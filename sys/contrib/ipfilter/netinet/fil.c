begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  *  * Copyright 2008 Sun Microsystems.  *  * $Id$  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
expr|\
operator|(
name|__FreeBSD_version
operator|>=
literal|220000
operator|)
end_if

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|==
literal|400019
operator|)
end_if

begin_define
define|#
directive|define
name|CSUM_DELAY_DATA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_AIX51
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_struct_decl
struct_decl|struct
name|file
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SOLARIS2
operator|<
literal|5
operator|)
operator|&&
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|_NET_ROUTE_INCLUDED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
name|defined
argument_list|(
name|IFF_DRVRLOCK
argument_list|)
end_if

begin_comment
comment|/* IRIX 6 */
end_comment

begin_include
include|#
directive|include
file|<sys/hashing.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AIX
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_undef
undef|#
directive|undef
name|_NET_ROUTE_INCLUDED
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__osf__
end_ifdef

begin_undef
undef|#
directive|undef
name|_RADIX_H_
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_if
if|#
directive|if
operator|!
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_proxy.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_auth.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_scan.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_sync.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_lookup.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_pool.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_htable.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_rules.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_BPF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ipl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|(
name|__NetBSD_Version__
operator|>=
literal|104230000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|callout
name|ipf_slowtimer_ch
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/timeout.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|timeout
name|ipf_slowtimer_ch
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END OF INCLUDES */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fil.c	1.36 6/5/96 (C) 1993-2000 Darren Reed"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static const char rcsid[] = "@(#)$Id: fil.c,v 2.243.2.125 2007/10/10 09:27:20 darrenr Exp $"; */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|"ipf.h"
end_include

begin_include
include|#
directive|include
file|"ipt.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|opts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|blockreason
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_define
define|#
directive|define
name|LBUMP
parameter_list|(
name|x
parameter_list|)
value|softc->x++
end_define

begin_define
define|#
directive|define
name|LBUMPD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do { softc->x.y++; DT(y); } while (0)
end_define

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_check_ipf
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|frentry_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_32_t
name|ipf_checkcipso
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_32_t
name|ipf_checkripso
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_32_t
name|ipf_decaps
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|u_32_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_decl_stmt
specifier|static
name|frentry_t
modifier|*
name|ipf_dolog
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|u_32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ipf_flushlist
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|int
operator|*
operator|,
name|frentry_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_flush_groups
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frgroup_t
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipfunc_t
name|ipf_findfunc
name|__P
argument_list|(
operator|(
name|ipfunc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|ipf_findlookup
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|int
operator|,
name|frentry_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|frentry_t
modifier|*
name|ipf_firewall
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|u_32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_fr_matcharray
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_frruleiter
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_funcfini
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frentry_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_funcinit
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frentry_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_geniter
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipftoken_t
operator|*
operator|,
name|ipfgeniter_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_getstat
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
expr|struct
name|friostat
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_group_flush
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frgroup_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_group_free
name|__P
argument_list|(
operator|(
name|frgroup_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_grpmapfini
name|__P
argument_list|(
operator|(
expr|struct
name|ipf_main_softc_s
operator|*
operator|,
name|frentry_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_grpmapinit
name|__P
argument_list|(
operator|(
expr|struct
name|ipf_main_softc_s
operator|*
operator|,
name|frentry_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|frentry_t
modifier|*
name|ipf_nextrule
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|frentry_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_portcheck
name|__P
argument_list|(
operator|(
name|frpcmp_t
operator|*
operator|,
name|u_32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_ah
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_esp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_gre
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_udp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_tcp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_icmp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_ipv4hdr
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_short
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_tcpcommon
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_udpcommon
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_rule_delete
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frentry_t
operator|*
name|f
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_rule_expire_insert
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frentry_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_synclist
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|frentry_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_token_flush
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_token_unlink
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipftoken_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
modifier|*
name|ipf_tune_findbyname
name|__P
argument_list|(
operator|(
name|ipftuneable_t
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
modifier|*
name|ipf_tune_findbycookie
name|__P
argument_list|(
operator|(
name|ipftuneable_t
operator|*
operator|*
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_updateipid
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_settimeout
name|__P
argument_list|(
operator|(
expr|struct
name|ipf_main_softc_s
operator|*
operator|,
expr|struct
name|ipftuneable
operator|*
operator|,
name|ipftuneval_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|)
operator|||
expr|\
name|FREEBSD_LT_REV
argument_list|(
literal|501000
argument_list|)
operator|||
name|NETBSD_LT_REV
argument_list|(
literal|105000000
argument_list|)
operator|||
expr|\
name|OPENBSD_LT_REV
argument_list|(
literal|200006
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|ppsratecheck
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * bit values for identifying presence of individual IP options  * All of these tables should be ordered by increasing key value on the left  * hand side to allow for binary searching of the array and include a trailer  * with a 0 for the bitmask for linear searches to easily find the end with.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|optlist
name|ipopts
index|[
literal|20
index|]
init|=
block|{
block|{
name|IPOPT_NOP
block|,
literal|0x000001
block|}
block|,
block|{
name|IPOPT_RR
block|,
literal|0x000002
block|}
block|,
block|{
name|IPOPT_ZSU
block|,
literal|0x000004
block|}
block|,
block|{
name|IPOPT_MTUP
block|,
literal|0x000008
block|}
block|,
block|{
name|IPOPT_MTUR
block|,
literal|0x000010
block|}
block|,
block|{
name|IPOPT_ENCODE
block|,
literal|0x000020
block|}
block|,
block|{
name|IPOPT_TS
block|,
literal|0x000040
block|}
block|,
block|{
name|IPOPT_TR
block|,
literal|0x000080
block|}
block|,
block|{
name|IPOPT_SECURITY
block|,
literal|0x000100
block|}
block|,
block|{
name|IPOPT_LSRR
block|,
literal|0x000200
block|}
block|,
block|{
name|IPOPT_E_SEC
block|,
literal|0x000400
block|}
block|,
block|{
name|IPOPT_CIPSO
block|,
literal|0x000800
block|}
block|,
block|{
name|IPOPT_SATID
block|,
literal|0x001000
block|}
block|,
block|{
name|IPOPT_SSRR
block|,
literal|0x002000
block|}
block|,
block|{
name|IPOPT_ADDEXT
block|,
literal|0x004000
block|}
block|,
block|{
name|IPOPT_VISA
block|,
literal|0x008000
block|}
block|,
block|{
name|IPOPT_IMITD
block|,
literal|0x010000
block|}
block|,
block|{
name|IPOPT_EIP
block|,
literal|0x020000
block|}
block|,
block|{
name|IPOPT_FINN
block|,
literal|0x040000
block|}
block|,
block|{
literal|0
block|,
literal|0x000000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|optlist
name|ip6exthdr
index|[]
init|=
block|{
block|{
name|IPPROTO_HOPOPTS
block|,
literal|0x000001
block|}
block|,
block|{
name|IPPROTO_IPV6
block|,
literal|0x000002
block|}
block|,
block|{
name|IPPROTO_ROUTING
block|,
literal|0x000004
block|}
block|,
block|{
name|IPPROTO_FRAGMENT
block|,
literal|0x000008
block|}
block|,
block|{
name|IPPROTO_ESP
block|,
literal|0x000010
block|}
block|,
block|{
name|IPPROTO_AH
block|,
literal|0x000020
block|}
block|,
block|{
name|IPPROTO_NONE
block|,
literal|0x000040
block|}
block|,
block|{
name|IPPROTO_DSTOPTS
block|,
literal|0x000080
block|}
block|,
block|{
name|IPPROTO_MOBILITY
block|,
literal|0x000100
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * bit values for identifying presence of individual IP security options  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|optlist
name|secopt
index|[
literal|8
index|]
init|=
block|{
block|{
name|IPSO_CLASS_RES4
block|,
literal|0x01
block|}
block|,
block|{
name|IPSO_CLASS_TOPS
block|,
literal|0x02
block|}
block|,
block|{
name|IPSO_CLASS_SECR
block|,
literal|0x04
block|}
block|,
block|{
name|IPSO_CLASS_RES3
block|,
literal|0x08
block|}
block|,
block|{
name|IPSO_CLASS_CONF
block|,
literal|0x10
block|}
block|,
block|{
name|IPSO_CLASS_UNCL
block|,
literal|0x20
block|}
block|,
block|{
name|IPSO_CLASS_RES2
block|,
literal|0x40
block|}
block|,
block|{
name|IPSO_CLASS_RES1
block|,
literal|0x80
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ipfilter_version
index|[]
init|=
name|IPL_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipf_features
init|=
literal|0
ifdef|#
directive|ifdef
name|IPFILTER_LKM
operator||
name|IPF_FEAT_LKM
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_LOG
operator||
name|IPF_FEAT_LOG
endif|#
directive|endif
operator||
name|IPF_FEAT_LOOKUP
ifdef|#
directive|ifdef
name|IPFILTER_BPF
operator||
name|IPF_FEAT_BPF
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
operator||
name|IPF_FEAT_COMPILED
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_CKSUM
operator||
name|IPF_FEAT_CKSUM
endif|#
directive|endif
operator||
name|IPF_FEAT_SYNC
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
operator||
name|IPF_FEAT_SCAN
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_INET6
operator||
name|IPF_FEAT_IPV6
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of functions available for use with call rules.  */
end_comment

begin_decl_stmt
specifier|static
name|ipfunc_resolve_t
name|ipf_availfuncs
index|[]
init|=
block|{
block|{
literal|"srcgrpmap"
block|,
name|ipf_srcgrpmap
block|,
name|ipf_grpmapinit
block|,
name|ipf_grpmapfini
block|}
block|,
block|{
literal|"dstgrpmap"
block|,
name|ipf_dstgrpmap
block|,
name|ipf_grpmapinit
block|,
name|ipf_grpmapfini
block|}
block|,
block|{
literal|""
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
name|ipf_main_tuneables
index|[]
init|=
block|{
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|struct ipf_main_softc_s
argument_list|,
argument|ipf_flags
argument_list|)
block|}
block|,
literal|"ipf_flags"
block|,
literal|0
block|,
literal|0xffffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_flags
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|struct ipf_main_softc_s
argument_list|,
argument|ipf_active
argument_list|)
block|}
block|,
literal|"active"
block|,
literal|0
block|,
literal|0
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_active
argument_list|)
block|,
name|IPFT_RDONLY
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_control_forwarding
argument_list|)
block|}
block|,
literal|"control_forwarding"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_control_forwarding
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_update_ipid
argument_list|)
block|}
block|,
literal|"update_ipid"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_update_ipid
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_chksrc
argument_list|)
block|}
block|,
literal|"chksrc"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_chksrc
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_minttl
argument_list|)
block|}
block|,
literal|"min_ttl"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_minttl
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_icmpminfragmtu
argument_list|)
block|}
block|,
literal|"icmp_minfragmtu"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_icmpminfragmtu
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_pass
argument_list|)
block|}
block|,
literal|"default_pass"
block|,
literal|0
block|,
literal|0xffffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_pass
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcpidletimeout
argument_list|)
block|}
block|,
literal|"tcp_idle_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcpidletimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcpclosewait
argument_list|)
block|}
block|,
literal|"tcp_close_wait"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcpclosewait
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcplastack
argument_list|)
block|}
block|,
literal|"tcp_last_ack"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcplastack
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcptimeout
argument_list|)
block|}
block|,
literal|"tcp_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcptimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcpsynsent
argument_list|)
block|}
block|,
literal|"tcp_syn_sent"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcpsynsent
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcpsynrecv
argument_list|)
block|}
block|,
literal|"tcp_syn_received"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcpsynrecv
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcpclosed
argument_list|)
block|}
block|,
literal|"tcp_closed"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcpclosed
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcphalfclosed
argument_list|)
block|}
block|,
literal|"tcp_half_closed"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcphalfclosed
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_tcptimewait
argument_list|)
block|}
block|,
literal|"tcp_time_wait"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_tcptimewait
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_udptimeout
argument_list|)
block|}
block|,
literal|"udp_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_udptimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_udpacktimeout
argument_list|)
block|}
block|,
literal|"udp_ack_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_udpacktimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_icmptimeout
argument_list|)
block|}
block|,
literal|"icmp_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_icmptimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_icmpacktimeout
argument_list|)
block|}
block|,
literal|"icmp_ack_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_icmpacktimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_iptimeout
argument_list|)
block|}
block|,
literal|"ip_timeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_iptimeout
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_settimeout
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|INSTANCES
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_main_softc_t
argument_list|,
argument|ipf_get_loopback
argument_list|)
block|}
block|,
literal|"intercept_loopback"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_main_softc_t
argument_list|,
name|ipf_get_loopback
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_set_loopback
block|}
block|,
endif|#
directive|endif
block|{
block|{
literal|0
block|}
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The next section of code is a a collection of small routines that set  * fields in the fr_info_t structure passed based on properties of the  * current packet.  There are different routines for the same protocol  * for each of IPv4 and IPv6.  Adding a new protocol, for which there  * will "special" inspection for setup, is now more easily done by adding  * a new routine and expanding the ipf_pr_ipinit*() function rather than by  * adding more code to a growing switch statement.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_ah6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_esp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_gre6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_udp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_tcp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_icmp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_ipv6hdr
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|ipf_pr_short6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_hopopts6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_mobility6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_routing6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_dstopts6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ipf_pr_fragment6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|INLINE
expr|struct
name|ip6_ext
operator|*
name|ipf_pr_ipv6exthdr
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_short6                                               */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I)  - pointer to packet information                     */
end_comment

begin_comment
comment|/*              xmin(I) - minimum header size                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function enforces the 'is a packet too short to be legit' rule   */
end_comment

begin_comment
comment|/* for IPv6 and marks the packet with FI_SHORT if so.  See function comment */
end_comment

begin_comment
comment|/* for ipf_pr_short() for more details.                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_short6
parameter_list|(
name|fin
parameter_list|,
name|xmin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|xmin
decl_stmt|;
block|{
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|<
name|xmin
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_ipv6hdr                                              */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Copy values from the IPv6 header into the fr_info_t struct and call the  */
end_comment

begin_comment
comment|/* per-protocol analyzer if it exists.  In validating the packet, a protocol*/
end_comment

begin_comment
comment|/* analyzer may pullup or free the packet itself so we need to be vigiliant */
end_comment

begin_comment
comment|/* of that possibility arising.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_ipv6hdr
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ip6_t
modifier|*
name|ip6
init|=
operator|(
name|ip6_t
operator|*
operator|)
name|fin
operator|->
name|fin_ip
decl_stmt|;
name|int
name|p
decl_stmt|,
name|go
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|hdrcount
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
init|=
operator|&
name|fin
operator|->
name|fin_fi
decl_stmt|;
name|fin
operator|->
name|fin_off
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_tos
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_optmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_secmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_auth
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|=
name|p
expr_stmt|;
name|fi
operator|->
name|fi_ttl
operator|=
name|ip6
operator|->
name|ip6_hlim
expr_stmt|;
name|fi
operator|->
name|fi_src
operator|.
name|in6
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|in6
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|fin
operator|->
name|fin_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fi
operator|->
name|fi_dst
operator|.
name|in6
argument_list|)
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MULTICAST
operator||
name|FI_MBCAST
expr_stmt|;
name|hdrcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|go
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
condition|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|ipf_pr_udp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|ipf_pr_tcp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMPV6
case|:
name|ipf_pr_icmp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
name|ipf_pr_gre6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
name|p
operator|=
name|ipf_pr_hopopts6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_MOBILITY
case|:
name|p
operator|=
name|ipf_pr_mobility6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_DSTOPTS
case|:
name|p
operator|=
name|ipf_pr_dstopts6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
name|p
operator|=
name|ipf_pr_routing6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|p
operator|=
name|ipf_pr_ah6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ESP
case|:
name|ipf_pr_esp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPV6
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_val
operator|==
name|p
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
expr_stmt|;
break|break;
block|}
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_NONE
case|:
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_FRAGMENT
case|:
name|p
operator|=
name|ipf_pr_fragment6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
comment|/* 			 * Given that the only fragments we want to let through 			 * (where fin_off != 0) are those where the non-first 			 * fragments only have data, we can safely stop looking 			 * at headers if this is a non-leading fragment. 			 */
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
name|go
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
name|go
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|hdrcount
operator|++
expr_stmt|;
comment|/* 		 * It is important to note that at this point, for the 		 * extension headers (go != 0), the entire header may not have 		 * been pulled up when the code gets to this point.  This is 		 * only done for "go != 0" because the other header handlers 		 * will all pullup their complete header.  The other indicator 		 * of an incomplete packet is that this was just an extension 		 * header. 		 */
if|if
condition|(
operator|(
name|go
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|p
operator|!=
name|IPPROTO_NONE
operator|)
operator|&&
operator|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|p
operator|=
name|IPPROTO_NONE
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Some of the above functions, like ipf_pr_esp6(), can call ipf_pullup 	 * and destroy whatever packet was here.  The caller of this function 	 * expects us to return if there is a problem with ipf_pullup. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_m
operator|==
name|NULL
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_bad
argument_list|)
expr_stmt|;
return|return;
block|}
name|fi
operator|->
name|fi_p
operator|=
name|p
expr_stmt|;
comment|/* 	 * IPv6 fragment case 1 - see comment for ipf_pr_fragment6(). 	 * "go != 0" imples the above loop hasn't arrived at a layer 4 header. 	 */
if|if
condition|(
operator|(
name|go
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
operator|)
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_ipv6_frag_1
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|int
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_badfrag
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_v6_bad
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_ipv6exthdr                                           */
end_comment

begin_comment
comment|/* Returns:     struct ip6_ext * - pointer to the start of the next header  */
end_comment

begin_comment
comment|/*                                 or NULL if there is a prolblem.          */
end_comment

begin_comment
comment|/* Parameters:  fin(I)      - pointer to packet information                 */
end_comment

begin_comment
comment|/*              multiple(I) - flag indicating yes/no if multiple occurances */
end_comment

begin_comment
comment|/*                            of this extension header are allowed.         */
end_comment

begin_comment
comment|/*              proto(I)    - protocol number for this extension header     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This function embodies a number of common checks that all IPv6 extension */
end_comment

begin_comment
comment|/* headers must be subjected to.  For example, making sure the packet is    */
end_comment

begin_comment
comment|/* big enough for it to be in, checking if it is repeated and setting a     */
end_comment

begin_comment
comment|/* flag to indicate its presence.                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_expr_stmt
specifier|static
name|INLINE
expr|struct
name|ip6_ext
operator|*
name|ipf_pr_ipv6exthdr
argument_list|(
argument|fin
argument_list|,
argument|multiple
argument_list|,
argument|proto
argument_list|)
name|fr_info_t
operator|*
name|fin
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|multiple
decl_stmt|,
name|proto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|struct
name|ip6_ext
modifier|*
name|hdr
decl_stmt|;
name|u_short
name|shift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_V6EXTHDR
expr_stmt|;
comment|/* 8 is default length of extension hdr */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_dlen
operator|-
literal|8
operator|)
operator|<
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_ext_short
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_ext_pullup
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hdr
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
name|shift
operator|=
literal|8
expr_stmt|;
break|break;
default|default :
name|shift
operator|=
literal|8
operator|+
operator|(
name|hdr
operator|->
name|ip6e_len
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|shift
operator|>
name|fin
operator|->
name|fin_dlen
condition|)
block|{
comment|/* Nasty extension header length? */
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT3
argument_list|(
name|ipf_fi_bad_pr_ipv6exthdr_len
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_short
argument_list|,
name|shift
argument_list|,
name|u_short
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_ext_hlen
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|+
name|shift
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|-=
name|shift
expr_stmt|;
comment|/* 	 * If we have seen a fragment header, do not set any flags to indicate 	 * the presence of this extension header as it has no impact on the 	 * end result until after it has been defragmented. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
condition|)
return|return
name|hdr
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_val
operator|==
name|proto
condition|)
block|{
comment|/* 			 * Most IPv6 extension headers are only allowed once. 			 */
if|if
condition|(
operator|(
name|multiple
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fin
operator|->
name|fin_optmsk
operator|&
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_ipv6exthdr_once
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
name|fin
operator|->
name|fin_optmsk
operator|&
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fin
operator|->
name|fin_optmsk
operator||=
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
expr_stmt|;
break|break;
block|}
return|return
name|hdr
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_hopopts6                                             */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks pending hop by hop options extension header      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_hopopts6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|struct
name|ip6_ext
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|ipf_pr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_HOPOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
name|IPPROTO_NONE
return|;
return|return
name|hdr
operator|->
name|ip6e_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_mobility6                                            */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks the IPv6 mobility extension header               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_mobility6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|struct
name|ip6_ext
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|ipf_pr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_MOBILITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
name|IPPROTO_NONE
return|;
return|return
name|hdr
operator|->
name|ip6e_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_routing6                                             */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks pending routing extension header                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_routing6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|struct
name|ip6_routing
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|ip6_routing
operator|*
operator|)
name|ipf_pr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_ROUTING
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
return|return
name|IPPROTO_NONE
return|;
switch|switch
condition|(
name|hdr
operator|->
name|ip6r_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Nasty extension header length? 		 */
if|if
condition|(
operator|(
operator|(
name|hdr
operator|->
name|ip6r_len
operator|>>
literal|1
operator|)
operator|<
name|hdr
operator|->
name|ip6r_segleft
operator|)
operator|||
operator|(
name|hdr
operator|->
name|ip6r_segleft
operator|&&
operator|(
name|hdr
operator|->
name|ip6r_len
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_routing6
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_rh_bad
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
break|break;
default|default :
break|break;
block|}
return|return
name|hdr
operator|->
name|ip6r_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_fragment6                                            */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Examine the IPv6 fragment header and extract fragment offset information.*/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Fragments in IPv6 are extraordinarily difficult to deal with - much more */
end_comment

begin_comment
comment|/* so than in IPv4.  There are 5 cases of fragments with IPv6 that all      */
end_comment

begin_comment
comment|/* packets with a fragment header can fit into.  They are as follows:       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* 1.  [IPv6][0-n EH][FH][0-n EH] (no L4HDR present)                        */
end_comment

begin_comment
comment|/* 2.  [IPV6][0-n EH][FH][0-n EH][L4HDR part] (short)                       */
end_comment

begin_comment
comment|/* 3.  [IPV6][0-n EH][FH][L4HDR part][0-n data] (short)                     */
end_comment

begin_comment
comment|/* 4.  [IPV6][0-n EH][FH][0-n EH][L4HDR][0-n data]                          */
end_comment

begin_comment
comment|/* 5.  [IPV6][0-n EH][FH][data]                                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPV6 = IPv6 header, FH = Fragment Header,                                */
end_comment

begin_comment
comment|/* 0-n EH = 0 or more extension headers, 0-n data = 0 or more bytes of data */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Packets that match 1, 2, 3 will be dropped as the only reasonable        */
end_comment

begin_comment
comment|/* scenario in which they happen is in extreme circumstances that are most  */
end_comment

begin_comment
comment|/* likely to be an indication of an attack rather than normal traffic.      */
end_comment

begin_comment
comment|/* A type 3 packet may be sent by an attacked after a type 4 packet.  There */
end_comment

begin_comment
comment|/* are two rules that can be used to guard against type 3 packets: L4       */
end_comment

begin_comment
comment|/* headers must always be in a packet that has the offset field set to 0    */
end_comment

begin_comment
comment|/* and no packet is allowed to overlay that where offset = 0.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_fragment6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|struct
name|ip6_frag
modifier|*
name|frag
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_FRAG
expr_stmt|;
name|frag
operator|=
operator|(
expr|struct
name|ip6_frag
operator|*
operator|)
name|ipf_pr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_FRAGMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_frag_bad
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
if|if
condition|(
operator|(
name|frag
operator|->
name|ip6f_offlg
operator|&
name|IP6F_MORE_FRAG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Any fragment that isn't the last fragment must have its 		 * length as a multiple of 8. 		 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_plen
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_frag_not_8
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
name|fin
operator|->
name|fin_plen
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fin
operator|->
name|fin_fraghdr
operator|=
name|frag
expr_stmt|;
name|fin
operator|->
name|fin_id
operator|=
name|frag
operator|->
name|ip6f_ident
expr_stmt|;
name|fin
operator|->
name|fin_off
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|ip6f_offlg
operator|&
name|IP6F_OFF_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_FRAGBODY
expr_stmt|;
comment|/* 	 * Jumbograms aren't handled, so the max. length is 64k 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_off
operator|<<
literal|3
operator|)
operator|+
name|fin
operator|->
name|fin_dlen
operator|>
literal|65535
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_jumbogram
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
operator|(
name|fin
operator|->
name|fin_off
operator|<<
literal|3
operator|)
operator|+
name|fin
operator|->
name|fin_dlen
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We don't know where the transport layer header (or whatever is next 	 * is), as it could be behind destination options (amongst others) so 	 * return the fragment header as the type of packet this is.  Note that 	 * this effectively disables the fragment cache for> 1 protocol at a 	 * time. 	 */
return|return
name|frag
operator|->
name|ip6f_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_dstopts6                                             */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks pending destination options extension header     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_dstopts6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|struct
name|ip6_ext
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|ipf_pr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_DSTOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_dst_bad
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
return|return
name|hdr
operator|->
name|ip6e_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_icmp6                                                */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This routine is mainly concerned with determining the minimum valid size */
end_comment

begin_comment
comment|/* for an ICMPv6 packet.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_icmp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|int
name|minicmpsz
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
decl_stmt|;
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
name|ICMP6ERR_MINPKTLEN
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_icmp6_pullup
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|1
condition|)
block|{
name|ip6_t
modifier|*
name|ip6
decl_stmt|;
name|icmp6
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|icmp6
expr_stmt|;
if|if
condition|(
operator|(
name|icmp6
operator|->
name|icmp6_type
operator|&
name|ICMP6_INFOMSG_MASK
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPQUERY
expr_stmt|;
switch|switch
condition|(
name|icmp6
operator|->
name|icmp6_type
condition|)
block|{
case|case
name|ICMP6_ECHO_REPLY
case|:
case|case
name|ICMP6_ECHO_REQUEST
case|:
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>=
literal|6
condition|)
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
operator|=
name|icmp6
operator|->
name|icmp6_id
expr_stmt|;
name|minicmpsz
operator|=
name|ICMP6ERR_MINPKTLEN
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH
case|:
case|case
name|ICMP6_PACKET_TOO_BIG
case|:
case|case
name|ICMP6_TIME_EXCEEDED
case|:
case|case
name|ICMP6_PARAM_PROB
case|:
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPERR
expr_stmt|;
name|minicmpsz
operator|=
name|ICMP6ERR_IPICMPHLEN
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMP6ERR_IPICMPHLEN
condition|)
break|break;
if|if
condition|(
name|M_LEN
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|)
operator|<
name|fin
operator|->
name|fin_plen
condition|)
block|{
if|if
condition|(
name|ipf_coalesce
argument_list|(
name|fin
argument_list|)
operator|!=
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
name|ICMP6ERR_MINPKTLEN
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* 			 * If the destination of this packet doesn't match the 			 * source of the original packet then this packet is 			 * not correct. 			 */
name|icmp6
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|icmp6
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
if|if
condition|(
name|IP6_NEQ
argument_list|(
operator|&
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
argument_list|,
operator|(
name|i6addr_t
operator|*
operator|)
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_icmp6
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
break|break;
block|}
block|}
name|ipf_pr_short6
argument_list|(
name|fin
argument_list|,
name|minicmpsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_SHORT
operator||
name|FI_BAD
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|u_char
name|p
init|=
name|fin
operator|->
name|fin_p
decl_stmt|;
name|fin
operator|->
name|fin_p
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|ipf_checkv6sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_p
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_udp6                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv6/UDP properties.                              */
end_comment

begin_comment
comment|/* Is not expected to be called for fragmented packets.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_udp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
name|ipf_pr_udpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_char
name|p
init|=
name|fin
operator|->
name|fin_p
decl_stmt|;
name|fin
operator|->
name|fin_p
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|ipf_checkv6sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_p
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_tcp6                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv6/TCP properties.                              */
end_comment

begin_comment
comment|/* Is not expected to be called for fragmented packets.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_tcp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
name|ipf_pr_tcpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_char
name|p
init|=
name|fin
operator|->
name|fin_p
decl_stmt|;
name|fin
operator|->
name|fin_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|ipf_checkv6sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_p
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_esp6                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for ESP properties.                                   */
end_comment

begin_comment
comment|/* The minimum length is taken to be the SPI (32bits) plus a tail (32bits)  */
end_comment

begin_comment
comment|/* even though the newer ESP packets must also have a sequence number that  */
end_comment

begin_comment
comment|/* is 32bits as well, it is not possible(?) to determine the version from a */
end_comment

begin_comment
comment|/* simple packet header.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_esp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_esp_pullup
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_ah6                                                  */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for AH properties.                                    */
end_comment

begin_comment
comment|/* The minimum length is taken to be the combination of all fields in the   */
end_comment

begin_comment
comment|/* header being present and no authentication data (null algorithm used.)   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_ah6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|authhdr_t
modifier|*
name|ah
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_AH
expr_stmt|;
name|ah
operator|=
operator|(
name|authhdr_t
operator|*
operator|)
name|ipf_pr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_HOPOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_ah_bad
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
name|ipf_pr_short6
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * No need for another pullup, ipf_pr_ipv6exthdr() will pullup 	 * enough data to satisfy ah_next (the very first one.) 	 */
return|return
name|ah
operator|->
name|ah_next
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_gre6                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for GRE properties.                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_gre6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|grehdr_t
modifier|*
name|gre
decl_stmt|;
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v6_gre_pullup
argument_list|)
expr_stmt|;
return|return;
block|}
name|gre
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|GRE_REV
argument_list|(
name|gre
operator|->
name|gr_flags
argument_list|)
operator|==
literal|1
condition|)
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
name|gre
operator|->
name|gr_call
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_INET6 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_pullup                                               */
end_comment

begin_comment
comment|/* Returns:     int     - 0 == pullup succeeded, -1 == failure              */
end_comment

begin_comment
comment|/* Parameters:  fin(I)  - pointer to packet information                     */
end_comment

begin_comment
comment|/*              plen(I) - length (excluding L3 header) to pullup            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Short inline function to cut down on code duplication to perform a call  */
end_comment

begin_comment
comment|/* to ipf_pullup to ensure there is the required amount of data,            */
end_comment

begin_comment
comment|/* consecutively in the packet buffer.                                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function pulls up 'extra' data at the location of fin_dp.  fin_dp   */
end_comment

begin_comment
comment|/* points to the first byte after the complete layer 3 header, which will   */
end_comment

begin_comment
comment|/* include all of the known extension headers for IPv6 or options for IPv4. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Since fr_pullup() expects the total length of bytes to be pulled up, it  */
end_comment

begin_comment
comment|/* is necessary to add those we can already assume to be pulled up (fin_dp  */
end_comment

begin_comment
comment|/* - fin_ip) to what is passed through.                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_pr_pullup
parameter_list|(
name|fin
parameter_list|,
name|plen
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|plen
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_dp
operator|!=
name|NULL
condition|)
name|plen
operator|+=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|fin
operator|->
name|fin_hlen
operator|)
expr_stmt|;
name|plen
operator|+=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
if|if
condition|(
name|M_LEN
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|)
operator|<
name|plen
operator|+
name|fin
operator|->
name|fin_ipoff
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|ipf_pullup
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
argument_list|,
name|plen
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DT
argument_list|(
name|ipf_pullup_fail
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_pull
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_pull
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_pull
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * Fake ipf_pullup failing 			 */
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_PULLUP
expr_stmt|;
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_ip
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_short                                                */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I)  - pointer to packet information                     */
end_comment

begin_comment
comment|/*              xmin(I) - minimum header size                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check if a packet is "short" as defined by xmin.  The rule we are        */
end_comment

begin_comment
comment|/* applying here is that the packet must not be fragmented within the layer */
end_comment

begin_comment
comment|/* 4 header.  That is, it must not be a fragment that has its offset set to */
end_comment

begin_comment
comment|/* start within the layer 4 header (hdrmin) or if it is at offset 0, the    */
end_comment

begin_comment
comment|/* entire layer 4 header must be present (min).                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_short
parameter_list|(
name|fin
parameter_list|,
name|xmin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|xmin
decl_stmt|;
block|{
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|<
name|xmin
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|<
name|xmin
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_icmp                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Do a sanity check on the packet for ICMP (v4).  In nearly all cases,     */
end_comment

begin_comment
comment|/* except extrememly bad packets, both type and code will be present.       */
end_comment

begin_comment
comment|/* The expected minimum size of an ICMP packet is very much dependent on    */
end_comment

begin_comment
comment|/* the type of it.                                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* XXX - other ICMP sanity checks?                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_icmp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|int
name|minicmpsz
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
decl_stmt|;
name|icmphdr_t
modifier|*
name|icmp
decl_stmt|;
name|ip_t
modifier|*
name|oip
decl_stmt|;
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
name|ICMPERR_ICMPHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_icmp_frag
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
name|ICMPERR_ICMPHLEN
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_icmp_pullup
argument_list|)
expr_stmt|;
return|return;
block|}
name|icmp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|icmp
expr_stmt|;
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
operator|=
name|icmp
operator|->
name|icmp_id
expr_stmt|;
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHOREPLY
case|:
case|case
name|ICMP_ECHO
case|:
comment|/* Router discovery messaes - RFC 1256 */
case|case
name|ICMP_ROUTERADVERT
case|:
case|case
name|ICMP_ROUTERSOLICIT
case|:
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPQUERY
expr_stmt|;
name|minicmpsz
operator|=
name|ICMP_MINLEN
expr_stmt|;
break|break;
comment|/* 	 * type(1) + code(1) + cksum(2) + id(2) seq(2) + 	 * 3 * timestamp(3 * 4) 	 */
case|case
name|ICMP_TSTAMP
case|:
case|case
name|ICMP_TSTAMPREPLY
case|:
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPQUERY
expr_stmt|;
name|minicmpsz
operator|=
literal|20
expr_stmt|;
break|break;
comment|/* 	 * type(1) + code(1) + cksum(2) + id(2) seq(2) + 	 * mask(4) 	 */
case|case
name|ICMP_IREQ
case|:
case|case
name|ICMP_IREQREPLY
case|:
case|case
name|ICMP_MASKREQ
case|:
case|case
name|ICMP_MASKREPLY
case|:
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPQUERY
expr_stmt|;
name|minicmpsz
operator|=
literal|12
expr_stmt|;
break|break;
comment|/* 	 * type(1) + code(1) + cksum(2) + id(2) seq(2) + ip(20+) 	 */
case|case
name|ICMP_UNREACH
case|:
ifdef|#
directive|ifdef
name|icmp_nextmtu
if|if
condition|(
name|icmp
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_NEEDFRAG
condition|)
block|{
if|if
condition|(
name|icmp
operator|->
name|icmp_nextmtu
operator|<
name|softc
operator|->
name|ipf_icmpminfragmtu
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT3
argument_list|(
name|ipf_fi_bad_icmp_nextmtu
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
name|icmp
operator|->
name|icmp_nextmtu
argument_list|,
name|u_int
argument_list|,
name|softc
operator|->
name|ipf_icmpminfragmtu
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_REDIRECT
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPERR
expr_stmt|;
if|if
condition|(
name|ipf_coalesce
argument_list|(
name|fin
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_icmp_coalesce
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * ICMP error packets should not be generated for IP 		 * packets that are a fragment that isn't the first 		 * fragment. 		 */
name|oip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|oip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_icmp_err
argument_list|,
name|fr_info_t
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
name|ntohs
argument_list|(
name|oip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the destination of this packet doesn't match the 		 * source of the original packet then this packet is 		 * not correct. 		 */
if|if
condition|(
name|oip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|fin
operator|->
name|fin_daddr
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_src_ne_dst
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
break|break;
block|}
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
name|minicmpsz
argument_list|)
expr_stmt|;
name|ipf_checkv4sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_tcpcommon                                            */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = header ok, 1 = bad packet, -1 = buffer error   */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* TCP header sanity checking.  Look for bad combinations of TCP flags,     */
end_comment

begin_comment
comment|/* and make some checks with how they interact with other fields.           */
end_comment

begin_comment
comment|/* If compiled with IPFILTER_CKSUM, check to see if the TCP checksum is     */
end_comment

begin_comment
comment|/* valid and mark the packet as bad if not.                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_tcpcommon
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|tlen
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_TCPUDP
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_tcp_frag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_tcp_pullup
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|3
condition|)
block|{
name|fin
operator|->
name|fin_sport
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_sport
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dport
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_dport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
operator|!=
literal|0
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_tcp_short
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Use of the TCP data offset *must* result in a value that is at 	 * least the same size as the TCP header. 	 */
name|tlen
operator|=
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_tcp_small
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT3
argument_list|(
name|ipf_fi_bad_tlen
argument_list|,
name|fr_info_t
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
name|tlen
argument_list|,
name|u_int
argument_list|,
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|flags
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
name|fin
operator|->
name|fin_tcpf
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
comment|/* 	 * If the urgent flag is set, then the urgent pointer must 	 * also be set and vice versa.  Good TCP packets do not have 	 * just one of these set. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|TH_URG
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tcp
operator|->
name|th_urp
operator|==
literal|0
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT3
argument_list|(
name|ipf_fi_bad_th_urg
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
name|flags
operator|&
name|TH_URG
operator|)
argument_list|,
name|u_int
argument_list|,
name|tcp
operator|->
name|th_urp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|} else if ((flags& TH_URG) == 0&& (tcp->th_urp != 0)) {
comment|/* 		 * Ignore this case (#if 0) as it shows up in "real" 		 * traffic with bogus values in the urgent pointer field. 		 */
block|fin->fin_flx |= FI_BAD; 		DT3(ipf_fi_bad_th_urg0, fr_info_t *, fin, u_int, (flags& TH_URG), u_int, tcp->th_urp);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_RST
operator|)
condition|)
block|{
comment|/* TH_FIN|TH_RST|TH_ACK seems to appear "naturally" */
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_th_fin_rst_ack
argument_list|,
name|fr_info_t
argument_list|,
name|fin
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|TH_SYN
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_PUSH
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * SYN with URG and PUSH set is not for normal TCP but it is 		 * possible(?) with T/TCP...but who uses T/TCP? 		 */
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_th_syn_urg_psh
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TH_ACK
operator|)
condition|)
block|{
comment|/* 		 * If the ack bit isn't set, then either the SYN or 		 * RST bit must be set.  If the SYN bit is set, then 		 * we expect the ACK field to be 0.  If the ACK is 		 * not set and if URG, PSH or FIN are set, consdier 		 * that to indicate a bad TCP packet. 		 */
if|if
condition|(
operator|(
name|flags
operator|==
name|TH_SYN
operator|)
operator|&&
operator|(
name|tcp
operator|->
name|th_ack
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Cisco PIX sets the ACK field to a random value. 			 * In light of this, do not set FI_BAD until a patch 			 * is available from Cisco to ensure that 			 * interoperability between existing systems is 			 * achieved. 			 */
comment|/*fin->fin_flx |= FI_BAD*/
empty_stmt|;
comment|/*DT1(ipf_fi_bad_th_syn_ack, fr_info_t *, fin);*/
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|TH_RST
operator||
name|TH_SYN
operator|)
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_th_rst_syn
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_PUSH
operator||
name|TH_FIN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_th_urg_push_fin
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_BAD
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_tcp_bad_flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * At this point, it's not exactly clear what is to be gained by 	 * marking up which TCP options are and are not present.  The one we 	 * are most interested in is the TCP window scale.  This is only in 	 * a SYN packet [RFC1323] so we don't need this here...? 	 * Now if we were to analyse the header for passive fingerprinting, 	 * then that might add some weight to adding this... 	 */
if|if
condition|(
name|tlen
operator|==
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
name|tlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_tcp_pullup
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
literal|0
block|tcp = fin->fin_dp; 	ip = fin->fin_ip; 	s = (u_char *)(tcp + 1); 	off = IP_HL(ip)<< 2;
ifdef|#
directive|ifdef
name|_KERNEL
block|if (fin->fin_mp != NULL) { 		mb_t *m = *fin->fin_mp;  		if (off + tlen> M_LEN(m)) 			return; 	}
endif|#
directive|endif
block|for (tlen -= (int)sizeof(*tcp); tlen> 0; ) { 		opt = *s; 		if (opt == '\0') 			break; 		else if (opt == TCPOPT_NOP) 			ol = 1; 		else { 			if (tlen< 2) 				break; 			ol = (int)*(s + 1); 			if (ol< 2 || ol> tlen) 				break; 		}  		for (i = 9, mv = 4; mv>= 0; ) { 			op = ipopts + i; 			if (opt == (u_char)op->ol_val) { 				optmsk |= op->ol_bit; 				break; 			} 		} 		tlen -= ol; 		s += ol; 	}
endif|#
directive|endif
comment|/* 0 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_udpcommon                                            */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = header ok, 1 = bad packet                      */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Extract the UDP source and destination ports, if present.  If compiled   */
end_comment

begin_comment
comment|/* with IPFILTER_CKSUM, check to see if the UDP checksum is valid.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_udpcommon
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|udphdr_t
modifier|*
name|udp
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_TCPUDP
expr_stmt|;
if|if
condition|(
operator|!
name|fin
operator|->
name|fin_off
operator|&&
operator|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udp
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_udp_pullup
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|udp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|fin
operator|->
name|fin_sport
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dport
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_tcp                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv4/TCP properties.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_tcp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_pr_tcpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
name|ipf_checkv4sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_udp                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv4/UDP properties.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_udp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_pr_udpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
name|ipf_checkv4sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_esp                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for ESP properties.                                   */
end_comment

begin_comment
comment|/* The minimum length is taken to be the SPI (32bits) plus a tail (32bits)  */
end_comment

begin_comment
comment|/* even though the newer ESP packets must also have a sequence number that  */
end_comment

begin_comment
comment|/* is 32bits as well, it is not possible(?) to determine the version from a */
end_comment

begin_comment
comment|/* simple packet header.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_esp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_esp_pullup
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_ah                                                   */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for AH properties.                                    */
end_comment

begin_comment
comment|/* The minimum length is taken to be the combination of all fields in the   */
end_comment

begin_comment
comment|/* header being present and no authentication data (null algorithm used.)   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_pr_ah
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|authhdr_t
modifier|*
name|ah
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_AH
expr_stmt|;
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
operator|)
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_ah_bad
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|DT
argument_list|(
name|fr_v4_ah_pullup_1
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_v4_ah_pullup
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
name|ah
operator|=
operator|(
name|authhdr_t
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|len
operator|=
operator|(
name|ah
operator|->
name|ah_plen
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|DT
argument_list|(
name|fr_v4_ah_pullup_2
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_v4_ah_pullup
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
comment|/* 	 * Adjust fin_dp and fin_dlen for skipping over the authentication 	 * header. 	 */
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|+
name|len
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|-=
name|len
expr_stmt|;
return|return
name|ah
operator|->
name|ah_next
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_gre                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for GRE properties.                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_gre
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|grehdr_t
modifier|*
name|gre
decl_stmt|;
name|ipf_pr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_gre_frag
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ipf_pr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_gre_pullup
argument_list|)
expr_stmt|;
return|return;
block|}
name|gre
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|GRE_REV
argument_list|(
name|gre
operator|->
name|gr_flags
argument_list|)
operator|==
literal|1
condition|)
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
name|gre
operator|->
name|gr_call
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_pr_ipv4hdr                                              */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Analyze the IPv4 header and set fields in the fr_info_t structure.       */
end_comment

begin_comment
comment|/* Check all options present and flag their presence if any exist.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|ipf_pr_ipv4hdr
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|u_short
name|optmsk
init|=
literal|0
decl_stmt|,
name|secmsk
init|=
literal|0
decl_stmt|,
name|auth
init|=
literal|0
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|ol
decl_stmt|,
name|mv
decl_stmt|,
name|p
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|struct
name|optlist
modifier|*
name|op
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|,
name|opt
decl_stmt|;
name|u_short
name|off
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|fi
operator|=
operator|&
name|fin
operator|->
name|fin_fi
expr_stmt|;
name|hlen
operator|=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fi
operator|->
name|fi_p
operator|=
name|p
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|=
name|p
expr_stmt|;
name|fi
operator|->
name|fi_tos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|fin
operator|->
name|fin_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* Get both TTL and protocol */
name|fi
operator|->
name|fi_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fi
operator|->
name|fi_ttl
operator|=
name|ip
operator|->
name|ip_ttl
expr_stmt|;
comment|/* Zero out bits not used in IPv6 address */
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_saddr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_saddr
expr_stmt|;
name|fi
operator|->
name|fi_daddr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|fin
operator|->
name|fin_crc
operator|+=
name|fi
operator|->
name|fi_daddr
expr_stmt|;
if|if
condition|(
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
name|fi
operator|->
name|fi_daddr
argument_list|)
argument_list|)
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MULTICAST
operator||
name|FI_MBCAST
expr_stmt|;
comment|/* 	 * set packet attribute flags based on the offset and 	 * calculate the byte offset that it represents. 	 */
name|off
operator|&=
name|IP_MF
operator||
name|IP_OFFMASK
expr_stmt|;
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
block|{
name|int
name|morefrag
init|=
name|off
operator|&
name|IP_MF
decl_stmt|;
name|fi
operator|->
name|fi_flx
operator||=
name|FI_FRAG
expr_stmt|;
name|off
operator|&=
name|IP_OFFMASK
expr_stmt|;
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_FRAGBODY
expr_stmt|;
name|off
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
name|fin
operator|->
name|fin_dlen
operator|>
literal|65535
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_dlen
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|morefrag
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fin
operator|->
name|fin_dlen
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 				 * The length of the packet, starting at its 				 * offset cannot exceed 65535 (0xffff) as the 				 * length of an IP packet is only 16 bits. 				 * 				 * Any fragment that isn't the last fragment 				 * must have a length greater than 0 and it 				 * must be an even multiple of 8. 				 */
name|fi
operator|->
name|fi_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_fragbody_gt_65535
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fin
operator|->
name|fin_off
operator|=
name|off
expr_stmt|;
comment|/* 	 * Call per-protocol setup and checking 	 */
if|if
condition|(
name|p
operator|==
name|IPPROTO_AH
condition|)
block|{
comment|/* 		 * Treat AH differently because we expect there to be another 		 * layer 4 header after it. 		 */
name|p
operator|=
name|ipf_pr_ah
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|ipf_pr_udp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|ipf_pr_tcp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|ipf_pr_icmp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ESP
case|:
name|ipf_pr_esp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
name|ipf_pr_gre
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If it is a standard IP header (no options), set the flag fields 	 * which relate to options to 0. 	 */
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
block|{
name|fi
operator|->
name|fi_optmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_secmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_auth
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * So the IP header has some IP options attached.  Walk the entire 	 * list of options present with this packet and set flags to indicate 	 * which ones are here and which ones are not.  For the somewhat out 	 * of date and obscure security classification options, set a flag to 	 * represent which classification is present. 	 */
name|fi
operator|->
name|fi_flx
operator||=
name|FI_OPTIONS
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
operator|,
name|hlen
operator|-=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
init|;
name|hlen
operator|>
literal|0
condition|;
control|)
block|{
name|opt
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
name|opt
operator|==
name|IPOPT_NOP
condition|)
name|ol
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hlen
operator|<
literal|2
condition|)
break|break;
name|ol
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ol
operator|<
literal|2
operator|||
name|ol
operator|>
name|hlen
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
operator|,
name|mv
operator|=
literal|4
init|;
name|mv
operator|>=
literal|0
condition|;
control|)
block|{
name|op
operator|=
name|ipopts
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|==
operator|(
name|u_char
operator|)
name|op
operator|->
name|ol_val
operator|)
operator|&&
operator|(
name|ol
operator|>
literal|4
operator|)
condition|)
block|{
name|u_32_t
name|doi
decl_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|IPOPT_SECURITY
case|:
if|if
condition|(
name|optmsk
operator|&
name|op
operator|->
name|ol_bit
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_ipopt_security
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_short
argument_list|,
operator|(
name|optmsk
operator|&
name|op
operator|->
name|ol_bit
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doi
operator|=
name|ipf_checkripso
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|secmsk
operator|=
name|doi
operator|>>
literal|16
expr_stmt|;
name|auth
operator|=
name|doi
operator|&
literal|0xffff
expr_stmt|;
block|}
break|break;
case|case
name|IPOPT_CIPSO
case|:
if|if
condition|(
name|optmsk
operator|&
name|op
operator|->
name|ol_bit
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_ipopt_cipso
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_short
argument_list|,
operator|(
name|optmsk
operator|&
name|op
operator|->
name|ol_bit
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doi
operator|=
name|ipf_checkcipso
argument_list|(
name|fin
argument_list|,
name|s
argument_list|,
name|ol
argument_list|)
expr_stmt|;
name|secmsk
operator|=
name|doi
operator|>>
literal|16
expr_stmt|;
name|auth
operator|=
name|doi
operator|&
literal|0xffff
expr_stmt|;
block|}
break|break;
block|}
name|optmsk
operator||=
name|op
operator|->
name|ol_bit
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|<
name|op
operator|->
name|ol_val
condition|)
name|i
operator|-=
name|mv
expr_stmt|;
else|else
name|i
operator|+=
name|mv
expr_stmt|;
name|mv
operator|--
expr_stmt|;
block|}
name|hlen
operator|-=
name|ol
expr_stmt|;
name|s
operator|+=
name|ol
expr_stmt|;
block|}
comment|/* 	 * 	 */
if|if
condition|(
name|auth
operator|&&
operator|!
operator|(
name|auth
operator|&
literal|0x0100
operator|)
condition|)
name|auth
operator|&=
literal|0xff00
expr_stmt|;
name|fi
operator|->
name|fi_optmsk
operator|=
name|optmsk
expr_stmt|;
name|fi
operator|->
name|fi_secmsk
operator|=
name|secmsk
expr_stmt|;
name|fi
operator|->
name|fi_auth
operator|=
name|auth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_checkripso                                              */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  s(I)   - pointer to start of RIPSO option                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|u_32_t
name|ipf_checkripso
parameter_list|(
name|s
parameter_list|)
name|u_char
modifier|*
name|s
decl_stmt|;
block|{
specifier|const
name|struct
name|optlist
modifier|*
name|sp
decl_stmt|;
name|u_short
name|secmsk
init|=
literal|0
decl_stmt|,
name|auth
init|=
literal|0
decl_stmt|;
name|u_char
name|sec
decl_stmt|;
name|int
name|j
decl_stmt|,
name|m
decl_stmt|;
name|sec
operator|=
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* classification */
for|for
control|(
name|j
operator|=
literal|3
operator|,
name|m
operator|=
literal|2
init|;
name|m
operator|>=
literal|0
condition|;
control|)
block|{
name|sp
operator|=
name|secopt
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sp
operator|->
name|ol_val
condition|)
block|{
name|secmsk
operator||=
name|sp
operator|->
name|ol_bit
expr_stmt|;
name|auth
operator|=
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
expr_stmt|;
name|auth
operator|*=
literal|256
expr_stmt|;
name|auth
operator|+=
operator|*
operator|(
name|s
operator|+
literal|4
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sec
operator|<
name|sp
operator|->
name|ol_val
condition|)
name|j
operator|-=
name|m
expr_stmt|;
else|else
name|j
operator|+=
name|m
expr_stmt|;
name|m
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|secmsk
operator|<<
literal|16
operator|)
operator||
name|auth
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_checkcipso                                              */
end_comment

begin_comment
comment|/* Returns:     u_32_t  - 0 = failure, else the doi from the header         */
end_comment

begin_comment
comment|/* Parameters:  fin(IO) - pointer to packet information                     */
end_comment

begin_comment
comment|/*              s(I)    - pointer to start of CIPSO option                  */
end_comment

begin_comment
comment|/*              ol(I)   - length of CIPSO option field                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function returns the domain of integrity (DOI) field from the CIPSO */
end_comment

begin_comment
comment|/* header and returns that whilst also storing the highest sensitivity      */
end_comment

begin_comment
comment|/* value found in the fr_info_t structure.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* No attempt is made to extract the category bitmaps as these are defined  */
end_comment

begin_comment
comment|/* by the user (rather than the protocol) and can be rather numerous on the */
end_comment

begin_comment
comment|/* end nodes.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|u_32_t
name|ipf_checkcipso
parameter_list|(
name|fin
parameter_list|,
name|s
parameter_list|,
name|ol
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|;
name|int
name|ol
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
decl_stmt|;
name|u_32_t
name|doi
decl_stmt|;
name|u_char
modifier|*
name|t
decl_stmt|,
name|tag
decl_stmt|,
name|tlen
decl_stmt|,
name|sensitivity
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ol
operator|<
literal|6
operator|||
name|ol
operator|>
literal|40
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_cipso_bad
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_ol
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
name|ol
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fi
operator|=
operator|&
name|fin
operator|->
name|fin_fi
expr_stmt|;
name|fi
operator|->
name|fi_sensitivity
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The DOI field MUST be there. 	 */
name|bcopy
argument_list|(
name|s
operator|+
literal|2
argument_list|,
operator|&
name|doi
argument_list|,
sizeof|sizeof
argument_list|(
name|doi
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|u_char
operator|*
operator|)
name|s
operator|+
literal|6
expr_stmt|;
for|for
control|(
name|len
operator|=
name|ol
operator|-
literal|6
init|;
name|len
operator|>=
literal|2
condition|;
name|len
operator|-=
name|tlen
operator|,
name|t
operator|+=
name|tlen
control|)
block|{
name|tag
operator|=
operator|*
name|t
expr_stmt|;
name|tlen
operator|=
operator|*
operator|(
name|t
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|>
name|len
operator|||
name|tlen
operator|<
literal|4
operator|||
name|tlen
operator|>
literal|34
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|,
name|fr_v4_cipso_tlen
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_tlen
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sensitivity
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Tag numbers 0, 1, 2, 5 are laid out in the CIPSO Internet 		 * draft (16 July 1992) that has expired. 		 */
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_tag
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|t
operator|+
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_tag1_t2
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
operator|*
name|t
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sensitivity
operator|=
operator|*
operator|(
name|t
operator|+
literal|3
operator|)
expr_stmt|;
comment|/* Category bitmap for categories 0-239 */
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|t
operator|+
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_tag4_t2
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
operator|*
name|t
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sensitivity
operator|=
operator|*
operator|(
name|t
operator|+
literal|3
operator|)
expr_stmt|;
comment|/* Enumerated categories, 16bits each, upto 15 */
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
literal|5
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|t
operator|+
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_tag5_t2
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
operator|(
operator|*
name|t
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sensitivity
operator|=
operator|*
operator|(
name|t
operator|+
literal|3
operator|)
expr_stmt|;
comment|/* Range of categories (2*16bits), up to 7 pairs */
block|}
elseif|else
if|if
condition|(
name|tag
operator|>
literal|127
condition|)
block|{
comment|/* Custom defined DOI */
empty_stmt|;
block|}
else|else
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT2
argument_list|(
name|ipf_fi_bad_checkcipso_tag127
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|u_int
argument_list|,
name|tag
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sensitivity
operator|>
name|fi
operator|->
name|fi_sensitivity
condition|)
name|fi
operator|->
name|fi_sensitivity
operator|=
name|sensitivity
expr_stmt|;
block|}
return|return
name|doi
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_makefrip                                                */
end_comment

begin_comment
comment|/* Returns:     int     - 0 == packet ok, -1 == packet freed                */
end_comment

begin_comment
comment|/* Parameters:  hlen(I) - length of IP packet header                        */
end_comment

begin_comment
comment|/*              ip(I)   - pointer to the IP header                          */
end_comment

begin_comment
comment|/*              fin(IO) - pointer to packet information                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compact the IP header into a structure which contains just the info.     */
end_comment

begin_comment
comment|/* which is useful for comparing IP headers with and store this information */
end_comment

begin_comment
comment|/* in the fr_info_t structure pointer to by fin.  At present, it is assumed */
end_comment

begin_comment
comment|/* this function will be called with either an IPv4 or IPv6 packet.         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_makefrip
parameter_list|(
name|hlen
parameter_list|,
name|ip
parameter_list|,
name|fin
parameter_list|)
name|int
name|hlen
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|int
name|v
decl_stmt|;
name|fin
operator|->
name|fin_depth
operator|=
literal|0
expr_stmt|;
name|fin
operator|->
name|fin_hlen
operator|=
operator|(
name|u_short
operator|)
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_ip
operator|=
name|ip
expr_stmt|;
name|fin
operator|->
name|fin_rule
operator|=
literal|0xffffffff
expr_stmt|;
name|fin
operator|->
name|fin_group
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fin
operator|->
name|fin_group
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
expr_stmt|;
name|v
operator|=
name|fin
operator|->
name|fin_v
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
name|fin
operator|->
name|fin_plen
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|hlen
expr_stmt|;
name|ipf_pr_ipv4hdr
argument_list|(
name|fin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
name|fin
operator|->
name|fin_plen
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
name|ip6_t
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|=
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|fin
operator|->
name|fin_plen
operator|+=
name|hlen
expr_stmt|;
name|ipf_pr_ipv6hdr
argument_list|(
name|fin
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fin
operator|->
name|fin_ip
operator|==
name|NULL
condition|)
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_ip_freed
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_portcheck                                               */
end_comment

begin_comment
comment|/* Returns:     int - 1 == port matched, 0 == port match failed             */
end_comment

begin_comment
comment|/* Parameters:  frp(I) - pointer to port check `expression'                 */
end_comment

begin_comment
comment|/*              pop(I) - port number to evaluate                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Perform a comparison of a port number against some other(s), using a     */
end_comment

begin_comment
comment|/* structure with compare information stored in it.                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_portcheck
parameter_list|(
name|frp
parameter_list|,
name|pop
parameter_list|)
name|frpcmp_t
modifier|*
name|frp
decl_stmt|;
name|u_32_t
name|pop
decl_stmt|;
block|{
name|int
name|err
init|=
literal|1
decl_stmt|;
name|u_32_t
name|po
decl_stmt|;
name|po
operator|=
name|frp
operator|->
name|frp_port
expr_stmt|;
comment|/* 	 * Do opposite test to that required and continue if that succeeds. 	 */
switch|switch
condition|(
name|frp
operator|->
name|frp_cmp
condition|)
block|{
case|case
name|FR_EQUAL
case|:
if|if
condition|(
name|pop
operator|!=
name|po
condition|)
comment|/* EQUAL */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_NEQUAL
case|:
if|if
condition|(
name|pop
operator|==
name|po
condition|)
comment|/* NOTEQUAL */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_LESST
case|:
if|if
condition|(
name|pop
operator|>=
name|po
condition|)
comment|/* LESSTHAN */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_GREATERT
case|:
if|if
condition|(
name|pop
operator|<=
name|po
condition|)
comment|/* GREATERTHAN */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_LESSTE
case|:
if|if
condition|(
name|pop
operator|>
name|po
condition|)
comment|/* LT or EQ */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_GREATERTE
case|:
if|if
condition|(
name|pop
operator|<
name|po
condition|)
comment|/* GT or EQ */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_OUTRANGE
case|:
if|if
condition|(
name|pop
operator|>=
name|po
operator|&&
name|pop
operator|<=
name|frp
operator|->
name|frp_top
condition|)
comment|/* Out of range */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_INRANGE
case|:
if|if
condition|(
name|pop
operator|<=
name|po
operator|||
name|pop
operator|>=
name|frp
operator|->
name|frp_top
condition|)
comment|/* In range */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_INCRANGE
case|:
if|if
condition|(
name|pop
operator|<
name|po
operator|||
name|pop
operator|>
name|frp
operator|->
name|frp_top
condition|)
comment|/* Inclusive range */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tcpudpchk                                               */
end_comment

begin_comment
comment|/* Returns:     int - 1 == protocol matched, 0 == check failed              */
end_comment

begin_comment
comment|/* Parameters:  fda(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              ft(I)  - pointer to structure with comparison data          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compares the current pcket (assuming it is TCP/UDP) information with a   */
end_comment

begin_comment
comment|/* structure containing information that we want to match against.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tcpudpchk
parameter_list|(
name|fi
parameter_list|,
name|ft
parameter_list|)
name|fr_ip_t
modifier|*
name|fi
decl_stmt|;
name|frtuc_t
modifier|*
name|ft
decl_stmt|;
block|{
name|int
name|err
init|=
literal|1
decl_stmt|;
comment|/* 	 * Both ports should *always* be in the first fragment. 	 * So far, I cannot find any cases where they can not be. 	 * 	 * compare destination ports 	 */
if|if
condition|(
name|ft
operator|->
name|ftu_dcmp
condition|)
name|err
operator|=
name|ipf_portcheck
argument_list|(
operator|&
name|ft
operator|->
name|ftu_dst
argument_list|,
name|fi
operator|->
name|fi_ports
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * compare source ports 	 */
if|if
condition|(
name|err
operator|&&
name|ft
operator|->
name|ftu_scmp
condition|)
name|err
operator|=
name|ipf_portcheck
argument_list|(
operator|&
name|ft
operator|->
name|ftu_src
argument_list|,
name|fi
operator|->
name|fi_ports
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have all the TCP/UDP header, then how can we 	 * expect to do any sort of match on it ?  If we were looking for 	 * TCP flags, then NO match.  If not, then match (which should 	 * satisfy the "short" class too). 	 */
if|if
condition|(
name|err
operator|&&
operator|(
name|fi
operator|->
name|fi_p
operator|==
name|IPPROTO_TCP
operator|)
condition|)
block|{
if|if
condition|(
name|fi
operator|->
name|fi_flx
operator|&
name|FI_SHORT
condition|)
return|return
operator|!
operator|(
name|ft
operator|->
name|ftu_tcpf
operator||
name|ft
operator|->
name|ftu_tcpfm
operator|)
return|;
comment|/* 		 * Match the flags ?  If not, abort this match. 		 */
if|if
condition|(
name|ft
operator|->
name|ftu_tcpfm
operator|&&
name|ft
operator|->
name|ftu_tcpf
operator|!=
operator|(
name|fi
operator|->
name|fi_tcpf
operator|&
name|ft
operator|->
name|ftu_tcpfm
operator|)
condition|)
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"f. %#x& %#x != %#x\n"
operator|,
name|fi
operator|->
name|fi_tcpf
operator|,
name|ft
operator|->
name|ftu_tcpfm
operator|,
name|ft
operator|->
name|ftu_tcpf
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_check_ipf                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 == match, else no match                             */
end_comment

begin_comment
comment|/* Parameters:  fin(I)     - pointer to packet information                  */
end_comment

begin_comment
comment|/*              fr(I)      - pointer to filter rule                         */
end_comment

begin_comment
comment|/*              portcmp(I) - flag indicating whether to attempt matching on */
end_comment

begin_comment
comment|/*                           TCP/UDP port data.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check to see if a packet matches an IPFilter rule.  Checks of addresses, */
end_comment

begin_comment
comment|/* port numbers, etc, for "standard" IPFilter rules are all orchestrated in */
end_comment

begin_comment
comment|/* this function.                                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ipf_check_ipf
parameter_list|(
name|fin
parameter_list|,
name|fr
parameter_list|,
name|portcmp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|int
name|portcmp
decl_stmt|;
block|{
name|u_32_t
modifier|*
name|ld
decl_stmt|,
modifier|*
name|lm
decl_stmt|,
modifier|*
name|lip
decl_stmt|;
name|fripf_t
modifier|*
name|fri
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fi
operator|=
operator|&
name|fin
operator|->
name|fin_fi
expr_stmt|;
name|fri
operator|=
name|fr
operator|->
name|fr_ipf
expr_stmt|;
name|lip
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|fi
expr_stmt|;
name|lm
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fri
operator|->
name|fri_mip
expr_stmt|;
name|ld
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fri
operator|->
name|fri_ip
expr_stmt|;
comment|/* 	 * first 32 bits to check coversion: 	 * IP version, TOS, TTL, protocol 	 */
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"0. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
literal|1
return|;
comment|/* 	 * Next 32 bits is a constructed bitmask indicating which IP options 	 * are present (if any) in this packet. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"1. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
comment|/* 	 * Unrolled loops (4 each, for 32 bits) for address checks. 	 */
comment|/* 	 * Check the source address. 	 */
if|if
condition|(
name|fr
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
condition|)
block|{
name|i
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_srcfunc
call|)
argument_list|(
name|fin
operator|->
name|fin_main_soft
argument_list|,
name|fr
operator|->
name|fr_srcptr
argument_list|,
name|fi
operator|->
name|fi_v
argument_list|,
name|lip
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2a. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_v
operator|==
literal|6
condition|)
block|{
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2b. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2c. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2d. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
block|}
name|i
operator|^=
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_NOTSRCIP
operator|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * Check the destination address. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
condition|)
block|{
name|i
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_dstfunc
call|)
argument_list|(
name|fin
operator|->
name|fin_main_soft
argument_list|,
name|fr
operator|->
name|fr_dstptr
argument_list|,
name|fi
operator|->
name|fi_v
argument_list|,
name|lip
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3a. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_v
operator|==
literal|6
condition|)
block|{
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3b. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3c. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3d. %#08x& %#08x != %#08x\n"
operator|,
name|ntohl
argument_list|(
operator|*
name|lip
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|lm
argument_list|)
operator|,
name|ntohl
argument_list|(
operator|*
name|ld
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
block|}
name|i
operator|^=
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_NOTDSTIP
operator|)
operator|>>
literal|7
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * IP addresses matched.  The next 32bits contains: 	 * mast of old IP header security& authentication bits. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator|=
operator|(
operator|*
name|ld
operator|-
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"4. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Next we have 32 bits of packet flags. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|*
name|ld
operator|-
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"5. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If a fragment, then only the first has what we're 		 * looking for here... 		 */
if|if
condition|(
name|portcmp
condition|)
block|{
if|if
condition|(
operator|!
name|ipf_tcpudpchk
argument_list|(
operator|&
name|fin
operator|->
name|fin_fi
argument_list|,
operator|&
name|fr
operator|->
name|fr_tuc
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fr
operator|->
name|fr_dcmp
operator|||
name|fr
operator|->
name|fr_scmp
operator|||
name|fr
operator|->
name|fr_tcpf
operator|||
name|fr
operator|->
name|fr_tcpfm
condition|)
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_icmpm
operator|||
name|fr
operator|->
name|fr_icmp
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|fi
operator|->
name|fi_p
operator|!=
name|IPPROTO_ICMP
operator|)
operator|&&
operator|(
name|fi
operator|->
name|fi_p
operator|!=
name|IPPROTO_ICMPV6
operator|)
operator|)
operator|||
name|fin
operator|->
name|fin_off
operator|||
operator|(
name|fin
operator|->
name|fin_dlen
operator|<
literal|2
operator|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|&
name|fr
operator|->
name|fr_icmpm
operator|)
operator|!=
name|fr
operator|->
name|fr_icmp
condition|)
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"i. %#x& %#x != %#x\n"
operator|,
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|,
name|fr
operator|->
name|fr_icmpm
operator|,
name|fr
operator|->
name|fr_icmp
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_scanlist                                                */
end_comment

begin_comment
comment|/* Returns:     int - result flags of scanning filter list                  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              pass(I) - default result to return for filtering            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check the input/output list of rules for a match to the current packet.  */
end_comment

begin_comment
comment|/* If a match is found, the value of fr_flags from the rule becomes the     */
end_comment

begin_comment
comment|/* return value and fin->fin_fr points to the matched rule.                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function may be called recusively upto 16 times (limit inbuilt.)    */
end_comment

begin_comment
comment|/* When unwinding, it should finish up with fin_depth as 0.                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Could be per interface, but this gets real nasty when you don't have,    */
end_comment

begin_comment
comment|/* or can't easily change, the kernel source code to .                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_scanlist
parameter_list|(
name|fin
parameter_list|,
name|pass
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|int
name|rulen
decl_stmt|,
name|portcmp
decl_stmt|,
name|off
decl_stmt|,
name|skip
decl_stmt|;
name|struct
name|frentry
modifier|*
name|fr
decl_stmt|,
modifier|*
name|fnext
decl_stmt|;
name|u_32_t
name|passt
decl_stmt|,
name|passo
decl_stmt|;
comment|/* 	 * Do not allow nesting deeper than 16 levels. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_depth
operator|>=
literal|16
condition|)
return|return
name|pass
return|;
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
comment|/* 	 * If there are no rules in this list, return now. 	 */
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
return|return
name|pass
return|;
name|skip
operator|=
literal|0
expr_stmt|;
name|portcmp
operator|=
literal|0
expr_stmt|;
name|fin
operator|->
name|fin_depth
operator|++
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
name|fin
operator|->
name|fin_off
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_TCPUDP
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|3
operator|)
operator|&&
operator|!
name|off
condition|)
name|portcmp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|rulen
operator|=
literal|0
init|;
name|fr
condition|;
name|fr
operator|=
name|fnext
operator|,
name|rulen
operator|++
control|)
block|{
name|fnext
operator|=
name|fr
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|FR_VERBOSE
argument_list|(
operator|(
literal|"SKIP %d (%#x)\n"
operator|,
name|skip
operator|,
name|fr
operator|->
name|fr_flags
operator|)
argument_list|)
expr_stmt|;
name|skip
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * In all checks below, a null (zero) value in the 		 * filter struture is taken to mean a wildcard. 		 * 		 * check that we are working for the right interface 		 */
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|fr
operator|->
name|fr_ifa
operator|&&
name|fr
operator|->
name|fr_ifa
operator|!=
name|fin
operator|->
name|fin_ifp
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
name|opts
operator|&
operator|(
name|OPT_VERBOSE
operator||
name|OPT_DEBUG
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|FR_VERBOSE
argument_list|(
operator|(
literal|"%c"
operator|,
name|FR_ISSKIP
argument_list|(
name|pass
argument_list|)
condition|?
literal|'s'
else|:
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|?
literal|'p'
else|:
name|FR_ISACCOUNT
argument_list|(
name|pass
argument_list|)
condition|?
literal|'A'
else|:
name|FR_ISAUTH
argument_list|(
name|pass
argument_list|)
condition|?
literal|'a'
else|:
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
condition|?
literal|'n'
else|:
literal|'b'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ifa
operator|&&
name|fr
operator|->
name|fr_ifa
operator|!=
name|fin
operator|->
name|fin_ifp
condition|)
continue|continue;
name|FR_VERBOSE
argument_list|(
operator|(
literal|":i"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fr
operator|->
name|fr_type
condition|)
block|{
case|case
name|FR_T_IPF
case|:
case|case
name|FR_T_IPF_BUILTIN
case|:
if|if
condition|(
name|ipf_check_ipf
argument_list|(
name|fin
argument_list|,
name|fr
argument_list|,
name|portcmp
argument_list|)
condition|)
continue|continue;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_BPF
argument_list|)
case|case
name|FR_T_BPFOPC
case|:
case|case
name|FR_T_BPFOPC_BUILTIN
case|:
block|{
name|u_char
modifier|*
name|mc
decl_stmt|;
name|int
name|wlen
decl_stmt|;
if|if
condition|(
operator|*
name|fin
operator|->
name|fin_mp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|fin
operator|->
name|fin_family
operator|!=
name|fr
operator|->
name|fr_family
condition|)
continue|continue;
name|mc
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fin
operator|->
name|fin_m
expr_stmt|;
name|wlen
operator|=
name|fin
operator|->
name|fin_dlen
operator|+
name|fin
operator|->
name|fin_hlen
expr_stmt|;
if|if
condition|(
operator|!
name|bpf_filter
argument_list|(
name|fr
operator|->
name|fr_data
argument_list|,
name|mc
argument_list|,
name|wlen
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
break|break;
block|}
endif|#
directive|endif
case|case
name|FR_T_CALLFUNC_BUILTIN
case|:
block|{
name|frentry_t
modifier|*
name|f
decl_stmt|;
name|f
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_func
call|)
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
name|fr
operator|=
name|f
expr_stmt|;
else|else
continue|continue;
break|break;
block|}
case|case
name|FR_T_IPFEXPR
case|:
case|case
name|FR_T_IPFEXPR_BUILTIN
case|:
if|if
condition|(
name|fin
operator|->
name|fin_family
operator|!=
name|fr
operator|->
name|fr_family
condition|)
continue|continue;
if|if
condition|(
name|ipf_fr_matcharray
argument_list|(
name|fin
argument_list|,
name|fr
operator|->
name|fr_data
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
break|break;
default|default :
break|break;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_nattag
operator|.
name|ipt_num
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_nattag
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ipf_matchtag
argument_list|(
operator|&
name|fr
operator|->
name|fr_nattag
argument_list|,
name|fin
operator|->
name|fin_nattag
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
name|FR_VERBOSE
argument_list|(
operator|(
literal|"=%d/%d.%d *"
operator|,
name|fr
operator|->
name|fr_grhead
operator|,
name|fr
operator|->
name|fr_group
operator|,
name|rulen
operator|)
argument_list|)
expr_stmt|;
name|passt
operator|=
name|fr
operator|->
name|fr_flags
expr_stmt|;
comment|/* 		 * If the rule is a "call now" rule, then call the function 		 * in the rule, if it exists and use the results from that. 		 * If the function pointer is bad, just make like we ignore 		 * it, except for increasing the hit counter. 		 */
if|if
condition|(
operator|(
name|passt
operator|&
name|FR_CALLNOW
operator|)
operator|!=
literal|0
condition|)
block|{
name|frentry_t
modifier|*
name|frs
decl_stmt|;
name|ATOMIC_INC64
argument_list|(
name|fr
operator|->
name|fr_hits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_func
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fr
operator|->
name|fr_func
operator|==
operator|(
name|ipfunc_t
operator|)
operator|-
literal|1
operator|)
condition|)
continue|continue;
name|frs
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
name|fr
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_func
call|)
argument_list|(
name|fin
argument_list|,
operator|&
name|passt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|fin
operator|->
name|fin_fr
operator|=
name|frs
expr_stmt|;
continue|continue;
block|}
name|passt
operator|=
name|fr
operator|->
name|fr_flags
expr_stmt|;
block|}
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
comment|/* 		 * Just log this packet... 		 */
if|if
condition|(
operator|(
name|passt
operator|&
name|FR_LOGMASK
operator|)
operator|==
name|FR_LOG
condition|)
block|{
if|if
condition|(
name|ipf_log_pkt
argument_list|(
name|fin
argument_list|,
name|passt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|passt
operator|&
name|FR_LOGORBLOCK
condition|)
block|{
name|DT
argument_list|(
name|frb_logfail
argument_list|)
expr_stmt|;
name|passt
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|passt
operator||=
name|FR_BLOCK
operator||
name|FR_QUICK
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_LOGFAIL
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* IPFILTER_LOG */
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_bytes
operator|+=
operator|(
name|U_QUAD_T
operator|)
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|fr
operator|->
name|fr_hits
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rule
operator|=
name|rulen
expr_stmt|;
name|passo
operator|=
name|pass
expr_stmt|;
if|if
condition|(
name|FR_ISSKIP
argument_list|(
name|passt
argument_list|)
condition|)
block|{
name|skip
operator|=
name|fr
operator|->
name|fr_arg
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|passt
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_LOG
operator|)
operator|&&
operator|(
operator|(
name|passt
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_DECAPSULATE
operator|)
condition|)
block|{
name|pass
operator|=
name|passt
expr_stmt|;
block|}
if|if
condition|(
name|passt
operator|&
operator|(
name|FR_RETICMP
operator||
name|FR_FAKEICMP
operator|)
condition|)
name|fin
operator|->
name|fin_icode
operator|=
name|fr
operator|->
name|fr_icode
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_group
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_NAME
argument_list|(
name|fr
argument_list|,
name|fr_group
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|FR_NAME
argument_list|(
name|fr
argument_list|,
name|fr_group
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fin
operator|->
name|fin_group
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|FR_DEBUG
argument_list|(
operator|(
literal|"pass %#x/%#x/%x\n"
operator|,
name|passo
operator|,
name|pass
operator|,
name|passt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_grphead
operator|!=
name|NULL
condition|)
block|{
name|fin
operator|->
name|fin_fr
operator|=
name|fr
operator|->
name|fr_grphead
operator|->
name|fg_start
expr_stmt|;
name|FR_VERBOSE
argument_list|(
operator|(
literal|"group %s\n"
operator|,
name|FR_NAME
argument_list|(
name|fr
argument_list|,
name|fr_grhead
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISDECAPS
argument_list|(
name|passt
argument_list|)
condition|)
name|passt
operator|=
name|ipf_decaps
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|,
name|fr
operator|->
name|fr_icode
argument_list|)
expr_stmt|;
else|else
name|passt
operator|=
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fr
operator|==
name|NULL
condition|)
block|{
name|fin
operator|->
name|fin_rule
operator|=
name|rulen
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_group
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_group
argument_list|,
name|strlen
argument_list|(
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_group
argument_list|)
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
name|passt
operator|=
name|pass
expr_stmt|;
block|}
name|pass
operator|=
name|passt
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|&
name|FR_QUICK
condition|)
block|{
comment|/* 			 * Finally, if we've asked to track state for this 			 * packet, set it up.  Add state for "quick" rules 			 * here so that if the action fails we can consider 			 * the rule to "not match" and keep on processing 			 * filter rules. 			 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|!
name|FR_ISAUTH
argument_list|(
name|pass
argument_list|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_STATE
operator|)
condition|)
block|{
name|int
name|out
init|=
name|fin
operator|->
name|fin_out
decl_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
if|if
condition|(
name|ipf_state_add
argument_list|(
name|softc
argument_list|,
name|fin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_ads
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_bads
argument_list|)
expr_stmt|;
name|pass
operator|=
name|passo
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
name|fin
operator|->
name|fin_depth
operator|--
expr_stmt|;
return|return
name|pass
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_acctpkt                                                 */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - always returns NULL                            */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Checks a packet against accounting rules, if there are any for the given */
end_comment

begin_comment
comment|/* IP protocol version.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* N.B.: this function returns NULL to match the prototype used by other    */
end_comment

begin_comment
comment|/* functions called from the IPFilter "mainline" in ipf_check().            */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|ipf_acctpkt
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|char
name|group
index|[
name|FR_GROUPLEN
index|]
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|,
modifier|*
name|frsave
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|,
name|rulen
decl_stmt|;
name|passp
operator|=
name|passp
expr_stmt|;
name|fr
operator|=
name|softc
operator|->
name|ipf_acct
index|[
name|fin
operator|->
name|fin_out
index|]
index|[
name|softc
operator|->
name|ipf_active
index|]
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|frsave
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|bcopy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|rulen
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
name|pass
operator|=
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
name|FR_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
literal|0
index|]
argument_list|,
name|fr_acct
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_fr
operator|=
name|frsave
expr_stmt|;
name|bcopy
argument_list|(
name|group
argument_list|,
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rule
operator|=
name|rulen
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_firewall                                                */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - returns pointer to matched rule, if no matches */
end_comment

begin_comment
comment|/*                           were found, returns NULL.                      */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Applies an appropriate set of firewall rules to the packet, to see if    */
end_comment

begin_comment
comment|/* there are any matches.  The first check is to see if a match can be seen */
end_comment

begin_comment
comment|/* in the cache.  If not, then search an appropriate list of rules.  Once a */
end_comment

begin_comment
comment|/* matching rule is found, take any appropriate actions as defined by the   */
end_comment

begin_comment
comment|/* rule - except logging.                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|frentry_t
modifier|*
name|ipf_firewall
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|;
name|int
name|out
decl_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|pass
operator|=
operator|*
name|passp
expr_stmt|;
comment|/* 	 * This rule cache will only affect packets that are not being 	 * statefully filtered. 	 */
name|fin
operator|->
name|fin_fr
operator|=
name|softc
operator|->
name|ipf_rules
index|[
name|out
index|]
index|[
name|softc
operator|->
name|ipf_active
index|]
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fr
operator|!=
name|NULL
condition|)
name|pass
operator|=
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
name|softc
operator|->
name|ipf_pass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_nom
argument_list|)
expr_stmt|;
block|}
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
comment|/* 	 * Apply packets per second rate-limiting to a rule as required. 	 */
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_pps
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|ppsratecheck
argument_list|(
operator|&
name|fr
operator|->
name|fr_lastpkt
argument_list|,
operator|&
name|fr
operator|->
name|fr_curpps
argument_list|,
name|fr
operator|->
name|fr_pps
argument_list|)
condition|)
block|{
name|DT2
argument_list|(
name|frb_ppsrate
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|frentry_t
operator|*
argument_list|,
name|fr
argument_list|)
expr_stmt|;
name|pass
operator|&=
operator|~
operator|(
name|FR_CMDMASK
operator||
name|FR_RETICMP
operator||
name|FR_RETRST
operator|)
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_ppshit
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_PPSRATE
expr_stmt|;
block|}
comment|/* 	 * If we fail to add a packet to the authorization queue, then we 	 * drop the packet later.  However, if it was added then pretend 	 * we've dropped it already. 	 */
if|if
condition|(
name|FR_ISAUTH
argument_list|(
name|pass
argument_list|)
condition|)
block|{
if|if
condition|(
name|ipf_auth_new
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DT1
argument_list|(
name|frb_authnew
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_AUTHNEW
expr_stmt|;
name|fin
operator|->
name|fin_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_error
operator|=
name|ENOSPC
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_func
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_func
operator|!=
operator|(
name|ipfunc_t
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|!
operator|(
name|pass
operator|&
name|FR_CALLNOW
operator|)
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fr
operator|->
name|fr_func
argument_list|)
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
comment|/* 	 * If a rule is a pre-auth rule, check again in the list of rules 	 * loaded for authenticated use.  It does not particulary matter 	 * if this search fails because a "preauth" result, from a rule, 	 * is treated as "not a pass", hence the packet is blocked. 	 */
if|if
condition|(
name|FR_ISPREAUTH
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|pass
operator|=
name|ipf_auth_pre_scanlist
argument_list|(
name|softc
argument_list|,
name|fin
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the rule has "keep frag" and the packet is actually a fragment, 	 * then create a fragment state entry. 	 */
if|if
condition|(
name|pass
operator|&
name|FR_KEEPFRAG
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
condition|)
block|{
if|if
condition|(
name|ipf_frag_new
argument_list|(
name|softc
argument_list|,
name|fin
argument_list|,
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_bnfr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_nfr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_cfr
argument_list|)
expr_stmt|;
block|}
block|}
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
operator|*
name|passp
operator|=
name|pass
expr_stmt|;
return|return
name|fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_check                                                   */
end_comment

begin_comment
comment|/* Returns:     int -  0 == packet allowed through,                         */
end_comment

begin_comment
comment|/*              User space:                                                 */
end_comment

begin_comment
comment|/*                    -1 == packet blocked                                  */
end_comment

begin_comment
comment|/*                     1 == packet not matched                              */
end_comment

begin_comment
comment|/*                    -2 == requires authentication                         */
end_comment

begin_comment
comment|/*              Kernel:                                                     */
end_comment

begin_comment
comment|/*> 0 == filter error # for packet                       */
end_comment

begin_comment
comment|/* Parameters: ip(I)   - pointer to start of IPv4/6 packet                  */
end_comment

begin_comment
comment|/*             hlen(I) - length of header                                   */
end_comment

begin_comment
comment|/*             ifp(I)  - pointer to interface this packet is on             */
end_comment

begin_comment
comment|/*             out(I)  - 0 == packet going in, 1 == packet going out        */
end_comment

begin_comment
comment|/*             mp(IO)  - pointer to caller's buffer pointer that holds this */
end_comment

begin_comment
comment|/*                       IP packet.                                         */
end_comment

begin_comment
comment|/* Solaris& HP-UX ONLY :                                                   */
end_comment

begin_comment
comment|/*             qpi(I)  - pointer to STREAMS queue information for this      */
end_comment

begin_comment
comment|/*                       interface& direction.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ipf_check() is the master function for all IPFilter packet processing.   */
end_comment

begin_comment
comment|/* It orchestrates: Network Address Translation (NAT), checking for packet  */
end_comment

begin_comment
comment|/* authorisation (or pre-authorisation), presence of related state info.,   */
end_comment

begin_comment
comment|/* generating log entries, IP packet accounting, routing of packets as      */
end_comment

begin_comment
comment|/* directed by firewall rules and of course whether or not to allow the     */
end_comment

begin_comment
comment|/* packet to be further processed by the kernel.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* For packets blocked, the contents of "mp" will be NULL'd and the buffer  */
end_comment

begin_comment
comment|/* freed.  Packets passed may be returned with the pointer pointed to by    */
end_comment

begin_comment
comment|/* by "mp" changed to a new buffer.                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_decl_stmt
name|int
name|ipf_check
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|,
name|ifp
argument_list|,
name|out
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|MENTAT
argument_list|)
argument_list|,
name|qif
argument_list|,
name|mp
argument_list|)
name|void
modifier|*
name|qif
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_operator
operator|,
end_operator

begin_expr_stmt
name|mp
end_expr_stmt

begin_endif
unit|)
endif|#
directive|endif
end_endif

begin_decl_stmt
name|mb_t
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ip_t
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|ctx
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * The above really sucks, but short of writing a diff 	 */
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|ctx
decl_stmt|;
name|fr_info_t
name|frinfo
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
init|=
operator|&
name|frinfo
decl_stmt|;
name|u_32_t
name|pass
init|=
name|softc
operator|->
name|ipf_pass
decl_stmt|;
name|frentry_t
modifier|*
name|fr
init|=
name|NULL
decl_stmt|;
name|int
name|v
init|=
name|IP_V
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|mb_t
modifier|*
name|mc
init|=
name|NULL
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
comment|/* 	 * The first part of ipf_check() deals with making sure that what goes 	 * into the filtering engine makes some sense.  Information about the 	 * the packet is distilled, collected into a fr_info_t structure and 	 * the an attempt to ensure the buffer the packet is in is big enough 	 * to hold all the required packet headers. 	 */
ifdef|#
directive|ifdef
name|_KERNEL
ifdef|#
directive|ifdef
name|MENTAT
name|qpktinfo_t
modifier|*
name|qpi
init|=
name|qif
decl_stmt|;
ifdef|#
directive|ifdef
name|__sparc
if|if
condition|(
operator|(
name|u_int
operator|)
name|ip
operator|&
literal|0x3
condition|)
return|return
literal|2
return|;
endif|#
directive|endif
else|#
directive|else
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MENTAT
if|if
condition|(
name|qpi
operator|->
name|qpi_flags
operator|&
name|QF_BROADCAST
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_BROADCAST
expr_stmt|;
if|if
condition|(
name|qpi
operator|->
name|qpi_flags
operator|&
name|QF_MULTICAST
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
name|m
operator|=
name|qpi
operator|->
name|qpi_m
expr_stmt|;
name|fin
operator|->
name|fin_qfm
operator|=
name|m
expr_stmt|;
name|fin
operator|->
name|fin_qpi
operator|=
name|qpi
expr_stmt|;
else|#
directive|else
comment|/* MENTAT */
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|M_MCAST
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M_MLOOP
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MLOOP
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M_BCAST
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_BROADCAST
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|M_CANFASTFWD
comment|/* 	 * XXX For now, IP Filter and fast-forwarding of cached flows 	 * XXX are mutually exclusive.  Eventually, IP Filter should 	 * XXX get a "can-fast-forward" filter rule. 	 */
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_CANFASTFWD
expr_stmt|;
endif|#
directive|endif
comment|/* M_CANFASTFWD */
if|#
directive|if
name|defined
argument_list|(
name|CSUM_DELAY_DATA
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|||
expr|\
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
operator|)
comment|/* 	 * disable delayed checksums. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|in_delayed_cksum
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CSUM_DELAY_DATA */
endif|#
directive|endif
comment|/* MENTAT */
else|#
directive|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|M_MCAST
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M_MLOOP
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MLOOP
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M_BCAST
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_BROADCAST
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* _KERNEL */
name|fin
operator|->
name|fin_v
operator|=
name|v
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|m
expr_stmt|;
name|fin
operator|->
name|fin_ip
operator|=
name|ip
expr_stmt|;
name|fin
operator|->
name|fin_mp
operator|=
name|mp
expr_stmt|;
name|fin
operator|->
name|fin_out
operator|=
name|out
expr_stmt|;
name|fin
operator|->
name|fin_ifp
operator|=
name|ifp
expr_stmt|;
name|fin
operator|->
name|fin_error
operator|=
name|ENETUNREACH
expr_stmt|;
name|fin
operator|->
name|fin_hlen
operator|=
operator|(
name|u_short
operator|)
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_main_soft
operator|=
name|softc
expr_stmt|;
name|fin
operator|->
name|fin_ipoff
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|-
name|MTOD
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_ipv6
argument_list|)
expr_stmt|;
comment|/* 		 * Jumbo grams are quite likely too big for internal buffer 		 * structures to handle comfortably, for now, so just drop 		 * them. 		 */
if|if
condition|(
operator|(
operator|(
name|ip6_t
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip6_plen
operator|==
literal|0
condition|)
block|{
name|DT1
argument_list|(
name|frb_jumbo
argument_list|,
name|ip6_t
operator|*
argument_list|,
operator|(
name|ip6_t
operator|*
operator|)
name|ip
argument_list|)
expr_stmt|;
name|pass
operator|=
name|FR_BLOCK
operator||
name|FR_NOMATCH
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_JUMBO
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
name|fin
operator|->
name|fin_family
operator|=
name|AF_INET6
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fin
operator|->
name|fin_family
operator|=
name|AF_INET
expr_stmt|;
block|}
if|if
condition|(
name|ipf_makefrip
argument_list|(
name|hlen
argument_list|,
name|ip
argument_list|,
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|DT1
argument_list|(
name|frb_makefrip
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|pass
operator|=
name|FR_BLOCK
operator||
name|FR_NOMATCH
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_MAKEFRIP
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* 	 * For at least IPv6 packets, if a m_pullup() fails then this pointer 	 * becomes NULL and so we have no packet to free. 	 */
if|if
condition|(
operator|*
name|fin
operator|->
name|fin_mp
operator|==
name|NULL
condition|)
goto|goto
name|finished
goto|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_chksrc
operator|&&
operator|!
name|ipf_verifysrc
argument_list|(
name|fin
argument_list|)
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
literal|0
index|]
argument_list|,
name|fr_v4_badsrc
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BADSRC
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_ip
operator|->
name|ip_ttl
operator|<
name|softc
operator|->
name|ipf_minttl
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
literal|0
index|]
argument_list|,
name|fr_v4_badttl
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_LOWTTL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ip6_t
operator|*
operator|)
name|ip
operator|)
operator|->
name|ip6_hlim
operator|<
name|softc
operator|->
name|ipf_minttl
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
literal|0
index|]
argument_list|,
name|fr_v6_badttl
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_LOWTTL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
condition|)
block|{
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_short
argument_list|)
expr_stmt|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
switch|switch
condition|(
name|fin
operator|->
name|fin_v
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|ipf_nat_checkin
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|filterdone
goto|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
literal|6
case|:
if|if
condition|(
name|ipf_nat6_checkin
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|filterdone
goto|;
block|}
break|break;
endif|#
directive|endif
default|default :
break|break;
block|}
block|}
comment|/* 	 * Check auth now. 	 * If a packet is found in the auth table, then skip checking 	 * the access lists for permission but we do need to consider 	 * the result as if it were from the ACL's.  In addition, being 	 * found in the auth table means it has been seen before, so do 	 * not pass it through accounting (again), lest it be counted twice. 	 */
name|fr
operator|=
name|ipf_auth_check
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
operator|&&
operator|(
name|fr
operator|==
name|NULL
operator|)
condition|)
operator|(
name|void
operator|)
name|ipf_acctpkt
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
operator|)
operator|!=
literal|0
condition|)
name|fr
operator|=
name|ipf_frag_known
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
name|fr
operator|=
name|ipf_state_check
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
operator|||
operator|(
name|fr
operator|==
name|NULL
operator|)
condition|)
name|fr
operator|=
name|ipf_firewall
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
comment|/* 	 * If we've asked to track state for this packet, set it up. 	 * Here rather than ipf_firewall because ipf_checkauth may decide 	 * to return a packet for "keep state" 	 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_m
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_STATE
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_state_add
argument_list|(
name|softc
argument_list|,
name|fin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_ads
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_bads
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|DT
argument_list|(
name|frb_stateadd
argument_list|)
expr_stmt|;
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_STATEADD
expr_stmt|;
block|}
block|}
block|}
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_STATE
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_dif
operator|=
operator|&
name|fr
operator|->
name|fr_dif
expr_stmt|;
name|fin
operator|->
name|fin_tif
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
block|}
comment|/* 	 * Only count/translate packets which will be passed on, out the 	 * interface. 	 */
if|if
condition|(
name|out
operator|&&
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ipf_acctpkt
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_v
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
name|ipf_nat_checkout
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|softc
operator|->
name|ipf_update_ipid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|v
operator|==
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_updateipid
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|DT
argument_list|(
name|frb_updateipid
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
literal|1
index|]
operator|.
name|fr_ipud
argument_list|)
expr_stmt|;
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_UPDATEIPID
expr_stmt|;
block|}
else|else
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
literal|0
index|]
operator|.
name|fr_ipud
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
literal|6
case|:
operator|(
name|void
operator|)
name|ipf_nat6_checkout
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default :
break|break;
block|}
block|}
name|filterdone
label|:
ifdef|#
directive|ifdef
name|IPFILTER_LOG
if|if
condition|(
operator|(
name|softc
operator|->
name|ipf_flags
operator|&
name|FF_LOGGING
operator|)
operator|||
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|ipf_dolog
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * The FI_STATE flag is cleared here so that calling ipf_state_check 	 * will work when called from inside of fr_fastroute.  Although 	 * there is a similar flag, FI_NATED, for NAT, it does have the same 	 * impact on code execution. 	 */
name|fin
operator|->
name|fin_flx
operator|&=
operator|~
name|FI_STATE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FASTROUTE_RECURSION
argument_list|)
comment|/* 	 * Up the reference on fr_lock and exit ipf_mutex. The generation of 	 * a packet below can sometimes cause a recursive call into IPFilter. 	 * On those platforms where that does happen, we need to hang onto 	 * the filter rule just in case someone decides to remove or flush it 	 * in the meantime. 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Should we return an ICMP packet to indicate error 		 * status passing through the packet filter ? 		 * WARNING: ICMP error packets AND TCP RST packets should 		 * ONLY be sent in repsonse to incoming packets.  Sending 		 * them in response to outbound packets can result in a 		 * panic on some operating systems. 		 */
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|pass
operator|&
name|FR_RETICMP
condition|)
block|{
name|int
name|dst
decl_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|==
name|FR_FAKEICMP
condition|)
name|dst
operator|=
literal|1
expr_stmt|;
else|else
name|dst
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_send_icmp_err
argument_list|(
name|ICMP_UNREACH
argument_list|,
name|fin
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
literal|0
index|]
operator|.
name|fr_ret
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|==
name|FR_RETRST
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ipf_send_reset
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
literal|1
index|]
operator|.
name|fr_ret
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * When using return-* with auth rules, the auth code 			 * takes over disposing of this packet. 			 */
if|if
condition|(
name|FR_ISAUTH
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|fin
operator|->
name|fin_m
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DT1
argument_list|(
name|frb_authcapture
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_AUTHCAPTURE
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pass
operator|&
name|FR_RETRST
condition|)
block|{
name|fin
operator|->
name|fin_error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * After the above so that ICMP unreachables and TCP RSTs get 	 * created properly. 	 */
if|if
condition|(
name|FR_ISBLOCK
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_NEWNAT
operator|)
condition|)
name|ipf_nat_uncreate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't drop off the bottom of the list of rules (and thus 	 * the 'current' rule fr is not NULL), then we may have some extra 	 * instructions about what to do with a packet. 	 * Once we're finished return to our caller, freeing the packet if 	 * we are dropping it. 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
comment|/* 		 * Generate a duplicated packet first because ipf_fastroute 		 * can lead to fin_m being free'd... not good. 		 */
name|fdp
operator|=
name|fin
operator|->
name|fin_dif
expr_stmt|;
if|if
condition|(
operator|(
name|fdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ptr
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|mc
operator|=
name|M_COPY
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|!=
name|NULL
condition|)
name|ipf_fastroute
argument_list|(
name|mc
argument_list|,
operator|&
name|mc
argument_list|,
name|fin
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
block|}
name|fdp
operator|=
name|fin
operator|->
name|fin_tif
expr_stmt|;
if|if
condition|(
operator|!
name|out
operator|&&
operator|(
name|pass
operator|&
name|FR_FASTROUTE
operator|)
condition|)
block|{
comment|/* 			 * For fastroute rule, no destination interface defined 			 * so pass NULL as the frdest_t parameter 			 */
operator|(
name|void
operator|)
name|ipf_fastroute
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|mp
argument_list|,
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ptr
operator|!=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* this is for to rules: */
name|ipf_fastroute
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|mp
argument_list|,
name|fin
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|FASTROUTE_RECURSION
argument_list|)
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FASTROUTE_RECURSION
argument_list|)
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|finished
label|:
if|if
condition|(
operator|!
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|FREE_MB_T
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_pass
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sgi
argument_list|)
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_hbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|mtod
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|!=
name|fin
operator|->
name|fin_ip
operator|)
condition|)
block|{
name|COPYBACK
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
literal|0
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|,
name|fin
operator|->
name|fin_hbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
return|return
literal|0
return|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|out
index|]
operator|.
name|fr_blocked
index|[
name|fin
operator|->
name|fin_reason
index|]
argument_list|)
expr_stmt|;
return|return
name|fin
operator|->
name|fin_error
return|;
else|#
directive|else
comment|/* _KERNEL */
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|mp
operator|)
operator|->
name|mb_ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|blockreason
operator|=
name|fin
operator|->
name|fin_reason
expr_stmt|;
name|FR_VERBOSE
argument_list|(
operator|(
literal|"fin_flx %#x pass %#x "
operator|,
name|fin
operator|->
name|fin_flx
operator|,
name|pass
operator|)
argument_list|)
expr_stmt|;
comment|/*if ((pass& FR_CMDMASK) == (softc->ipf_pass& FR_CMDMASK))*/
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|pass
operator|&
name|FR_RETMASK
condition|)
block|{
case|case
name|FR_RETRST
case|:
return|return
literal|3
return|;
case|case
name|FR_RETICMP
case|:
return|return
literal|4
return|;
case|case
name|FR_FAKEICMP
case|:
return|return
literal|5
return|;
block|}
switch|switch
condition|(
name|pass
operator|&
name|FR_CMDMASK
condition|)
block|{
case|case
name|FR_PASS
case|:
return|return
literal|0
return|;
case|case
name|FR_BLOCK
case|:
return|return
operator|-
literal|1
return|;
case|case
name|FR_AUTH
case|:
return|return
operator|-
literal|2
return|;
case|case
name|FR_ACCOUNT
case|:
return|return
operator|-
literal|3
return|;
case|case
name|FR_PREAUTH
case|:
return|return
operator|-
literal|4
return|;
block|}
return|return
literal|2
return|;
endif|#
directive|endif
comment|/* _KERNEL */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_dolog                                                   */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - returns contents of fin_fr (no change made)    */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Checks flags set to see how a packet should be logged, if it is to be    */
end_comment

begin_comment
comment|/* logged.  Adjust statistics based on its success or not.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|ipf_dolog
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|;
name|int
name|out
decl_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|pass
operator|=
operator|*
name|passp
expr_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|ipf_flags
operator|&
name|FF_LOGNOMATCH
operator|)
operator|&&
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
condition|)
block|{
name|pass
operator||=
name|FF_LOGNOMATCH
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_npkl
argument_list|)
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|==
name|FR_LOGP
operator|)
operator|||
operator|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|softc
operator|->
name|ipf_flags
operator|&
name|FF_LOGPASS
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_LOGP
condition|)
name|pass
operator||=
name|FF_LOGPASS
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_ppkl
argument_list|)
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|==
name|FR_LOGB
operator|)
operator|||
operator|(
name|FR_ISBLOCK
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|softc
operator|->
name|ipf_flags
operator|&
name|FF_LOGBLOCK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_LOGB
condition|)
name|pass
operator||=
name|FF_LOGBLOCK
expr_stmt|;
name|LBUMPD
argument_list|(
name|ipf_stats
index|[
name|out
index|]
argument_list|,
name|fr_bpkl
argument_list|)
expr_stmt|;
name|logit
label|:
if|if
condition|(
name|ipf_log_pkt
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * If the "or-block" option has been used then 			 * block the packet if we failed to log it. 			 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGORBLOCK
operator|)
operator|&&
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|DT1
argument_list|(
name|frb_logfail2
argument_list|,
name|u_int
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_LOGFAIL2
expr_stmt|;
block|}
block|}
operator|*
name|passp
operator|=
name|pass
expr_stmt|;
block|}
return|return
name|fin
operator|->
name|fin_fr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOG */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_cksum                                                   */
end_comment

begin_comment
comment|/* Returns:     u_short - IP header checksum                                */
end_comment

begin_comment
comment|/* Parameters:  addr(I) - pointer to start of buffer to checksum            */
end_comment

begin_comment
comment|/*              len(I)  - length of buffer in bytes                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Calculate the two's complement 16 bit checksum of the buffer passed.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* N.B.: addr should be 16bit aligned.                                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_short
name|ipf_cksum
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|u_short
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_32_t
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
init|;
name|len
operator|>
literal|1
condition|;
name|len
operator|-=
literal|2
control|)
name|sum
operator|+=
operator|*
name|addr
operator|++
expr_stmt|;
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|sum
operator|+=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
return|return
call|(
name|u_short
call|)
argument_list|(
operator|~
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_cksum                                                    */
end_comment

begin_comment
comment|/* Returns:     u_short - layer 4 checksum                                  */
end_comment

begin_comment
comment|/* Parameters:  fin(I)     - pointer to packet information                  */
end_comment

begin_comment
comment|/*              ip(I)      - pointer to IP header                           */
end_comment

begin_comment
comment|/*              l4proto(I) - protocol to caclulate checksum for             */
end_comment

begin_comment
comment|/*              l4hdr(I)   - pointer to layer 4 header                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Calculates the TCP checksum for the packet held in "m", using the data   */
end_comment

begin_comment
comment|/* in the IP header "ip" to seed it.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NB: This function assumes we've pullup'd enough for all of the IP header */
end_comment

begin_comment
comment|/* and the TCP header.  We also assume that data blocks aren't allocated in */
end_comment

begin_comment
comment|/* odd sizes.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Expects ip_len and ip_off to be in network byte order when called.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_short
name|fr_cksum
parameter_list|(
name|fin
parameter_list|,
name|ip
parameter_list|,
name|l4proto
parameter_list|,
name|l4hdr
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|int
name|l4proto
decl_stmt|;
name|void
modifier|*
name|l4hdr
decl_stmt|;
block|{
name|u_short
modifier|*
name|sp
decl_stmt|,
name|slen
decl_stmt|,
name|sumsave
decl_stmt|,
modifier|*
name|csump
decl_stmt|;
name|u_int
name|sum
decl_stmt|,
name|sum2
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|int
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
name|ip6_t
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|csump
operator|=
name|NULL
expr_stmt|;
name|sumsave
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|slen
operator|=
literal|0
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|l4proto
argument_list|)
expr_stmt|;
comment|/* 	 * Add up IP Header portion 	 */
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|4
condition|)
block|{
endif|#
directive|endif
name|hlen
operator|=
name|IP_HL
argument_list|(
name|ip
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|off
operator|=
name|hlen
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|ip
operator|->
name|ip_src
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip_src */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip_dst */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
block|}
elseif|else
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|6
condition|)
block|{
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
name|ip
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|-
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|)
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip6_src */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* This needs to be routing header aware. */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip6_dst */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0xffff
return|;
block|}
endif|#
directive|endif
name|slen
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|off
expr_stmt|;
name|sum
operator|+=
name|htons
argument_list|(
name|slen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|l4proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|udphdr_t
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|uh_sum
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|tcphdr_t
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|th_sum
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|icmphdr_t
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|icmp_cksum
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
comment|/* Pseudo-checksum is not included */
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|icmp6_cksum
expr_stmt|;
break|break;
endif|#
directive|endif
default|default :
break|break;
block|}
if|if
condition|(
name|csump
operator|!=
name|NULL
condition|)
block|{
name|sumsave
operator|=
operator|*
name|csump
expr_stmt|;
operator|*
name|csump
operator|=
literal|0
expr_stmt|;
block|}
name|sum2
operator|=
name|ipf_pcksum
argument_list|(
name|fin
argument_list|,
name|off
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|csump
operator|!=
name|NULL
condition|)
operator|*
name|csump
operator|=
name|sumsave
expr_stmt|;
return|return
name|sum2
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_findgroup                                               */
end_comment

begin_comment
comment|/* Returns:     frgroup_t * - NULL = group not found, else pointer to group */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              group(I) - group name to search for                         */
end_comment

begin_comment
comment|/*              unit(I)  - device to which this group belongs               */
end_comment

begin_comment
comment|/*              set(I)   - which set of rules (inactive/inactive) this is   */
end_comment

begin_comment
comment|/*              fgpp(O)  - pointer to place to store pointer to the pointer */
end_comment

begin_comment
comment|/*                         to where to add the next (last) group or where   */
end_comment

begin_comment
comment|/*                         to delete group from.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search amongst the defined groups for a particular group number.         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frgroup_t
modifier|*
name|ipf_findgroup
parameter_list|(
name|softc
parameter_list|,
name|group
parameter_list|,
name|unit
parameter_list|,
name|set
parameter_list|,
name|fgpp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
name|set
decl_stmt|;
name|frgroup_t
modifier|*
modifier|*
modifier|*
name|fgpp
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|,
modifier|*
modifier|*
name|fgp
decl_stmt|;
comment|/* 	 * Which list of groups to search in is dependent on which list of 	 * rules are being operated on. 	 */
name|fgp
operator|=
operator|&
name|softc
operator|->
name|ipf_groups
index|[
name|unit
index|]
index|[
name|set
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|fg
operator|=
operator|*
name|fgp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|group
argument_list|,
name|fg
operator|->
name|fg_name
argument_list|,
name|FR_GROUPLEN
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
name|fgp
operator|=
operator|&
name|fg
operator|->
name|fg_next
expr_stmt|;
block|}
if|if
condition|(
name|fgpp
operator|!=
name|NULL
condition|)
operator|*
name|fgpp
operator|=
name|fgp
expr_stmt|;
return|return
name|fg
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_group_add                                               */
end_comment

begin_comment
comment|/* Returns:     frgroup_t * - NULL == did not create group,                 */
end_comment

begin_comment
comment|/*                            != NULL == pointer to the group               */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              num(I)   - group number to add                              */
end_comment

begin_comment
comment|/*              head(I)  - rule pointer that is using this as the head      */
end_comment

begin_comment
comment|/*              flags(I) - rule flags which describe the type of rule it is */
end_comment

begin_comment
comment|/*              unit(I)  - device to which this group will belong to        */
end_comment

begin_comment
comment|/*              set(I)   - which set of rules (inactive/inactive) this is   */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Add a new group head, or if it already exists, increase the reference    */
end_comment

begin_comment
comment|/* count to it.                                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frgroup_t
modifier|*
name|ipf_group_add
parameter_list|(
name|softc
parameter_list|,
name|group
parameter_list|,
name|head
parameter_list|,
name|flags
parameter_list|,
name|unit
parameter_list|,
name|set
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|void
modifier|*
name|head
decl_stmt|;
name|u_32_t
name|flags
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|,
modifier|*
modifier|*
name|fgp
decl_stmt|;
name|u_32_t
name|gflags
decl_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGIPF
operator|&&
operator|*
name|group
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|fgp
operator|=
name|NULL
expr_stmt|;
name|gflags
operator|=
name|flags
operator|&
name|FR_INOUT
expr_stmt|;
name|fg
operator|=
name|ipf_findgroup
argument_list|(
name|softc
argument_list|,
name|group
argument_list|,
name|unit
argument_list|,
name|set
argument_list|,
operator|&
name|fgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fg
operator|->
name|fg_head
operator|==
name|NULL
operator|&&
name|head
operator|!=
name|NULL
condition|)
name|fg
operator|->
name|fg_head
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|fg_flags
operator|==
literal|0
condition|)
name|fg
operator|->
name|fg_flags
operator|=
name|gflags
expr_stmt|;
elseif|else
if|if
condition|(
name|gflags
operator|!=
name|fg
operator|->
name|fg_flags
condition|)
return|return
name|NULL
return|;
name|fg
operator|->
name|fg_ref
operator|++
expr_stmt|;
return|return
name|fg
return|;
block|}
name|KMALLOC
argument_list|(
name|fg
argument_list|,
name|frgroup_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
block|{
name|fg
operator|->
name|fg_head
operator|=
name|head
expr_stmt|;
name|fg
operator|->
name|fg_start
operator|=
name|NULL
expr_stmt|;
name|fg
operator|->
name|fg_next
operator|=
operator|*
name|fgp
expr_stmt|;
name|bcopy
argument_list|(
name|group
argument_list|,
name|fg
operator|->
name|fg_name
argument_list|,
name|strlen
argument_list|(
name|group
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fg
operator|->
name|fg_flags
operator|=
name|gflags
expr_stmt|;
name|fg
operator|->
name|fg_ref
operator|=
literal|1
expr_stmt|;
name|fg
operator|->
name|fg_set
operator|=
operator|&
name|softc
operator|->
name|ipf_groups
index|[
name|unit
index|]
index|[
name|set
index|]
expr_stmt|;
operator|*
name|fgp
operator|=
name|fg
expr_stmt|;
block|}
return|return
name|fg
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_group_del                                               */
end_comment

begin_comment
comment|/* Returns:     int      - number of rules deleted                          */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              group(I) - group name to delete                             */
end_comment

begin_comment
comment|/*              fr(I)    - filter rule from which group is referenced       */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is called whenever a reference to a group is to be dropped */
end_comment

begin_comment
comment|/* and thus its reference count needs to be lowered and the group free'd if */
end_comment

begin_comment
comment|/* the reference count reaches zero. Passing in fr is really for the sole   */
end_comment

begin_comment
comment|/* purpose of knowing when the head rule is being deleted.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_group_del
parameter_list|(
name|softc
parameter_list|,
name|group
parameter_list|,
name|fr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frgroup_t
modifier|*
name|group
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
if|if
condition|(
name|group
operator|->
name|fg_head
operator|==
name|fr
condition|)
name|group
operator|->
name|fg_head
operator|=
name|NULL
expr_stmt|;
name|group
operator|->
name|fg_ref
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|group
operator|->
name|fg_ref
operator|==
literal|0
operator|)
operator|&&
operator|(
name|group
operator|->
name|fg_start
operator|==
name|NULL
operator|)
condition|)
name|ipf_group_free
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_group_free                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  group(I) - pointer to filter rule group                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove the group from the list of groups and free it.                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_group_free
parameter_list|(
name|group
parameter_list|)
name|frgroup_t
modifier|*
name|group
decl_stmt|;
block|{
name|frgroup_t
modifier|*
modifier|*
name|gp
decl_stmt|;
for|for
control|(
name|gp
operator|=
name|group
operator|->
name|fg_set
init|;
operator|*
name|gp
operator|!=
name|NULL
condition|;
name|gp
operator|=
operator|&
operator|(
operator|*
name|gp
operator|)
operator|->
name|fg_next
control|)
block|{
if|if
condition|(
operator|*
name|gp
operator|==
name|group
condition|)
block|{
operator|*
name|gp
operator|=
name|group
operator|->
name|fg_next
expr_stmt|;
break|break;
block|}
block|}
name|KFREE
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_group_flush                                             */
end_comment

begin_comment
comment|/* Returns:     int      - number of rules flush from group                 */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/* Parameters:  group(I) - pointer to filter rule group                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove all of the rules that currently are listed under the given group. */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_group_flush
parameter_list|(
name|softc
parameter_list|,
name|group
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frgroup_t
modifier|*
name|group
decl_stmt|;
block|{
name|int
name|gone
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|ipf_flushlist
argument_list|(
name|softc
argument_list|,
operator|&
name|gone
argument_list|,
operator|&
name|group
operator|->
name|fg_start
argument_list|)
expr_stmt|;
return|return
name|gone
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_getrulen                                                */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - NULL == not found, else pointer to rule n     */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/* Parameters:  unit(I)  - device for which to count the rule's number      */
end_comment

begin_comment
comment|/*              flags(I) - which set of rules to find the rule in           */
end_comment

begin_comment
comment|/*              group(I) - group name                                       */
end_comment

begin_comment
comment|/*              n(I)     - rule number to find                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Find rule # n in group # g and return a pointer to it.  Return NULl if   */
end_comment

begin_comment
comment|/* group # g doesn't exist or there are less than n rules in the group.     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|ipf_getrulen
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|group
parameter_list|,
name|n
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|u_32_t
name|n
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|fg
operator|=
name|ipf_findgroup
argument_list|(
name|softc
argument_list|,
name|group
argument_list|,
name|unit
argument_list|,
name|softc
operator|->
name|ipf_active
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|fr
operator|=
name|fg
operator|->
name|fg_start
init|;
name|fr
operator|&&
name|n
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
operator|,
name|n
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_flushlist                                               */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of flushed rules                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I)   - pointer to soft context main structure         */
end_comment

begin_comment
comment|/*              nfreedp(O) - pointer to int where flush count is stored     */
end_comment

begin_comment
comment|/*              listp(I)   - pointer to list to flush pointer               */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Recursively flush rules from the list, descending groups as they are     */
end_comment

begin_comment
comment|/* encountered.  if a rule is the head of a group and it has lost all its   */
end_comment

begin_comment
comment|/* group members, then also delete the group reference.  nfreedp is needed  */
end_comment

begin_comment
comment|/* to store the accumulating count of rules removed, whereas the returned   */
end_comment

begin_comment
comment|/* value is just the number removed from the current list.  The latter is   */
end_comment

begin_comment
comment|/* needed to correctly adjust reference counts on rules that define groups. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: Rules not loaded from user space cannot be flushed.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_flushlist
parameter_list|(
name|softc
parameter_list|,
name|nfreedp
parameter_list|,
name|listp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
modifier|*
name|nfreedp
decl_stmt|;
name|frentry_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|freed
init|=
literal|0
decl_stmt|;
name|frentry_t
modifier|*
name|fp
decl_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
operator|*
name|listp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_type
operator|&
name|FR_T_BUILTIN
operator|)
operator|||
operator|!
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_COPIED
operator|)
condition|)
block|{
name|listp
operator|=
operator|&
name|fp
operator|->
name|fr_next
expr_stmt|;
continue|continue;
block|}
operator|*
name|listp
operator|=
name|fp
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_next
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|fr_next
operator|->
name|fr_pnext
operator|=
name|fp
operator|->
name|fr_pnext
expr_stmt|;
name|fp
operator|->
name|fr_pnext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_grphead
operator|!=
name|NULL
condition|)
block|{
name|freed
operator|+=
name|ipf_group_flush
argument_list|(
name|softc
argument_list|,
name|fp
operator|->
name|fr_grphead
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_names
index|[
name|fp
operator|->
name|fr_grhead
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_icmpgrp
operator|!=
name|NULL
condition|)
block|{
name|freed
operator|+=
name|ipf_group_flush
argument_list|(
name|softc
argument_list|,
name|fp
operator|->
name|fr_icmpgrp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_names
index|[
name|fp
operator|->
name|fr_icmphead
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_srctrack
operator|.
name|ht_max_nodes
condition|)
name|ipf_rb_ht_flush
argument_list|(
operator|&
name|fp
operator|->
name|fr_srctrack
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|fp
operator|->
name|fr_ref
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|fp
argument_list|)
operator|==
literal|0
condition|)
name|freed
operator|++
expr_stmt|;
block|}
operator|*
name|nfreedp
operator|+=
name|freed
expr_stmt|;
return|return
name|freed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_flush                                                   */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of flushed rules                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              unit(I)  - device for which to flush rules                  */
end_comment

begin_comment
comment|/*              flags(I) - which set of rules to flush                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Calls flushlist() for all filter rules (accounting, firewall - both IPv4 */
end_comment

begin_comment
comment|/* and IPv6) as defined by the value of flags.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_flush
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|flags
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|flushed
init|=
literal|0
decl_stmt|,
name|set
decl_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|set
operator|=
name|softc
operator|->
name|ipf_active
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FR_INACTIVE
operator|)
operator|==
name|FR_INACTIVE
condition|)
name|set
operator|=
literal|1
operator|-
name|set
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FR_OUTQUE
condition|)
block|{
name|ipf_flushlist
argument_list|(
name|softc
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|softc
operator|->
name|ipf_rules
index|[
literal|1
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
name|ipf_flushlist
argument_list|(
name|softc
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|softc
operator|->
name|ipf_acct
index|[
literal|1
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FR_INQUE
condition|)
block|{
name|ipf_flushlist
argument_list|(
name|softc
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|softc
operator|->
name|ipf_rules
index|[
literal|0
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
name|ipf_flushlist
argument_list|(
name|softc
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|softc
operator|->
name|ipf_acct
index|[
literal|0
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
block|}
name|flushed
operator|+=
name|ipf_flush_groups
argument_list|(
name|softc
argument_list|,
operator|&
name|softc
operator|->
name|ipf_groups
index|[
name|unit
index|]
index|[
name|set
index|]
argument_list|,
name|flags
operator|&
operator|(
name|FR_INQUE
operator||
name|FR_OUTQUE
operator|)
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGIPF
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGCOUNT
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0
condition|)
name|flushed
operator|+=
name|tmp
expr_stmt|;
block|}
return|return
name|flushed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_flush_groups                                            */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of flushed rules                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - soft context pointerto work with                */
end_comment

begin_comment
comment|/*              grhead(I) - pointer to the start of the group list to flush */
end_comment

begin_comment
comment|/*              flags(I)  - which set of rules to flush                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walk through all of the groups under the given group head and remove all */
end_comment

begin_comment
comment|/* of those that match the flags passed in. The for loop here is bit more   */
end_comment

begin_comment
comment|/* complicated than usual because the removal of a rule with ipf_derefrule  */
end_comment

begin_comment
comment|/* may end up removing not only the structure pointed to by "fg" but also   */
end_comment

begin_comment
comment|/* what is fg_next and fg_next after that. So if a filter rule is actually  */
end_comment

begin_comment
comment|/* removed from the group then it is necessary to start again.              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_flush_groups
parameter_list|(
name|softc
parameter_list|,
name|grhead
parameter_list|,
name|flags
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frgroup_t
modifier|*
modifier|*
name|grhead
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|,
modifier|*
modifier|*
name|frp
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|,
modifier|*
modifier|*
name|fgp
decl_stmt|;
name|int
name|flushed
init|=
literal|0
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|fgp
operator|=
name|grhead
init|;
operator|(
name|fg
operator|=
operator|*
name|fgp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|fg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|fg
operator|->
name|fg_flags
operator|&
name|flags
operator|)
operator|==
literal|0
operator|)
condition|)
name|fg
operator|=
name|fg
operator|->
name|fg_next
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
break|break;
name|removed
operator|=
literal|0
expr_stmt|;
name|frp
operator|=
operator|&
name|fg
operator|->
name|fg_start
expr_stmt|;
while|while
condition|(
operator|(
name|removed
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fr
operator|=
operator|*
name|frp
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|flags
operator|)
operator|==
literal|0
condition|)
block|{
name|frp
operator|=
operator|&
name|fr
operator|->
name|fr_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fr
operator|->
name|fr_next
operator|!=
name|NULL
condition|)
name|fr
operator|->
name|fr_next
operator|->
name|fr_pnext
operator|=
name|fr
operator|->
name|fr_pnext
expr_stmt|;
operator|*
name|frp
operator|=
name|fr
operator|->
name|fr_next
expr_stmt|;
name|fr
operator|->
name|fr_pnext
operator|=
name|NULL
expr_stmt|;
name|fr
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
name|flushed
operator|++
expr_stmt|;
name|removed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed
operator|==
literal|0
condition|)
name|fgp
operator|=
operator|&
name|fg
operator|->
name|fg_next
expr_stmt|;
block|}
return|return
name|flushed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    memstr                                                      */
end_comment

begin_comment
comment|/* Returns:     char *  - NULL if failed, != NULL pointer to matching bytes */
end_comment

begin_comment
comment|/* Parameters:  src(I)  - pointer to byte sequence to match                 */
end_comment

begin_comment
comment|/*              dst(I)  - pointer to byte sequence to search                */
end_comment

begin_comment
comment|/*              slen(I) - match length                                      */
end_comment

begin_comment
comment|/*              dlen(I) - length available to search in                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search dst for a sequence of bytes matching those at src and extend for  */
end_comment

begin_comment
comment|/* slen bytes.                                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|char
modifier|*
name|memstr
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|slen
parameter_list|,
name|dlen
parameter_list|)
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|size_t
name|slen
decl_stmt|,
name|dlen
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|dlen
operator|>=
name|slen
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|dst
expr_stmt|;
break|break;
block|}
name|dst
operator|++
expr_stmt|;
name|dlen
operator|--
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_fixskip                                                 */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  listp(IO)    - pointer to start of list with skip rule      */
end_comment

begin_comment
comment|/*              rp(I)        - rule added/removed with skip in it.          */
end_comment

begin_comment
comment|/*              addremove(I) - adjustment (-1/+1) to make to skip count,    */
end_comment

begin_comment
comment|/*                             depending on whether a rule was just added   */
end_comment

begin_comment
comment|/*                             or removed.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Adjust all the rules in a list which would have skip'd past the position */
end_comment

begin_comment
comment|/* where we are inserting to skip to the right place given the change.      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_fixskip
parameter_list|(
name|listp
parameter_list|,
name|rp
parameter_list|,
name|addremove
parameter_list|)
name|frentry_t
modifier|*
modifier|*
name|listp
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|addremove
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rules
decl_stmt|,
name|rn
decl_stmt|;
name|frentry_t
modifier|*
name|fp
decl_stmt|;
name|rules
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
operator|*
name|listp
init|;
operator|(
name|fp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fp
operator|!=
name|rp
operator|)
condition|;
name|fp
operator|=
name|fp
operator|->
name|fr_next
control|)
name|rules
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
for|for
control|(
name|rn
operator|=
literal|0
operator|,
name|fp
operator|=
operator|*
name|listp
init|;
name|fp
operator|&&
operator|(
name|fp
operator|!=
name|rp
operator|)
condition|;
name|fp
operator|=
name|fp
operator|->
name|fr_next
operator|,
name|rn
operator|++
control|)
if|if
condition|(
name|FR_ISSKIP
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
operator|&&
operator|(
name|rn
operator|+
name|fp
operator|->
name|fr_arg
operator|>=
name|rules
operator|)
condition|)
name|fp
operator|->
name|fr_arg
operator|+=
name|addremove
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    count4bits                                                  */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of consecutive bits in input            */
end_comment

begin_comment
comment|/* Parameters:  ip(I) - 32bit IP address                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 ONLY                                                                */
end_comment

begin_comment
comment|/* count consecutive 1's in bit mask.  If the mask generated by counting    */
end_comment

begin_comment
comment|/* consecutive 1's is different to that passed, return -1, else return #    */
end_comment

begin_comment
comment|/* of bits.                                                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|count4bits
parameter_list|(
name|ip
parameter_list|)
name|u_32_t
name|ip
decl_stmt|;
block|{
name|u_32_t
name|ipn
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ip
operator|=
name|ipn
operator|=
name|ntohl
argument_list|(
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|ipn
operator|*=
literal|2
control|)
if|if
condition|(
name|ipn
operator|&
literal|0x80000000
condition|)
name|cnt
operator|++
expr_stmt|;
else|else
break|break;
name|ipn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
operator|,
name|j
operator|=
name|cnt
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|j
operator|--
control|)
block|{
name|ipn
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|ipn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ipn
operator|==
name|ip
condition|)
return|return
name|cnt
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    count6bits                                                  */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of consecutive bits in input            */
end_comment

begin_comment
comment|/* Parameters:  msk(I) - pointer to start of IPv6 bitmask                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 ONLY                                                                */
end_comment

begin_comment
comment|/* count consecutive 1's in bit mask.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_function
name|int
name|count6bits
parameter_list|(
name|msk
parameter_list|)
name|u_32_t
modifier|*
name|msk
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
name|u_32_t
name|j
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|3
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
if|if
condition|(
name|msk
index|[
name|k
index|]
operator|==
literal|0xffffffff
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
else|else
block|{
for|for
control|(
name|j
operator|=
name|msk
index|[
name|k
index|]
init|;
name|j
condition|;
name|j
operator|<<=
literal|1
control|)
if|if
condition|(
name|j
operator|&
literal|0x80000000
condition|)
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_synclist                                                */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = no failures, else indication of first failure  */
end_comment

begin_comment
comment|/* Parameters:  fr(I)  - start of filter list to sync interface names for   */
end_comment

begin_comment
comment|/*              ifp(I) - interface pointer for limiting sync lookups        */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walk through a list of filter rules and resolve any interface names into */
end_comment

begin_comment
comment|/* pointers.  Where dynamic addresses are used, also update the IP address  */
end_comment

begin_comment
comment|/* used in the rule.  The interface pointer is used to limit the lookups to */
end_comment

begin_comment
comment|/* a specific set of matching names if it is non-NULL.                      */
end_comment

begin_comment
comment|/* Errors can occur when resolving the destination name of to/dup-to fields */
end_comment

begin_comment
comment|/* when the name points to a pool and that pool doest not exist. If this    */
end_comment

begin_comment
comment|/* does happen then it is necessary to check if there are any lookup refs   */
end_comment

begin_comment
comment|/* that need to be dropped before returning with an error.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_synclist
parameter_list|(
name|softc
parameter_list|,
name|fr
parameter_list|,
name|ifp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|frt
decl_stmt|,
modifier|*
name|start
init|=
name|fr
decl_stmt|;
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|ifa
decl_stmt|;
name|int
name|v
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|fr
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fr
operator|->
name|fr_family
operator|==
name|AF_INET
condition|)
name|v
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|fr
operator|->
name|fr_family
operator|==
name|AF_INET6
condition|)
name|v
operator|=
literal|6
expr_stmt|;
else|else
name|v
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Lookup all the interface names that are part of the rule. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|!=
name|ifp
operator|)
condition|)
continue|continue;
if|if
condition|(
name|fr
operator|->
name|fr_ifnames
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|name
operator|=
name|FR_NAME
argument_list|(
name|fr
argument_list|,
name|fr_ifnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
condition|)
block|{
if|if
condition|(
name|fr
operator|->
name|fr_satype
operator|!=
name|FRI_NORMAL
operator|&&
name|fr
operator|->
name|fr_satype
operator|!=
name|FRI_LOOKUP
condition|)
block|{
name|ifa
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_sifpidx
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|ipf_ifpaddr
argument_list|(
name|softc
argument_list|,
name|v
argument_list|,
name|fr
operator|->
name|fr_satype
argument_list|,
name|ifa
argument_list|,
operator|&
name|fr
operator|->
name|fr_src6
argument_list|,
operator|&
name|fr
operator|->
name|fr_smsk6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|->
name|fr_datype
operator|!=
name|FRI_NORMAL
operator|&&
name|fr
operator|->
name|fr_datype
operator|!=
name|FRI_LOOKUP
condition|)
block|{
name|ifa
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_sifpidx
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|ipf_ifpaddr
argument_list|(
name|softc
argument_list|,
name|v
argument_list|,
name|fr
operator|->
name|fr_datype
argument_list|,
name|ifa
argument_list|,
operator|&
name|fr
operator|->
name|fr_dst6
argument_list|,
operator|&
name|fr
operator|->
name|fr_dmsk6
argument_list|)
expr_stmt|;
block|}
block|}
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdp
operator|->
name|fd_ptr
operator|==
name|ifp
operator|)
condition|)
block|{
name|error
operator|=
name|ipf_resolvedest
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
argument_list|,
name|fdp
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unwind
goto|;
block|}
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdp
operator|->
name|fd_ptr
operator|==
name|ifp
operator|)
condition|)
block|{
name|error
operator|=
name|ipf_resolvedest
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
argument_list|,
name|fdp
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unwind
goto|;
block|}
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_dif
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdp
operator|->
name|fd_ptr
operator|==
name|ifp
operator|)
condition|)
block|{
name|error
operator|=
name|ipf_resolvedest
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
argument_list|,
name|fdp
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unwind
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|fr
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_srcptr
operator|==
name|NULL
operator|)
condition|)
block|{
name|fr
operator|->
name|fr_srcptr
operator|=
name|ipf_lookup_res_num
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_srctype
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|fr
operator|->
name|fr_srcnum
argument_list|,
operator|&
name|fr
operator|->
name|fr_srcfunc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|fr
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_dstptr
operator|==
name|NULL
operator|)
condition|)
block|{
name|fr
operator|->
name|fr_dstptr
operator|=
name|ipf_lookup_res_num
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_dsttype
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|fr
operator|->
name|fr_dstnum
argument_list|,
operator|&
name|fr
operator|->
name|fr_dstfunc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|unwind
label|:
for|for
control|(
name|frt
operator|=
name|start
init|;
name|frt
operator|!=
name|fr
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|frt
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
operator|)
operator|&&
operator|(
name|frt
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
operator|)
operator|&&
operator|(
name|frt
operator|->
name|fr_srcptr
operator|!=
name|NULL
operator|)
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|frt
operator|->
name|fr_srctype
argument_list|,
name|frt
operator|->
name|fr_srcptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|frt
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
operator|)
operator|&&
operator|(
name|frt
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
operator|)
operator|&&
operator|(
name|frt
operator|->
name|fr_dstptr
operator|!=
name|NULL
operator|)
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|frt
operator|->
name|fr_dsttype
argument_list|,
name|frt
operator|->
name|fr_dstptr
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_sync                                                    */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ipf_sync() is called when we suspect that the interface list or          */
end_comment

begin_comment
comment|/* information about interfaces (like IP#) has changed.  Go through all     */
end_comment

begin_comment
comment|/* filter rules, NAT entries and the state table and check if anything      */
end_comment

begin_comment
comment|/* needs to be changed/updated.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_sync
parameter_list|(
name|softc
parameter_list|,
name|ifp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|SOLARIS
name|ipf_nat_sync
argument_list|(
name|softc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ipf_state_sync
argument_list|(
name|softc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ipf_lookup_sync
argument_list|(
name|softc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_acct
index|[
literal|0
index|]
index|[
name|softc
operator|->
name|ipf_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_acct
index|[
literal|1
index|]
index|[
name|softc
operator|->
name|ipf_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_rules
index|[
literal|0
index|]
index|[
name|softc
operator|->
name|ipf_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_rules
index|[
literal|1
index|]
index|[
name|softc
operator|->
name|ipf_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPL_LOGSIZE
condition|;
name|i
operator|++
control|)
block|{
name|frgroup_t
modifier|*
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
name|softc
operator|->
name|ipf_groups
index|[
name|i
index|]
index|[
literal|0
index|]
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|fg_next
control|)
operator|(
name|void
operator|)
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|g
operator|->
name|fg_start
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|softc
operator|->
name|ipf_groups
index|[
name|i
index|]
index|[
literal|1
index|]
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|fg_next
control|)
operator|(
name|void
operator|)
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|g
operator|->
name|fg_start
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * In the functions below, bcopy() is called because the pointer being  * copied _from_ in this instance is a pointer to a char buf (which could  * end up being unaligned) and on the kernel's local stack.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    copyinptr                                                   */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else failure                             */
end_comment

begin_comment
comment|/* Parameters:  src(I)  - pointer to the source address                     */
end_comment

begin_comment
comment|/*              dst(I)  - destination address                               */
end_comment

begin_comment
comment|/*              size(I) - number of bytes to copy                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy a block of data in from user space, given a pointer to the pointer  */
end_comment

begin_comment
comment|/* to start copying from (src) and a pointer to where to store it (dst).    */
end_comment

begin_comment
comment|/* NB: src - pointer to user space pointer, dst - kernel space pointer      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|copyinptr
parameter_list|(
name|softc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|size
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|ca
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
name|SOLARIS
name|error
operator|=
name|COPYIN
argument_list|(
name|src
argument_list|,
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
else|#
directive|else
name|bcopy
argument_list|(
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|COPYIN
argument_list|(
name|ca
argument_list|,
name|dst
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    copyoutptr                                                  */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else failure                             */
end_comment

begin_comment
comment|/* Parameters:  src(I)  - pointer to the source address                     */
end_comment

begin_comment
comment|/*              dst(I)  - destination address                               */
end_comment

begin_comment
comment|/*              size(I) - number of bytes to copy                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy a block of data out to user space, given a pointer to the pointer   */
end_comment

begin_comment
comment|/* to start copying from (src) and a pointer to where to store it (dst).    */
end_comment

begin_comment
comment|/* NB: src - kernel space pointer, dst - pointer to user space pointer.     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|copyoutptr
parameter_list|(
name|softc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|size
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|ca
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bcopy
argument_list|(
name|dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|COPYOUT
argument_list|(
name|src
argument_list|,
name|ca
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_lock                                                    */
end_comment

begin_comment
comment|/* Returns:     int      - 0 = success, else error                          */
end_comment

begin_comment
comment|/* Parameters:  data(I)  - pointer to lock value to set                     */
end_comment

begin_comment
comment|/*              lockp(O) - pointer to location to store old lock value      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Get the new value for the lock integer, set it and return the old value  */
end_comment

begin_comment
comment|/* in *lockp.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_lock
parameter_list|(
name|data
parameter_list|,
name|lockp
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
name|int
modifier|*
name|lockp
decl_stmt|;
block|{
name|int
name|arg
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|EFAULT
return|;
name|err
operator|=
name|BCOPYOUT
argument_list|(
name|lockp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lockp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|EFAULT
return|;
operator|*
name|lockp
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_getstat                                                 */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              fiop(I)  - pointer to ipfilter stats structure              */
end_comment

begin_comment
comment|/*              rev(I)   - version claim by program doing ioctl             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stores a copy of current pointers, counters, etc, in the friostat        */
end_comment

begin_comment
comment|/* structure.                                                               */
end_comment

begin_comment
comment|/* If IPFILTER_COMPAT is compiled, we pretend to be whatever version the    */
end_comment

begin_comment
comment|/* program is looking for. This ensure that validation of the version it    */
end_comment

begin_comment
comment|/* expects will always succeed. Thus kernels with IPFILTER_COMPAT will      */
end_comment

begin_comment
comment|/* allow older binaries to work but kernels without it will not.            */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|ipf_getstat
parameter_list|(
name|softc
parameter_list|,
name|fiop
parameter_list|,
name|rev
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|friostat_t
modifier|*
name|fiop
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softc
operator|->
name|ipf_stats
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fiop
operator|->
name|f_st
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_statistics_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGSTATE
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGNAT
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGIPF
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGAUTH
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fiop
operator|->
name|f_ipf
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|softc
operator|->
name|ipf_rules
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_acct
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|softc
operator|->
name|ipf_acct
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_ipf
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|softc
operator|->
name|ipf_rules
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|fiop
operator|->
name|f_acct
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|softc
operator|->
name|ipf_acct
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|fiop
operator|->
name|f_ipf
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|softc
operator|->
name|ipf_rules
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_acct
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|softc
operator|->
name|ipf_acct
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_ipf
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|softc
operator|->
name|ipf_rules
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|fiop
operator|->
name|f_acct
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|softc
operator|->
name|ipf_acct
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|fiop
operator|->
name|f_ticks
operator|=
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
name|fiop
operator|->
name|f_active
operator|=
name|softc
operator|->
name|ipf_active
expr_stmt|;
name|fiop
operator|->
name|f_froute
index|[
literal|0
index|]
operator|=
name|softc
operator|->
name|ipf_frouteok
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_froute
index|[
literal|1
index|]
operator|=
name|softc
operator|->
name|ipf_frouteok
index|[
literal|1
index|]
expr_stmt|;
name|fiop
operator|->
name|f_rb_no_mem
operator|=
name|softc
operator|->
name|ipf_rb_no_mem
expr_stmt|;
name|fiop
operator|->
name|f_rb_node_max
operator|=
name|softc
operator|->
name|ipf_rb_node_max
expr_stmt|;
name|fiop
operator|->
name|f_running
operator|=
name|softc
operator|->
name|ipf_running
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPL_LOGSIZE
condition|;
name|i
operator|++
control|)
block|{
name|fiop
operator|->
name|f_groups
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|softc
operator|->
name|ipf_groups
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_groups
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|softc
operator|->
name|ipf_groups
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|fiop
operator|->
name|f_log_ok
operator|=
name|ipf_log_logok
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|f_log_fail
operator|=
name|ipf_log_failures
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|f_logging
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|fiop
operator|->
name|f_log_ok
operator|=
literal|0
expr_stmt|;
name|fiop
operator|->
name|f_log_fail
operator|=
literal|0
expr_stmt|;
name|fiop
operator|->
name|f_logging
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fiop
operator|->
name|f_defpass
operator|=
name|softc
operator|->
name|ipf_pass
expr_stmt|;
name|fiop
operator|->
name|f_features
operator|=
name|ipf_features
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_COMPAT
name|sprintf
argument_list|(
name|fiop
operator|->
name|f_version
argument_list|,
literal|"IP Filter: v%d.%d.%d"
argument_list|,
operator|(
name|rev
operator|/
literal|1000000
operator|)
operator|%
literal|100
argument_list|,
operator|(
name|rev
operator|/
literal|10000
operator|)
operator|%
literal|100
argument_list|,
operator|(
name|rev
operator|/
literal|100
operator|)
operator|%
literal|100
argument_list|)
expr_stmt|;
else|#
directive|else
name|rev
operator|=
name|rev
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fiop
operator|->
name|f_version
argument_list|,
name|ipfilter_version
argument_list|,
sizeof|sizeof
argument_list|(
name|fiop
operator|->
name|f_version
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
name|int
name|icmptoicmp6types
index|[
name|ICMP_MAXTYPE
operator|+
literal|1
index|]
init|=
block|{
name|ICMP6_ECHO_REPLY
block|,
comment|/* 0: ICMP_ECHOREPLY */
operator|-
literal|1
block|,
comment|/* 1: UNUSED */
operator|-
literal|1
block|,
comment|/* 2: UNUSED */
name|ICMP6_DST_UNREACH
block|,
comment|/* 3: ICMP_UNREACH */
operator|-
literal|1
block|,
comment|/* 4: ICMP_SOURCEQUENCH */
name|ND_REDIRECT
block|,
comment|/* 5: ICMP_REDIRECT */
operator|-
literal|1
block|,
comment|/* 6: UNUSED */
operator|-
literal|1
block|,
comment|/* 7: UNUSED */
name|ICMP6_ECHO_REQUEST
block|,
comment|/* 8: ICMP_ECHO */
operator|-
literal|1
block|,
comment|/* 9: UNUSED */
operator|-
literal|1
block|,
comment|/* 10: UNUSED */
name|ICMP6_TIME_EXCEEDED
block|,
comment|/* 11: ICMP_TIMXCEED */
name|ICMP6_PARAM_PROB
block|,
comment|/* 12: ICMP_PARAMPROB */
operator|-
literal|1
block|,
comment|/* 13: ICMP_TSTAMP */
operator|-
literal|1
block|,
comment|/* 14: ICMP_TSTAMPREPLY */
operator|-
literal|1
block|,
comment|/* 15: ICMP_IREQ */
operator|-
literal|1
block|,
comment|/* 16: ICMP_IREQREPLY */
operator|-
literal|1
block|,
comment|/* 17: ICMP_MASKREQ */
operator|-
literal|1
block|,
comment|/* 18: ICMP_MASKREPLY */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icmptoicmp6unreach
index|[
name|ICMP_MAX_UNREACH
index|]
init|=
block|{
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 0: ICMP_UNREACH_NET */
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 1: ICMP_UNREACH_HOST */
operator|-
literal|1
block|,
comment|/* 2: ICMP_UNREACH_PROTOCOL */
name|ICMP6_DST_UNREACH_NOPORT
block|,
comment|/* 3: ICMP_UNREACH_PORT */
operator|-
literal|1
block|,
comment|/* 4: ICMP_UNREACH_NEEDFRAG */
name|ICMP6_DST_UNREACH_NOTNEIGHBOR
block|,
comment|/* 5: ICMP_UNREACH_SRCFAIL */
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 6: ICMP_UNREACH_NET_UNKNOWN */
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 7: ICMP_UNREACH_HOST_UNKNOWN */
operator|-
literal|1
block|,
comment|/* 8: ICMP_UNREACH_ISOLATED */
name|ICMP6_DST_UNREACH_ADMIN
block|,
comment|/* 9: ICMP_UNREACH_NET_PROHIB */
name|ICMP6_DST_UNREACH_ADMIN
block|,
comment|/* 10: ICMP_UNREACH_HOST_PROHIB */
operator|-
literal|1
block|,
comment|/* 11: ICMP_UNREACH_TOSNET */
operator|-
literal|1
block|,
comment|/* 12: ICMP_UNREACH_TOSHOST */
name|ICMP6_DST_UNREACH_ADMIN
block|,
comment|/* 13: ICMP_UNREACH_ADMIN_PROHIBIT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icmpreplytype6
index|[
name|ICMP6_MAXTYPE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|icmpreplytype4
index|[
name|ICMP_MAXTYPE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matchicmpqueryreply                                     */
end_comment

begin_comment
comment|/* Returns:     int - 1 if "icmp" is a valid reply to "ic" else 0.          */
end_comment

begin_comment
comment|/* Parameters:  v(I)    - IP protocol version (4 or 6)                      */
end_comment

begin_comment
comment|/*              ic(I)   - ICMP information                                  */
end_comment

begin_comment
comment|/*              icmp(I) - ICMP packet header                                */
end_comment

begin_comment
comment|/*              rev(I)  - direction (0 = forward/1 = reverse) of packet     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check if the ICMP packet defined by the header pointed to by icmp is a   */
end_comment

begin_comment
comment|/* reply to one as described by what's in ic.  If it is a match, return 1,  */
end_comment

begin_comment
comment|/* else return 0 for no match.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_matchicmpqueryreply
parameter_list|(
name|v
parameter_list|,
name|ic
parameter_list|,
name|icmp
parameter_list|,
name|rev
parameter_list|)
name|int
name|v
decl_stmt|;
name|icmpinfo_t
modifier|*
name|ic
decl_stmt|;
name|icmphdr_t
modifier|*
name|icmp
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|int
name|ictype
decl_stmt|;
name|ictype
operator|=
name|ic
operator|->
name|ici_type
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
comment|/* 		 * If we matched its type on the way in, then when going out 		 * it will still be the same type. 		 */
if|if
condition|(
operator|(
operator|!
name|rev
operator|&&
operator|(
name|icmp
operator|->
name|icmp_type
operator|==
name|ictype
operator|)
operator|)
operator|||
operator|(
name|rev
operator|&&
operator|(
name|icmpreplytype4
index|[
name|ictype
index|]
operator|==
name|icmp
operator|->
name|icmp_type
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|icmp
operator|->
name|icmp_type
operator|!=
name|ICMP_ECHOREPLY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|icmp
operator|->
name|icmp_id
operator|==
name|ic
operator|->
name|ici_id
condition|)
return|return
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|rev
operator|&&
operator|(
name|icmp
operator|->
name|icmp_type
operator|==
name|ictype
operator|)
operator|)
operator|||
operator|(
name|rev
operator|&&
operator|(
name|icmpreplytype6
index|[
name|ictype
index|]
operator|==
name|icmp
operator|->
name|icmp_type
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|icmp
operator|->
name|icmp_type
operator|!=
name|ICMP6_ECHO_REPLY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|icmp
operator|->
name|icmp_id
operator|==
name|ic
operator|->
name|ici_id
condition|)
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rule_compare                                            */
end_comment

begin_comment
comment|/* Parameters:  fr1(I) - first rule structure to compare                    */
end_comment

begin_comment
comment|/*              fr2(I) - second rule structure to compare                   */
end_comment

begin_comment
comment|/* Returns:     int    - 0 == rules are the same, else mismatch             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compare two rules and return 0 if they match or a number indicating      */
end_comment

begin_comment
comment|/* which of the individual checks failed.                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_rule_compare
parameter_list|(
name|frentry_t
modifier|*
name|fr1
parameter_list|,
name|frentry_t
modifier|*
name|fr2
parameter_list|)
block|{
if|if
condition|(
name|fr1
operator|->
name|fr_cksum
operator|!=
name|fr2
operator|->
name|fr_cksum
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fr1
operator|->
name|fr_size
operator|!=
name|fr2
operator|->
name|fr_size
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|fr1
operator|->
name|fr_dsize
operator|!=
name|fr2
operator|->
name|fr_dsize
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fr1
operator|->
name|fr_func
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fr2
operator|->
name|fr_func
argument_list|,
name|fr1
operator|->
name|fr_size
operator|-
name|offsetof
argument_list|(
expr|struct
name|frentry
argument_list|,
name|fr_func
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|fr1
operator|->
name|fr_data
operator|&&
operator|!
name|fr2
operator|->
name|fr_data
condition|)
return|return
literal|5
return|;
if|if
condition|(
operator|!
name|fr1
operator|->
name|fr_data
operator|&&
name|fr2
operator|->
name|fr_data
condition|)
return|return
literal|6
return|;
if|if
condition|(
name|fr1
operator|->
name|fr_data
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|fr1
operator|->
name|fr_caddr
argument_list|,
name|fr2
operator|->
name|fr_caddr
argument_list|,
name|fr1
operator|->
name|fr_dsize
argument_list|)
condition|)
return|return
literal|7
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frrequest                                                   */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success,> 0 == errno value                      */
end_comment

begin_comment
comment|/* Parameters:  unit(I)     - device for which this is for                  */
end_comment

begin_comment
comment|/*              req(I)      - ioctl command (SIOC*)                         */
end_comment

begin_comment
comment|/*              data(I)     - pointr to ioctl data                          */
end_comment

begin_comment
comment|/*              set(I)      - 1 or 0 (filter set)                           */
end_comment

begin_comment
comment|/*              makecopy(I) - flag indicating whether data points to a rule */
end_comment

begin_comment
comment|/*                            in kernel space& hence doesn't need copying. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles all the requests which operate on the list of      */
end_comment

begin_comment
comment|/* filter rules.  This includes adding, deleting, insertion.  It is also    */
end_comment

begin_comment
comment|/* responsible for creating groups when a "head" rule is loaded.  Interface */
end_comment

begin_comment
comment|/* names are resolved here and other sanity checks are made on the content  */
end_comment

begin_comment
comment|/* of the rule structure being loaded.  If a rule has user defined timeouts */
end_comment

begin_comment
comment|/* then make sure they are created and initialised before exiting.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|frrequest
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|req
parameter_list|,
name|data
parameter_list|,
name|set
parameter_list|,
name|makecopy
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|ioctlcmd_t
name|req
decl_stmt|;
name|int
name|set
decl_stmt|,
name|makecopy
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|in
decl_stmt|,
name|family
decl_stmt|,
name|addrem
decl_stmt|,
name|need_free
init|=
literal|0
decl_stmt|;
name|frentry_t
name|frd
decl_stmt|,
modifier|*
name|fp
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|fprev
decl_stmt|,
modifier|*
modifier|*
name|ftail
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|uptr
decl_stmt|,
modifier|*
name|cptr
decl_stmt|;
name|u_int
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
name|cptr
operator|=
name|NULL
expr_stmt|;
name|fg
operator|=
name|NULL
expr_stmt|;
name|fp
operator|=
operator|&
name|frd
expr_stmt|;
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frd
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
name|fp
argument_list|,
name|IPFOBJ_FRENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_type
operator|&
name|FR_T_BUILTIN
operator|)
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|KMALLOCS
argument_list|(
name|f
argument_list|,
name|frentry_t
operator|*
argument_list|,
name|fp
operator|->
name|fr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|131
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bzero
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|fr_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_inobjsz
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|f
argument_list|,
name|IPFOBJ_FRENTRY
argument_list|,
name|fp
operator|->
name|fr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|KFREES
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|fr_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fp
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_dnext
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_pnext
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_pdnext
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_grp
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_grphead
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_icmpgrp
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_isc
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|fr_ptr
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fr_ref
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fr_flags
operator||=
name|FR_COPIED
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
operator|(
name|frentry_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_type
operator|&
name|FR_T_BUILTIN
operator|)
operator|==
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|fp
operator|->
name|fr_flags
operator|&=
operator|~
name|FR_COPIED
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|fp
operator|->
name|fr_dsize
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_data
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|fr_dsize
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_data
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
name|family
operator|=
name|fp
operator|->
name|fr_family
expr_stmt|;
name|uptr
operator|=
name|fp
operator|->
name|fr_data
expr_stmt|;
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINIFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADIFR
condition|)
name|addrem
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCRMAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCRMIFR
condition|)
name|addrem
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCZRLST
condition|)
name|addrem
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|IPFERROR
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
comment|/* 	 * Only filter rules for IPv4 or IPv6 are accepted. 	 */
if|if
condition|(
name|family
operator|==
name|AF_INET
condition|)
block|{
comment|/*EMPTY*/
empty_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
block|}
elseif|else
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
block|{
comment|/*EMPTY*/
empty_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|family
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
comment|/* 	 * If the rule is being loaded from user space, i.e. we had to copy it 	 * into kernel space, then do not trust the function pointer in the 	 * rule. 	 */
if|if
condition|(
operator|(
name|makecopy
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_func
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_findfunc
argument_list|(
name|fp
operator|->
name|fr_func
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
if|if
condition|(
name|addrem
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ipf_funcinit
argument_list|(
name|softc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|donenolock
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_CALLNOW
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|->
name|fr_func
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_func
operator|==
operator|(
name|ipfunc_t
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|142
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_CMDMASK
operator|)
operator|==
name|FR_CALL
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|->
name|fr_func
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_func
operator|==
operator|(
name|ipfunc_t
operator|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|143
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
name|ptr
operator|=
name|NULL
expr_stmt|;
name|cptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|unit
operator|=
name|IPL_LOGCOUNT
expr_stmt|;
comment|/* 	 * Check that each group name in the rule has a start index that 	 * is valid. 	 */
if|if
condition|(
name|fp
operator|->
name|fr_icmphead
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_icmphead
operator|<
literal|0
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_icmphead
operator|>=
name|fp
operator|->
name|fr_namelen
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|136
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|FR_NAME
argument_list|(
name|fp
argument_list|,
name|fr_icmphead
argument_list|)
argument_list|,
literal|"0"
argument_list|)
condition|)
name|fp
operator|->
name|fr_names
index|[
name|fp
operator|->
name|fr_icmphead
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_grhead
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_grhead
operator|<
literal|0
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_grhead
operator|>=
name|fp
operator|->
name|fr_namelen
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|137
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|FR_NAME
argument_list|(
name|fp
argument_list|,
name|fr_grhead
argument_list|)
argument_list|,
literal|"0"
argument_list|)
condition|)
name|fp
operator|->
name|fr_names
index|[
name|fp
operator|->
name|fr_grhead
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_group
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_group
operator|<
literal|0
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_group
operator|>=
name|fp
operator|->
name|fr_namelen
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|138
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
if|if
condition|(
operator|(
name|req
operator|!=
operator|(
name|int
operator|)
name|SIOCZRLST
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_group
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 			 * Allow loading rules that are in groups to cause 			 * them to be created if they don't already exit. 			 */
name|group
operator|=
name|FR_NAME
argument_list|(
name|fp
argument_list|,
name|fr_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrem
operator|==
literal|0
condition|)
block|{
name|fg
operator|=
name|ipf_group_add
argument_list|(
name|softc
argument_list|,
name|group
argument_list|,
name|NULL
argument_list|,
name|fp
operator|->
name|fr_flags
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_grp
operator|=
name|fg
expr_stmt|;
block|}
else|else
block|{
name|fg
operator|=
name|ipf_findgroup
argument_list|(
name|softc
argument_list|,
name|group
argument_list|,
name|unit
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
if|if
condition|(
name|fg
operator|->
name|fg_flags
operator|==
literal|0
condition|)
block|{
name|fg
operator|->
name|fg_flags
operator|=
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fg
operator|->
name|fg_flags
operator|!=
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INOUT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * If a rule is going to be part of a group then it does 		 * not matter whether it is an in or out rule, but if it 		 * isn't in a group, then it does... 		 */
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
operator|(
name|FR_INQUE
operator||
name|FR_OUTQUE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
name|in
operator|=
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INQUE
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* 	 * Work out which rule list this change is being applied to. 	 */
name|ftail
operator|=
name|NULL
expr_stmt|;
name|fprev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGAUTH
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_tifs
index|[
literal|0
index|]
operator|.
name|fd_ptr
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_tifs
index|[
literal|1
index|]
operator|.
name|fd_ptr
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_dif
operator|.
name|fd_ptr
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_FASTROUTE
operator|)
condition|)
block|{
name|softc
operator|->
name|ipf_interror
operator|=
literal|145
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
name|fprev
operator|=
name|ipf_auth_rulehead
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|fprev
operator|=
operator|&
name|softc
operator|->
name|ipf_acct
index|[
name|in
index|]
index|[
name|set
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
operator|(
name|FR_OUTQUE
operator||
name|FR_INQUE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fprev
operator|=
operator|&
name|softc
operator|->
name|ipf_rules
index|[
name|in
index|]
index|[
name|set
index|]
expr_stmt|;
block|}
if|if
condition|(
name|fprev
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
name|fprev
operator|=
operator|&
name|fg
operator|->
name|fg_start
expr_stmt|;
comment|/* 	 * Copy in extra data for the rule. 	 */
if|if
condition|(
name|fp
operator|->
name|fr_dsize
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
block|{
name|KMALLOCS
argument_list|(
name|ptr
argument_list|,
name|void
operator|*
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
comment|/* 			 * The bcopy case is for when the data is appended 			 * to the rule by ipf_in_compat(). 			 */
if|if
condition|(
name|uptr
operator|>=
operator|(
name|void
operator|*
operator|)
name|fp
operator|&&
name|uptr
operator|<
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|+
name|fp
operator|->
name|fr_size
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|uptr
argument_list|,
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|COPYIN
argument_list|(
name|uptr
argument_list|,
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
block|}
else|else
block|{
name|ptr
operator|=
name|uptr
expr_stmt|;
block|}
name|fp
operator|->
name|fr_data
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|fr_data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Perform per-rule type sanity checks of their members. 	 * All code after this needs to be aware that allocated memory 	 * may need to be free'd before exiting. 	 */
switch|switch
condition|(
name|fp
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_BPF
argument_list|)
case|case
name|FR_T_BPFOPC
case|:
if|if
condition|(
name|fp
operator|->
name|fr_dsize
operator|==
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|19
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bpf_validate
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_insn
argument_list|)
argument_list|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
case|case
name|FR_T_IPF
case|:
comment|/* 		 * Preparation for error case at the bottom of this function. 		 */
if|if
condition|(
name|fp
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
condition|)
name|fp
operator|->
name|fr_dstptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
condition|)
name|fp
operator|->
name|fr_srcptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_dsize
operator|!=
sizeof|sizeof
argument_list|(
name|fripf_t
argument_list|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|21
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Allowing a rule with both "keep state" and "with oow" is 		 * pointless because adding a state entry to the table will 		 * fail with the out of window (oow) flag set. 		 */
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_flx
operator|&
name|FI_OOW
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|fp
operator|->
name|fr_satype
condition|)
block|{
case|case
name|FRI_BROADCAST
case|:
case|case
name|FRI_DYNAMIC
case|:
case|case
name|FRI_NETWORK
case|:
case|case
name|FRI_NETMASKED
case|:
case|case
name|FRI_PEERADDR
case|:
if|if
condition|(
name|fp
operator|->
name|fr_sifpidx
operator|<
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|23
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FRI_LOOKUP
case|:
name|fp
operator|->
name|fr_srcptr
operator|=
name|ipf_findlookup
argument_list|(
name|softc
argument_list|,
name|unit
argument_list|,
name|fp
argument_list|,
operator|&
name|fp
operator|->
name|fr_src6
argument_list|,
operator|&
name|fp
operator|->
name|fr_smsk6
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_srcfunc
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|132
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FRI_NORMAL
case|:
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|133
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
switch|switch
condition|(
name|fp
operator|->
name|fr_datype
condition|)
block|{
case|case
name|FRI_BROADCAST
case|:
case|case
name|FRI_DYNAMIC
case|:
case|case
name|FRI_NETWORK
case|:
case|case
name|FRI_NETMASKED
case|:
case|case
name|FRI_PEERADDR
case|:
if|if
condition|(
name|fp
operator|->
name|fr_difpidx
operator|<
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FRI_LOOKUP
case|:
name|fp
operator|->
name|fr_dstptr
operator|=
name|ipf_findlookup
argument_list|(
name|softc
argument_list|,
name|unit
argument_list|,
name|fp
argument_list|,
operator|&
name|fp
operator|->
name|fr_dst6
argument_list|,
operator|&
name|fp
operator|->
name|fr_dmsk6
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_dstfunc
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|134
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
break|break;
case|case
name|FRI_NORMAL
case|:
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|135
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|FR_T_NONE
case|:
case|case
name|FR_T_CALLFUNC
case|:
case|case
name|FR_T_COMPIPF
case|:
break|break;
case|case
name|FR_T_IPFEXPR
case|:
if|if
condition|(
name|ipf_matcharray_verify
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|IPFERROR
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|donenolock
goto|;
if|if
condition|(
name|fp
operator|->
name|fr_tif
operator|.
name|fd_name
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_tif
operator|.
name|fd_name
operator|<
literal|0
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_tif
operator|.
name|fd_name
operator|>=
name|fp
operator|->
name|fr_namelen
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|139
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|fr_dif
operator|.
name|fd_name
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_dif
operator|.
name|fd_name
operator|<
literal|0
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_dif
operator|.
name|fd_name
operator|>=
name|fp
operator|->
name|fr_namelen
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|140
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|fr_rif
operator|.
name|fd_name
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_rif
operator|.
name|fd_name
operator|<
literal|0
operator|)
operator|||
operator|(
name|fp
operator|->
name|fr_rif
operator|.
name|fd_name
operator|>=
name|fp
operator|->
name|fr_namelen
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|141
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|donenolock
goto|;
block|}
block|}
comment|/* 	 * Lookup all the interface names that are part of the rule. 	 */
name|error
operator|=
name|ipf_synclist
argument_list|(
name|softc
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|donenolock
goto|;
name|fp
operator|->
name|fr_statecnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_srctrack
operator|.
name|ht_max_nodes
operator|!=
literal|0
condition|)
name|ipf_rb_ht_init
argument_list|(
operator|&
name|fp
operator|->
name|fr_srctrack
argument_list|)
expr_stmt|;
comment|/* 	 * Look for an existing matching filter rule, but don't include the 	 * next or interface pointer in the comparison (fr_next, fr_ifa). 	 * This elminates rules which are indentical being loaded.  Checksum 	 * the constant part of the filter rule to make comparisons quicker 	 * (this meaning no pointers are included). 	 */
for|for
control|(
name|fp
operator|->
name|fr_cksum
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_func
operator|,
name|pp
operator|=
operator|&
name|fp
operator|->
name|fr_cksum
init|;
name|p
operator|<
name|pp
condition|;
name|p
operator|++
control|)
name|fp
operator|->
name|fr_cksum
operator|+=
operator|*
name|p
expr_stmt|;
name|pp
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|(
name|fp
operator|->
name|fr_caddr
operator|+
name|fp
operator|->
name|fr_dsize
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|u_int
operator|*
operator|)
name|fp
operator|->
name|fr_data
init|;
name|p
operator|<
name|pp
condition|;
name|p
operator|++
control|)
name|fp
operator|->
name|fr_cksum
operator|+=
operator|*
name|p
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the filter rule lists are locked, we can walk the 	 * chain of them without fear. 	 */
name|ftail
operator|=
name|fprev
expr_stmt|;
for|for
control|(
name|f
operator|=
operator|*
name|ftail
init|;
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
operator|!=
name|NULL
condition|;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_collect
operator|<=
name|f
operator|->
name|fr_collect
condition|)
block|{
name|ftail
operator|=
name|fprev
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|fprev
operator|=
name|ftail
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
operator|!=
name|NULL
condition|;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|ipf_rule_compare
argument_list|(
name|fp
argument_list|,
name|f
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If zero'ing statistics, copy current to caller and zero. 	 */
if|if
condition|(
name|addrem
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Copy and reduce lock because of impending copyout. 			 * Well we should, but if we do then the atomicity of 			 * this call and the correctness of fr_hits and 			 * fr_bytes cannot be guaranteed.  As it is, this code 			 * only resets them to 0 if they are successfully 			 * copied out into user space. 			 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
name|f
operator|->
name|fr_size
argument_list|)
expr_stmt|;
comment|/* MUTEX_DOWNGRADE(&softc->ipf_mutex); */
comment|/* 			 * When we copy this rule back out, set the data 			 * pointer to be what it was in user space. 			 */
name|fp
operator|->
name|fr_data
operator|=
name|uptr
expr_stmt|;
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|fp
argument_list|,
name|IPFOBJ_FRENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|fr_dsize
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|uptr
operator|!=
name|NULL
operator|)
condition|)
name|error
operator|=
name|COPYOUT
argument_list|(
name|f
operator|->
name|fr_data
argument_list|,
name|uptr
argument_list|,
name|f
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|28
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|f
operator|->
name|fr_hits
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|fr_bytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
name|KFREES
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|fr_size
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/* 		 * At the end of this, ftail must point to the place where the 		 * new rule is to be saved/inserted/added. 		 * For SIOCAD*FR, this should be the last rule in the group of 		 * rules that have equal fr_collect fields. 		 * For SIOCIN*FR, ... 		 */
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADIFR
condition|)
block|{
for|for
control|(
name|ftail
operator|=
name|fprev
init|;
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_collect
operator|>
name|fp
operator|->
name|fr_collect
condition|)
break|break;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
name|fprev
operator|=
name|ftail
expr_stmt|;
block|}
name|ftail
operator|=
name|fprev
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINIFR
condition|)
block|{
while|while
condition|(
operator|(
name|f
operator|=
operator|*
name|fprev
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_collect
operator|>=
name|fp
operator|->
name|fr_collect
condition|)
break|break;
name|fprev
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
name|ftail
operator|=
name|fprev
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_hits
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|fp
operator|->
name|fr_hits
operator|&&
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_collect
operator|!=
name|fp
operator|->
name|fr_collect
condition|)
break|break;
name|fprev
operator|=
name|ftail
expr_stmt|;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
name|fp
operator|->
name|fr_hits
operator|--
expr_stmt|;
block|}
block|}
name|f
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Request to remove a rule. 	 */
if|if
condition|(
name|addrem
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|IPFERROR
argument_list|(
literal|29
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Do not allow activity from user space to interfere 			 * with rules not loaded that way. 			 */
if|if
condition|(
operator|(
name|makecopy
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
name|f
operator|->
name|fr_flags
operator|&
name|FR_COPIED
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * Return EBUSY if the rule is being reference by 			 * something else (eg state information.) 			 */
if|if
condition|(
name|f
operator|->
name|fr_ref
operator|>
literal|1
condition|)
block|{
name|IPFERROR
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
name|f
operator|->
name|fr_isctag
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|f
operator|->
name|fr_isc
operator|!=
operator|(
expr|struct
name|ipscan
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
name|ipf_scan_detachfr
argument_list|(
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unit
operator|==
name|IPL_LOGAUTH
condition|)
block|{
name|error
operator|=
name|ipf_auth_precmd
argument_list|(
name|softc
argument_list|,
name|req
argument_list|,
name|f
argument_list|,
name|ftail
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ipf_rule_delete
argument_list|(
name|softc
argument_list|,
name|f
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|need_free
operator|=
name|makecopy
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Not removing, so we must be adding/inserting a rule. 		 */
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|unit
operator|==
name|IPL_LOGAUTH
condition|)
block|{
name|error
operator|=
name|ipf_auth_precmd
argument_list|(
name|softc
argument_list|,
name|req
argument_list|,
name|fp
argument_list|,
name|ftail
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|MUTEX_NUKE
argument_list|(
operator|&
name|fp
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|fp
operator|->
name|fr_lock
argument_list|,
literal|"filter rule lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_die
operator|!=
literal|0
condition|)
name|ipf_rule_expire_insert
argument_list|(
name|softc
argument_list|,
name|fp
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_hits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
name|fp
operator|->
name|fr_ref
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|fr_pnext
operator|=
name|ftail
expr_stmt|;
name|fp
operator|->
name|fr_next
operator|=
operator|*
name|ftail
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_next
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|fr_next
operator|->
name|fr_pnext
operator|=
operator|&
name|fp
operator|->
name|fr_next
expr_stmt|;
operator|*
name|ftail
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|addrem
operator|==
literal|0
condition|)
name|ipf_fixskip
argument_list|(
name|ftail
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_icmpgrp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_icmphead
operator|!=
operator|-
literal|1
condition|)
block|{
name|group
operator|=
name|FR_NAME
argument_list|(
name|fp
argument_list|,
name|fr_icmphead
argument_list|)
expr_stmt|;
name|fg
operator|=
name|ipf_group_add
argument_list|(
name|softc
argument_list|,
name|group
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_icmpgrp
operator|=
name|fg
expr_stmt|;
block|}
name|fp
operator|->
name|fr_grphead
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_grhead
operator|!=
operator|-
literal|1
condition|)
block|{
name|group
operator|=
name|FR_NAME
argument_list|(
name|fp
argument_list|,
name|fr_grhead
argument_list|)
expr_stmt|;
name|fg
operator|=
name|ipf_group_add
argument_list|(
name|softc
argument_list|,
name|group
argument_list|,
name|fp
argument_list|,
name|fp
operator|->
name|fr_flags
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_grphead
operator|=
name|fg
expr_stmt|;
block|}
block|}
name|done
label|:
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|donenolock
label|:
if|if
condition|(
name|need_free
operator|||
operator|(
name|error
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_srcptr
operator|!=
name|NULL
operator|)
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|fp
operator|->
name|fr_srctype
argument_list|,
name|fp
operator|->
name|fr_srcptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_dstptr
operator|!=
name|NULL
operator|)
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|fp
operator|->
name|fr_dsttype
argument_list|,
name|fp
operator|->
name|fr_dstptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_grp
operator|!=
name|NULL
condition|)
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|ipf_group_del
argument_list|(
name|softc
argument_list|,
name|fp
operator|->
name|fr_grp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|makecopy
operator|!=
literal|0
operator|)
condition|)
block|{
name|KFREES
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
name|KFREES
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|fr_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_rule_delete                                              */
end_comment

begin_comment
comment|/* Returns:    Nil                                                          */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*             f(I)     - pointer to the rule being deleted                 */
end_comment

begin_comment
comment|/*             ftail(I) - pointer to the pointer to f                       */
end_comment

begin_comment
comment|/*             unit(I)  - device for which this is for                      */
end_comment

begin_comment
comment|/*             set(I)   - 1 or 0 (filter set)                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function attempts to do what it can to delete a filter rule: remove */
end_comment

begin_comment
comment|/* it from any linked lists and remove any groups it is responsible for.    */
end_comment

begin_comment
comment|/* But in the end, removing a rule can only drop the reference count - we   */
end_comment

begin_comment
comment|/* must use that as the guide for whether or not it can be freed.           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_rule_delete
parameter_list|(
name|softc
parameter_list|,
name|f
parameter_list|,
name|unit
parameter_list|,
name|set
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|f
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|set
decl_stmt|;
block|{
comment|/* 	 * If fr_pdnext is set, then the rule is on the expire list, so 	 * remove it from there. 	 */
if|if
condition|(
name|f
operator|->
name|fr_pdnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|f
operator|->
name|fr_pdnext
operator|=
name|f
operator|->
name|fr_dnext
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fr_dnext
operator|!=
name|NULL
condition|)
name|f
operator|->
name|fr_dnext
operator|->
name|fr_pdnext
operator|=
name|f
operator|->
name|fr_pdnext
expr_stmt|;
name|f
operator|->
name|fr_pdnext
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|fr_dnext
operator|=
name|NULL
expr_stmt|;
block|}
name|ipf_fixskip
argument_list|(
name|f
operator|->
name|fr_pnext
argument_list|,
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fr_pnext
operator|!=
name|NULL
condition|)
operator|*
name|f
operator|->
name|fr_pnext
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fr_next
operator|!=
name|NULL
condition|)
name|f
operator|->
name|fr_next
operator|->
name|fr_pnext
operator|=
name|f
operator|->
name|fr_pnext
expr_stmt|;
name|f
operator|->
name|fr_pnext
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_rule_expire_insert                                       */
end_comment

begin_comment
comment|/* Returns:    Nil                                                          */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*             f(I)     - pointer to rule to be added to expire list        */
end_comment

begin_comment
comment|/*             set(I)   - 1 or 0 (filter set)                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If the new rule has a given expiration time, insert it into the list of  */
end_comment

begin_comment
comment|/* expiring rules with the ones to be removed first added to the front of   */
end_comment

begin_comment
comment|/* the list. The insertion is O(n) but it is kept sorted for quick scans at */
end_comment

begin_comment
comment|/* expiration interval checks.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_rule_expire_insert
parameter_list|(
name|softc
parameter_list|,
name|f
parameter_list|,
name|set
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|f
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
comment|/* 	 */
name|f
operator|->
name|fr_die
operator|=
name|softc
operator|->
name|ipf_ticks
operator|+
name|IPF_TTLVAL
argument_list|(
name|f
operator|->
name|fr_die
argument_list|)
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|softc
operator|->
name|ipf_rule_explist
index|[
name|set
index|]
init|;
name|fr
operator|!=
name|NULL
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_dnext
control|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_die
operator|<
name|fr
operator|->
name|fr_die
condition|)
break|break;
if|if
condition|(
name|fr
operator|->
name|fr_dnext
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We've got to the last rule and everything 			 * wanted to be expired before this new node, 			 * so we have to tack it on the end... 			 */
name|fr
operator|->
name|fr_dnext
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|fr_pdnext
operator|=
operator|&
name|fr
operator|->
name|fr_dnext
expr_stmt|;
name|fr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_rule_explist
index|[
name|set
index|]
operator|==
name|NULL
condition|)
block|{
name|softc
operator|->
name|ipf_rule_explist
index|[
name|set
index|]
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|fr_pdnext
operator|=
operator|&
name|softc
operator|->
name|ipf_rule_explist
index|[
name|set
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|f
operator|->
name|fr_dnext
operator|=
name|fr
expr_stmt|;
name|f
operator|->
name|fr_pdnext
operator|=
name|fr
operator|->
name|fr_pdnext
expr_stmt|;
name|fr
operator|->
name|fr_pdnext
operator|=
operator|&
name|f
operator|->
name|fr_dnext
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_findlookup                                               */
end_comment

begin_comment
comment|/* Returns:    NULL = failure, else success                                 */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*             unit(I)  - ipf device we want to find match for              */
end_comment

begin_comment
comment|/*             fp(I)    - rule for which lookup is for                      */
end_comment

begin_comment
comment|/*             addrp(I) - pointer to lookup information in address struct   */
end_comment

begin_comment
comment|/*             maskp(O) - pointer to lookup information for storage         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When using pools and hash tables to store addresses for matching in      */
end_comment

begin_comment
comment|/* rules, it is necessary to resolve both the object referred to by the     */
end_comment

begin_comment
comment|/* name or address (and return that pointer) and also provide the means by  */
end_comment

begin_comment
comment|/* which to determine if an address belongs to that object to make the      */
end_comment

begin_comment
comment|/* packet matching quicker.                                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ipf_findlookup
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|fr
parameter_list|,
name|addrp
parameter_list|,
name|maskp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|i6addr_t
modifier|*
name|addrp
decl_stmt|,
decl|*
name|maskp
decl_stmt|;
end_function

begin_block
block|{
name|void
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|addrp
operator|->
name|iplookupsubtype
condition|)
block|{
case|case
literal|0
case|:
name|ptr
operator|=
name|ipf_lookup_res_num
argument_list|(
name|softc
argument_list|,
name|unit
argument_list|,
name|addrp
operator|->
name|iplookuptype
argument_list|,
name|addrp
operator|->
name|iplookupnum
argument_list|,
operator|&
name|maskp
operator|->
name|iplookupfunc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|addrp
operator|->
name|iplookupname
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|addrp
operator|->
name|iplookupname
operator|>=
name|fr
operator|->
name|fr_namelen
condition|)
break|break;
name|ptr
operator|=
name|ipf_lookup_res_name
argument_list|(
name|softc
argument_list|,
name|unit
argument_list|,
name|addrp
operator|->
name|iplookuptype
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|addrp
operator|->
name|iplookupname
argument_list|,
operator|&
name|maskp
operator|->
name|iplookupfunc
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_funcinit                                                */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else ESRCH: cannot resolve rule details */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              fr(I)    - pointer to filter rule                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If a rule is a call rule, then check if the function it points to needs  */
end_comment

begin_comment
comment|/* an init function to be called now the rule has been loaded.              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_funcinit
parameter_list|(
name|softc
parameter_list|,
name|fr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|ipfunc_resolve_t
modifier|*
name|ft
decl_stmt|;
name|int
name|err
decl_stmt|;
name|IPFERROR
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|err
operator|=
name|ESRCH
expr_stmt|;
for|for
control|(
name|ft
operator|=
name|ipf_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|fr
operator|->
name|fr_func
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|ipfu_init
operator|!=
name|NULL
condition|)
name|err
operator|=
call|(
modifier|*
name|ft
operator|->
name|ipfu_init
call|)
argument_list|(
name|softc
argument_list|,
name|fr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_funcfini                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              fr(I)    - pointer to filter rule                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* For a given filter rule, call the matching "fini" function if the rule   */
end_comment

begin_comment
comment|/* is using a known function that would have resulted in the "init" being   */
end_comment

begin_comment
comment|/* called for ealier.                                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_funcfini
parameter_list|(
name|softc
parameter_list|,
name|fr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|ipfunc_resolve_t
modifier|*
name|ft
decl_stmt|;
for|for
control|(
name|ft
operator|=
name|ipf_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|fr
operator|->
name|fr_func
condition|)
block|{
if|if
condition|(
name|ft
operator|->
name|ipfu_fini
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ft
operator|->
name|ipfu_fini
argument_list|)
argument_list|(
name|softc
argument_list|,
name|fr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_findfunc                                                */
end_comment

begin_comment
comment|/* Returns:     ipfunc_t - pointer to function if found, else NULL          */
end_comment

begin_comment
comment|/* Parameters:  funcptr(I) - function pointer to lookup                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a function in the table of known functions.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipfunc_t
name|ipf_findfunc
parameter_list|(
name|funcptr
parameter_list|)
name|ipfunc_t
name|funcptr
decl_stmt|;
block|{
name|ipfunc_resolve_t
modifier|*
name|ft
decl_stmt|;
for|for
control|(
name|ft
operator|=
name|ipf_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|funcptr
condition|)
return|return
name|funcptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_resolvefunc                                             */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else error                              */
end_comment

begin_comment
comment|/* Parameters:  data(IO) - ioctl data pointer to ipfunc_resolve_t struct    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy in a ipfunc_resolve_t structure and then fill in the missing field. */
end_comment

begin_comment
comment|/* This will either be the function name (if the pointer is set) or the     */
end_comment

begin_comment
comment|/* function pointer if the name is set.  When found, fill in the other one  */
end_comment

begin_comment
comment|/* so that the entire, complete, structure can be copied back to user space.*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_resolvefunc
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|ipfunc_resolve_t
name|res
decl_stmt|,
modifier|*
name|ft
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|res
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|123
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|res
operator|.
name|ipfu_addr
operator|==
name|NULL
operator|&&
name|res
operator|.
name|ipfu_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|ft
operator|=
name|ipf_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|,
name|ft
operator|->
name|ipfu_name
argument_list|,
sizeof|sizeof
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|ipfu_addr
operator|=
name|ft
operator|->
name|ipfu_addr
expr_stmt|;
name|res
operator|.
name|ipfu_init
operator|=
name|ft
operator|->
name|ipfu_init
expr_stmt|;
if|if
condition|(
name|COPYOUT
argument_list|(
operator|&
name|res
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|35
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|res
operator|.
name|ipfu_addr
operator|!=
name|NULL
operator|&&
name|res
operator|.
name|ipfu_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|ft
operator|=
name|ipf_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|res
operator|.
name|ipfu_addr
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|,
name|ft
operator|->
name|ipfu_name
argument_list|,
sizeof|sizeof
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|ipfu_init
operator|=
name|ft
operator|->
name|ipfu_init
expr_stmt|;
if|if
condition|(
name|COPYOUT
argument_list|(
operator|&
name|res
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|36
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
name|IPFERROR
argument_list|(
literal|37
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|)
operator|||
expr|\
name|FREEBSD_LT_REV
argument_list|(
literal|501000
argument_list|)
operator|||
name|NETBSD_LT_REV
argument_list|(
literal|105000000
argument_list|)
operator|||
expr|\
name|OPENBSD_LT_REV
argument_list|(
literal|200006
argument_list|)
end_if

begin_comment
comment|/*  * From: NetBSD  * ppsratecheck(): packets (or events) per second limitation.  */
end_comment

begin_function
name|int
name|ppsratecheck
parameter_list|(
name|lasttime
parameter_list|,
name|curpps
parameter_list|,
name|maxpps
parameter_list|)
name|struct
name|timeval
modifier|*
name|lasttime
decl_stmt|;
name|int
modifier|*
name|curpps
decl_stmt|;
name|int
name|maxpps
decl_stmt|;
comment|/* maximum pps allowed */
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|GETKTIME
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|delta
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|lasttime
operator|->
name|tv_sec
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
operator|-
name|lasttime
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
comment|/* 	 * check for 0,0 is so that the message will be seen at least once. 	 * if more than one second have passed since the last update of 	 * lasttime, reset the counter. 	 * 	 * we do increment *curpps even in *curpps< maxpps case, as some may 	 * try to use *curpps for stat purposes as well. 	 */
if|if
condition|(
operator|(
name|lasttime
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|lasttime
operator|->
name|tv_usec
operator|==
literal|0
operator|)
operator|||
name|delta
operator|.
name|tv_sec
operator|>=
literal|1
condition|)
block|{
operator|*
name|lasttime
operator|=
name|tv
expr_stmt|;
operator|*
name|curpps
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxpps
operator|<
literal|0
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|curpps
operator|<
name|maxpps
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
else|else
name|rv
operator|=
literal|0
expr_stmt|;
operator|*
name|curpps
operator|=
operator|*
name|curpps
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_derefrule                                               */
end_comment

begin_comment
comment|/* Returns:     int   - 0 == rule freed up, else rule not freed             */
end_comment

begin_comment
comment|/* Parameters:  fr(I) - pointer to filter rule                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Decrement the reference counter to a rule by one.  If it reaches zero,   */
end_comment

begin_comment
comment|/* free it and any associated storage space being used by it.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_derefrule
parameter_list|(
name|softc
parameter_list|,
name|frp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
modifier|*
name|frp
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|fr
operator|=
operator|*
name|frp
expr_stmt|;
operator|*
name|frp
operator|=
name|NULL
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ref
operator|--
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ref
operator|==
literal|0
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|ipf_funcfini
argument_list|(
name|softc
argument_list|,
name|fr
argument_list|)
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tif
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|IPLT_DSTLIST
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|)
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_rif
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|IPLT_DSTLIST
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|)
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_dif
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|IPLT_DSTLIST
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
operator|&&
name|fr
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_srctype
argument_list|,
name|fr
operator|->
name|fr_srcptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
operator|)
operator|==
name|FR_T_IPF
operator|&&
name|fr
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_dsttype
argument_list|,
name|fr
operator|->
name|fr_dstptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_grp
operator|!=
name|NULL
condition|)
name|ipf_group_del
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_grp
argument_list|,
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_grphead
operator|!=
name|NULL
condition|)
name|ipf_group_del
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_grphead
argument_list|,
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_icmpgrp
operator|!=
name|NULL
condition|)
name|ipf_group_del
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_icmpgrp
argument_list|,
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_COPIED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fr
operator|->
name|fr_dsize
condition|)
block|{
name|KFREES
argument_list|(
name|fr
operator|->
name|fr_data
argument_list|,
name|fr
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
name|KFREES
argument_list|(
name|fr
argument_list|,
name|fr
operator|->
name|fr_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_grpmapinit                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else ESRCH because table entry not found*/
end_comment

begin_comment
comment|/* Parameters:  fr(I) - pointer to rule to find hash table for              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Looks for group hash table fr_arg and stores a pointer to it in fr_ptr.  */
end_comment

begin_comment
comment|/* fr_ptr is later used by ipf_srcgrpmap and ipf_dstgrpmap.                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_grpmapinit
parameter_list|(
name|softc
parameter_list|,
name|fr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|char
name|name
index|[
name|FR_GROUPLEN
index|]
decl_stmt|;
name|iphtable_t
modifier|*
name|iph
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SNPRINTF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|SNPRINTF
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fr
operator|->
name|fr_arg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d"
argument_list|,
name|fr
operator|->
name|fr_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iph
operator|=
name|ipf_lookup_find_htable
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|38
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
if|if
condition|(
operator|(
name|iph
operator|->
name|iph_flags
operator|&
name|FR_INOUT
operator|)
operator|!=
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_INOUT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|39
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
name|iph
operator|->
name|iph_ref
operator|++
expr_stmt|;
name|fr
operator|->
name|fr_ptr
operator|=
name|iph
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_grpmapfini                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else ESRCH because table entry not found*/
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              fr(I)    - pointer to rule to release hash table for        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* For rules that have had ipf_grpmapinit called, ipf_lookup_deref needs to */
end_comment

begin_comment
comment|/* be called to undo what ipf_grpmapinit caused to be done.                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_grpmapfini
parameter_list|(
name|softc
parameter_list|,
name|fr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|iphtable_t
modifier|*
name|iph
decl_stmt|;
name|iph
operator|=
name|fr
operator|->
name|fr_ptr
expr_stmt|;
if|if
condition|(
name|iph
operator|!=
name|NULL
condition|)
name|ipf_lookup_deref
argument_list|(
name|softc
argument_list|,
name|IPLT_HASH
argument_list|,
name|iph
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_srcgrpmap                                               */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - pointer to "new last matching" rule or NULL   */
end_comment

begin_comment
comment|/* Parameters:  fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a rule group head in a hash table, using the source address as  */
end_comment

begin_comment
comment|/* the key, and descend into that group and continue matching rules against */
end_comment

begin_comment
comment|/* the packet.                                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|ipf_srcgrpmap
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|void
modifier|*
name|rval
decl_stmt|;
name|rval
operator|=
name|ipf_iphmfindgroup
argument_list|(
name|fin
operator|->
name|fin_main_soft
argument_list|,
name|fin
operator|->
name|fin_fr
operator|->
name|fr_ptr
argument_list|,
operator|&
name|fin
operator|->
name|fin_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fg
operator|=
name|rval
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fg
operator|->
name|fg_start
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
operator|*
name|passp
argument_list|)
expr_stmt|;
return|return
name|fin
operator|->
name|fin_fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_dstgrpmap                                               */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - pointer to "new last matching" rule or NULL   */
end_comment

begin_comment
comment|/* Parameters:  fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a rule group head in a hash table, using the destination        */
end_comment

begin_comment
comment|/* address as the key, and descend into that group and continue matching    */
end_comment

begin_comment
comment|/* rules against  the packet.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|ipf_dstgrpmap
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|void
modifier|*
name|rval
decl_stmt|;
name|rval
operator|=
name|ipf_iphmfindgroup
argument_list|(
name|fin
operator|->
name|fin_main_soft
argument_list|,
name|fin
operator|->
name|fin_fr
operator|->
name|fr_ptr
argument_list|,
operator|&
name|fin
operator|->
name|fin_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fg
operator|=
name|rval
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fg
operator|->
name|fg_start
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
operator|*
name|passp
argument_list|)
expr_stmt|;
return|return
name|fin
operator|->
name|fin_fr
return|;
block|}
end_function

begin_comment
comment|/*  * Queue functions  * ===============  * These functions manage objects on queues for efficient timeouts.  There  * are a number of system defined queues as well as user defined timeouts.  * It is expected that a lock is held in the domain in which the queue  * belongs (i.e. either state or NAT) when calling any of these functions  * that prevents ipf_freetimeoutqueue() from being called at the same time  * as any other.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_addtimeoutqueue                                         */
end_comment

begin_comment
comment|/* Returns:     struct ifqtq * - NULL if malloc fails, else pointer to      */
end_comment

begin_comment
comment|/*                               timeout queue with given interval.         */
end_comment

begin_comment
comment|/* Parameters:  parent(I)  - pointer to pointer to parent node of this list */
end_comment

begin_comment
comment|/*                           of interface queues.                           */
end_comment

begin_comment
comment|/*              seconds(I) - timeout value in seconds for this queue.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This routine first looks for a timeout queue that matches the interval   */
end_comment

begin_comment
comment|/* being requested.  If it finds one, increments the reference counter and  */
end_comment

begin_comment
comment|/* returns a pointer to it.  If none are found, it allocates a new one and  */
end_comment

begin_comment
comment|/* inserts it at the top of the list.                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking.                                                                 */
end_comment

begin_comment
comment|/* It is assumed that the caller of this function has an appropriate lock   */
end_comment

begin_comment
comment|/* held (exclusively) in the domain that encompases 'parent'.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipftq_t
modifier|*
name|ipf_addtimeoutqueue
parameter_list|(
name|softc
parameter_list|,
name|parent
parameter_list|,
name|seconds
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftq_t
modifier|*
modifier|*
name|parent
decl_stmt|;
name|u_int
name|seconds
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|period
operator|=
name|seconds
operator|*
name|IPF_HZ_DIVIDE
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
for|for
control|(
name|ifq
operator|=
operator|*
name|parent
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
block|{
if|if
condition|(
name|ifq
operator|->
name|ifq_ttl
operator|==
name|period
condition|)
block|{
comment|/* 			 * Reset the delete flag, if set, so the structure 			 * gets reused rather than freed and reallocated. 			 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|ifq
operator|->
name|ifq_flags
operator|&=
operator|~
name|IFQF_DELETE
expr_stmt|;
name|ifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
return|return
name|ifq
return|;
block|}
block|}
name|KMALLOC
argument_list|(
name|ifq
argument_list|,
name|ipftq_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifq
operator|!=
name|NULL
condition|)
block|{
name|MUTEX_NUKE
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
name|ifq
argument_list|,
name|period
argument_list|,
literal|"ipftq mutex"
argument_list|)
expr_stmt|;
name|ifq
operator|->
name|ifq_next
operator|=
operator|*
name|parent
expr_stmt|;
name|ifq
operator|->
name|ifq_pnext
operator|=
name|parent
expr_stmt|;
name|ifq
operator|->
name|ifq_flags
operator|=
name|IFQF_USER
expr_stmt|;
name|ifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
operator|*
name|parent
operator|=
name|ifq
expr_stmt|;
name|softc
operator|->
name|ipf_userifqs
operator|++
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
return|return
name|ifq
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_deletetimeoutqueue                                      */
end_comment

begin_comment
comment|/* Returns:     int    - new reference count value of the timeout queue     */
end_comment

begin_comment
comment|/* Parameters:  ifq(I) - timeout queue which is losing a reference.         */
end_comment

begin_comment
comment|/* Locks:       ifq->ifq_lock                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This routine must be called when we're discarding a pointer to a timeout */
end_comment

begin_comment
comment|/* queue object, taking care of the reference counter.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Now that this just sets a DELETE flag, it requires the expire code to    */
end_comment

begin_comment
comment|/* check the list of user defined timeout queues and call the free function */
end_comment

begin_comment
comment|/* below (currently commented out) to stop memory leaking.  It is done this */
end_comment

begin_comment
comment|/* way because the locking may not be sufficient to safely do a free when   */
end_comment

begin_comment
comment|/* this function is called.                                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_deletetimeoutqueue
parameter_list|(
name|ifq
parameter_list|)
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
block|{
name|ifq
operator|->
name|ifq_ref
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ifq
operator|->
name|ifq_ref
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_USER
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ifq
operator|->
name|ifq_flags
operator||=
name|IFQF_DELETE
expr_stmt|;
block|}
return|return
name|ifq
operator|->
name|ifq_ref
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_freetimeoutqueue                                        */
end_comment

begin_comment
comment|/* Parameters:  ifq(I) - timeout queue which is losing a reference.         */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking:                                                                 */
end_comment

begin_comment
comment|/* It is assumed that the caller of this function has an appropriate lock   */
end_comment

begin_comment
comment|/* held (exclusively) in the domain that encompases the callers "domain".   */
end_comment

begin_comment
comment|/* The ifq_lock for this structure should not be held.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove a user defined timeout queue from the list of queues it is in and */
end_comment

begin_comment
comment|/* tidy up after this is done.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_freetimeoutqueue
parameter_list|(
name|softc
parameter_list|,
name|ifq
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_DELETE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ifq
operator|->
name|ifq_ref
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_USER
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ipf_freetimeoutqueue(%lx) flags 0x%x ttl %d ref %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ifq
argument_list|,
name|ifq
operator|->
name|ifq_flags
argument_list|,
name|ifq
operator|->
name|ifq_ttl
argument_list|,
name|ifq
operator|->
name|ifq_ref
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove from its position in the list. 	 */
operator|*
name|ifq
operator|->
name|ifq_pnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
if|if
condition|(
name|ifq
operator|->
name|ifq_next
operator|!=
name|NULL
condition|)
name|ifq
operator|->
name|ifq_next
operator|->
name|ifq_pnext
operator|=
name|ifq
operator|->
name|ifq_pnext
expr_stmt|;
name|ifq
operator|->
name|ifq_next
operator|=
name|NULL
expr_stmt|;
name|ifq
operator|->
name|ifq_pnext
operator|=
name|NULL
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|ATOMIC_DEC
argument_list|(
name|softc
operator|->
name|ipf_userifqs
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_deletequeueentry                                        */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqe(I) - timeout queue entry to delete                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove a tail queue entry from its queue and make it an orphan.          */
end_comment

begin_comment
comment|/* ipf_deletetimeoutqueue is called to make sure the reference count on the */
end_comment

begin_comment
comment|/* queue is correct.  We can't, however, call ipf_freetimeoutqueue because  */
end_comment

begin_comment
comment|/* the correct lock(s) may not be held that would make it safe to do so.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_deletequeueentry
parameter_list|(
name|tqe
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|ifq
operator|=
name|tqe
operator|->
name|tqe_ifq
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_pnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
operator|!=
name|NULL
condition|)
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
else|else
comment|/* we must be the tail anyway */
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|NULL
expr_stmt|;
name|tqe
operator|->
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ipf_deletetimeoutqueue
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifq
operator|->
name|ifq_ref
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_queuefront                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqe(I) - pointer to timeout queue entry                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a queue entry to the front of the queue, if it isn't already there. */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_queuefront
parameter_list|(
name|tqe
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|ifq
operator|=
name|tqe
operator|->
name|tqe_ifq
expr_stmt|;
if|if
condition|(
name|ifq
operator|==
name|NULL
condition|)
return|return;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifq
operator|->
name|ifq_head
operator|!=
name|tqe
condition|)
block|{
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
condition|)
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
else|else
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
name|ifq
operator|->
name|ifq_head
operator|->
name|tqe_pnext
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|ifq
operator|->
name|ifq_head
operator|=
name|tqe
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
operator|&
name|ifq
operator|->
name|ifq_head
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_queueback                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  ticks(I) - ipf tick time to use with this call              */
end_comment

begin_comment
comment|/*              tqe(I)   - pointer to timeout queue entry                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a queue entry to the back of the queue, if it isn't already there.  */
end_comment

begin_comment
comment|/* We use use ticks to calculate the expiration and mark for when we last   */
end_comment

begin_comment
comment|/* touched the structure.                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_queueback
parameter_list|(
name|ticks
parameter_list|,
name|tqe
parameter_list|)
name|u_long
name|ticks
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|ifq
operator|=
name|tqe
operator|->
name|tqe_ifq
expr_stmt|;
if|if
condition|(
name|ifq
operator|==
name|NULL
condition|)
return|return;
name|tqe
operator|->
name|tqe_die
operator|=
name|ticks
operator|+
name|ifq
operator|->
name|ifq_ttl
expr_stmt|;
name|tqe
operator|->
name|tqe_touched
operator|=
name|ticks
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
operator|!=
name|NULL
condition|)
block|{
comment|/* at the end already ? */
comment|/* 		 * Remove from list 		 */
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
comment|/* 		 * Make it the last entry. 		 */
name|tqe
operator|->
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
operator|*
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
expr_stmt|;
name|ifq
operator|->
name|ifq_tail
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_queueappend                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  ticks(I)  - ipf tick time to use with this call             */
end_comment

begin_comment
comment|/*              tqe(I)    - pointer to timeout queue entry                  */
end_comment

begin_comment
comment|/*              ifq(I)    - pointer to timeout queue                        */
end_comment

begin_comment
comment|/*              parent(I) - owing object pointer                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Add a new item to this queue and put it on the very end.                 */
end_comment

begin_comment
comment|/* We use use ticks to calculate the expiration and mark for when we last   */
end_comment

begin_comment
comment|/* touched the structure.                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_queueappend
parameter_list|(
name|ticks
parameter_list|,
name|tqe
parameter_list|,
name|ifq
parameter_list|,
name|parent
parameter_list|)
name|u_long
name|ticks
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|void
modifier|*
name|parent
decl_stmt|;
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|tqe
operator|->
name|tqe_parent
operator|=
name|parent
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
operator|*
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
expr_stmt|;
name|ifq
operator|->
name|ifq_tail
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|tqe
operator|->
name|tqe_ifq
operator|=
name|ifq
expr_stmt|;
name|tqe
operator|->
name|tqe_die
operator|=
name|ticks
operator|+
name|ifq
operator|->
name|ifq_ttl
expr_stmt|;
name|tqe
operator|->
name|tqe_touched
operator|=
name|ticks
expr_stmt|;
name|ifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_movequeue                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tq(I)   - pointer to timeout queue information              */
end_comment

begin_comment
comment|/*              oifp(I) - old timeout queue entry was on                    */
end_comment

begin_comment
comment|/*              nifp(I) - new timeout queue to put entry on                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a queue entry from one timeout queue to another timeout queue.      */
end_comment

begin_comment
comment|/* If it notices that the current entry is already last and does not need   */
end_comment

begin_comment
comment|/* to move queue, the return.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_movequeue
parameter_list|(
name|ticks
parameter_list|,
name|tqe
parameter_list|,
name|oifq
parameter_list|,
name|nifq
parameter_list|)
name|u_long
name|ticks
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|ipftq_t
modifier|*
name|oifq
decl_stmt|,
decl|*
name|nifq
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * If the queue hasn't changed and we last touched this entry at the 	 * same ipf time, then we're not going to achieve anything by either 	 * changing the ttl or moving it on the queue. 	 */
if|if
condition|(
name|oifq
operator|==
name|nifq
operator|&&
name|tqe
operator|->
name|tqe_touched
operator|==
name|ticks
condition|)
return|return;
comment|/* 	 * For any of this to be outside the lock, there is a risk that two 	 * packets entering simultaneously, with one changing to a different 	 * queue and one not, could end up with things in a bizarre state. 	 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|oifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|tqe
operator|->
name|tqe_touched
operator|=
name|ticks
expr_stmt|;
name|tqe
operator|->
name|tqe_die
operator|=
name|ticks
operator|+
name|nifq
operator|->
name|ifq_ttl
expr_stmt|;
comment|/* 	 * Is the operation here going to be a no-op ? 	 */
if|if
condition|(
name|oifq
operator|==
name|nifq
condition|)
block|{
if|if
condition|(
operator|(
name|tqe
operator|->
name|tqe_next
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_die
operator|==
name|tqe
operator|->
name|tqe_die
operator|)
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|oifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Remove from the old queue 	 */
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
condition|)
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
else|else
name|oifq
operator|->
name|ifq_tail
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we're moving from one queue to another, release the 	 * lock on the old queue and get a lock on the new queue. 	 * For user defined queues, if we're moving off it, call 	 * delete in case it can now be freed. 	 */
if|if
condition|(
name|oifq
operator|!=
name|nifq
condition|)
block|{
name|tqe
operator|->
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_deletetimeoutqueue
argument_list|(
name|oifq
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|oifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|nifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|tqe
operator|->
name|tqe_ifq
operator|=
name|nifq
expr_stmt|;
name|nifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
block|}
comment|/* 	 * Add to the bottom of the new queue 	 */
name|tqe
operator|->
name|tqe_pnext
operator|=
name|nifq
operator|->
name|ifq_tail
expr_stmt|;
operator|*
name|nifq
operator|->
name|ifq_tail
operator|=
name|tqe
expr_stmt|;
name|nifq
operator|->
name|ifq_tail
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|nifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_updateipid                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == error (packet should be droppped) */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When we are doing NAT, change the IP of every packet to represent a      */
end_comment

begin_comment
comment|/* single sequence of packets coming from the host, hiding any host         */
end_comment

begin_comment
comment|/* specific sequencing that might otherwise be revealed.  If the packet is  */
end_comment

begin_comment
comment|/* a fragment, then store the 'new' IPid in the fragment cache and look up  */
end_comment

begin_comment
comment|/* the fragment cache for non-leading fragments.  If a non-leading fragment */
end_comment

begin_comment
comment|/* has no match in the cache, return an error.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_updateipid
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|u_short
name|id
decl_stmt|,
name|ido
decl_stmt|,
name|sums
decl_stmt|;
name|u_32_t
name|sumd
decl_stmt|,
name|sum
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|ido
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
block|{
name|sum
operator|=
name|ipf_frag_ipidknown
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0xffffffff
condition|)
return|return
operator|-
literal|1
return|;
name|sum
operator|&=
literal|0xffff
expr_stmt|;
name|id
operator|=
operator|(
name|u_short
operator|)
name|sum
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip_fillid
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|id
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|ipf_frag_ipidnew
argument_list|(
name|fin
argument_list|,
operator|(
name|u_32_t
operator|)
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|ido
condition|)
return|return
literal|0
return|;
name|CALC_SUMD
argument_list|(
name|ido
argument_list|,
name|id
argument_list|,
name|sumd
argument_list|)
expr_stmt|;
comment|/* DESTRUCTIVE MACRO! id,ido change */
name|sum
operator|=
operator|(
operator|~
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_sum
argument_list|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|sum
operator|+=
name|sumd
expr_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sums
operator|=
operator|~
operator|(
name|u_short
operator|)
name|sum
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|htons
argument_list|(
name|sums
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_FRGETIFNAME
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_getifname                                               */
end_comment

begin_comment
comment|/* Returns:     char *    - pointer to interface name                       */
end_comment

begin_comment
comment|/* Parameters:  ifp(I)    - pointer to network interface                    */
end_comment

begin_comment
comment|/*              buffer(O) - pointer to where to store interface name        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Constructs an interface name in the buffer passed.  The buffer passed is */
end_comment

begin_comment
comment|/* expected to be at least LIFNAMSIZ in bytes big.  If buffer is passed in  */
end_comment

begin_comment
comment|/* as a NULL pointer then return a pointer to a static array.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|char
modifier|*
name|ipf_getifname
parameter_list|(
name|ifp
parameter_list|,
name|buffer
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|char
name|namebuf
index|[
name|LIFNAMSIZ
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX51
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|)
name|int
name|unit
decl_stmt|,
name|space
decl_stmt|;
name|char
name|temp
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
name|buffer
operator|=
name|namebuf
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|LIFNAMSIZ
argument_list|)
expr_stmt|;
name|buffer
index|[
name|LIFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX51
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|)
for|for
control|(
name|s
operator|=
name|buffer
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|unit
operator|=
name|ifp
operator|->
name|if_unit
expr_stmt|;
name|space
operator|=
name|LIFNAMSIZ
operator|-
operator|(
name|s
operator|-
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|space
operator|>
literal|0
operator|)
operator|&&
operator|(
name|unit
operator|>=
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SNPRINTF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|SNPRINTF
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|s
argument_list|,
name|temp
argument_list|,
name|space
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ioctlswitch                                             */
end_comment

begin_comment
comment|/* Returns:     int     - -1 continue processing, else ioctl return value   */
end_comment

begin_comment
comment|/* Parameters:  unit(I) - device unit opened                                */
end_comment

begin_comment
comment|/*              data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              cmd(I)  - ioctl command                                     */
end_comment

begin_comment
comment|/*              mode(I) - mode value                                        */
end_comment

begin_comment
comment|/*              uid(I)  - uid making the ioctl call                         */
end_comment

begin_comment
comment|/*              ctx(I)  - pointer to context data                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Based on the value of unit, call the appropriate ioctl handler or return */
end_comment

begin_comment
comment|/* EIO if ipfilter is not running.   Also checks if write perms are req'd   */
end_comment

begin_comment
comment|/* for the device in order to execute the ioctl.  A special case is made    */
end_comment

begin_comment
comment|/* SIOCIPFINTERROR so that the same code isn't required in every handler.   */
end_comment

begin_comment
comment|/* The context data pointer is passed through as this is used as the key    */
end_comment

begin_comment
comment|/* for locating a matching token for continued access for walking lists,    */
end_comment

begin_comment
comment|/* etc.                                                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ioctlswitch
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|data
parameter_list|,
name|cmd
parameter_list|,
name|mode
parameter_list|,
name|uid
parameter_list|,
name|ctx
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|uid
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|,
decl|*
name|ctx
decl_stmt|;
end_function

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCIPFINTERROR
case|:
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_interror
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|ipf_interror
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
return|return
name|error
return|;
default|default :
break|break;
block|}
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|IPL_LOGIPF
case|:
name|error
operator|=
name|ipf_ipf_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPL_LOGNAT
case|:
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ipf_nat_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|IPL_LOGSTATE
case|:
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ipf_state_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|43
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|IPL_LOGAUTH
case|:
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ipf_auth_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|44
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|IPL_LOGSYNC
case|:
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ipf_sync_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|IPFERROR
argument_list|(
literal|45
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPL_LOGSCAN
case|:
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
name|error
operator|=
name|ipf_scan_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|IPFERROR
argument_list|(
literal|46
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPL_LOGLOOKUP
case|:
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ipf_lookup_ioctl
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|IPFERROR
argument_list|(
literal|47
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * This array defines the expected size of objects coming into the kernel  * for the various recognised object types. The first column is flags (see  * below), 2nd column is current size, 3rd column is the version number of  * when the current size became current.  * Flags:  * 1 = minimum size, not absolute size  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipf_objbytes
index|[
name|IPFOBJ_COUNT
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|1
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|frentry
argument_list|)
block|,
literal|5010000
block|}
block|,
comment|/* 0 */
block|{
literal|1
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|friostat
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fr_info
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipf_authstat
argument_list|)
block|,
literal|4010100
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipfrstat
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|1
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipnat
argument_list|)
block|,
literal|5010000
block|}
block|,
comment|/* 5 */
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|natstat
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipstate_save
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|1
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|nat_save
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|natlookup
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|1
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipstate
argument_list|)
block|,
literal|5010000
block|}
block|,
comment|/* 10 */
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ips_stat
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|frauth
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipftune
argument_list|)
block|,
literal|4010100
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|nat
argument_list|)
block|,
literal|5010000
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipfruleiter
argument_list|)
block|,
literal|4011400
block|}
block|,
comment|/* 15 */
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipfgeniter
argument_list|)
block|,
literal|4011400
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipftable
argument_list|)
block|,
literal|4011400
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipflookupiter
argument_list|)
block|,
literal|4011400
block|}
block|,
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipftq
argument_list|)
operator|*
name|IPF_TCP_NSTATES
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IPFEXPR */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PROXYCTL */
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fripf
argument_list|)
block|,
literal|5010000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_inobj                                                   */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - soft context pointerto work with                 */
end_comment

begin_comment
comment|/*              data(I)  - pointer to ioctl data                            */
end_comment

begin_comment
comment|/*              objp(O)  - where to store ipfobj structure                  */
end_comment

begin_comment
comment|/*              ptr(I)   - pointer to data to copy out                      */
end_comment

begin_comment
comment|/*              type(I)  - type of structure being moved                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy in the contents of what the ipfobj_t points to.  In future, we      */
end_comment

begin_comment
comment|/* add things to check for version numbers, sizes, etc, to make it backward */
end_comment

begin_comment
comment|/* compatible at the ABI for user land.                                     */
end_comment

begin_comment
comment|/* If objp is not NULL then we assume that the caller wants to see what is  */
end_comment

begin_comment
comment|/* in the ipfobj_t structure being copied in. As an example, this can tell  */
end_comment

begin_comment
comment|/* the caller what version of ipfilter the ioctl program was written to.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_inobj
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|objp
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|ipfobj_t
modifier|*
name|objp
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>=
name|IPFOBJ_COUNT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|49
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|objp
operator|==
name|NULL
condition|)
name|objp
operator|=
operator|&
name|obj
expr_stmt|;
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
name|objp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|objp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|124
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|objp
operator|->
name|ipfo_type
operator|!=
name|type
condition|)
block|{
name|IPFERROR
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|objp
operator|->
name|ipfo_rev
operator|>=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|objp
operator|->
name|ipfo_size
operator|<
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
block|{
name|IPFERROR
argument_list|(
literal|51
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|size
operator|=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objp
operator|->
name|ipfo_size
operator|==
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
block|{
name|size
operator|=
name|objp
operator|->
name|ipfo_size
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|52
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|COPYIN
argument_list|(
name|objp
operator|->
name|ipfo_ptr
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|55
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IPFILTER_COMPAT
name|error
operator|=
name|ipf_in_compat
argument_list|(
name|softc
argument_list|,
name|objp
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|IPFERROR
argument_list|(
literal|54
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_inobjsz                                                 */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - soft context pointerto work with                 */
end_comment

begin_comment
comment|/*              data(I)  - pointer to ioctl data                            */
end_comment

begin_comment
comment|/*              ptr(I)   - pointer to store real data in                    */
end_comment

begin_comment
comment|/*              type(I)  - type of structure being moved                    */
end_comment

begin_comment
comment|/*              sz(I)    - size of data to copy                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* As per ipf_inobj, except the size of the object to copy in is passed in  */
end_comment

begin_comment
comment|/* but it must not be smaller than the size defined for the type and the    */
end_comment

begin_comment
comment|/* type must allow for varied sized objects.  The extra requirement here is */
end_comment

begin_comment
comment|/* that sz must match the size of the object being passed in - this is not  */
end_comment

begin_comment
comment|/* not possible nor required in ipf_inobj().                                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_inobjsz
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|,
name|sz
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|,
name|sz
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>=
name|IPFOBJ_COUNT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|56
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|125
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
block|{
name|IPFERROR
argument_list|(
literal|58
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|>=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sz
operator|<
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|57
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|COPYIN
argument_list|(
name|obj
operator|.
name|ipfo_ptr
argument_list|,
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|61
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IPFILTER_COMPAT
name|error
operator|=
name|ipf_in_compat
argument_list|(
name|softc
argument_list|,
operator|&
name|obj
argument_list|,
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
else|#
directive|else
name|IPFERROR
argument_list|(
literal|60
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_outobjsz                                                */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to store real data in                     */
end_comment

begin_comment
comment|/*              type(I) - type of structure being moved                     */
end_comment

begin_comment
comment|/*              sz(I)   - size of data to copy                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* As per ipf_outobj, except the size of the object to copy out is passed in*/
end_comment

begin_comment
comment|/* but it must not be smaller than the size defined for the type and the    */
end_comment

begin_comment
comment|/* type must allow for varied sized objects.  The extra requirement here is */
end_comment

begin_comment
comment|/* that sz must match the size of the object being passed in - this is not  */
end_comment

begin_comment
comment|/* not possible nor required in ipf_outobj().                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_outobjsz
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|,
name|sz
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|,
name|sz
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>=
name|IPFOBJ_COUNT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|62
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|127
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
block|{
name|IPFERROR
argument_list|(
literal|63
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|>=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sz
operator|<
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|146
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|COPYOUT
argument_list|(
name|ptr
argument_list|,
name|obj
operator|.
name|ipfo_ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|66
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IPFILTER_COMPAT
name|error
operator|=
name|ipf_out_compat
argument_list|(
name|softc
argument_list|,
operator|&
name|obj
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|IPFERROR
argument_list|(
literal|65
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_outobj                                                  */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to store real data in                     */
end_comment

begin_comment
comment|/*              type(I) - type of structure being moved                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy out the contents of what ptr is to where ipfobj points to.  In      */
end_comment

begin_comment
comment|/* future, we add things to check for version numbers, sizes, etc, to make  */
end_comment

begin_comment
comment|/* it backward  compatible at the ABI for user land.                        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_outobj
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>=
name|IPFOBJ_COUNT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|67
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|126
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
block|{
name|IPFERROR
argument_list|(
literal|68
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|>=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|<
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
block|{
name|IPFERROR
argument_list|(
literal|69
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
block|{
name|IPFERROR
argument_list|(
literal|70
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|COPYOUT
argument_list|(
name|ptr
argument_list|,
name|obj
operator|.
name|ipfo_ptr
argument_list|,
name|obj
operator|.
name|ipfo_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|73
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IPFILTER_COMPAT
name|error
operator|=
name|ipf_out_compat
argument_list|(
name|softc
argument_list|,
operator|&
name|obj
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|IPFERROR
argument_list|(
literal|72
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_outobjk                                                 */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  obj(I)  - pointer to data description structure             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to kernel data to copy out                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* In the above functions, the ipfobj_t structure is copied into the kernel,*/
end_comment

begin_comment
comment|/* telling ipfilter how to copy out data. In this instance, the ipfobj_t is */
end_comment

begin_comment
comment|/* already populated with information and now we just need to use it.       */
end_comment

begin_comment
comment|/* There is no need for this function to have a "type" parameter as there   */
end_comment

begin_comment
comment|/* is no point in validating information that comes from the kernel with    */
end_comment

begin_comment
comment|/* itself.                                                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_outobjk
parameter_list|(
name|softc
parameter_list|,
name|obj
parameter_list|,
name|ptr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipfobj_t
modifier|*
name|obj
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|type
init|=
name|obj
operator|->
name|ipfo_type
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>=
name|IPFOBJ_COUNT
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|147
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|ipfo_rev
operator|>=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|ipfo_size
operator|<
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
block|{
name|IPFERROR
argument_list|(
literal|148
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|ipfo_size
operator|!=
name|ipf_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
block|{
name|IPFERROR
argument_list|(
literal|149
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|COPYOUT
argument_list|(
name|ptr
argument_list|,
name|obj
operator|->
name|ipfo_ptr
argument_list|,
name|obj
operator|->
name|ipfo_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IPFILTER_COMPAT
name|error
operator|=
name|ipf_out_compat
argument_list|(
name|softc
argument_list|,
name|obj
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|IPFERROR
argument_list|(
literal|151
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_checkl4sum                                              */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = good, -1 = bad, 1 = cannot check              */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If possible, calculate the layer 4 checksum for the packet.  If this is  */
end_comment

begin_comment
comment|/* not possible, return without indicating a failure or success but in a    */
end_comment

begin_comment
comment|/* way that is ditinguishable. This function should only be called by the   */
end_comment

begin_comment
comment|/* ipf_checkv6sum() for each platform.                                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|INLINE
name|int
name|ipf_checkl4sum
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|u_short
name|sum
decl_stmt|,
name|hdrsum
decl_stmt|,
modifier|*
name|csump
decl_stmt|;
name|udphdr_t
modifier|*
name|udp
decl_stmt|;
name|int
name|dosum
decl_stmt|;
comment|/* 	 * If the TCP packet isn't a fragment, isn't too short and otherwise 	 * isn't already considered "bad", then validate the checksum.  If 	 * this check fails then considered the packet to be "bad". 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_FRAG
operator||
name|FI_SHORT
operator||
name|FI_BAD
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|csump
operator|=
name|NULL
expr_stmt|;
name|hdrsum
operator|=
literal|0
expr_stmt|;
name|dosum
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|tcphdr_t
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|)
operator|->
name|th_sum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|udp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|udp
operator|->
name|uh_sum
operator|!=
literal|0
condition|)
block|{
name|csump
operator|=
operator|&
name|udp
operator|->
name|uh_sum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|)
operator|->
name|icmp6_cksum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|)
operator|->
name|icmp_cksum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
break|break;
default|default :
return|return
literal|1
return|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|csump
operator|!=
name|NULL
condition|)
name|hdrsum
operator|=
operator|*
name|csump
expr_stmt|;
if|if
condition|(
name|dosum
condition|)
block|{
name|sum
operator|=
name|fr_cksum
argument_list|(
name|fin
argument_list|,
name|fin
operator|->
name|fin_ip
argument_list|,
name|fin
operator|->
name|fin_p
argument_list|,
name|fin
operator|->
name|fin_dp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|sum
operator|==
name|hdrsum
condition|)
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"checkl4sum: %hx == %hx\n"
operator|,
name|sum
operator|,
name|hdrsum
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"checkl4sum: %hx != %hx\n"
operator|,
name|sum
operator|,
name|hdrsum
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DT2
argument_list|(
name|l4sums
argument_list|,
name|u_short
argument_list|,
name|hdrsum
argument_list|,
name|u_short
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrsum
operator|==
name|sum
condition|)
block|{
name|fin
operator|->
name|fin_cksum
operator|=
name|FI_CK_SUMOK
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fin
operator|->
name|fin_cksum
operator|=
name|FI_CK_BAD
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ifpfillv4addr                                           */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = address update, -1 = address not updated      */
end_comment

begin_comment
comment|/* Parameters:  atype(I)   - type of network address update to perform      */
end_comment

begin_comment
comment|/*              sin(I)     - pointer to source of address information       */
end_comment

begin_comment
comment|/*              mask(I)    - pointer to source of netmask information       */
end_comment

begin_comment
comment|/*              inp(I)     - pointer to destination address store           */
end_comment

begin_comment
comment|/*              inpmask(I) - pointer to destination netmask store           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a type of network address update (atype) to perform, copy          */
end_comment

begin_comment
comment|/* information from sin/mask into inp/inpmask.  If ipnmask is NULL then no  */
end_comment

begin_comment
comment|/* netmask update is performed unless FRI_NETMASKED is passed as atype, in  */
end_comment

begin_comment
comment|/* which case the operation fails.  For all values of atype other than      */
end_comment

begin_comment
comment|/* FRI_NETMASKED, if inpmask is non-NULL then the mask is set to an all 1s  */
end_comment

begin_comment
comment|/* value.                                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ifpfillv4addr
parameter_list|(
name|atype
parameter_list|,
name|sin
parameter_list|,
name|mask
parameter_list|,
name|inp
parameter_list|,
name|inpmask
parameter_list|)
name|int
name|atype
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|inp
decl_stmt|,
modifier|*
name|inpmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|inpmask
operator|!=
name|NULL
operator|&&
name|atype
operator|!=
name|FRI_NETMASKED
condition|)
name|inpmask
operator|->
name|s_addr
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|atype
operator|==
name|FRI_NETWORK
operator|||
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|inpmask
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|inpmask
operator|->
name|s_addr
operator|=
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
name|inp
operator|->
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ifpfillv6addr                                           */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = address update, -1 = address not updated      */
end_comment

begin_comment
comment|/* Parameters:  atype(I)   - type of network address update to perform      */
end_comment

begin_comment
comment|/*              sin(I)     - pointer to source of address information       */
end_comment

begin_comment
comment|/*              mask(I)    - pointer to source of netmask information       */
end_comment

begin_comment
comment|/*              inp(I)     - pointer to destination address store           */
end_comment

begin_comment
comment|/*              inpmask(I) - pointer to destination netmask store           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a type of network address update (atype) to perform, copy          */
end_comment

begin_comment
comment|/* information from sin/mask into inp/inpmask.  If ipnmask is NULL then no  */
end_comment

begin_comment
comment|/* netmask update is performed unless FRI_NETMASKED is passed as atype, in  */
end_comment

begin_comment
comment|/* which case the operation fails.  For all values of atype other than      */
end_comment

begin_comment
comment|/* FRI_NETMASKED, if inpmask is non-NULL then the mask is set to an all 1s  */
end_comment

begin_comment
comment|/* value.                                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ifpfillv6addr
parameter_list|(
name|atype
parameter_list|,
name|sin
parameter_list|,
name|mask
parameter_list|,
name|inp
parameter_list|,
name|inpmask
parameter_list|)
name|int
name|atype
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|i6addr_t
modifier|*
name|inp
decl_stmt|,
modifier|*
name|inpmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|i6addr_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|and
decl_stmt|;
name|src
operator|=
operator|(
name|i6addr_t
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin6_addr
expr_stmt|;
name|and
operator|=
operator|(
name|i6addr_t
operator|*
operator|)
operator|&
name|mask
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|inpmask
operator|!=
name|NULL
operator|&&
name|atype
operator|!=
name|FRI_NETMASKED
condition|)
block|{
name|inpmask
operator|->
name|i6
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|inpmask
operator|->
name|i6
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|inpmask
operator|->
name|i6
index|[
literal|2
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|inpmask
operator|->
name|i6
index|[
literal|3
index|]
operator|=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|atype
operator|==
name|FRI_NETWORK
operator|||
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|inpmask
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|inpmask
operator|->
name|i6
index|[
literal|0
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|inpmask
operator|->
name|i6
index|[
literal|1
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|inpmask
operator|->
name|i6
index|[
literal|2
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|inpmask
operator|->
name|i6
index|[
literal|3
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
name|inp
operator|->
name|i6
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|0
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|inp
operator|->
name|i6
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|1
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|inp
operator|->
name|i6
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|2
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|inp
operator|->
name|i6
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|3
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|i6
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|inp
operator|->
name|i6
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|inp
operator|->
name|i6
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|inp
operator|->
name|i6
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matchtag                                                */
end_comment

begin_comment
comment|/* Returns:     0 == mismatch, 1 == match.                                  */
end_comment

begin_comment
comment|/* Parameters:  tag1(I) - pointer to first tag to compare                   */
end_comment

begin_comment
comment|/*              tag2(I) - pointer to second tag to compare                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns true (non-zero) or false(0) if the two tag structures can be     */
end_comment

begin_comment
comment|/* considered to be a match or not match, respectively.  The tag is 16      */
end_comment

begin_comment
comment|/* bytes long (16 characters) but that is overlayed with 4 32bit ints so    */
end_comment

begin_comment
comment|/* compare the ints instead, for speed. tag1 is the master of the           */
end_comment

begin_comment
comment|/* comparison.  This function should only be called with both tag1 and tag2 */
end_comment

begin_comment
comment|/* as non-NULL pointers.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_matchtag
parameter_list|(
name|tag1
parameter_list|,
name|tag2
parameter_list|)
name|ipftag_t
modifier|*
name|tag1
decl_stmt|,
decl|*
name|tag2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|tag1
operator|==
name|tag2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tag2
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|1
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|2
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|2
index|]
operator|)
operator|&&
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|3
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|3
index|]
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_coalesce                                                */
end_comment

begin_comment
comment|/* Returns:     1 == success, -1 == failure, 0 == no change                 */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Attempt to get all of the packet data into a single, contiguous buffer.  */
end_comment

begin_comment
comment|/* If this call returns a failure then the buffers have also been freed.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_coalesce
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_COALESCE
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * If the mbuf pointers indicate that there is no mbuf to work with, 	 * return but do not indicate success or failure. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_m
operator|==
name|NULL
operator|||
name|fin
operator|->
name|fin_mp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|ipf_pullup
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|DT1
argument_list|(
name|frb_coalesce
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_stats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_badcoalesces
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MENTAT
name|FREE_MB_T
argument_list|(
operator|*
name|fin
operator|->
name|fin_mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_COALESCE
expr_stmt|;
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
name|fin
operator|=
name|fin
expr_stmt|;
comment|/* LINT */
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The following table lists all of the tunable variables that can be  * accessed via SIOCIPFGET/SIOCIPFSET/SIOCIPFGETNEXt.  The format of each row  * in the table below is as follows:  *  * pointer to value, name of value, minimum, maximum, size of the value's  *     container, value attribute flags  *  * For convienience, IPFT_RDONLY means the value is read-only, IPFT_WRDISABLED  * means the value can only be written to when IPFilter is loaded but disabled.  * The obvious implication is if neither of these are set then the value can be  * changed at any time without harm.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_findbycookie                                       */
end_comment

begin_comment
comment|/* Returns:     NULL = search failed, else pointer to tune struct           */
end_comment

begin_comment
comment|/* Parameters:  cookie(I) - cookie value to search for amongst tuneables    */
end_comment

begin_comment
comment|/*              next(O)   - pointer to place to store the cookie for the    */
end_comment

begin_comment
comment|/*                          "next" tuneable, if it is desired.              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is used to walk through all of the existing tunables with  */
end_comment

begin_comment
comment|/* successive calls.  It searches the known tunables for the one which has  */
end_comment

begin_comment
comment|/* a matching value for "cookie" - ie its address.  When returning a match, */
end_comment

begin_comment
comment|/* the next one to be found may be returned inside next.                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipftuneable_t
modifier|*
name|ipf_tune_findbycookie
parameter_list|(
name|ptop
parameter_list|,
name|cookie
parameter_list|,
name|next
parameter_list|)
name|ipftuneable_t
modifier|*
modifier|*
name|ptop
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|,
decl|*
modifier|*
name|next
decl_stmt|;
end_function

begin_block
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|,
modifier|*
modifier|*
name|tap
decl_stmt|;
for|for
control|(
name|ta
operator|=
operator|*
name|ptop
init|;
name|ta
operator|->
name|ipft_name
operator|!=
name|NULL
condition|;
name|ta
operator|++
control|)
if|if
condition|(
name|ta
operator|==
name|cookie
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * If the next entry in the array has a name 				 * present, then return a pointer to it for 				 * where to go next, else return a pointer to 				 * the dynaminc list as a key to search there 				 * next.  This facilitates a weak linking of 				 * the two "lists" together. 				 */
if|if
condition|(
operator|(
name|ta
operator|+
literal|1
operator|)
operator|->
name|ipft_name
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|=
name|ta
operator|+
literal|1
expr_stmt|;
else|else
operator|*
name|next
operator|=
name|ptop
expr_stmt|;
block|}
return|return
name|ta
return|;
block|}
for|for
control|(
name|tap
operator|=
name|ptop
init|;
operator|(
name|ta
operator|=
operator|*
name|tap
operator|)
operator|!=
name|NULL
condition|;
name|tap
operator|=
operator|&
name|ta
operator|->
name|ipft_next
control|)
if|if
condition|(
name|tap
operator|==
name|cookie
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|=
operator|&
name|ta
operator|->
name|ipft_next
expr_stmt|;
return|return
name|ta
return|;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_findbyname                                         */
end_comment

begin_comment
comment|/* Returns:     NULL = search failed, else pointer to tune struct           */
end_comment

begin_comment
comment|/* Parameters:  name(I) - name of the tuneable entry to find.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search the static array of tuneables and the list of dynamic tuneables   */
end_comment

begin_comment
comment|/* for an entry with a matching name.  If we can find one, return a pointer */
end_comment

begin_comment
comment|/* to the matching structure.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipftuneable_t
modifier|*
name|ipf_tune_findbyname
parameter_list|(
name|top
parameter_list|,
name|name
parameter_list|)
name|ipftuneable_t
modifier|*
name|top
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|;
for|for
control|(
name|ta
operator|=
name|top
init|;
name|ta
operator|!=
name|NULL
condition|;
name|ta
operator|=
name|ta
operator|->
name|ipft_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|ta
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_add_array                                          */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  newtune - pointer to new tune array to add to tuneables     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Appends tune structures from the array passed in (newtune) to the end of */
end_comment

begin_comment
comment|/* the current list of "dynamic" tuneable parameters.                       */
end_comment

begin_comment
comment|/* If any entry to be added is already present (by name) then the operation */
end_comment

begin_comment
comment|/* is aborted - entries that have been added are removed before returning.  */
end_comment

begin_comment
comment|/* An entry with no name (NULL) is used as the indication that the end of   */
end_comment

begin_comment
comment|/* the array has been reached.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tune_add_array
parameter_list|(
name|softc
parameter_list|,
name|newtune
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|newtune
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|nt
decl_stmt|,
modifier|*
name|dt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|nt
operator|=
name|newtune
init|;
name|nt
operator|->
name|ipft_name
operator|!=
name|NULL
condition|;
name|nt
operator|++
control|)
block|{
name|error
operator|=
name|ipf_tune_add
argument_list|(
name|softc
argument_list|,
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|dt
operator|=
name|newtune
init|;
name|dt
operator|!=
name|nt
condition|;
name|dt
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ipf_tune_del
argument_list|(
name|softc
argument_list|,
name|dt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_array_link                                         */
end_comment

begin_comment
comment|/* Returns:     0 == success, -1 == failure                                 */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - soft context pointerto work with                 */
end_comment

begin_comment
comment|/*              array(I) - pointer to an array of tuneables                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given an array of tunables (array), append them to the current list of   */
end_comment

begin_comment
comment|/* tuneables for this context (softc->ipf_tuners.) To properly prepare the  */
end_comment

begin_comment
comment|/* the array for being appended to the list, initialise all of the next     */
end_comment

begin_comment
comment|/* pointers so we don't need to walk parts of it with ++ and others with    */
end_comment

begin_comment
comment|/* next. The array is expected to have an entry with a NULL name as the     */
end_comment

begin_comment
comment|/* terminator. Trying to add an array with no non-NULL names will return as */
end_comment

begin_comment
comment|/* a failure.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tune_array_link
parameter_list|(
name|softc
parameter_list|,
name|array
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|array
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|t
operator|=
name|array
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|ipft_name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
name|t
index|[
literal|1
index|]
operator|.
name|ipft_name
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
name|t
index|[
literal|0
index|]
operator|.
name|ipft_next
operator|=
operator|&
name|t
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|->
name|ipft_next
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Since a pointer to the last entry isn't kept, we need to find it 	 * each time we want to add new variables to the list. 	 */
for|for
control|(
name|p
operator|=
operator|&
name|softc
operator|->
name|ipf_tuners
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
name|t
operator|->
name|ipft_next
control|)
if|if
condition|(
name|t
operator|->
name|ipft_name
operator|==
name|NULL
condition|)
break|break;
operator|*
name|p
operator|=
name|array
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_array_unlink                                       */
end_comment

begin_comment
comment|/* Returns:     0 == success, -1 == failure                                 */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - soft context pointerto work with                 */
end_comment

begin_comment
comment|/*              array(I) - pointer to an array of tuneables                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tune_array_unlink
parameter_list|(
name|softc
parameter_list|,
name|array
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|array
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|softc
operator|->
name|ipf_tuners
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
name|t
operator|->
name|ipft_next
control|)
if|if
condition|(
name|t
operator|==
name|array
condition|)
break|break;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
name|t
index|[
literal|1
index|]
operator|.
name|ipft_name
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
name|t
operator|->
name|ipft_next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_tune_array_copy                                          */
end_comment

begin_comment
comment|/* Returns:    NULL = failure, else pointer to new array                    */
end_comment

begin_comment
comment|/* Parameters: base(I)     - pointer to structure base                      */
end_comment

begin_comment
comment|/*             size(I)     - size of the array at template                  */
end_comment

begin_comment
comment|/*             template(I) - original array to copy                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Allocate memory for a new set of tuneable values and copy everything     */
end_comment

begin_comment
comment|/* from template into the new region of memory.  The new region is full of  */
end_comment

begin_comment
comment|/* uninitialised pointers (ipft_next) so set them up.  Now, ipftp_offset... */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: the following assumes that sizeof(long) == sizeof(void *)          */
end_comment

begin_comment
comment|/* In the array template, ipftp_offset is the offset (in bytes) of the      */
end_comment

begin_comment
comment|/* location of the tuneable value inside the structure pointed to by base.  */
end_comment

begin_comment
comment|/* As ipftp_offset is a union over the pointers to the tuneable values, if  */
end_comment

begin_comment
comment|/* we add base to the copy's ipftp_offset, copy ends up with a pointer in   */
end_comment

begin_comment
comment|/* ipftp_void that points to the stored value.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipftuneable_t
modifier|*
name|ipf_tune_array_copy
parameter_list|(
name|base
parameter_list|,
name|size
parameter_list|,
name|template
parameter_list|)
name|void
modifier|*
name|base
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ipftuneable_t
modifier|*
name|template
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KMALLOCS
argument_list|(
name|copy
argument_list|,
name|ipftuneable_t
operator|*
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|template
argument_list|,
name|copy
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|copy
index|[
name|i
index|]
operator|.
name|ipft_name
condition|;
name|i
operator|++
control|)
block|{
name|copy
index|[
name|i
index|]
operator|.
name|ipft_una
operator|.
name|ipftp_offset
operator|+=
operator|(
name|u_long
operator|)
name|base
expr_stmt|;
name|copy
index|[
name|i
index|]
operator|.
name|ipft_next
operator|=
name|copy
operator|+
name|i
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_add                                                */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  newtune - pointer to new tune entry to add to tuneables     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Appends tune structures from the array passed in (newtune) to the end of */
end_comment

begin_comment
comment|/* the current list of "dynamic" tuneable parameters.  Once added, the      */
end_comment

begin_comment
comment|/* owner of the object is not expected to ever change "ipft_next".          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tune_add
parameter_list|(
name|softc
parameter_list|,
name|newtune
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|newtune
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|,
modifier|*
modifier|*
name|tap
decl_stmt|;
name|ta
operator|=
name|ipf_tune_findbyname
argument_list|(
name|softc
operator|->
name|ipf_tuners
argument_list|,
name|newtune
operator|->
name|ipft_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|74
argument_list|)
expr_stmt|;
return|return
name|EEXIST
return|;
block|}
for|for
control|(
name|tap
operator|=
operator|&
name|softc
operator|->
name|ipf_tuners
init|;
operator|*
name|tap
operator|!=
name|NULL
condition|;
name|tap
operator|=
operator|&
operator|(
operator|*
name|tap
operator|)
operator|->
name|ipft_next
control|)
empty_stmt|;
name|newtune
operator|->
name|ipft_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|tap
operator|=
name|newtune
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_del                                                */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  oldtune - pointer to tune entry to remove from the list of  */
end_comment

begin_comment
comment|/*                        current dynamic tuneables                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search for the tune structure, by pointer, in the list of those that are */
end_comment

begin_comment
comment|/* dynamically added at run time.  If found, adjust the list so that this   */
end_comment

begin_comment
comment|/* structure is no longer part of it.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tune_del
parameter_list|(
name|softc
parameter_list|,
name|oldtune
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|oldtune
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|,
modifier|*
modifier|*
name|tap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tap
operator|=
operator|&
name|softc
operator|->
name|ipf_tuners
init|;
operator|(
name|ta
operator|=
operator|*
name|tap
operator|)
operator|!=
name|NULL
condition|;
name|tap
operator|=
operator|&
name|ta
operator|->
name|ipft_next
control|)
block|{
if|if
condition|(
name|ta
operator|==
name|oldtune
condition|)
block|{
operator|*
name|tap
operator|=
name|oldtune
operator|->
name|ipft_next
expr_stmt|;
name|oldtune
operator|->
name|ipft_next
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ta
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
name|IPFERROR
argument_list|(
literal|75
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune_del_array                                          */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  oldtune - pointer to tuneables array                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove each tuneable entry in the array from the list of "dynamic"       */
end_comment

begin_comment
comment|/* tunables.  If one entry should fail to be found, an error will be        */
end_comment

begin_comment
comment|/* returned and no further ones removed.                                    */
end_comment

begin_comment
comment|/* An entry with a NULL name is used as the indicator of the last entry in  */
end_comment

begin_comment
comment|/* the array.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tune_del_array
parameter_list|(
name|softc
parameter_list|,
name|oldtune
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|oldtune
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ot
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ot
operator|=
name|oldtune
init|;
name|ot
operator|->
name|ipft_name
operator|!=
name|NULL
condition|;
name|ot
operator|++
control|)
block|{
name|error
operator|=
name|ipf_tune_del
argument_list|(
name|softc
argument_list|,
name|ot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tune                                                    */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  cmd(I)  - ioctl command number                              */
end_comment

begin_comment
comment|/*              data(I) - pointer to ioctl data structure                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Implement handling of SIOCIPFGETNEXT, SIOCIPFGET and SIOCIPFSET.  These  */
end_comment

begin_comment
comment|/* three ioctls provide the means to access and control global variables    */
end_comment

begin_comment
comment|/* within IPFilter, allowing (for example) timeouts and table sizes to be   */
end_comment

begin_comment
comment|/* changed without rebooting, reloading or recompiling.  The initialisation */
end_comment

begin_comment
comment|/* and 'destruction' routines of the various components of ipfilter are all */
end_comment

begin_comment
comment|/* each responsible for handling their own values being too big.            */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ipftune
parameter_list|(
name|softc
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|;
name|ipftune_t
name|tu
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tu
operator|.
name|ipft_name
index|[
sizeof|sizeof
argument_list|(
name|tu
operator|.
name|ipft_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cookie
operator|=
name|tu
operator|.
name|ipft_cookie
expr_stmt|;
name|ta
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCIPFGETNEXT
case|:
comment|/* 		 * If cookie is non-NULL, assume it to be a pointer to the last 		 * entry we looked at, so find it (if possible) and return a 		 * pointer to the next one after it.  The last entry in the 		 * the table is a NULL entry, so when we get to it, set cookie 		 * to NULL and return that, indicating end of list, erstwhile 		 * if we come in with cookie set to NULL, we are starting anew 		 * at the front of the list. 		 */
if|if
condition|(
name|cookie
operator|!=
name|NULL
condition|)
block|{
name|ta
operator|=
name|ipf_tune_findbycookie
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tuners
argument_list|,
name|cookie
argument_list|,
operator|&
name|tu
operator|.
name|ipft_cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ta
operator|=
name|softc
operator|->
name|ipf_tuners
expr_stmt|;
name|tu
operator|.
name|ipft_cookie
operator|=
name|ta
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Entry found, but does the data pointed to by that 			 * row fit in what we can return? 			 */
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|>
sizeof|sizeof
argument_list|(
name|tu
operator|.
name|ipft_un
argument_list|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|76
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|tu
operator|.
name|ipft_vlong
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vlong
operator|=
operator|*
name|ta
operator|->
name|ipft_plong
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vint
operator|=
operator|*
name|ta
operator|->
name|ipft_pint
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vshort
operator|=
operator|*
name|ta
operator|->
name|ipft_pshort
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vchar
operator|=
operator|*
name|ta
operator|->
name|ipft_pchar
expr_stmt|;
name|tu
operator|.
name|ipft_sz
operator|=
name|ta
operator|->
name|ipft_sz
expr_stmt|;
name|tu
operator|.
name|ipft_min
operator|=
name|ta
operator|->
name|ipft_min
expr_stmt|;
name|tu
operator|.
name|ipft_max
operator|=
name|ta
operator|->
name|ipft_max
expr_stmt|;
name|tu
operator|.
name|ipft_flags
operator|=
name|ta
operator|->
name|ipft_flags
expr_stmt|;
name|bcopy
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|,
name|tu
operator|.
name|ipft_name
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|tu
operator|.
name|ipft_name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCIPFGET
case|:
case|case
name|SIOCIPFSET
case|:
comment|/* 		 * Search by name or by cookie value for a particular entry 		 * in the tuning paramter table. 		 */
name|IPFERROR
argument_list|(
literal|77
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
if|if
condition|(
name|cookie
operator|!=
name|NULL
condition|)
block|{
name|ta
operator|=
name|ipf_tune_findbycookie
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tuners
argument_list|,
name|cookie
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tu
operator|.
name|ipft_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ta
operator|=
name|ipf_tune_findbyname
argument_list|(
name|softc
operator|->
name|ipf_tuners
argument_list|,
name|tu
operator|.
name|ipft_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCIPFGET
condition|)
block|{
comment|/* 			 * Fetch the tuning parameters for a particular value 			 */
name|tu
operator|.
name|ipft_vlong
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vlong
operator|=
operator|*
name|ta
operator|->
name|ipft_plong
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vint
operator|=
operator|*
name|ta
operator|->
name|ipft_pint
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vshort
operator|=
operator|*
name|ta
operator|->
name|ipft_pshort
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vchar
operator|=
operator|*
name|ta
operator|->
name|ipft_pchar
expr_stmt|;
name|tu
operator|.
name|ipft_cookie
operator|=
name|ta
expr_stmt|;
name|tu
operator|.
name|ipft_sz
operator|=
name|ta
operator|->
name|ipft_sz
expr_stmt|;
name|tu
operator|.
name|ipft_min
operator|=
name|ta
operator|->
name|ipft_min
expr_stmt|;
name|tu
operator|.
name|ipft_max
operator|=
name|ta
operator|->
name|ipft_max
expr_stmt|;
name|tu
operator|.
name|ipft_flags
operator|=
name|ta
operator|->
name|ipft_flags
expr_stmt|;
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCIPFSET
condition|)
block|{
comment|/* 			 * Set an internal parameter.  The hard part here is 			 * getting the new value safely and correctly out of 			 * the kernel (given we only know its size, not type.) 			 */
name|u_long
name|in
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ta
operator|->
name|ipft_flags
operator|&
name|IPFT_WRDISABLED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|78
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|in
operator|=
name|tu
operator|.
name|ipft_vlong
expr_stmt|;
if|if
condition|(
name|in
operator|<
name|ta
operator|->
name|ipft_min
operator|||
name|in
operator|>
name|ta
operator|->
name|ipft_max
condition|)
block|{
name|IPFERROR
argument_list|(
literal|79
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ta
operator|->
name|ipft_func
operator|!=
name|NULL
condition|)
block|{
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ta
operator|->
name|ipft_func
call|)
argument_list|(
name|softc
argument_list|,
name|ta
argument_list|,
operator|&
name|tu
operator|.
name|ipft_un
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vlong
operator|=
operator|*
name|ta
operator|->
name|ipft_plong
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_plong
operator|=
name|in
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vint
operator|=
operator|*
name|ta
operator|->
name|ipft_pint
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_pint
operator|=
call|(
name|u_int
call|)
argument_list|(
name|in
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vshort
operator|=
operator|*
name|ta
operator|->
name|ipft_pshort
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_pshort
operator|=
call|(
name|u_short
call|)
argument_list|(
name|in
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vchar
operator|=
operator|*
name|ta
operator|->
name|ipft_pchar
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_pchar
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|80
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_zerostats                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else failure                             */
end_comment

begin_comment
comment|/* Parameters:  data(O) - pointer to pointer for copying data back to       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copies the current statistics out to userspace and then zero's the       */
end_comment

begin_comment
comment|/* current ones in the kernel. The lock is only held across the bzero() as  */
end_comment

begin_comment
comment|/* the copyout may result in paging (ie network activity.)                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_zerostats
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|friostat_t
name|fio
decl_stmt|;
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|fio
argument_list|,
name|IPFOBJ_IPFSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|ipf_getstat
argument_list|(
name|softc
argument_list|,
operator|&
name|fio
argument_list|,
name|obj
operator|.
name|ipfo_rev
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|fio
argument_list|,
name|IPFOBJ_IPFSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|softc
operator|->
name|ipf_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|ipf_stats
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_resolvedest                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              base(I)  - where strings are stored                         */
end_comment

begin_comment
comment|/*              fdp(IO)  - pointer to destination information to resolve    */
end_comment

begin_comment
comment|/*              v(I)     - IP protocol version to match                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Looks up an interface name in the frdest structure pointed to by fdp and */
end_comment

begin_comment
comment|/* if a matching name can be found for the particular IP protocol version   */
end_comment

begin_comment
comment|/* then store the interface pointer in the frdest struct.  If no match is   */
end_comment

begin_comment
comment|/* found, then set the interface pointer to be -1 as NULL is considered to  */
end_comment

begin_comment
comment|/* indicate there is no information at all in the structure.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_resolvedest
parameter_list|(
name|softc
parameter_list|,
name|base
parameter_list|,
name|fdp
parameter_list|,
name|v
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|int
name|errval
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_name
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
block|{
name|ifp
operator|=
name|ipf_lookup_res_name
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|IPLT_DSTLIST
argument_list|,
name|base
operator|+
name|fdp
operator|->
name|fd_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|144
argument_list|)
expr_stmt|;
name|errval
operator|=
name|ESRCH
expr_stmt|;
block|}
block|}
else|else
block|{
name|ifp
operator|=
name|GETIFP
argument_list|(
name|base
operator|+
name|fdp
operator|->
name|fd_name
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|ifp
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|fdp
operator|->
name|fd_ptr
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ifp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|fdp
operator|->
name|fd_local
operator|=
name|ipf_deliverlocal
argument_list|(
name|softc
argument_list|,
name|v
argument_list|,
name|ifp
argument_list|,
operator|&
name|fdp
operator|->
name|fd_ip6
argument_list|)
expr_stmt|;
block|}
return|return
name|errval
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_resolvenic                                              */
end_comment

begin_comment
comment|/* Returns:     void* - NULL = wildcard name, -1 = failed to find NIC, else */
end_comment

begin_comment
comment|/*                      pointer to interface structure for NIC              */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure            */
end_comment

begin_comment
comment|/*              name(I) - complete interface name                           */
end_comment

begin_comment
comment|/*              v(I)    - IP protocol version                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a network interface structure that firstly has a matching name  */
end_comment

begin_comment
comment|/* to that passed in and that is also being used for that IP protocol       */
end_comment

begin_comment
comment|/* version (necessary on some platforms where there are separate listings   */
end_comment

begin_comment
comment|/* for both IPv4 and IPv6 on the same physical NIC.                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|ipf_resolvenic
parameter_list|(
name|softc
parameter_list|,
name|name
parameter_list|,
name|v
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|void
modifier|*
name|nic
decl_stmt|;
name|softc
operator|=
name|softc
expr_stmt|;
comment|/* gcc -Wextra */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|nic
operator|=
name|GETIFP
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|==
name|NULL
condition|)
name|nic
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|nic
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_expire                                            */
end_comment

begin_comment
comment|/* Returns:     None.                                                       */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is run every ipf tick to see if there are any tokens that  */
end_comment

begin_comment
comment|/* have been held for too long and need to be freed up.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_token_expire
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipftoken_t
modifier|*
name|it
decl_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|it
operator|=
name|softc
operator|->
name|ipf_token_head
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|ipt_die
operator|>
name|softc
operator|->
name|ipf_ticks
condition|)
break|break;
name|ipf_token_deref
argument_list|(
name|softc
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_flush                                             */
end_comment

begin_comment
comment|/* Returns:     None.                                                       */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Loop through all of the existing tokens and call deref to see if they    */
end_comment

begin_comment
comment|/* can be freed. Normally a function like this might just loop on           */
end_comment

begin_comment
comment|/* ipf_token_head but there is a chance that a token might have a ref count */
end_comment

begin_comment
comment|/* of greater than one and in that case the the reference would drop twice  */
end_comment

begin_comment
comment|/* by code that is only entitled to drop it once.                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_token_flush
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipftoken_t
modifier|*
name|it
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|softc
operator|->
name|ipf_token_head
init|;
name|it
operator|!=
name|NULL
condition|;
name|it
operator|=
name|next
control|)
block|{
name|next
operator|=
name|it
operator|->
name|ipt_next
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_token_deref
argument_list|(
name|softc
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_del                                               */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else error                           */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure            */
end_comment

begin_comment
comment|/*              type(I) - the token type to match                           */
end_comment

begin_comment
comment|/*              uid(I)  - uid owning the token                              */
end_comment

begin_comment
comment|/*              ptr(I)  - context pointer for the token                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function looks for a a token in the current list that matches up    */
end_comment

begin_comment
comment|/* the fields (type, uid, ptr).  If none is found, ESRCH is returned, else  */
end_comment

begin_comment
comment|/* call ipf_token_dewref() to remove it from the list. In the event that    */
end_comment

begin_comment
comment|/* the token has a reference held elsewhere, setting ipt_complete to 2      */
end_comment

begin_comment
comment|/* enables debugging to distinguish between the two paths that ultimately   */
end_comment

begin_comment
comment|/* lead to a token to be deleted.                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_token_del
parameter_list|(
name|softc
parameter_list|,
name|type
parameter_list|,
name|uid
parameter_list|,
name|ptr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|type
decl_stmt|,
name|uid
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|ipftoken_t
modifier|*
name|it
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IPFERROR
argument_list|(
literal|82
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|softc
operator|->
name|ipf_token_head
init|;
name|it
operator|!=
name|NULL
condition|;
name|it
operator|=
name|it
operator|->
name|ipt_next
control|)
block|{
if|if
condition|(
name|ptr
operator|==
name|it
operator|->
name|ipt_ctx
operator|&&
name|type
operator|==
name|it
operator|->
name|ipt_type
operator|&&
name|uid
operator|==
name|it
operator|->
name|ipt_uid
condition|)
block|{
name|it
operator|->
name|ipt_complete
operator|=
literal|2
expr_stmt|;
name|ipf_token_deref
argument_list|(
name|softc
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_mark_complete                                     */
end_comment

begin_comment
comment|/* Returns:     None.                                                       */
end_comment

begin_comment
comment|/* Parameters:  token(I) - pointer to token structure                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Mark a token as being ineligable for being found with ipf_token_find.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_token_mark_complete
parameter_list|(
name|token
parameter_list|)
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
block|{
if|if
condition|(
name|token
operator|->
name|ipt_complete
operator|==
literal|0
condition|)
name|token
operator|->
name|ipt_complete
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_find                                               */
end_comment

begin_comment
comment|/* Returns:     ipftoken_t * - NULL if no memory, else pointer to token     */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure            */
end_comment

begin_comment
comment|/*              type(I) - the token type to match                           */
end_comment

begin_comment
comment|/*              uid(I)  - uid owning the token                              */
end_comment

begin_comment
comment|/*              ptr(I)  - context pointer for the token                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function looks for a live token in the list of current tokens that  */
end_comment

begin_comment
comment|/* matches the tuple (type, uid, ptr).  If one cannot be found then one is  */
end_comment

begin_comment
comment|/* allocated.  If one is found then it is moved to the top of the list of   */
end_comment

begin_comment
comment|/* currently active tokens.                                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipftoken_t
modifier|*
name|ipf_token_find
parameter_list|(
name|softc
parameter_list|,
name|type
parameter_list|,
name|uid
parameter_list|,
name|ptr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|type
decl_stmt|,
name|uid
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|ipftoken_t
modifier|*
name|it
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|KMALLOC
argument_list|(
name|new
argument_list|,
name|ipftoken_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
for|for
control|(
name|it
operator|=
name|softc
operator|->
name|ipf_token_head
init|;
name|it
operator|!=
name|NULL
condition|;
name|it
operator|=
name|it
operator|->
name|ipt_next
control|)
block|{
if|if
condition|(
operator|(
name|ptr
operator|==
name|it
operator|->
name|ipt_ctx
operator|)
operator|&&
operator|(
name|type
operator|==
name|it
operator|->
name|ipt_type
operator|)
operator|&&
operator|(
name|uid
operator|==
name|it
operator|->
name|ipt_uid
operator|)
operator|&&
operator|(
name|it
operator|->
name|ipt_complete
operator|<
literal|2
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|it
operator|=
name|new
expr_stmt|;
name|new
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|it
operator|->
name|ipt_ctx
operator|=
name|ptr
expr_stmt|;
name|it
operator|->
name|ipt_uid
operator|=
name|uid
expr_stmt|;
name|it
operator|->
name|ipt_type
operator|=
name|type
expr_stmt|;
name|it
operator|->
name|ipt_ref
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|ipt_complete
operator|>
literal|0
condition|)
name|it
operator|=
name|NULL
expr_stmt|;
else|else
name|ipf_token_unlink
argument_list|(
name|softc
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|!=
name|NULL
condition|)
block|{
name|it
operator|->
name|ipt_pnext
operator|=
name|softc
operator|->
name|ipf_token_tail
expr_stmt|;
operator|*
name|softc
operator|->
name|ipf_token_tail
operator|=
name|it
expr_stmt|;
name|softc
operator|->
name|ipf_token_tail
operator|=
operator|&
name|it
operator|->
name|ipt_next
expr_stmt|;
name|it
operator|->
name|ipt_next
operator|=
name|NULL
expr_stmt|;
name|it
operator|->
name|ipt_ref
operator|++
expr_stmt|;
name|it
operator|->
name|ipt_die
operator|=
name|softc
operator|->
name|ipf_ticks
operator|+
literal|20
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
return|return
name|it
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_unlink                                            */
end_comment

begin_comment
comment|/* Returns:     None.                                                       */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              token(I) - pointer to token structure                       */
end_comment

begin_comment
comment|/* Write Locks: ipf_tokens                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function unlinks a token structure from the linked list of tokens   */
end_comment

begin_comment
comment|/* that "own" it.  The head pointer never needs to be explicitly adjusted   */
end_comment

begin_comment
comment|/* but the tail does due to the linked list implementation.                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_token_unlink
parameter_list|(
name|softc
parameter_list|,
name|token
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_token_tail
operator|==
operator|&
name|token
operator|->
name|ipt_next
condition|)
name|softc
operator|->
name|ipf_token_tail
operator|=
name|token
operator|->
name|ipt_pnext
expr_stmt|;
operator|*
name|token
operator|->
name|ipt_pnext
operator|=
name|token
operator|->
name|ipt_next
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|ipt_next
operator|!=
name|NULL
condition|)
name|token
operator|->
name|ipt_next
operator|->
name|ipt_pnext
operator|=
name|token
operator|->
name|ipt_pnext
expr_stmt|;
name|token
operator|->
name|ipt_next
operator|=
name|NULL
expr_stmt|;
name|token
operator|->
name|ipt_pnext
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_token_deref                                             */
end_comment

begin_comment
comment|/* Returns:     int      - 0 == token freed, else reference count           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              token(I) - pointer to token structure                       */
end_comment

begin_comment
comment|/* Write Locks: ipf_tokens                                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Drop the reference count on the token structure and if it drops to zero, */
end_comment

begin_comment
comment|/* call the dereference function for the token type because it is then      */
end_comment

begin_comment
comment|/* possible to free the token data structure.                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_token_deref
parameter_list|(
name|softc
parameter_list|,
name|token
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
block|{
name|void
modifier|*
name|data
decl_stmt|,
modifier|*
modifier|*
name|datap
decl_stmt|;
name|ASSERT
argument_list|(
name|token
operator|->
name|ipt_ref
operator|>
literal|0
argument_list|)
expr_stmt|;
name|token
operator|->
name|ipt_ref
operator|--
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|ipt_ref
operator|>
literal|0
condition|)
return|return
name|token
operator|->
name|ipt_ref
return|;
name|data
operator|=
name|token
operator|->
name|ipt_data
expr_stmt|;
name|datap
operator|=
operator|&
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|data
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
switch|switch
condition|(
name|token
operator|->
name|ipt_type
condition|)
block|{
case|case
name|IPFGENITER_IPF
case|:
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|(
name|frentry_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPFGENITER_IPNAT
case|:
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_nat
argument_list|)
expr_stmt|;
name|ipf_nat_rule_deref
argument_list|(
name|softc
argument_list|,
operator|(
name|ipnat_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_nat
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPFGENITER_NAT
case|:
name|ipf_nat_deref
argument_list|(
name|softc
argument_list|,
operator|(
name|nat_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPFGENITER_STATE
case|:
name|ipf_state_deref
argument_list|(
name|softc
argument_list|,
operator|(
name|ipstate_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPFGENITER_FRAG
case|:
name|ipf_frag_pkt_deref
argument_list|(
name|softc
argument_list|,
operator|(
name|ipfr_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPFGENITER_NATFRAG
case|:
name|ipf_frag_nat_deref
argument_list|(
name|softc
argument_list|,
operator|(
name|ipfr_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPFGENITER_HOSTMAP
case|:
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_nat
argument_list|)
expr_stmt|;
name|ipf_nat_hostmapdel
argument_list|(
name|softc
argument_list|,
operator|(
name|hostmap_t
operator|*
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_nat
argument_list|)
expr_stmt|;
break|break;
default|default :
name|ipf_lookup_iterderef
argument_list|(
name|softc
argument_list|,
name|token
operator|->
name|ipt_type
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ipf_token_unlink
argument_list|(
name|softc
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_nextrule                                                */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - NULL == no more rules, else pointer to next   */
end_comment

begin_comment
comment|/* Parameters:  softc(I)    - pointer to soft context main structure        */
end_comment

begin_comment
comment|/*              fr(I)       - pointer to filter rule                        */
end_comment

begin_comment
comment|/*              out(I)      - 1 == out rules, 0 == input rules              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Starting with "fr", find the next rule to visit. This includes visiting  */
end_comment

begin_comment
comment|/* the list of rule groups if either fr is NULL (empty list) or it is the   */
end_comment

begin_comment
comment|/* last rule in the list. When walking rule lists, it is either input or    */
end_comment

begin_comment
comment|/* output rules that are returned, never both.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|frentry_t
modifier|*
name|ipf_nextrule
parameter_list|(
name|softc
parameter_list|,
name|active
parameter_list|,
name|unit
parameter_list|,
name|fr
parameter_list|,
name|out
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|active
decl_stmt|,
name|unit
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|int
name|out
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|next
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
operator|&&
name|fr
operator|->
name|fr_group
operator|!=
operator|-
literal|1
condition|)
block|{
name|fg
operator|=
name|ipf_findgroup
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_group
argument_list|,
name|unit
argument_list|,
name|active
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
name|fg
operator|=
name|fg
operator|->
name|fg_next
expr_stmt|;
block|}
else|else
block|{
name|fg
operator|=
name|softc
operator|->
name|ipf_groups
index|[
name|unit
index|]
index|[
name|active
index|]
expr_stmt|;
block|}
while|while
condition|(
name|fg
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|fg
operator|->
name|fg_start
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|out
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|fr_flags
operator|&
name|FR_OUTQUE
condition|)
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|next
operator|->
name|fr_flags
operator|&
name|FR_INQUE
condition|)
block|{
return|return
name|next
return|;
block|}
name|next
operator|=
name|next
operator|->
name|fr_next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|fg
operator|=
name|fg
operator|->
name|fg_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_getnextrule                                             */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else error                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure            */
end_comment

begin_comment
comment|/*              t(I)   - pointer to destination information to resolve      */
end_comment

begin_comment
comment|/*              ptr(I) - pointer to ipfobj_t to copyin from user space      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function's first job is to bring in the ipfruleiter_t structure via */
end_comment

begin_comment
comment|/* the ipfobj_t structure to determine what should be the next rule to      */
end_comment

begin_comment
comment|/* return. Once the ipfruleiter_t has been brought in, it then tries to     */
end_comment

begin_comment
comment|/* find the 'next rule'.  This may include searching rule group lists or    */
end_comment

begin_comment
comment|/* just be as simple as looking at the 'next' field in the rule structure.  */
end_comment

begin_comment
comment|/* When we have found the rule to return, increase its reference count and  */
end_comment

begin_comment
comment|/* if we used an existing rule to get here, decrease its reference count.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_getnextrule
parameter_list|(
name|softc
parameter_list|,
name|t
parameter_list|,
name|ptr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftoken_t
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|,
modifier|*
name|next
decl_stmt|,
name|zero
decl_stmt|;
name|ipfruleiter_t
name|it
decl_stmt|;
name|int
name|error
decl_stmt|,
name|out
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|predict
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
operator|||
name|ptr
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|84
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|ptr
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|it
argument_list|,
name|IPFOBJ_IPFITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|it
operator|.
name|iri_inout
operator|<
literal|0
operator|)
operator|||
operator|(
name|it
operator|.
name|iri_inout
operator|>
literal|3
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|85
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|it
operator|.
name|iri_active
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|it
operator|.
name|iri_active
operator|!=
literal|1
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|86
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|it
operator|.
name|iri_nrules
operator|==
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|87
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
if|if
condition|(
name|it
operator|.
name|iri_rule
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|88
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|fg
operator|=
name|NULL
expr_stmt|;
name|fr
operator|=
name|t
operator|->
name|ipt_data
expr_stmt|;
if|if
condition|(
operator|(
name|it
operator|.
name|iri_inout
operator|&
name|F_OUT
operator|)
operator|!=
literal|0
condition|)
name|out
operator|=
literal|1
expr_stmt|;
else|else
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|it
operator|.
name|iri_inout
operator|&
name|F_ACIN
operator|)
operator|!=
literal|0
condition|)
name|unit
operator|=
name|IPL_LOGCOUNT
expr_stmt|;
else|else
name|unit
operator|=
name|IPL_LOGIPF
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|it
operator|.
name|iri_group
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|unit
operator|==
name|IPL_LOGCOUNT
condition|)
block|{
name|next
operator|=
name|softc
operator|->
name|ipf_acct
index|[
name|out
index|]
index|[
name|it
operator|.
name|iri_active
index|]
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|softc
operator|->
name|ipf_rules
index|[
name|out
index|]
index|[
name|it
operator|.
name|iri_active
index|]
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|next
operator|=
name|ipf_nextrule
argument_list|(
name|softc
argument_list|,
name|it
operator|.
name|iri_active
argument_list|,
name|unit
argument_list|,
name|NULL
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fg
operator|=
name|ipf_findgroup
argument_list|(
name|softc
argument_list|,
name|it
operator|.
name|iri_group
argument_list|,
name|unit
argument_list|,
name|it
operator|.
name|iri_active
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
name|next
operator|=
name|fg
operator|->
name|fg_start
expr_stmt|;
else|else
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|next
operator|=
name|fr
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|next
operator|=
name|ipf_nextrule
argument_list|(
name|softc
argument_list|,
name|it
operator|.
name|iri_active
argument_list|,
name|unit
argument_list|,
name|fr
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|next
operator|->
name|fr_next
operator|!=
name|NULL
condition|)
name|predict
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ipf_nextrule
argument_list|(
name|softc
argument_list|,
name|it
operator|.
name|iri_active
argument_list|,
name|unit
argument_list|,
name|next
argument_list|,
name|out
argument_list|)
operator|!=
name|NULL
condition|)
name|predict
operator|=
literal|1
expr_stmt|;
else|else
name|predict
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
name|obj
operator|.
name|ipfo_type
operator|=
name|IPFOBJ_FRENTRY
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|it
operator|.
name|iri_rule
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|obj
operator|.
name|ipfo_size
operator|=
name|next
operator|->
name|fr_size
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|next
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|next
operator|->
name|fr_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|next
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|t
operator|->
name|ipt_data
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|.
name|ipfo_size
operator|=
sizeof|sizeof
argument_list|(
name|frentry_t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|zero
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|zero
expr_stmt|;
name|t
operator|->
name|ipt_data
operator|=
name|NULL
expr_stmt|;
block|}
name|it
operator|.
name|iri_rule
operator|=
name|predict
condition|?
name|next
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|predict
operator|==
literal|0
condition|)
name|ipf_token_mark_complete
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|obj
operator|.
name|ipfo_ptr
operator|=
name|dst
expr_stmt|;
name|error
operator|=
name|ipf_outobjk
argument_list|(
name|softc
argument_list|,
operator|&
name|obj
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|t
operator|->
name|ipt_data
operator|!=
name|NULL
condition|)
block|{
name|dst
operator|+=
name|obj
operator|.
name|ipfo_size
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|fr_data
operator|!=
name|NULL
condition|)
block|{
name|ipfobj_t
name|dobj
decl_stmt|;
if|if
condition|(
name|next
operator|->
name|fr_type
operator|==
name|FR_T_IPFEXPR
condition|)
name|dobj
operator|.
name|ipfo_type
operator|=
name|IPFOBJ_IPFEXPR
expr_stmt|;
else|else
name|dobj
operator|.
name|ipfo_type
operator|=
name|IPFOBJ_FRIPF
expr_stmt|;
name|dobj
operator|.
name|ipfo_size
operator|=
name|next
operator|->
name|fr_dsize
expr_stmt|;
name|dobj
operator|.
name|ipfo_rev
operator|=
name|obj
operator|.
name|ipfo_rev
expr_stmt|;
name|dobj
operator|.
name|ipfo_ptr
operator|=
name|dst
expr_stmt|;
name|error
operator|=
name|ipf_outobjk
argument_list|(
name|softc
argument_list|,
operator|&
name|dobj
argument_list|,
name|next
operator|->
name|fr_data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|next
operator|==
operator|&
name|zero
operator|)
condition|)
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_frruleiter                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else error                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure            */
end_comment

begin_comment
comment|/*              data(I) - the token type to match                           */
end_comment

begin_comment
comment|/*              uid(I)  - uid owning the token                              */
end_comment

begin_comment
comment|/*              ptr(I)  - context pointer for the token                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function serves as a stepping stone between ipf_ipf_ioctl and       */
end_comment

begin_comment
comment|/* ipf_getnextrule.  It's role is to find the right token in the kernel for */
end_comment

begin_comment
comment|/* the process doing the ioctl and use that to ask for the next rule.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_frruleiter
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|uid
parameter_list|,
name|ctx
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|,
decl|*
name|ctx
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfruleiter_t
name|it
decl_stmt|;
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|token
operator|=
name|ipf_token_find
argument_list|(
name|softc
argument_list|,
name|IPFGENITER_IPF
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ipf_getnextrule
argument_list|(
name|softc
argument_list|,
name|token
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
name|ipf_token_deref
argument_list|(
name|softc
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|it
argument_list|,
name|IPFOBJ_IPFITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|it
operator|.
name|iri_rule
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|it
argument_list|,
name|IPFOBJ_IPFITER
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_geniter                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else error                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              token(I) - pointer to ipftoken_t structure                  */
end_comment

begin_comment
comment|/*              itp(I)   - pointer to iterator data                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Decide which iterator function to call using information passed through  */
end_comment

begin_comment
comment|/* the ipfgeniter_t structure at itp.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_geniter
parameter_list|(
name|softc
parameter_list|,
name|token
parameter_list|,
name|itp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfgeniter_t
modifier|*
name|itp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|itp
operator|->
name|igi_type
condition|)
block|{
case|case
name|IPFGENITER_FRAG
case|:
name|error
operator|=
name|ipf_frag_pkt_next
argument_list|(
name|softc
argument_list|,
name|token
argument_list|,
name|itp
argument_list|)
expr_stmt|;
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|92
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_genericiter                                             */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else error                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure            */
end_comment

begin_comment
comment|/*              data(I) - the token type to match                           */
end_comment

begin_comment
comment|/*              uid(I)  - uid owning the token                              */
end_comment

begin_comment
comment|/*              ptr(I)  - context pointer for the token                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Handle the SIOCGENITER ioctl for the ipfilter device. The primary role   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_genericiter
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|uid
parameter_list|,
name|ctx
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|,
decl|*
name|ctx
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfgeniter_t
name|iter
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
operator|&
name|iter
argument_list|,
name|IPFOBJ_GENITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|token
operator|=
name|ipf_token_find
argument_list|(
name|softc
argument_list|,
name|iter
operator|.
name|igi_type
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
name|token
operator|->
name|ipt_subtype
operator|=
name|iter
operator|.
name|igi_type
expr_stmt|;
name|error
operator|=
name|ipf_geniter
argument_list|(
name|softc
argument_list|,
name|token
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
name|ipf_token_deref
argument_list|(
name|softc
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|93
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ipf_ioctl                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else error                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I)- pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              data(I) - the token type to match                           */
end_comment

begin_comment
comment|/*              cmd(I)  - the ioctl command number                          */
end_comment

begin_comment
comment|/*              mode(I) - mode flags for the ioctl                          */
end_comment

begin_comment
comment|/*              uid(I)  - uid owning the token                              */
end_comment

begin_comment
comment|/*              ptr(I)  - context pointer for the token                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles all of the ioctl command that are actually isssued */
end_comment

begin_comment
comment|/* to the /dev/ipl device.                                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ipf_ioctl
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|cmd
parameter_list|,
name|mode
parameter_list|,
name|uid
parameter_list|,
name|ctx
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|uid
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|friostat_t
name|fio
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tmp
decl_stmt|;
name|ipfobj_t
name|obj
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCFRENB
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|94
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|95
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|>
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|ipfattach
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|softc
operator|->
name|ipf_running
operator|=
literal|1
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|ipfdetach
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|==
literal|1
condition|)
name|error
operator|=
name|ipfdetach
argument_list|(
name|softc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|softc
operator|->
name|ipf_running
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCIPFSET
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|96
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|SIOCIPFGETNEXT
case|:
case|case
name|SIOCIPFGET
case|:
name|error
operator|=
name|ipf_ipftune
argument_list|(
name|softc
argument_list|,
name|cmd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSETFF
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|97
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|softc
operator|->
name|ipf_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|ipf_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|98
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIOCGETFF
case|:
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_flags
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|ipf_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|99
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
case|case
name|SIOCFUNCL
case|:
name|error
operator|=
name|ipf_resolvefunc
argument_list|(
name|softc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCINAFR
case|:
case|case
name|SIOCRMAFR
case|:
case|case
name|SIOCADAFR
case|:
case|case
name|SIOCZRLST
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|frrequest
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
name|softc
operator|->
name|ipf_active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCINIFR
case|:
case|case
name|SIOCRMIFR
case|:
case|case
name|SIOCADIFR
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|101
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|frrequest
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
literal|1
operator|-
name|softc
operator|->
name|ipf_active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSWAPA
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|102
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_active
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|softc
operator|->
name|ipf_active
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|103
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|softc
operator|->
name|ipf_active
operator|=
literal|1
operator|-
name|softc
operator|->
name|ipf_active
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGETFS
case|:
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|fio
argument_list|,
name|IPFOBJ_IPFSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|ipf_getstat
argument_list|(
name|softc
argument_list|,
operator|&
name|fio
argument_list|,
name|obj
operator|.
name|ipfo_rev
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|fio
argument_list|,
name|IPFOBJ_IPFSTAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCFRZST
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|104
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ipf_zerostats
argument_list|(
name|softc
argument_list|,
operator|(
name|caddr_t
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCIPFFL
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|105
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|tmp
operator|=
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|tmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|106
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|107
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|SIOCIPFL6
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|108
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|tmp
operator|=
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|tmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|109
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|110
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|SIOCSTLCK
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|122
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ipf_state_setlock
argument_list|(
name|softc
operator|->
name|ipf_state_soft
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ipf_nat_setlock
argument_list|(
name|softc
operator|->
name|ipf_nat_soft
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ipf_frag_setlock
argument_list|(
name|softc
operator|->
name|ipf_frag_soft
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ipf_auth_setlock
argument_list|(
name|softc
operator|->
name|ipf_auth_soft
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|111
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
case|case
name|SIOCIPFFB
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|112
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|ipf_log_clear
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|tmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IPFERROR
argument_list|(
literal|113
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* IPFILTER_LOG */
case|case
name|SIOCFRSYN
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|114
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|INSTANCES
argument_list|)
name|error
operator|=
name|ipfsync
argument_list|()
expr_stmt|;
else|#
directive|else
name|ipf_sync
argument_list|(
name|softc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGFRST
case|:
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
name|ipf_frag_stats
argument_list|(
name|softc
operator|->
name|ipf_frag_soft
argument_list|)
argument_list|,
name|IPFOBJ_FRAGSTAT
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
case|case
name|FIONREAD
case|:
name|tmp
operator|=
name|ipf_log_bytesused
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|tmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCIPFITER
case|:
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_frruleiter
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGENITER
case|:
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_genericiter
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCIPFDELTOK
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_token_del
argument_list|(
name|softc
argument_list|,
name|tmp
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|115
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_decaps                                                  */
end_comment

begin_comment
comment|/* Returns:     int        - -1 == decapsulation failed, else bit mask of   */
end_comment

begin_comment
comment|/*                           flags indicating packet filtering decision.    */
end_comment

begin_comment
comment|/* Parameters:  fin(I)     - pointer to packet information                  */
end_comment

begin_comment
comment|/*              pass(I)    - IP protocol version to match                   */
end_comment

begin_comment
comment|/*              l5proto(I) - layer 5 protocol to decode UDP data as.        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is called for packets that are wrapt up in other packets,  */
end_comment

begin_comment
comment|/* for example, an IP packet that is the entire data segment for another IP */
end_comment

begin_comment
comment|/* packet.  If the basic constraints for this are satisfied, change the     */
end_comment

begin_comment
comment|/* buffer to point to the start of the inner packet and start processing    */
end_comment

begin_comment
comment|/* rules belonging to the head group this rule specifies.                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_32_t
name|ipf_decaps
parameter_list|(
name|fin
parameter_list|,
name|pass
parameter_list|,
name|l5proto
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|;
name|int
name|l5proto
decl_stmt|;
block|{
name|fr_info_t
name|fin2
decl_stmt|,
modifier|*
name|fino
init|=
name|NULL
decl_stmt|;
name|int
name|elen
decl_stmt|,
name|hlen
decl_stmt|,
name|nh
decl_stmt|;
name|grehdr_t
name|gre
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_COALESCE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ipf_coalesce
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|cantdecaps
goto|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
name|hlen
operator|=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_p
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
comment|/* 		 * In this case, the specific protocol being decapsulated 		 * inside UDP frames comes from the rule. 		 */
name|nh
operator|=
name|fin
operator|->
name|fin_fr
operator|->
name|fr_icode
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
comment|/* 47 */
name|bcopy
argument_list|(
name|fin
operator|->
name|fin_dp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gre
argument_list|,
sizeof|sizeof
argument_list|(
name|gre
argument_list|)
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|gre
operator|.
name|gr_R
operator||
name|gre
operator|.
name|gr_s
condition|)
goto|goto
name|cantdecaps
goto|;
if|if
condition|(
name|gre
operator|.
name|gr_C
condition|)
name|hlen
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|gre
operator|.
name|gr_K
condition|)
name|hlen
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|gre
operator|.
name|gr_S
condition|)
name|hlen
operator|+=
literal|4
expr_stmt|;
name|nh
operator|=
name|IPPROTO_IP
expr_stmt|;
comment|/* 		 * If the routing options flag is set, validate that it is 		 * there and bounce over it. 		 */
if|#
directive|if
literal|0
comment|/* This is really heavy weight and lots of room for error, */
comment|/* so for now, put it off and get the simple stuff right.  */
block|if (gre.gr_R) { 			u_char off, len, *s; 			u_short af; 			int end;  			end = 0; 			s = fin->fin_dp; 			s += hlen; 			aplen = fin->fin_plen - hlen; 			while (aplen> 3) { 				af = (s[0]<< 8) | s[1]; 				off = s[2]; 				len = s[3]; 				aplen -= 4; 				s += 4; 				if (af == 0&& len == 0) { 					end = 1; 					break; 				} 				if (aplen< len) 					break; 				s += len; 				aplen -= len; 			} 			if (end != 1) 				goto cantdecaps; 			hlen = s - (u_char *)fin->fin_dp; 		}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|IPPROTO_IPIP
case|case
name|IPPROTO_IPIP
case|:
comment|/* 4 */
endif|#
directive|endif
name|nh
operator|=
name|IPPROTO_IP
expr_stmt|;
break|break;
default|default :
comment|/* Includes ESP, AH is special for IPv4 */
goto|goto
name|cantdecaps
goto|;
block|}
switch|switch
condition|(
name|nh
condition|)
block|{
case|case
name|IPPROTO_IP
case|:
case|case
name|IPPROTO_IPV6
case|:
break|break;
default|default :
goto|goto
name|cantdecaps
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fin2
argument_list|,
sizeof|sizeof
argument_list|(
name|fin2
argument_list|)
argument_list|)
expr_stmt|;
name|fino
operator|=
name|fin
expr_stmt|;
name|fin
operator|=
operator|&
name|fin2
expr_stmt|;
name|elen
operator|=
name|hlen
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|m
operator|->
name|b_rptr
operator|+=
name|elen
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_data
operator|+=
name|elen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|elen
expr_stmt|;
endif|#
directive|endif
name|fin
operator|->
name|fin_plen
operator|-=
name|elen
expr_stmt|;
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|elen
operator|)
expr_stmt|;
comment|/* 	 * Make sure we have at least enough data for the network layer 	 * header. 	 */
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|4
condition|)
name|hlen
operator|=
name|IP_HL
argument_list|(
name|ip
argument_list|)
operator|<<
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|6
condition|)
name|hlen
operator|=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
goto|goto
name|cantdecaps2
goto|;
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|<
name|hlen
condition|)
goto|goto
name|cantdecaps2
goto|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
expr_stmt|;
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|4
condition|)
block|{
comment|/* 		 * Perform IPv4 header checksum validation. 		 */
if|if
condition|(
name|ipf_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|ip
argument_list|,
name|hlen
argument_list|)
condition|)
goto|goto
name|cantdecaps2
goto|;
block|}
if|if
condition|(
name|ipf_makefrip
argument_list|(
name|hlen
argument_list|,
name|ip
argument_list|,
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|cantdecaps2
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|m
operator|->
name|b_rptr
operator|-=
name|elen
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_data
operator|-=
name|elen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|elen
expr_stmt|;
endif|#
directive|endif
block|}
name|cantdecaps
label|:
name|DT1
argument_list|(
name|frb_decapfrip
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
operator||
name|FR_QUICK
expr_stmt|;
name|fin
operator|->
name|fin_reason
operator|=
name|FRB_DECAPFRIP
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pass
operator|=
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the packet filter "result" fields out of the fr_info_t struct 	 * that is local to the decapsulation processing and back into the 	 * one we were called with. 	 */
name|fino
operator|->
name|fin_flx
operator|=
name|fin
operator|->
name|fin_flx
expr_stmt|;
name|fino
operator|->
name|fin_rev
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
name|fino
operator|->
name|fin_icode
operator|=
name|fin
operator|->
name|fin_icode
expr_stmt|;
name|fino
operator|->
name|fin_rule
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fino
operator|->
name|fin_group
argument_list|,
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fino
operator|->
name|fin_fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|fino
operator|->
name|fin_error
operator|=
name|fin
operator|->
name|fin_error
expr_stmt|;
name|fino
operator|->
name|fin_mp
operator|=
name|fin
operator|->
name|fin_mp
expr_stmt|;
name|fino
operator|->
name|fin_m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|m
operator|->
name|b_rptr
operator|-=
name|elen
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_data
operator|-=
name|elen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|elen
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|pass
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matcharray_load                                         */
end_comment

begin_comment
comment|/* Returns:     int         - 0 = success, else error                       */
end_comment

begin_comment
comment|/* Parameters:  softc(I)    - pointer to soft context main structure        */
end_comment

begin_comment
comment|/*              data(I)     - pointer to ioctl data                         */
end_comment

begin_comment
comment|/*              objp(I)     - ipfobj_t structure to load data into          */
end_comment

begin_comment
comment|/*              arrayptr(I) - pointer to location to store array pointer    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function loads in a mathing array through the ipfobj_t struct that  */
end_comment

begin_comment
comment|/* describes it.  Sanity checking and array size limitations are enforced   */
end_comment

begin_comment
comment|/* in this function to prevent userspace from trying to load in something   */
end_comment

begin_comment
comment|/* that is insanely big.  Once the size of the array is known, the memory   */
end_comment

begin_comment
comment|/* required is malloc'd and returned through changing *arrayptr.  The       */
end_comment

begin_comment
comment|/* contents of the array are verified before returning.  Only in the event  */
end_comment

begin_comment
comment|/* of a successful call is the caller required to free up the malloc area.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_matcharray_load
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|objp
parameter_list|,
name|arrayptr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|ipfobj_t
modifier|*
name|objp
decl_stmt|;
name|int
modifier|*
modifier|*
name|arrayptr
decl_stmt|;
block|{
name|int
name|arraysize
decl_stmt|,
modifier|*
name|array
decl_stmt|,
name|error
decl_stmt|;
operator|*
name|arrayptr
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
name|objp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|objp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|116
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|objp
operator|->
name|ipfo_type
operator|!=
name|IPFOBJ_IPFEXPR
condition|)
block|{
name|IPFERROR
argument_list|(
literal|117
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|objp
operator|->
name|ipfo_size
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|objp
operator|->
name|ipfo_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|objp
operator|->
name|ipfo_size
operator|>
literal|1024
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|118
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|arraysize
operator|=
name|objp
operator|->
name|ipfo_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
expr_stmt|;
name|KMALLOCS
argument_list|(
name|array
argument_list|,
name|int
operator|*
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|119
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|error
operator|=
name|COPYIN
argument_list|(
name|objp
operator|->
name|ipfo_ptr
argument_list|,
name|array
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|KFREES
argument_list|(
name|array
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|120
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|ipf_matcharray_verify
argument_list|(
name|array
argument_list|,
name|arraysize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|KFREES
argument_list|(
name|array
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|121
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|*
name|arrayptr
operator|=
name|array
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matcharray_verify                                       */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  array(I)     - pointer to matching array                    */
end_comment

begin_comment
comment|/*              arraysize(I) - number of elements in the array              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Verify the contents of a matching array by stepping through each element */
end_comment

begin_comment
comment|/* in it.  The actual commands in the array are not verified for            */
end_comment

begin_comment
comment|/* correctness, only that all of the sizes are correctly within limits.     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_matcharray_verify
parameter_list|(
name|array
parameter_list|,
name|arraysize
parameter_list|)
name|int
modifier|*
name|array
decl_stmt|,
name|arraysize
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nelem
decl_stmt|,
name|maxidx
decl_stmt|;
name|ipfexp_t
modifier|*
name|e
decl_stmt|;
name|nelem
operator|=
name|arraysize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
expr_stmt|;
comment|/* 	 * Currently, it makes no sense to have an array less than 6 	 * elements long - the initial size at the from, a single operation 	 * (minimum 4 in length) and a trailer, for a total of 6. 	 */
if|if
condition|(
operator|(
name|array
index|[
literal|0
index|]
operator|<
literal|6
operator|)
operator|||
operator|(
name|arraysize
operator|<
literal|24
operator|)
operator|||
operator|(
name|arraysize
operator|>
literal|4096
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Verify the size of data pointed to by array with how long 	 * the array claims to be itself. 	 */
if|if
condition|(
name|array
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
operator|!=
name|arraysize
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|maxidx
operator|=
name|nelem
operator|-
literal|1
expr_stmt|;
comment|/* 	 * The last opcode in this array should be an IPF_EXP_END. 	 */
if|if
condition|(
name|array
index|[
name|maxidx
index|]
operator|!=
name|IPF_EXP_END
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|maxidx
condition|;
control|)
block|{
name|e
operator|=
operator|(
name|ipfexp_t
operator|*
operator|)
operator|(
name|array
operator|+
name|i
operator|)
expr_stmt|;
comment|/* 		 * The length of the bits to check must be at least 1 		 * (or else there is nothing to comapre with!) and it 		 * cannot exceed the length of the data present. 		 */
if|if
condition|(
operator|(
name|e
operator|->
name|ipfe_size
operator|<
literal|1
operator|)
operator|||
operator|(
name|e
operator|->
name|ipfe_size
operator|+
name|i
operator|>
name|maxidx
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|i
operator|+=
name|e
operator|->
name|ipfe_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_fr_matcharray                                           */
end_comment

begin_comment
comment|/* Returns:     int      - 0 = match failed, else positive match            */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              array(I) - pointer to matching array                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is used to apply a matching array against a packet and     */
end_comment

begin_comment
comment|/* return an indication of whether or not the packet successfully matches   */
end_comment

begin_comment
comment|/* all of the commands in it.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_fr_matcharray
parameter_list|(
name|fin
parameter_list|,
name|array
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
modifier|*
name|array
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
modifier|*
name|x
decl_stmt|,
name|rv
decl_stmt|,
name|p
decl_stmt|;
name|ipfexp_t
modifier|*
name|e
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|array
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|x
operator|+=
literal|3
operator|+
name|x
index|[
literal|3
index|]
operator|,
name|rv
operator|=
literal|0
control|)
block|{
name|e
operator|=
operator|(
name|ipfexp_t
operator|*
operator|)
name|x
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|ipfe_cmd
operator|==
name|IPF_EXP_END
condition|)
break|break;
name|n
operator|-=
name|e
operator|->
name|ipfe_size
expr_stmt|;
comment|/* 		 * The upper 16 bits currently store the protocol value. 		 * This is currently used with TCP and UDP port compares and 		 * allows "tcp.port = 80" without requiring an explicit 		 " "ip.pr = tcp" first. 		 */
name|p
operator|=
name|e
operator|->
name|ipfe_cmd
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|p
operator|!=
name|fin
operator|->
name|fin_p
operator|)
condition|)
break|break;
switch|switch
condition|(
name|e
operator|->
name|ipfe_cmd
condition|)
block|{
case|case
name|IPF_EXP_IP_PR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|fin
operator|->
name|fin_p
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP_SRCADDR
case|:
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
literal|4
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|fin
operator|->
name|fin_saddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP_DSTADDR
case|:
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
literal|4
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|fin
operator|->
name|fin_daddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP_ADDR
case|:
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
literal|4
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|fin
operator|->
name|fin_saddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_daddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPF_EXP_IP6_SRCADDR
case|:
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
literal|6
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
name|IP6_MASKEQ
argument_list|(
operator|&
name|fin
operator|->
name|fin_src6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP6_DSTADDR
case|:
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
literal|6
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
name|IP6_MASKEQ
argument_list|(
operator|&
name|fin
operator|->
name|fin_dst6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP6_ADDR
case|:
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
literal|6
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
name|IP6_MASKEQ
argument_list|(
operator|&
name|fin
operator|->
name|fin_src6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
operator|||
name|IP6_MASKEQ
argument_list|(
operator|&
name|fin
operator|->
name|fin_dst6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|IPF_EXP_UDP_PORT
case|:
case|case
name|IPF_EXP_TCP_PORT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|fin
operator|->
name|fin_sport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_dport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_UDP_SPORT
case|:
case|case
name|IPF_EXP_TCP_SPORT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|fin
operator|->
name|fin_sport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_UDP_DPORT
case|:
case|case
name|IPF_EXP_TCP_DPORT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|fin
operator|->
name|fin_dport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_TCP_FLAGS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|fin
operator|->
name|fin_tcpf
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|rv
operator|^=
name|e
operator|->
name|ipfe_not
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_queueflush                                              */
end_comment

begin_comment
comment|/* Returns:     int - number of entries flushed (0 = none)                  */
end_comment

begin_comment
comment|/* Parameters:  softc(I)    - pointer to soft context main structure        */
end_comment

begin_comment
comment|/*              deletefn(I) - function to call to delete entry              */
end_comment

begin_comment
comment|/*              ipfqs(I)    - top of the list of ipf internal queues        */
end_comment

begin_comment
comment|/*              userqs(I)   - top of the list of user defined timeouts      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This fucntion gets called when the state/NAT hash tables fill up and we  */
end_comment

begin_comment
comment|/* need to try a bit harder to free up some space.  The algorithm used here */
end_comment

begin_comment
comment|/* split into two parts but both halves have the same goal: to reduce the   */
end_comment

begin_comment
comment|/* number of connections considered to be "active" to the low watermark.    */
end_comment

begin_comment
comment|/* There are two steps in doing this:                                       */
end_comment

begin_comment
comment|/* 1) Remove any TCP connections that are already considered to be "closed" */
end_comment

begin_comment
comment|/*    but have not yet been removed from the state table.  The two states   */
end_comment

begin_comment
comment|/*    TCPS_TIME_WAIT and TCPS_CLOSED are considered to be the perfect       */
end_comment

begin_comment
comment|/*    candidates for this style of removal.  If freeing up entries in       */
end_comment

begin_comment
comment|/*    CLOSED or both CLOSED and TIME_WAIT brings us to the low watermark,   */
end_comment

begin_comment
comment|/*    we do not go on to step 2.                                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* 2) Look for the oldest entries on each timeout queue and free them if    */
end_comment

begin_comment
comment|/*    they are within the given window we are considering.  Where the       */
end_comment

begin_comment
comment|/*    window starts and the steps taken to increase its size depend upon    */
end_comment

begin_comment
comment|/*    how long ipf has been running (ipf_ticks.)  Anything modified in the  */
end_comment

begin_comment
comment|/*    last 30 seconds is not touched.                                       */
end_comment

begin_comment
comment|/*                                              touched                     */
end_comment

begin_comment
comment|/*         die     ipf_ticks  30*1.5    1800*1.5   |  43200*1.5             */
end_comment

begin_comment
comment|/*           |          |        |           |     |     |                  */
end_comment

begin_comment
comment|/* future<--+----------+--------+-----------+-----+-----+-----------> past */
end_comment

begin_comment
comment|/*                     now        \_int=30s_/ \_int=1hr_/ \_int=12hr        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Points to note:                                                          */
end_comment

begin_comment
comment|/* - tqe_die is the time, in the future, when entries die.                  */
end_comment

begin_comment
comment|/* - tqe_die - ipf_ticks is how long left the connection has to live in ipf */
end_comment

begin_comment
comment|/*   ticks.                                                                 */
end_comment

begin_comment
comment|/* - tqe_touched is when the entry was last used by NAT/state               */
end_comment

begin_comment
comment|/* - the closer tqe_touched is to ipf_ticks, the further tqe_die will be    */
end_comment

begin_comment
comment|/*   ipf_ticks any given timeout queue and vice versa.                      */
end_comment

begin_comment
comment|/* - both tqe_die and tqe_touched increase over time                        */
end_comment

begin_comment
comment|/* - timeout queues are sorted with the highest value of tqe_die at the     */
end_comment

begin_comment
comment|/*   bottom and therefore the smallest values of each are at the top        */
end_comment

begin_comment
comment|/* - the pointer passed in as ipfqs should point to an array of timeout     */
end_comment

begin_comment
comment|/*   queues representing each of the TCP states                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* We start by setting up a maximum range to scan for things to move of     */
end_comment

begin_comment
comment|/* iend (newest) to istart (oldest) in chunks of "interval".  If nothing is */
end_comment

begin_comment
comment|/* found in that range, "interval" is adjusted (so long as it isn't 30) and */
end_comment

begin_comment
comment|/* we start again with a new value for "iend" and "istart".  This is        */
end_comment

begin_comment
comment|/* continued until we either finish the scan of 30 second intervals or the  */
end_comment

begin_comment
comment|/* low water mark is reached.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_queueflush
parameter_list|(
name|softc
parameter_list|,
name|deletefn
parameter_list|,
name|ipfqs
parameter_list|,
name|userqs
parameter_list|,
name|activep
parameter_list|,
name|size
parameter_list|,
name|low
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftq_delete_fn_t
name|deletefn
decl_stmt|;
name|ipftq_t
modifier|*
name|ipfqs
decl_stmt|,
decl|*
name|userqs
decl_stmt|;
end_function

begin_decl_stmt
name|u_int
modifier|*
name|activep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|,
name|low
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_long
name|interval
decl_stmt|,
name|istart
decl_stmt|,
name|iend
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|,
modifier|*
name|ifqnext
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|,
modifier|*
name|tqn
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tqn
operator|=
name|ipfqs
index|[
name|IPF_TCPS_CLOSED
index|]
operator|.
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|deletefn
call|)
argument_list|(
name|softc
argument_list|,
name|tqe
operator|->
name|tqe_parent
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|activep
operator|*
literal|100
operator|/
name|size
operator|)
operator|>
name|low
condition|)
block|{
for|for
control|(
name|tqn
operator|=
name|ipfqs
index|[
name|IPF_TCPS_TIME_WAIT
index|]
operator|.
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|deletefn
call|)
argument_list|(
name|softc
argument_list|,
name|tqe
operator|->
name|tqe_parent
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|activep
operator|*
literal|100
operator|/
name|size
operator|)
operator|<=
name|low
condition|)
block|{
return|return
name|removed
return|;
block|}
comment|/* 	 * NOTE: Use of "* 15 / 10" is required here because if "* 1.5" is 	 *       used then the operations are upgraded to floating point 	 *       and kernels don't like floating point... 	 */
if|if
condition|(
name|softc
operator|->
name|ipf_ticks
operator|>
name|IPF_TTLVAL
argument_list|(
literal|43200
operator|*
literal|15
operator|/
literal|10
argument_list|)
condition|)
block|{
name|istart
operator|=
name|IPF_TTLVAL
argument_list|(
literal|86400
operator|*
literal|4
argument_list|)
expr_stmt|;
name|interval
operator|=
name|IPF_TTLVAL
argument_list|(
literal|43200
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|ipf_ticks
operator|>
name|IPF_TTLVAL
argument_list|(
literal|1800
operator|*
literal|15
operator|/
literal|10
argument_list|)
condition|)
block|{
name|istart
operator|=
name|IPF_TTLVAL
argument_list|(
literal|43200
argument_list|)
expr_stmt|;
name|interval
operator|=
name|IPF_TTLVAL
argument_list|(
literal|1800
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|softc
operator|->
name|ipf_ticks
operator|>
name|IPF_TTLVAL
argument_list|(
literal|30
operator|*
literal|15
operator|/
literal|10
argument_list|)
condition|)
block|{
name|istart
operator|=
name|IPF_TTLVAL
argument_list|(
literal|1800
argument_list|)
expr_stmt|;
name|interval
operator|=
name|IPF_TTLVAL
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|istart
operator|>
name|softc
operator|->
name|ipf_ticks
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_ticks
operator|-
name|interval
operator|<
name|interval
condition|)
name|istart
operator|=
name|interval
expr_stmt|;
else|else
name|istart
operator|=
operator|(
name|softc
operator|->
name|ipf_ticks
operator|/
name|interval
operator|)
operator|*
name|interval
expr_stmt|;
block|}
name|iend
operator|=
name|softc
operator|->
name|ipf_ticks
operator|-
name|interval
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|activep
operator|*
literal|100
operator|/
name|size
operator|)
operator|>
name|low
condition|)
block|{
name|u_long
name|try
decl_stmt|;
name|try
operator|=
name|softc
operator|->
name|ipf_ticks
operator|-
name|istart
expr_stmt|;
for|for
control|(
name|ifq
operator|=
name|ipfqs
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
block|{
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|try
operator|<
name|tqe
operator|->
name|tqe_touched
condition|)
break|break;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|deletefn
call|)
argument_list|(
name|softc
argument_list|,
name|tqe
operator|->
name|tqe_parent
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|ifq
operator|=
name|userqs
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|try
operator|<
name|tqe
operator|->
name|tqe_touched
condition|)
break|break;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|deletefn
call|)
argument_list|(
name|softc
argument_list|,
name|tqe
operator|->
name|tqe_parent
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|try
operator|>=
name|iend
condition|)
block|{
if|if
condition|(
name|interval
operator|==
name|IPF_TTLVAL
argument_list|(
literal|43200
argument_list|)
condition|)
block|{
name|interval
operator|=
name|IPF_TTLVAL
argument_list|(
literal|1800
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interval
operator|==
name|IPF_TTLVAL
argument_list|(
literal|1800
argument_list|)
condition|)
block|{
name|interval
operator|=
name|IPF_TTLVAL
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|interval
operator|>=
name|softc
operator|->
name|ipf_ticks
condition|)
break|break;
name|iend
operator|=
name|softc
operator|->
name|ipf_ticks
operator|-
name|interval
expr_stmt|;
block|}
name|istart
operator|-=
name|interval
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_deliverlocal                                            */
end_comment

begin_comment
comment|/* Returns:     int - 1 = local address, 0 = non-local address              */
end_comment

begin_comment
comment|/* Parameters:  softc(I)     - pointer to soft context main structure       */
end_comment

begin_comment
comment|/*              ipversion(I) - IP protocol version (4 or 6)                 */
end_comment

begin_comment
comment|/*              ifp(I)       - network interface pointer                    */
end_comment

begin_comment
comment|/*              ipaddr(I)    - IPv4/6 destination address                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This fucntion is used to determine in the address "ipaddr" belongs to    */
end_comment

begin_comment
comment|/* the network interface represented by ifp.                                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_deliverlocal
parameter_list|(
name|softc
parameter_list|,
name|ipversion
parameter_list|,
name|ifp
parameter_list|,
name|ipaddr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|ipversion
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
name|i6addr_t
modifier|*
name|ipaddr
decl_stmt|;
block|{
name|i6addr_t
name|addr
decl_stmt|;
name|int
name|islocal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ipversion
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|ipf_ifpaddr
argument_list|(
name|softc
argument_list|,
literal|4
argument_list|,
name|FRI_NORMAL
argument_list|,
name|ifp
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|.
name|in4
operator|.
name|s_addr
operator|==
name|ipaddr
operator|->
name|in4
operator|.
name|s_addr
condition|)
name|islocal
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_INET6
block|}
elseif|else
if|if
condition|(
name|ipversion
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|ipf_ifpaddr
argument_list|(
name|softc
argument_list|,
literal|6
argument_list|,
name|FRI_NORMAL
argument_list|,
name|ifp
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IP6_EQ
argument_list|(
operator|&
name|addr
argument_list|,
name|ipaddr
argument_list|)
condition|)
name|islocal
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|islocal
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_settimeout                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, -1 = failure                             */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              t(I)     - pointer to tuneable array entry                  */
end_comment

begin_comment
comment|/*              p(I)     - pointer to values passed in to apply             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is called to set the timeout values for each distinct      */
end_comment

begin_comment
comment|/* queue timeout that is available.  When called, it calls into both the    */
end_comment

begin_comment
comment|/* state and NAT code, telling them to update their timeout queues.         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_settimeout
parameter_list|(
name|softc
parameter_list|,
name|t
parameter_list|,
name|p
parameter_list|)
name|struct
name|ipf_main_softc_s
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|t
decl_stmt|;
name|ipftuneval_t
modifier|*
name|p
decl_stmt|;
block|{
comment|/* 	 * ipf_interror should be set by the functions called here, not 	 * by this function - it's just a middle man. 	 */
if|if
condition|(
name|ipf_state_settimeout
argument_list|(
name|softc
argument_list|,
name|t
argument_list|,
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_nat_settimeout
argument_list|(
name|softc
argument_list|,
name|t
argument_list|,
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_apply_timeout                                           */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, -1 = failure                             */
end_comment

begin_comment
comment|/* Parameters:  head(I)    - pointer to tuneable array entry                */
end_comment

begin_comment
comment|/*              seconds(I) - pointer to values passed in to apply           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function applies a timeout of "seconds" to the timeout queue that   */
end_comment

begin_comment
comment|/* is pointed to by "head".  All entries on this list have an expiration    */
end_comment

begin_comment
comment|/* set to be the current tick value of ipf plus the ttl.  Given that this   */
end_comment

begin_comment
comment|/* function should only be called when the delta is non-zero, the task is   */
end_comment

begin_comment
comment|/* to walk the entire list and apply the change.  The sort order will not   */
end_comment

begin_comment
comment|/* change.  The only catch is that this is O(n) across the list, so if the  */
end_comment

begin_comment
comment|/* queue has lots of entries (10s of thousands or 100s of thousands), it    */
end_comment

begin_comment
comment|/* could take a relatively long time to work through them all.              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_apply_timeout
parameter_list|(
name|head
parameter_list|,
name|seconds
parameter_list|)
name|ipftq_t
modifier|*
name|head
decl_stmt|;
name|u_int
name|seconds
decl_stmt|;
block|{
name|u_int
name|oldtimeout
decl_stmt|,
name|newtimeout
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|head
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|oldtimeout
operator|=
name|head
operator|->
name|ifq_ttl
expr_stmt|;
name|newtimeout
operator|=
name|IPF_TTLVAL
argument_list|(
name|seconds
argument_list|)
expr_stmt|;
name|delta
operator|=
name|oldtimeout
operator|-
name|newtimeout
expr_stmt|;
name|head
operator|->
name|ifq_ttl
operator|=
name|newtimeout
expr_stmt|;
for|for
control|(
name|tqe
operator|=
name|head
operator|->
name|ifq_head
init|;
name|tqe
operator|!=
name|NULL
condition|;
name|tqe
operator|=
name|tqe
operator|->
name|tqe_next
control|)
block|{
name|tqe
operator|->
name|tqe_die
operator|+=
name|delta
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|head
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_settimeout_tcp                                           */
end_comment

begin_comment
comment|/* Returns:    int - 0 = successfully applied, -1 = failed                  */
end_comment

begin_comment
comment|/* Parameters: t(I)   - pointer to tuneable to change                       */
end_comment

begin_comment
comment|/*             p(I)   - pointer to new timeout information                  */
end_comment

begin_comment
comment|/*             tab(I) - pointer to table of TCP queues                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function applies the new timeout (p) to the TCP tunable (t) and     */
end_comment

begin_comment
comment|/* updates all of the entries on the relevant timeout queue by calling      */
end_comment

begin_comment
comment|/* ipf_apply_timeout().                                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_settimeout_tcp
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|,
name|tab
parameter_list|)
name|ipftuneable_t
modifier|*
name|t
decl_stmt|;
name|ipftuneval_t
modifier|*
name|p
decl_stmt|;
name|ipftq_t
modifier|*
name|tab
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_idle_timeout"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_established"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_ESTABLISHED
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_close_wait"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_CLOSE_WAIT
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_last_ack"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_LAST_ACK
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_timeout"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_LISTEN
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_HALF_ESTAB
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_CLOSING
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_listen"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_LISTEN
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_half_established"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_HALF_ESTAB
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_closing"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_CLOSING
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_syn_received"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_SYN_RECEIVED
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_syn_sent"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_SYN_SENT
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_closed"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_CLOSED
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_half_closed"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_CLOSED
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_time_wait"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|tab
index|[
name|IPF_TCPS_TIME_WAIT
index|]
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * ipf_interror isn't set here because it should be set 		 * by whatever called this function. 		 */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_main_soft_create                                         */
end_comment

begin_comment
comment|/* Returns:    NULL = failure, else success                                 */
end_comment

begin_comment
comment|/* Parameters: arg(I) - pointer to soft context structure if already allocd */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Create the foundation soft context structure. In circumstances where it  */
end_comment

begin_comment
comment|/* is not required to dynamically allocate the context, a pointer can be    */
end_comment

begin_comment
comment|/* passed in (rather than NULL) to a structure to be initialised.           */
end_comment

begin_comment
comment|/* The main thing of interest is that a number of locks are initialised     */
end_comment

begin_comment
comment|/* here instead of in the where might be expected - in the relevant create  */
end_comment

begin_comment
comment|/* function elsewhere.  This is done because the current locking design has */
end_comment

begin_comment
comment|/* some areas where these locks are used outside of their module.           */
end_comment

begin_comment
comment|/* Possibly the most important exercise that is done here is setting of all */
end_comment

begin_comment
comment|/* the timeout values, allowing them to be changed before init().           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|ipf_main_soft_create
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
block|{
name|KMALLOC
argument_list|(
name|softc
argument_list|,
name|ipf_main_softc_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
name|softc
operator|=
name|arg
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This serves as a flag as to whether or not the softc should be 	 * free'd when _destroy is called. 	 */
name|softc
operator|->
name|ipf_dynamic_softc
operator|=
operator|(
name|arg
operator|==
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|softc
operator|->
name|ipf_tuners
operator|=
name|ipf_tune_array_copy
argument_list|(
name|softc
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_main_tuneables
argument_list|)
argument_list|,
name|ipf_main_tuneables
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_tuners
operator|==
name|NULL
condition|)
block|{
name|ipf_main_soft_destroy
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MUTEX_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_rw
argument_list|,
literal|"ipf rw mutex"
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|,
literal|"ipf timeout lock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|,
literal|"ipf filter load/unload mutex"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|,
literal|"ipf filter rwlock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|,
literal|"ipf token rwlock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|,
literal|"ipf state rwlock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_nat
argument_list|,
literal|"ipf IP NAT rwlock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_poolrw
argument_list|,
literal|"ipf pool rwlock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_frag
argument_list|,
literal|"ipf frag rwlock"
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_token_head
operator|=
name|NULL
expr_stmt|;
name|softc
operator|->
name|ipf_token_tail
operator|=
operator|&
name|softc
operator|->
name|ipf_token_head
expr_stmt|;
name|softc
operator|->
name|ipf_tcpidletimeout
operator|=
name|FIVE_DAYS
expr_stmt|;
name|softc
operator|->
name|ipf_tcpclosewait
operator|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcplastack
operator|=
name|IPF_TTLVAL
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcptimewait
operator|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcptimeout
operator|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcpsynsent
operator|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcpsynrecv
operator|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcpclosed
operator|=
name|IPF_TTLVAL
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_tcphalfclosed
operator|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
literal|3600
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_udptimeout
operator|=
name|IPF_TTLVAL
argument_list|(
literal|120
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_udpacktimeout
operator|=
name|IPF_TTLVAL
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_icmptimeout
operator|=
name|IPF_TTLVAL
argument_list|(
literal|60
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_icmpacktimeout
operator|=
name|IPF_TTLVAL
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_iptimeout
operator|=
name|IPF_TTLVAL
argument_list|(
literal|60
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_DEFAULT_BLOCK
argument_list|)
name|softc
operator|->
name|ipf_pass
operator|=
name|FR_BLOCK
operator||
name|FR_NOMATCH
expr_stmt|;
else|#
directive|else
name|softc
operator|->
name|ipf_pass
operator|=
operator|(
name|IPF_DEFAULT_PASS
operator|)
operator||
name|FR_NOMATCH
expr_stmt|;
endif|#
directive|endif
name|softc
operator|->
name|ipf_minttl
operator|=
literal|4
expr_stmt|;
name|softc
operator|->
name|ipf_icmpminfragmtu
operator|=
literal|68
expr_stmt|;
name|softc
operator|->
name|ipf_flags
operator|=
name|IPF_LOGGING
expr_stmt|;
return|return
name|softc
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_main_soft_init                                           */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A null-op function that exists as a placeholder so that the flow in      */
end_comment

begin_comment
comment|/* other functions is obvious.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|ipf_main_soft_init
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_main_soft_destroy                                        */
end_comment

begin_comment
comment|/* Returns:    void                                                         */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Undo everything that we did in ipf_main_soft_create.                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The most important check that needs to be made here is whether or not    */
end_comment

begin_comment
comment|/* the structure was allocated by ipf_main_soft_create() by checking what   */
end_comment

begin_comment
comment|/* value is stored in ipf_dynamic_main.                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|ipf_main_soft_destroy
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_frag
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_poolrw
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_nat
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_global
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softc
operator|->
name|ipf_rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_tuners
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|softc
operator|->
name|ipf_tuners
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_main_tuneables
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_dynamic_softc
operator|==
literal|1
condition|)
block|{
name|KFREE
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_main_soft_fini                                           */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Clean out the rules which have been added since _init was last called,   */
end_comment

begin_comment
comment|/* the only dynamic part of the mainline.                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_main_soft_fini
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
operator||
name|FR_INACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGCOUNT
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
operator||
name|FR_INACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_flush
argument_list|(
name|softc
argument_list|,
name|IPL_LOGCOUNT
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_main_load                                                */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: none                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Handle global initialisation that needs to be done for the base part of  */
end_comment

begin_comment
comment|/* IPFilter. At present this just amounts to initialising some ICMP lookup  */
end_comment

begin_comment
comment|/* arrays that get used by the state/NAT code.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_main_load
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* fill icmp reply type table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ICMP_MAXTYPE
condition|;
name|i
operator|++
control|)
name|icmpreplytype4
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_ECHO
index|]
operator|=
name|ICMP_ECHOREPLY
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_TSTAMP
index|]
operator|=
name|ICMP_TSTAMPREPLY
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_IREQ
index|]
operator|=
name|ICMP_IREQREPLY
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_MASKREQ
index|]
operator|=
name|ICMP_MASKREPLY
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
comment|/* fill icmp reply type table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ICMP6_MAXTYPE
condition|;
name|i
operator|++
control|)
name|icmpreplytype6
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|icmpreplytype6
index|[
name|ICMP6_ECHO_REQUEST
index|]
operator|=
name|ICMP6_ECHO_REPLY
expr_stmt|;
name|icmpreplytype6
index|[
name|ICMP6_MEMBERSHIP_QUERY
index|]
operator|=
name|ICMP6_MEMBERSHIP_REPORT
expr_stmt|;
name|icmpreplytype6
index|[
name|ICMP6_NI_QUERY
index|]
operator|=
name|ICMP6_NI_REPLY
expr_stmt|;
name|icmpreplytype6
index|[
name|ND_ROUTER_SOLICIT
index|]
operator|=
name|ND_ROUTER_ADVERT
expr_stmt|;
name|icmpreplytype6
index|[
name|ND_NEIGHBOR_SOLICIT
index|]
operator|=
name|ND_NEIGHBOR_ADVERT
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_main_unload                                              */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: none                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A null-op function that exists as a placeholder so that the flow in      */
end_comment

begin_comment
comment|/* other functions is obvious.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_main_unload
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_load_all                                                 */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: none                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Work through all of the subsystems inside IPFilter and call the load     */
end_comment

begin_comment
comment|/* function for each in an order that won't lead to a crash :)              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_load_all
parameter_list|()
block|{
if|if
condition|(
name|ipf_main_load
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_state_main_load
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_nat_main_load
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_frag_main_load
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_auth_main_load
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_proxy_main_load
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_unload_all                                               */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: none                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Work through all of the subsystems inside IPFilter and call the unload   */
end_comment

begin_comment
comment|/* function for each in an order that won't lead to a crash :)              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_unload_all
parameter_list|()
block|{
if|if
condition|(
name|ipf_proxy_main_unload
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_auth_main_unload
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_frag_main_unload
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_nat_main_unload
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_state_main_unload
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_main_unload
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_create_all                                               */
end_comment

begin_comment
comment|/* Returns:    NULL = failure, else success                                 */
end_comment

begin_comment
comment|/* Parameters: arg(I) - pointer to soft context main structure              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Work through all of the subsystems inside IPFilter and call the create   */
end_comment

begin_comment
comment|/* function for each in an order that won't lead to a crash :)              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipf_main_softc_t
modifier|*
name|ipf_create_all
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|softc
operator|=
name|ipf_main_soft_create
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|softc
operator|->
name|ipf_log_soft
operator|=
name|ipf_log_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_log_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|softc
operator|->
name|ipf_lookup_soft
operator|=
name|ipf_lookup_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_lookup_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softc
operator|->
name|ipf_sync_soft
operator|=
name|ipf_sync_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_sync_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softc
operator|->
name|ipf_state_soft
operator|=
name|ipf_state_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_state_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softc
operator|->
name|ipf_nat_soft
operator|=
name|ipf_nat_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_nat_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softc
operator|->
name|ipf_frag_soft
operator|=
name|ipf_frag_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_frag_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softc
operator|->
name|ipf_auth_soft
operator|=
name|ipf_auth_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_auth_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softc
operator|->
name|ipf_proxy_soft
operator|=
name|ipf_proxy_soft_create
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_proxy_soft
operator|==
name|NULL
condition|)
block|{
name|ipf_destroy_all
argument_list|(
name|softc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|softc
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_destroy_all                                              */
end_comment

begin_comment
comment|/* Returns:    void                                                         */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Work through all of the subsystems inside IPFilter and call the destroy  */
end_comment

begin_comment
comment|/* function for each in an order that won't lead to a crash :)              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Every one of these functions is expected to succeed, so there is no      */
end_comment

begin_comment
comment|/* checking of return values.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_destroy_all
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_state_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_state_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_state_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_state_soft
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_nat_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_nat_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_nat_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_nat_soft
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_frag_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_frag_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_frag_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_frag_soft
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_auth_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_auth_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_auth_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_auth_soft
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_proxy_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_proxy_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_proxy_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_proxy_soft
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_sync_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_sync_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_sync_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_sync_soft
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softc
operator|->
name|ipf_lookup_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_lookup_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_lookup_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_lookup_soft
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOG
if|if
condition|(
name|softc
operator|->
name|ipf_log_soft
operator|!=
name|NULL
condition|)
block|{
name|ipf_log_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_log_soft
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_log_soft
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|ipf_main_soft_destroy
argument_list|(
name|softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_init_all                                                 */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Work through all of the subsystems inside IPFilter and call the init     */
end_comment

begin_comment
comment|/* function for each in an order that won't lead to a crash :)              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_init_all
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
if|if
condition|(
name|ipf_main_soft_init
argument_list|(
name|softc
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
if|if
condition|(
name|ipf_log_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_log_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|ipf_lookup_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_lookup_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_sync_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_sync_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_state_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_state_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_nat_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_nat_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_frag_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_frag_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_auth_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_auth_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_proxy_soft_init
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_proxy_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   ipf_fini_all                                                 */
end_comment

begin_comment
comment|/* Returns:    0 = success, -1 = failure                                    */
end_comment

begin_comment
comment|/* Parameters: softc(I) - pointer to soft context main structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Work through all of the subsystems inside IPFilter and call the fini     */
end_comment

begin_comment
comment|/* function for each in an order that won't lead to a crash :)              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_fini_all
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipf_token_flush
argument_list|(
name|softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_proxy_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_proxy_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_auth_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_auth_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_frag_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_frag_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_nat_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_nat_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_state_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_state_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_sync_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_sync_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ipf_lookup_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_lookup_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
if|if
condition|(
name|ipf_log_soft_fini
argument_list|(
name|softc
argument_list|,
name|softc
operator|->
name|ipf_log_soft
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|ipf_main_soft_fini
argument_list|(
name|softc
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rule_expire                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* At present this function exists just to support temporary addition of    */
end_comment

begin_comment
comment|/* firewall rules. Both inactive and active lists are scanned for items to  */
end_comment

begin_comment
comment|/* purge, as by rights, the expiration is computed as soon as the rule is   */
end_comment

begin_comment
comment|/* loaded in.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rule_expire
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
operator|(
name|softc
operator|->
name|ipf_rule_explist
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|softc
operator|->
name|ipf_rule_explist
index|[
literal|1
index|]
operator|==
name|NULL
operator|)
condition|)
return|return;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fr
operator|=
name|softc
operator|->
name|ipf_rule_explist
index|[
literal|0
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Because the list is kept sorted on insertion, the fist 		 * one that dies in the future means no more work to do. 		 */
if|if
condition|(
name|fr
operator|->
name|fr_die
operator|>
name|softc
operator|->
name|ipf_ticks
condition|)
break|break;
name|ipf_rule_delete
argument_list|(
name|softc
argument_list|,
name|fr
argument_list|,
name|IPL_LOGIPF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|fr
operator|=
name|softc
operator|->
name|ipf_rule_explist
index|[
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Because the list is kept sorted on insertion, the fist 		 * one that dies in the future means no more work to do. 		 */
if|if
condition|(
name|fr
operator|->
name|fr_die
operator|>
name|softc
operator|->
name|ipf_ticks
condition|)
break|break;
name|ipf_rule_delete
argument_list|(
name|softc
argument_list|,
name|fr
argument_list|,
name|IPL_LOGIPF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ipf_ht_node_cmp
name|__P
argument_list|(
operator|(
expr|struct
name|host_node_s
operator|*
operator|,
expr|struct
name|host_node_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_ht_node_make_key
name|__P
argument_list|(
operator|(
name|host_track_t
operator|*
operator|,
name|host_node_t
operator|*
operator|,
name|int
operator|,
name|i6addr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|host_node_t
name|RBI_ZERO
parameter_list|(
name|ipf_rb
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|RBI_CODE
argument_list|(
argument|ipf_rb
argument_list|,
argument|host_node_t
argument_list|,
argument|hn_entry
argument_list|,
argument|ipf_ht_node_cmp
argument_list|)
end_macro

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ht_node_cmp                                             */
end_comment

begin_comment
comment|/* Returns:     int   - 0 == nodes are the same, ..                         */
end_comment

begin_comment
comment|/* Parameters:  k1(I) - pointer to first key to compare                     */
end_comment

begin_comment
comment|/*              k2(I) - pointer to second key to compare                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The "key" for the node is a combination of two fields: the address       */
end_comment

begin_comment
comment|/* family and the address itself.                                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Because we're not actually interpreting the address data, it isn't       */
end_comment

begin_comment
comment|/* necessary to convert them to/from network/host byte order. The mask is   */
end_comment

begin_comment
comment|/* just used to remove bits that aren't significant - it doesn't matter     */
end_comment

begin_comment
comment|/* where they are, as long as they're always in the same place.             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* As with IP6_EQ, comparing IPv6 addresses starts at the bottom because    */
end_comment

begin_comment
comment|/* this is where individual ones will differ the most - but not true for    */
end_comment

begin_comment
comment|/* for /48's, etc.                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_ht_node_cmp
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|)
name|struct
name|host_node_s
modifier|*
name|k1
decl_stmt|,
decl|*
name|k2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|k2
operator|->
name|hn_addr
operator|.
name|adf_family
operator|-
name|k1
operator|->
name|hn_addr
operator|.
name|adf_family
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
if|if
condition|(
name|k1
operator|->
name|hn_addr
operator|.
name|adf_family
operator|==
name|AF_INET
condition|)
return|return
operator|(
name|k2
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|in4
operator|.
name|s_addr
operator|-
name|k1
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|in4
operator|.
name|s_addr
operator|)
return|;
name|i
operator|=
name|k2
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|3
index|]
operator|-
name|k1
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|i
operator|=
name|k2
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|2
index|]
operator|-
name|k1
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|i
operator|=
name|k2
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|1
index|]
operator|-
name|k1
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|i
operator|=
name|k2
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
operator|-
name|k1
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ht_node_make_key                                        */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* parameters:  htp(I)    - pointer to address tracking structure           */
end_comment

begin_comment
comment|/*              key(I)    - where to store masked address for lookup        */
end_comment

begin_comment
comment|/*              family(I) - protocol family of address                      */
end_comment

begin_comment
comment|/*              addr(I)   - pointer to network address                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Using the "netmask" (number of bits) stored parent host tracking struct, */
end_comment

begin_comment
comment|/* copy the address passed in into the key structure whilst masking out the */
end_comment

begin_comment
comment|/* bits that we don't want.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Because the parser will set ht_netmask to 128 if there is no protocol    */
end_comment

begin_comment
comment|/* specified (the parser doesn't know if it should be a v4 or v6 rule), we  */
end_comment

begin_comment
comment|/* have to be wary of that and not allow 32-128 to happen.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_ht_node_make_key
parameter_list|(
name|htp
parameter_list|,
name|key
parameter_list|,
name|family
parameter_list|,
name|addr
parameter_list|)
name|host_track_t
modifier|*
name|htp
decl_stmt|;
name|host_node_t
modifier|*
name|key
decl_stmt|;
name|int
name|family
decl_stmt|;
name|i6addr_t
modifier|*
name|addr
decl_stmt|;
block|{
name|key
operator|->
name|hn_addr
operator|.
name|adf_family
operator|=
name|family
expr_stmt|;
if|if
condition|(
name|family
operator|==
name|AF_INET
condition|)
block|{
name|u_32_t
name|mask
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_len
operator|=
sizeof|sizeof
argument_list|(
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|in4
argument_list|)
expr_stmt|;
name|bits
operator|=
name|htp
operator|->
name|ht_netmask
expr_stmt|;
if|if
condition|(
name|bits
operator|>=
literal|32
condition|)
block|{
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|in4
operator|.
name|s_addr
operator|=
name|addr
operator|->
name|in4
operator|.
name|s_addr
operator|&
name|mask
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
block|}
else|else
block|{
name|int
name|bits
init|=
name|htp
operator|->
name|ht_netmask
decl_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_len
operator|=
sizeof|sizeof
argument_list|(
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|>
literal|96
condition|)
block|{
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|3
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|3
index|]
operator|&
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|128
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|2
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|1
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits
operator|>
literal|64
condition|)
block|{
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|2
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|2
index|]
operator|&
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|96
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|1
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits
operator|>
literal|32
condition|)
block|{
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|1
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|1
index|]
operator|&
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|64
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|hn_addr
operator|.
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
operator|=
name|addr
operator|->
name|i6
index|[
literal|0
index|]
operator|&
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ht_node_add                                             */
end_comment

begin_comment
comment|/* Returns:     int       - 0 == success,  -1 == failure                    */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to soft context main structure          */
end_comment

begin_comment
comment|/*              htp(I)    - pointer to address tracking structure           */
end_comment

begin_comment
comment|/*              family(I) - protocol family of address                      */
end_comment

begin_comment
comment|/*              addr(I)   - pointer to network address                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: THIS FUNCTION MUST BE CALLED WITH AN EXCLUSIVE LOCK THAT PREVENTS  */
end_comment

begin_comment
comment|/*       ipf_ht_node_del FROM RUNNING CONCURRENTLY ON THE SAME htp.         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* After preparing the key with the address information to find, look in    */
end_comment

begin_comment
comment|/* the red-black tree to see if the address is known. A successful call to  */
end_comment

begin_comment
comment|/* this function can mean one of two things: a new node was added to the    */
end_comment

begin_comment
comment|/* tree or a matching node exists and we're able to bump up its activity.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ht_node_add
parameter_list|(
name|softc
parameter_list|,
name|htp
parameter_list|,
name|family
parameter_list|,
name|addr
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|host_track_t
modifier|*
name|htp
decl_stmt|;
name|int
name|family
decl_stmt|;
name|i6addr_t
modifier|*
name|addr
decl_stmt|;
block|{
name|host_node_t
modifier|*
name|h
decl_stmt|;
name|host_node_t
name|k
decl_stmt|;
name|ipf_ht_node_make_key
argument_list|(
name|htp
argument_list|,
operator|&
name|k
argument_list|,
name|family
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|h
operator|=
name|RBI_SEARCH
argument_list|(
name|ipf_rb
argument_list|,
operator|&
name|htp
operator|->
name|ht_root
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htp
operator|->
name|ht_cur_nodes
operator|>=
name|htp
operator|->
name|ht_max_nodes
condition|)
return|return
operator|-
literal|1
return|;
name|KMALLOC
argument_list|(
name|h
argument_list|,
name|host_node_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|DT
argument_list|(
name|ipf_rb_no_mem
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_rb_no_mem
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * If there was a macro to initialise the RB node then that 		 * would get used here, but there isn't... 		 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hn_addr
operator|=
name|k
operator|.
name|hn_addr
expr_stmt|;
name|h
operator|->
name|hn_addr
operator|.
name|adf_family
operator|=
name|k
operator|.
name|hn_addr
operator|.
name|adf_family
expr_stmt|;
name|RBI_INSERT
argument_list|(
name|ipf_rb
argument_list|,
operator|&
name|htp
operator|->
name|ht_root
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|htp
operator|->
name|ht_cur_nodes
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|htp
operator|->
name|ht_max_per_node
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|hn_active
operator|>=
name|htp
operator|->
name|ht_max_per_node
operator|)
condition|)
block|{
name|DT
argument_list|(
name|ipf_rb_node_max
argument_list|)
expr_stmt|;
name|LBUMP
argument_list|(
name|ipf_rb_node_max
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|h
operator|->
name|hn_active
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ht_node_del                                             */
end_comment

begin_comment
comment|/* Returns:     int       - 0 == success,  -1 == failure                    */
end_comment

begin_comment
comment|/* parameters:  htp(I)    - pointer to address tracking structure           */
end_comment

begin_comment
comment|/*              family(I) - protocol family of address                      */
end_comment

begin_comment
comment|/*              addr(I)   - pointer to network address                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: THIS FUNCTION MUST BE CALLED WITH AN EXCLUSIVE LOCK THAT PREVENTS  */
end_comment

begin_comment
comment|/*       ipf_ht_node_add FROM RUNNING CONCURRENTLY ON THE SAME htp.         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Try and find the address passed in amongst the leavese on this tree to   */
end_comment

begin_comment
comment|/* be friend. If found then drop the active account for that node drops by  */
end_comment

begin_comment
comment|/* one. If that count reaches 0, it is time to free it all up.              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_ht_node_del
parameter_list|(
name|htp
parameter_list|,
name|family
parameter_list|,
name|addr
parameter_list|)
name|host_track_t
modifier|*
name|htp
decl_stmt|;
name|int
name|family
decl_stmt|;
name|i6addr_t
modifier|*
name|addr
decl_stmt|;
block|{
name|host_node_t
modifier|*
name|h
decl_stmt|;
name|host_node_t
name|k
decl_stmt|;
name|ipf_ht_node_make_key
argument_list|(
name|htp
argument_list|,
operator|&
name|k
argument_list|,
name|family
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|h
operator|=
name|RBI_SEARCH
argument_list|(
name|ipf_rb
argument_list|,
operator|&
name|htp
operator|->
name|ht_root
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|h
operator|->
name|hn_active
operator|--
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|hn_active
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|RBI_DELETE
argument_list|(
name|ipf_rb
argument_list|,
operator|&
name|htp
operator|->
name|ht_root
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|htp
operator|->
name|ht_cur_nodes
operator|--
expr_stmt|;
name|KFREE
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rb_ht_init                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  head(I) - pointer to host tracking structure                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise the host tracking structure to be ready for use above.        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rb_ht_init
parameter_list|(
name|head
parameter_list|)
name|host_track_t
modifier|*
name|head
decl_stmt|;
block|{
name|RBI_INIT
argument_list|(
name|ipf_rb
argument_list|,
operator|&
name|head
operator|->
name|ht_root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rb_ht_freenode                                          */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  head(I) - pointer to host tracking structure                */
end_comment

begin_comment
comment|/*              arg(I)  - additional argument from walk caller              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Free an actual host_node_t structure.                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rb_ht_freenode
parameter_list|(
name|node
parameter_list|,
name|arg
parameter_list|)
name|host_node_t
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|KFREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rb_ht_flush                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  head(I) - pointer to host tracking structure                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove all of the nodes in the tree tracking hosts by calling a walker   */
end_comment

begin_comment
comment|/* and free'ing each one.                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rb_ht_flush
parameter_list|(
name|head
parameter_list|)
name|host_track_t
modifier|*
name|head
decl_stmt|;
block|{
name|RBI_WALK
argument_list|(
name|ipf_rb
argument_list|,
operator|&
name|head
operator|->
name|ht_root
argument_list|,
name|ipf_rb_ht_freenode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_slowtimer                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  ptr(I) - pointer to main ipf soft context structure         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Slowly expire held state for fragments.  Timeouts are set * in           */
end_comment

begin_comment
comment|/* expectation of this being called twice per second.                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_slowtimer
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipf_token_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_frag_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_state_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_nat_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_auth_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_lookup_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_rule_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|ipf_sync_expire
argument_list|(
name|softc
argument_list|)
expr_stmt|;
name|softc
operator|->
name|ipf_ticks
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|timeout_add
argument_list|(
operator|&
name|ipf_slowtimer_ch
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_inet_mask_add                                           */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  bits(I) - pointer to nat context information                */
end_comment

begin_comment
comment|/*              mtab(I) - pointer to mask hash table structure              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When called, bits represents the mask of a new NAT rule that has just    */
end_comment

begin_comment
comment|/* been added. This function inserts a bitmask into the array of masks to   */
end_comment

begin_comment
comment|/* search when searching for a matching NAT rule for a packet.              */
end_comment

begin_comment
comment|/* Prevention of duplicate masks is achieved by checking the use count for  */
end_comment

begin_comment
comment|/* a given netmask.                                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_inet_mask_add
parameter_list|(
name|bits
parameter_list|,
name|mtab
parameter_list|)
name|int
name|bits
decl_stmt|;
name|ipf_v4_masktab_t
modifier|*
name|mtab
decl_stmt|;
block|{
name|u_32_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mtab
operator|->
name|imt4_masks
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|mtab
operator|->
name|imt4_masks
index|[
name|bits
index|]
operator|>
literal|1
condition|)
return|return;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
name|mask
operator|=
literal|0
expr_stmt|;
else|else
name|mask
operator|=
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|bits
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|33
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohl
argument_list|(
name|mtab
operator|->
name|imt4_active
index|[
name|i
index|]
argument_list|)
operator|<
name|mask
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|32
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
name|mtab
operator|->
name|imt4_active
index|[
name|j
index|]
operator|=
name|mtab
operator|->
name|imt4_active
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|mtab
operator|->
name|imt4_active
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtab
operator|->
name|imt4_max
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_inet_mask_del                                           */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  bits(I) - number of bits set in the netmask                 */
end_comment

begin_comment
comment|/*              mtab(I) - pointer to mask hash table structure              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove the 32bit bitmask represented by "bits" from the collection of    */
end_comment

begin_comment
comment|/* netmasks stored inside of mtab.                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_inet_mask_del
parameter_list|(
name|bits
parameter_list|,
name|mtab
parameter_list|)
name|int
name|bits
decl_stmt|;
name|ipf_v4_masktab_t
modifier|*
name|mtab
decl_stmt|;
block|{
name|u_32_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mtab
operator|->
name|imt4_masks
index|[
name|bits
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|mtab
operator|->
name|imt4_masks
index|[
name|bits
index|]
operator|>
literal|0
condition|)
return|return;
name|mask
operator|=
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|33
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mtab
operator|->
name|imt4_active
index|[
name|i
index|]
operator|==
name|mask
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
literal|33
condition|;
name|j
operator|++
control|)
name|mtab
operator|->
name|imt4_active
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|mtab
operator|->
name|imt4_active
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
name|mtab
operator|->
name|imt4_max
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|mtab
operator|->
name|imt4_max
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_inet6_mask_add                                          */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  bits(I) - number of bits set in mask                        */
end_comment

begin_comment
comment|/*              mask(I) - pointer to mask to add                            */
end_comment

begin_comment
comment|/*              mtab(I) - pointer to mask hash table structure              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When called, bitcount represents the mask of a IPv6 NAT map rule that    */
end_comment

begin_comment
comment|/* has just been added. This function inserts a bitmask into the array of   */
end_comment

begin_comment
comment|/* masks to search when searching for a matching NAT rule for a packet.     */
end_comment

begin_comment
comment|/* Prevention of duplicate masks is achieved by checking the use count for  */
end_comment

begin_comment
comment|/* a given netmask.                                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_inet6_mask_add
parameter_list|(
name|bits
parameter_list|,
name|mask
parameter_list|,
name|mtab
parameter_list|)
name|int
name|bits
decl_stmt|;
name|i6addr_t
modifier|*
name|mask
decl_stmt|;
name|ipf_v6_masktab_t
modifier|*
name|mtab
decl_stmt|;
block|{
name|i6addr_t
name|zero
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mtab
operator|->
name|imt6_masks
index|[
name|bits
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|mtab
operator|->
name|imt6_masks
index|[
name|bits
index|]
operator|>
literal|1
condition|)
return|return;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
operator|&
name|zero
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|129
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IP6_LT
argument_list|(
operator|&
name|mtab
operator|->
name|imt6_active
index|[
name|i
index|]
argument_list|,
name|mask
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|128
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
name|mtab
operator|->
name|imt6_active
index|[
name|j
index|]
operator|=
name|mtab
operator|->
name|imt6_active
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|mtab
operator|->
name|imt6_active
index|[
name|i
index|]
operator|=
operator|*
name|mask
expr_stmt|;
break|break;
block|}
block|}
name|mtab
operator|->
name|imt6_max
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_inet6_mask_del                                          */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  bits(I) - number of bits set in mask                        */
end_comment

begin_comment
comment|/*              mask(I) - pointer to mask to remove                         */
end_comment

begin_comment
comment|/*              mtab(I) - pointer to mask hash table structure              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove the 128bit bitmask represented by "bits" from the collection of   */
end_comment

begin_comment
comment|/* netmasks stored inside of mtab.                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_inet6_mask_del
parameter_list|(
name|bits
parameter_list|,
name|mask
parameter_list|,
name|mtab
parameter_list|)
name|int
name|bits
decl_stmt|;
name|i6addr_t
modifier|*
name|mask
decl_stmt|;
name|ipf_v6_masktab_t
modifier|*
name|mtab
decl_stmt|;
block|{
name|i6addr_t
name|zero
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mtab
operator|->
name|imt6_masks
index|[
name|bits
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|mtab
operator|->
name|imt6_masks
index|[
name|bits
index|]
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
name|mask
operator|=
operator|&
name|zero
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|zero
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|129
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IP6_EQ
argument_list|(
operator|&
name|mtab
operator|->
name|imt6_active
index|[
name|i
index|]
argument_list|,
name|mask
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
literal|129
condition|;
name|j
operator|++
control|)
block|{
name|mtab
operator|->
name|imt6_active
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|mtab
operator|->
name|imt6_active
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|IP6_EQ
argument_list|(
operator|&
name|mtab
operator|->
name|imt6_active
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
operator|&
name|zero
argument_list|)
condition|)
break|break;
block|}
break|break;
block|}
block|}
name|mtab
operator|->
name|imt6_max
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|mtab
operator|->
name|imt6_max
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

