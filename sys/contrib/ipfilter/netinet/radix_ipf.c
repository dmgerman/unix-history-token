begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RDX_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/radix_ipf.h"
end_include

begin_define
define|#
directive|define
name|ADF_OFF
value|offsetof(addrfamily_t, adf_addr)
end_define

begin_define
define|#
directive|define
name|ADF_OFF_BITS
value|(ADF_OFF<< 3)
end_define

begin_decl_stmt
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_insert
name|__P
argument_list|(
operator|(
name|ipf_rdx_head_t
operator|*
operator|,
name|ipf_rdx_node_t
name|nodes
index|[
literal|2
index|]
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_rx_attach_mask
name|__P
argument_list|(
operator|(
name|ipf_rdx_node_t
operator|*
operator|,
name|ipf_rdx_mask_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_mask_bits
name|__P
argument_list|(
operator|(
name|addrfamily_t
operator|*
operator|,
name|u_32_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|buildnodes
name|__P
argument_list|(
operator|(
name|addrfamily_t
operator|*
operator|,
name|addrfamily_t
operator|*
operator|,
name|ipf_rdx_node_t
name|n
index|[
literal|2
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_find_addr
name|__P
argument_list|(
operator|(
name|ipf_rdx_node_t
operator|*
operator|,
name|u_32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_lookup
name|__P
argument_list|(
operator|(
name|ipf_rdx_head_t
operator|*
operator|,
name|addrfamily_t
operator|*
operator|,
name|addrfamily_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_match
name|__P
argument_list|(
operator|(
name|ipf_rdx_head_t
operator|*
operator|,
name|addrfamily_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Foreword.  * ---------  * The code in this file has been written to target using the addrfamily_t  * data structure to house the address information and no other. Thus there  * are certain aspects of thise code (such as offsets to the address itself)  * that are hard coded here whilst they might be more variable elsewhere.  * Similarly, this code enforces no maximum key length as that's implied by  * all keys needing to be stored in addrfamily_t.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    count_mask_bits                                             */
end_comment

begin_comment
comment|/* Returns:     number of consecutive bits starting at "mask".              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Count the number of bits set in the address section of addrfamily_t and  */
end_comment

begin_comment
comment|/* return both that number and a pointer to the last word with a bit set if */
end_comment

begin_comment
comment|/* lastp is not NULL. The bit count is performed using network byte order   */
end_comment

begin_comment
comment|/* as the guide for which bit is the most significant bit.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|count_mask_bits
parameter_list|(
name|mask
parameter_list|,
name|lastp
parameter_list|)
name|addrfamily_t
modifier|*
name|mask
decl_stmt|;
name|u_32_t
modifier|*
modifier|*
name|lastp
decl_stmt|;
block|{
name|u_32_t
modifier|*
name|mp
init|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|mask
operator|->
name|adf_addr
decl_stmt|;
name|u_32_t
name|m
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|mlen
decl_stmt|;
name|mlen
operator|=
name|mask
operator|->
name|adf_len
operator|-
name|offsetof
argument_list|(
name|addrfamily_t
argument_list|,
name|adf_addr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|mlen
operator|>
literal|0
condition|;
name|mlen
operator|-=
literal|4
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ntohl
argument_list|(
operator|*
name|mp
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|lastp
operator|!=
name|NULL
condition|)
operator|*
name|lastp
operator|=
name|mp
expr_stmt|;
for|for
control|(
init|;
name|m
operator|&
literal|0x80000000
condition|;
name|m
operator|<<=
literal|1
control|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    buildnodes                                                  */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  addr(I)  - network address for this radix node              */
end_comment

begin_comment
comment|/*              mask(I)  - netmask associated with the above address        */
end_comment

begin_comment
comment|/*              nodes(O) - pair of ipf_rdx_node_t's to initialise with data */
end_comment

begin_comment
comment|/*                         associated with addr and mask.                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise the fields in a pair of radix tree nodes according to the     */
end_comment

begin_comment
comment|/* data supplied in the paramters "addr" and "mask". It is expected that    */
end_comment

begin_comment
comment|/* "mask" will contain a consecutive string of bits set. Masks with gaps in */
end_comment

begin_comment
comment|/* the middle are not handled by this implementation.                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|buildnodes
parameter_list|(
name|addr
parameter_list|,
name|mask
parameter_list|,
name|nodes
parameter_list|)
name|addrfamily_t
modifier|*
name|addr
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|ipf_rdx_node_t
name|nodes
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_32_t
name|maskbits
decl_stmt|;
name|u_32_t
name|lastbits
decl_stmt|;
name|u_32_t
name|lastmask
decl_stmt|;
name|u_32_t
modifier|*
name|last
decl_stmt|;
name|int
name|masklen
decl_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
name|maskbits
operator|=
name|count_mask_bits
argument_list|(
name|mask
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
name|masklen
operator|=
literal|0
expr_stmt|;
name|lastmask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|masklen
operator|=
name|last
operator|-
operator|(
name|u_32_t
operator|*
operator|)
name|mask
expr_stmt|;
name|lastmask
operator|=
operator|*
name|last
expr_stmt|;
block|}
name|lastbits
operator|=
name|maskbits
operator|&
literal|0x1f
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|nodes
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_rdx_node_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|maskbitcount
operator|=
name|maskbits
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|index
operator|=
operator|-
literal|1
operator|-
operator|(
name|ADF_OFF_BITS
operator|+
name|maskbits
operator|)
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|addrkey
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|addr
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|maskkey
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|mask
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|addroff
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|addrkey
operator|+
name|masklen
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|maskoff
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|maskkey
operator|+
name|masklen
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|parent
operator|=
operator|&
name|nodes
index|[
literal|1
index|]
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|masklen
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|lastmask
operator|=
name|lastmask
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|offset
operator|=
name|masklen
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|left
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|maskbitcount
operator|=
name|maskbits
expr_stmt|;
ifdef|#
directive|ifdef
name|RDX_DEBUG
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nodes
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"_BUILD.0"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nodes
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
literal|"_BUILD.1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_find_addr                                            */
end_comment

begin_comment
comment|/* Returns:     ipf_rdx_node_t * - pointer to a node in the radix tree.     */
end_comment

begin_comment
comment|/* Parameters:  tree(I)  - pointer to first right node in tree to search    */
end_comment

begin_comment
comment|/*              addr(I)  - pointer to address to match                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walk the radix tree given by "tree", looking for a leaf node that is a   */
end_comment

begin_comment
comment|/* match for the address given by "addr".                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_find_addr
parameter_list|(
name|tree
parameter_list|,
name|addr
parameter_list|)
name|ipf_rdx_node_t
modifier|*
name|tree
decl_stmt|;
name|u_32_t
modifier|*
name|addr
decl_stmt|;
block|{
name|ipf_rdx_node_t
modifier|*
name|cur
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|tree
init|;
name|cur
operator|->
name|index
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|bitmask
operator|&
name|addr
index|[
name|cur
operator|->
name|offset
index|]
condition|)
block|{
name|cur
operator|=
name|cur
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|=
name|cur
operator|->
name|left
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cur
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_match                                                */
end_comment

begin_comment
comment|/* Returns:     ipf_rdx_node_t * - NULL on error, else pointer to the node  */
end_comment

begin_comment
comment|/*                                 added to the tree.                       */
end_comment

begin_comment
comment|/* Paramters:   head(I)  - pointer to tree head to search                   */
end_comment

begin_comment
comment|/*              addr(I)  - pointer to address to find                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search the radix tree for the best match to the address pointed to by    */
end_comment

begin_comment
comment|/* "addr" and return a pointer to that node. This search will not match the */
end_comment

begin_comment
comment|/* address information stored in either of the root leaves as neither of    */
end_comment

begin_comment
comment|/* them are considered to be part of the tree of data being stored.         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_match
parameter_list|(
name|head
parameter_list|,
name|addr
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
name|addrfamily_t
modifier|*
name|addr
decl_stmt|;
block|{
name|ipf_rdx_mask_t
modifier|*
name|masknode
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|prev
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|cur
decl_stmt|;
name|u_32_t
modifier|*
name|data
decl_stmt|;
name|u_32_t
modifier|*
name|mask
decl_stmt|;
name|u_32_t
modifier|*
name|key
decl_stmt|;
name|u_32_t
modifier|*
name|end
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|=
name|addr
operator|->
name|adf_len
expr_stmt|;
name|end
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|addr
operator|+
name|len
operator|)
expr_stmt|;
name|node
operator|=
name|ipf_rx_find_addr
argument_list|(
name|head
operator|->
name|root
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Search the dupkey list for a potential match. 	 */
for|for
control|(
name|cur
operator|=
name|node
init|;
operator|(
name|cur
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cur
operator|->
name|root
operator|==
literal|0
operator|)
condition|;
name|cur
operator|=
name|cur
operator|->
name|dupkey
control|)
block|{
name|i
operator|=
name|cur
index|[
literal|0
index|]
operator|.
name|addroff
operator|-
name|cur
index|[
literal|0
index|]
operator|.
name|addrkey
expr_stmt|;
name|data
operator|=
name|cur
index|[
literal|0
index|]
operator|.
name|addrkey
operator|+
name|i
expr_stmt|;
name|mask
operator|=
name|cur
index|[
literal|0
index|]
operator|.
name|maskkey
operator|+
name|i
expr_stmt|;
name|key
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|addr
operator|+
name|i
expr_stmt|;
for|for
control|(
init|;
name|key
operator|<
name|end
condition|;
name|data
operator|++
operator|,
name|key
operator|++
operator|,
name|mask
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|key
operator|&
operator|*
name|mask
operator|)
operator|!=
operator|*
name|data
condition|)
break|break;
if|if
condition|(
operator|(
name|end
operator|==
name|key
operator|)
operator|&&
operator|(
name|cur
operator|->
name|root
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|cur
operator|)
return|;
comment|/* Equal keys */
block|}
name|prev
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|key
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|node
operator|=
name|prev
init|;
name|node
operator|->
name|root
operator|==
literal|0
condition|;
name|node
operator|=
name|node
operator|->
name|parent
control|)
block|{
comment|/* 		 * We know that the node hasn't matched so therefore only 		 * the entries in the mask list are searched, not the top 		 * node nor the dupkey list. 		 */
name|masknode
operator|=
name|node
operator|->
name|masks
expr_stmt|;
for|for
control|(
init|;
name|masknode
operator|!=
name|NULL
condition|;
name|masknode
operator|=
name|masknode
operator|->
name|next
control|)
block|{
if|if
condition|(
name|masknode
operator|->
name|maskbitcount
operator|>
name|node
operator|->
name|maskbitcount
condition|)
continue|continue;
name|cur
operator|=
name|masknode
operator|->
name|node
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ADF_OFF
operator|>>
literal|2
init|;
name|i
operator|<=
name|node
operator|->
name|offset
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|key
index|[
name|i
index|]
operator|&
name|masknode
operator|->
name|mask
index|[
name|i
index|]
operator|)
operator|==
name|cur
operator|->
name|addrkey
index|[
name|i
index|]
condition|)
return|return
operator|(
name|cur
operator|)
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_lookup                                               */
end_comment

begin_comment
comment|/* Returns:     ipf_rdx_node_t * - NULL on error, else pointer to the node  */
end_comment

begin_comment
comment|/*                                 added to the tree.                       */
end_comment

begin_comment
comment|/* Paramters:   head(I)  - pointer to tree head to search                   */
end_comment

begin_comment
comment|/*              addr(I)  - address part of the key to match                 */
end_comment

begin_comment
comment|/*              mask(I)  - netmask part of the key to match                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ipf_rx_lookup searches for an exact match on (addr,mask). The intention  */
end_comment

begin_comment
comment|/* is to see if a given key is in the tree, not to see if a route exists.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_lookup
parameter_list|(
name|head
parameter_list|,
name|addr
parameter_list|,
name|mask
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
name|addrfamily_t
modifier|*
name|addr
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_block
block|{
name|ipf_rdx_node_t
modifier|*
name|found
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|u_32_t
modifier|*
name|akey
decl_stmt|;
name|int
name|count
decl_stmt|;
name|found
operator|=
name|ipf_rx_find_addr
argument_list|(
name|head
operator|->
name|root
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|->
name|root
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* 	 * It is possible to find a matching address in the tree but for the 	 * netmask to not match. If the netmask does not match and there is 	 * no list of alternatives present at dupkey, return a failure. 	 */
name|count
operator|=
name|count_mask_bits
argument_list|(
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|found
operator|->
name|maskbitcount
operator|&&
name|found
operator|->
name|dupkey
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|akey
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|found
operator|->
name|addrkey
index|[
name|found
operator|->
name|offset
index|]
operator|&
name|found
operator|->
name|maskkey
index|[
name|found
operator|->
name|offset
index|]
operator|)
operator|!=
name|akey
index|[
name|found
operator|->
name|offset
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|found
operator|->
name|dupkey
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|found
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|maskbitcount
operator|!=
name|count
condition|)
name|node
operator|=
name|node
operator|->
name|dupkey
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|found
operator|=
name|node
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_attach_mask                                          */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  node(I)  - pointer to a radix tree node                     */
end_comment

begin_comment
comment|/*              mask(I)  - pointer to mask structure to add                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Add the netmask to the given node in an ordering where the most specific */
end_comment

begin_comment
comment|/* netmask is at the top of the list.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_rx_attach_mask
parameter_list|(
name|node
parameter_list|,
name|mask
parameter_list|)
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|ipf_rdx_mask_t
modifier|*
name|mask
decl_stmt|;
block|{
name|ipf_rdx_mask_t
modifier|*
modifier|*
name|pm
decl_stmt|;
name|ipf_rdx_mask_t
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|pm
operator|=
operator|&
name|node
operator|->
name|masks
init|;
operator|(
name|m
operator|=
operator|*
name|pm
operator|)
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|maskbitcount
operator|<
name|mask
operator|->
name|maskbitcount
condition|)
break|break;
name|mask
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_insert                                               */
end_comment

begin_comment
comment|/* Returns:     ipf_rdx_node_t * - NULL on error, else pointer to the node  */
end_comment

begin_comment
comment|/*                                 added to the tree.                       */
end_comment

begin_comment
comment|/* Paramters:   head(I)  - pointer to tree head to add nodes to             */
end_comment

begin_comment
comment|/*              nodes(I) - pointer to radix nodes to be added               */
end_comment

begin_comment
comment|/*              dup(O)   - set to 1 if node is a duplicate, else 0.         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Add the new radix tree entry that owns nodes[] to the tree given by head.*/
end_comment

begin_comment
comment|/* If there is already a matching key in the table, "dup" will be set to 1  */
end_comment

begin_comment
comment|/* and the existing node pointer returned if there is a complete key match. */
end_comment

begin_comment
comment|/* A complete key match is a matching of all key data that is presented by  */
end_comment

begin_comment
comment|/* by the netmask.                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_insert
parameter_list|(
name|head
parameter_list|,
name|nodes
parameter_list|,
name|dup
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
name|ipf_rdx_node_t
name|nodes
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|dup
decl_stmt|;
block|{
name|ipf_rdx_mask_t
modifier|*
modifier|*
name|pmask
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|prev
decl_stmt|;
name|ipf_rdx_mask_t
modifier|*
name|mask
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|cur
decl_stmt|;
name|u_32_t
name|nodemask
decl_stmt|;
name|u_32_t
modifier|*
name|addr
decl_stmt|;
name|u_32_t
modifier|*
name|data
decl_stmt|;
name|int
name|nodebits
decl_stmt|;
name|u_32_t
modifier|*
name|key
decl_stmt|;
name|u_32_t
modifier|*
name|end
decl_stmt|;
name|u_32_t
name|bits
decl_stmt|;
name|int
name|nodekey
decl_stmt|;
name|int
name|nodeoff
decl_stmt|;
name|int
name|nlen
decl_stmt|;
name|int
name|len
decl_stmt|;
name|addr
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|addrkey
expr_stmt|;
name|node
operator|=
name|ipf_rx_find_addr
argument_list|(
name|head
operator|->
name|root
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
operator|(
name|addrfamily_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|adf_len
expr_stmt|;
name|key
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|addrfamily_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|adf_addr
expr_stmt|;
name|data
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|addrfamily_t
operator|*
operator|)
name|node
operator|->
name|addrkey
operator|)
operator|->
name|adf_addr
expr_stmt|;
name|end
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|addr
operator|+
name|len
operator|)
expr_stmt|;
for|for
control|(
name|nlen
operator|=
literal|0
init|;
name|key
operator|<
name|end
condition|;
name|data
operator|++
operator|,
name|key
operator|++
operator|,
name|nlen
operator|+=
literal|32
control|)
if|if
condition|(
operator|*
name|key
operator|!=
operator|*
name|data
condition|)
break|break;
if|if
condition|(
name|end
operator|==
name|data
condition|)
block|{
operator|*
name|dup
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
comment|/* Equal keys */
block|}
operator|*
name|dup
operator|=
literal|0
expr_stmt|;
name|bits
operator|=
operator|(
name|ntohl
argument_list|(
operator|*
name|data
argument_list|)
operator|^
name|ntohl
argument_list|(
operator|*
name|key
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|bits
operator|!=
literal|0
condition|;
name|nlen
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bits
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
break|break;
name|bits
operator|<<=
literal|1
expr_stmt|;
block|}
name|nlen
operator|+=
name|ADF_OFF_BITS
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|index
operator|=
name|nlen
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|bitmask
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator|>>
operator|(
name|nlen
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|nlen
operator|/
literal|32
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|offset
operator|=
name|nlen
operator|/
literal|32
expr_stmt|;
comment|/* 	 * Walk through the tree and look for the correct place to attach 	 * this node. ipf_rx_fin_addr is not used here because the place 	 * to attach this node may be an internal node (same key, different 	 * netmask.) Additionally, the depth of the search is forcibly limited 	 * here to not exceed the netmask, so that a short netmask will be 	 * added higher up the tree even if there are lower branches. 	 */
name|cur
operator|=
name|head
operator|->
name|root
expr_stmt|;
name|key
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|addrkey
expr_stmt|;
do|do
block|{
name|prev
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|key
index|[
name|cur
operator|->
name|offset
index|]
operator|&
name|cur
operator|->
name|bitmask
condition|)
block|{
name|cur
operator|=
name|cur
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|=
name|cur
operator|->
name|left
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nlen
operator|>
operator|(
name|unsigned
operator|)
name|cur
operator|->
name|index
condition|)
do|;
if|if
condition|(
operator|(
name|key
index|[
name|prev
operator|->
name|offset
index|]
operator|&
name|prev
operator|->
name|bitmask
operator|)
operator|==
literal|0
condition|)
block|{
name|prev
operator|->
name|left
operator|=
operator|&
name|nodes
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|right
operator|=
operator|&
name|nodes
index|[
literal|1
index|]
expr_stmt|;
block|}
name|cur
operator|->
name|parent
operator|=
operator|&
name|nodes
index|[
literal|1
index|]
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|parent
operator|=
name|prev
expr_stmt|;
if|if
condition|(
operator|(
name|key
index|[
name|nodes
index|[
literal|1
index|]
operator|.
name|offset
index|]
operator|&
name|nodes
index|[
literal|1
index|]
operator|.
name|bitmask
operator|)
operator|==
literal|0
condition|)
block|{
name|nodes
index|[
literal|1
index|]
operator|.
name|right
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|nodes
index|[
literal|1
index|]
operator|.
name|right
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
name|nodes
index|[
literal|1
index|]
operator|.
name|left
operator|=
name|cur
expr_stmt|;
block|}
name|nodeoff
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|offset
expr_stmt|;
name|nodekey
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|addrkey
index|[
name|nodeoff
index|]
expr_stmt|;
name|nodemask
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|lastmask
expr_stmt|;
name|nodebits
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|maskbitcount
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Find the node up the tree with the largest pattern that still 	 * matches the node being inserted to see if this mask can be 	 * moved there. 	 */
for|for
control|(
name|cur
operator|=
name|nodes
index|[
literal|1
index|]
operator|.
name|parent
init|;
name|cur
operator|->
name|root
operator|==
literal|0
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|maskbitcount
operator|<=
name|nodebits
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|cur
operator|-
literal|1
operator|)
operator|->
name|addrkey
index|[
name|nodeoff
index|]
operator|&
name|nodemask
operator|)
operator|!=
name|nodekey
condition|)
break|break;
name|prev
operator|=
name|cur
expr_stmt|;
block|}
name|KMALLOC
argument_list|(
name|mask
argument_list|,
name|ipf_rdx_mask_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mask
operator|->
name|node
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
name|mask
operator|->
name|maskbitcount
operator|=
name|nodebits
expr_stmt|;
name|mask
operator|->
name|mask
operator|=
name|nodes
index|[
literal|0
index|]
operator|.
name|maskkey
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|mymask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ipf_rdx_mask_t
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|pmask
operator|=
operator|&
name|prev
operator|->
name|masks
init|;
operator|(
name|m
operator|=
operator|*
name|pmask
operator|)
operator|!=
name|NULL
condition|;
name|pmask
operator|=
operator|&
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|maskbitcount
operator|<
name|nodebits
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * No higher up nodes qualify, so attach mask locally. 		 */
name|pmask
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
operator|.
name|masks
expr_stmt|;
block|}
name|mask
operator|->
name|next
operator|=
operator|*
name|pmask
expr_stmt|;
operator|*
name|pmask
operator|=
name|mask
expr_stmt|;
comment|/* 	 * Search the mask list on each child to see if there are any masks 	 * there that can be moved up to this newly inserted node. 	 */
name|cur
operator|=
name|nodes
index|[
literal|1
index|]
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|root
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|pmask
operator|=
operator|&
name|cur
operator|->
name|masks
init|;
operator|(
name|mask
operator|=
operator|*
name|pmask
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|mask
operator|->
name|maskbitcount
operator|<
name|nodebits
condition|)
block|{
operator|*
name|pmask
operator|=
name|mask
operator|->
name|next
expr_stmt|;
name|ipf_rx_attach_mask
argument_list|(
operator|&
name|nodes
index|[
literal|0
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmask
operator|=
operator|&
name|mask
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|cur
operator|=
name|nodes
index|[
literal|1
index|]
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|root
operator|==
literal|0
operator|&&
name|cur
operator|!=
operator|&
name|nodes
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|pmask
operator|=
operator|&
name|cur
operator|->
name|masks
init|;
operator|(
name|mask
operator|=
operator|*
name|pmask
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|mask
operator|->
name|maskbitcount
operator|<
name|nodebits
condition|)
block|{
operator|*
name|pmask
operator|=
name|mask
operator|->
name|next
expr_stmt|;
name|ipf_rx_attach_mask
argument_list|(
operator|&
name|nodes
index|[
literal|0
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmask
operator|=
operator|&
name|mask
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|&
name|nodes
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_addroute                                             */
end_comment

begin_comment
comment|/* Returns:     ipf_rdx_node_t * - NULL on error, else pointer to the node  */
end_comment

begin_comment
comment|/*                                 added to the tree.                       */
end_comment

begin_comment
comment|/* Paramters:   head(I)  - pointer to tree head to search                   */
end_comment

begin_comment
comment|/*              addr(I)  - address portion of "route" to add                */
end_comment

begin_comment
comment|/*              mask(I)  - netmask portion of "route" to add                */
end_comment

begin_comment
comment|/*              nodes(I) - radix tree data nodes inside allocate structure  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Attempt to add a node to the radix tree. The key for the node is the     */
end_comment

begin_comment
comment|/* (addr,mask). No memory allocation for the radix nodes themselves is      */
end_comment

begin_comment
comment|/* performed here, the data structure that this radix node is being used to */
end_comment

begin_comment
comment|/* find is expected to house the node data itself however the call to       */
end_comment

begin_comment
comment|/* ipf_rx_insert() will attempt to allocate memory in order for netmask to  */
end_comment

begin_comment
comment|/* be promoted further up the tree.                                         */
end_comment

begin_comment
comment|/* In this case, the ip_pool_node_t structure from ip_pool.h contains both  */
end_comment

begin_comment
comment|/* the key material (addr,mask) and the radix tree nodes[].                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* The mechanics of inserting the node into the tree is handled by the      */
end_comment

begin_comment
comment|/* function ipf_rx_insert() above. Here, the code deals with the case       */
end_comment

begin_comment
comment|/* where the data to be inserted is a duplicate.                            */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_addroute
parameter_list|(
name|head
parameter_list|,
name|addr
parameter_list|,
name|mask
parameter_list|,
name|nodes
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
name|addrfamily_t
modifier|*
name|addr
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|ipf_rdx_node_t
modifier|*
name|nodes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|prev
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|x
decl_stmt|;
name|int
name|dup
decl_stmt|;
name|buildnodes
argument_list|(
name|addr
argument_list|,
name|mask
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
name|x
operator|=
name|ipf_rx_insert
argument_list|(
name|head
argument_list|,
name|nodes
argument_list|,
operator|&
name|dup
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|dup
operator|==
literal|1
condition|)
block|{
name|node
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * The duplicate list is kept sorted with the longest 		 * mask at the top, meaning that the most specific entry 		 * in the listis found first. This list thus allows for 		 * duplicates such as 128.128.0.0/32 and 128.128.0.0/16. 		 */
while|while
condition|(
operator|(
name|x
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|x
operator|->
name|maskbitcount
operator|>
name|node
operator|->
name|maskbitcount
operator|)
condition|)
block|{
name|prev
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|x
operator|->
name|dupkey
expr_stmt|;
block|}
comment|/* 		 * Is it a complete duplicate? If so, return NULL and 		 * fail the insert. Otherwise, insert it into the list 		 * of netmasks active for this key. 		 */
if|if
condition|(
operator|(
name|x
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|x
operator|->
name|maskbitcount
operator|==
name|node
operator|->
name|maskbitcount
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|nodes
index|[
literal|0
index|]
operator|.
name|dupkey
operator|=
name|x
expr_stmt|;
name|prev
operator|->
name|dupkey
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|parent
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
name|x
operator|->
name|parent
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|nodes
index|[
literal|0
index|]
operator|.
name|dupkey
operator|=
name|x
operator|->
name|dupkey
expr_stmt|;
name|prev
operator|=
name|x
operator|->
name|parent
expr_stmt|;
name|nodes
index|[
literal|0
index|]
operator|.
name|parent
operator|=
name|prev
expr_stmt|;
name|x
operator|->
name|parent
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|left
operator|==
name|x
condition|)
name|prev
operator|->
name|left
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
else|else
name|prev
operator|->
name|right
operator|=
operator|&
name|nodes
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
return|return
operator|&
name|nodes
index|[
literal|0
index|]
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_delete                                               */
end_comment

begin_comment
comment|/* Returns:     ipf_rdx_node_t * - NULL on error, else node removed from    */
end_comment

begin_comment
comment|/*                                 the tree.                                */
end_comment

begin_comment
comment|/* Paramters:   head(I)  - pointer to tree head to search                   */
end_comment

begin_comment
comment|/*              addr(I)  - pointer to the address part of the key           */
end_comment

begin_comment
comment|/*              mask(I)  - pointer to the netmask part of the key           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search for an entry in the radix tree that is an exact match for (addr,  */
end_comment

begin_comment
comment|/* mask) and remove it if it exists. In the case where (addr,mask) is a not */
end_comment

begin_comment
comment|/* a unique key, the tree structure itself is not changed - only the list   */
end_comment

begin_comment
comment|/* of duplicate keys.                                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipf_rdx_node_t
modifier|*
name|ipf_rx_delete
parameter_list|(
name|head
parameter_list|,
name|addr
parameter_list|,
name|mask
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
name|addrfamily_t
modifier|*
name|addr
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_block
block|{
name|ipf_rdx_mask_t
modifier|*
modifier|*
name|pmask
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|parent
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|found
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|prev
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|cur
decl_stmt|;
name|ipf_rdx_mask_t
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
name|found
operator|=
name|ipf_rx_find_addr
argument_list|(
name|head
operator|->
name|root
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|found
operator|->
name|root
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
name|count
operator|=
name|count_mask_bits
argument_list|(
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parent
operator|=
name|found
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|found
operator|->
name|dupkey
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|found
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|maskbitcount
operator|!=
name|count
condition|)
name|node
operator|=
name|node
operator|->
name|dupkey
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|node
operator|!=
name|found
condition|)
block|{
comment|/* 			 * Remove from the dupkey list. Here, "parent" is 			 * the previous node on the list (rather than tree) 			 * and "dupkey" is the next node on the list. 			 */
name|parent
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|parent
operator|->
name|dupkey
operator|=
name|node
operator|->
name|dupkey
expr_stmt|;
name|node
operator|->
name|dupkey
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *  			 * When removing the top node of the dupkey list, 			 * the pointers at the top of the list that point 			 * to other tree nodes need to be preserved and 			 * any children must have their parent updated. 			 */
name|node
operator|=
name|node
operator|->
name|dupkey
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|found
operator|->
name|parent
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|found
operator|->
name|right
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|found
operator|->
name|left
expr_stmt|;
name|found
operator|->
name|right
operator|->
name|parent
operator|=
name|node
expr_stmt|;
name|found
operator|->
name|left
operator|->
name|parent
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|left
operator|==
name|found
condition|)
name|parent
operator|->
name|left
operator|=
name|node
expr_stmt|;
else|else
name|parent
operator|->
name|right
operator|=
name|node
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|count
operator|!=
name|found
operator|->
name|maskbitcount
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * Remove the node from the tree and reconnect the subtree 		 * below. 		 */
comment|/* 		 * If there is a tree to the left, look for something to 		 * attach in place of "found". 		 */
name|prev
operator|=
name|found
operator|+
literal|1
expr_stmt|;
name|cur
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|found
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|parent
operator|->
name|right
operator|==
name|found
operator|+
literal|1
condition|)
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|parent
operator|->
name|right
operator|=
name|parent
expr_stmt|;
else|else
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|parent
operator|->
name|left
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|right
operator|==
name|parent
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|left
operator|==
name|found
condition|)
block|{
name|cur
operator|->
name|right
operator|=
name|parent
operator|->
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|left
operator|!=
name|parent
operator|-
literal|1
condition|)
block|{
name|cur
operator|->
name|right
operator|=
name|parent
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|right
operator|=
name|parent
operator|-
literal|1
expr_stmt|;
block|}
name|cur
operator|->
name|right
operator|->
name|parent
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parent
operator|->
name|right
operator|==
name|found
condition|)
block|{
name|cur
operator|->
name|left
operator|=
name|parent
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|right
operator|!=
name|parent
operator|-
literal|1
condition|)
block|{
name|cur
operator|->
name|left
operator|=
name|parent
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|left
operator|=
name|parent
operator|-
literal|1
expr_stmt|;
block|}
name|cur
operator|->
name|left
operator|->
name|parent
operator|=
name|cur
expr_stmt|;
block|}
name|parent
operator|->
name|left
operator|=
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|left
expr_stmt|;
if|if
condition|(
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|right
operator|!=
name|parent
condition|)
name|parent
operator|->
name|right
operator|=
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|right
expr_stmt|;
name|parent
operator|->
name|left
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|right
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|parent
operator|=
operator|(
name|found
operator|+
literal|1
operator|)
operator|->
name|parent
expr_stmt|;
name|parent
operator|->
name|bitmask
operator|=
name|prev
operator|->
name|bitmask
expr_stmt|;
name|parent
operator|->
name|offset
operator|=
name|prev
operator|->
name|offset
expr_stmt|;
name|parent
operator|->
name|index
operator|=
name|prev
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We found an edge node. 			 */
name|cur
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|left
operator|==
name|parent
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|left
operator|==
name|found
condition|)
block|{
name|cur
operator|->
name|left
operator|=
name|parent
operator|->
name|right
expr_stmt|;
name|parent
operator|->
name|right
operator|->
name|parent
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|left
operator|=
name|parent
operator|->
name|left
expr_stmt|;
name|parent
operator|->
name|left
operator|->
name|parent
operator|=
name|cur
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parent
operator|->
name|right
operator|!=
name|found
condition|)
block|{
name|cur
operator|->
name|right
operator|=
name|parent
operator|->
name|right
expr_stmt|;
name|parent
operator|->
name|right
operator|->
name|parent
operator|=
name|cur
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|right
operator|=
name|parent
operator|->
name|left
expr_stmt|;
name|prev
operator|->
name|left
operator|->
name|parent
operator|=
name|cur
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Remove mask associated with this node. 	 */
for|for
control|(
name|cur
operator|=
name|parent
init|;
name|cur
operator|->
name|root
operator|==
literal|0
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
block|{
name|ipf_rdx_mask_t
modifier|*
modifier|*
name|pm
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|maskbitcount
operator|<=
name|found
operator|->
name|maskbitcount
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|cur
operator|-
literal|1
operator|)
operator|->
name|addrkey
index|[
name|found
operator|->
name|offset
index|]
operator|&
name|found
operator|->
name|bitmask
operator|)
operator|!=
name|found
operator|->
name|addrkey
index|[
name|found
operator|->
name|offset
index|]
condition|)
break|break;
for|for
control|(
name|pm
operator|=
operator|&
name|cur
operator|->
name|masks
init|;
operator|(
name|m
operator|=
operator|*
name|pm
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|m
operator|->
name|node
operator|==
name|cur
condition|)
block|{
operator|*
name|pm
operator|=
name|m
operator|->
name|next
expr_stmt|;
break|break;
block|}
else|else
block|{
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
block|}
name|KFREE
argument_list|(
name|found
operator|->
name|mymask
argument_list|)
expr_stmt|;
comment|/* 	 * Masks that have been brought up to this node from below need to 	 * be sent back down. 	 */
for|for
control|(
name|pmask
operator|=
operator|&
name|parent
operator|->
name|masks
init|;
operator|(
name|m
operator|=
operator|*
name|pmask
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
operator|*
name|pmask
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|cur
operator|=
name|m
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|found
condition|)
continue|continue;
if|if
condition|(
name|found
operator|->
name|addrkey
index|[
name|cur
operator|->
name|offset
index|]
operator|&
name|cur
operator|->
name|lastmask
condition|)
block|{
name|ipf_rx_attach_mask
argument_list|(
name|parent
operator|->
name|right
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|left
operator|!=
name|found
condition|)
block|{
name|ipf_rx_attach_mask
argument_list|(
name|parent
operator|->
name|left
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_walktree                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Paramters:   head(I)   - pointer to tree head to search                  */
end_comment

begin_comment
comment|/*              walker(I) - function to call for each node in the tree      */
end_comment

begin_comment
comment|/*              arg(I)    - parameter to pass to walker, in addition to the */
end_comment

begin_comment
comment|/*                          node pointer                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A standard tree walking function except that it is iterative, rather     */
end_comment

begin_comment
comment|/* than recursive and tracks the next node in case the "walker" function    */
end_comment

begin_comment
comment|/* should happen to delete and free the current node. It thus goes without  */
end_comment

begin_comment
comment|/* saying that the "walker" function is not permitted to cause any change   */
end_comment

begin_comment
comment|/* in the validity of the data found at either the left or right child.     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rx_walktree
parameter_list|(
name|head
parameter_list|,
name|walker
parameter_list|,
name|arg
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
name|radix_walk_func_t
name|walker
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_rdx_node_t
modifier|*
name|next
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|node
init|=
name|head
operator|->
name|root
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|base
decl_stmt|;
while|while
condition|(
name|node
operator|->
name|index
operator|>=
literal|0
condition|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|base
operator|=
name|node
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|->
name|parent
operator|->
name|right
operator|==
name|node
operator|)
operator|&&
operator|(
name|node
operator|->
name|root
operator|==
literal|0
operator|)
condition|)
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
for|for
control|(
name|node
operator|=
name|node
operator|->
name|parent
operator|->
name|right
init|;
name|node
operator|->
name|index
operator|>=
literal|0
condition|;
control|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
name|next
operator|=
name|node
expr_stmt|;
for|for
control|(
name|node
operator|=
name|base
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|base
control|)
block|{
name|base
operator|=
name|node
operator|->
name|dupkey
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|root
operator|==
literal|0
condition|)
name|walker
argument_list|(
name|node
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|root
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_inithead                                             */
end_comment

begin_comment
comment|/* Returns:     int       - 0 = success, else failure                       */
end_comment

begin_comment
comment|/* Paramters:   softr(I)  - pointer to radix context                        */
end_comment

begin_comment
comment|/*              headp(O)  - location for where to store allocated tree head */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function allocates and initialises a radix tree head structure.     */
end_comment

begin_comment
comment|/* As a traditional radix tree, node 0 is used as the "0" sentinel and node */
end_comment

begin_comment
comment|/* "2" is used as the all ones sentinel, leaving node "1" as the root from  */
end_comment

begin_comment
comment|/* which the tree is hung with node "0" on its left and node "2" to the     */
end_comment

begin_comment
comment|/* right. The context, "softr", is used here to provide a common source of  */
end_comment

begin_comment
comment|/* the zeroes and ones data rather than have one per head.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_rx_inithead
parameter_list|(
name|softr
parameter_list|,
name|headp
parameter_list|)
name|radix_softc_t
modifier|*
name|softr
decl_stmt|;
name|ipf_rdx_head_t
modifier|*
modifier|*
name|headp
decl_stmt|;
block|{
name|ipf_rdx_head_t
modifier|*
name|ptr
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|KMALLOC
argument_list|(
name|ptr
argument_list|,
name|ipf_rdx_head_t
operator|*
argument_list|)
expr_stmt|;
operator|*
name|headp
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|ptr
operator|->
name|nodes
expr_stmt|;
name|ptr
operator|->
name|root
operator|=
name|node
operator|+
literal|1
expr_stmt|;
name|node
index|[
literal|0
index|]
operator|.
name|index
operator|=
name|ADF_OFF_BITS
expr_stmt|;
name|node
index|[
literal|0
index|]
operator|.
name|index
operator|=
operator|-
literal|1
operator|-
name|node
index|[
literal|0
index|]
operator|.
name|index
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|index
operator|=
name|ADF_OFF_BITS
expr_stmt|;
name|node
index|[
literal|2
index|]
operator|.
name|index
operator|=
name|node
index|[
literal|0
index|]
operator|.
name|index
expr_stmt|;
name|node
index|[
literal|0
index|]
operator|.
name|parent
operator|=
name|node
operator|+
literal|1
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|parent
operator|=
name|node
operator|+
literal|1
expr_stmt|;
name|node
index|[
literal|2
index|]
operator|.
name|parent
operator|=
name|node
operator|+
literal|1
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|bitmask
operator|=
name|htonl
argument_list|(
literal|0x80000000
argument_list|)
expr_stmt|;
name|node
index|[
literal|0
index|]
operator|.
name|root
operator|=
literal|1
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|root
operator|=
literal|1
expr_stmt|;
name|node
index|[
literal|2
index|]
operator|.
name|root
operator|=
literal|1
expr_stmt|;
name|node
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|ADF_OFF_BITS
operator|>>
literal|5
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|offset
operator|=
name|ADF_OFF_BITS
operator|>>
literal|5
expr_stmt|;
name|node
index|[
literal|2
index|]
operator|.
name|offset
operator|=
name|ADF_OFF_BITS
operator|>>
literal|5
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|left
operator|=
operator|&
name|node
index|[
literal|0
index|]
expr_stmt|;
name|node
index|[
literal|1
index|]
operator|.
name|right
operator|=
operator|&
name|node
index|[
literal|2
index|]
expr_stmt|;
name|node
index|[
literal|0
index|]
operator|.
name|addrkey
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|softr
operator|->
name|zeros
expr_stmt|;
name|node
index|[
literal|2
index|]
operator|.
name|addrkey
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|softr
operator|->
name|ones
expr_stmt|;
ifdef|#
directive|ifdef
name|RDX_DEBUG
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|node
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"0_ROOT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
literal|"1_ROOT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|node
index|[
literal|2
index|]
operator|.
name|name
argument_list|,
literal|"2_ROOT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|->
name|addaddr
operator|=
name|ipf_rx_addroute
expr_stmt|;
name|ptr
operator|->
name|deladdr
operator|=
name|ipf_rx_delete
expr_stmt|;
name|ptr
operator|->
name|lookup
operator|=
name|ipf_rx_lookup
expr_stmt|;
name|ptr
operator|->
name|matchaddr
operator|=
name|ipf_rx_match
expr_stmt|;
name|ptr
operator|->
name|walktree
operator|=
name|ipf_rx_walktree
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_freehead                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Paramters:   head(I)  - pointer to tree head to free                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function simply free's up the radix tree head. Prior to calling     */
end_comment

begin_comment
comment|/* this function, it is expected that the tree will have been emptied.      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rx_freehead
parameter_list|(
name|head
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|head
decl_stmt|;
block|{
name|KFREE
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_create                                               */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|ipf_rx_create
parameter_list|()
block|{
name|radix_softc_t
modifier|*
name|softr
decl_stmt|;
name|KMALLOC
argument_list|(
name|softr
argument_list|,
name|radix_softc_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|softr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softr
argument_list|)
argument_list|)
expr_stmt|;
name|KMALLOCS
argument_list|(
name|softr
operator|->
name|zeros
argument_list|,
name|u_char
operator|*
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|addrfamily_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softr
operator|->
name|zeros
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|softr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|softr
operator|->
name|ones
operator|=
name|softr
operator|->
name|zeros
operator|+
sizeof|sizeof
argument_list|(
name|addrfamily_t
argument_list|)
expr_stmt|;
return|return
name|softr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_init                                                 */
end_comment

begin_comment
comment|/* Returns:     int       - 0 = success (always)                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_rx_init
parameter_list|(
name|ctx
parameter_list|)
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|radix_softc_t
modifier|*
name|softr
init|=
name|ctx
decl_stmt|;
name|memset
argument_list|(
name|softr
operator|->
name|zeros
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|addrfamily_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|softr
operator|->
name|ones
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|addrfamily_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_rx_destroy                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_rx_destroy
parameter_list|(
name|ctx
parameter_list|)
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|radix_softc_t
modifier|*
name|softr
init|=
name|ctx
decl_stmt|;
if|if
condition|(
name|softr
operator|->
name|zeros
operator|!=
name|NULL
condition|)
name|KFREES
argument_list|(
name|softr
operator|->
name|zeros
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|addrfamily_t
argument_list|)
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|softr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ====================================================================== */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RDX_DEBUG
end_ifdef

begin_comment
comment|/*  * To compile this file as a standalone test unit, use -DRDX_DEBUG=1  */
end_comment

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|x
parameter_list|)
value|((x)->index< 0 ? (x)->name : (x)->name)
end_define

begin_define
define|#
directive|define
name|GNAME
parameter_list|(
name|y
parameter_list|)
value|((y) == NULL ? "NULL" : NAME(y))
end_define

begin_typedef
typedef|typedef
struct|struct
name|myst
block|{
name|struct
name|ipf_rdx_node
name|nodes
index|[
literal|2
index|]
decl_stmt|;
name|addrfamily_t
name|dst
decl_stmt|;
name|addrfamily_t
name|mask
decl_stmt|;
name|struct
name|myst
modifier|*
name|next
decl_stmt|;
name|int
name|printed
decl_stmt|;
block|}
name|myst_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tabe_s
block|{
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|mask
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
block|}
name|tabe_t
typedef|;
end_typedef

begin_decl_stmt
name|tabe_t
name|builtin
index|[]
init|=
block|{
if|#
directive|if
literal|1
block|{
literal|"192:168:100::0"
block|,
literal|"48"
block|,
literal|"d"
block|}
block|,
block|{
literal|"192:168:100::2"
block|,
literal|"128"
block|,
literal|"d"
block|}
block|,
else|#
directive|else
block|{
literal|"127.192.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.128.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.96.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.80.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.72.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.64.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.56.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.48.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.40.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.32.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.24.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.16.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.8.0.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"124.0.0.0"
block|,
literal|"255.0.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"125.0.0.0"
block|,
literal|"255.0.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"126.0.0.0"
block|,
literal|"255.0.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"127.0.0.0"
block|,
literal|"255.0.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"10.0.0.0"
block|,
literal|"255.0.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"128.250.0.0"
block|,
literal|"255.255.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"192.168.0.0"
block|,
literal|"255.255.0.0"
block|,
literal|"d"
block|}
block|,
block|{
literal|"192.168.1.0"
block|,
literal|"255.255.255.0"
block|,
literal|"d"
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mtable
index|[]
index|[
literal|1
index|]
init|=
block|{
if|#
directive|if
literal|1
block|{
literal|"192:168:100::2"
block|}
block|,
block|{
literal|"192:168:101::2"
block|}
block|,
else|#
directive|else
block|{
literal|"9.0.0.0"
block|}
block|,
block|{
literal|"9.0.0.1"
block|}
block|,
block|{
literal|"11.0.0.0"
block|}
block|,
block|{
literal|"11.0.0.1"
block|}
block|,
block|{
literal|"127.0.0.1"
block|}
block|,
block|{
literal|"127.0.1.0"
block|}
block|,
block|{
literal|"255.255.255.0"
block|}
block|,
block|{
literal|"126.0.0.1"
block|}
block|,
block|{
literal|"128.251.0.0"
block|}
block|,
block|{
literal|"128.251.0.1"
block|}
block|,
block|{
literal|"128.251.255.255"
block|}
block|,
block|{
literal|"129.250.0.0"
block|}
block|,
block|{
literal|"129.250.0.1"
block|}
block|,
block|{
literal|"192.168.255.255"
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forder
index|[
literal|22
index|]
init|=
block|{
literal|14
block|,
literal|13
block|,
literal|12
block|,
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|19
block|,
literal|7
block|,
literal|4
block|,
literal|20
block|,
literal|8
block|,
literal|2
block|,
literal|17
block|,
literal|9
block|,
literal|16
block|,
literal|11
block|,
literal|15
block|,
literal|1
block|,
literal|6
block|,
literal|18
block|,
literal|0
block|,
literal|21
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nodecount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|myst_t
modifier|*
name|myst_top
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tabe_t
modifier|*
name|ttable
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|add_addr
parameter_list|(
name|ipf_rdx_head_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|checktree
parameter_list|(
name|ipf_rdx_head_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|delete_addr
parameter_list|(
name|ipf_rdx_head_t
modifier|*
name|rnh
parameter_list|,
name|int
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dumptree
parameter_list|(
name|ipf_rdx_head_t
modifier|*
name|rnh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|nodeprinter
parameter_list|(
name|ipf_rdx_node_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printroots
parameter_list|(
name|ipf_rdx_head_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|random_add
parameter_list|(
name|ipf_rdx_head_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|random_delete
parameter_list|(
name|ipf_rdx_head_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_addr
parameter_list|(
name|ipf_rdx_head_t
modifier|*
name|rnh
parameter_list|,
name|int
name|pref
parameter_list|,
name|addrfamily_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ipf_rx_freenode
parameter_list|(
name|node
parameter_list|,
name|arg
parameter_list|)
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_rdx_head_t
modifier|*
name|head
init|=
name|arg
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|rv
decl_stmt|;
name|myst_t
modifier|*
name|stp
decl_stmt|;
name|stp
operator|=
operator|(
name|myst_t
operator|*
operator|)
name|node
expr_stmt|;
name|rv
operator|=
name|ipf_rx_delete
argument_list|(
name|head
argument_list|,
operator|&
name|stp
operator|->
name|dst
argument_list|,
operator|&
name|stp
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|addrname
parameter_list|(
name|ap
parameter_list|)
name|addrfamily_t
modifier|*
name|ap
decl_stmt|;
block|{
specifier|static
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|txt
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|txt
operator|=
name|inet_ntop
argument_list|(
name|ap
operator|->
name|adf_family
argument_list|,
operator|&
name|ap
operator|->
name|adf_addr
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|txt
return|;
block|}
end_function

begin_function
name|void
name|fill6bits
parameter_list|(
name|bits
parameter_list|,
name|msk
parameter_list|)
name|int
name|bits
decl_stmt|;
name|u_int
modifier|*
name|msk
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
name|msk
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|msk
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|msk
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|msk
index|[
literal|2
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|msk
index|[
literal|3
index|]
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|128
condition|)
return|return;
if|if
condition|(
name|bits
operator|>
literal|96
condition|)
block|{
name|msk
index|[
literal|3
index|]
operator|=
name|htonl
argument_list|(
name|msk
index|[
literal|3
index|]
operator|<<
operator|(
literal|128
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits
operator|>
literal|64
condition|)
block|{
name|msk
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
name|msk
index|[
literal|2
index|]
operator|<<
operator|(
literal|96
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits
operator|>
literal|32
condition|)
block|{
name|msk
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|msk
index|[
literal|1
index|]
operator|<<
operator|(
literal|64
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msk
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msk
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|msk
index|[
literal|0
index|]
operator|<<
operator|(
literal|32
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|setaddr
parameter_list|(
name|afp
parameter_list|,
name|str
parameter_list|)
name|addrfamily_t
modifier|*
name|afp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|afp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|afp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|afp
operator|->
name|adf_family
operator|=
name|AF_INET
expr_stmt|;
name|afp
operator|->
name|adf_len
operator|=
name|offsetof
argument_list|(
name|addrfamily_t
argument_list|,
name|adf_addr
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|afp
operator|->
name|adf_family
operator|=
name|AF_INET6
expr_stmt|;
name|afp
operator|->
name|adf_len
operator|=
name|offsetof
argument_list|(
name|addrfamily_t
argument_list|,
name|adf_addr
argument_list|)
operator|+
literal|16
expr_stmt|;
block|}
name|inet_pton
argument_list|(
name|afp
operator|->
name|adf_family
argument_list|,
name|str
argument_list|,
operator|&
name|afp
operator|->
name|adf_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setmask
parameter_list|(
name|afp
parameter_list|,
name|str
parameter_list|)
name|addrfamily_t
modifier|*
name|afp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|strchr
argument_list|(
name|str
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|afp
operator|->
name|adf_addr
operator|.
name|in4
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|afp
operator|->
name|adf_len
operator|=
name|offsetof
argument_list|(
name|addrfamily_t
argument_list|,
name|adf_addr
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|afp
operator|->
name|adf_family
operator|==
name|AF_INET
condition|)
block|{
name|afp
operator|->
name|adf_addr
operator|.
name|i6
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|atoi
argument_list|(
name|str
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|afp
operator|->
name|adf_len
operator|=
name|offsetof
argument_list|(
name|addrfamily_t
argument_list|,
name|adf_addr
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|afp
operator|->
name|adf_family
operator|==
name|AF_INET6
condition|)
block|{
name|fill6bits
argument_list|(
name|atoi
argument_list|(
name|str
argument_list|)
argument_list|,
name|afp
operator|->
name|adf_addr
operator|.
name|i6
argument_list|)
expr_stmt|;
name|afp
operator|->
name|adf_len
operator|=
name|offsetof
argument_list|(
name|addrfamily_t
argument_list|,
name|adf_addr
argument_list|)
operator|+
literal|16
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nodeprinter
parameter_list|(
name|node
parameter_list|,
name|arg
parameter_list|)
name|ipf_rdx_node_t
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|myst_t
modifier|*
name|stp
init|=
operator|(
name|myst_t
operator|*
operator|)
name|node
decl_stmt|;
name|printf
argument_list|(
literal|"Node %-9.9s L %-9.9s R %-9.9s P %9.9s/%-9.9s %s/%d\n"
argument_list|,
name|node
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|left
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|right
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|0
index|]
operator|.
name|parent
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|parent
argument_list|)
argument_list|,
name|addrname
argument_list|(
operator|&
name|stp
operator|->
name|dst
argument_list|)
argument_list|,
name|node
index|[
literal|0
index|]
operator|.
name|maskbitcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|printed
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"!!! %d\n"
argument_list|,
name|stp
operator|->
name|printed
argument_list|)
expr_stmt|;
else|else
name|stp
operator|->
name|printed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printnode
parameter_list|(
name|stp
parameter_list|)
name|myst_t
modifier|*
name|stp
decl_stmt|;
block|{
name|ipf_rdx_node_t
modifier|*
name|node
init|=
operator|&
name|stp
operator|->
name|nodes
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|stp
operator|->
name|nodes
index|[
literal|0
index|]
operator|.
name|index
operator|>
literal|0
condition|)
name|stp
operator|=
operator|(
name|myst_t
operator|*
operator|)
operator|&
name|stp
operator|->
name|nodes
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"Node %-9.9s "
argument_list|,
name|node
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L %-9.9s "
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"R %-9.9s "
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"P %9.9s"
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|0
index|]
operator|.
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/%-9.9s "
argument_list|,
name|GNAME
argument_list|(
name|node
index|[
literal|1
index|]
operator|.
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s P%d\n"
argument_list|,
name|addrname
argument_list|(
operator|&
name|stp
operator|->
name|dst
argument_list|)
argument_list|,
name|stp
operator|->
name|printed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buildtab
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|tabe_t
modifier|*
name|tab
decl_stmt|;
name|int
name|lines
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|lines
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
literal|"hosts"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|lines
operator|++
expr_stmt|;
if|if
condition|(
name|lines
operator|==
literal|1
condition|)
name|tab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|tab
operator|=
name|realloc
argument_list|(
name|tab
argument_list|,
operator|(
name|lines
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|tab
index|[
name|lines
operator|-
literal|1
index|]
operator|.
name|host
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|tab
index|[
name|lines
operator|-
literal|1
index|]
operator|.
name|host
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tab
index|[
name|lines
operator|-
literal|1
index|]
operator|.
name|mask
operator|=
name|s
expr_stmt|;
name|tab
index|[
name|lines
operator|-
literal|1
index|]
operator|.
name|what
operator|=
literal|"d"
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|tab
index|[
name|lines
index|]
operator|.
name|host
operator|=
name|NULL
expr_stmt|;
name|tab
index|[
name|lines
index|]
operator|.
name|mask
operator|=
name|NULL
expr_stmt|;
name|tab
index|[
name|lines
index|]
operator|.
name|what
operator|=
name|NULL
expr_stmt|;
name|ttable
operator|=
name|tab
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printroots
parameter_list|(
name|rnh
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"Root.0.%s b %3d p %-9.9s l %-9.9s r %-9.9s\n"
argument_list|,
name|GNAME
argument_list|(
operator|&
name|rnh
operator|->
name|nodes
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rnh
operator|->
name|nodes
index|[
literal|0
index|]
operator|.
name|index
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|0
index|]
operator|.
name|parent
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|0
index|]
operator|.
name|left
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|0
index|]
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Root.1.%s b %3d p %-9.9s l %-9.9s r %-9.9s\n"
argument_list|,
name|GNAME
argument_list|(
operator|&
name|rnh
operator|->
name|nodes
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|rnh
operator|->
name|nodes
index|[
literal|1
index|]
operator|.
name|index
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|1
index|]
operator|.
name|parent
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|1
index|]
operator|.
name|left
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|1
index|]
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Root.2.%s b %3d p %-9.9s l %-9.9s r %-9.9s\n"
argument_list|,
name|GNAME
argument_list|(
operator|&
name|rnh
operator|->
name|nodes
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|rnh
operator|->
name|nodes
index|[
literal|2
index|]
operator|.
name|index
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|2
index|]
operator|.
name|parent
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|2
index|]
operator|.
name|left
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rnh
operator|->
name|nodes
index|[
literal|2
index|]
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|addrfamily_t
name|af
decl_stmt|;
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
name|radix_softc_t
modifier|*
name|ctx
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rnh
operator|=
name|NULL
expr_stmt|;
name|buildtab
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|ipf_rx_create
argument_list|()
expr_stmt|;
name|ipf_rx_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ipf_rx_inithead
argument_list|(
name|ctx
argument_list|,
operator|&
name|rnh
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=== ADD-0 ===\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ttable
index|[
name|i
index|]
operator|.
name|host
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|add_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
name|printroots
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=== DELETE-0 ===\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ttable
index|[
name|i
index|]
operator|.
name|host
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|delete_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printroots
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"=== ADD-1 ===\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ttable
index|[
name|i
index|]
operator|.
name|host
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|setaddr
argument_list|(
operator|&
name|af
argument_list|,
name|ttable
index|[
name|i
index|]
operator|.
name|host
argument_list|)
expr_stmt|;
name|add_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*forder[i]); */
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
name|dumptree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=== TEST-1 ===\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ttable
index|[
name|i
index|]
operator|.
name|host
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|setaddr
argument_list|(
operator|&
name|af
argument_list|,
name|ttable
index|[
name|i
index|]
operator|.
name|host
argument_list|)
expr_stmt|;
name|test_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|,
operator|&
name|af
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"=== TEST-2 ===\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mtable
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|setaddr
argument_list|(
operator|&
name|af
argument_list|,
name|mtable
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|test_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|,
operator|&
name|af
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"=== DELETE-1 ===\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ttable
index|[
name|i
index|]
operator|.
name|host
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ttable
index|[
name|i
index|]
operator|.
name|what
index|[
literal|0
index|]
operator|!=
literal|'d'
condition|)
continue|continue;
name|delete_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|ttable
index|[
name|j
index|]
operator|.
name|host
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
name|setaddr
argument_list|(
operator|&
name|af
argument_list|,
name|ttable
index|[
name|j
index|]
operator|.
name|host
argument_list|)
expr_stmt|;
name|test_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|,
operator|&
name|af
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|printroots
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dumptree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=== ADD-2 ===\n"
argument_list|)
expr_stmt|;
name|random_add
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=== DELETE-2 ===\n"
argument_list|)
expr_stmt|;
name|random_delete
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|ipf_rx_freenode
argument_list|,
name|rnh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|dumptree
parameter_list|(
name|rnh
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
block|{
name|myst_t
modifier|*
name|stp
decl_stmt|;
name|printf
argument_list|(
literal|"VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n"
argument_list|)
expr_stmt|;
name|printroots
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
for|for
control|(
name|stp
operator|=
name|myst_top
init|;
name|stp
condition|;
name|stp
operator|=
name|stp
operator|->
name|next
control|)
name|printnode
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|test_addr
parameter_list|(
name|rnh
parameter_list|,
name|pref
parameter_list|,
name|addr
parameter_list|,
name|limit
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
name|int
name|pref
decl_stmt|;
name|addrfamily_t
modifier|*
name|addr
decl_stmt|;
block|{
specifier|static
name|int
name|extras
index|[
literal|14
index|]
init|=
block|{
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|9
block|,
literal|15
block|,
literal|16
block|,
literal|19
block|,
literal|255
block|,
literal|256
block|,
literal|65535
block|,
literal|65536
block|}
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|rn
decl_stmt|;
name|addrfamily_t
name|af
decl_stmt|;
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
name|myst_t
modifier|*
name|stp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|af
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|af
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (limit< 0 || limit> 14) 		limit = 14;  	for (i = 0; i< limit; i++) { 		if (ttable[i].host == NULL) 			break; 		setaddr(&af, ttable[i].host); 		printf("%d.%d.LOOKUP(%s)", pref, i, addrname(&af)); 		rn = ipf_rx_match(rnh,&af); 		stp = (myst_t *)rn; 		printf(" = %s (%s/%d)\n", GNAME(rn), 			rn ? addrname(&stp->dst) : "NULL", 			rn ? rn->maskbitcount : 0); 	}
else|#
directive|else
name|printf
argument_list|(
literal|"%d.%d.LOOKUP(%s)"
argument_list|,
name|pref
argument_list|,
operator|-
literal|1
argument_list|,
name|addrname
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|rn
operator|=
name|ipf_rx_match
argument_list|(
name|rnh
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|stp
operator|=
operator|(
name|myst_t
operator|*
operator|)
name|rn
expr_stmt|;
name|printf
argument_list|(
literal|" = %s (%s/%d)\n"
argument_list|,
name|GNAME
argument_list|(
name|rn
argument_list|)
argument_list|,
name|rn
condition|?
name|addrname
argument_list|(
operator|&
name|stp
operator|->
name|dst
argument_list|)
else|:
literal|"NULL"
argument_list|,
name|rn
condition|?
name|rn
operator|->
name|maskbitcount
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|delete_addr
parameter_list|(
name|rnh
parameter_list|,
name|item
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
name|int
name|item
decl_stmt|;
block|{
name|ipf_rdx_node_t
modifier|*
name|rn
decl_stmt|;
name|addrfamily_t
name|mask
decl_stmt|;
name|addrfamily_t
name|af
decl_stmt|;
name|myst_t
modifier|*
modifier|*
name|pstp
decl_stmt|;
name|myst_t
modifier|*
name|stp
decl_stmt|;
name|memset
argument_list|(
operator|&
name|af
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|af
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|setaddr
argument_list|(
operator|&
name|af
argument_list|,
name|ttable
index|[
name|item
index|]
operator|.
name|host
argument_list|)
expr_stmt|;
name|mask
operator|.
name|adf_family
operator|=
name|af
operator|.
name|adf_family
expr_stmt|;
name|setmask
argument_list|(
operator|&
name|mask
argument_list|,
name|ttable
index|[
name|item
index|]
operator|.
name|mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DELETE(%s)\n"
argument_list|,
name|addrname
argument_list|(
operator|&
name|af
argument_list|)
argument_list|)
expr_stmt|;
name|rn
operator|=
name|ipf_rx_delete
argument_list|(
name|rnh
argument_list|,
operator|&
name|af
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"FAIL LOOKUP DELETE\n"
argument_list|)
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
for|for
control|(
name|stp
operator|=
name|myst_top
init|;
name|stp
operator|!=
name|NULL
condition|;
name|stp
operator|=
name|stp
operator|->
name|next
control|)
if|if
condition|(
name|stp
operator|->
name|printed
operator|!=
operator|-
literal|1
condition|)
name|stp
operator|->
name|printed
operator|=
operator|-
literal|2
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|rnh
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d.delete(%s) = %s\n"
argument_list|,
name|item
argument_list|,
name|addrname
argument_list|(
operator|&
name|af
argument_list|)
argument_list|,
name|GNAME
argument_list|(
name|rn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pstp
operator|=
operator|&
name|myst_top
init|;
operator|(
name|stp
operator|=
operator|*
name|pstp
operator|)
operator|!=
name|NULL
condition|;
name|pstp
operator|=
operator|&
name|stp
operator|->
name|next
control|)
if|if
condition|(
name|stp
operator|==
operator|(
name|myst_t
operator|*
operator|)
name|rn
condition|)
break|break;
name|stp
operator|->
name|printed
operator|=
operator|-
literal|1
expr_stmt|;
name|stp
operator|->
name|nodes
index|[
literal|0
index|]
operator|.
name|parent
operator|=
operator|&
name|stp
operator|->
name|nodes
index|[
literal|0
index|]
expr_stmt|;
name|stp
operator|->
name|nodes
index|[
literal|1
index|]
operator|.
name|parent
operator|=
operator|&
name|stp
operator|->
name|nodes
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|pstp
operator|=
name|stp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|nodecount
operator|--
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_addr
parameter_list|(
name|rnh
parameter_list|,
name|n
parameter_list|,
name|item
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
name|int
name|n
decl_stmt|,
name|item
decl_stmt|;
block|{
name|ipf_rdx_node_t
modifier|*
name|rn
decl_stmt|;
name|myst_t
modifier|*
name|stp
decl_stmt|;
name|stp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stp
argument_list|)
argument_list|)
expr_stmt|;
name|rn
operator|=
operator|(
name|ipf_rdx_node_t
operator|*
operator|)
name|stp
expr_stmt|;
name|setaddr
argument_list|(
operator|&
name|stp
operator|->
name|dst
argument_list|,
name|ttable
index|[
name|item
index|]
operator|.
name|host
argument_list|)
expr_stmt|;
name|stp
operator|->
name|mask
operator|.
name|adf_family
operator|=
name|stp
operator|->
name|dst
operator|.
name|adf_family
expr_stmt|;
name|setmask
argument_list|(
operator|&
name|stp
operator|->
name|mask
argument_list|,
name|ttable
index|[
name|item
index|]
operator|.
name|mask
argument_list|)
expr_stmt|;
name|stp
operator|->
name|next
operator|=
name|myst_top
expr_stmt|;
name|myst_top
operator|=
name|stp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rn
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"_BORN.0"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rn
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
literal|"_BORN.1"
argument_list|)
expr_stmt|;
name|rn
operator|=
name|ipf_rx_addroute
argument_list|(
name|rnh
argument_list|,
operator|&
name|stp
operator|->
name|dst
argument_list|,
operator|&
name|stp
operator|->
name|mask
argument_list|,
name|stp
operator|->
name|nodes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rn
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"%d_NODE.0"
argument_list|,
name|item
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rn
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
literal|"%d_NODE.1"
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ADD %d/%d %s/%s\n"
argument_list|,
name|n
argument_list|,
name|item
argument_list|,
name|rn
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|rn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|nodecount
operator|++
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|checktree
parameter_list|(
name|ipf_rdx_head_t
modifier|*
name|head
parameter_list|)
block|{
name|myst_t
modifier|*
name|s1
decl_stmt|;
name|ipf_rdx_node_t
modifier|*
name|rn
decl_stmt|;
if|if
condition|(
name|nodecount
operator|<=
literal|1
condition|)
return|return;
for|for
control|(
name|s1
operator|=
name|myst_top
init|;
name|s1
operator|!=
name|NULL
condition|;
name|s1
operator|=
name|s1
operator|->
name|next
control|)
block|{
name|int
name|fault
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s1
operator|->
name|printed
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|rn
operator|=
operator|&
name|s1
operator|->
name|nodes
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|right
operator|->
name|parent
operator|!=
name|rn
condition|)
name|fault
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|left
operator|->
name|parent
operator|!=
name|rn
condition|)
name|fault
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|parent
operator|->
name|left
operator|!=
name|rn
operator|&&
name|rn
operator|->
name|parent
operator|->
name|right
operator|!=
name|rn
condition|)
name|fault
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|fault
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"FAULT %#x %s\n"
argument_list|,
name|fault
argument_list|,
name|rn
operator|->
name|name
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|ipf_rx_walktree
argument_list|(
name|head
argument_list|,
name|nodeprinter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
modifier|*
name|randomize
parameter_list|(
name|int
modifier|*
name|pnitems
parameter_list|)
block|{
name|int
modifier|*
name|order
decl_stmt|;
name|int
name|nitems
decl_stmt|;
name|int
name|choice
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nitems
operator|=
sizeof|sizeof
argument_list|(
name|ttable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ttable
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|pnitems
operator|=
name|nitems
expr_stmt|;
name|order
operator|=
name|calloc
argument_list|(
name|nitems
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|order
argument_list|)
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|getpid
argument_list|()
operator|*
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|order
argument_list|,
literal|0xff
argument_list|,
name|nitems
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|order
argument_list|)
argument_list|)
expr_stmt|;
name|order
index|[
literal|21
index|]
operator|=
literal|21
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
name|choice
operator|=
name|rand
argument_list|()
operator|%
operator|(
name|nitems
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nitems
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|order
index|[
name|j
index|]
operator|==
name|choice
condition|)
break|break;
block|}
do|while
condition|(
name|j
operator|!=
name|nitems
condition|)
do|;
name|order
index|[
name|i
index|]
operator|=
name|choice
expr_stmt|;
block|}
return|return
name|order
return|;
block|}
end_function

begin_function
name|void
name|random_add
parameter_list|(
name|rnh
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
block|{
name|int
modifier|*
name|order
decl_stmt|;
name|int
name|nitems
decl_stmt|;
name|int
name|i
decl_stmt|;
name|order
operator|=
name|randomize
argument_list|(
operator|&
name|nitems
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|add_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|,
name|order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|random_delete
parameter_list|(
name|rnh
parameter_list|)
name|ipf_rdx_head_t
modifier|*
name|rnh
decl_stmt|;
block|{
name|int
modifier|*
name|order
decl_stmt|;
name|int
name|nitems
decl_stmt|;
name|int
name|i
decl_stmt|;
name|order
operator|=
name|randomize
argument_list|(
operator|&
name|nitems
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|delete_addr
argument_list|(
name|rnh
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|checktree
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RDX_DEBUG */
end_comment

end_unit

