begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  * You may select, at your option, one of the above-listed licenses.  */
end_comment

begin_comment
comment|/*- Dependencies -*/
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* size_t, ptrdiff_t */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free, qsort */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_STATIC_LINKING_ONLY
end_ifndef

begin_define
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* XXH64_state_t */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* XXH64_* */
end_comment

begin_include
include|#
directive|include
file|"zstd_v07.h"
end_include

begin_define
define|#
directive|define
name|FSEv07_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* FSEv07_MIN_TABLELOG */
end_comment

begin_define
define|#
directive|define
name|HUFv07_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* HUFv07_TABLELOG_ABSOLUTEMAX */
end_comment

begin_define
define|#
directive|define
name|ZSTDv07_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ZSTDv07_STATIC_LINKING_ONLY
end_ifdef

begin_comment
comment|/* ====================================================================================  * The definitions in this section are considered experimental.  * They should never be used with a dynamic library, as they may change in the future.  * They are provided for advanced usages.  * Use them only in association with static linking.  * ==================================================================================== */
end_comment

begin_comment
comment|/*--- Constants ---*/
end_comment

begin_define
define|#
directive|define
name|ZSTDv07_MAGIC_SKIPPABLE_START
value|0x184D2A50U
end_define

begin_define
define|#
directive|define
name|ZSTDv07_WINDOWLOG_MAX_32
value|25
end_define

begin_define
define|#
directive|define
name|ZSTDv07_WINDOWLOG_MAX_64
value|27
end_define

begin_define
define|#
directive|define
name|ZSTDv07_WINDOWLOG_MAX
value|((U32)(MEM_32bits() ? ZSTDv07_WINDOWLOG_MAX_32 : ZSTDv07_WINDOWLOG_MAX_64))
end_define

begin_define
define|#
directive|define
name|ZSTDv07_WINDOWLOG_MIN
value|18
end_define

begin_define
define|#
directive|define
name|ZSTDv07_CHAINLOG_MAX
value|(ZSTDv07_WINDOWLOG_MAX+1)
end_define

begin_define
define|#
directive|define
name|ZSTDv07_CHAINLOG_MIN
value|4
end_define

begin_define
define|#
directive|define
name|ZSTDv07_HASHLOG_MAX
value|ZSTDv07_WINDOWLOG_MAX
end_define

begin_define
define|#
directive|define
name|ZSTDv07_HASHLOG_MIN
value|12
end_define

begin_define
define|#
directive|define
name|ZSTDv07_HASHLOG3_MAX
value|17
end_define

begin_define
define|#
directive|define
name|ZSTDv07_SEARCHLOG_MAX
value|(ZSTDv07_WINDOWLOG_MAX-1)
end_define

begin_define
define|#
directive|define
name|ZSTDv07_SEARCHLOG_MIN
value|1
end_define

begin_define
define|#
directive|define
name|ZSTDv07_SEARCHLENGTH_MAX
value|7
end_define

begin_define
define|#
directive|define
name|ZSTDv07_SEARCHLENGTH_MIN
value|3
end_define

begin_define
define|#
directive|define
name|ZSTDv07_TARGETLENGTH_MIN
value|4
end_define

begin_define
define|#
directive|define
name|ZSTDv07_TARGETLENGTH_MAX
value|999
end_define

begin_define
define|#
directive|define
name|ZSTDv07_FRAMEHEADERSIZE_MAX
value|18
end_define

begin_comment
comment|/* for static allocation */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTDv07_frameHeaderSize_min
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTDv07_frameHeaderSize_max
init|=
name|ZSTDv07_FRAMEHEADERSIZE_MAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTDv07_skippableHeaderSize
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* magic number + skippable frame length */
end_comment

begin_comment
comment|/* custom memory allocation functions */
end_comment

begin_typedef
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|ZSTDv07_allocFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ZSTDv07_freeFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|ZSTDv07_allocFunction
name|customAlloc
decl_stmt|;
name|ZSTDv07_freeFunction
name|customFree
decl_stmt|;
name|void
modifier|*
name|opaque
decl_stmt|;
block|}
name|ZSTDv07_customMem
typedef|;
end_typedef

begin_comment
comment|/*--- Advanced Decompression functions ---*/
end_comment

begin_comment
comment|/*! ZSTDv07_estimateDCtxSize() :  *  Gives the potential amount of memory allocated to create a ZSTDv07_DCtx */
end_comment

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_estimateDCtxSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*! ZSTDv07_createDCtx_advanced() :  *  Create a ZSTD decompression context using external alloc and free functions */
end_comment

begin_function_decl
name|ZSTDLIBv07_API
name|ZSTDv07_DCtx
modifier|*
name|ZSTDv07_createDCtx_advanced
parameter_list|(
name|ZSTDv07_customMem
name|customMem
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*! ZSTDv07_sizeofDCtx() :  *  Gives the amount of memory used by a given ZSTDv07_DCtx */
end_comment

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_sizeofDCtx
parameter_list|(
specifier|const
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ****************************************************************** *  Buffer-less streaming functions (synchronous mode) ********************************************************************/
end_comment

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_decompressBegin
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_decompressBegin_usingDict
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ZSTDLIBv07_API
name|void
name|ZSTDv07_copyDCtx
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|ZSTDv07_DCtx
modifier|*
name|preparedDCtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_nextSrcSizeToDecompress
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_decompressContinue
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   Buffer-less streaming decompression (synchronous mode)    A ZSTDv07_DCtx object is required to track streaming operations.   Use ZSTDv07_createDCtx() / ZSTDv07_freeDCtx() to manage it.   A ZSTDv07_DCtx object can be re-used multiple times.    First optional operation is to retrieve frame parameters, using ZSTDv07_getFrameParams(), which doesn't consume the input.   It can provide the minimum size of rolling buffer required to properly decompress data (`windowSize`),   and optionally the final size of uncompressed content.   (Note : content size is an optional info that may not be present. 0 means : content size unknown)   Frame parameters are extracted from the beginning of compressed frame.   The amount of data to read is variable, from ZSTDv07_frameHeaderSize_min to ZSTDv07_frameHeaderSize_max (so if `srcSize`>= ZSTDv07_frameHeaderSize_max, it will always work)   If `srcSize` is too small for operation to succeed, function will return the minimum size it requires to produce a result.   Result : 0 when successful, it means the ZSTDv07_frameParams structure has been filled.>0 : means there is not enough data into `src`. Provides the expected size to successfully decode header.            errorCode, which can be tested using ZSTDv07_isError()    Start decompression, with ZSTDv07_decompressBegin() or ZSTDv07_decompressBegin_usingDict().   Alternatively, you can copy a prepared context, using ZSTDv07_copyDCtx().    Then use ZSTDv07_nextSrcSizeToDecompress() and ZSTDv07_decompressContinue() alternatively.   ZSTDv07_nextSrcSizeToDecompress() tells how much bytes to provide as 'srcSize' to ZSTDv07_decompressContinue().   ZSTDv07_decompressContinue() requires this exact amount of bytes, or it will fail.    @result of ZSTDv07_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily<= dstCapacity).   It can be zero, which is not an error; it just means ZSTDv07_decompressContinue() has decoded some header.    ZSTDv07_decompressContinue() needs previous data blocks during decompression, up to `windowSize`.   They should preferably be located contiguously, prior to current block.   Alternatively, a round buffer of sufficient size is also possible. Sufficient size is determined by frame parameters.   ZSTDv07_decompressContinue() is very sensitive to contiguity,   if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,     or that previous contiguous segment is large enough to properly handle maximum back-reference.    A frame is fully decoded when ZSTDv07_nextSrcSizeToDecompress() returns zero.   Context can then be reset to start a new decompression.     == Special case : skippable frames ==    Skippable frames allow the integration of user-defined data into a flow of concatenated frames.   Skippable frames will be ignored (skipped) by a decompressor. The format of skippable frame is following:   a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F   b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits   c) Frame Content - any content (User Data) of length equal to Frame Size   For skippable frames ZSTDv07_decompressContinue() always returns 0.   For skippable frames ZSTDv07_getFrameParams() returns fparamsPtr->windowLog==0 what means that a frame is skippable.   It also returns Frame Size as fparamsPtr->frameContentSize. */
end_comment

begin_comment
comment|/* ************************************** *  Block functions ****************************************/
end_comment

begin_comment
comment|/*! Block functions produce and decode raw zstd blocks, without frame metadata.     Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes).     User will have to take in charge required information to regenerate data, such as compressed and content sizes.      A few rules to respect :     - Compressing and decompressing require a context structure       + Use ZSTDv07_createCCtx() and ZSTDv07_createDCtx()     - It is necessary to init context before starting       + compression : ZSTDv07_compressBegin()       + decompression : ZSTDv07_decompressBegin()       + variants _usingDict() are also allowed       + copyCCtx() and copyDCtx() work too     - Block size is limited, it must be<= ZSTDv07_getBlockSizeMax()       + If you need to compress more, cut data into multiple blocks       + Consider using the regular ZSTDv07_compress() instead, as frame metadata costs become negligible when source size is large.     - When a block is considered not compressible enough, ZSTDv07_compressBlock() result will be zero.       In which case, nothing is produced into `dst`.       + User must test for such outcome and deal directly with uncompressed data       + ZSTDv07_decompressBlock() doesn't accept uncompressed data as input !!!       + In case of multiple successive blocks, decoder must be informed of uncompressed block existence to follow proper history.         Use ZSTDv07_insertBlock() in such a case. */
end_comment

begin_define
define|#
directive|define
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
value|(128 * 1024)
end_define

begin_comment
comment|/* define, for static allocation */
end_comment

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_decompressBlock
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_insertBlock
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|blockStart
parameter_list|,
name|size_t
name|blockSize
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**< insert block into `dctx` history. Useful for uncompressed blocks */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZSTDv07_STATIC_LINKING_ONLY */
end_comment

begin_comment
comment|/* ******************************************************************    mem.h    low-level memory access routines    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|MEM_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*-**************************************** *  Compiler specifics ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
include|#
directive|include
file|<stdlib.h>
comment|/* _byteswap_ulong */
include|#
directive|include
file|<intrin.h>
comment|/* _byteswap_* */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|MEM_STATIC
value|static __attribute__((unused))
elif|#
directive|elif
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
define|#
directive|define
name|MEM_STATIC
value|static inline
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|MEM_STATIC
value|static __inline
else|#
directive|else
define|#
directive|define
name|MEM_STATIC
value|static
comment|/* this version may generate warnings for unused static functions; disable the relevant warning */
endif|#
directive|endif
comment|/*-************************************************************** *  Basic Types *****************************************************************/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__VMS
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
operator|)
include|#
directive|include
file|<stdint.h>
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
typedef|typedef
name|uint16_t
name|U16
typedef|;
typedef|typedef
name|int16_t
name|S16
typedef|;
typedef|typedef
name|uint32_t
name|U32
typedef|;
typedef|typedef
name|int32_t
name|S32
typedef|;
typedef|typedef
name|uint64_t
name|U64
typedef|;
typedef|typedef
name|int64_t
name|S64
typedef|;
else|#
directive|else
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
typedef|typedef
name|signed
name|short
name|S16
typedef|;
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
typedef|typedef
name|signed
name|int
name|S32
typedef|;
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
typedef|typedef
name|signed
name|long
name|long
name|S64
typedef|;
endif|#
directive|endif
comment|/*-************************************************************** *  Memory I/O *****************************************************************/
comment|/* MEM_FORCE_MEMORY_ACCESS :  * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.  * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.  * The below switch allow to select different access method for improved performance.  * Method 0 (default) : use `memcpy()`. Safe and portable.  * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).  *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.  * Method 2 : direct access. This method is portable but violate C standard.  *            It can generate buggy code on targets depending on alignment.  *            In some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)  * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.  * Prefer these methods in priority order (0> 1> 2)  */
ifndef|#
directive|ifndef
name|MEM_FORCE_MEMORY_ACCESS
comment|/* can be defined externally, on command line for example */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_6__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6J__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6K__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6Z__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6ZK__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6T2__
argument_list|)
operator|)
define|#
directive|define
name|MEM_FORCE_MEMORY_ACCESS
value|2
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_7__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7A__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7R__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7M__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7S__
argument_list|)
operator|)
operator|)
define|#
directive|define
name|MEM_FORCE_MEMORY_ACCESS
value|1
endif|#
directive|endif
endif|#
directive|endif
name|MEM_STATIC
name|unsigned
name|MEM_32bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
return|;
block|}
name|MEM_STATIC
name|unsigned
name|MEM_64bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|8
return|;
block|}
name|MEM_STATIC
name|unsigned
name|MEM_isLittleEndian
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
union|union
block|{
name|U32
name|u
decl_stmt|;
name|BYTE
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|one
init|=
block|{
literal|1
block|}
union|;
comment|/* don't use static : performance detrimental  */
return|return
name|one
operator|.
name|c
index|[
literal|0
index|]
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|MEM_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|MEM_FORCE_MEMORY_ACCESS
operator|==
literal|2
operator|)
comment|/* violates C standard, by lying on structure alignment. Only use if no other choice to achieve best performance on target platform */
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U16
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
operator|*
operator|(
name|U16
operator|*
operator|)
name|memPtr
operator|=
name|value
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|MEM_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|MEM_FORCE_MEMORY_ACCESS
operator|==
literal|1
operator|)
comment|/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
comment|/* currently only defined for gcc and icc */
typedef|typedef
union|union
block|{
name|U16
name|u16
decl_stmt|;
name|U32
name|u32
decl_stmt|;
name|U64
name|u64
decl_stmt|;
name|size_t
name|st
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|unalign
typedef|;
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u16
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u32
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u64
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
operator|(
operator|(
name|unalign
operator|*
operator|)
name|memPtr
operator|)
operator|->
name|u16
operator|=
name|value
expr_stmt|;
block|}
else|#
directive|else
comment|/* default method, safe and standard.    can sometimes prove slower */
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U16
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U32
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U64
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
name|memcpy
argument_list|(
name|memPtr
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MEM_FORCE_MEMORY_ACCESS */
name|MEM_STATIC
name|U32
name|MEM_swap32
parameter_list|(
name|U32
name|in
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
return|return
name|_byteswap_ulong
argument_list|(
name|in
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
return|return
name|__builtin_bswap32
argument_list|(
name|in
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|in
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
endif|#
directive|endif
block|}
name|MEM_STATIC
name|U64
name|MEM_swap64
parameter_list|(
name|U64
name|in
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
return|return
name|_byteswap_uint64
argument_list|(
name|in
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
return|return
name|__builtin_bswap64
argument_list|(
name|in
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|in
operator|<<
literal|56
operator|)
operator|&
literal|0xff00000000000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|40
operator|)
operator|&
literal|0x00ff000000000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|24
operator|)
operator|&
literal|0x0000ff0000000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|8
operator|)
operator|&
literal|0x000000ff00000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|8
operator|)
operator|&
literal|0x00000000ff000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|24
operator|)
operator|&
literal|0x0000000000ff0000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|40
operator|)
operator|&
literal|0x000000000000ff00ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|56
operator|)
operator|&
literal|0x00000000000000ffULL
operator|)
return|;
endif|#
directive|endif
block|}
comment|/*=== Little endian r/w ===*/
name|MEM_STATIC
name|U16
name|MEM_readLE16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read16
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U16
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
block|}
name|MEM_STATIC
name|void
name|MEM_writeLE16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|val
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
block|{
name|MEM_write16
argument_list|(
name|memPtr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BYTE
modifier|*
name|p
init|=
operator|(
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|val
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|MEM_STATIC
name|U32
name|MEM_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
name|MEM_swap32
argument_list|(
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
argument_list|)
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_readLE64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
name|MEM_swap64
argument_list|(
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
argument_list|)
return|;
block|}
name|MEM_STATIC
name|size_t
name|MEM_readLEST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
return|return
operator|(
name|size_t
operator|)
name|MEM_readLE32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
operator|(
name|size_t
operator|)
name|MEM_readLE64
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MEM_H_MODULE */
end_comment

begin_comment
comment|/* ******************************************************************    bitstream    Part of FSE library    header file (to include)    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITSTREAM_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|BITSTREAM_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* *  This API consists of small unitary functions, which must be inlined for best performance. *  Since link-time-optimization is not available for all compilers, *  these functions are defined into a .h to be included. */
comment|/*========================================= *  Target specific =========================================*/
if|#
directive|if
name|defined
argument_list|(
name|__BMI__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
include|#
directive|include
file|<immintrin.h>
comment|/* support for bextr (experimental) */
endif|#
directive|endif
comment|/*-******************************************** *  bitStream decoding API (read backward) **********************************************/
typedef|typedef
struct|struct
block|{
name|size_t
name|bitContainer
decl_stmt|;
name|unsigned
name|bitsConsumed
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
block|}
name|BITv07_DStream_t
typedef|;
typedef|typedef
enum|enum
block|{
name|BITv07_DStream_unfinished
init|=
literal|0
block|,
name|BITv07_DStream_endOfBuffer
init|=
literal|1
block|,
name|BITv07_DStream_completed
init|=
literal|2
block|,
name|BITv07_DStream_overflow
init|=
literal|3
block|}
name|BITv07_DStream_status
typedef|;
comment|/* result of BITv07_reloadDStream() */
comment|/* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( */
name|MEM_STATIC
name|size_t
name|BITv07_initDStream
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|MEM_STATIC
name|size_t
name|BITv07_readBits
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
name|MEM_STATIC
name|BITv07_DStream_status
name|BITv07_reloadDStream
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
name|MEM_STATIC
name|unsigned
name|BITv07_endOfDStream
parameter_list|(
specifier|const
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/* Start by invoking BITv07_initDStream(). *  A chunk of the bitStream is then stored into a local register. *  Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t). *  You can then retrieve bitFields stored into the local register, **in reverse order**. *  Local register is explicitly reloaded from memory by the BITv07_reloadDStream() method. *  A reload guarantee a minimum of ((8*sizeof(bitD->bitContainer))-7) bits when its result is BITv07_DStream_unfinished. *  Otherwise, it can be less than that, so proceed accordingly. *  Checking if DStream has reached its end can be performed with BITv07_endOfDStream(). */
comment|/*-**************************************** *  unsafe API ******************************************/
name|MEM_STATIC
name|size_t
name|BITv07_readBitsFast
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/* faster, but works only if nbBits>= 1 */
comment|/*-************************************************************** *  Internal functions ****************************************************************/
name|MEM_STATIC
name|unsigned
name|BITv07_highbit32
parameter_list|(
specifier|register
name|U32
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual */
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
comment|/* Use GCC Intrinsic */
return|return
literal|31
operator|-
name|__builtin_clz
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
comment|/* Software version */
specifier|static
specifier|const
name|unsigned
name|DeBruijnClz
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|21
block|,
literal|2
block|,
literal|29
block|,
literal|11
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|30
block|,
literal|8
block|,
literal|12
block|,
literal|20
block|,
literal|28
block|,
literal|15
block|,
literal|17
block|,
literal|24
block|,
literal|7
block|,
literal|19
block|,
literal|27
block|,
literal|23
block|,
literal|6
block|,
literal|26
block|,
literal|5
block|,
literal|4
block|,
literal|31
block|}
decl_stmt|;
name|U32
name|v
init|=
name|val
decl_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
return|return
name|DeBruijnClz
index|[
call|(
name|U32
call|)
argument_list|(
name|v
operator|*
literal|0x07C4ACDDU
argument_list|)
operator|>>
literal|27
index|]
return|;
endif|#
directive|endif
block|}
comment|/*-******************************************************** * bitStream decoding **********************************************************/
comment|/*! BITv07_initDStream() : *   Initialize a BITv07_DStream_t. *   `bitD` : a pointer to an already allocated BITv07_DStream_t structure. *   `srcSize` must be the *exact* size of the bitStream, in bytes. *   @return : size of stream (== srcSize) or an errorCode if a problem is detected */
name|MEM_STATIC
name|size_t
name|BITv07_initDStream
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bitD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bitD
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|}
if|if
condition|(
name|srcSize
operator|>=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
condition|)
block|{
comment|/* normal case */
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|srcSize
operator|-
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|{
name|BYTE
specifier|const
name|lastByte
init|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
decl_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|=
name|lastByte
condition|?
literal|8
operator|-
name|BITv07_highbit32
argument_list|(
name|lastByte
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|lastByte
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* endMark not present */
block|}
block|}
else|else
block|{
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|ptr
operator|=
name|bitD
operator|->
name|start
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
expr_stmt|;
switch|switch
condition|(
name|srcSize
condition|)
block|{
case|case
literal|7
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|6
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|16
operator|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|6
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|5
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|24
operator|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|5
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|4
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|32
operator|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|4
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|24
expr_stmt|;
comment|/* fall-through */
case|case
literal|3
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* fall-through */
case|case
literal|2
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
comment|/* fall-through */
default|default:
break|break;
block|}
block|{
name|BYTE
specifier|const
name|lastByte
init|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
decl_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|=
name|lastByte
condition|?
literal|8
operator|-
name|BITv07_highbit32
argument_list|(
name|lastByte
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|lastByte
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* endMark not present */
block|}
name|bitD
operator|->
name|bitsConsumed
operator|+=
call|(
name|U32
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|-
name|srcSize
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
return|return
name|srcSize
return|;
block|}
comment|/*! BITv07_lookBits() :  *  Provides next n bits from local register.  *  local register is not modified.  *  On 32-bits, maxNbBits==24.  *  On 64-bits, maxNbBits==56.  *  @return : value extracted  */
name|MEM_STATIC
name|size_t
name|BITv07_lookBits
parameter_list|(
specifier|const
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|U32
specifier|const
name|bitMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|bitMask
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|>>
operator|(
operator|(
name|bitMask
operator|-
name|nbBits
operator|)
operator|&
name|bitMask
operator|)
return|;
block|}
comment|/*! BITv07_lookBitsFast() : *   unsafe version; only works only if nbBits>= 1 */
name|MEM_STATIC
name|size_t
name|BITv07_lookBitsFast
parameter_list|(
specifier|const
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|U32
specifier|const
name|bitMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|bitMask
operator|)
operator|)
operator|>>
operator|(
operator|(
operator|(
name|bitMask
operator|+
literal|1
operator|)
operator|-
name|nbBits
operator|)
operator|&
name|bitMask
operator|)
return|;
block|}
name|MEM_STATIC
name|void
name|BITv07_skipBits
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|bitD
operator|->
name|bitsConsumed
operator|+=
name|nbBits
expr_stmt|;
block|}
comment|/*! BITv07_readBits() :  *  Read (consume) next n bits from local register and update.  *  Pay attention to not read more than nbBits contained into local register.  *  @return : extracted value.  */
name|MEM_STATIC
name|size_t
name|BITv07_readBits
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
specifier|const
name|value
init|=
name|BITv07_lookBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|BITv07_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/*! BITv07_readBitsFast() : *   unsafe version; only works only if nbBits>= 1 */
name|MEM_STATIC
name|size_t
name|BITv07_readBitsFast
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
specifier|const
name|value
init|=
name|BITv07_lookBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|BITv07_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/*! BITv07_reloadDStream() : *   Refill `BITv07_DStream_t` from src buffer previously defined (see BITv07_initDStream() ). *   This function is safe, it guarantees it will not read beyond src buffer. *   @return : status of `BITv07_DStream_t` internal register.               if status == unfinished, internal register is filled with>= (sizeof(bitD->bitContainer)*8 - 7) bits */
name|MEM_STATIC
name|BITv07_DStream_status
name|BITv07_reloadDStream
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
comment|/* should not happen => corruption detected */
return|return
name|BITv07_DStream_overflow
return|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|>=
name|bitD
operator|->
name|start
operator|+
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
condition|)
block|{
name|bitD
operator|->
name|ptr
operator|-=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|&=
literal|7
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
return|return
name|BITv07_DStream_unfinished
return|;
block|}
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|==
name|bitD
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|<
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
return|return
name|BITv07_DStream_endOfBuffer
return|;
return|return
name|BITv07_DStream_completed
return|;
block|}
block|{
name|U32
name|nbBytes
init|=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
decl_stmt|;
name|BITv07_DStream_status
name|result
init|=
name|BITv07_DStream_unfinished
decl_stmt|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|-
name|nbBytes
operator|<
name|bitD
operator|->
name|start
condition|)
block|{
name|nbBytes
operator|=
call|(
name|U32
call|)
argument_list|(
name|bitD
operator|->
name|ptr
operator|-
name|bitD
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* ptr> start */
name|result
operator|=
name|BITv07_DStream_endOfBuffer
expr_stmt|;
block|}
name|bitD
operator|->
name|ptr
operator|-=
name|nbBytes
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|-=
name|nbBytes
operator|*
literal|8
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
comment|/* reminder : srcSize> sizeof(bitD) */
return|return
name|result
return|;
block|}
block|}
comment|/*! BITv07_endOfDStream() : *   @return Tells if DStream has exactly reached its end (all bits consumed). */
name|MEM_STATIC
name|unsigned
name|BITv07_endOfDStream
parameter_list|(
specifier|const
name|BITv07_DStream_t
modifier|*
name|DStream
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DStream
operator|->
name|ptr
operator|==
name|DStream
operator|->
name|start
operator|)
operator|&&
operator|(
name|DStream
operator|->
name|bitsConsumed
operator|==
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BITSTREAM_H_MODULE */
end_comment

begin_comment
comment|/* ******************************************************************    FSE : Finite State Entropy codec    Public Prototypes declaration    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSEv07_H
end_ifndef

begin_define
define|#
directive|define
name|FSEv07_H
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*-**************************************** *  FSE simple functions ******************************************/
comment|/*! FSEv07_decompress():     Decompress FSE data from buffer 'cSrc', of size 'cSrcSize',     into already allocated destination buffer 'dst', of size 'dstCapacity'.     @return : size of regenerated data (<= maxDstSize),               or an error code, which can be tested using FSEv07_isError() .      ** Important ** : FSEv07_decompress() does not decompress non-compressible nor RLE data !!!     Why ? : making this distinction requires a header.     Header management is intentionally delegated to the user layer, which can better manage special cases. */
name|size_t
name|FSEv07_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* Error Management */
name|unsigned
name|FSEv07_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* tells if a return value is an error code */
specifier|const
name|char
modifier|*
name|FSEv07_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* provides error code string (useful for debugging) */
comment|/*-***************************************** *  FSE detailed API ******************************************/
comment|/*! FSEv07_decompress() does the following: 1. read normalized counters with readNCount() 2. build decoding table 'DTable' from normalized counters 3. decode the data stream using decoding table 'DTable'  The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and provide normalized distribution using external method. */
comment|/* *** DECOMPRESSION *** */
comment|/*! FSEv07_readNCount():     Read compactly saved 'normalizedCounter' from 'rBuffer'.     @return : size read from 'rBuffer',               or an errorCode, which can be tested using FSEv07_isError().               maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values */
name|size_t
name|FSEv07_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|rBuffer
parameter_list|,
name|size_t
name|rBuffSize
parameter_list|)
function_decl|;
comment|/*! Constructor and Destructor of FSEv07_DTable.     Note that its size depends on 'tableLog' */
typedef|typedef
name|unsigned
name|FSEv07_DTable
typedef|;
comment|/* don't allocate that. It's just a way to be more restrictive than void* */
name|FSEv07_DTable
modifier|*
name|FSEv07_createDTable
parameter_list|(
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
name|void
name|FSEv07_freeDTable
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
comment|/*! FSEv07_buildDTable():     Builds 'dt', which must be already allocated, using FSEv07_createDTable().     return : 0, or an errorCode, which can be tested using FSEv07_isError() */
name|size_t
name|FSEv07_buildDTable
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*! FSEv07_decompress_usingDTable():     Decompress compressed source `cSrc` of size `cSrcSize` using `dt`     into `dst` which must be already allocated.     @return : size of regenerated data (necessarily<= `dstCapacity`),               or an errorCode, which can be tested using FSEv07_isError() */
name|size_t
name|FSEv07_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
comment|/*! Tutorial : ---------- (Note : these functions only decompress FSE-compressed blocks.  If block is uncompressed, use memcpy() instead  If block is a single repeated byte, use memset() instead )  The first step is to obtain the normalized frequencies of symbols. This can be performed by FSEv07_readNCount() if it was saved using FSEv07_writeNCount(). 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short. In practice, that means it's necessary to know 'maxSymbolValue' beforehand, or size the table to handle worst case situations (typically 256). FSEv07_readNCount() will provide 'tableLog' and 'maxSymbolValue'. The result of FSEv07_readNCount() is the number of bytes read from 'rBuffer'. Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that. If there is an error, the function will return an error code, which can be tested using FSEv07_isError().  The next step is to build the decompression tables 'FSEv07_DTable' from 'normalizedCounter'. This is performed by the function FSEv07_buildDTable(). The space required by 'FSEv07_DTable' must be already allocated using FSEv07_createDTable(). If there is an error, the function will return an error code, which can be tested using FSEv07_isError().  `FSEv07_DTable` can then be used to decompress `cSrc`, with FSEv07_decompress_usingDTable(). `cSrcSize` must be strictly correct, otherwise decompression will fail. FSEv07_decompress_usingDTable() result will tell how many bytes were regenerated (<=`dstCapacity`). If there is an error, the function will return an error code, which can be tested using FSEv07_isError(). (ex: dst buffer too small) */
ifdef|#
directive|ifdef
name|FSEv07_STATIC_LINKING_ONLY
comment|/* ***************************************** *  Static allocation *******************************************/
comment|/* FSE buffer bounds */
define|#
directive|define
name|FSEv07_NCOUNTBOUND
value|512
define|#
directive|define
name|FSEv07_BLOCKBOUND
parameter_list|(
name|size
parameter_list|)
value|(size + (size>>7))
comment|/* It is possible to statically allocate FSE CTable/DTable as a table of unsigned using below macros */
define|#
directive|define
name|FSEv07_DTABLE_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<maxTableLog))
comment|/* ***************************************** *  FSE advanced API *******************************************/
name|size_t
name|FSEv07_countFast
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/**< same as FSEv07_count(), but blindly trusts that all byte values within src are<= *maxSymbolValuePtr  */
name|unsigned
name|FSEv07_optimalTableLog_internal
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|minus
parameter_list|)
function_decl|;
comment|/**< same as FSEv07_optimalTableLog(), which used `minus==2` */
name|size_t
name|FSEv07_buildDTable_raw
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/**< build a fake FSEv07_DTable, designed to read an uncompressed bitstream where each symbol uses nbBits */
name|size_t
name|FSEv07_buildDTable_rle
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|char
name|symbolValue
parameter_list|)
function_decl|;
comment|/**< build a fake FSEv07_DTable, designed to always generate the same symbolValue */
comment|/* ***************************************** *  FSE symbol decompression API *******************************************/
typedef|typedef
struct|struct
block|{
name|size_t
name|state
decl_stmt|;
specifier|const
name|void
modifier|*
name|table
decl_stmt|;
comment|/* precise table may vary, depending on U16 */
block|}
name|FSEv07_DState_t
typedef|;
specifier|static
name|void
name|FSEv07_initDState
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
specifier|static
name|unsigned
name|char
name|FSEv07_decodeSymbol
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/**< Let's now decompose FSEv07_decompress_usingDTable() into its unitary components. You will decode FSE-encoded symbols from the bitStream, and also any other bitFields you put in, **in reverse order**.  You will need a few variables to track your bitStream. They are :  BITv07_DStream_t DStream;    // Stream context FSEv07_DState_t  DState;     // State context. Multiple ones are possible FSEv07_DTable*   DTablePtr;  // Decoding table, provided by FSEv07_buildDTable()  The first thing to do is to init the bitStream.     errorCode = BITv07_initDStream(&DStream, srcBuffer, srcSize);  You should then retrieve your initial state(s) (in reverse flushing order if you have several ones) :     errorCode = FSEv07_initDState(&DState,&DStream, DTablePtr);  You can then decode your data, symbol after symbol. For information the maximum number of bits read by FSEv07_decodeSymbol() is 'tableLog'. Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).     unsigned char symbol = FSEv07_decodeSymbol(&DState,&DStream);  You can retrieve any bitfield you eventually stored into the bitStream (in reverse order) Note : maximum allowed nbBits is 25, for 32-bits compatibility     size_t bitField = BITv07_readBits(&DStream, nbBits);  All above operations only read from local register (which size depends on size_t). Refueling the register from memory is manually performed by the reload method.     endSignal = FSEv07_reloadDStream(&DStream);  BITv07_reloadDStream() result tells if there is still some more data to read from DStream. BITv07_DStream_unfinished : there is still some data left into the DStream. BITv07_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled. BITv07_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed. BITv07_DStream_tooFar : Dstream went too far. Decompression result is corrupted.  When reaching end of buffer (BITv07_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop, to properly detect the exact end of stream. After each decoded symbol, check if DStream is fully consumed using this simple test :     BITv07_reloadDStream(&DStream)>= BITv07_DStream_completed  When it's done, verify decompression is fully completed, by checking both DStream and the relevant states. Checking if DStream has reached its end is performed by :     BITv07_endOfDStream(&DStream); Check also the states. There might be some symbols left there, if some high probability ones (>50%) are possible.     FSEv07_endOfDState(&DState); */
comment|/* ***************************************** *  FSE unsafe API *******************************************/
specifier|static
name|unsigned
name|char
name|FSEv07_decodeSymbolFast
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/* faster, but works only if nbBits is always>= 1 (otherwise, result will be corrupted) */
comment|/* ======    Decompression    ====== */
typedef|typedef
struct|struct
block|{
name|U16
name|tableLog
decl_stmt|;
name|U16
name|fastMode
decl_stmt|;
block|}
name|FSEv07_DTableHeader
typedef|;
comment|/* sizeof U32 */
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|newState
decl_stmt|;
name|unsigned
name|char
name|symbol
decl_stmt|;
name|unsigned
name|char
name|nbBits
decl_stmt|;
block|}
name|FSEv07_decode_t
typedef|;
comment|/* size == U32 */
name|MEM_STATIC
name|void
name|FSEv07_initDState
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
specifier|const
name|FSEv07_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
specifier|const
name|FSEv07_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|BITv07_readBits
argument_list|(
name|bitD
argument_list|,
name|DTableH
operator|->
name|tableLog
argument_list|)
expr_stmt|;
name|BITv07_reloadDStream
argument_list|(
name|bitD
argument_list|)
expr_stmt|;
name|DStatePtr
operator|->
name|table
operator|=
name|dt
operator|+
literal|1
expr_stmt|;
block|}
name|MEM_STATIC
name|BYTE
name|FSEv07_peekSymbol
parameter_list|(
specifier|const
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|)
block|{
name|FSEv07_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSEv07_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
return|return
name|DInfo
operator|.
name|symbol
return|;
block|}
name|MEM_STATIC
name|void
name|FSEv07_updateState
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
name|FSEv07_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSEv07_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|size_t
specifier|const
name|lowBits
init|=
name|BITv07_readBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
block|}
name|MEM_STATIC
name|BYTE
name|FSEv07_decodeSymbol
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
name|FSEv07_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSEv07_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
specifier|const
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
specifier|const
name|lowBits
init|=
name|BITv07_readBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
comment|/*! FSEv07_decodeSymbolFast() :     unsafe, only works if no symbol has a probability> 50% */
name|MEM_STATIC
name|BYTE
name|FSEv07_decodeSymbolFast
parameter_list|(
name|FSEv07_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
name|FSEv07_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSEv07_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
specifier|const
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
specifier|const
name|lowBits
init|=
name|BITv07_readBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
ifndef|#
directive|ifndef
name|FSEv07_COMMONDEFS_ONLY
comment|/* ************************************************************** *  Tuning parameters ****************************************************************/
comment|/*!MEMORY_USAGE : *  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.) *  Increasing memory usage improves compression ratio *  Reduced memory usage can improve speed, due to cache effect *  Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */
define|#
directive|define
name|FSEv07_MAX_MEMORY_USAGE
value|14
define|#
directive|define
name|FSEv07_DEFAULT_MEMORY_USAGE
value|13
comment|/*!FSEv07_MAX_SYMBOL_VALUE : *  Maximum symbol value authorized. *  Required for proper stack allocation */
define|#
directive|define
name|FSEv07_MAX_SYMBOL_VALUE
value|255
comment|/* ************************************************************** *  template functions type& suffix ****************************************************************/
define|#
directive|define
name|FSEv07_FUNCTION_TYPE
value|BYTE
define|#
directive|define
name|FSEv07_FUNCTION_EXTENSION
define|#
directive|define
name|FSEv07_DECODE_TYPE
value|FSEv07_decode_t
endif|#
directive|endif
comment|/* !FSEv07_COMMONDEFS_ONLY */
comment|/* *************************************************************** *  Constants *****************************************************************/
define|#
directive|define
name|FSEv07_MAX_TABLELOG
value|(FSEv07_MAX_MEMORY_USAGE-2)
define|#
directive|define
name|FSEv07_MAX_TABLESIZE
value|(1U<<FSEv07_MAX_TABLELOG)
define|#
directive|define
name|FSEv07_MAXTABLESIZE_MASK
value|(FSEv07_MAX_TABLESIZE-1)
define|#
directive|define
name|FSEv07_DEFAULT_TABLELOG
value|(FSEv07_DEFAULT_MEMORY_USAGE-2)
define|#
directive|define
name|FSEv07_MIN_TABLELOG
value|5
define|#
directive|define
name|FSEv07_TABLELOG_ABSOLUTE_MAX
value|15
if|#
directive|if
name|FSEv07_MAX_TABLELOG
operator|>
name|FSEv07_TABLELOG_ABSOLUTE_MAX
error|#
directive|error
literal|"FSEv07_MAX_TABLELOG> FSEv07_TABLELOG_ABSOLUTE_MAX is not supported"
endif|#
directive|endif
define|#
directive|define
name|FSEv07_TABLESTEP
parameter_list|(
name|tableSize
parameter_list|)
value|((tableSize>>1) + (tableSize>>3) + 3)
endif|#
directive|endif
comment|/* FSEv07_STATIC_LINKING_ONLY */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FSEv07_H */
end_comment

begin_comment
comment|/* ******************************************************************    Huffman coder, part of New Generation Entropy library    header file    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HUFv07_H_298734234
end_ifndef

begin_define
define|#
directive|define
name|HUFv07_H_298734234
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* *** simple functions *** */
comment|/** HUFv07_decompress() :     Decompress HUF data from buffer 'cSrc', of size 'cSrcSize',     into already allocated buffer 'dst', of minimum size 'dstSize'.     `dstSize` : **must** be the ***exact*** size of original (uncompressed) data.     Note : in contrast with FSE, HUFv07_decompress can regenerate            RLE (cSrcSize==1) and uncompressed (cSrcSize==dstSize) data,            because it knows size to regenerate.     @return : size of regenerated data (== dstSize),               or an error code, which can be tested using HUFv07_isError() */
name|size_t
name|HUFv07_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* **************************************** *  Tool functions ******************************************/
define|#
directive|define
name|HUFv07_BLOCKSIZE_MAX
value|(128 * 1024)
comment|/* Error Management */
name|unsigned
name|HUFv07_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/**< tells if a return value is an error code */
specifier|const
name|char
modifier|*
name|HUFv07_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/**< provides error code string (useful for debugging) */
comment|/* *** Advanced function *** */
ifdef|#
directive|ifdef
name|HUFv07_STATIC_LINKING_ONLY
comment|/* *** Constants *** */
define|#
directive|define
name|HUFv07_TABLELOG_ABSOLUTEMAX
value|16
comment|/* absolute limit of HUFv07_MAX_TABLELOG. Beyond that value, code does not work */
define|#
directive|define
name|HUFv07_TABLELOG_MAX
value|12
comment|/* max configured tableLog (for static allocation); can be modified up to HUFv07_ABSOLUTEMAX_TABLELOG */
define|#
directive|define
name|HUFv07_TABLELOG_DEFAULT
value|11
comment|/* tableLog by default, when not specified */
define|#
directive|define
name|HUFv07_SYMBOLVALUE_MAX
value|255
if|#
directive|if
operator|(
name|HUFv07_TABLELOG_MAX
operator|>
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|)
error|#
directive|error
literal|"HUFv07_TABLELOG_MAX is too large !"
endif|#
directive|endif
comment|/* **************************************** *  Static allocation ******************************************/
comment|/* HUF buffer bounds */
define|#
directive|define
name|HUFv07_BLOCKBOUND
parameter_list|(
name|size
parameter_list|)
value|(size + (size>>8) + 8)
comment|/* only true if incompressible pre-filtered with fast heuristic */
comment|/* static allocation of HUF's DTable */
typedef|typedef
name|U32
name|HUFv07_DTable
typedef|;
define|#
directive|define
name|HUFv07_DTABLE_SIZE
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<(maxTableLog)))
define|#
directive|define
name|HUFv07_CREATE_STATIC_DTABLEX2
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|HUFv07_DTable DTable[HUFv07_DTABLE_SIZE((maxTableLog)-1)] = { ((U32)((maxTableLog)-1)*0x1000001) }
define|#
directive|define
name|HUFv07_CREATE_STATIC_DTABLEX4
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|HUFv07_DTable DTable[HUFv07_DTABLE_SIZE(maxTableLog)] = { ((U32)(maxTableLog)*0x1000001) }
comment|/* **************************************** *  Advanced decompression functions ******************************************/
name|size_t
name|HUFv07_decompress4X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< single-symbol decoder */
name|size_t
name|HUFv07_decompress4X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< double-symbols decoder */
name|size_t
name|HUFv07_decompress4X_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< decodes RLE and uncompressed */
name|size_t
name|HUFv07_decompress4X_hufOnly
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< considers RLE and uncompressed as errors */
name|size_t
name|HUFv07_decompress4X2_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< single-symbol decoder */
name|size_t
name|HUFv07_decompress4X4_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< double-symbols decoder */
name|size_t
name|HUFv07_decompress1X_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_decompress1X2_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< single-symbol decoder */
name|size_t
name|HUFv07_decompress1X4_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< double-symbols decoder */
comment|/* **************************************** *  HUF detailed API ******************************************/
comment|/*! The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and regenerate 'CTable' using external methods. */
comment|/* FSEv07_count() : find it within "fse.h" */
comment|/*! HUFv07_readStats() :     Read compact Huffman tree, saved by HUFv07_writeCTable().     `huffWeight` is destination buffer.     @return : size read from `src` , or an error Code .     Note : Needed by HUFv07_readCTable() and HUFv07_readDTableXn() . */
name|size_t
name|HUFv07_readStats
parameter_list|(
name|BYTE
modifier|*
name|huffWeight
parameter_list|,
name|size_t
name|hwSize
parameter_list|,
name|U32
modifier|*
name|rankStats
parameter_list|,
name|U32
modifier|*
name|nbSymbolsPtr
parameter_list|,
name|U32
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/* HUFv07_decompress() does the following: 1. select the decompression algorithm (X2, X4) based on pre-computed heuristics 2. build Huffman table from save, using HUFv07_readDTableXn() 3. decode 1 or 4 segments in parallel using HUFv07_decompressSXn_usingDTable */
comment|/** HUFv07_selectDecoder() : *   Tells which decoder is likely to decode faster, *   based on a set of pre-determined metrics. *   @return : 0==HUFv07_decompress4X2, 1==HUFv07_decompress4X4 . *   Assumption : 0< cSrcSize< dstSize<= 128 KB */
name|U32
name|HUFv07_selectDecoder
parameter_list|(
name|size_t
name|dstSize
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_readDTableX2
parameter_list|(
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_readDTableX4
parameter_list|(
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_decompress4X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_decompress4X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_decompress4X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
comment|/* single stream variants */
name|size_t
name|HUFv07_decompress1X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* single-symbol decoder */
name|size_t
name|HUFv07_decompress1X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* double-symbol decoder */
name|size_t
name|HUFv07_decompress1X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_decompress1X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUFv07_decompress1X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* HUFv07_STATIC_LINKING_ONLY */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HUFv07_H_298734234 */
end_comment

begin_comment
comment|/*    Common functions of New Generation Entropy library    Copyright (C) 2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c *************************************************************************** */
end_comment

begin_comment
comment|/*-**************************************** *  FSE Error Management ******************************************/
end_comment

begin_function
name|unsigned
name|FSEv07_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|FSEv07_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************** *  HUF Error Management ****************************************************************/
end_comment

begin_function
name|unsigned
name|HUFv07_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|HUFv07_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-************************************************************** *  FSE NCount encoding-decoding ****************************************************************/
end_comment

begin_function
specifier|static
name|short
name|FSEv07_abs
parameter_list|(
name|short
name|a
parameter_list|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|a
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSEv07_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSVPtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|headerBuffer
parameter_list|,
name|size_t
name|hbSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|headerBuffer
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|hbSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|int
name|nbBits
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|U32
name|bitStream
decl_stmt|;
name|int
name|bitCount
decl_stmt|;
name|unsigned
name|charnum
init|=
literal|0
decl_stmt|;
name|int
name|previous0
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hbSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|nbBits
operator|=
operator|(
name|bitStream
operator|&
literal|0xF
operator|)
operator|+
name|FSEv07_MIN_TABLELOG
expr_stmt|;
comment|/* extract tableLog */
if|if
condition|(
name|nbBits
operator|>
name|FSEv07_TABLELOG_ABSOLUTE_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
name|bitStream
operator|>>=
literal|4
expr_stmt|;
name|bitCount
operator|=
literal|4
expr_stmt|;
operator|*
name|tableLogPtr
operator|=
name|nbBits
expr_stmt|;
name|remaining
operator|=
operator|(
literal|1
operator|<<
name|nbBits
operator|)
operator|+
literal|1
expr_stmt|;
name|threshold
operator|=
literal|1
operator|<<
name|nbBits
expr_stmt|;
name|nbBits
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|remaining
operator|>
literal|1
operator|)
operator|&&
operator|(
name|charnum
operator|<=
operator|*
name|maxSVPtr
operator|)
condition|)
block|{
if|if
condition|(
name|previous0
condition|)
block|{
name|unsigned
name|n0
init|=
name|charnum
decl_stmt|;
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0xFFFF
condition|)
block|{
name|n0
operator|+=
literal|24
expr_stmt|;
if|if
condition|(
name|ip
operator|<
name|iend
operator|-
literal|5
condition|)
block|{
name|ip
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
block|{
name|bitStream
operator|>>=
literal|16
expr_stmt|;
name|bitCount
operator|+=
literal|16
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|n0
operator|+=
literal|3
expr_stmt|;
name|bitStream
operator|>>=
literal|2
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
block|}
name|n0
operator|+=
name|bitStream
operator|&
literal|3
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|n0
operator|>
operator|*
name|maxSVPtr
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooSmall
argument_list|)
return|;
while|while
condition|(
name|charnum
operator|<
name|n0
condition|)
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
name|bitStream
operator|>>=
literal|2
expr_stmt|;
block|}
block|{
name|short
specifier|const
name|max
init|=
call|(
name|short
call|)
argument_list|(
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
operator|-
name|remaining
argument_list|)
decl_stmt|;
name|short
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
operator|)
operator|<
operator|(
name|U32
operator|)
name|max
condition|)
block|{
name|count
operator|=
call|(
name|short
call|)
argument_list|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
call|(
name|short
call|)
argument_list|(
name|bitStream
operator|&
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|threshold
condition|)
name|count
operator|-=
name|max
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* extra accuracy */
name|remaining
operator|-=
name|FSEv07_abs
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
name|count
expr_stmt|;
name|previous0
operator|=
operator|!
name|count
expr_stmt|;
while|while
condition|(
name|remaining
operator|<
name|threshold
condition|)
block|{
name|nbBits
operator|--
expr_stmt|;
name|threshold
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bitCount
operator|-=
call|(
name|int
call|)
argument_list|(
literal|8
operator|*
operator|(
name|iend
operator|-
literal|4
operator|-
name|ip
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|iend
operator|-
literal|4
expr_stmt|;
block|}
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
operator|(
name|bitCount
operator|&
literal|31
operator|)
expr_stmt|;
block|}
block|}
comment|/* while ((remaining>1)&& (charnum<=*maxSVPtr)) */
if|if
condition|(
name|remaining
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
operator|*
name|maxSVPtr
operator|=
name|charnum
operator|-
literal|1
expr_stmt|;
name|ip
operator|+=
operator|(
name|bitCount
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|ip
operator|-
name|istart
argument_list|)
operator|>
name|hbSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
return|return
name|ip
operator|-
name|istart
return|;
block|}
end_function

begin_comment
comment|/*! HUFv07_readStats() :     Read compact Huffman tree, saved by HUFv07_writeCTable().     `huffWeight` is destination buffer.     @return : size read from `src` , or an error Code .     Note : Needed by HUFv07_readCTable() and HUFv07_readDTableXn() . */
end_comment

begin_function
name|size_t
name|HUFv07_readStats
parameter_list|(
name|BYTE
modifier|*
name|huffWeight
parameter_list|,
name|size_t
name|hwSize
parameter_list|,
name|U32
modifier|*
name|rankStats
parameter_list|,
name|U32
modifier|*
name|nbSymbolsPtr
parameter_list|,
name|U32
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|U32
name|weightTotal
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|size_t
name|oSize
decl_stmt|;
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|iSize
operator|=
name|ip
index|[
literal|0
index|]
expr_stmt|;
comment|//memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */
if|if
condition|(
name|iSize
operator|>=
literal|128
condition|)
block|{
comment|/* special header */
if|if
condition|(
name|iSize
operator|>=
operator|(
literal|242
operator|)
condition|)
block|{
comment|/* RLE */
specifier|static
name|U32
name|l
index|[
literal|14
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|31
block|,
literal|32
block|,
literal|63
block|,
literal|64
block|,
literal|127
block|,
literal|128
block|}
decl_stmt|;
name|oSize
operator|=
name|l
index|[
name|iSize
operator|-
literal|242
index|]
expr_stmt|;
name|memset
argument_list|(
name|huffWeight
argument_list|,
literal|1
argument_list|,
name|hwSize
argument_list|)
expr_stmt|;
name|iSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Incompressible */
name|oSize
operator|=
name|iSize
operator|-
literal|127
expr_stmt|;
name|iSize
operator|=
operator|(
operator|(
name|oSize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|oSize
operator|>=
name|hwSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
literal|1
expr_stmt|;
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|+=
literal|2
control|)
block|{
name|huffWeight
index|[
name|n
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|>>
literal|4
expr_stmt|;
name|huffWeight
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|&
literal|15
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* header compressed with FSE (normal case) */
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|oSize
operator|=
name|FSEv07_decompress
argument_list|(
name|huffWeight
argument_list|,
name|hwSize
operator|-
literal|1
argument_list|,
name|ip
operator|+
literal|1
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
comment|/* max (hwSize-1) values decoded, as last one is implied */
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|oSize
argument_list|)
condition|)
return|return
name|oSize
return|;
block|}
comment|/* collect weight stats */
name|memset
argument_list|(
name|rankStats
argument_list|,
literal|0
argument_list|,
operator|(
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|weightTotal
operator|=
literal|0
expr_stmt|;
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|huffWeight
index|[
name|n
index|]
operator|>=
name|HUFv07_TABLELOG_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|rankStats
index|[
name|huffWeight
index|[
name|n
index|]
index|]
operator|++
expr_stmt|;
name|weightTotal
operator|+=
operator|(
literal|1
operator|<<
name|huffWeight
index|[
name|n
index|]
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|weightTotal
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* get last non-null symbol weight (implied, total must be 2^n) */
block|{
name|U32
specifier|const
name|tableLog
init|=
name|BITv07_highbit32
argument_list|(
name|weightTotal
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|tableLog
operator|>
name|HUFv07_TABLELOG_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
operator|*
name|tableLogPtr
operator|=
name|tableLog
expr_stmt|;
comment|/* determine last weight */
block|{
name|U32
specifier|const
name|total
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|U32
specifier|const
name|rest
init|=
name|total
operator|-
name|weightTotal
decl_stmt|;
name|U32
specifier|const
name|verif
init|=
literal|1
operator|<<
name|BITv07_highbit32
argument_list|(
name|rest
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|lastWeight
init|=
name|BITv07_highbit32
argument_list|(
name|rest
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|verif
operator|!=
name|rest
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* last value must be a clean power of 2 */
name|huffWeight
index|[
name|oSize
index|]
operator|=
operator|(
name|BYTE
operator|)
name|lastWeight
expr_stmt|;
name|rankStats
index|[
name|lastWeight
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* check tree construction validity */
if|if
condition|(
operator|(
name|rankStats
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
operator|(
name|rankStats
index|[
literal|1
index|]
operator|&
literal|1
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* by construction : at least 2 elts of rank 1, must be even */
comment|/* results */
operator|*
name|nbSymbolsPtr
operator|=
call|(
name|U32
call|)
argument_list|(
name|oSize
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|iSize
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************    FSE : Finite State Entropy decoder    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
end_define

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_comment
comment|/* For Visual 2005 */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4214
name|)
end_pragma

begin_comment
comment|/* disable: C4214: non-int bitfields */
end_comment

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC_VERSION__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|FSEv07_isError
value|ERR_isError
end_define

begin_define
define|#
directive|define
name|FSEv07_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { FSEv07_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/* ************************************************************** *  Complex types ****************************************************************/
end_comment

begin_typedef
typedef|typedef
name|U32
name|DTable_max_t
index|[
name|FSEv07_DTABLE_SIZE_U32
argument_list|(
name|FSEv07_MAX_TABLELOG
argument_list|)
index|]
typedef|;
end_typedef

begin_comment
comment|/* ************************************************************** *  Templates ****************************************************************/
end_comment

begin_comment
comment|/*   designed to be included   for type-specific functions (template emulation in C)   Objective is to write these functions only once, for improved maintenance */
end_comment

begin_comment
comment|/* safety checks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSEv07_FUNCTION_EXTENSION
end_ifndef

begin_error
error|#
directive|error
literal|"FSEv07_FUNCTION_EXTENSION must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FSEv07_FUNCTION_TYPE
end_ifndef

begin_error
error|#
directive|error
literal|"FSEv07_FUNCTION_TYPE must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function names */
end_comment

begin_define
define|#
directive|define
name|FSEv07_CAT
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|X##Y
end_define

begin_define
define|#
directive|define
name|FSEv07_FUNCTION_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSEv07_CAT(X,Y)
end_define

begin_define
define|#
directive|define
name|FSEv07_TYPE_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSEv07_CAT(X,Y)
end_define

begin_comment
comment|/* Function templates */
end_comment

begin_function
name|FSEv07_DTable
modifier|*
name|FSEv07_createDTable
parameter_list|(
name|unsigned
name|tableLog
parameter_list|)
block|{
if|if
condition|(
name|tableLog
operator|>
name|FSEv07_TABLELOG_ABSOLUTE_MAX
condition|)
name|tableLog
operator|=
name|FSEv07_TABLELOG_ABSOLUTE_MAX
expr_stmt|;
return|return
operator|(
name|FSEv07_DTable
operator|*
operator|)
name|malloc
argument_list|(
name|FSEv07_DTABLE_SIZE_U32
argument_list|(
name|tableLog
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|FSEv07_freeDTable
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|)
block|{
name|free
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|FSEv07_buildDTable
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|void
modifier|*
specifier|const
name|tdPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
comment|/* because *dt is unsigned, 32-bits aligned on 32-bits */
name|FSEv07_DECODE_TYPE
modifier|*
specifier|const
name|tableDecode
init|=
operator|(
name|FSEv07_DECODE_TYPE
operator|*
operator|)
operator|(
name|tdPtr
operator|)
decl_stmt|;
name|U16
name|symbolNext
index|[
name|FSEv07_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
specifier|const
name|maxSV1
init|=
name|maxSymbolValue
operator|+
literal|1
decl_stmt|;
name|U32
specifier|const
name|tableSize
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|U32
name|highThreshold
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
comment|/* Sanity Checks */
if|if
condition|(
name|maxSymbolValue
operator|>
name|FSEv07_MAX_SYMBOL_VALUE
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooLarge
argument_list|)
return|;
if|if
condition|(
name|tableLog
operator|>
name|FSEv07_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* Init, lay down lowprob symbols */
block|{
name|FSEv07_DTableHeader
name|DTableH
decl_stmt|;
name|DTableH
operator|.
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|tableLog
expr_stmt|;
name|DTableH
operator|.
name|fastMode
operator|=
literal|1
expr_stmt|;
block|{
name|S16
specifier|const
name|largeLimit
init|=
call|(
name|S16
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|tableLog
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|maxSV1
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|tableDecode
index|[
name|highThreshold
operator|--
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSEv07_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|>=
name|largeLimit
condition|)
name|DTableH
operator|.
name|fastMode
operator|=
literal|0
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
name|normalizedCounter
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|dt
argument_list|,
operator|&
name|DTableH
argument_list|,
sizeof|sizeof
argument_list|(
name|DTableH
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Spread symbols */
block|{
name|U32
specifier|const
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
name|U32
specifier|const
name|step
init|=
name|FSEv07_TABLESTEP
argument_list|(
name|tableSize
argument_list|)
decl_stmt|;
name|U32
name|s
decl_stmt|,
name|position
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|maxSV1
condition|;
name|s
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|normalizedCounter
index|[
name|s
index|]
condition|;
name|i
operator|++
control|)
block|{
name|tableDecode
index|[
name|position
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSEv07_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
while|while
condition|(
name|position
operator|>
name|highThreshold
condition|)
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
comment|/* lowprob area */
block|}
block|}
if|if
condition|(
name|position
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* position must reach all cells once, otherwise normalizedCounter is incorrect */
block|}
comment|/* Build Decoding table */
block|{
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|tableSize
condition|;
name|u
operator|++
control|)
block|{
name|FSEv07_FUNCTION_TYPE
specifier|const
name|symbol
init|=
call|(
name|FSEv07_FUNCTION_TYPE
call|)
argument_list|(
name|tableDecode
index|[
name|u
index|]
operator|.
name|symbol
argument_list|)
decl_stmt|;
name|U16
name|nextState
init|=
name|symbolNext
index|[
name|symbol
index|]
operator|++
decl_stmt|;
name|tableDecode
index|[
name|u
index|]
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|-
name|BITv07_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|nextState
argument_list|)
argument_list|)
expr_stmt|;
name|tableDecode
index|[
name|u
index|]
operator|.
name|newState
operator|=
call|(
name|U16
call|)
argument_list|(
operator|(
name|nextState
operator|<<
name|tableDecode
index|[
name|u
index|]
operator|.
name|nbBits
operator|)
operator|-
name|tableSize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FSEv07_COMMONDEFS_ONLY
end_ifndef

begin_comment
comment|/*-******************************************************* *  Decompression (Byte symbols) *********************************************************/
end_comment

begin_function
name|size_t
name|FSEv07_buildDTable_rle
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
name|BYTE
name|symbolValue
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSEv07_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSEv07_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|void
modifier|*
name|dPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
name|FSEv07_decode_t
modifier|*
specifier|const
name|cell
init|=
operator|(
name|FSEv07_decode_t
operator|*
operator|)
name|dPtr
decl_stmt|;
name|DTableH
operator|->
name|tableLog
operator|=
literal|0
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|newState
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|symbol
operator|=
name|symbolValue
expr_stmt|;
name|cell
operator|->
name|nbBits
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|FSEv07_buildDTable_raw
parameter_list|(
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSEv07_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSEv07_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|void
modifier|*
name|dPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
name|FSEv07_decode_t
modifier|*
specifier|const
name|dinfo
init|=
operator|(
name|FSEv07_decode_t
operator|*
operator|)
name|dPtr
decl_stmt|;
specifier|const
name|unsigned
name|tableSize
init|=
literal|1
operator|<<
name|nbBits
decl_stmt|;
specifier|const
name|unsigned
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|maxSV1
init|=
name|tableMask
operator|+
literal|1
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nbBits
operator|<
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* min size */
comment|/* Build Decoding Table */
name|DTableH
operator|->
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|nbBits
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|maxSV1
condition|;
name|s
operator|++
control|)
block|{
name|dinfo
index|[
name|s
index|]
operator|.
name|newState
operator|=
literal|0
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|nbBits
operator|=
operator|(
name|BYTE
operator|)
name|nbBits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|size_t
name|FSEv07_decompress_usingDTable_generic
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|unsigned
name|fast
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|omax
init|=
name|op
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|olimit
init|=
name|omax
operator|-
literal|3
decl_stmt|;
name|BITv07_DStream_t
name|bitD
decl_stmt|;
name|FSEv07_DState_t
name|state1
decl_stmt|;
name|FSEv07_DState_t
name|state2
decl_stmt|;
comment|/* Init */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
comment|/* replaced last arg by maxCompressed Size */
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
name|FSEv07_initDState
argument_list|(
operator|&
name|state1
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
name|FSEv07_initDState
argument_list|(
operator|&
name|state2
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
define|#
directive|define
name|FSEv07_GETSYMBOL
parameter_list|(
name|statePtr
parameter_list|)
value|fast ? FSEv07_decodeSymbolFast(statePtr,&bitD) : FSEv07_decodeSymbol(statePtr,&bitD)
comment|/* 4 symbols per loop */
for|for
control|(
init|;
operator|(
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|op
operator|<
name|olimit
operator|)
condition|;
name|op
operator|+=
literal|4
control|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSEv07_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSEv07_MAX_TABLELOG
operator|*
literal|4
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
block|{
if|if
condition|(
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|BITv07_DStream_unfinished
condition|)
block|{
name|op
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
name|op
index|[
literal|2
index|]
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSEv07_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
block|}
comment|/* tail */
comment|/* note : BITv07_reloadDStream(&bitD)>= FSEv07_DStream_partiallyFilled; Ends at exactly BITv07_DStream_completed */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|op
operator|>
operator|(
name|omax
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
operator|*
name|op
operator|++
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BITv07_DStream_overflow
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|>
operator|(
name|omax
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
operator|*
name|op
operator|++
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BITv07_DStream_overflow
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|FSEv07_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
name|size_t
name|FSEv07_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|originalSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSEv07_DTable
modifier|*
name|dt
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
specifier|const
name|FSEv07_DTableHeader
modifier|*
name|DTableH
init|=
operator|(
specifier|const
name|FSEv07_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|U32
name|fastMode
init|=
name|DTableH
operator|->
name|fastMode
decl_stmt|;
comment|/* select fast mode (static) */
if|if
condition|(
name|fastMode
condition|)
return|return
name|FSEv07_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|FSEv07_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSEv07_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|short
name|counting
index|[
name|FSEv07_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|DTable_max_t
name|dt
decl_stmt|;
comment|/* Static analyzer seems unable to understand this table will be properly initialized later */
name|unsigned
name|tableLog
decl_stmt|;
name|unsigned
name|maxSymbolValue
init|=
name|FSEv07_MAX_SYMBOL_VALUE
decl_stmt|;
if|if
condition|(
name|cSrcSize
operator|<
literal|2
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* too small input size */
comment|/* normal FSE decoding mode */
block|{
name|size_t
specifier|const
name|NCountLength
init|=
name|FSEv07_readNCount
argument_list|(
name|counting
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
operator|&
name|tableLog
argument_list|,
name|istart
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|NCountLength
argument_list|)
condition|)
return|return
name|NCountLength
return|;
if|if
condition|(
name|NCountLength
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* too small input size */
name|ip
operator|+=
name|NCountLength
expr_stmt|;
name|cSrcSize
operator|-=
name|NCountLength
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|FSEv07_buildDTable
argument_list|(
name|dt
argument_list|,
name|counting
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
return|return
name|FSEv07_decompress_usingDTable
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|)
return|;
comment|/* always return, even if it is an error code */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FSEv07_COMMONDEFS_ONLY */
end_comment

begin_comment
comment|/* ******************************************************************    Huffman decoder, part of New Generation Entropy library    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
end_if

begin_comment
comment|/* inline is defined */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_define
define|#
directive|define
name|inline
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|inline
end_define

begin_comment
comment|/* disable inline */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|HUFv07_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { HUFv07_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/*-***************************/
end_comment

begin_comment
comment|/*  generic DTableDesc       */
end_comment

begin_comment
comment|/*-***************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|maxTableLog
decl_stmt|;
name|BYTE
name|tableType
decl_stmt|;
name|BYTE
name|tableLog
decl_stmt|;
name|BYTE
name|reserved
decl_stmt|;
block|}
name|DTableDesc
typedef|;
end_typedef

begin_function
specifier|static
name|DTableDesc
name|HUFv07_getDTableDesc
parameter_list|(
specifier|const
name|HUFv07_DTable
modifier|*
name|table
parameter_list|)
block|{
name|DTableDesc
name|dtd
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dtd
argument_list|,
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|dtd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dtd
return|;
block|}
end_function

begin_comment
comment|/*-***************************/
end_comment

begin_comment
comment|/*  single-symbol decoding   */
end_comment

begin_comment
comment|/*-***************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|byte
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|HUFv07_DEltX2
typedef|;
end_typedef

begin_comment
comment|/* single-symbol decoding */
end_comment

begin_function
name|size_t
name|HUFv07_readDTableX2
parameter_list|(
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|huffWeight
index|[
name|HUFv07_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* large enough for values from 0 to 16 */
name|U32
name|tableLog
init|=
literal|0
decl_stmt|;
name|U32
name|nbSymbols
init|=
literal|0
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
name|HUFv07_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
name|HUFv07_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|HUFv07_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|DTableDesc
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|HUFv07_DTable
argument_list|)
argument_list|)
expr_stmt|;
comment|//memset(huffWeight, 0, sizeof(huffWeight));   /* is not necessary, even though some analyzer complain ... */
name|iSize
operator|=
name|HUFv07_readStats
argument_list|(
name|huffWeight
argument_list|,
name|HUFv07_SYMBOLVALUE_MAX
operator|+
literal|1
argument_list|,
name|rankVal
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|iSize
argument_list|)
condition|)
return|return
name|iSize
return|;
comment|/* Table header */
block|{
name|DTableDesc
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLog
operator|>
call|(
name|U32
call|)
argument_list|(
name|dtd
operator|.
name|maxTableLog
operator|+
literal|1
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* DTable too small, huffman tree cannot fit in */
name|dtd
operator|.
name|tableType
operator|=
literal|0
expr_stmt|;
name|dtd
operator|.
name|tableLog
operator|=
operator|(
name|BYTE
operator|)
name|tableLog
expr_stmt|;
name|memcpy
argument_list|(
name|DTable
argument_list|,
operator|&
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|dtd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare ranks */
block|{
name|U32
name|n
decl_stmt|,
name|nextRankStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|tableLog
operator|+
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
operator|(
name|rankVal
index|[
name|n
index|]
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rankVal
index|[
name|n
index|]
operator|=
name|current
expr_stmt|;
block|}
block|}
comment|/* fill DTable */
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbSymbols
condition|;
name|n
operator|++
control|)
block|{
name|U32
specifier|const
name|w
init|=
name|huffWeight
index|[
name|n
index|]
decl_stmt|;
name|U32
specifier|const
name|length
init|=
operator|(
literal|1
operator|<<
name|w
operator|)
operator|>>
literal|1
decl_stmt|;
name|U32
name|i
decl_stmt|;
name|HUFv07_DEltX2
name|D
decl_stmt|;
name|D
operator|.
name|byte
operator|=
operator|(
name|BYTE
operator|)
name|n
expr_stmt|;
name|D
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|+
literal|1
operator|-
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rankVal
index|[
name|w
index|]
init|;
name|i
operator|<
name|rankVal
index|[
name|w
index|]
operator|+
name|length
condition|;
name|i
operator|++
control|)
name|dt
index|[
name|i
index|]
operator|=
name|D
expr_stmt|;
name|rankVal
index|[
name|w
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
return|return
name|iSize
return|;
block|}
end_function

begin_function
specifier|static
name|BYTE
name|HUFv07_decodeSymbolX2
parameter_list|(
name|BITv07_DStream_t
modifier|*
name|Dstream
parameter_list|,
specifier|const
name|HUFv07_DEltX2
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|size_t
specifier|const
name|val
init|=
name|BITv07_lookBitsFast
argument_list|(
name|Dstream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|BYTE
specifier|const
name|c
init|=
name|dt
index|[
name|val
index|]
operator|.
name|byte
decl_stmt|;
name|BITv07_skipBits
argument_list|(
name|Dstream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HUFv07_DECODE_SYMBOLX2_0
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|*ptr++ = HUFv07_decodeSymbolX2(DStreamPtr, dt, dtLog)
end_define

begin_define
define|#
directive|define
name|HUFv07_DECODE_SYMBOLX2_1
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits() || (HUFv07_TABLELOG_MAX<=12)) \         HUFv07_DECODE_SYMBOLX2_0(ptr, DStreamPtr)
end_define

begin_define
define|#
directive|define
name|HUFv07_DECODE_SYMBOLX2_2
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits()) \         HUFv07_DECODE_SYMBOLX2_0(ptr, DStreamPtr)
end_define

begin_function
specifier|static
specifier|inline
name|size_t
name|HUFv07_decodeStreamX2
parameter_list|(
name|BYTE
modifier|*
name|p
parameter_list|,
name|BITv07_DStream_t
modifier|*
specifier|const
name|bitDPtr
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|pEnd
parameter_list|,
specifier|const
name|HUFv07_DEltX2
modifier|*
specifier|const
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|pStart
init|=
name|p
decl_stmt|;
comment|/* up to 4 symbols at a time */
while|while
condition|(
operator|(
name|BITv07_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<=
name|pEnd
operator|-
literal|4
operator|)
condition|)
block|{
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_1
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
block|}
comment|/* closer to the end */
while|while
condition|(
operator|(
name|BITv07_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<
name|pEnd
operator|)
condition|)
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
comment|/* no more data to retrieve from bitstream, hence no need to reload */
while|while
condition|(
name|p
operator|<
name|pEnd
condition|)
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
return|return
name|pEnd
operator|-
name|pStart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUFv07_decompress1X2_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
specifier|const
name|HUFv07_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUFv07_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|BITv07_DStream_t
name|bitD
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dtLog
init|=
name|dtd
operator|.
name|tableLog
decl_stmt|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
name|HUFv07_decodeStreamX2
argument_list|(
name|op
argument_list|,
operator|&
name|bitD
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
if|if
condition|(
operator|!
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
return|return
name|dstSize
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUFv07_decompress1X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X2_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|DCtx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
specifier|const
name|hSize
init|=
name|HUFv07_readDTableX2
argument_list|(
name|DCtx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUFv07_decompress1X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DCtx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUFv07_CREATE_STATIC_DTABLEX2
argument_list|(
name|DTable
argument_list|,
name|HUFv07_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUFv07_decompress1X2_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUFv07_decompress4X2_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
comment|/* Check */
if|if
condition|(
name|cSrcSize
operator|<
literal|10
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* strict minimum : jump table + 1 byte per stream */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
specifier|const
name|HUFv07_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUFv07_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
comment|/* Init */
name|BITv07_DStream_t
name|bitD1
decl_stmt|;
name|BITv07_DStream_t
name|bitD2
decl_stmt|;
name|BITv07_DStream_t
name|bitD3
decl_stmt|;
name|BITv07_DStream_t
name|bitD4
decl_stmt|;
name|size_t
specifier|const
name|length1
init|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length2
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|2
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length3
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length4
init|=
name|cSrcSize
operator|-
operator|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart1
init|=
name|istart
operator|+
literal|6
decl_stmt|;
comment|/* jumpTable */
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart2
init|=
name|istart1
operator|+
name|length1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart3
init|=
name|istart2
operator|+
name|length2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart4
init|=
name|istart3
operator|+
name|length3
decl_stmt|;
specifier|const
name|size_t
name|segmentSize
init|=
operator|(
name|dstSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart2
init|=
name|ostart
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart3
init|=
name|opStart2
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart4
init|=
name|opStart3
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
name|op1
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
name|op2
init|=
name|opStart2
decl_stmt|;
name|BYTE
modifier|*
name|op3
init|=
name|opStart3
decl_stmt|;
name|BYTE
modifier|*
name|op4
init|=
name|opStart4
decl_stmt|;
name|U32
name|endSignal
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dtLog
init|=
name|dtd
operator|.
name|tableLog
decl_stmt|;
if|if
condition|(
name|length4
operator|>
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* overflow */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|istart1
argument_list|,
name|length1
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|istart2
argument_list|,
name|length2
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|istart3
argument_list|,
name|length3
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|istart4
argument_list|,
name|length4
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
comment|/* 16-32 symbols per loop (4-8 symbols per stream) */
name|endSignal
operator|=
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|endSignal
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|op4
operator|<
operator|(
name|oend
operator|-
literal|7
operator|)
operator|)
condition|;
control|)
block|{
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_1
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_1
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_1
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_1
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX2_0
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|endSignal
operator|=
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
block|}
comment|/* check corruption */
if|if
condition|(
name|op1
operator|>
name|opStart2
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op2
operator|>
name|opStart3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op3
operator|>
name|opStart4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* note : op4 supposed already verified within main loop */
comment|/* finish bitStreams one by one */
name|HUFv07_decodeStreamX2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|,
name|opStart2
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUFv07_decodeStreamX2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|,
name|opStart3
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUFv07_decodeStreamX2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|,
name|opStart4
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUFv07_decodeStreamX2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
name|endSignal
operator|=
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator|&
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator|&
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator|&
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endSignal
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUFv07_decompress4X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X2_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
specifier|const
name|hSize
init|=
name|HUFv07_readDTableX2
argument_list|(
name|dctx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUFv07_decompress4X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dctx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUFv07_CREATE_STATIC_DTABLEX2
argument_list|(
name|DTable
argument_list|,
name|HUFv07_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUFv07_decompress4X2_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* *************************/
end_comment

begin_comment
comment|/* double-symbols decoding */
end_comment

begin_comment
comment|/* *************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|U16
name|sequence
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
name|BYTE
name|length
decl_stmt|;
block|}
name|HUFv07_DEltX4
typedef|;
end_typedef

begin_comment
comment|/* double-symbols decoding */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|symbol
decl_stmt|;
name|BYTE
name|weight
decl_stmt|;
block|}
name|sortedSymbol_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|HUFv07_fillDTableX4Level2
parameter_list|(
name|HUFv07_DEltX4
modifier|*
name|DTable
parameter_list|,
name|U32
name|sizeLog
parameter_list|,
specifier|const
name|U32
name|consumed
parameter_list|,
specifier|const
name|U32
modifier|*
name|rankValOrigin
parameter_list|,
specifier|const
name|int
name|minWeight
parameter_list|,
specifier|const
name|sortedSymbol_t
modifier|*
name|sortedSymbols
parameter_list|,
specifier|const
name|U32
name|sortedListSize
parameter_list|,
name|U32
name|nbBitsBaseline
parameter_list|,
name|U16
name|baseSeq
parameter_list|)
block|{
name|HUFv07_DEltX4
name|DElt
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* get pre-calculated rankVal */
name|memcpy
argument_list|(
name|rankVal
argument_list|,
name|rankValOrigin
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill skipped values */
if|if
condition|(
name|minWeight
operator|>
literal|1
condition|)
block|{
name|U32
name|i
decl_stmt|,
name|skipSize
init|=
name|rankVal
index|[
name|minWeight
index|]
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
name|baseSeq
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|consumed
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skipSize
condition|;
name|i
operator|++
control|)
name|DTable
index|[
name|i
index|]
operator|=
name|DElt
expr_stmt|;
block|}
comment|/* fill DTable */
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|sortedListSize
condition|;
name|s
operator|++
control|)
block|{
comment|/* note : sortedSymbols already skipped */
specifier|const
name|U32
name|symbol
init|=
name|sortedSymbols
index|[
name|s
index|]
operator|.
name|symbol
decl_stmt|;
specifier|const
name|U32
name|weight
init|=
name|sortedSymbols
index|[
name|s
index|]
operator|.
name|weight
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|nbBitsBaseline
operator|-
name|weight
decl_stmt|;
specifier|const
name|U32
name|length
init|=
literal|1
operator|<<
operator|(
name|sizeLog
operator|-
name|nbBits
operator|)
decl_stmt|;
specifier|const
name|U32
name|start
init|=
name|rankVal
index|[
name|weight
index|]
decl_stmt|;
name|U32
name|i
init|=
name|start
decl_stmt|;
specifier|const
name|U32
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
call|(
name|U16
call|)
argument_list|(
name|baseSeq
operator|+
operator|(
name|symbol
operator|<<
literal|8
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|nbBits
operator|+
name|consumed
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|DTable
index|[
name|i
operator|++
index|]
operator|=
name|DElt
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|end
condition|)
do|;
comment|/* since length>= 1 */
name|rankVal
index|[
name|weight
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
block|}
end_function

begin_typedef
typedef|typedef
name|U32
name|rankVal_t
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
index|]
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|HUFv07_fillDTableX4
parameter_list|(
name|HUFv07_DEltX4
modifier|*
name|DTable
parameter_list|,
specifier|const
name|U32
name|targetLog
parameter_list|,
specifier|const
name|sortedSymbol_t
modifier|*
name|sortedList
parameter_list|,
specifier|const
name|U32
name|sortedListSize
parameter_list|,
specifier|const
name|U32
modifier|*
name|rankStart
parameter_list|,
name|rankVal_t
name|rankValOrigin
parameter_list|,
specifier|const
name|U32
name|maxWeight
parameter_list|,
specifier|const
name|U32
name|nbBitsBaseline
parameter_list|)
block|{
name|U32
name|rankVal
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|int
name|scaleLog
init|=
name|nbBitsBaseline
operator|-
name|targetLog
decl_stmt|;
comment|/* note : targetLog>= srcLog, hence scaleLog<= 1 */
specifier|const
name|U32
name|minBits
init|=
name|nbBitsBaseline
operator|-
name|maxWeight
decl_stmt|;
name|U32
name|s
decl_stmt|;
name|memcpy
argument_list|(
name|rankVal
argument_list|,
name|rankValOrigin
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill DTable */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|sortedListSize
condition|;
name|s
operator|++
control|)
block|{
specifier|const
name|U16
name|symbol
init|=
name|sortedList
index|[
name|s
index|]
operator|.
name|symbol
decl_stmt|;
specifier|const
name|U32
name|weight
init|=
name|sortedList
index|[
name|s
index|]
operator|.
name|weight
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|nbBitsBaseline
operator|-
name|weight
decl_stmt|;
specifier|const
name|U32
name|start
init|=
name|rankVal
index|[
name|weight
index|]
decl_stmt|;
specifier|const
name|U32
name|length
init|=
literal|1
operator|<<
operator|(
name|targetLog
operator|-
name|nbBits
operator|)
decl_stmt|;
if|if
condition|(
name|targetLog
operator|-
name|nbBits
operator|>=
name|minBits
condition|)
block|{
comment|/* enough room for a second symbol */
name|U32
name|sortedRank
decl_stmt|;
name|int
name|minWeight
init|=
name|nbBits
operator|+
name|scaleLog
decl_stmt|;
if|if
condition|(
name|minWeight
operator|<
literal|1
condition|)
name|minWeight
operator|=
literal|1
expr_stmt|;
name|sortedRank
operator|=
name|rankStart
index|[
name|minWeight
index|]
expr_stmt|;
name|HUFv07_fillDTableX4Level2
argument_list|(
name|DTable
operator|+
name|start
argument_list|,
name|targetLog
operator|-
name|nbBits
argument_list|,
name|nbBits
argument_list|,
name|rankValOrigin
index|[
name|nbBits
index|]
argument_list|,
name|minWeight
argument_list|,
name|sortedList
operator|+
name|sortedRank
argument_list|,
name|sortedListSize
operator|-
name|sortedRank
argument_list|,
name|nbBitsBaseline
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HUFv07_DEltX4
name|DElt
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|nbBits
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|1
expr_stmt|;
block|{
name|U32
name|u
decl_stmt|;
specifier|const
name|U32
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
for|for
control|(
name|u
operator|=
name|start
init|;
name|u
operator|<
name|end
condition|;
name|u
operator|++
control|)
name|DTable
index|[
name|u
index|]
operator|=
name|DElt
expr_stmt|;
block|}
block|}
name|rankVal
index|[
name|weight
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUFv07_readDTableX4
parameter_list|(
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|weightList
index|[
name|HUFv07_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|sortedSymbol_t
name|sortedSymbol
index|[
name|HUFv07_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankStats
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
name|rankStart0
index|[
name|HUFv07_TABLELOG_ABSOLUTEMAX
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
modifier|*
specifier|const
name|rankStart
init|=
name|rankStart0
operator|+
literal|1
decl_stmt|;
name|rankVal_t
name|rankVal
decl_stmt|;
name|U32
name|tableLog
decl_stmt|,
name|maxW
decl_stmt|,
name|sizeOfSort
decl_stmt|,
name|nbSymbols
decl_stmt|;
name|DTableDesc
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|maxTableLog
init|=
name|dtd
operator|.
name|maxTableLog
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|void
modifier|*
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
comment|/* force compiler to avoid strict-aliasing */
name|HUFv07_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
name|HUFv07_DEltX4
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|HUFv07_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|HUFv07_DEltX4
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|HUFv07_DTable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if compilation fails here, assertion is false */
if|if
condition|(
name|maxTableLog
operator|>
name|HUFv07_TABLELOG_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|//memset(weightList, 0, sizeof(weightList));   /* is not necessary, even though some analyzer complain ... */
name|iSize
operator|=
name|HUFv07_readStats
argument_list|(
name|weightList
argument_list|,
name|HUFv07_SYMBOLVALUE_MAX
operator|+
literal|1
argument_list|,
name|rankStats
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|iSize
argument_list|)
condition|)
return|return
name|iSize
return|;
comment|/* check result */
if|if
condition|(
name|tableLog
operator|>
name|maxTableLog
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* DTable can't fit code depth */
comment|/* find maxWeight */
for|for
control|(
name|maxW
operator|=
name|tableLog
init|;
name|rankStats
index|[
name|maxW
index|]
operator|==
literal|0
condition|;
name|maxW
operator|--
control|)
block|{}
comment|/* necessarily finds a solution before 0 */
comment|/* Get start index of each weight */
block|{
name|U32
name|w
decl_stmt|,
name|nextRankStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<
name|maxW
operator|+
literal|1
condition|;
name|w
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
name|rankStats
index|[
name|w
index|]
expr_stmt|;
name|rankStart
index|[
name|w
index|]
operator|=
name|current
expr_stmt|;
block|}
name|rankStart
index|[
literal|0
index|]
operator|=
name|nextRankStart
expr_stmt|;
comment|/* put all 0w symbols at the end of sorted list*/
name|sizeOfSort
operator|=
name|nextRankStart
expr_stmt|;
block|}
comment|/* sort symbols by weight */
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|nbSymbols
condition|;
name|s
operator|++
control|)
block|{
name|U32
specifier|const
name|w
init|=
name|weightList
index|[
name|s
index|]
decl_stmt|;
name|U32
specifier|const
name|r
init|=
name|rankStart
index|[
name|w
index|]
operator|++
decl_stmt|;
name|sortedSymbol
index|[
name|r
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|sortedSymbol
index|[
name|r
index|]
operator|.
name|weight
operator|=
operator|(
name|BYTE
operator|)
name|w
expr_stmt|;
block|}
name|rankStart
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* forget 0w symbols; this is beginning of weight(1) */
block|}
comment|/* Build rankVal */
block|{
name|U32
modifier|*
specifier|const
name|rankVal0
init|=
name|rankVal
index|[
literal|0
index|]
decl_stmt|;
block|{
name|int
specifier|const
name|rescale
init|=
operator|(
name|maxTableLog
operator|-
name|tableLog
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* tableLog<= maxTableLog */
name|U32
name|nextRankVal
init|=
literal|0
decl_stmt|;
name|U32
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<
name|maxW
operator|+
literal|1
condition|;
name|w
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankVal
decl_stmt|;
name|nextRankVal
operator|+=
name|rankStats
index|[
name|w
index|]
operator|<<
operator|(
name|w
operator|+
name|rescale
operator|)
expr_stmt|;
name|rankVal0
index|[
name|w
index|]
operator|=
name|current
expr_stmt|;
block|}
block|}
block|{
name|U32
specifier|const
name|minBits
init|=
name|tableLog
operator|+
literal|1
operator|-
name|maxW
decl_stmt|;
name|U32
name|consumed
decl_stmt|;
for|for
control|(
name|consumed
operator|=
name|minBits
init|;
name|consumed
operator|<
name|maxTableLog
operator|-
name|minBits
operator|+
literal|1
condition|;
name|consumed
operator|++
control|)
block|{
name|U32
modifier|*
specifier|const
name|rankValPtr
init|=
name|rankVal
index|[
name|consumed
index|]
decl_stmt|;
name|U32
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<
name|maxW
operator|+
literal|1
condition|;
name|w
operator|++
control|)
block|{
name|rankValPtr
index|[
name|w
index|]
operator|=
name|rankVal0
index|[
name|w
index|]
operator|>>
name|consumed
expr_stmt|;
block|}
block|}
block|}
block|}
name|HUFv07_fillDTableX4
argument_list|(
name|dt
argument_list|,
name|maxTableLog
argument_list|,
name|sortedSymbol
argument_list|,
name|sizeOfSort
argument_list|,
name|rankStart0
argument_list|,
name|rankVal
argument_list|,
name|maxW
argument_list|,
name|tableLog
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dtd
operator|.
name|tableLog
operator|=
operator|(
name|BYTE
operator|)
name|maxTableLog
expr_stmt|;
name|dtd
operator|.
name|tableType
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|DTable
argument_list|,
operator|&
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|dtd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iSize
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|HUFv07_decodeSymbolX4
parameter_list|(
name|void
modifier|*
name|op
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|DStream
parameter_list|,
specifier|const
name|HUFv07_DEltX4
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
specifier|const
name|size_t
name|val
init|=
name|BITv07_lookBitsFast
argument_list|(
name|DStream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|memcpy
argument_list|(
name|op
argument_list|,
name|dt
operator|+
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BITv07_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|dt
index|[
name|val
index|]
operator|.
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|HUFv07_decodeLastSymbolX4
parameter_list|(
name|void
modifier|*
name|op
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|DStream
parameter_list|,
specifier|const
name|HUFv07_DEltX4
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
specifier|const
name|size_t
name|val
init|=
name|BITv07_lookBitsFast
argument_list|(
name|DStream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|memcpy
argument_list|(
name|op
argument_list|,
name|dt
operator|+
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
index|[
name|val
index|]
operator|.
name|length
operator|==
literal|1
condition|)
name|BITv07_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DStream
operator|->
name|bitsConsumed
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
block|{
name|BITv07_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|DStream
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
name|DStream
operator|->
name|bitsConsumed
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* ugly hack; works only because it's the last symbol. Note : can't easily extract nbBits from just this symbol */
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HUFv07_DECODE_SYMBOLX4_0
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|ptr += HUFv07_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
end_define

begin_define
define|#
directive|define
name|HUFv07_DECODE_SYMBOLX4_1
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits() || (HUFv07_TABLELOG_MAX<=12)) \         ptr += HUFv07_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
end_define

begin_define
define|#
directive|define
name|HUFv07_DECODE_SYMBOLX4_2
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits()) \         ptr += HUFv07_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
end_define

begin_function
specifier|static
specifier|inline
name|size_t
name|HUFv07_decodeStreamX4
parameter_list|(
name|BYTE
modifier|*
name|p
parameter_list|,
name|BITv07_DStream_t
modifier|*
name|bitDPtr
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|pEnd
parameter_list|,
specifier|const
name|HUFv07_DEltX4
modifier|*
specifier|const
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|pStart
init|=
name|p
decl_stmt|;
comment|/* up to 8 symbols at a time */
while|while
condition|(
operator|(
name|BITv07_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<
name|pEnd
operator|-
literal|7
operator|)
condition|)
block|{
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_1
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
block|}
comment|/* closer to end : up to 2 symbols at a time */
while|while
condition|(
operator|(
name|BITv07_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<=
name|pEnd
operator|-
literal|2
operator|)
condition|)
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|pEnd
operator|-
literal|2
condition|)
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
comment|/* no need to reload : reached the end of DStream */
if|if
condition|(
name|p
operator|<
name|pEnd
condition|)
name|p
operator|+=
name|HUFv07_decodeLastSymbolX4
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
return|return
name|p
operator|-
name|pStart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUFv07_decompress1X4_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|BITv07_DStream_t
name|bitD
decl_stmt|;
comment|/* Init */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
comment|/* decode */
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
comment|/* force compiler to not use strict-aliasing */
specifier|const
name|HUFv07_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUFv07_DEltX4
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|HUFv07_decodeStreamX4
argument_list|(
name|ostart
argument_list|,
operator|&
name|bitD
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtd
operator|.
name|tableLog
argument_list|)
expr_stmt|;
block|}
comment|/* check */
if|if
condition|(
operator|!
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUFv07_decompress1X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X4_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|DCtx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
specifier|const
name|hSize
init|=
name|HUFv07_readDTableX4
argument_list|(
name|DCtx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUFv07_decompress1X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DCtx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUFv07_CREATE_STATIC_DTABLEX4
argument_list|(
name|DTable
argument_list|,
name|HUFv07_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUFv07_decompress1X4_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUFv07_decompress4X4_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
if|if
condition|(
name|cSrcSize
operator|<
literal|10
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* strict minimum : jump table + 1 byte per stream */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
specifier|const
name|HUFv07_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUFv07_DEltX4
operator|*
operator|)
name|dtPtr
decl_stmt|;
comment|/* Init */
name|BITv07_DStream_t
name|bitD1
decl_stmt|;
name|BITv07_DStream_t
name|bitD2
decl_stmt|;
name|BITv07_DStream_t
name|bitD3
decl_stmt|;
name|BITv07_DStream_t
name|bitD4
decl_stmt|;
name|size_t
specifier|const
name|length1
init|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length2
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|2
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length3
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length4
init|=
name|cSrcSize
operator|-
operator|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart1
init|=
name|istart
operator|+
literal|6
decl_stmt|;
comment|/* jumpTable */
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart2
init|=
name|istart1
operator|+
name|length1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart3
init|=
name|istart2
operator|+
name|length2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart4
init|=
name|istart3
operator|+
name|length3
decl_stmt|;
name|size_t
specifier|const
name|segmentSize
init|=
operator|(
name|dstSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart2
init|=
name|ostart
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart3
init|=
name|opStart2
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart4
init|=
name|opStart3
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
name|op1
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
name|op2
init|=
name|opStart2
decl_stmt|;
name|BYTE
modifier|*
name|op3
init|=
name|opStart3
decl_stmt|;
name|BYTE
modifier|*
name|op4
init|=
name|opStart4
decl_stmt|;
name|U32
name|endSignal
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dtLog
init|=
name|dtd
operator|.
name|tableLog
decl_stmt|;
if|if
condition|(
name|length4
operator|>
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* overflow */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|istart1
argument_list|,
name|length1
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|istart2
argument_list|,
name|length2
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|istart3
argument_list|,
name|length3
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|istart4
argument_list|,
name|length4
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
comment|/* 16-32 symbols per loop (4-8 symbols per stream) */
name|endSignal
operator|=
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|endSignal
operator|==
name|BITv07_DStream_unfinished
operator|)
operator|&&
operator|(
name|op4
operator|<
operator|(
name|oend
operator|-
literal|7
operator|)
operator|)
condition|;
control|)
block|{
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_1
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_1
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_1
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_1
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUFv07_DECODE_SYMBOLX4_0
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|endSignal
operator|=
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BITv07_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
block|}
comment|/* check corruption */
if|if
condition|(
name|op1
operator|>
name|opStart2
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op2
operator|>
name|opStart3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op3
operator|>
name|opStart4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* note : op4 supposed already verified within main loop */
comment|/* finish bitStreams one by one */
name|HUFv07_decodeStreamX4
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|,
name|opStart2
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUFv07_decodeStreamX4
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|,
name|opStart3
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUFv07_decodeStreamX4
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|,
name|opStart4
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUFv07_decodeStreamX4
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
block|{
name|U32
specifier|const
name|endCheck
init|=
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator|&
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator|&
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator|&
name|BITv07_endOfDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|endCheck
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUFv07_decompress4X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X4_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
name|hSize
init|=
name|HUFv07_readDTableX4
argument_list|(
name|dctx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUFv07_decompress4X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dctx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUFv07_CREATE_STATIC_DTABLEX4
argument_list|(
name|DTable
argument_list|,
name|HUFv07_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUFv07_decompress4X4_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************/
end_comment

begin_comment
comment|/* Generic decompression selector */
end_comment

begin_comment
comment|/* ********************************/
end_comment

begin_function
name|size_t
name|HUFv07_decompress1X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
return|return
name|dtd
operator|.
name|tableType
condition|?
name|HUFv07_decompress1X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
else|:
name|HUFv07_decompress1X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUFv07_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUFv07_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
return|return
name|dtd
operator|.
name|tableType
condition|?
name|HUFv07_decompress4X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
else|:
name|HUFv07_decompress4X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|tableTime
decl_stmt|;
name|U32
name|decode256Time
decl_stmt|;
block|}
name|algo_time_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|algo_time_t
name|algoTime
index|[
literal|16
comment|/* Quantization */
index|]
index|[
literal|3
comment|/* single, double, quad */
index|]
init|=
block|{
comment|/* single, double, quad */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|}
block|,
comment|/* Q==0 : impossible */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|}
block|,
comment|/* Q==1 : impossible */
block|{
block|{
literal|38
block|,
literal|130
block|}
block|,
block|{
literal|1313
block|,
literal|74
block|}
block|,
block|{
literal|2151
block|,
literal|38
block|}
block|}
block|,
comment|/* Q == 2 : 12-18% */
block|{
block|{
literal|448
block|,
literal|128
block|}
block|,
block|{
literal|1353
block|,
literal|74
block|}
block|,
block|{
literal|2238
block|,
literal|41
block|}
block|}
block|,
comment|/* Q == 3 : 18-25% */
block|{
block|{
literal|556
block|,
literal|128
block|}
block|,
block|{
literal|1353
block|,
literal|74
block|}
block|,
block|{
literal|2238
block|,
literal|47
block|}
block|}
block|,
comment|/* Q == 4 : 25-32% */
block|{
block|{
literal|714
block|,
literal|128
block|}
block|,
block|{
literal|1418
block|,
literal|74
block|}
block|,
block|{
literal|2436
block|,
literal|53
block|}
block|}
block|,
comment|/* Q == 5 : 32-38% */
block|{
block|{
literal|883
block|,
literal|128
block|}
block|,
block|{
literal|1437
block|,
literal|74
block|}
block|,
block|{
literal|2464
block|,
literal|61
block|}
block|}
block|,
comment|/* Q == 6 : 38-44% */
block|{
block|{
literal|897
block|,
literal|128
block|}
block|,
block|{
literal|1515
block|,
literal|75
block|}
block|,
block|{
literal|2622
block|,
literal|68
block|}
block|}
block|,
comment|/* Q == 7 : 44-50% */
block|{
block|{
literal|926
block|,
literal|128
block|}
block|,
block|{
literal|1613
block|,
literal|75
block|}
block|,
block|{
literal|2730
block|,
literal|75
block|}
block|}
block|,
comment|/* Q == 8 : 50-56% */
block|{
block|{
literal|947
block|,
literal|128
block|}
block|,
block|{
literal|1729
block|,
literal|77
block|}
block|,
block|{
literal|3359
block|,
literal|77
block|}
block|}
block|,
comment|/* Q == 9 : 56-62% */
block|{
block|{
literal|1107
block|,
literal|128
block|}
block|,
block|{
literal|2083
block|,
literal|81
block|}
block|,
block|{
literal|4006
block|,
literal|84
block|}
block|}
block|,
comment|/* Q ==10 : 62-69% */
block|{
block|{
literal|1177
block|,
literal|128
block|}
block|,
block|{
literal|2379
block|,
literal|87
block|}
block|,
block|{
literal|4785
block|,
literal|88
block|}
block|}
block|,
comment|/* Q ==11 : 69-75% */
block|{
block|{
literal|1242
block|,
literal|128
block|}
block|,
block|{
literal|2415
block|,
literal|93
block|}
block|,
block|{
literal|5155
block|,
literal|84
block|}
block|}
block|,
comment|/* Q ==12 : 75-81% */
block|{
block|{
literal|1349
block|,
literal|128
block|}
block|,
block|{
literal|2644
block|,
literal|106
block|}
block|,
block|{
literal|5260
block|,
literal|106
block|}
block|}
block|,
comment|/* Q ==13 : 81-87% */
block|{
block|{
literal|1455
block|,
literal|128
block|}
block|,
block|{
literal|2422
block|,
literal|124
block|}
block|,
block|{
literal|4174
block|,
literal|124
block|}
block|}
block|,
comment|/* Q ==14 : 87-93% */
block|{
block|{
literal|722
block|,
literal|128
block|}
block|,
block|{
literal|1891
block|,
literal|145
block|}
block|,
block|{
literal|1936
block|,
literal|146
block|}
block|}
block|,
comment|/* Q ==15 : 93-99% */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** HUFv07_selectDecoder() : *   Tells which decoder is likely to decode faster, *   based on a set of pre-determined metrics. *   @return : 0==HUFv07_decompress4X2, 1==HUFv07_decompress4X4 . *   Assumption : 0< cSrcSize< dstSize<= 128 KB */
end_comment

begin_function
name|U32
name|HUFv07_selectDecoder
parameter_list|(
name|size_t
name|dstSize
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* decoder timing evaluation */
name|U32
specifier|const
name|Q
init|=
call|(
name|U32
call|)
argument_list|(
name|cSrcSize
operator|*
literal|16
operator|/
name|dstSize
argument_list|)
decl_stmt|;
comment|/* Q< 16 since dstSize> cSrcSize */
name|U32
specifier|const
name|D256
init|=
call|(
name|U32
call|)
argument_list|(
name|dstSize
operator|>>
literal|8
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|DTime0
init|=
name|algoTime
index|[
name|Q
index|]
index|[
literal|0
index|]
operator|.
name|tableTime
operator|+
operator|(
name|algoTime
index|[
name|Q
index|]
index|[
literal|0
index|]
operator|.
name|decode256Time
operator|*
name|D256
operator|)
decl_stmt|;
name|U32
name|DTime1
init|=
name|algoTime
index|[
name|Q
index|]
index|[
literal|1
index|]
operator|.
name|tableTime
operator|+
operator|(
name|algoTime
index|[
name|Q
index|]
index|[
literal|1
index|]
operator|.
name|decode256Time
operator|*
name|D256
operator|)
decl_stmt|;
name|DTime1
operator|+=
name|DTime1
operator|>>
literal|3
expr_stmt|;
comment|/* advantage to algorithm using less memory, for cache eviction */
return|return
name|DTime1
operator|<
name|DTime0
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|decompressionAlgo
function_decl|)
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
end_typedef

begin_function
name|size_t
name|HUFv07_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|static
specifier|const
name|decompressionAlgo
name|decompress
index|[
literal|2
index|]
init|=
block|{
name|HUFv07_decompress4X2
block|,
name|HUFv07_decompress4X4
block|}
decl_stmt|;
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUFv07_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|decompress
index|[
name|algoNb
index|]
operator|(
name|dst
operator|,
name|dstSize
operator|,
name|cSrc
operator|,
name|cSrcSize
operator|)
return|;
block|}
comment|//return HUFv07_decompress4X2(dst, dstSize, cSrc, cSrcSize);   /* multi-streams single-symbol decoding */
comment|//return HUFv07_decompress4X4(dst, dstSize, cSrc, cSrcSize);   /* multi-streams double-symbols decoding */
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUFv07_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|algoNb
condition|?
name|HUFv07_decompress4X4_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
else|:
name|HUFv07_decompress4X2_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress4X_hufOnly
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
operator|(
name|cSrcSize
operator|>=
name|dstSize
operator|)
operator|||
operator|(
name|cSrcSize
operator|<=
literal|1
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUFv07_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|algoNb
condition|?
name|HUFv07_decompress4X4_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
else|:
name|HUFv07_decompress4X2_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUFv07_decompress1X_DCtx
parameter_list|(
name|HUFv07_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUFv07_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|algoNb
condition|?
name|HUFv07_decompress1X4_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
else|:
name|HUFv07_decompress1X2_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*     Common functions of Zstd compression library     Copyright (C) 2015-2016, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd homepage : http://www.zstd.net/ */
end_comment

begin_comment
comment|/*-**************************************** *  ZSTD Error Management ******************************************/
end_comment

begin_comment
comment|/*! ZSTDv07_isError() : *   tells if a return value is an error code */
end_comment

begin_function
name|unsigned
name|ZSTDv07_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*! ZSTDv07_getErrorName() : *   provides error code string from function result (useful for debugging) */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ZSTDv07_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************** *  ZBUFF Error Management ****************************************************************/
end_comment

begin_function
name|unsigned
name|ZBUFFv07_isError
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ZBUFFv07_getErrorName
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ZSTDv07_defaultAllocFunction
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|address
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|opaque
expr_stmt|;
comment|/* printf("alloc %p, %d opaque=%p \n", address, (int)size, opaque); */
return|return
name|address
return|;
block|}
end_function

begin_function
name|void
name|ZSTDv07_defaultFreeFunction
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
operator|(
name|void
operator|)
name|opaque
expr_stmt|;
comment|/* if (address) printf("free %p opaque=%p \n", address, opaque); */
name|free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     zstd_internal - common functions to include     Header File for include     Copyright (C) 2014-2016, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd homepage : https://www.zstd.net */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTDv07_CCOMMON_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|ZSTDv07_CCOMMON_H_MODULE
end_define

begin_comment
comment|/*-************************************* *  Common macros ***************************************/
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
end_define

begin_comment
comment|/*-************************************* *  Common constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|ZSTDv07_OPT_NUM
value|(1<<12)
end_define

begin_define
define|#
directive|define
name|ZSTDv07_DICT_MAGIC
value|0xEC30A437
end_define

begin_comment
comment|/* v0.7 */
end_comment

begin_define
define|#
directive|define
name|ZSTDv07_REP_NUM
value|3
end_define

begin_define
define|#
directive|define
name|ZSTDv07_REP_INIT
value|ZSTDv07_REP_NUM
end_define

begin_define
define|#
directive|define
name|ZSTDv07_REP_MOVE
value|(ZSTDv07_REP_NUM-1)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|repStartValue
index|[
name|ZSTDv07_REP_NUM
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|BIT7
value|128
end_define

begin_define
define|#
directive|define
name|BIT6
value|64
end_define

begin_define
define|#
directive|define
name|BIT5
value|32
end_define

begin_define
define|#
directive|define
name|BIT4
value|16
end_define

begin_define
define|#
directive|define
name|BIT1
value|2
end_define

begin_define
define|#
directive|define
name|BIT0
value|1
end_define

begin_define
define|#
directive|define
name|ZSTDv07_WINDOWLOG_ABSOLUTEMIN
value|10
end_define

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTDv07_fcs_fieldSize
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTDv07_did_fieldSize
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZSTDv07_BLOCKHEADERSIZE
value|3
end_define

begin_comment
comment|/* C standard doesn't allow `static const` variable to be init using another `static const` variable */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTDv07_blockHeaderSize
init|=
name|ZSTDv07_BLOCKHEADERSIZE
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|bt_compressed
block|,
name|bt_raw
block|,
name|bt_rle
block|,
name|bt_end
block|}
name|blockType_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MIN_SEQUENCES_SIZE
value|1
end_define

begin_comment
comment|/* nbSeq==0 */
end_comment

begin_define
define|#
directive|define
name|MIN_CBLOCK_SIZE
value|(1
comment|/*litCSize*/
value|+ 1
comment|/* RLE or RAW */
value|+ MIN_SEQUENCES_SIZE
comment|/* nbSeq==0 */
value|)
end_define

begin_comment
comment|/* for a non-null block */
end_comment

begin_define
define|#
directive|define
name|HufLog
value|12
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|lbt_huffman
block|,
name|lbt_repeat
block|,
name|lbt_raw
block|,
name|lbt_rle
block|}
name|litBlockType_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LONGNBSEQ
value|0x7F00
end_define

begin_define
define|#
directive|define
name|MINMATCH
value|3
end_define

begin_define
define|#
directive|define
name|EQUAL_READ32
value|4
end_define

begin_define
define|#
directive|define
name|Litbits
value|8
end_define

begin_define
define|#
directive|define
name|MaxLit
value|((1<<Litbits) - 1)
end_define

begin_define
define|#
directive|define
name|MaxML
value|52
end_define

begin_define
define|#
directive|define
name|MaxLL
value|35
end_define

begin_define
define|#
directive|define
name|MaxOff
value|28
end_define

begin_define
define|#
directive|define
name|MaxSeq
value|MAX(MaxLL, MaxML)
end_define

begin_comment
comment|/* Assumption : MaxOff< MaxLL,MaxML */
end_comment

begin_define
define|#
directive|define
name|MLFSELog
value|9
end_define

begin_define
define|#
directive|define
name|LLFSELog
value|9
end_define

begin_define
define|#
directive|define
name|OffFSELog
value|8
end_define

begin_define
define|#
directive|define
name|FSEv07_ENCODING_RAW
value|0
end_define

begin_define
define|#
directive|define
name|FSEv07_ENCODING_RLE
value|1
end_define

begin_define
define|#
directive|define
name|FSEv07_ENCODING_STATIC
value|2
end_define

begin_define
define|#
directive|define
name|FSEv07_ENCODING_DYNAMIC
value|3
end_define

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|LL_bits
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|S16
name|LL_defaultNorm
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|LL_defaultNormLog
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|ML_bits
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|S16
name|ML_defaultNorm
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|ML_defaultNormLog
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|S16
name|OF_defaultNorm
index|[
name|MaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|OF_defaultNormLog
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-******************************************* *  Shared functions to include for inlining *********************************************/
end_comment

begin_function
specifier|static
name|void
name|ZSTDv07_copy8
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|COPY8
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ ZSTDv07_copy8(d,s); d+=8; s+=8; }
end_define

begin_comment
comment|/*! ZSTDv07_wildcopy() : *   custom version of memcpy(), can copy up to 7 bytes too many (8 bytes if length==0) */
end_comment

begin_define
define|#
directive|define
name|WILDCOPY_OVERLENGTH
value|8
end_define

begin_function
name|MEM_STATIC
name|void
name|ZSTDv07_wildcopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|ptrdiff_t
name|length
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|length
decl_stmt|;
do|do
name|COPY8
argument_list|(
argument|op
argument_list|,
argument|ip
argument_list|)
while|while
condition|(
name|op
operator|<
name|oend
condition|)
empty_stmt|;
do|}
comment|/*-******************************************* *  Private interfaces *********************************************/
typedef|typedef
name|struct
name|ZSTDv07_stats_s
name|ZSTDv07_stats_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|off
decl_stmt|;
name|U32
name|len
decl_stmt|;
block|}
name|ZSTDv07_match_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|price
decl_stmt|;
name|U32
name|off
decl_stmt|;
name|U32
name|mlen
decl_stmt|;
name|U32
name|litlen
decl_stmt|;
name|U32
name|rep
index|[
name|ZSTDv07_REP_INIT
index|]
decl_stmt|;
block|}
name|ZSTDv07_optimal_t
typedef|;
struct|struct
name|ZSTDv07_stats_s
block|{
name|U32
name|unused
decl_stmt|;
block|}
struct|;
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|buffer
decl_stmt|;
name|U32
modifier|*
name|offsetStart
decl_stmt|;
name|U32
modifier|*
name|offset
decl_stmt|;
name|BYTE
modifier|*
name|offCodeStart
decl_stmt|;
name|BYTE
modifier|*
name|litStart
decl_stmt|;
name|BYTE
modifier|*
name|lit
decl_stmt|;
name|U16
modifier|*
name|litLengthStart
decl_stmt|;
name|U16
modifier|*
name|litLength
decl_stmt|;
name|BYTE
modifier|*
name|llCodeStart
decl_stmt|;
name|U16
modifier|*
name|matchLengthStart
decl_stmt|;
name|U16
modifier|*
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
name|mlCodeStart
decl_stmt|;
name|U32
name|longLengthID
decl_stmt|;
comment|/* 0 == no longLength; 1 == Lit.longLength; 2 == Match.longLength; */
name|U32
name|longLengthPos
decl_stmt|;
comment|/* opt */
name|ZSTDv07_optimal_t
modifier|*
name|priceTable
decl_stmt|;
name|ZSTDv07_match_t
modifier|*
name|matchTable
decl_stmt|;
name|U32
modifier|*
name|matchLengthFreq
decl_stmt|;
name|U32
modifier|*
name|litLengthFreq
decl_stmt|;
name|U32
modifier|*
name|litFreq
decl_stmt|;
name|U32
modifier|*
name|offCodeFreq
decl_stmt|;
name|U32
name|matchLengthSum
decl_stmt|;
name|U32
name|matchSum
decl_stmt|;
name|U32
name|litLengthSum
decl_stmt|;
name|U32
name|litSum
decl_stmt|;
name|U32
name|offCodeSum
decl_stmt|;
name|U32
name|log2matchLengthSum
decl_stmt|;
name|U32
name|log2matchSum
decl_stmt|;
name|U32
name|log2litLengthSum
decl_stmt|;
name|U32
name|log2litSum
decl_stmt|;
name|U32
name|log2offCodeSum
decl_stmt|;
name|U32
name|factor
decl_stmt|;
name|U32
name|cachedPrice
decl_stmt|;
name|U32
name|cachedLitLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|cachedLiterals
decl_stmt|;
name|ZSTDv07_stats_t
name|stats
decl_stmt|;
block|}
name|seqStore_t
typedef|;
name|void
name|ZSTDv07_seqToCodes
argument_list|(
specifier|const
name|seqStore_t
operator|*
name|seqStorePtr
argument_list|,
name|size_t
specifier|const
name|nbSeq
argument_list|)
decl_stmt|;
comment|/* custom memory allocation functions */
specifier|static
specifier|const
name|ZSTDv07_customMem
name|defaultCustomMem
init|=
block|{
name|ZSTDv07_defaultAllocFunction
block|,
name|ZSTDv07_defaultFreeFunction
block|,
name|NULL
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* ZSTDv07_CCOMMON_H_MODULE */
comment|/*     zstd - standard compression library     Copyright (C) 2014-2016, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd homepage : http://www.zstd.net */
comment|/* *************************************************************** *  Tuning parameters *****************************************************************/
comment|/*!  * HEAPMODE :  * Select how default decompression function ZSTDv07_decompress() will allocate memory,  * in memory stack (0), or in memory heap (1, requires malloc())  */
ifndef|#
directive|ifndef
name|ZSTDv07_HEAPMODE
define|#
directive|define
name|ZSTDv07_HEAPMODE
value|1
endif|#
directive|endif
comment|/*-******************************************************* *  Compiler specifics *********************************************************/
ifdef|#
directive|ifdef
name|_MSC_VER
comment|/* Visual Studio */
include|#
directive|include
file|<intrin.h>
comment|/* For Visual 2005 */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
comment|/* disable: C4127: conditional expression is constant */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4324
name|)
comment|/* disable: C4324: padded structure */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4100
name|)
comment|/* disable: C4100: unreferenced formal parameter */
endif|#
directive|endif
comment|/*-************************************* *  Macros ***************************************/
define|#
directive|define
name|ZSTDv07_isError
value|ERR_isError
comment|/* for inlining */
define|#
directive|define
name|FSEv07_isError
value|ERR_isError
define|#
directive|define
name|HUFv07_isError
value|ERR_isError
comment|/*_******************************************************* *  Memory operations **********************************************************/
specifier|static
name|void
name|ZSTDv07_copy4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/*-************************************************************* *   Context management ***************************************************************/
typedef|typedef
enum|enum
block|{
name|ZSTDds_getFrameHeaderSize
block|,
name|ZSTDds_decodeFrameHeader
block|,
name|ZSTDds_decodeBlockHeader
block|,
name|ZSTDds_decompressBlock
block|,
name|ZSTDds_decodeSkippableHeader
block|,
name|ZSTDds_skipFrame
block|}
name|ZSTDv07_dStage
typedef|;
struct|struct
name|ZSTDv07_DCtx_s
block|{
name|FSEv07_DTable
name|LLTable
index|[
name|FSEv07_DTABLE_SIZE_U32
argument_list|(
name|LLFSELog
argument_list|)
index|]
decl_stmt|;
name|FSEv07_DTable
name|OffTable
index|[
name|FSEv07_DTABLE_SIZE_U32
argument_list|(
name|OffFSELog
argument_list|)
index|]
decl_stmt|;
name|FSEv07_DTable
name|MLTable
index|[
name|FSEv07_DTABLE_SIZE_U32
argument_list|(
name|MLFSELog
argument_list|)
index|]
decl_stmt|;
name|HUFv07_DTable
name|hufTable
index|[
name|HUFv07_DTABLE_SIZE
argument_list|(
name|HufLog
argument_list|)
index|]
decl_stmt|;
comment|/* can accommodate HUFv07_decompress4X */
specifier|const
name|void
modifier|*
name|previousDstEnd
decl_stmt|;
specifier|const
name|void
modifier|*
name|base
decl_stmt|;
specifier|const
name|void
modifier|*
name|vBase
decl_stmt|;
specifier|const
name|void
modifier|*
name|dictEnd
decl_stmt|;
name|size_t
name|expected
decl_stmt|;
name|U32
name|rep
index|[
literal|3
index|]
decl_stmt|;
name|ZSTDv07_frameParams
name|fParams
decl_stmt|;
name|blockType_t
name|bType
decl_stmt|;
comment|/* used in ZSTDv07_decompressContinue(), to transfer blockType between header decoding and block decoding stages */
name|ZSTDv07_dStage
name|stage
decl_stmt|;
name|U32
name|litEntropy
decl_stmt|;
name|U32
name|fseEntropy
decl_stmt|;
name|XXH64_state_t
name|xxhState
decl_stmt|;
name|size_t
name|headerSize
decl_stmt|;
name|U32
name|dictID
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
decl_stmt|;
name|ZSTDv07_customMem
name|customMem
decl_stmt|;
name|size_t
name|litSize
decl_stmt|;
name|BYTE
name|litBuffer
index|[
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
operator|+
name|WILDCOPY_OVERLENGTH
index|]
decl_stmt|;
name|BYTE
name|headerBuffer
index|[
name|ZSTDv07_FRAMEHEADERSIZE_MAX
index|]
decl_stmt|;
block|}
struct|;
comment|/* typedef'd to ZSTDv07_DCtx within "zstd_static.h" */
name|int
name|ZSTDv07_isSkipFrame
argument_list|(
name|ZSTDv07_DCtx
operator|*
name|dctx
argument_list|)
decl_stmt|;
name|size_t
name|ZSTDv07_sizeofDCtx
parameter_list|(
specifier|const
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
operator|*
name|dctx
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_estimateDCtxSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|ZSTDv07_DCtx
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_decompressBegin
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
name|dctx
operator|->
name|expected
operator|=
name|ZSTDv07_frameHeaderSize_min
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|dictEnd
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|hufTable
index|[
literal|0
index|]
operator|=
call|(
name|HUFv07_DTable
call|)
argument_list|(
operator|(
name|HufLog
operator|)
operator|*
literal|0x1000001
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litEntropy
operator|=
name|dctx
operator|->
name|fseEntropy
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|dictID
operator|=
literal|0
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTDv07_REP_NUM
condition|;
name|i
operator|++
control|)
name|dctx
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|repStartValue
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|ZSTDv07_DCtx
modifier|*
name|ZSTDv07_createDCtx_advanced
parameter_list|(
name|ZSTDv07_customMem
name|customMem
parameter_list|)
block|{
name|ZSTDv07_DCtx
modifier|*
name|dctx
decl_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|&&
operator|!
name|customMem
operator|.
name|customFree
condition|)
name|customMem
operator|=
name|defaultCustomMem
expr_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|||
operator|!
name|customMem
operator|.
name|customFree
condition|)
return|return
name|NULL
return|;
name|dctx
operator|=
operator|(
name|ZSTDv07_DCtx
operator|*
operator|)
name|customMem
operator|.
name|customAlloc
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTDv07_DCtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dctx
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|&
name|dctx
operator|->
name|customMem
argument_list|,
operator|&
name|customMem
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTDv07_customMem
argument_list|)
argument_list|)
expr_stmt|;
name|ZSTDv07_decompressBegin
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|dctx
return|;
block|}
name|ZSTDv07_DCtx
modifier|*
name|ZSTDv07_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTDv07_createDCtx_advanced
argument_list|(
name|defaultCustomMem
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_freeDCtx
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support free on NULL */
name|dctx
operator|->
name|customMem
operator|.
name|customFree
argument_list|(
name|dctx
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|dctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* reserved as a potential error code in the future */
block|}
name|void
name|ZSTDv07_copyDCtx
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dstDCtx
parameter_list|,
specifier|const
name|ZSTDv07_DCtx
modifier|*
name|srcDCtx
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dstDCtx
argument_list|,
name|srcDCtx
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTDv07_DCtx
argument_list|)
operator|-
operator|(
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
operator|+
name|WILDCOPY_OVERLENGTH
operator|+
name|ZSTDv07_frameHeaderSize_max
operator|)
argument_list|)
expr_stmt|;
comment|/* no need to copy workspace */
block|}
comment|/*-************************************************************* *   Decompression section ***************************************************************/
comment|/* Frame format description    Frame Header -  [ Block Header - Block ] - Frame End    1) Frame Header       - 4 bytes - Magic Number : ZSTDv07_MAGICNUMBER (defined within zstd.h)       - 1 byte  - Frame Descriptor    2) Block Header       - 3 bytes, starting with a 2-bits descriptor                  Uncompressed, Compressed, Frame End, unused    3) Block       See Block Format Description    4) Frame End       - 3 bytes, compatible with Block Header */
comment|/* Frame Header :     1 byte - FrameHeaderDescription :    bit 0-1 : dictID (0, 1, 2 or 4 bytes)    bit 2   : checksumFlag    bit 3   : reserved (must be zero)    bit 4   : reserved (unused, can be any value)    bit 5   : Single Segment (if 1, WindowLog byte is not present)    bit 6-7 : FrameContentFieldSize (0, 2, 4, or 8)              if (SkippedWindowLog&& !FrameContentFieldsize) FrameContentFieldsize=1;     Optional : WindowLog (0 or 1 byte)    bit 0-2 : octal Fractional (1/8th)    bit 3-7 : Power of 2, with 0 = 1 KB (up to 2 TB)     Optional : dictID (0, 1, 2 or 4 bytes)    Automatic adaptation    0 : no dictID    1 : 1 - 255    2 : 256 - 65535    4 : all other values     Optional : content size (0, 1, 2, 4 or 8 bytes)    0 : unknown          (fcfs==0 and swl==0)    1 : 0-255 bytes      (fcfs==0 and swl==1)    2 : 256 - 65535+256  (fcfs==1)    4 : 0 - 4GB-1        (fcfs==2)    8 : 0 - 16EB-1       (fcfs==3) */
comment|/* Compressed Block, format description     Block = Literal Section - Sequences Section    Prerequisite : size of (compressed) block, maximum size of regenerated data     1) Literal Section     1.1) Header : 1-5 bytes         flags: 2 bits             00 compressed by Huff0             01 unused             10 is Raw (uncompressed)             11 is Rle             Note : using 01 => Huff0 with precomputed table ?             Note : delta map ? => compressed ?     1.1.1) Huff0-compressed literal block : 3-5 bytes             srcSize< 1 KB => 3 bytes (2-2-10-10) => single stream             srcSize< 1 KB => 3 bytes (2-2-10-10)             srcSize< 16KB => 4 bytes (2-2-14-14)             else           => 5 bytes (2-2-18-18)             big endian convention     1.1.2) Raw (uncompressed) literal block header : 1-3 bytes         size :  5 bits: (IS_RAW<<6) + (0<<4) + size                12 bits: (IS_RAW<<6) + (2<<4) + (size>>8)                         size&255                20 bits: (IS_RAW<<6) + (3<<4) + (size>>16)                         size>>8&255                         size&255     1.1.3) Rle (repeated single byte) literal block header : 1-3 bytes         size :  5 bits: (IS_RLE<<6) + (0<<4) + size                12 bits: (IS_RLE<<6) + (2<<4) + (size>>8)                         size&255                20 bits: (IS_RLE<<6) + (3<<4) + (size>>16)                         size>>8&255                         size&255     1.1.4) Huff0-compressed literal block, using precomputed CTables : 3-5 bytes             srcSize< 1 KB => 3 bytes (2-2-10-10) => single stream             srcSize< 1 KB => 3 bytes (2-2-10-10)             srcSize< 16KB => 4 bytes (2-2-14-14)             else           => 5 bytes (2-2-18-18)             big endian convention          1- CTable available (stored into workspace ?)         2- Small input (fast heuristic ? Full comparison ? depend on clevel ?)      1.2) Literal block content     1.2.1) Huff0 block, using sizes from header         See Huff0 format     1.2.2) Huff0 block, using prepared table     1.2.3) Raw content     1.2.4) single byte      2) Sequences section       TO DO */
comment|/** ZSTDv07_frameHeaderSize() : *   srcSize must be>= ZSTDv07_frameHeaderSize_min. *   @return : size of the Frame Header */
specifier|static
name|size_t
name|ZSTDv07_frameHeaderSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
name|ZSTDv07_frameHeaderSize_min
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|{
name|BYTE
specifier|const
name|fhd
init|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
index|[
literal|4
index|]
decl_stmt|;
name|U32
specifier|const
name|dictID
init|=
name|fhd
operator|&
literal|3
decl_stmt|;
name|U32
specifier|const
name|directMode
init|=
operator|(
name|fhd
operator|>>
literal|5
operator|)
operator|&
literal|1
decl_stmt|;
name|U32
specifier|const
name|fcsId
init|=
name|fhd
operator|>>
literal|6
decl_stmt|;
return|return
name|ZSTDv07_frameHeaderSize_min
operator|+
operator|!
name|directMode
operator|+
name|ZSTDv07_did_fieldSize
index|[
name|dictID
index|]
operator|+
name|ZSTDv07_fcs_fieldSize
index|[
name|fcsId
index|]
operator|+
operator|(
name|directMode
operator|&&
operator|!
name|ZSTDv07_fcs_fieldSize
index|[
name|fcsId
index|]
operator|)
return|;
block|}
block|}
comment|/** ZSTDv07_getFrameParams() : *   decode Frame Header, or require larger `srcSize`. *   @return : 0, `fparamsPtr` is correctly filled, *>0, `srcSize` is too small, result is expected `srcSize`, *             or an error code, which can be tested using ZSTDv07_isError() */
name|size_t
name|ZSTDv07_getFrameParams
parameter_list|(
name|ZSTDv07_frameParams
modifier|*
name|fparamsPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTDv07_frameHeaderSize_min
condition|)
return|return
name|ZSTDv07_frameHeaderSize_min
return|;
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|!=
name|ZSTDv07_MAGICNUMBER
condition|)
block|{
if|if
condition|(
operator|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTDv07_MAGIC_SKIPPABLE_START
condition|)
block|{
if|if
condition|(
name|srcSize
operator|<
name|ZSTDv07_skippableHeaderSize
condition|)
return|return
name|ZSTDv07_skippableHeaderSize
return|;
comment|/* magic number + skippable frame length */
name|memset
argument_list|(
name|fparamsPtr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fparamsPtr
argument_list|)
argument_list|)
expr_stmt|;
name|fparamsPtr
operator|->
name|frameContentSize
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fparamsPtr
operator|->
name|windowSize
operator|=
literal|0
expr_stmt|;
comment|/* windowSize==0 means a frame is skippable */
return|return
literal|0
return|;
block|}
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
block|}
comment|/* ensure there is enough `srcSize` to fully read/decode frame header */
block|{
name|size_t
specifier|const
name|fhsize
init|=
name|ZSTDv07_frameHeaderSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|fhsize
condition|)
return|return
name|fhsize
return|;
block|}
block|{
name|BYTE
specifier|const
name|fhdByte
init|=
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|pos
init|=
literal|5
decl_stmt|;
name|U32
specifier|const
name|dictIDSizeCode
init|=
name|fhdByte
operator|&
literal|3
decl_stmt|;
name|U32
specifier|const
name|checksumFlag
init|=
operator|(
name|fhdByte
operator|>>
literal|2
operator|)
operator|&
literal|1
decl_stmt|;
name|U32
specifier|const
name|directMode
init|=
operator|(
name|fhdByte
operator|>>
literal|5
operator|)
operator|&
literal|1
decl_stmt|;
name|U32
specifier|const
name|fcsID
init|=
name|fhdByte
operator|>>
literal|6
decl_stmt|;
name|U32
specifier|const
name|windowSizeMax
init|=
literal|1U
operator|<<
name|ZSTDv07_WINDOWLOG_MAX
decl_stmt|;
name|U32
name|windowSize
init|=
literal|0
decl_stmt|;
name|U32
name|dictID
init|=
literal|0
decl_stmt|;
name|U64
name|frameContentSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fhdByte
operator|&
literal|0x08
operator|)
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_unsupported
argument_list|)
return|;
comment|/* reserved bits, which must be zero */
if|if
condition|(
operator|!
name|directMode
condition|)
block|{
name|BYTE
specifier|const
name|wlByte
init|=
name|ip
index|[
name|pos
operator|++
index|]
decl_stmt|;
name|U32
specifier|const
name|windowLog
init|=
operator|(
name|wlByte
operator|>>
literal|3
operator|)
operator|+
name|ZSTDv07_WINDOWLOG_ABSOLUTEMIN
decl_stmt|;
if|if
condition|(
name|windowLog
operator|>
name|ZSTDv07_WINDOWLOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_unsupported
argument_list|)
return|;
name|windowSize
operator|=
operator|(
literal|1U
operator|<<
name|windowLog
operator|)
expr_stmt|;
name|windowSize
operator|+=
operator|(
name|windowSize
operator|>>
literal|3
operator|)
operator|*
operator|(
name|wlByte
operator|&
literal|7
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dictIDSizeCode
condition|)
block|{
default|default:
comment|/* impossible */
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|dictID
operator|=
name|ip
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dictID
operator|=
name|MEM_readLE16
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dictID
operator|=
name|MEM_readLE32
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|fcsID
condition|)
block|{
default|default:
comment|/* impossible */
case|case
literal|0
case|:
if|if
condition|(
name|directMode
condition|)
name|frameContentSize
operator|=
name|ip
index|[
name|pos
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|frameContentSize
operator|=
name|MEM_readLE16
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
operator|+
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|frameContentSize
operator|=
name|MEM_readLE32
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|frameContentSize
operator|=
name|MEM_readLE64
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|windowSize
condition|)
name|windowSize
operator|=
operator|(
name|U32
operator|)
name|frameContentSize
expr_stmt|;
if|if
condition|(
name|windowSize
operator|>
name|windowSizeMax
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_unsupported
argument_list|)
return|;
name|fparamsPtr
operator|->
name|frameContentSize
operator|=
name|frameContentSize
expr_stmt|;
name|fparamsPtr
operator|->
name|windowSize
operator|=
name|windowSize
expr_stmt|;
name|fparamsPtr
operator|->
name|dictID
operator|=
name|dictID
expr_stmt|;
name|fparamsPtr
operator|->
name|checksumFlag
operator|=
name|checksumFlag
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/** ZSTDv07_getDecompressedSize() : *   compatible with legacy mode *   @return : decompressed size if known, 0 otherwise               note : 0 can mean any of the following :                    - decompressed size is not provided within frame header                    - frame header unknown / not supported                    - frame header not completely provided (`srcSize` too small) */
name|unsigned
name|long
name|long
name|ZSTDv07_getDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
block|{
name|ZSTDv07_frameParams
name|fparams
decl_stmt|;
name|size_t
specifier|const
name|frResult
init|=
name|ZSTDv07_getFrameParams
argument_list|(
operator|&
name|fparams
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|frResult
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|fparams
operator|.
name|frameContentSize
return|;
block|}
block|}
comment|/** ZSTDv07_decodeFrameHeader() : *   `srcSize` must be the size provided by ZSTDv07_frameHeaderSize(). *   @return : 0 if success, or an error code, which can be tested using ZSTDv07_isError() */
specifier|static
name|size_t
name|ZSTDv07_decodeFrameHeader
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
specifier|const
name|result
init|=
name|ZSTDv07_getFrameParams
argument_list|(
operator|&
operator|(
name|dctx
operator|->
name|fParams
operator|)
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|dictID
operator|&&
operator|(
name|dctx
operator|->
name|dictID
operator|!=
name|dctx
operator|->
name|fParams
operator|.
name|dictID
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_wrong
argument_list|)
return|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_reset
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
typedef|typedef
struct|struct
block|{
name|blockType_t
name|blockType
decl_stmt|;
name|U32
name|origSize
decl_stmt|;
block|}
name|blockProperties_t
typedef|;
comment|/*! ZSTDv07_getcBlockSize() : *   Provides the size of compressed block from block header `src` */
name|size_t
name|ZSTDv07_getcBlockSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|blockProperties_t
modifier|*
name|bpPtr
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|in
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
name|U32
name|cSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTDv07_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|bpPtr
operator|->
name|blockType
operator|=
call|(
name|blockType_t
call|)
argument_list|(
operator|(
operator|*
name|in
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|cSize
operator|=
name|in
index|[
literal|2
index|]
operator|+
operator|(
name|in
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|in
index|[
literal|0
index|]
operator|&
literal|7
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bpPtr
operator|->
name|origSize
operator|=
operator|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
operator|)
condition|?
name|cSize
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
condition|)
return|return
literal|1
return|;
return|return
name|cSize
return|;
block|}
specifier|static
name|size_t
name|ZSTDv07_copyRawBlock
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|>
name|dstCapacity
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
return|return
name|srcSize
return|;
block|}
comment|/*! ZSTDv07_decodeLiteralsBlock() :     @return : nb of bytes read from src (< srcSize ) */
name|size_t
name|ZSTDv07_decodeLiteralsBlock
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
comment|/* note : srcSize< BLOCKSIZE */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|MIN_CBLOCK_SIZE
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
switch|switch
condition|(
call|(
name|litBlockType_t
call|)
argument_list|(
name|istart
index|[
literal|0
index|]
operator|>>
literal|6
argument_list|)
condition|)
block|{
case|case
name|lbt_huffman
case|:
block|{
name|size_t
name|litSize
decl_stmt|,
name|litCSize
decl_stmt|,
name|singleStream
init|=
literal|0
decl_stmt|;
name|U32
name|lhSize
init|=
operator|(
name|istart
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|3
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
literal|5
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* srcSize>= MIN_CBLOCK_SIZE == 3; here we need up to 5 for lhSize, + cSize (+nbSeq) */
switch|switch
condition|(
name|lhSize
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
default|default:
comment|/* note : default is impossible, since lhSize into [0..3] */
comment|/* 2 - 2 - 10 - 10 */
name|lhSize
operator|=
literal|3
expr_stmt|;
name|singleStream
operator|=
name|istart
index|[
literal|0
index|]
operator|&
literal|16
expr_stmt|;
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
name|istart
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
name|litCSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|1
index|]
operator|&
literal|3
operator|)
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 - 2 - 14 - 14 */
name|lhSize
operator|=
literal|4
expr_stmt|;
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|10
operator|)
operator|+
operator|(
name|istart
index|[
literal|1
index|]
operator|<<
literal|2
operator|)
operator|+
operator|(
name|istart
index|[
literal|2
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
name|litCSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|2
index|]
operator|&
literal|63
operator|)
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 2 - 2 - 18 - 18 */
name|lhSize
operator|=
literal|5
expr_stmt|;
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|14
operator|)
operator|+
operator|(
name|istart
index|[
literal|1
index|]
operator|<<
literal|6
operator|)
operator|+
operator|(
name|istart
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
name|litCSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|2
index|]
operator|&
literal|3
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|istart
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|4
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|litSize
operator|>
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|litCSize
operator|+
name|lhSize
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|singleStream
condition|?
name|HUFv07_decompress1X2_DCtx
argument_list|(
name|dctx
operator|->
name|hufTable
argument_list|,
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|)
else|:
name|HUFv07_decompress4X_hufOnly
argument_list|(
name|dctx
operator|->
name|hufTable
argument_list|,
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|)
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|dctx
operator|->
name|litEntropy
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
return|return
name|litCSize
operator|+
name|lhSize
return|;
block|}
case|case
name|lbt_repeat
case|:
block|{
name|size_t
name|litSize
decl_stmt|,
name|litCSize
decl_stmt|;
name|U32
name|lhSize
init|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|3
decl_stmt|;
if|if
condition|(
name|lhSize
operator|!=
literal|1
condition|)
comment|/* only case supported for now : small litSize, single stream */
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|dctx
operator|->
name|litEntropy
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
comment|/* 2 - 2 - 10 - 10 */
name|lhSize
operator|=
literal|3
expr_stmt|;
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
name|istart
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
name|litCSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|1
index|]
operator|&
literal|3
operator|)
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|litCSize
operator|+
name|lhSize
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|HUFv07_decompress1X4_usingDTable
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|,
name|dctx
operator|->
name|hufTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
return|return
name|litCSize
operator|+
name|lhSize
return|;
block|}
case|case
name|lbt_raw
case|:
block|{
name|size_t
name|litSize
decl_stmt|;
name|U32
name|lhSize
init|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|3
decl_stmt|;
switch|switch
condition|(
name|lhSize
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
default|default:
comment|/* note : default is impossible, since lhSize into [0..3] */
name|lhSize
operator|=
literal|1
expr_stmt|;
name|litSize
operator|=
name|istart
index|[
literal|0
index|]
operator|&
literal|31
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|istart
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lhSize
operator|+
name|litSize
operator|+
name|WILDCOPY_OVERLENGTH
operator|>
name|srcSize
condition|)
block|{
comment|/* risk reading beyond src buffer with wildcopy */
if|if
condition|(
name|litSize
operator|+
name|lhSize
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
return|return
name|lhSize
operator|+
name|litSize
return|;
block|}
comment|/* direct reference into compressed stream */
name|dctx
operator|->
name|litPtr
operator|=
name|istart
operator|+
name|lhSize
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
return|return
name|lhSize
operator|+
name|litSize
return|;
block|}
case|case
name|lbt_rle
case|:
block|{
name|size_t
name|litSize
decl_stmt|;
name|U32
name|lhSize
init|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|)
operator|>>
literal|4
operator|)
operator|&
literal|3
decl_stmt|;
switch|switch
condition|(
name|lhSize
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
default|default:
comment|/* note : default is impossible, since lhSize into [0..3] */
name|lhSize
operator|=
literal|1
expr_stmt|;
name|litSize
operator|=
name|istart
index|[
literal|0
index|]
operator|&
literal|31
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|litSize
operator|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|&
literal|15
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|istart
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|istart
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|srcSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* srcSize>= MIN_CBLOCK_SIZE == 3; here we need lhSize+1 = 4 */
break|break;
block|}
if|if
condition|(
name|litSize
operator|>
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|istart
index|[
name|lhSize
index|]
argument_list|,
name|litSize
operator|+
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
return|return
name|lhSize
operator|+
literal|1
return|;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
comment|/*! ZSTDv07_buildSeqTable() :     @return : nb bytes read from src,               or an error code if it fails, testable with ZSTDv07_isError() */
name|size_t
name|ZSTDv07_buildSeqTable
parameter_list|(
name|FSEv07_DTable
modifier|*
name|DTable
parameter_list|,
name|U32
name|type
parameter_list|,
name|U32
name|max
parameter_list|,
name|U32
name|maxLog
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|S16
modifier|*
name|defaultNorm
parameter_list|,
name|U32
name|defaultLog
parameter_list|,
name|U32
name|flagRepeatTable
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FSEv07_ENCODING_RLE
case|:
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
operator|(
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
operator|>
name|max
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|FSEv07_buildDTable_rle
argument_list|(
name|DTable
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
argument_list|)
expr_stmt|;
comment|/* if *src> max, data is corrupted */
return|return
literal|1
return|;
case|case
name|FSEv07_ENCODING_RAW
case|:
name|FSEv07_buildDTable
argument_list|(
name|DTable
argument_list|,
name|defaultNorm
argument_list|,
name|max
argument_list|,
name|defaultLog
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|FSEv07_ENCODING_STATIC
case|:
if|if
condition|(
operator|!
name|flagRepeatTable
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
return|return
literal|0
return|;
default|default :
comment|/* impossible */
case|case
name|FSEv07_ENCODING_DYNAMIC
case|:
block|{
name|U32
name|tableLog
decl_stmt|;
name|S16
name|norm
index|[
name|MaxSeq
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
specifier|const
name|headerSize
init|=
name|FSEv07_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|tableLog
operator|>
name|maxLog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|FSEv07_buildDTable
argument_list|(
name|DTable
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|)
expr_stmt|;
return|return
name|headerSize
return|;
block|}
block|}
block|}
name|size_t
name|ZSTDv07_decodeSeqHeaders
parameter_list|(
name|int
modifier|*
name|nbSeqPtr
parameter_list|,
name|FSEv07_DTable
modifier|*
name|DTableLL
parameter_list|,
name|FSEv07_DTable
modifier|*
name|DTableML
parameter_list|,
name|FSEv07_DTable
modifier|*
name|DTableOffb
parameter_list|,
name|U32
name|flagRepeatTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
comment|/* check */
if|if
condition|(
name|srcSize
operator|<
name|MIN_SEQUENCES_SIZE
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* SeqHead */
block|{
name|int
name|nbSeq
init|=
operator|*
name|ip
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|nbSeq
condition|)
block|{
operator|*
name|nbSeqPtr
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nbSeq
operator|>
literal|0x7F
condition|)
block|{
if|if
condition|(
name|nbSeq
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|ip
operator|+
literal|2
operator|>
name|iend
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|nbSeq
operator|=
name|MEM_readLE16
argument_list|(
name|ip
argument_list|)
operator|+
name|LONGNBSEQ
operator|,
name|ip
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|>=
name|iend
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|nbSeq
operator|=
operator|(
operator|(
name|nbSeq
operator|-
literal|0x80
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
name|ip
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|nbSeqPtr
operator|=
name|nbSeq
expr_stmt|;
block|}
comment|/* FSE table descriptors */
block|{
name|U32
specifier|const
name|LLtype
init|=
operator|*
name|ip
operator|>>
literal|6
decl_stmt|;
name|U32
specifier|const
name|OFtype
init|=
operator|(
operator|*
name|ip
operator|>>
literal|4
operator|)
operator|&
literal|3
decl_stmt|;
name|U32
specifier|const
name|MLtype
init|=
operator|(
operator|*
name|ip
operator|>>
literal|2
operator|)
operator|&
literal|3
decl_stmt|;
name|ip
operator|++
expr_stmt|;
comment|/* check */
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : all 3 are "raw", hence no header, but at least xxLog bits per type */
comment|/* Build DTables */
block|{
name|size_t
specifier|const
name|llhSize
init|=
name|ZSTDv07_buildSeqTable
argument_list|(
name|DTableLL
argument_list|,
name|LLtype
argument_list|,
name|MaxLL
argument_list|,
name|LLFSELog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|LL_defaultNorm
argument_list|,
name|LL_defaultNormLog
argument_list|,
name|flagRepeatTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|llhSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|llhSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|ofhSize
init|=
name|ZSTDv07_buildSeqTable
argument_list|(
name|DTableOffb
argument_list|,
name|OFtype
argument_list|,
name|MaxOff
argument_list|,
name|OffFSELog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|OF_defaultNorm
argument_list|,
name|OF_defaultNormLog
argument_list|,
name|flagRepeatTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|ofhSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|ofhSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|mlhSize
init|=
name|ZSTDv07_buildSeqTable
argument_list|(
name|DTableML
argument_list|,
name|MLtype
argument_list|,
name|MaxML
argument_list|,
name|MLFSELog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|ML_defaultNorm
argument_list|,
name|ML_defaultNormLog
argument_list|,
name|flagRepeatTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|mlhSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|mlhSize
expr_stmt|;
block|}
block|}
return|return
name|ip
operator|-
name|istart
return|;
block|}
typedef|typedef
struct|struct
block|{
name|size_t
name|litLength
decl_stmt|;
name|size_t
name|matchLength
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
block|}
name|seq_t
typedef|;
typedef|typedef
struct|struct
block|{
name|BITv07_DStream_t
name|DStream
decl_stmt|;
name|FSEv07_DState_t
name|stateLL
decl_stmt|;
name|FSEv07_DState_t
name|stateOffb
decl_stmt|;
name|FSEv07_DState_t
name|stateML
decl_stmt|;
name|size_t
name|prevOffset
index|[
name|ZSTDv07_REP_INIT
index|]
decl_stmt|;
block|}
name|seqState_t
typedef|;
specifier|static
name|seq_t
name|ZSTDv07_decodeSequence
parameter_list|(
name|seqState_t
modifier|*
name|seqState
parameter_list|)
block|{
name|seq_t
name|seq
decl_stmt|;
name|U32
specifier|const
name|llCode
init|=
name|FSEv07_peekSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateLL
operator|)
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|mlCode
init|=
name|FSEv07_peekSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateML
operator|)
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|ofCode
init|=
name|FSEv07_peekSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateOffb
operator|)
argument_list|)
decl_stmt|;
comment|/*<= maxOff, by table construction */
name|U32
specifier|const
name|llBits
init|=
name|LL_bits
index|[
name|llCode
index|]
decl_stmt|;
name|U32
specifier|const
name|mlBits
init|=
name|ML_bits
index|[
name|mlCode
index|]
decl_stmt|;
name|U32
specifier|const
name|ofBits
init|=
name|ofCode
decl_stmt|;
name|U32
specifier|const
name|totalBits
init|=
name|llBits
operator|+
name|mlBits
operator|+
name|ofBits
decl_stmt|;
specifier|static
specifier|const
name|U32
name|LL_base
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|18
block|,
literal|20
block|,
literal|22
block|,
literal|24
block|,
literal|28
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|64
block|,
literal|0x80
block|,
literal|0x100
block|,
literal|0x200
block|,
literal|0x400
block|,
literal|0x800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0x10000
block|}
decl_stmt|;
specifier|static
specifier|const
name|U32
name|ML_base
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|37
block|,
literal|39
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|0x83
block|,
literal|0x103
block|,
literal|0x203
block|,
literal|0x403
block|,
literal|0x803
block|,
literal|0x1003
block|,
literal|0x2003
block|,
literal|0x4003
block|,
literal|0x8003
block|,
literal|0x10003
block|}
decl_stmt|;
specifier|static
specifier|const
name|U32
name|OF_base
index|[
name|MaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|0xD
block|,
literal|0x1D
block|,
literal|0x3D
block|,
literal|0x7D
block|,
literal|0xFD
block|,
literal|0x1FD
block|,
literal|0x3FD
block|,
literal|0x7FD
block|,
literal|0xFFD
block|,
literal|0x1FFD
block|,
literal|0x3FFD
block|,
literal|0x7FFD
block|,
literal|0xFFFD
block|,
literal|0x1FFFD
block|,
literal|0x3FFFD
block|,
literal|0x7FFFD
block|,
literal|0xFFFFD
block|,
literal|0x1FFFFD
block|,
literal|0x3FFFFD
block|,
literal|0x7FFFFD
block|,
literal|0xFFFFFD
block|,
literal|0x1FFFFFD
block|,
literal|0x3FFFFFD
block|,
literal|0x7FFFFFD
block|,
literal|0xFFFFFFD
block|}
decl_stmt|;
comment|/* sequence */
block|{
name|size_t
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|ofCode
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|offset
operator|=
name|OF_base
index|[
name|ofCode
index|]
operator|+
name|BITv07_readBits
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|,
name|ofBits
argument_list|)
expr_stmt|;
comment|/*<=  (ZSTDv07_WINDOWLOG_MAX-1) bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BITv07_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ofCode
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|llCode
operator|==
literal|0
operator|)
operator|&
operator|(
name|offset
operator|<=
literal|1
operator|)
condition|)
name|offset
operator|=
literal|1
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|size_t
specifier|const
name|temp
init|=
name|seqState
operator|->
name|prevOffset
index|[
name|offset
index|]
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|1
condition|)
name|seqState
operator|->
name|prevOffset
index|[
literal|2
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|=
name|offset
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|seqState
operator|->
name|prevOffset
index|[
literal|2
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|.
name|matchLength
operator|=
name|ML_base
index|[
name|mlCode
index|]
operator|+
operator|(
operator|(
name|mlCode
operator|>
literal|31
operator|)
condition|?
name|BITv07_readBits
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|,
name|mlBits
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/*<=  16 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|&&
operator|(
name|mlBits
operator|+
name|llBits
operator|>
literal|24
operator|)
condition|)
name|BITv07_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
name|seq
operator|.
name|litLength
operator|=
name|LL_base
index|[
name|llCode
index|]
operator|+
operator|(
operator|(
name|llCode
operator|>
literal|15
operator|)
condition|?
name|BITv07_readBits
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|,
name|llBits
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/*<=  16 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|||
operator|(
name|totalBits
operator|>
literal|64
operator|-
literal|7
operator|-
operator|(
name|LLFSELog
operator|+
name|MLFSELog
operator|+
name|OffFSELog
operator|)
operator|)
condition|)
name|BITv07_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
comment|/* ANS state update */
name|FSEv07_updateState
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateLL
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
comment|/*<=  9 bits */
name|FSEv07_updateState
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateML
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
comment|/*<=  9 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BITv07_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
comment|/*<= 18 bits */
name|FSEv07_updateState
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateOffb
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
comment|/*<=  8 bits */
return|return
name|seq
return|;
block|}
specifier|static
name|size_t
name|ZSTDv07_execSequence
parameter_list|(
name|BYTE
modifier|*
name|op
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|,
name|seq_t
name|sequence
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litPtr
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|litLimit
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|oLitEnd
init|=
name|op
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
name|size_t
specifier|const
name|sequenceLength
init|=
name|sequence
operator|.
name|litLength
operator|+
name|sequence
operator|.
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oMatchEnd
init|=
name|op
operator|+
name|sequenceLength
decl_stmt|;
comment|/* risk : address space overflow (32-bits) */
name|BYTE
modifier|*
specifier|const
name|oend_w
init|=
name|oend
operator|-
name|WILDCOPY_OVERLENGTH
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLitEnd
init|=
operator|*
name|litPtr
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
name|oLitEnd
operator|-
name|sequence
operator|.
name|offset
decl_stmt|;
comment|/* check */
if|if
condition|(
operator|(
name|oLitEnd
operator|>
name|oend_w
operator|)
operator||
operator|(
name|oMatchEnd
operator|>
name|oend
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* last match must start at a minimum distance of WILDCOPY_OVERLENGTH from oend */
if|if
condition|(
name|iLitEnd
operator|>
name|litLimit
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* over-read beyond lit buffer */
comment|/* copy Literals */
name|ZSTDv07_wildcopy
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|,
name|sequence
operator|.
name|litLength
argument_list|)
expr_stmt|;
comment|/* note : since oLitEnd<= oend-WILDCOPY_OVERLENGTH, no risk of overwrite beyond oend */
name|op
operator|=
name|oLitEnd
expr_stmt|;
operator|*
name|litPtr
operator|=
name|iLitEnd
expr_stmt|;
comment|/* update for next sequence */
comment|/* copy Match */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|base
argument_list|)
condition|)
block|{
comment|/* offset beyond prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|vBase
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|match
operator|=
name|dictEnd
operator|-
operator|(
name|base
operator|-
name|match
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|+
name|sequence
operator|.
name|matchLength
operator|<=
name|dictEnd
condition|)
block|{
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|sequence
operator|.
name|matchLength
argument_list|)
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
comment|/* span extDict& currentPrefixSegment */
block|{
name|size_t
specifier|const
name|length1
init|=
name|dictEnd
operator|-
name|match
decl_stmt|;
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|op
operator|=
name|oLitEnd
operator|+
name|length1
expr_stmt|;
name|sequence
operator|.
name|matchLength
operator|-=
name|length1
expr_stmt|;
name|match
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|op
operator|>
name|oend_w
operator|||
name|sequence
operator|.
name|matchLength
operator|<
name|MINMATCH
condition|)
block|{
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
block|}
block|}
comment|/* Requirement: op<= oend_w */
comment|/* match within prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|<
literal|8
condition|)
block|{
comment|/* close range match, overlap */
specifier|static
specifier|const
name|U32
name|dec32table
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|/* added */
specifier|static
specifier|const
name|int
name|dec64table
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
comment|/* substracted */
name|int
specifier|const
name|sub2
init|=
name|dec64table
index|[
name|sequence
operator|.
name|offset
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|match
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|match
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|match
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|match
index|[
literal|3
index|]
expr_stmt|;
name|match
operator|+=
name|dec32table
index|[
name|sequence
operator|.
name|offset
index|]
expr_stmt|;
name|ZSTDv07_copy4
argument_list|(
name|op
operator|+
literal|4
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|match
operator|-=
name|sub2
expr_stmt|;
block|}
else|else
block|{
name|ZSTDv07_copy8
argument_list|(
name|op
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
literal|8
expr_stmt|;
name|match
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
operator|-
operator|(
literal|16
operator|-
name|MINMATCH
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|<
name|oend_w
condition|)
block|{
name|ZSTDv07_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
name|oend_w
operator|-
name|op
argument_list|)
expr_stmt|;
name|match
operator|+=
name|oend_w
operator|-
name|op
expr_stmt|;
name|op
operator|=
name|oend_w
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ZSTDv07_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
operator|(
name|ptrdiff_t
operator|)
name|sequence
operator|.
name|matchLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* works even if matchLength< 8 */
block|}
return|return
name|sequenceLength
return|;
block|}
specifier|static
name|size_t
name|ZSTDv07_decompressSequences
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|seqStart
parameter_list|,
name|size_t
name|seqSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|seqStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|seqSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
init|=
name|dctx
operator|->
name|litPtr
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
name|litPtr
operator|+
name|dctx
operator|->
name|litSize
decl_stmt|;
name|FSEv07_DTable
modifier|*
name|DTableLL
init|=
name|dctx
operator|->
name|LLTable
decl_stmt|;
name|FSEv07_DTable
modifier|*
name|DTableML
init|=
name|dctx
operator|->
name|MLTable
decl_stmt|;
name|FSEv07_DTable
modifier|*
name|DTableOffb
init|=
name|dctx
operator|->
name|OffTable
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|vBase
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|dictEnd
operator|)
decl_stmt|;
name|int
name|nbSeq
decl_stmt|;
comment|/* Build Decoding Tables */
block|{
name|size_t
specifier|const
name|seqHSize
init|=
name|ZSTDv07_decodeSeqHeaders
argument_list|(
operator|&
name|nbSeq
argument_list|,
name|DTableLL
argument_list|,
name|DTableML
argument_list|,
name|DTableOffb
argument_list|,
name|dctx
operator|->
name|fseEntropy
argument_list|,
name|ip
argument_list|,
name|seqSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|seqHSize
argument_list|)
condition|)
return|return
name|seqHSize
return|;
name|ip
operator|+=
name|seqHSize
expr_stmt|;
block|}
comment|/* Regen sequences */
if|if
condition|(
name|nbSeq
condition|)
block|{
name|seqState_t
name|seqState
decl_stmt|;
name|dctx
operator|->
name|fseEntropy
operator|=
literal|1
expr_stmt|;
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTDv07_REP_INIT
condition|;
name|i
operator|++
control|)
name|seqState
operator|.
name|prevOffset
index|[
name|i
index|]
operator|=
name|dctx
operator|->
name|rep
index|[
name|i
index|]
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BITv07_initDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
decl_stmt|;
if|if
condition|(
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
name|FSEv07_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateLL
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableLL
argument_list|)
expr_stmt|;
name|FSEv07_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateOffb
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableOffb
argument_list|)
expr_stmt|;
name|FSEv07_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateML
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableML
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|BITv07_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
operator|<=
name|BITv07_DStream_completed
operator|)
operator|&&
name|nbSeq
condition|;
control|)
block|{
name|nbSeq
operator|--
expr_stmt|;
block|{
name|seq_t
specifier|const
name|sequence
init|=
name|ZSTDv07_decodeSequence
argument_list|(
operator|&
name|seqState
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|oneSeqSize
init|=
name|ZSTDv07_execSequence
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequence
argument_list|,
operator|&
name|litPtr
argument_list|,
name|litEnd
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|oneSeqSize
argument_list|)
condition|)
return|return
name|oneSeqSize
return|;
name|op
operator|+=
name|oneSeqSize
expr_stmt|;
block|}
block|}
comment|/* check if reached exact end */
if|if
condition|(
name|nbSeq
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* save reps for next block */
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTDv07_REP_INIT
condition|;
name|i
operator|++
control|)
name|dctx
operator|->
name|rep
index|[
name|i
index|]
operator|=
call|(
name|U32
call|)
argument_list|(
name|seqState
operator|.
name|prevOffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* last literal segment */
block|{
name|size_t
specifier|const
name|lastLLSize
init|=
name|litEnd
operator|-
name|litPtr
decl_stmt|;
comment|//if (litPtr> litEnd) return ERROR(corruption_detected);   /* too many literals already used */
if|if
condition|(
name|lastLLSize
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oend
operator|-
name|op
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|litPtr
argument_list|,
name|lastLLSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|lastLLSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
specifier|static
name|void
name|ZSTDv07_checkContinuity
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|!=
name|dctx
operator|->
name|previousDstEnd
condition|)
block|{
comment|/* not contiguous */
name|dctx
operator|->
name|dictEnd
operator|=
name|dctx
operator|->
name|previousDstEnd
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dst
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|dst
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|dst
expr_stmt|;
block|}
block|}
specifier|static
name|size_t
name|ZSTDv07_decompressBlock_internal
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* blockType == blockCompressed */
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
if|if
condition|(
name|srcSize
operator|>=
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* Decode literals sub-block */
block|{
name|size_t
specifier|const
name|litCSize
init|=
name|ZSTDv07_decodeLiteralsBlock
argument_list|(
name|dctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|litCSize
argument_list|)
condition|)
return|return
name|litCSize
return|;
name|ip
operator|+=
name|litCSize
expr_stmt|;
name|srcSize
operator|-=
name|litCSize
expr_stmt|;
block|}
return|return
name|ZSTDv07_decompressSequences
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|ip
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_decompressBlock
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
name|dSize
decl_stmt|;
name|ZSTDv07_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dSize
operator|=
name|ZSTDv07_decompressBlock_internal
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|dSize
expr_stmt|;
return|return
name|dSize
return|;
block|}
comment|/** ZSTDv07_insertBlock() :     insert `src` block into `dctx` history. Useful to track uncompressed blocks. */
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_insertBlock
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|blockStart
parameter_list|,
name|size_t
name|blockSize
parameter_list|)
block|{
name|ZSTDv07_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|blockStart
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|blockStart
operator|+
name|blockSize
expr_stmt|;
return|return
name|blockSize
return|;
block|}
name|size_t
name|ZSTDv07_generateNxBytes
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|BYTE
name|byte
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|>
name|dstCapacity
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memset
argument_list|(
name|dst
argument_list|,
name|byte
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
comment|/*! ZSTDv07_decompressFrame() : *   `dctx` must be properly initialized */
specifier|static
name|size_t
name|ZSTDv07_decompressFrame
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|srcSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstCapacity
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
comment|/* check */
if|if
condition|(
name|srcSize
operator|<
name|ZSTDv07_frameHeaderSize_min
operator|+
name|ZSTDv07_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* Frame Header */
block|{
name|size_t
specifier|const
name|frameHeaderSize
init|=
name|ZSTDv07_frameHeaderSize
argument_list|(
name|src
argument_list|,
name|ZSTDv07_frameHeaderSize_min
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|frameHeaderSize
argument_list|)
condition|)
return|return
name|frameHeaderSize
return|;
if|if
condition|(
name|srcSize
operator|<
name|frameHeaderSize
operator|+
name|ZSTDv07_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|ZSTDv07_decodeFrameHeader
argument_list|(
name|dctx
argument_list|,
name|src
argument_list|,
name|frameHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|frameHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|frameHeaderSize
expr_stmt|;
block|}
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|decodedSize
decl_stmt|;
name|blockProperties_t
name|blockProperties
decl_stmt|;
name|size_t
specifier|const
name|cBlockSize
init|=
name|ZSTDv07_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
name|ip
operator|+=
name|ZSTDv07_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTDv07_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|cBlockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
switch|switch
condition|(
name|blockProperties
operator|.
name|blockType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|decodedSize
operator|=
name|ZSTDv07_decompressBlock_internal
argument_list|(
name|dctx
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|cBlockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|decodedSize
operator|=
name|ZSTDv07_copyRawBlock
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|cBlockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
name|decodedSize
operator|=
name|ZSTDv07_generateNxBytes
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
operator|*
name|ip
argument_list|,
name|blockProperties
operator|.
name|origSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_end
case|:
comment|/* end of frame */
if|if
condition|(
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|decodedSize
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
if|if
condition|(
name|blockProperties
operator|.
name|blockType
operator|==
name|bt_end
condition|)
break|break;
comment|/* bt_end */
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_update
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|,
name|op
argument_list|,
name|decodedSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|decodedSize
expr_stmt|;
name|ip
operator|+=
name|cBlockSize
expr_stmt|;
name|remainingSize
operator|-=
name|cBlockSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
comment|/*! ZSTDv07_decompress_usingPreparedDCtx() : *   Same as ZSTDv07_decompress_usingDict, but using a reference context `preparedDCtx`, where dictionary has been loaded. *   It avoids reloading the dictionary each time. *   `preparedDCtx` must have been properly initialized using ZSTDv07_decompressBegin_usingDict(). *   Requires 2 contexts : 1 for reference (preparedDCtx), which will not be modified, and 1 to run the decompression operation (dctx) */
name|size_t
name|ZSTDv07_decompress_usingPreparedDCtx
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|ZSTDv07_DCtx
modifier|*
name|refDCtx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|ZSTDv07_copyDCtx
argument_list|(
name|dctx
argument_list|,
name|refDCtx
argument_list|)
expr_stmt|;
name|ZSTDv07_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
name|ZSTDv07_decompressFrame
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_decompress_usingDict
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|ZSTDv07_decompressBegin_usingDict
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|ZSTDv07_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
name|ZSTDv07_decompressFrame
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_decompressDCtx
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTDv07_decompress_usingDict
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ZSTDv07_HEAPMODE
argument_list|)
operator|&&
operator|(
name|ZSTDv07_HEAPMODE
operator|==
literal|1
operator|)
name|size_t
name|regenSize
decl_stmt|;
name|ZSTDv07_DCtx
modifier|*
specifier|const
name|dctx
init|=
name|ZSTDv07_createDCtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|regenSize
operator|=
name|ZSTDv07_decompressDCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
name|ZSTDv07_freeDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|regenSize
return|;
else|#
directive|else
comment|/* stack mode */
name|ZSTDv07_DCtx
name|dctx
decl_stmt|;
return|return
name|ZSTDv07_decompressDCtx
argument_list|(
operator|&
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
endif|#
directive|endif
block|}
name|size_t
name|ZSTDv07_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
comment|/* check */
if|if
condition|(
name|srcSize
operator|<
name|ZSTDv07_frameHeaderSize_min
operator|+
name|ZSTDv07_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* Frame Header */
block|{
name|size_t
specifier|const
name|frameHeaderSize
init|=
name|ZSTDv07_frameHeaderSize
argument_list|(
name|src
argument_list|,
name|ZSTDv07_frameHeaderSize_min
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|frameHeaderSize
argument_list|)
condition|)
return|return
name|frameHeaderSize
return|;
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|!=
name|ZSTDv07_MAGICNUMBER
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
if|if
condition|(
name|srcSize
operator|<
name|frameHeaderSize
operator|+
name|ZSTDv07_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|frameHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|frameHeaderSize
expr_stmt|;
block|}
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|blockProperties_t
name|blockProperties
decl_stmt|;
name|size_t
specifier|const
name|cBlockSize
init|=
name|ZSTDv07_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|remainingSize
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
name|ip
operator|+=
name|ZSTDv07_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTDv07_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|blockProperties
operator|.
name|blockType
operator|==
name|bt_end
condition|)
break|break;
if|if
condition|(
name|cBlockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|cBlockSize
expr_stmt|;
name|remainingSize
operator|-=
name|cBlockSize
expr_stmt|;
block|}
return|return
name|ip
operator|-
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
return|;
block|}
comment|/*_****************************** *  Streaming Decompression API ********************************/
name|size_t
name|ZSTDv07_nextSrcSizeToDecompress
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|dctx
operator|->
name|expected
return|;
block|}
name|int
name|ZSTDv07_isSkipFrame
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|dctx
operator|->
name|stage
operator|==
name|ZSTDds_skipFrame
return|;
block|}
comment|/** ZSTDv07_decompressContinue() : *   @return : nb of bytes generated into `dst` (necessarily<= `dstCapacity) *             or an error code, which can be tested using ZSTDv07_isError() */
name|size_t
name|ZSTDv07_decompressContinue
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|srcSize
operator|!=
name|dctx
operator|->
name|expected
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|dstCapacity
condition|)
name|ZSTDv07_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dctx
operator|->
name|stage
condition|)
block|{
case|case
name|ZSTDds_getFrameHeaderSize
case|:
if|if
condition|(
name|srcSize
operator|!=
name|ZSTDv07_frameHeaderSize_min
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* impossible */
if|if
condition|(
operator|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTDv07_MAGIC_SKIPPABLE_START
condition|)
block|{
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
argument_list|,
name|src
argument_list|,
name|ZSTDv07_frameHeaderSize_min
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|ZSTDv07_skippableHeaderSize
operator|-
name|ZSTDv07_frameHeaderSize_min
expr_stmt|;
comment|/* magic number + skippable frame length */
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeSkippableHeader
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dctx
operator|->
name|headerSize
operator|=
name|ZSTDv07_frameHeaderSize
argument_list|(
name|src
argument_list|,
name|ZSTDv07_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|dctx
operator|->
name|headerSize
argument_list|)
condition|)
return|return
name|dctx
operator|->
name|headerSize
return|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
argument_list|,
name|src
argument_list|,
name|ZSTDv07_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|headerSize
operator|>
name|ZSTDv07_frameHeaderSize_min
condition|)
block|{
name|dctx
operator|->
name|expected
operator|=
name|dctx
operator|->
name|headerSize
operator|-
name|ZSTDv07_frameHeaderSize_min
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeFrameHeader
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
comment|/* not necessary to copy more */
comment|/* fall-through */
case|case
name|ZSTDds_decodeFrameHeader
case|:
block|{
name|size_t
name|result
decl_stmt|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
operator|+
name|ZSTDv07_frameHeaderSize_min
argument_list|,
name|src
argument_list|,
name|dctx
operator|->
name|expected
argument_list|)
expr_stmt|;
name|result
operator|=
name|ZSTDv07_decodeFrameHeader
argument_list|(
name|dctx
argument_list|,
name|dctx
operator|->
name|headerBuffer
argument_list|,
name|dctx
operator|->
name|headerSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
name|dctx
operator|->
name|expected
operator|=
name|ZSTDv07_blockHeaderSize
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_decodeBlockHeader
case|:
block|{
name|blockProperties_t
name|bp
decl_stmt|;
name|size_t
specifier|const
name|cBlockSize
init|=
name|ZSTDv07_getcBlockSize
argument_list|(
name|src
argument_list|,
name|ZSTDv07_blockHeaderSize
argument_list|,
operator|&
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
if|if
condition|(
name|bp
operator|.
name|blockType
operator|==
name|bt_end
condition|)
block|{
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
block|{
name|U64
specifier|const
name|h64
init|=
name|XXH64_digest
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|h32
init|=
call|(
name|U32
call|)
argument_list|(
name|h64
operator|>>
literal|11
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|22
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|U32
specifier|const
name|check32
init|=
name|ip
index|[
literal|2
index|]
operator|+
operator|(
name|ip
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|ip
index|[
literal|0
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|16
operator|)
decl_stmt|;
if|if
condition|(
name|check32
operator|!=
name|h32
condition|)
return|return
name|ERROR
argument_list|(
name|checksum_wrong
argument_list|)
return|;
block|}
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
block|}
else|else
block|{
name|dctx
operator|->
name|expected
operator|=
name|cBlockSize
expr_stmt|;
name|dctx
operator|->
name|bType
operator|=
name|bp
operator|.
name|blockType
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decompressBlock
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_decompressBlock
case|:
block|{
name|size_t
name|rSize
decl_stmt|;
switch|switch
condition|(
name|dctx
operator|->
name|bType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|rSize
operator|=
name|ZSTDv07_decompressBlock_internal
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|rSize
operator|=
name|ZSTDv07_copyRawBlock
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* not yet handled */
break|break;
case|case
name|bt_end
case|:
comment|/* should never happen (filtered at phase 1) */
name|rSize
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|ZSTDv07_blockHeaderSize
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|rSize
expr_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|rSize
argument_list|)
condition|)
return|return
name|rSize
return|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_update
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|,
name|dst
argument_list|,
name|rSize
argument_list|)
expr_stmt|;
return|return
name|rSize
return|;
block|}
case|case
name|ZSTDds_decodeSkippableHeader
case|:
block|{
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
operator|+
name|ZSTDv07_frameHeaderSize_min
argument_list|,
name|src
argument_list|,
name|dctx
operator|->
name|expected
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|MEM_readLE32
argument_list|(
name|dctx
operator|->
name|headerBuffer
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_skipFrame
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_skipFrame
case|:
block|{
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
specifier|static
name|size_t
name|ZSTDv07_refDictContent
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|dctx
operator|->
name|dictEnd
operator|=
name|dctx
operator|->
name|previousDstEnd
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|dict
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
name|dictSize
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|size_t
name|ZSTDv07_loadEntropy
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|dict
parameter_list|,
name|size_t
specifier|const
name|dictSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|dictPtr
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|dict
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictPtr
operator|+
name|dictSize
decl_stmt|;
block|{
name|size_t
specifier|const
name|hSize
init|=
name|HUFv07_readDTableX4
argument_list|(
name|dctx
operator|->
name|hufTable
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUFv07_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dictPtr
operator|+=
name|hSize
expr_stmt|;
block|}
block|{
name|short
name|offcodeNCount
index|[
name|MaxOff
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|offcodeMaxValue
init|=
name|MaxOff
decl_stmt|,
name|offcodeLog
decl_stmt|;
name|size_t
specifier|const
name|offcodeHeaderSize
init|=
name|FSEv07_readNCount
argument_list|(
name|offcodeNCount
argument_list|,
operator|&
name|offcodeMaxValue
argument_list|,
operator|&
name|offcodeLog
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|offcodeHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
if|if
condition|(
name|offcodeLog
operator|>
name|OffFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|FSEv07_buildDTable
argument_list|(
name|dctx
operator|->
name|OffTable
argument_list|,
name|offcodeNCount
argument_list|,
name|offcodeMaxValue
argument_list|,
name|offcodeLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|}
name|dictPtr
operator|+=
name|offcodeHeaderSize
expr_stmt|;
block|}
block|{
name|short
name|matchlengthNCount
index|[
name|MaxML
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|matchlengthMaxValue
init|=
name|MaxML
decl_stmt|,
name|matchlengthLog
decl_stmt|;
name|size_t
specifier|const
name|matchlengthHeaderSize
init|=
name|FSEv07_readNCount
argument_list|(
name|matchlengthNCount
argument_list|,
operator|&
name|matchlengthMaxValue
argument_list|,
operator|&
name|matchlengthLog
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|matchlengthHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
if|if
condition|(
name|matchlengthLog
operator|>
name|MLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|FSEv07_buildDTable
argument_list|(
name|dctx
operator|->
name|MLTable
argument_list|,
name|matchlengthNCount
argument_list|,
name|matchlengthMaxValue
argument_list|,
name|matchlengthLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|}
name|dictPtr
operator|+=
name|matchlengthHeaderSize
expr_stmt|;
block|}
block|{
name|short
name|litlengthNCount
index|[
name|MaxLL
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|litlengthMaxValue
init|=
name|MaxLL
decl_stmt|,
name|litlengthLog
decl_stmt|;
name|size_t
specifier|const
name|litlengthHeaderSize
init|=
name|FSEv07_readNCount
argument_list|(
name|litlengthNCount
argument_list|,
operator|&
name|litlengthMaxValue
argument_list|,
operator|&
name|litlengthLog
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|litlengthHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
if|if
condition|(
name|litlengthLog
operator|>
name|LLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|FSEv07_buildDTable
argument_list|(
name|dctx
operator|->
name|LLTable
argument_list|,
name|litlengthNCount
argument_list|,
name|litlengthMaxValue
argument_list|,
name|litlengthLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSEv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|}
name|dictPtr
operator|+=
name|litlengthHeaderSize
expr_stmt|;
block|}
if|if
condition|(
name|dictPtr
operator|+
literal|12
operator|>
name|dictEnd
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dctx
operator|->
name|rep
index|[
literal|0
index|]
operator|=
name|MEM_readLE32
argument_list|(
name|dictPtr
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|rep
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|dctx
operator|->
name|rep
index|[
literal|0
index|]
operator|>=
name|dictSize
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dctx
operator|->
name|rep
index|[
literal|1
index|]
operator|=
name|MEM_readLE32
argument_list|(
name|dictPtr
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|rep
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|dctx
operator|->
name|rep
index|[
literal|1
index|]
operator|>=
name|dictSize
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dctx
operator|->
name|rep
index|[
literal|2
index|]
operator|=
name|MEM_readLE32
argument_list|(
name|dictPtr
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|rep
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|dctx
operator|->
name|rep
index|[
literal|2
index|]
operator|>=
name|dictSize
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dictPtr
operator|+=
literal|12
expr_stmt|;
name|dctx
operator|->
name|litEntropy
operator|=
name|dctx
operator|->
name|fseEntropy
operator|=
literal|1
expr_stmt|;
return|return
name|dictPtr
operator|-
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|dict
return|;
block|}
specifier|static
name|size_t
name|ZSTDv07_decompress_insertDictionary
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
if|if
condition|(
name|dictSize
operator|<
literal|8
condition|)
return|return
name|ZSTDv07_refDictContent
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
block|{
name|U32
specifier|const
name|magic
init|=
name|MEM_readLE32
argument_list|(
name|dict
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic
operator|!=
name|ZSTDv07_DICT_MAGIC
condition|)
block|{
return|return
name|ZSTDv07_refDictContent
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
comment|/* pure content mode */
block|}
block|}
name|dctx
operator|->
name|dictID
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* load entropy tables */
name|dict
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
literal|8
expr_stmt|;
name|dictSize
operator|-=
literal|8
expr_stmt|;
block|{
name|size_t
specifier|const
name|eSize
init|=
name|ZSTDv07_loadEntropy
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|eSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dict
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
name|eSize
expr_stmt|;
name|dictSize
operator|-=
name|eSize
expr_stmt|;
block|}
comment|/* reference dictionary content */
return|return
name|ZSTDv07_refDictContent
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_decompressBegin_usingDict
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTDv07_decompressBegin
argument_list|(
name|dctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
if|if
condition|(
name|dict
operator|&&
name|dictSize
condition|)
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTDv07_decompress_insertDictionary
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
struct|struct
name|ZSTDv07_DDict_s
block|{
name|void
modifier|*
name|dict
decl_stmt|;
name|size_t
name|dictSize
decl_stmt|;
name|ZSTDv07_DCtx
modifier|*
name|refContext
decl_stmt|;
block|}
struct|;
comment|/* typedef'd tp ZSTDv07_CDict within zstd.h */
name|ZSTDv07_DDict
modifier|*
name|ZSTDv07_createDDict_advanced
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTDv07_customMem
name|customMem
parameter_list|)
block|{
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|&&
operator|!
name|customMem
operator|.
name|customFree
condition|)
name|customMem
operator|=
name|defaultCustomMem
expr_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|||
operator|!
name|customMem
operator|.
name|customFree
condition|)
return|return
name|NULL
return|;
block|{
name|ZSTDv07_DDict
modifier|*
specifier|const
name|ddict
init|=
operator|(
name|ZSTDv07_DDict
operator|*
operator|)
name|customMem
operator|.
name|customAlloc
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ddict
argument_list|)
argument_list|)
decl_stmt|;
name|void
modifier|*
specifier|const
name|dictContent
init|=
name|customMem
operator|.
name|customAlloc
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
name|ZSTDv07_DCtx
modifier|*
specifier|const
name|dctx
init|=
name|ZSTDv07_createDCtx_advanced
argument_list|(
name|customMem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dictContent
operator|||
operator|!
name|ddict
operator|||
operator|!
name|dctx
condition|)
block|{
name|customMem
operator|.
name|customFree
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|dictContent
argument_list|)
expr_stmt|;
name|customMem
operator|.
name|customFree
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|ddict
argument_list|)
expr_stmt|;
name|customMem
operator|.
name|customFree
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|dctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|dictContent
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTDv07_decompressBegin_usingDict
argument_list|(
name|dctx
argument_list|,
name|dictContent
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|customMem
operator|.
name|customFree
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|dictContent
argument_list|)
expr_stmt|;
name|customMem
operator|.
name|customFree
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|ddict
argument_list|)
expr_stmt|;
name|customMem
operator|.
name|customFree
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
name|dctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|ddict
operator|->
name|dict
operator|=
name|dictContent
expr_stmt|;
name|ddict
operator|->
name|dictSize
operator|=
name|dictSize
expr_stmt|;
name|ddict
operator|->
name|refContext
operator|=
name|dctx
expr_stmt|;
return|return
name|ddict
return|;
block|}
block|}
comment|/*! ZSTDv07_createDDict() : *   Create a digested dictionary, ready to start decompression without startup delay. *   `dict` can be released after `ZSTDv07_DDict` creation */
name|ZSTDv07_DDict
modifier|*
name|ZSTDv07_createDDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|ZSTDv07_customMem
specifier|const
name|allocator
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|ZSTDv07_createDDict_advanced
argument_list|(
name|dict
argument_list|,
name|dictSize
argument_list|,
name|allocator
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv07_freeDDict
parameter_list|(
name|ZSTDv07_DDict
modifier|*
name|ddict
parameter_list|)
block|{
name|ZSTDv07_freeFunction
specifier|const
name|cFree
init|=
name|ddict
operator|->
name|refContext
operator|->
name|customMem
operator|.
name|customFree
decl_stmt|;
name|void
modifier|*
specifier|const
name|opaque
init|=
name|ddict
operator|->
name|refContext
operator|->
name|customMem
operator|.
name|opaque
decl_stmt|;
name|ZSTDv07_freeDCtx
argument_list|(
name|ddict
operator|->
name|refContext
argument_list|)
expr_stmt|;
name|cFree
argument_list|(
name|opaque
argument_list|,
name|ddict
operator|->
name|dict
argument_list|)
expr_stmt|;
name|cFree
argument_list|(
name|opaque
argument_list|,
name|ddict
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*! ZSTDv07_decompress_usingDDict() : *   Decompression using a pre-digested Dictionary *   Use dictionary without significant overhead. */
name|ZSTDLIBv07_API
name|size_t
name|ZSTDv07_decompress_usingDDict
parameter_list|(
name|ZSTDv07_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTDv07_DDict
modifier|*
name|ddict
parameter_list|)
block|{
return|return
name|ZSTDv07_decompress_usingPreparedDCtx
argument_list|(
name|dctx
argument_list|,
name|ddict
operator|->
name|refContext
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
comment|/*     Buffered version of Zstd compression library     Copyright (C) 2015-2016, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd homepage : http://www.zstd.net/ */
comment|/*-*************************************************************************** *  Streaming decompression howto * *  A ZBUFFv07_DCtx object is required to track streaming operations. *  Use ZBUFFv07_createDCtx() and ZBUFFv07_freeDCtx() to create/release resources. *  Use ZBUFFv07_decompressInit() to start a new decompression operation, *   or ZBUFFv07_decompressInitDictionary() if decompression requires a dictionary. *  Note that ZBUFFv07_DCtx objects can be re-init multiple times. * *  Use ZBUFFv07_decompressContinue() repetitively to consume your input. *  *srcSizePtr and *dstCapacityPtr can be any size. *  The function will report how many bytes were read or written by modifying *srcSizePtr and *dstCapacityPtr. *  Note that it may not consume the entire input, in which case it's up to the caller to present remaining input again. *  The content of @dst will be overwritten (up to *dstCapacityPtr) at each function call, so save its content if it matters, or change @dst. *  @return : a hint to preferred nb of bytes to use as input for next function call (it's only a hint, to help latency), *            or 0 when a frame is completely decoded, *            or an error code, which can be tested using ZBUFFv07_isError(). * *  Hint : recommended buffer sizes (not compulsory) : ZBUFFv07_recommendedDInSize() and ZBUFFv07_recommendedDOutSize() *  output : ZBUFFv07_recommendedDOutSize==128 KB block size is the internal unit, it ensures it's always possible to write a full block when decoded. *  input  : ZBUFFv07_recommendedDInSize == 128KB + 3; *           just follow indications from ZBUFFv07_decompressContinue() to minimize latency. It should always be<= 128 KB + 3 . * *******************************************************************************/
typedef|typedef
enum|enum
block|{
name|ZBUFFds_init
block|,
name|ZBUFFds_loadHeader
block|,
name|ZBUFFds_read
block|,
name|ZBUFFds_load
block|,
name|ZBUFFds_flush
block|}
name|ZBUFFv07_dStage
typedef|;
comment|/* *** Resource management *** */
struct|struct
name|ZBUFFv07_DCtx_s
block|{
name|ZSTDv07_DCtx
modifier|*
name|zd
decl_stmt|;
name|ZSTDv07_frameParams
name|fParams
decl_stmt|;
name|ZBUFFv07_dStage
name|stage
decl_stmt|;
name|char
modifier|*
name|inBuff
decl_stmt|;
name|size_t
name|inBuffSize
decl_stmt|;
name|size_t
name|inPos
decl_stmt|;
name|char
modifier|*
name|outBuff
decl_stmt|;
name|size_t
name|outBuffSize
decl_stmt|;
name|size_t
name|outStart
decl_stmt|;
name|size_t
name|outEnd
decl_stmt|;
name|size_t
name|blockSize
decl_stmt|;
name|BYTE
name|headerBuffer
index|[
name|ZSTDv07_FRAMEHEADERSIZE_MAX
index|]
decl_stmt|;
name|size_t
name|lhSize
decl_stmt|;
name|ZSTDv07_customMem
name|customMem
decl_stmt|;
block|}
struct|;
comment|/* typedef'd to ZBUFFv07_DCtx within "zstd_buffered.h" */
name|ZSTDLIBv07_API
name|ZBUFFv07_DCtx
modifier|*
name|ZBUFFv07_createDCtx_advanced
argument_list|(
name|ZSTDv07_customMem
name|customMem
argument_list|)
decl_stmt|;
name|ZBUFFv07_DCtx
modifier|*
name|ZBUFFv07_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZBUFFv07_createDCtx_advanced
argument_list|(
name|defaultCustomMem
argument_list|)
return|;
block|}
name|ZBUFFv07_DCtx
modifier|*
name|ZBUFFv07_createDCtx_advanced
parameter_list|(
name|ZSTDv07_customMem
name|customMem
parameter_list|)
block|{
name|ZBUFFv07_DCtx
modifier|*
name|zbd
decl_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|&&
operator|!
name|customMem
operator|.
name|customFree
condition|)
name|customMem
operator|=
name|defaultCustomMem
expr_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|||
operator|!
name|customMem
operator|.
name|customFree
condition|)
return|return
name|NULL
return|;
name|zbd
operator|=
operator|(
name|ZBUFFv07_DCtx
operator|*
operator|)
name|customMem
operator|.
name|customAlloc
argument_list|(
name|customMem
operator|.
name|opaque
argument_list|,
sizeof|sizeof
argument_list|(
name|ZBUFFv07_DCtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|zbd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ZBUFFv07_DCtx
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|zbd
operator|->
name|customMem
argument_list|,
operator|&
name|customMem
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTDv07_customMem
argument_list|)
argument_list|)
expr_stmt|;
name|zbd
operator|->
name|zd
operator|=
name|ZSTDv07_createDCtx_advanced
argument_list|(
name|customMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|zd
operator|==
name|NULL
condition|)
block|{
name|ZBUFFv07_freeDCtx
argument_list|(
name|zbd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_init
expr_stmt|;
return|return
name|zbd
return|;
block|}
name|size_t
name|ZBUFFv07_freeDCtx
parameter_list|(
name|ZBUFFv07_DCtx
modifier|*
name|zbd
parameter_list|)
block|{
if|if
condition|(
name|zbd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support free on null */
name|ZSTDv07_freeDCtx
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|inBuff
condition|)
name|zbd
operator|->
name|customMem
operator|.
name|customFree
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|zbd
operator|->
name|inBuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|outBuff
condition|)
name|zbd
operator|->
name|customMem
operator|.
name|customFree
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|zbd
operator|->
name|outBuff
argument_list|)
expr_stmt|;
name|zbd
operator|->
name|customMem
operator|.
name|customFree
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|zbd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* *** Initialization *** */
name|size_t
name|ZBUFFv07_decompressInitDictionary
parameter_list|(
name|ZBUFFv07_DCtx
modifier|*
name|zbd
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_loadHeader
expr_stmt|;
name|zbd
operator|->
name|lhSize
operator|=
name|zbd
operator|->
name|inPos
operator|=
name|zbd
operator|->
name|outStart
operator|=
name|zbd
operator|->
name|outEnd
operator|=
literal|0
expr_stmt|;
return|return
name|ZSTDv07_decompressBegin_usingDict
argument_list|(
name|zbd
operator|->
name|zd
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
block|}
name|size_t
name|ZBUFFv07_decompressInit
parameter_list|(
name|ZBUFFv07_DCtx
modifier|*
name|zbd
parameter_list|)
block|{
return|return
name|ZBUFFv07_decompressInitDictionary
argument_list|(
name|zbd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* internal util function */
name|MEM_STATIC
name|size_t
name|ZBUFFv07_limitCopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
specifier|const
name|length
init|=
name|MIN
argument_list|(
name|dstCapacity
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
comment|/* *** Decompression *** */
name|size_t
name|ZBUFFv07_decompressContinue
parameter_list|(
name|ZBUFFv07_DCtx
modifier|*
name|zbd
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|dstCapacityPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
modifier|*
name|srcSizePtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
operator|*
name|srcSizePtr
decl_stmt|;
specifier|const
name|char
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|char
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|char
operator|*
operator|)
name|dst
decl_stmt|;
name|char
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
operator|*
name|dstCapacityPtr
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|U32
name|notDone
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|notDone
condition|)
block|{
switch|switch
condition|(
name|zbd
operator|->
name|stage
condition|)
block|{
case|case
name|ZBUFFds_init
case|:
return|return
name|ERROR
argument_list|(
name|init_missing
argument_list|)
return|;
case|case
name|ZBUFFds_loadHeader
case|:
block|{
name|size_t
specifier|const
name|hSize
init|=
name|ZSTDv07_getFrameParams
argument_list|(
operator|&
operator|(
name|zbd
operator|->
name|fParams
operator|)
argument_list|,
name|zbd
operator|->
name|headerBuffer
argument_list|,
name|zbd
operator|->
name|lhSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|!=
literal|0
condition|)
block|{
name|size_t
specifier|const
name|toLoad
init|=
name|hSize
operator|-
name|zbd
operator|->
name|lhSize
decl_stmt|;
comment|/* if hSize!=0, hSize> zbd->lhSize */
if|if
condition|(
name|toLoad
operator|>
call|(
name|size_t
call|)
argument_list|(
name|iend
operator|-
name|ip
argument_list|)
condition|)
block|{
comment|/* not enough input to load full header */
name|memcpy
argument_list|(
name|zbd
operator|->
name|headerBuffer
operator|+
name|zbd
operator|->
name|lhSize
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
name|zbd
operator|->
name|lhSize
operator|+=
name|iend
operator|-
name|ip
expr_stmt|;
operator|*
name|dstCapacityPtr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|hSize
operator|-
name|zbd
operator|->
name|lhSize
operator|)
operator|+
name|ZSTDv07_blockHeaderSize
return|;
comment|/* remaining header bytes + next block header */
block|}
name|memcpy
argument_list|(
name|zbd
operator|->
name|headerBuffer
operator|+
name|zbd
operator|->
name|lhSize
argument_list|,
name|ip
argument_list|,
name|toLoad
argument_list|)
expr_stmt|;
name|zbd
operator|->
name|lhSize
operator|=
name|hSize
expr_stmt|;
name|ip
operator|+=
name|toLoad
expr_stmt|;
break|break;
block|}
block|}
comment|/* Consume header */
block|{
name|size_t
specifier|const
name|h1Size
init|=
name|ZSTDv07_nextSrcSizeToDecompress
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
comment|/* == ZSTDv07_frameHeaderSize_min */
name|size_t
specifier|const
name|h1Result
init|=
name|ZSTDv07_decompressContinue
argument_list|(
name|zbd
operator|->
name|zd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zbd
operator|->
name|headerBuffer
argument_list|,
name|h1Size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|h1Result
argument_list|)
condition|)
return|return
name|h1Result
return|;
if|if
condition|(
name|h1Size
operator|<
name|zbd
operator|->
name|lhSize
condition|)
block|{
comment|/* long header */
name|size_t
specifier|const
name|h2Size
init|=
name|ZSTDv07_nextSrcSizeToDecompress
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|h2Result
init|=
name|ZSTDv07_decompressContinue
argument_list|(
name|zbd
operator|->
name|zd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zbd
operator|->
name|headerBuffer
operator|+
name|h1Size
argument_list|,
name|h2Size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|h2Result
argument_list|)
condition|)
return|return
name|h2Result
return|;
block|}
block|}
name|zbd
operator|->
name|fParams
operator|.
name|windowSize
operator|=
name|MAX
argument_list|(
name|zbd
operator|->
name|fParams
operator|.
name|windowSize
argument_list|,
literal|1U
operator|<<
name|ZSTDv07_WINDOWLOG_ABSOLUTEMIN
argument_list|)
expr_stmt|;
comment|/* Frame header instruct buffer sizes */
block|{
name|size_t
specifier|const
name|blockSize
init|=
name|MIN
argument_list|(
name|zbd
operator|->
name|fParams
operator|.
name|windowSize
argument_list|,
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
argument_list|)
decl_stmt|;
name|zbd
operator|->
name|blockSize
operator|=
name|blockSize
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|inBuffSize
operator|<
name|blockSize
condition|)
block|{
name|zbd
operator|->
name|customMem
operator|.
name|customFree
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|zbd
operator|->
name|inBuff
argument_list|)
expr_stmt|;
name|zbd
operator|->
name|inBuffSize
operator|=
name|blockSize
expr_stmt|;
name|zbd
operator|->
name|inBuff
operator|=
operator|(
name|char
operator|*
operator|)
name|zbd
operator|->
name|customMem
operator|.
name|customAlloc
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|inBuff
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
block|{
name|size_t
specifier|const
name|neededOutSize
init|=
name|zbd
operator|->
name|fParams
operator|.
name|windowSize
operator|+
name|blockSize
operator|+
name|WILDCOPY_OVERLENGTH
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|zbd
operator|->
name|outBuffSize
operator|<
name|neededOutSize
condition|)
block|{
name|zbd
operator|->
name|customMem
operator|.
name|customFree
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|zbd
operator|->
name|outBuff
argument_list|)
expr_stmt|;
name|zbd
operator|->
name|outBuffSize
operator|=
name|neededOutSize
expr_stmt|;
name|zbd
operator|->
name|outBuff
operator|=
operator|(
name|char
operator|*
operator|)
name|zbd
operator|->
name|customMem
operator|.
name|customAlloc
argument_list|(
name|zbd
operator|->
name|customMem
operator|.
name|opaque
argument_list|,
name|neededOutSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|outBuff
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
block|}
block|}
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_read
expr_stmt|;
comment|/* pass-through */
comment|/* fall-through */
case|case
name|ZBUFFds_read
case|:
block|{
name|size_t
specifier|const
name|neededInSize
init|=
name|ZSTDv07_nextSrcSizeToDecompress
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
if|if
condition|(
name|neededInSize
operator|==
literal|0
condition|)
block|{
comment|/* end of frame */
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_init
expr_stmt|;
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|iend
operator|-
name|ip
argument_list|)
operator|>=
name|neededInSize
condition|)
block|{
comment|/* decode directly from src */
specifier|const
name|int
name|isSkipFrame
init|=
name|ZSTDv07_isSkipFrame
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decodedSize
init|=
name|ZSTDv07_decompressContinue
argument_list|(
name|zbd
operator|->
name|zd
argument_list|,
name|zbd
operator|->
name|outBuff
operator|+
name|zbd
operator|->
name|outStart
argument_list|,
operator|(
name|isSkipFrame
condition|?
literal|0
else|:
name|zbd
operator|->
name|outBuffSize
operator|-
name|zbd
operator|->
name|outStart
operator|)
argument_list|,
name|ip
argument_list|,
name|neededInSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|ip
operator|+=
name|neededInSize
expr_stmt|;
if|if
condition|(
operator|!
name|decodedSize
operator|&&
operator|!
name|isSkipFrame
condition|)
break|break;
comment|/* this was just a header */
name|zbd
operator|->
name|outEnd
operator|=
name|zbd
operator|->
name|outStart
operator|+
name|decodedSize
expr_stmt|;
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_flush
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|iend
condition|)
block|{
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* no more input */
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_load
expr_stmt|;
block|}
comment|/* fall-through */
case|case
name|ZBUFFds_load
case|:
block|{
name|size_t
specifier|const
name|neededInSize
init|=
name|ZSTDv07_nextSrcSizeToDecompress
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|toLoad
init|=
name|neededInSize
operator|-
name|zbd
operator|->
name|inPos
decl_stmt|;
comment|/* should always be<= remaining space within inBuff */
name|size_t
name|loadedSize
decl_stmt|;
if|if
condition|(
name|toLoad
operator|>
name|zbd
operator|->
name|inBuffSize
operator|-
name|zbd
operator|->
name|inPos
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* should never happen */
name|loadedSize
operator|=
name|ZBUFFv07_limitCopy
argument_list|(
name|zbd
operator|->
name|inBuff
operator|+
name|zbd
operator|->
name|inPos
argument_list|,
name|toLoad
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|loadedSize
expr_stmt|;
name|zbd
operator|->
name|inPos
operator|+=
name|loadedSize
expr_stmt|;
if|if
condition|(
name|loadedSize
operator|<
name|toLoad
condition|)
block|{
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* not enough input, wait for more */
comment|/* decode loaded input */
block|{
specifier|const
name|int
name|isSkipFrame
init|=
name|ZSTDv07_isSkipFrame
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decodedSize
init|=
name|ZSTDv07_decompressContinue
argument_list|(
name|zbd
operator|->
name|zd
argument_list|,
name|zbd
operator|->
name|outBuff
operator|+
name|zbd
operator|->
name|outStart
argument_list|,
name|zbd
operator|->
name|outBuffSize
operator|-
name|zbd
operator|->
name|outStart
argument_list|,
name|zbd
operator|->
name|inBuff
argument_list|,
name|neededInSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv07_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|zbd
operator|->
name|inPos
operator|=
literal|0
expr_stmt|;
comment|/* input is consumed */
if|if
condition|(
operator|!
name|decodedSize
operator|&&
operator|!
name|isSkipFrame
condition|)
block|{
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_read
expr_stmt|;
break|break;
block|}
comment|/* this was just a header */
name|zbd
operator|->
name|outEnd
operator|=
name|zbd
operator|->
name|outStart
operator|+
name|decodedSize
expr_stmt|;
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_flush
expr_stmt|;
comment|/* break; */
comment|/* pass-through */
block|}
block|}
comment|/* fall-through */
case|case
name|ZBUFFds_flush
case|:
block|{
name|size_t
specifier|const
name|toFlushSize
init|=
name|zbd
operator|->
name|outEnd
operator|-
name|zbd
operator|->
name|outStart
decl_stmt|;
name|size_t
specifier|const
name|flushedSize
init|=
name|ZBUFFv07_limitCopy
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|zbd
operator|->
name|outBuff
operator|+
name|zbd
operator|->
name|outStart
argument_list|,
name|toFlushSize
argument_list|)
decl_stmt|;
name|op
operator|+=
name|flushedSize
expr_stmt|;
name|zbd
operator|->
name|outStart
operator|+=
name|flushedSize
expr_stmt|;
if|if
condition|(
name|flushedSize
operator|==
name|toFlushSize
condition|)
block|{
name|zbd
operator|->
name|stage
operator|=
name|ZBUFFds_read
expr_stmt|;
if|if
condition|(
name|zbd
operator|->
name|outStart
operator|+
name|zbd
operator|->
name|blockSize
operator|>
name|zbd
operator|->
name|outBuffSize
condition|)
name|zbd
operator|->
name|outStart
operator|=
name|zbd
operator|->
name|outEnd
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* cannot flush everything */
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
comment|/* result */
operator|*
name|srcSizePtr
operator|=
name|ip
operator|-
name|istart
expr_stmt|;
operator|*
name|dstCapacityPtr
operator|=
name|op
operator|-
name|ostart
expr_stmt|;
block|{
name|size_t
name|nextSrcSizeHint
init|=
name|ZSTDv07_nextSrcSizeToDecompress
argument_list|(
name|zbd
operator|->
name|zd
argument_list|)
decl_stmt|;
name|nextSrcSizeHint
operator|-=
name|zbd
operator|->
name|inPos
expr_stmt|;
comment|/* already loaded*/
return|return
name|nextSrcSizeHint
return|;
block|}
block|}
comment|/* ************************************* *  Tool functions ***************************************/
name|size_t
name|ZBUFFv07_recommendedDInSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
operator|+
name|ZSTDv07_blockHeaderSize
comment|/* block header size*/
return|;
block|}
name|size_t
name|ZBUFFv07_recommendedDOutSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTDv07_BLOCKSIZE_ABSOLUTEMAX
return|;
block|}
end_function

end_unit

