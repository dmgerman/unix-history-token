begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * divsufsort.c for libdivsufsort-lite  * Copyright (c) 2003-2008 Yuta Mori All Rights Reserved.  *  * Permission is hereby granted, free of charge, to any person  * obtaining a copy of this software and associated documentation  * files (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use,  * copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following  * conditions:  *  * The above copyright notice and this permission notice shall be  * included in all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_comment
comment|/*- Compiler specifics -*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__clang__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|clang
name|diagnostic
name|ignored
literal|"-Wshorten-64-to-32"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4244
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* C4127 : Condition expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*- Dependencies -*/
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"divsufsort.h"
end_include

begin_comment
comment|/*- Constants -*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INLINE
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|INLINE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INLINE
argument_list|)
end_if

begin_define
define|#
directive|define
name|INLINE
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ALPHABET_SIZE
argument_list|)
operator|&&
operator|(
name|ALPHABET_SIZE
operator|<
literal|1
operator|)
end_if

begin_undef
undef|#
directive|undef
name|ALPHABET_SIZE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ALPHABET_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|ALPHABET_SIZE
value|(256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BUCKET_A_SIZE
value|(ALPHABET_SIZE)
end_define

begin_define
define|#
directive|define
name|BUCKET_B_SIZE
value|(ALPHABET_SIZE * ALPHABET_SIZE)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SS_INSERTIONSORT_THRESHOLD
argument_list|)
end_if

begin_if
if|#
directive|if
name|SS_INSERTIONSORT_THRESHOLD
operator|<
literal|1
end_if

begin_undef
undef|#
directive|undef
name|SS_INSERTIONSORT_THRESHOLD
end_undef

begin_define
define|#
directive|define
name|SS_INSERTIONSORT_THRESHOLD
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SS_INSERTIONSORT_THRESHOLD
value|(8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SS_BLOCKSIZE
argument_list|)
end_if

begin_if
if|#
directive|if
name|SS_BLOCKSIZE
operator|<
literal|0
end_if

begin_undef
undef|#
directive|undef
name|SS_BLOCKSIZE
end_undef

begin_define
define|#
directive|define
name|SS_BLOCKSIZE
value|(0)
end_define

begin_elif
elif|#
directive|elif
literal|32768
operator|<=
name|SS_BLOCKSIZE
end_elif

begin_undef
undef|#
directive|undef
name|SS_BLOCKSIZE
end_undef

begin_define
define|#
directive|define
name|SS_BLOCKSIZE
value|(32767)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SS_BLOCKSIZE
value|(1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* minstacksize = log(SS_BLOCKSIZE) / log(3) * 2 */
end_comment

begin_if
if|#
directive|if
name|SS_BLOCKSIZE
operator|==
literal|0
end_if

begin_define
define|#
directive|define
name|SS_MISORT_STACKSIZE
value|(96)
end_define

begin_elif
elif|#
directive|elif
name|SS_BLOCKSIZE
operator|<=
literal|4096
end_elif

begin_define
define|#
directive|define
name|SS_MISORT_STACKSIZE
value|(16)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SS_MISORT_STACKSIZE
value|(24)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SS_SMERGE_STACKSIZE
value|(32)
end_define

begin_define
define|#
directive|define
name|TR_INSERTIONSORT_THRESHOLD
value|(8)
end_define

begin_define
define|#
directive|define
name|TR_STACKSIZE
value|(64)
end_define

begin_comment
comment|/*- Macros -*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SWAP
end_ifndef

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|)
value|do { t = (_a); (_a) = (_b); (_b) = t; } while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SWAP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|)
value|(((_a)< (_b)) ? (_a) : (_b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MIN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|)
value|(((_a)> (_b)) ? (_a) : (_b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX */
end_comment

begin_define
define|#
directive|define
name|STACK_PUSH
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|,
name|_c
parameter_list|,
name|_d
parameter_list|)
define|\
value|do {\     assert(ssize< STACK_SIZE);\     stack[ssize].a = (_a), stack[ssize].b = (_b),\     stack[ssize].c = (_c), stack[ssize++].d = (_d);\   } while(0)
end_define

begin_define
define|#
directive|define
name|STACK_PUSH5
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|,
name|_c
parameter_list|,
name|_d
parameter_list|,
name|_e
parameter_list|)
define|\
value|do {\     assert(ssize< STACK_SIZE);\     stack[ssize].a = (_a), stack[ssize].b = (_b),\     stack[ssize].c = (_c), stack[ssize].d = (_d), stack[ssize++].e = (_e);\   } while(0)
end_define

begin_define
define|#
directive|define
name|STACK_POP
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|,
name|_c
parameter_list|,
name|_d
parameter_list|)
define|\
value|do {\     assert(0<= ssize);\     if(ssize == 0) { return; }\     (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\     (_c) = stack[ssize].c, (_d) = stack[ssize].d;\   } while(0)
end_define

begin_define
define|#
directive|define
name|STACK_POP5
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|,
name|_c
parameter_list|,
name|_d
parameter_list|,
name|_e
parameter_list|)
define|\
value|do {\     assert(0<= ssize);\     if(ssize == 0) { return; }\     (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\     (_c) = stack[ssize].c, (_d) = stack[ssize].d, (_e) = stack[ssize].e;\   } while(0)
end_define

begin_define
define|#
directive|define
name|BUCKET_A
parameter_list|(
name|_c0
parameter_list|)
value|bucket_A[(_c0)]
end_define

begin_if
if|#
directive|if
name|ALPHABET_SIZE
operator|==
literal|256
end_if

begin_define
define|#
directive|define
name|BUCKET_B
parameter_list|(
name|_c0
parameter_list|,
name|_c1
parameter_list|)
value|(bucket_B[((_c1)<< 8) | (_c0)])
end_define

begin_define
define|#
directive|define
name|BUCKET_BSTAR
parameter_list|(
name|_c0
parameter_list|,
name|_c1
parameter_list|)
value|(bucket_B[((_c0)<< 8) | (_c1)])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUCKET_B
parameter_list|(
name|_c0
parameter_list|,
name|_c1
parameter_list|)
value|(bucket_B[(_c1) * ALPHABET_SIZE + (_c0)])
end_define

begin_define
define|#
directive|define
name|BUCKET_BSTAR
parameter_list|(
name|_c0
parameter_list|,
name|_c1
parameter_list|)
value|(bucket_B[(_c0) * ALPHABET_SIZE + (_c1)])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*- Private Functions -*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|lg_table
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|SS_BLOCKSIZE
operator|==
literal|0
operator|)
operator|||
operator|(
name|SS_INSERTIONSORT_THRESHOLD
operator|<
name|SS_BLOCKSIZE
operator|)
end_if

begin_function
specifier|static
name|INLINE
name|int
name|ss_ilg
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|#
directive|if
name|SS_BLOCKSIZE
operator|==
literal|0
return|return
operator|(
name|n
operator|&
literal|0xffff0000
operator|)
condition|?
operator|(
operator|(
name|n
operator|&
literal|0xff000000
operator|)
condition|?
literal|24
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|24
operator|)
operator|&
literal|0xff
index|]
else|:
literal|16
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator|)
else|:
operator|(
operator|(
name|n
operator|&
literal|0x0000ff00
operator|)
condition|?
literal|8
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
else|:
literal|0
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|0
operator|)
operator|&
literal|0xff
index|]
operator|)
return|;
elif|#
directive|elif
name|SS_BLOCKSIZE
operator|<
literal|256
return|return
name|lg_table
index|[
name|n
index|]
return|;
else|#
directive|else
return|return
operator|(
name|n
operator|&
literal|0xff00
operator|)
condition|?
literal|8
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
else|:
literal|0
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|0
operator|)
operator|&
literal|0xff
index|]
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD< SS_BLOCKSIZE) */
end_comment

begin_if
if|#
directive|if
name|SS_BLOCKSIZE
operator|!=
literal|0
end_if

begin_decl_stmt
specifier|static
specifier|const
name|int
name|sqq_table
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|16
block|,
literal|22
block|,
literal|27
block|,
literal|32
block|,
literal|35
block|,
literal|39
block|,
literal|42
block|,
literal|45
block|,
literal|48
block|,
literal|50
block|,
literal|53
block|,
literal|55
block|,
literal|57
block|,
literal|59
block|,
literal|61
block|,
literal|64
block|,
literal|65
block|,
literal|67
block|,
literal|69
block|,
literal|71
block|,
literal|73
block|,
literal|75
block|,
literal|76
block|,
literal|78
block|,
literal|80
block|,
literal|81
block|,
literal|83
block|,
literal|84
block|,
literal|86
block|,
literal|87
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|93
block|,
literal|94
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|128
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|192
block|,
literal|193
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|203
block|,
literal|204
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|208
block|,
literal|209
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|211
block|,
literal|212
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|214
block|,
literal|215
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|217
block|,
literal|218
block|,
literal|218
block|,
literal|219
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|221
block|,
literal|222
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|224
block|,
literal|225
block|,
literal|225
block|,
literal|226
block|,
literal|226
block|,
literal|227
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|229
block|,
literal|230
block|,
literal|230
block|,
literal|231
block|,
literal|231
block|,
literal|232
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|234
block|,
literal|235
block|,
literal|235
block|,
literal|236
block|,
literal|236
block|,
literal|237
block|,
literal|237
block|,
literal|238
block|,
literal|238
block|,
literal|239
block|,
literal|240
block|,
literal|240
block|,
literal|241
block|,
literal|241
block|,
literal|242
block|,
literal|242
block|,
literal|243
block|,
literal|243
block|,
literal|244
block|,
literal|244
block|,
literal|245
block|,
literal|245
block|,
literal|246
block|,
literal|246
block|,
literal|247
block|,
literal|247
block|,
literal|248
block|,
literal|248
block|,
literal|249
block|,
literal|249
block|,
literal|250
block|,
literal|250
block|,
literal|251
block|,
literal|251
block|,
literal|252
block|,
literal|252
block|,
literal|253
block|,
literal|253
block|,
literal|254
block|,
literal|254
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|INLINE
name|int
name|ss_isqrt
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
name|x
operator|>=
operator|(
name|SS_BLOCKSIZE
operator|*
name|SS_BLOCKSIZE
operator|)
condition|)
block|{
return|return
name|SS_BLOCKSIZE
return|;
block|}
name|e
operator|=
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
condition|?
operator|(
operator|(
name|x
operator|&
literal|0xff000000
operator|)
condition|?
literal|24
operator|+
name|lg_table
index|[
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0xff
index|]
else|:
literal|16
operator|+
name|lg_table
index|[
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator|)
else|:
operator|(
operator|(
name|x
operator|&
literal|0x0000ff00
operator|)
condition|?
literal|8
operator|+
name|lg_table
index|[
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
else|:
literal|0
operator|+
name|lg_table
index|[
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0xff
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|16
condition|)
block|{
name|y
operator|=
name|sqq_table
index|[
name|x
operator|>>
operator|(
operator|(
name|e
operator|-
literal|6
operator|)
operator|-
operator|(
name|e
operator|&
literal|1
operator|)
operator|)
index|]
operator|<<
operator|(
operator|(
name|e
operator|>>
literal|1
operator|)
operator|-
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|24
condition|)
block|{
name|y
operator|=
operator|(
name|y
operator|+
literal|1
operator|+
name|x
operator|/
name|y
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
name|y
operator|=
operator|(
name|y
operator|+
literal|1
operator|+
name|x
operator|/
name|y
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|>=
literal|8
condition|)
block|{
name|y
operator|=
operator|(
name|sqq_table
index|[
name|x
operator|>>
operator|(
operator|(
name|e
operator|-
literal|6
operator|)
operator|-
operator|(
name|e
operator|&
literal|1
operator|)
operator|)
index|]
operator|>>
operator|(
literal|7
operator|-
operator|(
name|e
operator|>>
literal|1
operator|)
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|sqq_table
index|[
name|x
index|]
operator|>>
literal|4
return|;
block|}
return|return
operator|(
name|x
operator|<
operator|(
name|y
operator|*
name|y
operator|)
operator|)
condition|?
name|y
operator|-
literal|1
else|:
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SS_BLOCKSIZE != 0 */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Compares two suffixes. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ss_compare
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|p1
parameter_list|,
specifier|const
name|int
modifier|*
name|p2
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|U1
decl_stmt|,
modifier|*
name|U2
decl_stmt|,
modifier|*
name|U1n
decl_stmt|,
modifier|*
name|U2n
decl_stmt|;
for|for
control|(
name|U1
operator|=
name|T
operator|+
name|depth
operator|+
operator|*
name|p1
operator|,
name|U2
operator|=
name|T
operator|+
name|depth
operator|+
operator|*
name|p2
operator|,
name|U1n
operator|=
name|T
operator|+
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
operator|+
literal|2
operator|,
name|U2n
operator|=
name|T
operator|+
operator|*
operator|(
name|p2
operator|+
literal|1
operator|)
operator|+
literal|2
init|;
operator|(
name|U1
operator|<
name|U1n
operator|)
operator|&&
operator|(
name|U2
operator|<
name|U2n
operator|)
operator|&&
operator|(
operator|*
name|U1
operator|==
operator|*
name|U2
operator|)
condition|;
operator|++
name|U1
operator|,
operator|++
name|U2
control|)
block|{   }
return|return
name|U1
operator|<
name|U1n
condition|?
operator|(
name|U2
operator|<
name|U2n
condition|?
operator|*
name|U1
operator|-
operator|*
name|U2
else|:
literal|1
operator|)
else|:
operator|(
name|U2
operator|<
name|U2n
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
operator|(
name|SS_BLOCKSIZE
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|SS_INSERTIONSORT_THRESHOLD
operator|!=
literal|1
operator|)
end_if

begin_comment
comment|/* Insertionsort for small size groups */
end_comment

begin_function
specifier|static
name|void
name|ss_insertionsort
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last
operator|-
literal|2
init|;
name|first
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
for|for
control|(
name|t
operator|=
operator|*
name|i
operator|,
name|j
operator|=
name|i
operator|+
literal|1
init|;
literal|0
operator|<
operator|(
name|r
operator|=
name|ss_compare
argument_list|(
name|T
argument_list|,
name|PA
operator|+
name|t
argument_list|,
name|PA
operator|+
operator|*
name|j
argument_list|,
name|depth
argument_list|)
operator|)
condition|;
control|)
block|{
do|do
block|{
operator|*
operator|(
name|j
operator|-
literal|1
operator|)
operator|=
operator|*
name|j
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|++
name|j
operator|<
name|last
operator|)
operator|&&
operator|(
operator|*
name|j
operator|<
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|last
operator|<=
name|j
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
operator|*
name|j
operator|=
operator|~
operator|*
name|j
expr_stmt|;
block|}
operator|*
operator|(
name|j
operator|-
literal|1
operator|)
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (SS_BLOCKSIZE != 1)&& (SS_INSERTIONSORT_THRESHOLD != 1) */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
operator|(
name|SS_BLOCKSIZE
operator|==
literal|0
operator|)
operator|||
operator|(
name|SS_INSERTIONSORT_THRESHOLD
operator|<
name|SS_BLOCKSIZE
operator|)
end_if

begin_function
specifier|static
name|INLINE
name|void
name|ss_fixdown
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|Td
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|;
for|for
control|(
name|v
operator|=
name|SA
index|[
name|i
index|]
operator|,
name|c
operator|=
name|Td
index|[
name|PA
index|[
name|v
index|]
index|]
init|;
operator|(
name|j
operator|=
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|<
name|size
condition|;
name|SA
index|[
name|i
index|]
operator|=
name|SA
index|[
name|k
index|]
operator|,
name|i
operator|=
name|k
control|)
block|{
name|d
operator|=
name|Td
index|[
name|PA
index|[
name|SA
index|[
name|k
operator|=
name|j
operator|++
index|]
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
operator|(
name|e
operator|=
name|Td
index|[
name|PA
index|[
name|SA
index|[
name|j
index|]
index|]
index|]
operator|)
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|d
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<=
name|c
condition|)
block|{
break|break;
block|}
block|}
name|SA
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple top-down heapsort. */
end_comment

begin_function
specifier|static
name|void
name|ss_heapsort
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|Td
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|int
name|t
decl_stmt|;
name|m
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|--
expr_stmt|;
if|if
condition|(
name|Td
index|[
name|PA
index|[
name|SA
index|[
name|m
operator|/
literal|2
index|]
index|]
index|]
operator|<
name|Td
index|[
name|PA
index|[
name|SA
index|[
name|m
index|]
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|SA
index|[
name|m
index|]
argument_list|,
name|SA
index|[
name|m
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|m
operator|/
literal|2
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
name|ss_fixdown
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|SA
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|SA
index|[
literal|0
index|]
argument_list|,
name|SA
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|ss_fixdown
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|SA
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|1
init|;
literal|0
operator|<
name|i
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|SA
index|[
literal|0
index|]
operator|,
name|SA
index|[
literal|0
index|]
operator|=
name|SA
index|[
name|i
index|]
expr_stmt|;
name|ss_fixdown
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|SA
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SA
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Returns the median of three elements. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|ss_median3
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|Td
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|v1
parameter_list|,
name|int
modifier|*
name|v2
parameter_list|,
name|int
modifier|*
name|v3
parameter_list|)
block|{
name|int
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v1
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v2
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v2
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v3
index|]
index|]
condition|)
block|{
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v1
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v3
index|]
index|]
condition|)
block|{
return|return
name|v1
return|;
block|}
else|else
block|{
return|return
name|v3
return|;
block|}
block|}
return|return
name|v2
return|;
block|}
end_function

begin_comment
comment|/* Returns the median of five elements. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|ss_median5
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|Td
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|v1
parameter_list|,
name|int
modifier|*
name|v2
parameter_list|,
name|int
modifier|*
name|v3
parameter_list|,
name|int
modifier|*
name|v4
parameter_list|,
name|int
modifier|*
name|v5
parameter_list|)
block|{
name|int
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v2
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v3
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v4
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v5
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v4
argument_list|,
name|v5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v2
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v4
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v2
argument_list|,
name|v4
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
name|v3
argument_list|,
name|v5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v1
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v3
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v1
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v1
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v4
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v1
argument_list|,
name|v4
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
name|v3
argument_list|,
name|v5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|v3
index|]
index|]
operator|>
name|Td
index|[
name|PA
index|[
operator|*
name|v4
index|]
index|]
condition|)
block|{
return|return
name|v4
return|;
block|}
return|return
name|v3
return|;
block|}
end_function

begin_comment
comment|/* Returns the pivot element. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|ss_pivot
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|Td
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|)
block|{
name|int
modifier|*
name|middle
decl_stmt|;
name|int
name|t
decl_stmt|;
name|t
operator|=
name|last
operator|-
name|first
expr_stmt|;
name|middle
operator|=
name|first
operator|+
name|t
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|t
operator|<=
literal|512
condition|)
block|{
if|if
condition|(
name|t
operator|<=
literal|32
condition|)
block|{
return|return
name|ss_median3
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|t
operator|>>=
literal|2
expr_stmt|;
return|return
name|ss_median5
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|first
operator|+
name|t
argument_list|,
name|middle
argument_list|,
name|last
operator|-
literal|1
operator|-
name|t
argument_list|,
name|last
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
name|t
operator|>>=
literal|3
expr_stmt|;
name|first
operator|=
name|ss_median3
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|first
operator|+
name|t
argument_list|,
name|first
operator|+
operator|(
name|t
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|middle
operator|=
name|ss_median3
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|middle
operator|-
name|t
argument_list|,
name|middle
argument_list|,
name|middle
operator|+
name|t
argument_list|)
expr_stmt|;
name|last
operator|=
name|ss_median3
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|last
operator|-
literal|1
operator|-
operator|(
name|t
operator|<<
literal|1
operator|)
argument_list|,
name|last
operator|-
literal|1
operator|-
name|t
argument_list|,
name|last
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ss_median3
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Binary partition for substrings. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|ss_partition
parameter_list|(
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|t
decl_stmt|;
for|for
control|(
name|a
operator|=
name|first
operator|-
literal|1
operator|,
name|b
operator|=
name|last
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
operator|(
operator|++
name|a
operator|<
name|b
operator|)
operator|&&
operator|(
operator|(
name|PA
index|[
operator|*
name|a
index|]
operator|+
name|depth
operator|)
operator|>=
operator|(
name|PA
index|[
operator|*
name|a
operator|+
literal|1
index|]
operator|+
literal|1
operator|)
operator|)
condition|;
control|)
block|{
operator|*
name|a
operator|=
operator|~
operator|*
name|a
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|a
operator|<
operator|--
name|b
operator|)
operator|&&
operator|(
operator|(
name|PA
index|[
operator|*
name|b
index|]
operator|+
name|depth
operator|)
operator|<
operator|(
name|PA
index|[
operator|*
name|b
operator|+
literal|1
index|]
operator|+
literal|1
operator|)
operator|)
condition|;
control|)
block|{ }
if|if
condition|(
name|b
operator|<=
name|a
condition|)
block|{
break|break;
block|}
name|t
operator|=
operator|~
operator|*
name|b
expr_stmt|;
operator|*
name|b
operator|=
operator|*
name|a
expr_stmt|;
operator|*
name|a
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|<
name|a
condition|)
block|{
operator|*
name|first
operator|=
operator|~
operator|*
name|first
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* Multikey introsort for medium size groups. */
end_comment

begin_function
specifier|static
name|void
name|ss_mintrosort
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
define|#
directive|define
name|STACK_SIZE
value|SS_MISORT_STACKSIZE
struct|struct
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
name|c
decl_stmt|;
name|int
name|d
decl_stmt|;
block|}
name|stack
index|[
name|STACK_SIZE
index|]
struct|;
specifier|const
name|unsigned
name|char
modifier|*
name|Td
decl_stmt|;
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
name|int
name|ssize
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|int
name|v
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ssize
operator|=
literal|0
operator|,
name|limit
operator|=
name|ss_ilg
argument_list|(
name|last
operator|-
name|first
argument_list|)
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|last
operator|-
name|first
operator|)
operator|<=
name|SS_INSERTIONSORT_THRESHOLD
condition|)
block|{
if|#
directive|if
literal|1
operator|<
name|SS_INSERTIONSORT_THRESHOLD
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|first
operator|)
condition|)
block|{
name|ss_insertionsort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|STACK_POP
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Td
operator|=
name|T
operator|+
name|depth
expr_stmt|;
if|if
condition|(
name|limit
operator|--
operator|==
literal|0
condition|)
block|{
name|ss_heapsort
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|a
operator|=
name|first
operator|+
literal|1
operator|,
name|v
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|first
index|]
index|]
init|;
name|a
operator|<
name|last
condition|;
operator|++
name|a
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|a
index|]
index|]
operator|)
operator|!=
name|v
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
break|break;
block|}
name|v
operator|=
name|x
expr_stmt|;
name|first
operator|=
name|a
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|first
index|]
operator|-
literal|1
index|]
operator|<
name|v
condition|)
block|{
name|first
operator|=
name|ss_partition
argument_list|(
name|PA
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|a
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|a
argument_list|,
name|last
argument_list|,
name|depth
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
operator|,
name|depth
operator|+=
literal|1
operator|,
name|limit
operator|=
name|ss_ilg
argument_list|(
name|a
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|a
operator|,
name|limit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|a
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|first
argument_list|,
name|a
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|ss_ilg
argument_list|(
name|a
operator|-
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|a
operator|,
name|limit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|a
operator|,
name|depth
operator|+=
literal|1
operator|,
name|limit
operator|=
name|ss_ilg
argument_list|(
name|a
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* choose pivot */
name|a
operator|=
name|ss_pivot
argument_list|(
name|Td
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|v
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|a
index|]
index|]
expr_stmt|;
name|SWAP
argument_list|(
operator|*
name|first
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
comment|/* partition */
for|for
control|(
name|b
operator|=
name|first
init|;
operator|(
operator|++
name|b
operator|<
name|last
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|b
index|]
index|]
operator|)
operator|==
name|v
operator|)
condition|;
control|)
block|{ }
if|if
condition|(
operator|(
operator|(
name|a
operator|=
name|b
operator|)
operator|<
name|last
operator|)
operator|&&
operator|(
name|x
operator|<
name|v
operator|)
condition|)
block|{
for|for
control|(
init|;
operator|(
operator|++
name|b
operator|<
name|last
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|b
index|]
index|]
operator|)
operator|<=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|c
operator|=
name|last
init|;
operator|(
name|b
operator|<
operator|--
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|c
index|]
index|]
operator|)
operator|==
name|v
operator|)
condition|;
control|)
block|{ }
if|if
condition|(
operator|(
name|b
operator|<
operator|(
name|d
operator|=
name|c
operator|)
operator|)
operator|&&
operator|(
name|x
operator|>
name|v
operator|)
condition|)
block|{
for|for
control|(
init|;
operator|(
name|b
operator|<
operator|--
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|c
index|]
index|]
operator|)
operator|>=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
operator|--
name|d
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
name|b
operator|<
name|c
condition|;
control|)
block|{
name|SWAP
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|++
name|b
operator|<
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|b
index|]
index|]
operator|)
operator|<=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
operator|(
name|b
operator|<
operator|--
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|Td
index|[
name|PA
index|[
operator|*
name|c
index|]
index|]
operator|)
operator|>=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
operator|--
name|d
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|<=
name|d
condition|)
block|{
name|c
operator|=
name|b
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|a
operator|-
name|first
operator|)
operator|>
operator|(
name|t
operator|=
name|b
operator|-
name|a
operator|)
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|first
operator|,
name|f
operator|=
name|b
operator|-
name|s
init|;
literal|0
operator|<
name|s
condition|;
operator|--
name|s
operator|,
operator|++
name|e
operator|,
operator|++
name|f
control|)
block|{
name|SWAP
argument_list|(
operator|*
name|e
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|d
operator|-
name|c
operator|)
operator|>
operator|(
name|t
operator|=
name|last
operator|-
name|d
operator|-
literal|1
operator|)
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|b
operator|,
name|f
operator|=
name|last
operator|-
name|s
init|;
literal|0
operator|<
name|s
condition|;
operator|--
name|s
operator|,
operator|++
name|e
operator|,
operator|++
name|f
control|)
block|{
name|SWAP
argument_list|(
operator|*
name|e
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
name|first
operator|+
operator|(
name|b
operator|-
name|a
operator|)
operator|,
name|c
operator|=
name|last
operator|-
operator|(
name|d
operator|-
name|c
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|v
operator|<=
name|Td
index|[
name|PA
index|[
operator|*
name|a
index|]
operator|-
literal|1
index|]
operator|)
condition|?
name|a
else|:
name|ss_partition
argument_list|(
name|PA
argument_list|,
name|a
argument_list|,
name|c
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|c
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|last
operator|-
name|c
operator|)
operator|<=
operator|(
name|c
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|ss_ilg
argument_list|(
name|c
operator|-
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|STACK_PUSH
argument_list|(
name|c
argument_list|,
name|last
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|c
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|c
argument_list|,
name|last
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|STACK_PUSH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|ss_ilg
argument_list|(
name|c
operator|-
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|STACK_PUSH
argument_list|(
name|c
argument_list|,
name|last
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|STACK_PUSH
argument_list|(
name|first
argument_list|,
name|a
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
operator|,
name|last
operator|=
name|c
operator|,
name|depth
operator|+=
literal|1
operator|,
name|limit
operator|=
name|ss_ilg
argument_list|(
name|c
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|c
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|ss_ilg
argument_list|(
name|c
operator|-
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|STACK_PUSH
argument_list|(
name|first
argument_list|,
name|a
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|first
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last
operator|-
name|c
operator|)
operator|<=
operator|(
name|c
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|first
argument_list|,
name|a
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|STACK_PUSH
argument_list|(
name|b
argument_list|,
name|c
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|ss_ilg
argument_list|(
name|c
operator|-
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|STACK_PUSH
argument_list|(
name|first
argument_list|,
name|a
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|STACK_PUSH
argument_list|(
name|c
argument_list|,
name|last
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
operator|,
name|last
operator|=
name|c
operator|,
name|depth
operator|+=
literal|1
operator|,
name|limit
operator|=
name|ss_ilg
argument_list|(
name|c
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|limit
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|Td
index|[
name|PA
index|[
operator|*
name|first
index|]
operator|-
literal|1
index|]
operator|<
name|v
condition|)
block|{
name|first
operator|=
name|ss_partition
argument_list|(
name|PA
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|limit
operator|=
name|ss_ilg
argument_list|(
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
name|depth
operator|+=
literal|1
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|STACK_SIZE
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD< SS_BLOCKSIZE) */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|SS_BLOCKSIZE
operator|!=
literal|0
end_if

begin_function
specifier|static
name|INLINE
name|void
name|ss_blockswap
parameter_list|(
name|int
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
for|for
control|(
init|;
literal|0
operator|<
name|n
condition|;
operator|--
name|n
operator|,
operator|++
name|a
operator|,
operator|++
name|b
control|)
block|{
name|t
operator|=
operator|*
name|a
operator|,
operator|*
name|a
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|ss_rotate
parameter_list|(
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|middle
parameter_list|,
name|int
modifier|*
name|last
parameter_list|)
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
name|t
decl_stmt|;
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
name|l
operator|=
name|middle
operator|-
name|first
operator|,
name|r
operator|=
name|last
operator|-
name|middle
expr_stmt|;
for|for
control|(
init|;
operator|(
literal|0
operator|<
name|l
operator|)
operator|&&
operator|(
literal|0
operator|<
name|r
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|l
operator|==
name|r
condition|)
block|{
name|ss_blockswap
argument_list|(
name|first
argument_list|,
name|middle
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l
operator|<
name|r
condition|)
block|{
name|a
operator|=
name|last
operator|-
literal|1
operator|,
name|b
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
name|t
operator|=
operator|*
name|a
expr_stmt|;
do|do
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|b
operator|<
name|first
condition|)
block|{
operator|*
name|a
operator|=
name|t
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|-=
name|l
operator|+
literal|1
operator|)
operator|<=
name|l
condition|)
block|{
break|break;
block|}
name|a
operator|-=
literal|1
operator|,
name|b
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
name|t
operator|=
operator|*
name|a
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
block|{
name|a
operator|=
name|first
operator|,
name|b
operator|=
name|middle
expr_stmt|;
name|t
operator|=
operator|*
name|a
expr_stmt|;
do|do
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|++
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|last
operator|<=
name|b
condition|)
block|{
operator|*
name|a
operator|=
name|t
expr_stmt|;
name|first
operator|=
name|a
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|-=
name|r
operator|+
literal|1
operator|)
operator|<=
name|r
condition|)
block|{
break|break;
block|}
name|a
operator|+=
literal|1
operator|,
name|b
operator|=
name|middle
expr_stmt|;
name|t
operator|=
operator|*
name|a
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ss_inplacemerge
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|middle
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|len
decl_stmt|,
name|half
decl_stmt|;
name|int
name|q
decl_stmt|,
name|r
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|last
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
block|{
name|x
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|PA
operator|+
operator|~
operator|*
operator|(
name|last
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|PA
operator|+
operator|*
operator|(
name|last
operator|-
literal|1
operator|)
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
name|first
operator|,
name|len
operator|=
name|middle
operator|-
name|first
operator|,
name|half
operator|=
name|len
operator|>>
literal|1
operator|,
name|r
operator|=
operator|-
literal|1
init|;
literal|0
operator|<
name|len
condition|;
name|len
operator|=
name|half
operator|,
name|half
operator|>>=
literal|1
control|)
block|{
name|b
operator|=
name|a
operator|+
name|half
expr_stmt|;
name|q
operator|=
name|ss_compare
argument_list|(
name|T
argument_list|,
name|PA
operator|+
operator|(
operator|(
literal|0
operator|<=
operator|*
name|b
operator|)
condition|?
operator|*
name|b
else|:
operator|~
operator|*
name|b
operator|)
argument_list|,
name|p
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|<
literal|0
condition|)
block|{
name|a
operator|=
name|b
operator|+
literal|1
expr_stmt|;
name|half
operator|-=
operator|(
name|len
operator|&
literal|1
operator|)
operator|^
literal|1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|q
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a
operator|<
name|middle
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
operator|*
name|a
operator|=
operator|~
operator|*
name|a
expr_stmt|;
block|}
name|ss_rotate
argument_list|(
name|a
argument_list|,
name|middle
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|-=
name|middle
operator|-
name|a
expr_stmt|;
name|middle
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|middle
condition|)
block|{
break|break;
block|}
block|}
operator|--
name|last
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|last
operator|<
literal|0
condition|)
block|{ }
block|}
if|if
condition|(
name|middle
operator|==
name|last
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Merge-forward with internal buffer. */
end_comment

begin_function
specifier|static
name|void
name|ss_mergeforward
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|middle
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|bufend
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|r
decl_stmt|;
name|bufend
operator|=
name|buf
operator|+
operator|(
name|middle
operator|-
name|first
operator|)
operator|-
literal|1
expr_stmt|;
name|ss_blockswap
argument_list|(
name|buf
argument_list|,
name|first
argument_list|,
name|middle
operator|-
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
operator|*
operator|(
name|a
operator|=
name|first
operator|)
operator|,
name|b
operator|=
name|buf
operator|,
name|c
operator|=
name|middle
init|;
condition|;
control|)
block|{
name|r
operator|=
name|ss_compare
argument_list|(
name|T
argument_list|,
name|PA
operator|+
operator|*
name|b
argument_list|,
name|PA
operator|+
operator|*
name|c
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
do|do
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|bufend
operator|<=
name|b
condition|)
block|{
operator|*
name|bufend
operator|=
name|t
expr_stmt|;
return|return;
block|}
operator|*
name|b
operator|++
operator|=
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|b
operator|<
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
do|do
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|c
operator|,
operator|*
name|c
operator|++
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|last
operator|<=
name|c
condition|)
block|{
while|while
condition|(
name|b
operator|<
name|bufend
condition|)
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|++
operator|=
operator|*
name|a
expr_stmt|;
block|}
operator|*
name|a
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|=
name|t
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
do|;
block|}
else|else
block|{
operator|*
name|c
operator|=
operator|~
operator|*
name|c
expr_stmt|;
do|do
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|bufend
operator|<=
name|b
condition|)
block|{
operator|*
name|bufend
operator|=
name|t
expr_stmt|;
return|return;
block|}
operator|*
name|b
operator|++
operator|=
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|b
operator|<
literal|0
condition|)
do|;
do|do
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|c
operator|,
operator|*
name|c
operator|++
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|last
operator|<=
name|c
condition|)
block|{
while|while
condition|(
name|b
operator|<
name|bufend
condition|)
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|++
operator|=
operator|*
name|a
expr_stmt|;
block|}
operator|*
name|a
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|=
name|t
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
do|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge-backward with internal buffer. */
end_comment

begin_function
specifier|static
name|void
name|ss_mergebackward
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|middle
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|bufend
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|x
decl_stmt|;
name|bufend
operator|=
name|buf
operator|+
operator|(
name|last
operator|-
name|middle
operator|)
operator|-
literal|1
expr_stmt|;
name|ss_blockswap
argument_list|(
name|buf
argument_list|,
name|middle
argument_list|,
name|last
operator|-
name|middle
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|bufend
operator|<
literal|0
condition|)
block|{
name|p1
operator|=
name|PA
operator|+
operator|~
operator|*
name|bufend
expr_stmt|;
name|x
operator||=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
name|PA
operator|+
operator|*
name|bufend
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|middle
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
block|{
name|p2
operator|=
name|PA
operator|+
operator|~
operator|*
operator|(
name|middle
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator||=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p2
operator|=
name|PA
operator|+
operator|*
operator|(
name|middle
operator|-
literal|1
operator|)
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
operator|*
operator|(
name|a
operator|=
name|last
operator|-
literal|1
operator|)
operator|,
name|b
operator|=
name|bufend
operator|,
name|c
operator|=
name|middle
operator|-
literal|1
init|;
condition|;
control|)
block|{
name|r
operator|=
name|ss_compare
argument_list|(
name|T
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|r
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
do|do
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|b
operator|<
literal|0
condition|)
do|;
name|x
operator|^=
literal|1
expr_stmt|;
block|}
operator|*
name|a
operator|--
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|<=
name|buf
condition|)
block|{
operator|*
name|buf
operator|=
name|t
expr_stmt|;
break|break;
block|}
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|<
literal|0
condition|)
block|{
name|p1
operator|=
name|PA
operator|+
operator|~
operator|*
name|b
expr_stmt|;
name|x
operator||=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
name|PA
operator|+
operator|*
name|b
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|2
condition|)
block|{
do|do
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|c
operator|,
operator|*
name|c
operator|--
operator|=
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
do|;
name|x
operator|^=
literal|2
expr_stmt|;
block|}
operator|*
name|a
operator|--
operator|=
operator|*
name|c
operator|,
operator|*
name|c
operator|--
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|first
condition|)
block|{
while|while
condition|(
name|buf
operator|<
name|b
condition|)
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
block|}
operator|*
name|a
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|=
name|t
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
block|{
name|p2
operator|=
name|PA
operator|+
operator|~
operator|*
name|c
expr_stmt|;
name|x
operator||=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p2
operator|=
name|PA
operator|+
operator|*
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
do|do
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|b
operator|<
literal|0
condition|)
do|;
name|x
operator|^=
literal|1
expr_stmt|;
block|}
operator|*
name|a
operator|--
operator|=
operator|~
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|<=
name|buf
condition|)
block|{
operator|*
name|buf
operator|=
name|t
expr_stmt|;
break|break;
block|}
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|2
condition|)
block|{
do|do
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|c
operator|,
operator|*
name|c
operator|--
operator|=
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
do|;
name|x
operator|^=
literal|2
expr_stmt|;
block|}
operator|*
name|a
operator|--
operator|=
operator|*
name|c
operator|,
operator|*
name|c
operator|--
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|first
condition|)
block|{
while|while
condition|(
name|buf
operator|<
name|b
condition|)
block|{
operator|*
name|a
operator|--
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|--
operator|=
operator|*
name|a
expr_stmt|;
block|}
operator|*
name|a
operator|=
operator|*
name|b
operator|,
operator|*
name|b
operator|=
name|t
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|b
operator|<
literal|0
condition|)
block|{
name|p1
operator|=
name|PA
operator|+
operator|~
operator|*
name|b
expr_stmt|;
name|x
operator||=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|=
name|PA
operator|+
operator|*
name|b
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|c
operator|<
literal|0
condition|)
block|{
name|p2
operator|=
name|PA
operator|+
operator|~
operator|*
name|c
expr_stmt|;
name|x
operator||=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p2
operator|=
name|PA
operator|+
operator|*
name|c
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* D&C based merge. */
end_comment

begin_function
specifier|static
name|void
name|ss_swapmerge
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|middle
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
define|#
directive|define
name|STACK_SIZE
value|SS_SMERGE_STACKSIZE
define|#
directive|define
name|GETIDX
parameter_list|(
name|a
parameter_list|)
value|((0<= (a)) ? (a) : (~(a)))
define|#
directive|define
name|MERGE_CHECK
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {\     if(((c)& 1) ||\        (((c)& 2)&& (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\       *(a) = ~*(a);\     }\     if(((c)& 4)&& ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\       *(b) = ~*(b);\     }\   } while(0)
struct|struct
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|d
decl_stmt|;
block|}
name|stack
index|[
name|STACK_SIZE
index|]
struct|;
name|int
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|lm
decl_stmt|,
modifier|*
name|rm
decl_stmt|;
name|int
name|m
decl_stmt|,
name|len
decl_stmt|,
name|half
decl_stmt|;
name|int
name|ssize
decl_stmt|;
name|int
name|check
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|check
operator|=
literal|0
operator|,
name|ssize
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|last
operator|-
name|middle
operator|)
operator|<=
name|bufsize
condition|)
block|{
if|if
condition|(
operator|(
name|first
operator|<
name|middle
operator|)
operator|&&
operator|(
name|middle
operator|<
name|last
operator|)
condition|)
block|{
name|ss_mergebackward
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|buf
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|MERGE_CHECK
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|check
argument_list|)
expr_stmt|;
name|STACK_POP
argument_list|(
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|check
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|middle
operator|-
name|first
operator|)
operator|<=
name|bufsize
condition|)
block|{
if|if
condition|(
name|first
operator|<
name|middle
condition|)
block|{
name|ss_mergeforward
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|buf
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|MERGE_CHECK
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|check
argument_list|)
expr_stmt|;
name|STACK_POP
argument_list|(
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|check
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|m
operator|=
literal|0
operator|,
name|len
operator|=
name|MIN
argument_list|(
name|middle
operator|-
name|first
argument_list|,
name|last
operator|-
name|middle
argument_list|)
operator|,
name|half
operator|=
name|len
operator|>>
literal|1
init|;
literal|0
operator|<
name|len
condition|;
name|len
operator|=
name|half
operator|,
name|half
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|ss_compare
argument_list|(
name|T
argument_list|,
name|PA
operator|+
name|GETIDX
argument_list|(
operator|*
operator|(
name|middle
operator|+
name|m
operator|+
name|half
operator|)
argument_list|)
argument_list|,
name|PA
operator|+
name|GETIDX
argument_list|(
operator|*
operator|(
name|middle
operator|-
name|m
operator|-
name|half
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|depth
argument_list|)
operator|<
literal|0
condition|)
block|{
name|m
operator|+=
name|half
operator|+
literal|1
expr_stmt|;
name|half
operator|-=
operator|(
name|len
operator|&
literal|1
operator|)
operator|^
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
name|lm
operator|=
name|middle
operator|-
name|m
operator|,
name|rm
operator|=
name|middle
operator|+
name|m
expr_stmt|;
name|ss_blockswap
argument_list|(
name|lm
argument_list|,
name|middle
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|l
operator|=
name|r
operator|=
name|middle
operator|,
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rm
operator|<
name|last
condition|)
block|{
if|if
condition|(
operator|*
name|rm
operator|<
literal|0
condition|)
block|{
operator|*
name|rm
operator|=
operator|~
operator|*
name|rm
expr_stmt|;
if|if
condition|(
name|first
operator|<
name|lm
condition|)
block|{
for|for
control|(
init|;
operator|*
operator|--
name|l
operator|<
literal|0
condition|;
control|)
block|{ }
name|next
operator||=
literal|4
expr_stmt|;
block|}
name|next
operator||=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|<
name|lm
condition|)
block|{
for|for
control|(
init|;
operator|*
name|r
operator|<
literal|0
condition|;
operator|++
name|r
control|)
block|{ }
name|next
operator||=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|l
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|r
operator|)
condition|)
block|{
name|STACK_PUSH
argument_list|(
name|r
argument_list|,
name|rm
argument_list|,
name|last
argument_list|,
operator|(
name|next
operator|&
literal|3
operator|)
operator||
operator|(
name|check
operator|&
literal|4
operator|)
argument_list|)
expr_stmt|;
name|middle
operator|=
name|lm
operator|,
name|last
operator|=
name|l
operator|,
name|check
operator|=
operator|(
name|check
operator|&
literal|3
operator|)
operator||
operator|(
name|next
operator|&
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|next
operator|&
literal|2
operator|)
operator|&&
operator|(
name|r
operator|==
name|middle
operator|)
condition|)
block|{
name|next
operator|^=
literal|6
expr_stmt|;
block|}
name|STACK_PUSH
argument_list|(
name|first
argument_list|,
name|lm
argument_list|,
name|l
argument_list|,
operator|(
name|check
operator|&
literal|3
operator|)
operator||
operator|(
name|next
operator|&
literal|4
operator|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|r
operator|,
name|middle
operator|=
name|rm
operator|,
name|check
operator|=
operator|(
name|next
operator|&
literal|3
operator|)
operator||
operator|(
name|check
operator|&
literal|4
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ss_compare
argument_list|(
name|T
argument_list|,
name|PA
operator|+
name|GETIDX
argument_list|(
operator|*
operator|(
name|middle
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|PA
operator|+
operator|*
name|middle
argument_list|,
name|depth
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|middle
operator|=
operator|~
operator|*
name|middle
expr_stmt|;
block|}
name|MERGE_CHECK
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|check
argument_list|)
expr_stmt|;
name|STACK_POP
argument_list|(
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|check
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|STACK_SIZE
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SS_BLOCKSIZE != 0 */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Substring sort */
end_comment

begin_function
specifier|static
name|void
name|sssort
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
specifier|const
name|int
modifier|*
name|PA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|lastsuffix
parameter_list|)
block|{
name|int
modifier|*
name|a
decl_stmt|;
if|#
directive|if
name|SS_BLOCKSIZE
operator|!=
literal|0
name|int
modifier|*
name|b
decl_stmt|,
modifier|*
name|middle
decl_stmt|,
modifier|*
name|curbuf
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|curbufsize
decl_stmt|,
name|limit
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lastsuffix
operator|!=
literal|0
condition|)
block|{
operator|++
name|first
expr_stmt|;
block|}
if|#
directive|if
name|SS_BLOCKSIZE
operator|==
literal|0
name|ss_mintrosort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|depth
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|bufsize
operator|<
name|SS_BLOCKSIZE
operator|)
operator|&&
operator|(
name|bufsize
operator|<
operator|(
name|last
operator|-
name|first
operator|)
operator|)
operator|&&
operator|(
name|bufsize
operator|<
operator|(
name|limit
operator|=
name|ss_isqrt
argument_list|(
name|last
operator|-
name|first
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|SS_BLOCKSIZE
operator|<
name|limit
condition|)
block|{
name|limit
operator|=
name|SS_BLOCKSIZE
expr_stmt|;
block|}
name|buf
operator|=
name|middle
operator|=
name|last
operator|-
name|limit
operator|,
name|bufsize
operator|=
name|limit
expr_stmt|;
block|}
else|else
block|{
name|middle
operator|=
name|last
operator|,
name|limit
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
name|first
operator|,
name|i
operator|=
literal|0
init|;
name|SS_BLOCKSIZE
operator|<
operator|(
name|middle
operator|-
name|a
operator|)
condition|;
name|a
operator|+=
name|SS_BLOCKSIZE
operator|,
operator|++
name|i
control|)
block|{
if|#
directive|if
name|SS_INSERTIONSORT_THRESHOLD
operator|<
name|SS_BLOCKSIZE
name|ss_mintrosort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|a
argument_list|,
name|a
operator|+
name|SS_BLOCKSIZE
argument_list|,
name|depth
argument_list|)
expr_stmt|;
elif|#
directive|elif
literal|1
operator|<
name|SS_BLOCKSIZE
name|ss_insertionsort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|a
argument_list|,
name|a
operator|+
name|SS_BLOCKSIZE
argument_list|,
name|depth
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curbufsize
operator|=
name|last
operator|-
operator|(
name|a
operator|+
name|SS_BLOCKSIZE
operator|)
expr_stmt|;
name|curbuf
operator|=
name|a
operator|+
name|SS_BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|curbufsize
operator|<=
name|bufsize
condition|)
block|{
name|curbufsize
operator|=
name|bufsize
operator|,
name|curbuf
operator|=
name|buf
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
name|a
operator|,
name|k
operator|=
name|SS_BLOCKSIZE
operator|,
name|j
operator|=
name|i
init|;
name|j
operator|&
literal|1
condition|;
name|b
operator|-=
name|k
operator|,
name|k
operator|<<=
literal|1
operator|,
name|j
operator|>>=
literal|1
control|)
block|{
name|ss_swapmerge
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|b
operator|-
name|k
argument_list|,
name|b
argument_list|,
name|b
operator|+
name|k
argument_list|,
name|curbuf
argument_list|,
name|curbufsize
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|SS_INSERTIONSORT_THRESHOLD
operator|<
name|SS_BLOCKSIZE
name|ss_mintrosort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|a
argument_list|,
name|middle
argument_list|,
name|depth
argument_list|)
expr_stmt|;
elif|#
directive|elif
literal|1
operator|<
name|SS_BLOCKSIZE
name|ss_insertionsort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|a
argument_list|,
name|middle
argument_list|,
name|depth
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|k
operator|=
name|SS_BLOCKSIZE
init|;
name|i
operator|!=
literal|0
condition|;
name|k
operator|<<=
literal|1
operator|,
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|ss_swapmerge
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|a
operator|-
name|k
argument_list|,
name|a
argument_list|,
name|middle
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|a
operator|-=
name|k
expr_stmt|;
block|}
block|}
if|if
condition|(
name|limit
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|SS_INSERTIONSORT_THRESHOLD
operator|<
name|SS_BLOCKSIZE
name|ss_mintrosort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|depth
argument_list|)
expr_stmt|;
elif|#
directive|elif
literal|1
operator|<
name|SS_BLOCKSIZE
name|ss_insertionsort
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|depth
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ss_inplacemerge
argument_list|(
name|T
argument_list|,
name|PA
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lastsuffix
operator|!=
literal|0
condition|)
block|{
comment|/* Insert last type B* suffix. */
name|int
name|PAi
index|[
literal|2
index|]
decl_stmt|;
name|PAi
index|[
literal|0
index|]
operator|=
name|PA
index|[
operator|*
operator|(
name|first
operator|-
literal|1
operator|)
index|]
operator|,
name|PAi
index|[
literal|1
index|]
operator|=
name|n
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|a
operator|=
name|first
operator|,
name|i
operator|=
operator|*
operator|(
name|first
operator|-
literal|1
operator|)
init|;
operator|(
name|a
operator|<
name|last
operator|)
operator|&&
operator|(
operator|(
operator|*
name|a
operator|<
literal|0
operator|)
operator|||
operator|(
literal|0
operator|<
name|ss_compare
argument_list|(
name|T
argument_list|,
operator|&
operator|(
name|PAi
index|[
literal|0
index|]
operator|)
argument_list|,
name|PA
operator|+
operator|*
name|a
argument_list|,
name|depth
argument_list|)
operator|)
operator|)
condition|;
operator|++
name|a
control|)
block|{
operator|*
operator|(
name|a
operator|-
literal|1
operator|)
operator|=
operator|*
name|a
expr_stmt|;
block|}
operator|*
operator|(
name|a
operator|-
literal|1
operator|)
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|tr_ilg
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|&
literal|0xffff0000
operator|)
condition|?
operator|(
operator|(
name|n
operator|&
literal|0xff000000
operator|)
condition|?
literal|24
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|24
operator|)
operator|&
literal|0xff
index|]
else|:
literal|16
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator|)
else|:
operator|(
operator|(
name|n
operator|&
literal|0x0000ff00
operator|)
condition|?
literal|8
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
else|:
literal|0
operator|+
name|lg_table
index|[
operator|(
name|n
operator|>>
literal|0
operator|)
operator|&
literal|0xff
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Simple insertionsort for small size groups. */
end_comment

begin_function
specifier|static
name|void
name|tr_insertionsort
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|)
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|t
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
name|a
operator|=
name|first
operator|+
literal|1
init|;
name|a
operator|<
name|last
condition|;
operator|++
name|a
control|)
block|{
for|for
control|(
name|t
operator|=
operator|*
name|a
operator|,
name|b
operator|=
name|a
operator|-
literal|1
init|;
literal|0
operator|>
operator|(
name|r
operator|=
name|ISAd
index|[
name|t
index|]
operator|-
name|ISAd
index|[
operator|*
name|b
index|]
operator|)
condition|;
control|)
block|{
do|do
block|{
operator|*
operator|(
name|b
operator|+
literal|1
operator|)
operator|=
operator|*
name|b
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|first
operator|<=
operator|--
name|b
operator|)
operator|&&
operator|(
operator|*
name|b
operator|<
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|b
operator|<
name|first
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
operator|*
name|b
operator|=
operator|~
operator|*
name|b
expr_stmt|;
block|}
operator|*
operator|(
name|b
operator|+
literal|1
operator|)
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|tr_fixdown
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|v
decl_stmt|;
name|int
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|;
for|for
control|(
name|v
operator|=
name|SA
index|[
name|i
index|]
operator|,
name|c
operator|=
name|ISAd
index|[
name|v
index|]
init|;
operator|(
name|j
operator|=
literal|2
operator|*
name|i
operator|+
literal|1
operator|)
operator|<
name|size
condition|;
name|SA
index|[
name|i
index|]
operator|=
name|SA
index|[
name|k
index|]
operator|,
name|i
operator|=
name|k
control|)
block|{
name|d
operator|=
name|ISAd
index|[
name|SA
index|[
name|k
operator|=
name|j
operator|++
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
operator|(
name|e
operator|=
name|ISAd
index|[
name|SA
index|[
name|j
index|]
index|]
operator|)
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|d
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<=
name|c
condition|)
block|{
break|break;
block|}
block|}
name|SA
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple top-down heapsort. */
end_comment

begin_function
specifier|static
name|void
name|tr_heapsort
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|int
name|t
decl_stmt|;
name|m
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|--
expr_stmt|;
if|if
condition|(
name|ISAd
index|[
name|SA
index|[
name|m
operator|/
literal|2
index|]
index|]
operator|<
name|ISAd
index|[
name|SA
index|[
name|m
index|]
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|SA
index|[
name|m
index|]
argument_list|,
name|SA
index|[
name|m
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|m
operator|/
literal|2
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
name|tr_fixdown
argument_list|(
name|ISAd
argument_list|,
name|SA
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|SA
index|[
literal|0
index|]
argument_list|,
name|SA
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|tr_fixdown
argument_list|(
name|ISAd
argument_list|,
name|SA
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|1
init|;
literal|0
operator|<
name|i
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|SA
index|[
literal|0
index|]
operator|,
name|SA
index|[
literal|0
index|]
operator|=
name|SA
index|[
name|i
index|]
expr_stmt|;
name|tr_fixdown
argument_list|(
name|ISAd
argument_list|,
name|SA
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SA
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Returns the median of three elements. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|tr_median3
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|v1
parameter_list|,
name|int
modifier|*
name|v2
parameter_list|,
name|int
modifier|*
name|v3
parameter_list|)
block|{
name|int
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ISAd
index|[
operator|*
name|v1
index|]
operator|>
name|ISAd
index|[
operator|*
name|v2
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISAd
index|[
operator|*
name|v2
index|]
operator|>
name|ISAd
index|[
operator|*
name|v3
index|]
condition|)
block|{
if|if
condition|(
name|ISAd
index|[
operator|*
name|v1
index|]
operator|>
name|ISAd
index|[
operator|*
name|v3
index|]
condition|)
block|{
return|return
name|v1
return|;
block|}
else|else
block|{
return|return
name|v3
return|;
block|}
block|}
return|return
name|v2
return|;
block|}
end_function

begin_comment
comment|/* Returns the median of five elements. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|tr_median5
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|v1
parameter_list|,
name|int
modifier|*
name|v2
parameter_list|,
name|int
modifier|*
name|v3
parameter_list|,
name|int
modifier|*
name|v4
parameter_list|,
name|int
modifier|*
name|v5
parameter_list|)
block|{
name|int
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ISAd
index|[
operator|*
name|v2
index|]
operator|>
name|ISAd
index|[
operator|*
name|v3
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISAd
index|[
operator|*
name|v4
index|]
operator|>
name|ISAd
index|[
operator|*
name|v5
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v4
argument_list|,
name|v5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISAd
index|[
operator|*
name|v2
index|]
operator|>
name|ISAd
index|[
operator|*
name|v4
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v2
argument_list|,
name|v4
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
name|v3
argument_list|,
name|v5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISAd
index|[
operator|*
name|v1
index|]
operator|>
name|ISAd
index|[
operator|*
name|v3
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v1
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISAd
index|[
operator|*
name|v1
index|]
operator|>
name|ISAd
index|[
operator|*
name|v4
index|]
condition|)
block|{
name|SWAP
argument_list|(
name|v1
argument_list|,
name|v4
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
name|v3
argument_list|,
name|v5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISAd
index|[
operator|*
name|v3
index|]
operator|>
name|ISAd
index|[
operator|*
name|v4
index|]
condition|)
block|{
return|return
name|v4
return|;
block|}
return|return
name|v3
return|;
block|}
end_function

begin_comment
comment|/* Returns the pivot element. */
end_comment

begin_function
specifier|static
name|INLINE
name|int
modifier|*
name|tr_pivot
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|)
block|{
name|int
modifier|*
name|middle
decl_stmt|;
name|int
name|t
decl_stmt|;
name|t
operator|=
name|last
operator|-
name|first
expr_stmt|;
name|middle
operator|=
name|first
operator|+
name|t
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|t
operator|<=
literal|512
condition|)
block|{
if|if
condition|(
name|t
operator|<=
literal|32
condition|)
block|{
return|return
name|tr_median3
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|t
operator|>>=
literal|2
expr_stmt|;
return|return
name|tr_median5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|first
operator|+
name|t
argument_list|,
name|middle
argument_list|,
name|last
operator|-
literal|1
operator|-
name|t
argument_list|,
name|last
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
name|t
operator|>>=
literal|3
expr_stmt|;
name|first
operator|=
name|tr_median3
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|first
operator|+
name|t
argument_list|,
name|first
operator|+
operator|(
name|t
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|middle
operator|=
name|tr_median3
argument_list|(
name|ISAd
argument_list|,
name|middle
operator|-
name|t
argument_list|,
name|middle
argument_list|,
name|middle
operator|+
name|t
argument_list|)
expr_stmt|;
name|last
operator|=
name|tr_median3
argument_list|(
name|ISAd
argument_list|,
name|last
operator|-
literal|1
operator|-
operator|(
name|t
operator|<<
literal|1
operator|)
argument_list|,
name|last
operator|-
literal|1
operator|-
name|t
argument_list|,
name|last
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|tr_median3
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|middle
argument_list|,
name|last
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_typedef
typedef|typedef
name|struct
name|_trbudget_t
name|trbudget_t
typedef|;
end_typedef

begin_struct
struct|struct
name|_trbudget_t
block|{
name|int
name|chance
decl_stmt|;
name|int
name|remain
decl_stmt|;
name|int
name|incval
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|INLINE
name|void
name|trbudget_init
parameter_list|(
name|trbudget_t
modifier|*
name|budget
parameter_list|,
name|int
name|chance
parameter_list|,
name|int
name|incval
parameter_list|)
block|{
name|budget
operator|->
name|chance
operator|=
name|chance
expr_stmt|;
name|budget
operator|->
name|remain
operator|=
name|budget
operator|->
name|incval
operator|=
name|incval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|trbudget_check
parameter_list|(
name|trbudget_t
modifier|*
name|budget
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
name|budget
operator|->
name|remain
condition|)
block|{
name|budget
operator|->
name|remain
operator|-=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|budget
operator|->
name|chance
operator|==
literal|0
condition|)
block|{
name|budget
operator|->
name|count
operator|+=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
name|budget
operator|->
name|remain
operator|+=
name|budget
operator|->
name|incval
operator|-
name|size
expr_stmt|;
name|budget
operator|->
name|chance
operator|-=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|tr_partition
parameter_list|(
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|middle
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
modifier|*
modifier|*
name|pa
parameter_list|,
name|int
modifier|*
modifier|*
name|pb
parameter_list|,
name|int
name|v
parameter_list|)
block|{
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|int
name|t
decl_stmt|,
name|s
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
name|b
operator|=
name|middle
operator|-
literal|1
init|;
operator|(
operator|++
name|b
operator|<
name|last
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|b
index|]
operator|)
operator|==
name|v
operator|)
condition|;
control|)
block|{ }
if|if
condition|(
operator|(
operator|(
name|a
operator|=
name|b
operator|)
operator|<
name|last
operator|)
operator|&&
operator|(
name|x
operator|<
name|v
operator|)
condition|)
block|{
for|for
control|(
init|;
operator|(
operator|++
name|b
operator|<
name|last
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|b
index|]
operator|)
operator|<=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|c
operator|=
name|last
init|;
operator|(
name|b
operator|<
operator|--
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|c
index|]
operator|)
operator|==
name|v
operator|)
condition|;
control|)
block|{ }
if|if
condition|(
operator|(
name|b
operator|<
operator|(
name|d
operator|=
name|c
operator|)
operator|)
operator|&&
operator|(
name|x
operator|>
name|v
operator|)
condition|)
block|{
for|for
control|(
init|;
operator|(
name|b
operator|<
operator|--
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|c
index|]
operator|)
operator|>=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
operator|--
name|d
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
name|b
operator|<
name|c
condition|;
control|)
block|{
name|SWAP
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|++
name|b
operator|<
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|b
index|]
operator|)
operator|<=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
operator|(
name|b
operator|<
operator|--
name|c
operator|)
operator|&&
operator|(
operator|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|c
index|]
operator|)
operator|>=
name|v
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
name|v
condition|)
block|{
name|SWAP
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
operator|--
name|d
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|<=
name|d
condition|)
block|{
name|c
operator|=
name|b
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|a
operator|-
name|first
operator|)
operator|>
operator|(
name|t
operator|=
name|b
operator|-
name|a
operator|)
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|first
operator|,
name|f
operator|=
name|b
operator|-
name|s
init|;
literal|0
operator|<
name|s
condition|;
operator|--
name|s
operator|,
operator|++
name|e
operator|,
operator|++
name|f
control|)
block|{
name|SWAP
argument_list|(
operator|*
name|e
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|d
operator|-
name|c
operator|)
operator|>
operator|(
name|t
operator|=
name|last
operator|-
name|d
operator|-
literal|1
operator|)
condition|)
block|{
name|s
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|b
operator|,
name|f
operator|=
name|last
operator|-
name|s
init|;
literal|0
operator|<
name|s
condition|;
operator|--
name|s
operator|,
operator|++
name|e
operator|,
operator|++
name|f
control|)
block|{
name|SWAP
argument_list|(
operator|*
name|e
argument_list|,
operator|*
name|f
argument_list|)
expr_stmt|;
block|}
name|first
operator|+=
operator|(
name|b
operator|-
name|a
operator|)
operator|,
name|last
operator|-=
operator|(
name|d
operator|-
name|c
operator|)
expr_stmt|;
block|}
operator|*
name|pa
operator|=
name|first
operator|,
operator|*
name|pb
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tr_copy
parameter_list|(
name|int
modifier|*
name|ISA
parameter_list|,
specifier|const
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
comment|/* sort suffixes of middle partition      by using sorted order of suffixes of left and right partition. */
name|int
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|s
decl_stmt|,
name|v
decl_stmt|;
name|v
operator|=
name|b
operator|-
name|SA
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
name|first
operator|,
name|d
operator|=
name|a
operator|-
literal|1
init|;
name|c
operator|<=
name|d
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
operator|(
name|s
operator|=
operator|*
name|c
operator|-
name|depth
operator|)
operator|)
operator|&&
operator|(
name|ISA
index|[
name|s
index|]
operator|==
name|v
operator|)
condition|)
block|{
operator|*
operator|++
name|d
operator|=
name|s
expr_stmt|;
name|ISA
index|[
name|s
index|]
operator|=
name|d
operator|-
name|SA
expr_stmt|;
block|}
block|}
for|for
control|(
name|c
operator|=
name|last
operator|-
literal|1
operator|,
name|e
operator|=
name|d
operator|+
literal|1
operator|,
name|d
operator|=
name|b
init|;
name|e
operator|<
name|d
condition|;
operator|--
name|c
control|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
operator|(
name|s
operator|=
operator|*
name|c
operator|-
name|depth
operator|)
operator|)
operator|&&
operator|(
name|ISA
index|[
name|s
index|]
operator|==
name|v
operator|)
condition|)
block|{
operator|*
operator|--
name|d
operator|=
name|s
expr_stmt|;
name|ISA
index|[
name|s
index|]
operator|=
name|d
operator|-
name|SA
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tr_partialcopy
parameter_list|(
name|int
modifier|*
name|ISA
parameter_list|,
specifier|const
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|s
decl_stmt|,
name|v
decl_stmt|;
name|int
name|rank
decl_stmt|,
name|lastrank
decl_stmt|,
name|newrank
init|=
operator|-
literal|1
decl_stmt|;
name|v
operator|=
name|b
operator|-
name|SA
operator|-
literal|1
expr_stmt|;
name|lastrank
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
name|first
operator|,
name|d
operator|=
name|a
operator|-
literal|1
init|;
name|c
operator|<=
name|d
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
operator|(
name|s
operator|=
operator|*
name|c
operator|-
name|depth
operator|)
operator|)
operator|&&
operator|(
name|ISA
index|[
name|s
index|]
operator|==
name|v
operator|)
condition|)
block|{
operator|*
operator|++
name|d
operator|=
name|s
expr_stmt|;
name|rank
operator|=
name|ISA
index|[
name|s
operator|+
name|depth
index|]
expr_stmt|;
if|if
condition|(
name|lastrank
operator|!=
name|rank
condition|)
block|{
name|lastrank
operator|=
name|rank
expr_stmt|;
name|newrank
operator|=
name|d
operator|-
name|SA
expr_stmt|;
block|}
name|ISA
index|[
name|s
index|]
operator|=
name|newrank
expr_stmt|;
block|}
block|}
name|lastrank
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|e
operator|=
name|d
init|;
name|first
operator|<=
name|e
condition|;
operator|--
name|e
control|)
block|{
name|rank
operator|=
name|ISA
index|[
operator|*
name|e
index|]
expr_stmt|;
if|if
condition|(
name|lastrank
operator|!=
name|rank
condition|)
block|{
name|lastrank
operator|=
name|rank
expr_stmt|;
name|newrank
operator|=
name|e
operator|-
name|SA
expr_stmt|;
block|}
if|if
condition|(
name|newrank
operator|!=
name|rank
condition|)
block|{
name|ISA
index|[
operator|*
name|e
index|]
operator|=
name|newrank
expr_stmt|;
block|}
block|}
name|lastrank
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
name|last
operator|-
literal|1
operator|,
name|e
operator|=
name|d
operator|+
literal|1
operator|,
name|d
operator|=
name|b
init|;
name|e
operator|<
name|d
condition|;
operator|--
name|c
control|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
operator|(
name|s
operator|=
operator|*
name|c
operator|-
name|depth
operator|)
operator|)
operator|&&
operator|(
name|ISA
index|[
name|s
index|]
operator|==
name|v
operator|)
condition|)
block|{
operator|*
operator|--
name|d
operator|=
name|s
expr_stmt|;
name|rank
operator|=
name|ISA
index|[
name|s
operator|+
name|depth
index|]
expr_stmt|;
if|if
condition|(
name|lastrank
operator|!=
name|rank
condition|)
block|{
name|lastrank
operator|=
name|rank
expr_stmt|;
name|newrank
operator|=
name|d
operator|-
name|SA
expr_stmt|;
block|}
name|ISA
index|[
name|s
index|]
operator|=
name|newrank
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tr_introsort
parameter_list|(
name|int
modifier|*
name|ISA
parameter_list|,
specifier|const
name|int
modifier|*
name|ISAd
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|first
parameter_list|,
name|int
modifier|*
name|last
parameter_list|,
name|trbudget_t
modifier|*
name|budget
parameter_list|)
block|{
define|#
directive|define
name|STACK_SIZE
value|TR_STACKSIZE
struct|struct
block|{
specifier|const
name|int
modifier|*
name|a
decl_stmt|;
name|int
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|d
decl_stmt|,
name|e
decl_stmt|;
block|}
name|stack
index|[
name|STACK_SIZE
index|]
struct|;
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|v
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
name|int
name|incr
init|=
name|ISAd
operator|-
name|ISA
decl_stmt|;
name|int
name|limit
decl_stmt|,
name|next
decl_stmt|;
name|int
name|ssize
decl_stmt|,
name|trlink
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|ssize
operator|=
literal|0
operator|,
name|limit
operator|=
name|tr_ilg
argument_list|(
name|last
operator|-
name|first
argument_list|)
init|;
condition|;
control|)
block|{
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|limit
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* tandem repeat partition */
name|tr_partition
argument_list|(
name|ISAd
operator|-
name|incr
argument_list|,
name|first
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|last
operator|-
name|SA
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* update ranks */
if|if
condition|(
name|a
operator|<
name|last
condition|)
block|{
for|for
control|(
name|c
operator|=
name|first
operator|,
name|v
operator|=
name|a
operator|-
name|SA
operator|-
literal|1
init|;
name|c
operator|<
name|a
condition|;
operator|++
name|c
control|)
block|{
name|ISA
index|[
operator|*
name|c
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
if|if
condition|(
name|b
operator|<
name|last
condition|)
block|{
for|for
control|(
name|c
operator|=
name|a
operator|,
name|v
operator|=
name|b
operator|-
name|SA
operator|-
literal|1
init|;
name|c
operator|<
name|b
condition|;
operator|++
name|c
control|)
block|{
name|ISA
index|[
operator|*
name|c
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
comment|/* push */
if|if
condition|(
literal|1
operator|<
operator|(
name|b
operator|-
name|a
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|NULL
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|-
name|incr
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
operator|-
literal|2
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|trlink
operator|=
name|ssize
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|tr_ilg
argument_list|(
name|last
operator|-
name|b
argument_list|)
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
operator|,
name|limit
operator|=
name|tr_ilg
argument_list|(
name|a
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|first
operator|=
name|b
operator|,
name|limit
operator|=
name|tr_ilg
argument_list|(
name|last
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|tr_ilg
argument_list|(
name|a
operator|-
name|first
argument_list|)
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
operator|,
name|limit
operator|=
name|tr_ilg
argument_list|(
name|last
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|last
operator|=
name|a
operator|,
name|limit
operator|=
name|tr_ilg
argument_list|(
name|a
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|limit
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* tandem repeat copy */
name|a
operator|=
name|stack
index|[
operator|--
name|ssize
index|]
operator|.
name|b
operator|,
name|b
operator|=
name|stack
index|[
name|ssize
index|]
operator|.
name|c
expr_stmt|;
if|if
condition|(
name|stack
index|[
name|ssize
index|]
operator|.
name|d
operator|==
literal|0
condition|)
block|{
name|tr_copy
argument_list|(
name|ISA
argument_list|,
name|SA
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|ISAd
operator|-
name|ISA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|0
operator|<=
name|trlink
condition|)
block|{
name|stack
index|[
name|trlink
index|]
operator|.
name|d
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|tr_partialcopy
argument_list|(
name|ISA
argument_list|,
name|SA
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|ISAd
operator|-
name|ISA
argument_list|)
expr_stmt|;
block|}
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* sorted partition */
if|if
condition|(
literal|0
operator|<=
operator|*
name|first
condition|)
block|{
name|a
operator|=
name|first
expr_stmt|;
do|do
block|{
name|ISA
index|[
operator|*
name|a
index|]
operator|=
name|a
operator|-
name|SA
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|++
name|a
operator|<
name|last
operator|)
operator|&&
operator|(
literal|0
operator|<=
operator|*
name|a
operator|)
condition|)
do|;
name|first
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|<
name|last
condition|)
block|{
name|a
operator|=
name|first
expr_stmt|;
do|do
block|{
operator|*
name|a
operator|=
operator|~
operator|*
name|a
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|a
operator|<
literal|0
condition|)
do|;
name|next
operator|=
operator|(
name|ISA
index|[
operator|*
name|a
index|]
operator|!=
name|ISAd
index|[
operator|*
name|a
index|]
operator|)
condition|?
name|tr_ilg
argument_list|(
name|a
operator|-
name|first
operator|+
literal|1
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|a
operator|<
name|last
condition|)
block|{
for|for
control|(
name|b
operator|=
name|first
operator|,
name|v
operator|=
name|a
operator|-
name|SA
operator|-
literal|1
init|;
name|b
operator|<
name|a
condition|;
operator|++
name|b
control|)
block|{
name|ISA
index|[
operator|*
name|b
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
comment|/* push */
if|if
condition|(
name|trbudget_check
argument_list|(
name|budget
argument_list|,
name|a
operator|-
name|first
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|a
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|a
argument_list|,
name|last
argument_list|,
operator|-
literal|3
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|ISAd
operator|+=
name|incr
operator|,
name|last
operator|=
name|a
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|a
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|first
operator|=
name|a
operator|,
name|limit
operator|=
operator|-
literal|3
expr_stmt|;
block|}
else|else
block|{
name|ISAd
operator|+=
name|incr
operator|,
name|last
operator|=
name|a
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
literal|0
operator|<=
name|trlink
condition|)
block|{
name|stack
index|[
name|trlink
index|]
operator|.
name|d
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|a
operator|)
condition|)
block|{
name|first
operator|=
name|a
operator|,
name|limit
operator|=
operator|-
literal|3
expr_stmt|;
block|}
else|else
block|{
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|last
operator|-
name|first
operator|)
operator|<=
name|TR_INSERTIONSORT_THRESHOLD
condition|)
block|{
name|tr_insertionsort
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|-
literal|3
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|limit
operator|--
operator|==
literal|0
condition|)
block|{
name|tr_heapsort
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|last
operator|-
literal|1
init|;
name|first
operator|<
name|a
condition|;
name|a
operator|=
name|b
control|)
block|{
for|for
control|(
name|x
operator|=
name|ISAd
index|[
operator|*
name|a
index|]
operator|,
name|b
operator|=
name|a
operator|-
literal|1
init|;
operator|(
name|first
operator|<=
name|b
operator|)
operator|&&
operator|(
name|ISAd
index|[
operator|*
name|b
index|]
operator|==
name|x
operator|)
condition|;
operator|--
name|b
control|)
block|{
operator|*
name|b
operator|=
operator|~
operator|*
name|b
expr_stmt|;
block|}
block|}
name|limit
operator|=
operator|-
literal|3
expr_stmt|;
continue|continue;
block|}
comment|/* choose pivot */
name|a
operator|=
name|tr_pivot
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|SWAP
argument_list|(
operator|*
name|first
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
name|v
operator|=
name|ISAd
index|[
operator|*
name|first
index|]
expr_stmt|;
comment|/* partition */
name|tr_partition
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|first
operator|+
literal|1
argument_list|,
name|last
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|last
operator|-
name|first
operator|)
operator|!=
operator|(
name|b
operator|-
name|a
operator|)
condition|)
block|{
name|next
operator|=
operator|(
name|ISA
index|[
operator|*
name|a
index|]
operator|!=
name|v
operator|)
condition|?
name|tr_ilg
argument_list|(
name|b
operator|-
name|a
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
comment|/* update ranks */
for|for
control|(
name|c
operator|=
name|first
operator|,
name|v
operator|=
name|a
operator|-
name|SA
operator|-
literal|1
init|;
name|c
operator|<
name|a
condition|;
operator|++
name|c
control|)
block|{
name|ISA
index|[
operator|*
name|c
index|]
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
name|last
condition|)
block|{
for|for
control|(
name|c
operator|=
name|a
operator|,
name|v
operator|=
name|b
operator|-
name|SA
operator|-
literal|1
init|;
name|c
operator|<
name|b
condition|;
operator|++
name|c
control|)
block|{
name|ISA
index|[
operator|*
name|c
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
comment|/* push */
if|if
condition|(
operator|(
literal|1
operator|<
operator|(
name|b
operator|-
name|a
operator|)
operator|)
operator|&&
operator|(
name|trbudget_check
argument_list|(
name|budget
argument_list|,
name|b
operator|-
name|a
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|last
operator|-
name|b
operator|)
operator|<=
operator|(
name|b
operator|-
name|a
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|ISAd
operator|+=
name|incr
operator|,
name|first
operator|=
name|a
operator|,
name|last
operator|=
name|b
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|b
operator|-
name|a
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|ISAd
operator|+=
name|incr
operator|,
name|first
operator|=
name|a
operator|,
name|last
operator|=
name|b
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|ISAd
operator|+=
name|incr
operator|,
name|first
operator|=
name|a
operator|,
name|last
operator|=
name|b
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|b
operator|-
name|a
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|ISAd
operator|+=
name|incr
operator|,
name|first
operator|=
name|a
operator|,
name|last
operator|=
name|b
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|last
operator|-
name|b
operator|)
operator|<=
operator|(
name|b
operator|-
name|a
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
operator|+
name|incr
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|next
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|ISAd
operator|+=
name|incr
operator|,
name|first
operator|=
name|a
operator|,
name|last
operator|=
name|b
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|ISAd
operator|+=
name|incr
operator|,
name|first
operator|=
name|a
operator|,
name|last
operator|=
name|b
operator|,
name|limit
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
literal|1
operator|<
operator|(
name|b
operator|-
name|a
operator|)
operator|)
operator|&&
operator|(
literal|0
operator|<=
name|trlink
operator|)
condition|)
block|{
name|stack
index|[
name|trlink
index|]
operator|.
name|d
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|a
operator|-
name|first
operator|)
operator|<=
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|b
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|last
operator|=
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|first
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|b
operator|)
condition|)
block|{
name|STACK_PUSH5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|a
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|1
operator|<
operator|(
name|a
operator|-
name|first
operator|)
condition|)
block|{
name|last
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|trbudget_check
argument_list|(
name|budget
argument_list|,
name|last
operator|-
name|first
argument_list|)
condition|)
block|{
name|limit
operator|=
name|tr_ilg
argument_list|(
name|last
operator|-
name|first
argument_list|)
operator|,
name|ISAd
operator|+=
name|incr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|0
operator|<=
name|trlink
condition|)
block|{
name|stack
index|[
name|trlink
index|]
operator|.
name|d
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|STACK_POP5
argument_list|(
name|ISAd
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
name|limit
argument_list|,
name|trlink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|STACK_SIZE
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Tandem repeat sort */
end_comment

begin_function
specifier|static
name|void
name|trsort
parameter_list|(
name|int
modifier|*
name|ISA
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
modifier|*
name|ISAd
decl_stmt|;
name|int
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|trbudget_t
name|budget
decl_stmt|;
name|int
name|t
decl_stmt|,
name|skip
decl_stmt|,
name|unsorted
decl_stmt|;
name|trbudget_init
argument_list|(
operator|&
name|budget
argument_list|,
name|tr_ilg
argument_list|(
name|n
argument_list|)
operator|*
literal|2
operator|/
literal|3
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/*  trbudget_init(&budget, tr_ilg(n) * 3 / 4, n); */
for|for
control|(
name|ISAd
operator|=
name|ISA
operator|+
name|depth
init|;
operator|-
name|n
operator|<
operator|*
name|SA
condition|;
name|ISAd
operator|+=
name|ISAd
operator|-
name|ISA
control|)
block|{
name|first
operator|=
name|SA
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
name|unsorted
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|t
operator|=
operator|*
name|first
operator|)
operator|<
literal|0
condition|)
block|{
name|first
operator|-=
name|t
expr_stmt|;
name|skip
operator|+=
name|t
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|first
operator|+
name|skip
operator|)
operator|=
name|skip
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
name|last
operator|=
name|SA
operator|+
name|ISA
index|[
name|t
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
literal|1
operator|<
operator|(
name|last
operator|-
name|first
operator|)
condition|)
block|{
name|budget
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|tr_introsort
argument_list|(
name|ISA
argument_list|,
name|ISAd
argument_list|,
name|SA
argument_list|,
name|first
argument_list|,
name|last
argument_list|,
operator|&
name|budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|budget
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|unsorted
operator|+=
name|budget
operator|.
name|count
expr_stmt|;
block|}
else|else
block|{
name|skip
operator|=
name|first
operator|-
name|last
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|last
operator|-
name|first
operator|)
operator|==
literal|1
condition|)
block|{
name|skip
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|first
operator|=
name|last
expr_stmt|;
block|}
block|}
do|while
condition|(
name|first
operator|<
operator|(
name|SA
operator|+
name|n
operator|)
condition|)
do|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|first
operator|+
name|skip
operator|)
operator|=
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|unsorted
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Sorts suffixes of type B*. */
end_comment

begin_function
specifier|static
name|int
name|sort_typeBstar
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|bucket_A
parameter_list|,
name|int
modifier|*
name|bucket_B
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|openMP
parameter_list|)
block|{
name|int
modifier|*
name|PAb
decl_stmt|,
modifier|*
name|ISAb
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBBSC_OPENMP
name|int
modifier|*
name|curbuf
decl_stmt|;
name|int
name|l
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|t
decl_stmt|,
name|m
decl_stmt|,
name|bufsize
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBBSC_OPENMP
name|int
name|d0
decl_stmt|,
name|d1
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|openMP
expr_stmt|;
comment|/* Initialize bucket arrays. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKET_A_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|bucket_A
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKET_B_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|bucket_B
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Count the number of occurrences of the first one or two characters of each      type A, B and B* suffix. Moreover, store the beginning position of all      type B* suffixes into the array SA. */
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
operator|,
name|m
operator|=
name|n
operator|,
name|c0
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
init|;
literal|0
operator|<=
name|i
condition|;
control|)
block|{
comment|/* type A suffix. */
do|do
block|{
operator|++
name|BUCKET_A
argument_list|(
name|c1
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
literal|0
operator|<=
operator|--
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|>=
name|c1
operator|)
condition|)
do|;
if|if
condition|(
literal|0
operator|<=
name|i
condition|)
block|{
comment|/* type B* suffix. */
operator|++
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|SA
index|[
operator|--
name|m
index|]
operator|=
name|i
expr_stmt|;
comment|/* type B suffix. */
for|for
control|(
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
init|;
operator|(
literal|0
operator|<=
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|<=
name|c1
operator|)
condition|;
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
control|)
block|{
operator|++
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|m
operator|=
name|n
operator|-
name|m
expr_stmt|;
comment|/* note:   A type B* suffix is lexicographically smaller than a type B suffix that   begins with the same first two characters. */
comment|/* Calculate the index of start/end point of each bucket. */
for|for
control|(
name|c0
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|c0
operator|<
name|ALPHABET_SIZE
condition|;
operator|++
name|c0
control|)
block|{
name|t
operator|=
name|i
operator|+
name|BUCKET_A
argument_list|(
name|c0
argument_list|)
expr_stmt|;
name|BUCKET_A
argument_list|(
name|c0
argument_list|)
operator|=
name|i
operator|+
name|j
expr_stmt|;
comment|/* start point */
name|i
operator|=
name|t
operator|+
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c0
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c0
operator|+
literal|1
init|;
name|c1
operator|<
name|ALPHABET_SIZE
condition|;
operator|++
name|c1
control|)
block|{
name|j
operator|+=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|=
name|j
expr_stmt|;
comment|/* end point */
name|i
operator|+=
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Sort the type B* suffixes by their first two characters. */
name|PAb
operator|=
name|SA
operator|+
name|n
operator|-
name|m
expr_stmt|;
name|ISAb
operator|=
name|SA
operator|+
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|2
init|;
literal|0
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|PAb
index|[
name|i
index|]
operator|,
name|c0
operator|=
name|T
index|[
name|t
index|]
operator|,
name|c1
operator|=
name|T
index|[
name|t
operator|+
literal|1
index|]
expr_stmt|;
name|SA
index|[
operator|--
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
name|t
operator|=
name|PAb
index|[
name|m
operator|-
literal|1
index|]
operator|,
name|c0
operator|=
name|T
index|[
name|t
index|]
operator|,
name|c1
operator|=
name|T
index|[
name|t
operator|+
literal|1
index|]
expr_stmt|;
name|SA
index|[
operator|--
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
index|]
operator|=
name|m
operator|-
literal|1
expr_stmt|;
comment|/* Sort the type B* substrings using sssort. */
ifdef|#
directive|ifdef
name|LIBBSC_OPENMP
if|if
condition|(
name|openMP
condition|)
block|{
name|buf
operator|=
name|SA
operator|+
name|m
expr_stmt|;
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
operator|,
name|j
operator|=
name|m
expr_stmt|;
pragma|#
directive|pragma
name|omp
name|parallel
name|default
name|(
name|shared
name|)
name|private
name|(
name|bufsize
name|,
name|curbuf
name|,
name|k
name|,
name|l
name|,
name|d0
name|,
name|d1
name|)
block|{
name|bufsize
operator|=
operator|(
name|n
operator|-
operator|(
literal|2
operator|*
name|m
operator|)
operator|)
operator|/
name|omp_get_num_threads
argument_list|()
expr_stmt|;
name|curbuf
operator|=
name|buf
operator|+
name|omp_get_thread_num
argument_list|()
operator|*
name|bufsize
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
pragma|#
directive|pragma
name|omp
name|critical
name|(
name|sssort_lock
name|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|l
operator|=
name|j
operator|)
condition|)
block|{
name|d0
operator|=
name|c0
operator|,
name|d1
operator|=
name|c1
expr_stmt|;
do|do
block|{
name|k
operator|=
name|BUCKET_BSTAR
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|d1
operator|<=
name|d0
condition|)
block|{
name|d1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|d0
operator|<
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|l
operator|-
name|k
operator|)
operator|<=
literal|1
operator|)
operator|&&
operator|(
literal|0
operator|<
operator|(
name|l
operator|=
name|k
operator|)
operator|)
condition|)
do|;
name|c0
operator|=
name|d0
operator|,
name|c1
operator|=
name|d1
operator|,
name|j
operator|=
name|k
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|sssort
argument_list|(
name|T
argument_list|,
name|PAb
argument_list|,
name|SA
operator|+
name|k
argument_list|,
name|SA
operator|+
name|l
argument_list|,
name|curbuf
argument_list|,
name|bufsize
argument_list|,
literal|2
argument_list|,
name|n
argument_list|,
operator|*
operator|(
name|SA
operator|+
name|k
operator|)
operator|==
operator|(
name|m
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|buf
operator|=
name|SA
operator|+
name|m
operator|,
name|bufsize
operator|=
name|n
operator|-
operator|(
literal|2
operator|*
name|m
operator|)
expr_stmt|;
for|for
control|(
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|j
operator|=
name|m
init|;
literal|0
operator|<
name|j
condition|;
operator|--
name|c0
control|)
block|{
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
init|;
name|c0
operator|<
name|c1
condition|;
name|j
operator|=
name|i
operator|,
operator|--
name|c1
control|)
block|{
name|i
operator|=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
operator|(
name|j
operator|-
name|i
operator|)
condition|)
block|{
name|sssort
argument_list|(
name|T
argument_list|,
name|PAb
argument_list|,
name|SA
operator|+
name|i
argument_list|,
name|SA
operator|+
name|j
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|2
argument_list|,
name|n
argument_list|,
operator|*
operator|(
name|SA
operator|+
name|i
operator|)
operator|==
operator|(
name|m
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|#
directive|else
name|buf
operator|=
name|SA
operator|+
name|m
operator|,
name|bufsize
operator|=
name|n
operator|-
operator|(
literal|2
operator|*
name|m
operator|)
expr_stmt|;
for|for
control|(
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|j
operator|=
name|m
init|;
literal|0
operator|<
name|j
condition|;
operator|--
name|c0
control|)
block|{
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
init|;
name|c0
operator|<
name|c1
condition|;
name|j
operator|=
name|i
operator|,
operator|--
name|c1
control|)
block|{
name|i
operator|=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
operator|(
name|j
operator|-
name|i
operator|)
condition|)
block|{
name|sssort
argument_list|(
name|T
argument_list|,
name|PAb
argument_list|,
name|SA
operator|+
name|i
argument_list|,
name|SA
operator|+
name|j
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|2
argument_list|,
name|n
argument_list|,
operator|*
operator|(
name|SA
operator|+
name|i
operator|)
operator|==
operator|(
name|m
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Compute ranks of type B* substrings. */
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|1
init|;
literal|0
operator|<=
name|i
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<=
name|SA
index|[
name|i
index|]
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
name|ISAb
index|[
name|SA
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|(
literal|0
operator|<=
operator|--
name|i
operator|)
operator|&&
operator|(
literal|0
operator|<=
name|SA
index|[
name|i
index|]
operator|)
condition|)
do|;
name|SA
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|i
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
name|ISAb
index|[
name|SA
index|[
name|i
index|]
operator|=
operator|~
name|SA
index|[
name|i
index|]
index|]
operator|=
name|j
expr_stmt|;
block|}
do|while
condition|(
name|SA
index|[
operator|--
name|i
index|]
operator|<
literal|0
condition|)
do|;
name|ISAb
index|[
name|SA
index|[
name|i
index|]
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/* Construct the inverse suffix array of type B* suffixes using trsort. */
name|trsort
argument_list|(
name|ISAb
argument_list|,
name|SA
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the sorted order of tyoe B* suffixes. */
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
operator|,
name|j
operator|=
name|m
operator|,
name|c0
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
init|;
literal|0
operator|<=
name|i
condition|;
control|)
block|{
for|for
control|(
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
init|;
operator|(
literal|0
operator|<=
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|>=
name|c1
operator|)
condition|;
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
control|)
block|{ }
if|if
condition|(
literal|0
operator|<=
name|i
condition|)
block|{
name|t
operator|=
name|i
expr_stmt|;
for|for
control|(
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
init|;
operator|(
literal|0
operator|<=
name|i
operator|)
operator|&&
operator|(
operator|(
name|c0
operator|=
name|T
index|[
name|i
index|]
operator|)
operator|<=
name|c1
operator|)
condition|;
operator|--
name|i
operator|,
name|c1
operator|=
name|c0
control|)
block|{ }
name|SA
index|[
name|ISAb
index|[
operator|--
name|j
index|]
index|]
operator|=
operator|(
operator|(
name|t
operator|==
literal|0
operator|)
operator|||
operator|(
literal|1
operator|<
operator|(
name|t
operator|-
name|i
operator|)
operator|)
operator|)
condition|?
name|t
else|:
operator|~
name|t
expr_stmt|;
block|}
block|}
comment|/* Calculate the index of start/end point of each bucket. */
name|BUCKET_B
argument_list|(
name|ALPHABET_SIZE
operator|-
literal|1
argument_list|,
name|ALPHABET_SIZE
operator|-
literal|1
argument_list|)
operator|=
name|n
expr_stmt|;
comment|/* end point */
for|for
control|(
name|c0
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
operator|,
name|k
operator|=
name|m
operator|-
literal|1
init|;
literal|0
operator|<=
name|c0
condition|;
operator|--
name|c0
control|)
block|{
name|i
operator|=
name|BUCKET_A
argument_list|(
name|c0
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
init|;
name|c0
operator|<
name|c1
condition|;
operator|--
name|c1
control|)
block|{
name|t
operator|=
name|i
operator|-
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* end point */
comment|/* Move all type B* suffixes to the correct position. */
for|for
control|(
name|i
operator|=
name|t
operator|,
name|j
operator|=
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c1
argument_list|)
init|;
name|j
operator|<=
name|k
condition|;
operator|--
name|i
operator|,
operator|--
name|k
control|)
block|{
name|SA
index|[
name|i
index|]
operator|=
name|SA
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
name|BUCKET_BSTAR
argument_list|(
name|c0
argument_list|,
name|c0
operator|+
literal|1
argument_list|)
operator|=
name|i
operator|-
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* start point */
name|BUCKET_B
argument_list|(
name|c0
argument_list|,
name|c0
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* end point */
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Constructs the suffix array by using the sorted order of type B* suffixes. */
end_comment

begin_function
specifier|static
name|void
name|construct_SA
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|bucket_A
parameter_list|,
name|int
modifier|*
name|bucket_B
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|int
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Construct the sorted order of type B suffixes by using        the sorted order of type B* suffixes. */
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
init|;
literal|0
operator|<=
name|c1
condition|;
operator|--
name|c1
control|)
block|{
comment|/* Scan the suffix array from right to left. */
for|for
control|(
name|i
operator|=
name|SA
operator|+
name|BUCKET_BSTAR
argument_list|(
name|c1
argument_list|,
name|c1
operator|+
literal|1
argument_list|)
operator|,
name|j
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
operator|-
literal|1
operator|,
name|k
operator|=
name|NULL
operator|,
name|c2
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|j
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|j
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|<
name|n
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|<=
name|T
index|[
name|s
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|c2
condition|)
block|{
name|BUCKET_B
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
block|}
name|k
operator|=
name|SA
operator|+
name|BUCKET_B
argument_list|(
name|c2
operator|=
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|k
operator|<
name|j
argument_list|)
expr_stmt|;
operator|*
name|k
operator|--
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|==
literal|0
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|==
name|c1
operator|)
operator|)
operator|||
operator|(
name|s
operator|<
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Construct the suffix array by using      the sorted order of type B suffixes. */
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
operator|(
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|<
name|c2
operator|)
condition|?
operator|~
operator|(
name|n
operator|-
literal|1
operator|)
else|:
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Scan the suffix array from left to right. */
for|for
control|(
name|i
operator|=
name|SA
operator|,
name|j
operator|=
name|SA
operator|+
name|n
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|i
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|==
literal|0
operator|)
operator|||
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
name|BUCKET_A
argument_list|(
name|c2
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|<
name|k
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|s
operator|<
literal|0
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
operator|~
name|s
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Constructs the burrows-wheeler transformed string directly    by using the sorted order of type B* suffixes. */
end_comment

begin_function
specifier|static
name|int
name|construct_BWT
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|bucket_A
parameter_list|,
name|int
modifier|*
name|bucket_B
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|int
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|orig
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Construct the sorted order of type B suffixes by using        the sorted order of type B* suffixes. */
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
init|;
literal|0
operator|<=
name|c1
condition|;
operator|--
name|c1
control|)
block|{
comment|/* Scan the suffix array from right to left. */
for|for
control|(
name|i
operator|=
name|SA
operator|+
name|BUCKET_BSTAR
argument_list|(
name|c1
argument_list|,
name|c1
operator|+
literal|1
argument_list|)
operator|,
name|j
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
operator|-
literal|1
operator|,
name|k
operator|=
name|NULL
operator|,
name|c2
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|j
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|j
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|<
name|n
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|<=
name|T
index|[
name|s
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
operator|*
name|j
operator|=
operator|~
operator|(
operator|(
name|int
operator|)
name|c0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|c2
condition|)
block|{
name|BUCKET_B
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
block|}
name|k
operator|=
name|SA
operator|+
name|BUCKET_B
argument_list|(
name|c2
operator|=
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|k
operator|<
name|j
argument_list|)
expr_stmt|;
operator|*
name|k
operator|--
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
block|}
else|else
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|/* Construct the BWTed string by using      the sorted order of type B suffixes. */
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
operator|(
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|<
name|c2
operator|)
condition|?
operator|~
operator|(
operator|(
name|int
operator|)
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|)
else|:
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Scan the suffix array from left to right. */
for|for
control|(
name|i
operator|=
name|SA
operator|,
name|j
operator|=
name|SA
operator|+
name|n
operator|,
name|orig
operator|=
name|SA
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|i
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
operator|*
name|i
operator|=
name|c0
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
operator|(
operator|(
name|int
operator|)
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
name|BUCKET_A
argument_list|(
name|c2
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|<
name|k
argument_list|)
expr_stmt|;
operator|*
name|k
operator|++
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
operator|*
name|i
operator|=
operator|~
name|s
expr_stmt|;
block|}
else|else
block|{
name|orig
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|orig
operator|-
name|SA
return|;
block|}
end_function

begin_comment
comment|/* Constructs the burrows-wheeler transformed string directly    by using the sorted order of type B* suffixes. */
end_comment

begin_function
specifier|static
name|int
name|construct_BWT_indexes
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
modifier|*
name|bucket_A
parameter_list|,
name|int
modifier|*
name|bucket_B
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|m
parameter_list|,
name|unsigned
name|char
modifier|*
name|num_indexes
parameter_list|,
name|int
modifier|*
name|indexes
parameter_list|)
block|{
name|int
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|orig
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|mod
init|=
name|n
operator|/
literal|8
decl_stmt|;
block|{
name|mod
operator||=
name|mod
operator|>>
literal|1
expr_stmt|;
name|mod
operator||=
name|mod
operator|>>
literal|2
expr_stmt|;
name|mod
operator||=
name|mod
operator|>>
literal|4
expr_stmt|;
name|mod
operator||=
name|mod
operator|>>
literal|8
expr_stmt|;
name|mod
operator||=
name|mod
operator|>>
literal|16
expr_stmt|;
name|mod
operator|>>=
literal|1
expr_stmt|;
operator|*
name|num_indexes
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|/
operator|(
name|mod
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<
name|m
condition|)
block|{
comment|/* Construct the sorted order of type B suffixes by using        the sorted order of type B* suffixes. */
for|for
control|(
name|c1
operator|=
name|ALPHABET_SIZE
operator|-
literal|2
init|;
literal|0
operator|<=
name|c1
condition|;
operator|--
name|c1
control|)
block|{
comment|/* Scan the suffix array from right to left. */
for|for
control|(
name|i
operator|=
name|SA
operator|+
name|BUCKET_BSTAR
argument_list|(
name|c1
argument_list|,
name|c1
operator|+
literal|1
argument_list|)
operator|,
name|j
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c1
operator|+
literal|1
argument_list|)
operator|-
literal|1
operator|,
name|k
operator|=
name|NULL
operator|,
name|c2
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
name|j
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|j
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|<
name|n
operator|)
operator|&&
operator|(
name|T
index|[
name|s
index|]
operator|<=
name|T
index|[
name|s
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|mod
operator|)
operator|==
literal|0
condition|)
name|indexes
index|[
name|s
operator|/
operator|(
name|mod
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
name|j
operator|-
name|SA
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
operator|*
name|j
operator|=
operator|~
operator|(
operator|(
name|int
operator|)
name|c0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>
name|c0
operator|)
condition|)
block|{
name|s
operator|=
operator|~
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|c2
condition|)
block|{
name|BUCKET_B
argument_list|(
name|c2
argument_list|,
name|c1
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
block|}
name|k
operator|=
name|SA
operator|+
name|BUCKET_B
argument_list|(
name|c2
operator|=
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|k
operator|<
name|j
argument_list|)
expr_stmt|;
operator|*
name|k
operator|--
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
operator|*
name|j
operator|=
operator|~
name|s
expr_stmt|;
ifndef|#
directive|ifndef
name|NDEBUG
block|}
else|else
block|{
name|assert
argument_list|(
name|T
index|[
name|s
index|]
operator|==
name|c1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|/* Construct the BWTed string by using      the sorted order of type B suffixes. */
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|<
name|c2
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|mod
operator|)
operator|==
literal|0
condition|)
name|indexes
index|[
operator|(
name|n
operator|-
literal|1
operator|)
operator|/
operator|(
name|mod
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
name|k
operator|-
name|SA
expr_stmt|;
operator|*
name|k
operator|++
operator|=
operator|~
operator|(
operator|(
name|int
operator|)
name|T
index|[
name|n
operator|-
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|k
operator|++
operator|=
name|n
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Scan the suffix array from left to right. */
for|for
control|(
name|i
operator|=
name|SA
operator|,
name|j
operator|=
name|SA
operator|+
name|n
operator|,
name|orig
operator|=
name|SA
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
literal|0
operator|<
operator|(
name|s
operator|=
operator|*
name|i
operator|)
condition|)
block|{
name|assert
argument_list|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|>=
name|T
index|[
name|s
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|mod
operator|)
operator|==
literal|0
condition|)
name|indexes
index|[
name|s
operator|/
operator|(
name|mod
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
name|i
operator|-
name|SA
expr_stmt|;
name|c0
operator|=
name|T
index|[
operator|--
name|s
index|]
expr_stmt|;
operator|*
name|i
operator|=
name|c0
expr_stmt|;
if|if
condition|(
name|c0
operator|!=
name|c2
condition|)
block|{
name|BUCKET_A
argument_list|(
name|c2
argument_list|)
operator|=
name|k
operator|-
name|SA
expr_stmt|;
name|k
operator|=
name|SA
operator|+
name|BUCKET_A
argument_list|(
name|c2
operator|=
name|c0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|<
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<
name|s
operator|)
operator|&&
operator|(
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|<
name|c0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|&
name|mod
operator|)
operator|==
literal|0
condition|)
name|indexes
index|[
name|s
operator|/
operator|(
name|mod
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
operator|=
name|k
operator|-
name|SA
expr_stmt|;
operator|*
name|k
operator|++
operator|=
operator|~
operator|(
operator|(
name|int
operator|)
name|T
index|[
name|s
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
else|else
operator|*
name|k
operator|++
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
operator|*
name|i
operator|=
operator|~
name|s
expr_stmt|;
block|}
else|else
block|{
name|orig
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|orig
operator|-
name|SA
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*- Function -*/
end_comment

begin_function
name|int
name|divsufsort
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
name|int
modifier|*
name|SA
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|openMP
parameter_list|)
block|{
name|int
modifier|*
name|bucket_A
decl_stmt|,
modifier|*
name|bucket_B
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check arguments. */
if|if
condition|(
operator|(
name|T
operator|==
name|NULL
operator|)
operator|||
operator|(
name|SA
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|SA
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|2
condition|)
block|{
name|m
operator|=
operator|(
name|T
index|[
literal|0
index|]
operator|<
name|T
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|SA
index|[
name|m
operator|^
literal|1
index|]
operator|=
literal|0
operator|,
name|SA
index|[
name|m
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bucket_A
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_A_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bucket_B
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_B_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Suffixsort. */
if|if
condition|(
operator|(
name|bucket_A
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bucket_B
operator|!=
name|NULL
operator|)
condition|)
block|{
name|m
operator|=
name|sort_typeBstar
argument_list|(
name|T
argument_list|,
name|SA
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|openMP
argument_list|)
expr_stmt|;
name|construct_SA
argument_list|(
name|T
argument_list|,
name|SA
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|free
argument_list|(
name|bucket_B
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bucket_A
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|divbwt
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|T
parameter_list|,
name|unsigned
name|char
modifier|*
name|U
parameter_list|,
name|int
modifier|*
name|A
parameter_list|,
name|int
name|n
parameter_list|,
name|unsigned
name|char
modifier|*
name|num_indexes
parameter_list|,
name|int
modifier|*
name|indexes
parameter_list|,
name|int
name|openMP
parameter_list|)
block|{
name|int
modifier|*
name|B
decl_stmt|;
name|int
modifier|*
name|bucket_A
decl_stmt|,
modifier|*
name|bucket_B
decl_stmt|;
name|int
name|m
decl_stmt|,
name|pidx
decl_stmt|,
name|i
decl_stmt|;
comment|/* Check arguments. */
if|if
condition|(
operator|(
name|T
operator|==
name|NULL
operator|)
operator|||
operator|(
name|U
operator|==
name|NULL
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|U
index|[
literal|0
index|]
operator|=
name|T
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
if|if
condition|(
operator|(
name|B
operator|=
name|A
operator|)
operator|==
name|NULL
condition|)
block|{
name|B
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bucket_A
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_A_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bucket_B
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|BUCKET_B_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Burrows-Wheeler Transform. */
if|if
condition|(
operator|(
name|B
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bucket_A
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bucket_B
operator|!=
name|NULL
operator|)
condition|)
block|{
name|m
operator|=
name|sort_typeBstar
argument_list|(
name|T
argument_list|,
name|B
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|openMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_indexes
operator|==
name|NULL
operator|||
name|indexes
operator|==
name|NULL
condition|)
block|{
name|pidx
operator|=
name|construct_BWT
argument_list|(
name|T
argument_list|,
name|B
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pidx
operator|=
name|construct_BWT_indexes
argument_list|(
name|T
argument_list|,
name|B
argument_list|,
name|bucket_A
argument_list|,
name|bucket_B
argument_list|,
name|n
argument_list|,
name|m
argument_list|,
name|num_indexes
argument_list|,
name|indexes
argument_list|)
expr_stmt|;
block|}
comment|/* Copy to output string. */
name|U
index|[
literal|0
index|]
operator|=
name|T
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pidx
condition|;
operator|++
name|i
control|)
block|{
name|U
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|B
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|+=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|U
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|B
index|[
name|i
index|]
expr_stmt|;
block|}
name|pidx
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pidx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|free
argument_list|(
name|bucket_B
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bucket_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|A
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|B
argument_list|)
expr_stmt|;
block|}
return|return
name|pidx
return|;
block|}
end_function

end_unit

