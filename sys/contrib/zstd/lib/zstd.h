begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  * You may select, at your option, one of the above-listed licenses.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_H_235446
define|#
directive|define
name|ZSTD_H_235446
comment|/* ======   Dependency   ======*/
include|#
directive|include
file|<stddef.h>
comment|/* size_t */
comment|/* =====   ZSTDLIB_API : control library symbols visibility   ===== */
ifndef|#
directive|ifndef
name|ZSTDLIB_VISIBILITY
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|4
operator|)
define|#
directive|define
name|ZSTDLIB_VISIBILITY
value|__attribute__ ((visibility ("default")))
else|#
directive|else
define|#
directive|define
name|ZSTDLIB_VISIBILITY
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_DLL_EXPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_DLL_EXPORT
operator|==
literal|1
operator|)
define|#
directive|define
name|ZSTDLIB_API
value|__declspec(dllexport) ZSTDLIB_VISIBILITY
elif|#
directive|elif
name|defined
argument_list|(
name|ZSTD_DLL_IMPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_DLL_IMPORT
operator|==
literal|1
operator|)
define|#
directive|define
name|ZSTDLIB_API
value|__declspec(dllimport) ZSTDLIB_VISIBILITY
comment|/* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
else|#
directive|else
define|#
directive|define
name|ZSTDLIB_API
value|ZSTDLIB_VISIBILITY
endif|#
directive|endif
comment|/*******************************************************************************************************   Introduction    zstd, short for Zstandard, is a fast lossless compression algorithm,   targeting real-time compression scenarios at zlib-level and better compression ratios.   The zstd compression library provides in-memory compression and decompression functions.   The library supports compression levels from 1 up to ZSTD_maxCLevel() which is currently 22.   Levels>= 20, labeled `--ultra`, should be used with caution, as they require more memory.   Compression can be done in:     - a single step (described as Simple API)     - a single step, reusing a context (described as Explicit memory management)     - unbounded multiple steps (described as Streaming compression)   The compression ratio achievable on small data can be highly improved using a dictionary in:     - a single step (described as Simple dictionary API)     - a single step, reusing a dictionary (described as Fast dictionary API)    Advanced experimental functions can be accessed using #define ZSTD_STATIC_LINKING_ONLY before including zstd.h.   Advanced experimental APIs shall never be used with a dynamic library.   They are not "stable", their definition may change in the future. Only static linking is allowed. *********************************************************************************************************/
comment|/*------   Version   ------*/
define|#
directive|define
name|ZSTD_VERSION_MAJOR
value|1
define|#
directive|define
name|ZSTD_VERSION_MINOR
value|3
define|#
directive|define
name|ZSTD_VERSION_RELEASE
value|2
define|#
directive|define
name|ZSTD_VERSION_NUMBER
value|(ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)
name|ZSTDLIB_API
name|unsigned
name|ZSTD_versionNumber
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< useful to check dll version */
define|#
directive|define
name|ZSTD_LIB_VERSION
value|ZSTD_VERSION_MAJOR.ZSTD_VERSION_MINOR.ZSTD_VERSION_RELEASE
define|#
directive|define
name|ZSTD_QUOTE
parameter_list|(
name|str
parameter_list|)
value|#str
define|#
directive|define
name|ZSTD_EXPAND_AND_QUOTE
parameter_list|(
name|str
parameter_list|)
value|ZSTD_QUOTE(str)
define|#
directive|define
name|ZSTD_VERSION_STRING
value|ZSTD_EXPAND_AND_QUOTE(ZSTD_LIB_VERSION)
name|ZSTDLIB_API
specifier|const
name|char
modifier|*
name|ZSTD_versionString
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* v1.3.0 */
comment|/*************************************** *  Simple API ***************************************/
comment|/*! ZSTD_compress() :  *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.  *  Hint : compression runs faster if `dstCapacity`>=  `ZSTD_compressBound(srcSize)`.  *  @return : compressed size written into `dst` (<= `dstCapacity),  *            or an error code if it fails (which can be tested using ZSTD_isError()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress() :  *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.  *  `dstCapacity` is an upper bound of originalSize to regenerate.  *  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.  *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),  *            or an errorCode if it fails (which can be tested using ZSTD_isError()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|compressedSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getFrameContentSize() : v1.3.0  *  `src` should point to the start of a ZSTD encoded frame.  *  `srcSize` must be at least as large as the frame header.  *            hint : any size>= `ZSTD_frameHeaderSize_max` is large enough.  *  @return : - decompressed size of the frame in `src`, if known  *            - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined  *            - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small)  *   note 1 : a 0 return value means the frame is valid but "empty".  *   note 2 : decompressed size is an optional field, it may not be present, typically in streaming mode.  *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.  *            In which case, it's necessary to use streaming mode to decompress data.  *            Optionally, application can rely on some implicit limit,  *            as ZSTD_decompress() only needs an upper bound of decompressed size.  *            (For example, data could be necessarily cut into blocks<= 16 KB).  *   note 3 : decompressed size is always present when compression is done with ZSTD_compress()  *   note 4 : decompressed size can be very large (64-bits value),  *            potentially larger than what local system can handle as a single memory segment.  *            In which case, it's necessary to use streaming mode to decompress data.  *   note 5 : If source is untrusted, decompressed size could be wrong or intentionally modified.  *            Always ensure return value fits within application's authorized limits.  *            Each application can set its own limits.  *   note 6 : This function replaces ZSTD_getDecompressedSize() */
define|#
directive|define
name|ZSTD_CONTENTSIZE_UNKNOWN
value|(0ULL - 1)
define|#
directive|define
name|ZSTD_CONTENTSIZE_ERROR
value|(0ULL - 2)
name|ZSTDLIB_API
name|unsigned
name|long
name|long
name|ZSTD_getFrameContentSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDecompressedSize() :  *  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().  *  Both functions work the same way,  *  but ZSTD_getDecompressedSize() blends  *  "empty", "unknown" and "error" results in the same return value (0),  *  while ZSTD_getFrameContentSize() distinguishes them.  *  *  'src' is the start of a zstd compressed frame.  *  @return : content size to be decompressed, as a 64-bits value _if known and not empty_, 0 otherwise. */
name|ZSTDLIB_API
name|unsigned
name|long
name|long
name|ZSTD_getDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*======  Helper functions  ======*/
define|#
directive|define
name|ZSTD_COMPRESSBOUND
parameter_list|(
name|srcSize
parameter_list|)
value|((srcSize) + ((srcSize)>>8) + (((srcSize)< 128 KB) ? ((128 KB - (srcSize))>> 11)
comment|/* margin, from 64 to 0 */
value|: 0))
comment|/* this formula ensures that bound(A) + bound(B)<= bound(A+B) as long as A and B>= 128 KB */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBound
parameter_list|(
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*!< maximum compressed size in worst case scenario */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/*!< tells if a `size_t` function result is an error code */
name|ZSTDLIB_API
specifier|const
name|char
modifier|*
name|ZSTD_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/*!< provides readable string from an error code */
name|ZSTDLIB_API
name|int
name|ZSTD_maxCLevel
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*!< maximum compression level available */
comment|/*************************************** *  Explicit memory management ***************************************/
comment|/*= Compression context  *  When compressing many times,  *  it is recommended to allocate a context just once, and re-use it for each successive compression operation.  *  This will make workload friendlier for system's memory.  *  Use one context per thread for parallel execution in multi-threaded environments. */
typedef|typedef
name|struct
name|ZSTD_CCtx_s
name|ZSTD_CCtx
typedef|;
name|ZSTDLIB_API
name|ZSTD_CCtx
modifier|*
name|ZSTD_createCCtx
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCCtx
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
comment|/*! ZSTD_compressCCtx() :  *  Same as ZSTD_compress(), requires an allocated ZSTD_CCtx (see ZSTD_createCCtx()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressCCtx
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*= Decompression context  *  When decompressing many times,  *  it is recommended to allocate a context only once,  *  and re-use it for each successive compression operation.  *  This will make workload friendlier for system's memory.  *  Use one context per thread for parallel execution. */
typedef|typedef
name|struct
name|ZSTD_DCtx_s
name|ZSTD_DCtx
typedef|;
name|ZSTDLIB_API
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompressDCtx() :  *  Same as ZSTD_decompress(), requires an allocated ZSTD_DCtx (see ZSTD_createDCtx()) */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/************************** *  Simple dictionary API ***************************/
comment|/*! ZSTD_compress_usingDict() :  *  Compression using a predefined Dictionary (see dictBuilder/zdict.h).  *  Note : This function loads the dictionary, resulting in significant startup delay.  *  Note : When `dict == NULL || dictSize< 8` no dictionary is used. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_usingDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress_usingDict() :  *  Decompression using a predefined Dictionary (see dictBuilder/zdict.h).  *  Dictionary must be identical to the one used during compression.  *  Note : This function loads the dictionary, resulting in significant startup delay.  *  Note : When `dict == NULL || dictSize< 8` no dictionary is used. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/**********************************  *  Bulk processing dictionary API  *********************************/
typedef|typedef
name|struct
name|ZSTD_CDict_s
name|ZSTD_CDict
typedef|;
comment|/*! ZSTD_createCDict() :  *  When compressing multiple messages / blocks with the same dictionary, it's recommended to load it just once.  *  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.  *  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.  *  `dictBuffer` can be released after ZSTD_CDict creation, since its content is copied within CDict */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_createCDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_freeCDict() :  *  Function frees memory allocated by ZSTD_createCDict(). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCDict
parameter_list|(
name|ZSTD_CDict
modifier|*
name|CDict
parameter_list|)
function_decl|;
comment|/*! ZSTD_compress_usingCDict() :  *  Compression using a digested Dictionary.  *  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times.  *  Note that compression level is decided during dictionary creation.  *  Frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_usingCDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
typedef|typedef
name|struct
name|ZSTD_DDict_s
name|ZSTD_DDict
typedef|;
comment|/*! ZSTD_createDDict() :  *  Create a digested dictionary, ready to start decompression operation without startup delay.  *  dictBuffer can be released after DDict creation, as its content is copied inside DDict */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_freeDDict() :  *  Function frees memory allocated with ZSTD_createDDict() */
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeDDict
parameter_list|(
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress_usingDDict() :  *  Decompression using a digested Dictionary.  *  Faster startup than ZSTD_decompress_usingDict(), recommended when same dictionary is used multiple times. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress_usingDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/**************************** *  Streaming ****************************/
typedef|typedef
struct|struct
name|ZSTD_inBuffer_s
block|{
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
comment|/**< start of input buffer */
name|size_t
name|size
decl_stmt|;
comment|/**< size of input buffer */
name|size_t
name|pos
decl_stmt|;
comment|/**< position where reading stopped. Will be updated. Necessarily 0<= pos<= size */
block|}
name|ZSTD_inBuffer
typedef|;
typedef|typedef
struct|struct
name|ZSTD_outBuffer_s
block|{
name|void
modifier|*
name|dst
decl_stmt|;
comment|/**< start of output buffer */
name|size_t
name|size
decl_stmt|;
comment|/**< size of output buffer */
name|size_t
name|pos
decl_stmt|;
comment|/**< position where writing stopped. Will be updated. Necessarily 0<= pos<= size */
block|}
name|ZSTD_outBuffer
typedef|;
comment|/*-*********************************************************************** *  Streaming compression - HowTo * *  A ZSTD_CStream object is required to track streaming operation. *  Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources. *  ZSTD_CStream objects can be reused multiple times on consecutive compression operations. *  It is recommended to re-use ZSTD_CStream in situations where many streaming operations will be achieved consecutively, *  since it will play nicer with system's memory, by re-using already allocated memory. *  Use one separate ZSTD_CStream per thread for parallel execution. * *  Start a new compression by initializing ZSTD_CStream. *  Use ZSTD_initCStream() to start a new compression operation. *  Use ZSTD_initCStream_usingDict() or ZSTD_initCStream_usingCDict() for a compression which requires a dictionary (experimental section) * *  Use ZSTD_compressStream() repetitively to consume input stream. *  The function will automatically update both `pos` fields. *  Note that it may not consume the entire input, in which case `pos< size`, *  and it's up to the caller to present again remaining data. *  @return : a size hint, preferred nb of bytes to use as input for next function call *            or an error code, which can be tested using ZSTD_isError(). *            Note 1 : it's just a hint, to help latency a little, any other value will work fine. *            Note 2 : size hint is guaranteed to be<= ZSTD_CStreamInSize() * *  At any moment, it's possible to flush whatever data remains within internal buffer, using ZSTD_flushStream(). *  `output->pos` will be updated. *  Note that some content might still be left within internal buffer if `output->size` is too small. *  @return : nb of bytes still present within internal buffer (0 if it's empty) *            or an error code, which can be tested using ZSTD_isError(). * *  ZSTD_endStream() instructs to finish a frame. *  It will perform a flush and write frame epilogue. *  The epilogue is required for decoders to consider a frame completed. *  ZSTD_endStream() may not be able to flush full data if `output->size` is too small. *  In which case, call again ZSTD_endStream() to complete the flush. *  @return : 0 if frame fully completed and fully flushed,              or>0 if some data is still present within internal buffer                   (value is minimum size estimation for remaining data to flush, but it could be more) *            or an error code, which can be tested using ZSTD_isError(). * * *******************************************************************/
typedef|typedef
name|ZSTD_CCtx
name|ZSTD_CStream
typedef|;
comment|/**< CCtx and CStream are now effectively same object (>= v1.3.0) */
comment|/* Continue to distinguish them for compatibility with versions<= v1.2.0 */
comment|/*===== ZSTD_CStream management functions =====*/
name|ZSTDLIB_API
name|ZSTD_CStream
modifier|*
name|ZSTD_createCStream
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|)
function_decl|;
comment|/*===== Streaming compression functions =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_flushStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_endStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_CStreamInSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< recommended size for input buffer */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CStreamOutSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block in all circumstances. */
comment|/*-*************************************************************************** *  Streaming decompression - HowTo * *  A ZSTD_DStream object is required to track streaming operations. *  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources. *  ZSTD_DStream objects can be re-used multiple times. * *  Use ZSTD_initDStream() to start a new decompression operation, *   or ZSTD_initDStream_usingDict() if decompression requires a dictionary. *   @return : recommended first input size * *  Use ZSTD_decompressStream() repetitively to consume your input. *  The function will update both `pos` fields. *  If `input.pos< input.size`, some input has not been consumed. *  It's up to the caller to present again remaining data. *  If `output.pos< output.size`, decoder has flushed everything it could. *  @return : 0 when a frame is completely decoded and fully flushed, *            an error code, which can be tested using ZSTD_isError(), *            any other value> 0, which means there is still some decoding to do to complete current frame. *            The return value is a suggested next input size (a hint to improve latency) that will never load more than the current frame. * *******************************************************************************/
typedef|typedef
name|ZSTD_DCtx
name|ZSTD_DStream
typedef|;
comment|/**< DCtx and DStream are now effectively same object (>= v1.3.0) */
comment|/* Continue to distinguish them for compatibility with versions<= v1.2.0 */
comment|/*===== ZSTD_DStream management functions =====*/
name|ZSTDLIB_API
name|ZSTD_DStream
modifier|*
name|ZSTD_createDStream
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
comment|/*===== Streaming decompression functions =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_initDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_DStreamInSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*!< recommended size for input buffer */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DStreamOutSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */
endif|#
directive|endif
comment|/* ZSTD_H_235446 */
comment|/****************************************************************************************  * START OF ADVANCED AND EXPERIMENTAL FUNCTIONS  * The definitions in this section are considered experimental.  * They should never be used with a dynamic library, as prototypes may change in the future.  * They are provided for advanced scenarios.  * Use them only in association with static linking.  * ***************************************************************************************/
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_STATIC_LINKING_ONLY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ZSTD_H_ZSTD_STATIC_LINKING_ONLY
argument_list|)
define|#
directive|define
name|ZSTD_H_ZSTD_STATIC_LINKING_ONLY
comment|/* --- Constants ---*/
define|#
directive|define
name|ZSTD_MAGICNUMBER
value|0xFD2FB528
comment|/*>= v0.8.0 */
define|#
directive|define
name|ZSTD_MAGIC_SKIPPABLE_START
value|0x184D2A50U
define|#
directive|define
name|ZSTD_MAGIC_DICTIONARY
value|0xEC30A437
comment|/* v0.7+ */
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX_32
value|30
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX_64
value|31
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX
value|((unsigned)(sizeof(size_t) == 4 ? ZSTD_WINDOWLOG_MAX_32 : ZSTD_WINDOWLOG_MAX_64))
define|#
directive|define
name|ZSTD_WINDOWLOG_MIN
value|10
define|#
directive|define
name|ZSTD_HASHLOG_MAX
value|MIN(ZSTD_WINDOWLOG_MAX, 30)
define|#
directive|define
name|ZSTD_HASHLOG_MIN
value|6
define|#
directive|define
name|ZSTD_CHAINLOG_MAX
value|MIN(ZSTD_WINDOWLOG_MAX+1, 30)
define|#
directive|define
name|ZSTD_CHAINLOG_MIN
value|ZSTD_HASHLOG_MIN
define|#
directive|define
name|ZSTD_HASHLOG3_MAX
value|17
define|#
directive|define
name|ZSTD_SEARCHLOG_MAX
value|(ZSTD_WINDOWLOG_MAX-1)
define|#
directive|define
name|ZSTD_SEARCHLOG_MIN
value|1
define|#
directive|define
name|ZSTD_SEARCHLENGTH_MAX
value|7
comment|/* only for ZSTD_fast, other strategies are limited to 6 */
define|#
directive|define
name|ZSTD_SEARCHLENGTH_MIN
value|3
comment|/* only for ZSTD_btopt, other strategies are limited to 4 */
define|#
directive|define
name|ZSTD_TARGETLENGTH_MIN
value|4
comment|/* only useful for btopt */
define|#
directive|define
name|ZSTD_TARGETLENGTH_MAX
value|999
comment|/* only useful for btopt */
define|#
directive|define
name|ZSTD_LDM_MINMATCH_MIN
value|4
define|#
directive|define
name|ZSTD_LDM_MINMATCH_MAX
value|4096
define|#
directive|define
name|ZSTD_LDM_BUCKETSIZELOG_MAX
value|8
define|#
directive|define
name|ZSTD_FRAMEHEADERSIZE_PREFIX
value|5
comment|/* minimum input size to know frame header size */
define|#
directive|define
name|ZSTD_FRAMEHEADERSIZE_MIN
value|6
define|#
directive|define
name|ZSTD_FRAMEHEADERSIZE_MAX
value|18
comment|/* for static allocation */
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_prefix
init|=
name|ZSTD_FRAMEHEADERSIZE_PREFIX
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_min
init|=
name|ZSTD_FRAMEHEADERSIZE_MIN
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_max
init|=
name|ZSTD_FRAMEHEADERSIZE_MAX
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_skippableHeaderSize
init|=
literal|8
decl_stmt|;
comment|/* magic number + skippable frame length */
comment|/*--- Advanced types ---*/
typedef|typedef
enum|enum
block|{
name|ZSTD_fast
init|=
literal|1
block|,
name|ZSTD_dfast
block|,
name|ZSTD_greedy
block|,
name|ZSTD_lazy
block|,
name|ZSTD_lazy2
block|,
name|ZSTD_btlazy2
block|,
name|ZSTD_btopt
block|,
name|ZSTD_btultra
block|}
name|ZSTD_strategy
typedef|;
comment|/* from faster to stronger */
typedef|typedef
struct|struct
block|{
name|unsigned
name|windowLog
decl_stmt|;
comment|/**< largest match distance : larger == more compression, more memory needed during decompression */
name|unsigned
name|chainLog
decl_stmt|;
comment|/**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */
name|unsigned
name|hashLog
decl_stmt|;
comment|/**< dispatch table : larger == faster, more memory */
name|unsigned
name|searchLog
decl_stmt|;
comment|/**< nb of searches : larger == more compression, slower */
name|unsigned
name|searchLength
decl_stmt|;
comment|/**< match length searched : larger == faster decompression, sometimes less compression */
name|unsigned
name|targetLength
decl_stmt|;
comment|/**< acceptable match size for optimal parser (only) : larger == more compression, slower */
name|ZSTD_strategy
name|strategy
decl_stmt|;
block|}
name|ZSTD_compressionParameters
typedef|;
typedef|typedef
struct|struct
block|{
name|unsigned
name|contentSizeFlag
decl_stmt|;
comment|/**< 1: content size will be in frame header (when known) */
name|unsigned
name|checksumFlag
decl_stmt|;
comment|/**< 1: generate a 32-bits checksum at end of frame, for error detection */
name|unsigned
name|noDictIDFlag
decl_stmt|;
comment|/**< 1: no dictID will be saved into frame header (if dictionary compression) */
block|}
name|ZSTD_frameParameters
typedef|;
typedef|typedef
struct|struct
block|{
name|ZSTD_compressionParameters
name|cParams
decl_stmt|;
name|ZSTD_frameParameters
name|fParams
decl_stmt|;
block|}
name|ZSTD_parameters
typedef|;
typedef|typedef
name|struct
name|ZSTD_CCtx_params_s
name|ZSTD_CCtx_params
typedef|;
comment|/*= Custom memory allocation functions */
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|ZSTD_allocFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|ZSTD_freeFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
block|{
name|ZSTD_allocFunction
name|customAlloc
decl_stmt|;
name|ZSTD_freeFunction
name|customFree
decl_stmt|;
name|void
modifier|*
name|opaque
decl_stmt|;
block|}
name|ZSTD_customMem
typedef|;
comment|/* use this constant to defer to stdlib's functions */
specifier|static
specifier|const
name|ZSTD_customMem
name|ZSTD_defaultCMem
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/*************************************** *  Frame size functions ***************************************/
comment|/*! ZSTD_findFrameCompressedSize() :  *  `src` should point to the start of a ZSTD encoded frame or skippable frame  *  `srcSize` must be at least as large as the frame  *  @return : the compressed size of the first frame starting at `src`,  *            suitable to pass to `ZSTD_decompress` or similar,  *            or an error code if input is invalid */
name|ZSTDLIB_API
name|size_t
name|ZSTD_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_findDecompressedSize() :  *  `src` should point the start of a series of ZSTD encoded and/or skippable frames  *  `srcSize` must be the _exact_ size of this series  *       (i.e. there should be a frame boundary exactly at `srcSize` bytes after `src`)  *  @return : - decompressed size of all data in all successive frames  *            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN  *            - if an error occurred: ZSTD_CONTENTSIZE_ERROR  *  *   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.  *            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.  *            In which case, it's necessary to use streaming mode to decompress data.  *   note 2 : decompressed size is always present when compression is done with ZSTD_compress()  *   note 3 : decompressed size can be very large (64-bits value),  *            potentially larger than what local system can handle as a single memory segment.  *            In which case, it's necessary to use streaming mode to decompress data.  *   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.  *            Always ensure result fits within application's authorized limits.  *            Each application can set its own limits.  *   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to  *            read each contained frame header.  This is fast as most of the data is skipped,  *            however it does mean that all frame data must be present and valid. */
name|ZSTDLIB_API
name|unsigned
name|long
name|long
name|ZSTD_findDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_frameHeaderSize() : *   `src` should point to the start of a ZSTD frame *   `srcSize` must be>= ZSTD_frameHeaderSize_prefix. *   @return : size of the Frame Header */
name|ZSTDLIB_API
name|size_t
name|ZSTD_frameHeaderSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*************************************** *  Context memory usage ***************************************/
comment|/*! ZSTD_sizeof_*() :  *  These functions give the current memory usage of selected object.  *  Object memory usage can evolve when re-used multiple times. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_CCtx
parameter_list|(
specifier|const
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_DCtx
parameter_list|(
specifier|const
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_CStream
parameter_list|(
specifier|const
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_DStream
parameter_list|(
specifier|const
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_CDict
parameter_list|(
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_DDict
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/*! ZSTD_estimate*() :  *  These functions make it possible to estimate memory usage  *  of a future {D,C}Ctx, before its creation.  *  ZSTD_estimateCCtxSize() will provide a budget large enough for any compression level up to selected one.  *  It will also consider src size to be arbitrarily "large", which is worst case.  *  If srcSize is known to always be small, ZSTD_estimateCCtxSize_usingCParams() can provide a tighter estimation.  *  ZSTD_estimateCCtxSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.  *  ZSTD_estimateCCtxSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParam_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_p_nbThreads is> 1.  *  Note : CCtx estimation is only correct for single-threaded compression */
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCCtxSize
parameter_list|(
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCCtxSize_usingCParams
parameter_list|(
name|ZSTD_compressionParameters
name|cParams
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCCtxSize_usingCCtxParams
parameter_list|(
specifier|const
name|ZSTD_CCtx_params
modifier|*
name|params
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateDCtxSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*! ZSTD_estimateCStreamSize() :  *  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.  *  It will also consider src size to be arbitrarily "large", which is worst case.  *  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.  *  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.  *  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParam_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_p_nbThreads is set to a value> 1.  *  Note : CStream estimation is only correct for single-threaded compression.  *  ZSTD_DStream memory budget depends on window Size.  *  This information can be passed manually, using ZSTD_estimateDStreamSize,  *  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();  *  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),  *         an internal ?Dict will be created, which additional size is not estimated here.  *         In this case, get total size by adding ZSTD_estimate?DictSize */
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCStreamSize
parameter_list|(
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCStreamSize_usingCParams
parameter_list|(
name|ZSTD_compressionParameters
name|cParams
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCStreamSize_usingCCtxParams
parameter_list|(
specifier|const
name|ZSTD_CCtx_params
modifier|*
name|params
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateDStreamSize
parameter_list|(
name|size_t
name|windowSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateDStreamSize_fromFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|ZSTD_dlm_byCopy
init|=
literal|0
block|,
comment|/**< Copy dictionary content internally */
name|ZSTD_dlm_byRef
block|,
comment|/**< Reference dictionary content -- the dictionary buffer must outlive its users. */
block|}
name|ZSTD_dictLoadMethod_e
typedef|;
comment|/*! ZSTD_estimate?DictSize() :  *  ZSTD_estimateCDictSize() will bet that src size is relatively "small", and content is copied, like ZSTD_createCDict().  *  ZSTD_estimateCStreamSize_advanced_usingCParams() makes it possible to control precisely compression parameters, like ZSTD_createCDict_advanced().  *  Note : dictionary created by reference using ZSTD_dlm_byRef are smaller  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCDictSize
parameter_list|(
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCDictSize_advanced
parameter_list|(
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_compressionParameters
name|cParams
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateDDictSize
parameter_list|(
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|)
function_decl|;
comment|/*************************************** *  Advanced compression functions ***************************************/
comment|/*! ZSTD_createCCtx_advanced() :  *  Create a ZSTD compression context using external alloc and free functions */
name|ZSTDLIB_API
name|ZSTD_CCtx
modifier|*
name|ZSTD_createCCtx_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_initStaticCCtx() : initialize a fixed-size zstd compression context  *  workspace: The memory area to emplace the context into.  *             Provided pointer must 8-bytes aligned.  *             It must outlive context usage.  *  workspaceSize: Use ZSTD_estimateCCtxSize() or ZSTD_estimateCStreamSize()  *                 to determine how large workspace must be to support scenario.  * @return : pointer to ZSTD_CCtx*, or NULL if error (size too small)  *  Note : zstd will never resize nor malloc() when using a static cctx.  *         If it needs more memory than available, it will simply error out.  *  Note 2 : there is no corresponding "free" function.  *           Since workspace was allocated externally, it must be freed externally too.  *  Limitation 1 : currently not compatible with internal CDict creation, such as  *                 ZSTD_CCtx_loadDictionary() or ZSTD_initCStream_usingDict().  *  Limitation 2 : currently not compatible with multi-threading  */
name|ZSTDLIB_API
name|ZSTD_CCtx
modifier|*
name|ZSTD_initStaticCCtx
parameter_list|(
name|void
modifier|*
name|workspace
parameter_list|,
name|size_t
name|workspaceSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_createCDict_byReference() :  *  Create a digested dictionary for compression  *  Dictionary content is simply referenced, and therefore stays in dictBuffer.  *  It is important that dictBuffer outlives CDict, it must remain read accessible throughout the lifetime of CDict */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_createCDict_byReference
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|ZSTD_dm_auto
init|=
literal|0
block|,
comment|/* dictionary is "full" if it starts with ZSTD_MAGIC_DICTIONARY, otherwise it is "rawContent" */
name|ZSTD_dm_rawContent
block|,
comment|/* ensures dictionary is always loaded as rawContent, even if it starts with ZSTD_MAGIC_DICTIONARY */
name|ZSTD_dm_fullDict
comment|/* refuses to load a dictionary if it does not respect Zstandard's specification */
block|}
name|ZSTD_dictMode_e
typedef|;
comment|/*! ZSTD_createCDict_advanced() :  *  Create a ZSTD_CDict using external alloc and free, and customized compression parameters */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_createCDict_advanced
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|,
name|ZSTD_dictMode_e
name|dictMode
parameter_list|,
name|ZSTD_compressionParameters
name|cParams
parameter_list|,
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_initStaticCDict_advanced() :  *  Generate a digested dictionary in provided memory area.  *  workspace: The memory area to emplace the dictionary into.  *             Provided pointer must 8-bytes aligned.  *             It must outlive dictionary usage.  *  workspaceSize: Use ZSTD_estimateCDictSize()  *                 to determine how large workspace must be.  *  cParams : use ZSTD_getCParams() to transform a compression level  *            into its relevants cParams.  * @return : pointer to ZSTD_CDict*, or NULL if error (size too small)  *  Note : there is no corresponding "free" function.  *         Since workspace was allocated externally, it must be freed externally.  */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_initStaticCDict
parameter_list|(
name|void
modifier|*
name|workspace
parameter_list|,
name|size_t
name|workspaceSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|,
name|ZSTD_dictMode_e
name|dictMode
parameter_list|,
name|ZSTD_compressionParameters
name|cParams
parameter_list|)
function_decl|;
comment|/*! ZSTD_getCParams() : *   @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize. *   `estimatedSrcSize` value is optional, select 0 if not known */
name|ZSTDLIB_API
name|ZSTD_compressionParameters
name|ZSTD_getCParams
parameter_list|(
name|int
name|compressionLevel
parameter_list|,
name|unsigned
name|long
name|long
name|estimatedSrcSize
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getParams() : *   same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`. *   All fields of `ZSTD_frameParameters` are set to default (0) */
name|ZSTDLIB_API
name|ZSTD_parameters
name|ZSTD_getParams
parameter_list|(
name|int
name|compressionLevel
parameter_list|,
name|unsigned
name|long
name|long
name|estimatedSrcSize
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_checkCParams() : *   Ensure param values remain within authorized range */
name|ZSTDLIB_API
name|size_t
name|ZSTD_checkCParams
parameter_list|(
name|ZSTD_compressionParameters
name|params
parameter_list|)
function_decl|;
comment|/*! ZSTD_adjustCParams() :  *  optimize params for a given `srcSize` and `dictSize`.  *  both values are optional, select `0` if unknown. */
name|ZSTDLIB_API
name|ZSTD_compressionParameters
name|ZSTD_adjustCParams
parameter_list|(
name|ZSTD_compressionParameters
name|cPar
parameter_list|,
name|unsigned
name|long
name|long
name|srcSize
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_compress_advanced() : *   Same as ZSTD_compress_usingDict(), with fine-tune control over each compression parameter */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|)
function_decl|;
comment|/*! ZSTD_compress_usingCDict_advanced() : *   Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_usingCDict_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|ZSTD_frameParameters
name|fParams
parameter_list|)
function_decl|;
comment|/*--- Advanced decompression functions ---*/
comment|/*! ZSTD_isFrame() :  *  Tells if the content of `buffer` starts with a valid Frame Identifier.  *  Note : Frame Identifier is 4 bytes. If `size< 4`, @return will always be 0.  *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.  *  Note 3 : Skippable Frame Identifiers are considered valid. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_isFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/*! ZSTD_createDCtx_advanced() :  *  Create a ZSTD decompression context using external alloc and free functions */
name|ZSTDLIB_API
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_initStaticDCtx() : initialize a fixed-size zstd decompression context  *  workspace: The memory area to emplace the context into.  *             Provided pointer must 8-bytes aligned.  *             It must outlive context usage.  *  workspaceSize: Use ZSTD_estimateDCtxSize() or ZSTD_estimateDStreamSize()  *                 to determine how large workspace must be to support scenario.  * @return : pointer to ZSTD_DCtx*, or NULL if error (size too small)  *  Note : zstd will never resize nor malloc() when using a static dctx.  *         If it needs more memory than available, it will simply error out.  *  Note 2 : static dctx is incompatible with legacy support  *  Note 3 : there is no corresponding "free" function.  *           Since workspace was allocated externally, it must be freed externally.  *  Limitation : currently not compatible with internal DDict creation,  *               such as ZSTD_initDStream_usingDict().  */
name|ZSTDLIB_API
name|ZSTD_DCtx
modifier|*
name|ZSTD_initStaticDCtx
parameter_list|(
name|void
modifier|*
name|workspace
parameter_list|,
name|size_t
name|workspaceSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_createDDict_byReference() :  *  Create a digested dictionary, ready to start decompression operation without startup delay.  *  Dictionary content is referenced, and therefore stays in dictBuffer.  *  It is important that dictBuffer outlives DDict,  *  it must remain read accessible throughout the lifetime of DDict */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict_byReference
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_createDDict_advanced() :  *  Create a ZSTD_DDict using external alloc and free, optionally by reference */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict_advanced
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|,
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_initStaticDDict() :  *  Generate a digested dictionary in provided memory area.  *  workspace: The memory area to emplace the dictionary into.  *             Provided pointer must 8-bytes aligned.  *             It must outlive dictionary usage.  *  workspaceSize: Use ZSTD_estimateDDictSize()  *                 to determine how large workspace must be.  * @return : pointer to ZSTD_DDict*, or NULL if error (size too small)  *  Note : there is no corresponding "free" function.  *         Since workspace was allocated externally, it must be freed externally.  */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_initStaticDDict
parameter_list|(
name|void
modifier|*
name|workspace
parameter_list|,
name|size_t
name|workspaceSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDictID_fromDict() :  *  Provides the dictID stored within dictionary.  *  if @return == 0, the dictionary is not conformant with Zstandard specification.  *  It can still be loaded, but as a content-only dictionary. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_getDictID_fromDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDictID_fromDDict() :  *  Provides the dictID of the dictionary loaded into `ddict`.  *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.  *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_getDictID_fromDDict
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDictID_fromFrame() :  *  Provides the dictID required to decompressed the frame stored within `src`.  *  If @return == 0, the dictID could not be decoded.  *  This could for one of the following reasons :  *  - The frame does not require a dictionary to be decoded (most common case).  *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.  *    Note : this use case also happens when using a non-conformant dictionary.  *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize< ZSTD_FRAMEHEADERSIZE_MAX`).  *  - This is not a Zstandard frame.  *  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_getDictID_fromFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/******************************************************************** *  Advanced streaming functions ********************************************************************/
comment|/*=====   Advanced Streaming compression functions  =====*/
name|ZSTDLIB_API
name|ZSTD_CStream
modifier|*
name|ZSTD_createCStream_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|ZSTD_CStream
modifier|*
name|ZSTD_initStaticCStream
parameter_list|(
name|void
modifier|*
name|workspace
parameter_list|,
name|size_t
name|workspaceSize
parameter_list|)
function_decl|;
comment|/**< same as ZSTD_initStaticCCtx() */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_srcSize
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< pledgedSrcSize must be correct, a size of 0 means unknown.  for a frame size of 0 use initCStream_advanced */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_usingDict
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/**< creates of an internal CDict (incompatible with static CCtx), except if dict == NULL or dictSize< 8, in which case no dict is used. Note: dict is loaded with ZSTD_dm_auto (treated as a full zstd dictionary if it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_advanced
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< pledgedSrcSize is optional and can be 0 (meaning unknown). note: if the contentSizeFlag is set, pledgedSrcSize == 0 means the source size is actually 0. dict is loaded with ZSTD_dm_auto and ZSTD_dlm_byCopy. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_usingCDict
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
comment|/**< note : cdict will just be referenced, and must outlive compression session */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_usingCDict_advanced
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|ZSTD_frameParameters
name|fParams
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< same as ZSTD_initCStream_usingCDict(), with control over frame parameters */
comment|/*! ZSTD_resetCStream() :  *  start a new compression job, using same parameters from previous job.  *  This is typically useful to skip dictionary loading stage, since it will re-use it in-place..  *  Note that zcs must be init at least once before using ZSTD_resetCStream().  *  pledgedSrcSize==0 means "srcSize unknown".  *  If pledgedSrcSize> 0, its value must be correct, as it will be written in header, and controlled at the end.  *  @return : 0, or an error code (which can be tested using ZSTD_isError()) */
name|ZSTDLIB_API
name|size_t
name|ZSTD_resetCStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/*=====   Advanced Streaming decompression functions  =====*/
name|ZSTDLIB_API
name|ZSTD_DStream
modifier|*
name|ZSTD_createDStream_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|ZSTD_DStream
modifier|*
name|ZSTD_initStaticDStream
parameter_list|(
name|void
modifier|*
name|workspace
parameter_list|,
name|size_t
name|workspaceSize
parameter_list|)
function_decl|;
comment|/**< same as ZSTD_initStaticDCtx() */
typedef|typedef
enum|enum
block|{
name|DStream_p_maxWindowSize
block|}
name|ZSTD_DStreamParameter_e
typedef|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_setDStreamParameter
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
name|ZSTD_DStreamParameter_e
name|paramType
parameter_list|,
name|unsigned
name|paramValue
parameter_list|)
function_decl|;
comment|/* obsolete : this API will be removed in a future version */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initDStream_usingDict
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/**< note: no dictionary will be used if dict == NULL or dictSize< 8 */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initDStream_usingDDict
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/**< note : ddict is referenced, it must outlive decompression session */
name|ZSTDLIB_API
name|size_t
name|ZSTD_resetDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
comment|/**< re-use decompression parameters from previous init; saves dictionary loading */
comment|/********************************************************************* *  Buffer-less and synchronous inner streaming functions * *  This is an advanced API, giving full control over buffer management, for users which need direct control over memory. *  But it's also a complex one, with several restrictions, documented below. *  Prefer normal streaming API for an easier experience. ********************************************************************* */
comment|/**   Buffer-less streaming compression (synchronous mode)    A ZSTD_CCtx object is required to track streaming operations.   Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.   ZSTD_CCtx object can be re-used multiple times within successive compression operations.    Start by initializing a context.   Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,   or ZSTD_compressBegin_advanced(), for finer parameter control.   It's also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()    Then, consume your input using ZSTD_compressContinue().   There are some important considerations to keep in mind when using this advanced function :   - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.   - Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.   - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.     Worst case evaluation is provided by ZSTD_compressBound().     ZSTD_compressContinue() doesn't guarantee recover after a failed compression.   - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).     It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)   - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.     In which case, it will "discard" the relevant memory section from its history.    Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.   It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.   Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.    `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again. */
comment|/*=====   Buffer-less streaming compression functions  =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_usingDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< pledgedSrcSize is optional and can be 0 (meaning unknown). note: if the contentSizeFlag is set, pledgedSrcSize == 0 means the source size is actually 0 */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_usingCDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
comment|/**< note: fails if cdict==NULL */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_usingCDict_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
specifier|const
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
specifier|const
name|cdict
parameter_list|,
name|ZSTD_frameParameters
specifier|const
name|fParams
parameter_list|,
name|unsigned
name|long
name|long
specifier|const
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/* compression parameters are already set within cdict. pledgedSrcSize=0 means null-size */
name|ZSTDLIB_API
name|size_t
name|ZSTD_copyCCtx
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CCtx
modifier|*
name|preparedCCtx
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**<  note: if pledgedSrcSize can be 0, indicating unknown size.  if it is non-zero, it must be accurate.  for 0 size frames, use compressBegin_advanced */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressContinue
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressEnd
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*-   Buffer-less streaming decompression (synchronous mode)    A ZSTD_DCtx object is required to track streaming operations.   Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.   A ZSTD_DCtx object can be re-used multiple times.    First typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().   Frame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough.   Data fragment must be large enough to ensure successful decoding.  `ZSTD_frameHeaderSize_max` bytes is guaranteed to always be large enough.   @result : 0 : successful decoding, the `ZSTD_frameHeader` structure is correctly filled.>0 : `srcSize` is too small, please provide at least @result bytes on next attempt.            errorCode, which can be tested using ZSTD_isError().    It fills a ZSTD_frameHeader structure with important information to correctly decode the frame,   such as the dictionary ID, content size, or maximum back-reference distance (`windowSize`).   Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.   As a consequence, check that values remain within valid application range.   For example, do not allocate memory blindly, check that `windowSize` is within expectation.   Each application can set its own limits, depending on local restrictions.   For extended interoperability, it is recommended to support `windowSize` of at least 8 MB.    ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize` bytes.   ZSTD_decompressContinue() is very sensitive to contiguity,   if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,   or that previous contiguous segment is large enough to properly handle maximum back-reference distance.   There are multiple ways to guarantee this condition.    The most memory efficient way is to use a round buffer of sufficient size.   Sufficient size is determined by invoking ZSTD_decodingBufferSize_min(),   which can @return an error code if required value is too large for current system (in 32-bits mode).   In a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,   up to the moment there is not enough room left in the buffer to guarantee decoding another full block,   which maximum size is provided in `ZSTD_frameHeader` structure, field `blockSizeMax`.   At which point, decoding can resume from the beginning of the buffer.   Note that already decoded data stored in the buffer should be flushed before being overwritten.    There are alternatives possible, for example using two or more buffers of size `windowSize` each, though they consume more memory.    Finally, if you control the compression process, you can also ignore all buffer size rules,   as long as the encoder and decoder progress in "lock-step",   aka use exactly the same buffer sizes, break contiguity at the same place, etc.    Once buffers are setup, start decompression, with ZSTD_decompressBegin().   If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().    Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.   ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().   ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.   @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily<= dstCapacity).   It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.   It can also be an error code, which can be tested with ZSTD_isError().    A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.   Context can then be reset to start a new decompression.    Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().   This information is not required to properly decode a frame.    == Special case : skippable frames ==    Skippable frames allow integration of user-defined data into a flow of concatenated frames.   Skippable frames will be ignored (skipped) by decompressor.   The format of skippable frames is as follows :   a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F   b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits   c) Frame Content - any content (User Data) of length equal to Frame Size   For skippable frames ZSTD_getFrameHeader() returns zfhPtr->frameType==ZSTD_skippableFrame.   For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content. */
comment|/*=====   Buffer-less streaming decompression functions  =====*/
typedef|typedef
enum|enum
block|{
name|ZSTD_frame
block|,
name|ZSTD_skippableFrame
block|}
name|ZSTD_frameType_e
typedef|;
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|long
name|frameContentSize
decl_stmt|;
comment|/* if == ZSTD_CONTENTSIZE_UNKNOWN, it means this field is not available. 0 means "empty" */
name|unsigned
name|long
name|long
name|windowSize
decl_stmt|;
comment|/* can be very large, up to<= frameContentSize */
name|unsigned
name|blockSizeMax
decl_stmt|;
name|ZSTD_frameType_e
name|frameType
decl_stmt|;
comment|/* if == ZSTD_skippableFrame, frameContentSize is the size of skippable content */
name|unsigned
name|headerSize
decl_stmt|;
name|unsigned
name|dictID
decl_stmt|;
name|unsigned
name|checksumFlag
decl_stmt|;
block|}
name|ZSTD_frameHeader
typedef|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_getFrameHeader
parameter_list|(
name|ZSTD_frameHeader
modifier|*
name|zfhPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/**< doesn't consume input */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decodingBufferSize_min
parameter_list|(
name|unsigned
name|long
name|long
name|windowSize
parameter_list|,
name|unsigned
name|long
name|long
name|frameContentSize
parameter_list|)
function_decl|;
comment|/**< when frame content size is not known, pass in frameContentSize == ZSTD_CONTENTSIZE_UNKNOWN */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBegin
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBegin_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBegin_usingDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_nextSrcSizeToDecompress
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressContinue
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/* misc */
name|ZSTDLIB_API
name|void
name|ZSTD_copyDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|ZSTD_DCtx
modifier|*
name|preparedDCtx
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|ZSTDnit_frameHeader
block|,
name|ZSTDnit_blockHeader
block|,
name|ZSTDnit_block
block|,
name|ZSTDnit_lastBlock
block|,
name|ZSTDnit_checksum
block|,
name|ZSTDnit_skippableFrame
block|}
name|ZSTD_nextInputType_e
typedef|;
name|ZSTDLIB_API
name|ZSTD_nextInputType_e
name|ZSTD_nextInputType
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
comment|/* ============================================ */
comment|/**       New advanced API (experimental)       */
comment|/* ============================================ */
comment|/* notes on API design :  *   In this proposal, parameters are pushed one by one into an existing context,  *   and then applied on all subsequent compression jobs.  *   When no parameter is ever provided, CCtx is created with compression level ZSTD_CLEVEL_DEFAULT.  *  *   This API is intended to replace all others experimental API.  *   It can basically do all other use cases, and even new ones.  *   In constrast with _advanced() variants, it stands a reasonable chance to become "stable",  *   after a good testing period.  */
comment|/* note on naming convention :  *   Initially, the API favored names like ZSTD_setCCtxParameter() .  *   In this proposal, convention is changed towards ZSTD_CCtx_setParameter() .  *   The main driver is that it identifies more clearly the target object type.  *   It feels clearer when considering multiple targets :  *   ZSTD_CDict_setParameter() (rather than ZSTD_setCDictParameter())  *   ZSTD_CCtxParams_setParameter()  (rather than ZSTD_setCCtxParamsParameter() )  *   etc...  */
comment|/* note on enum design :  * All enum will be pinned to explicit values before reaching "stable API" status */
typedef|typedef
enum|enum
block|{
comment|/* Question : should we have a format ZSTD_f_auto ?      * For the time being, it would mean exactly the same as ZSTD_f_zstd1.      * But, in the future, should several formats be supported,      * on the compression side, it would mean "default format".      * On the decompression side, it would mean "multi format",      * and ZSTD_f_zstd1 could be reserved to mean "accept *only* zstd frames".      * Since meaning is a little different, another option could be to define different enums for compression and decompression.      * This question could be kept for later, when there are actually multiple formats to support,      * but there is also the question of pinning enum values, and pinning value `0` is especially important */
name|ZSTD_f_zstd1
init|=
literal|0
block|,
comment|/* zstd frame format, specified in zstd_compression_format.md (default) */
name|ZSTD_f_zstd1_magicless
block|,
comment|/* Variant of zstd frame format, without initial 4-bytes magic number.                               * Useful to save 4 bytes per generated frame.                               * Decoder cannot recognise automatically this format, requiring instructions. */
block|}
name|ZSTD_format_e
typedef|;
typedef|typedef
enum|enum
block|{
comment|/* compression format */
name|ZSTD_p_format
init|=
literal|10
block|,
comment|/* See ZSTD_format_e enum definition.                               * Cast selected format as unsigned for ZSTD_CCtx_setParameter() compatibility. */
comment|/* compression parameters */
name|ZSTD_p_compressionLevel
init|=
literal|100
block|,
comment|/* Update all compression parameters according to pre-defined cLevel table                               * Default level is ZSTD_CLEVEL_DEFAULT==3.                               * Special: value 0 means "do not change cLevel". */
name|ZSTD_p_windowLog
block|,
comment|/* Maximum allowed back-reference distance, expressed as power of 2.                               * Must be clamped between ZSTD_WINDOWLOG_MIN and ZSTD_WINDOWLOG_MAX.                               * Special: value 0 means "do not change windowLog".                               * Note: Using a window size greater than ZSTD_MAXWINDOWSIZE_DEFAULT (default: 2^27)                               * requires setting the maximum window size at least as large during decompression. */
name|ZSTD_p_hashLog
block|,
comment|/* Size of the probe table, as a power of 2.                               * Resulting table size is (1<< (hashLog+2)).                               * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX.                               * Larger tables improve compression ratio of strategies<= dFast,                               * and improve speed of strategies> dFast.                               * Special: value 0 means "do not change hashLog". */
name|ZSTD_p_chainLog
block|,
comment|/* Size of the full-search table, as a power of 2.                               * Resulting table size is (1<< (chainLog+2)).                               * Larger tables result in better and slower compression.                               * This parameter is useless when using "fast" strategy.                               * Special: value 0 means "do not change chainLog". */
name|ZSTD_p_searchLog
block|,
comment|/* Number of search attempts, as a power of 2.                               * More attempts result in better and slower compression.                               * This parameter is useless when using "fast" and "dFast" strategies.                               * Special: value 0 means "do not change searchLog". */
name|ZSTD_p_minMatch
block|,
comment|/* Minimum size of searched matches (note : repCode matches can be smaller).                               * Larger values make faster compression and decompression, but decrease ratio.                               * Must be clamped between ZSTD_SEARCHLENGTH_MIN and ZSTD_SEARCHLENGTH_MAX.                               * Note that currently, for all strategies< btopt, effective minimum is 4.                               * Note that currently, for all strategies> fast, effective maximum is 6.                               * Special: value 0 means "do not change minMatchLength". */
name|ZSTD_p_targetLength
block|,
comment|/* Only useful for strategies>= btopt.                               * Length of Match considered "good enough" to stop search.                               * Larger values make compression stronger and slower.                               * Special: value 0 means "do not change targetLength". */
name|ZSTD_p_compressionStrategy
block|,
comment|/* See ZSTD_strategy enum definition.                               * Cast selected strategy as unsigned for ZSTD_CCtx_setParameter() compatibility.                               * The higher the value of selected strategy, the more complex it is,                               * resulting in stronger and slower compression.                               * Special: value 0 means "do not change strategy". */
comment|/* frame parameters */
name|ZSTD_p_contentSizeFlag
init|=
literal|200
block|,
comment|/* Content size is written into frame header _whenever known_ (default:1)                               * note that content size must be known at the beginning,                               * it is sent using ZSTD_CCtx_setPledgedSrcSize() */
name|ZSTD_p_checksumFlag
block|,
comment|/* A 32-bits checksum of content is written at end of frame (default:0) */
name|ZSTD_p_dictIDFlag
block|,
comment|/* When applicable, dictID of dictionary is provided in frame header (default:1) */
comment|/* multi-threading parameters */
name|ZSTD_p_nbThreads
init|=
literal|400
block|,
comment|/* Select how many threads a compression job can spawn (default:1)                               * More threads improve speed, but also increase memory usage.                               * Can only receive a value> 1 if ZSTD_MULTITHREAD is enabled.                               * Special: value 0 means "do not change nbThreads" */
name|ZSTD_p_jobSize
block|,
comment|/* Size of a compression job. Each compression job is completed in parallel.                               * 0 means default, which is dynamically determined based on compression parameters.                               * Job size must be a minimum of overlapSize, or 1 KB, whichever is largest                               * The minimum size is automatically and transparently enforced */
name|ZSTD_p_overlapSizeLog
block|,
comment|/* Size of previous input reloaded at the beginning of each job.                               * 0 => no overlap, 6(default) => use 1/8th of windowSize,>=9 => use full windowSize */
comment|/* advanced parameters - may not remain available after API update */
name|ZSTD_p_forceMaxWindow
init|=
literal|1100
block|,
comment|/* Force back-reference distances to remain< windowSize,                               * even when referencing into Dictionary content (default:0) */
name|ZSTD_p_enableLongDistanceMatching
init|=
literal|1200
block|,
comment|/* Enable long distance matching.                                          * This parameter is designed to improve the compression                                          * ratio for large inputs with long distance matches.                                          * This increases the memory usage as well as window size.                                          * Note: setting this parameter sets all the LDM parameters                                          * as well as ZSTD_p_windowLog. It should be set after                                          * ZSTD_p_compressionLevel and before ZSTD_p_windowLog and                                          * other LDM parameters. Setting the compression level                                          * after this parameter overrides the window log, though LDM                                          * will remain enabled until explicitly disabled. */
name|ZSTD_p_ldmHashLog
block|,
comment|/* Size of the table for long distance matching, as a power of 2.                           * Larger values increase memory usage and compression ratio, but decrease                           * compression speed.                           * Must be clamped between ZSTD_HASHLOG_MIN and ZSTD_HASHLOG_MAX                           * (default: windowlog - 7). */
name|ZSTD_p_ldmMinMatch
block|,
comment|/* Minimum size of searched matches for long distance matcher.                           * Larger/too small values usually decrease compression ratio.                           * Must be clamped between ZSTD_LDM_MINMATCH_MIN                           * and ZSTD_LDM_MINMATCH_MAX (default: 64). */
name|ZSTD_p_ldmBucketSizeLog
block|,
comment|/* Log size of each bucket in the LDM hash table for collision resolution.                                * Larger values usually improve collision resolution but may decrease                                * compression speed.                                * The maximum value is ZSTD_LDM_BUCKETSIZELOG_MAX (default: 3). */
name|ZSTD_p_ldmHashEveryLog
block|,
comment|/* Frequency of inserting/looking up entries in the LDM hash table.                               * The default is MAX(0, (windowLog - ldmHashLog)) to                               * optimize hash table usage.                               * Larger values improve compression speed. Deviating far from the                               * default value will likely result in a decrease in compression ratio.                               * Must be clamped between 0 and ZSTD_WINDOWLOG_MAX - ZSTD_HASHLOG_MIN. */
block|}
name|ZSTD_cParameter
typedef|;
comment|/*! ZSTD_CCtx_setParameter() :  *  Set one compression parameter, selected by enum ZSTD_cParameter.  *  Note : when `value` is an enum, cast it to unsigned for proper type checking.  *  @result : 0, or an error code (which can be tested with ZSTD_isError()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_setParameter
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|ZSTD_cParameter
name|param
parameter_list|,
name|unsigned
name|value
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_setPledgedSrcSize() :  *  Total input data size to be compressed as a single frame.  *  This value will be controlled at the end, and result in error if not respected.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Note 1 : 0 means zero, empty.  *           In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.  *           Note that ZSTD_CONTENTSIZE_UNKNOWN is default value for new compression jobs.  *  Note 2 : If all data is provided and consumed in a single round,  *           this value is overriden by srcSize instead. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_setPledgedSrcSize
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_loadDictionary() :  *  Create an internal CDict from dict buffer.  *  Decompression will have to use same buffer.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,  *            meaning "return to no-dictionary mode".  *  Note 1 : `dict` content will be copied internally. Use  *            ZSTD_CCtx_loadDictionary_byReference() to reference dictionary  *            content instead. The dictionary buffer must then outlive its  *            users.  *  Note 2 : Loading a dictionary involves building tables, which are dependent on compression parameters.  *           For this reason, compression parameters cannot be changed anymore after loading a dictionary.  *           It's also a CPU-heavy operation, with non-negligible impact on latency.  *  Note 3 : Dictionary will be used for all future compression jobs.  *           To return to "no-dictionary" situation, load a NULL dictionary  *  Note 5 : Use ZSTD_CCtx_loadDictionary_advanced() to select how dictionary  *           content will be interpreted.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_loadDictionary
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_loadDictionary_byReference
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_loadDictionary_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|,
name|ZSTD_dictMode_e
name|dictMode
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_refCDict() :  *  Reference a prepared dictionary, to be used for all next compression jobs.  *  Note that compression parameters are enforced from within CDict,  *  and supercede any compression parameter previously set within CCtx.  *  The dictionary will remain valid for future compression jobs using same CCtx.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Special : adding a NULL CDict means "return to no-dictionary mode".  *  Note 1 : Currently, only one dictionary can be managed.  *           Adding a new dictionary effectively "discards" any previous one.  *  Note 2 : CDict is just referenced, its lifetime must outlive CCtx.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_refCDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_refPrefix() :  *  Reference a prefix (single-usage dictionary) for next compression job.  *  Decompression need same prefix to properly regenerate data.  *  Prefix is **only used once**. Tables are discarded at end of compression job.  *  Subsequent compression jobs will be done without prefix (if none is explicitly referenced).  *  If there is a need to use same prefix multiple times, consider embedding it into a ZSTD_CDict instead.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Special : Adding any prefix (including NULL) invalidates any previous prefix or dictionary  *  Note 1 : Prefix buffer is referenced. It must outlive compression job.  *  Note 2 : Referencing a prefix involves building tables, which are dependent on compression parameters.  *           It's a CPU-heavy operation, with non-negligible impact on latency.  *  Note 3 : By default, the prefix is treated as raw content  *           (ZSTD_dm_rawContent). Use ZSTD_CCtx_refPrefix_advanced() to alter  *           dictMode. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_refPrefix
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefixSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_refPrefix_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefixSize
parameter_list|,
name|ZSTD_dictMode_e
name|dictMode
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|ZSTD_e_continue
init|=
literal|0
block|,
comment|/* collect more data, encoder transparently decides when to output result, for optimal conditions */
name|ZSTD_e_flush
block|,
comment|/* flush any data provided so far - frame will continue, future data can still reference previous data for better compression */
name|ZSTD_e_end
comment|/* flush any remaining data and close current frame. Any additional data starts a new frame. */
block|}
name|ZSTD_EndDirective
typedef|;
comment|/*! ZSTD_compress_generic() :  *  Behave about the same as ZSTD_compressStream. To note :  *  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_setParameter()  *  - Compression parameters cannot be changed once compression is started.  *  - outpot->pos must be<= dstCapacity, input->pos must be<= srcSize  *  - outpot->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.  *  - @return provides the minimum amount of data still to flush from internal buffers  *            or an error code, which can be tested using ZSTD_isError().  *            if @return != 0, flush is not fully completed, there is some data left within internal buffers.  *  - after a ZSTD_e_end directive, if internal buffer is not fully flushed,  *            only ZSTD_e_end or ZSTD_e_flush operations are allowed.  *            It is necessary to fully flush internal buffers  *            before starting a new compression job, or changing compression parameters.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_generic
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|,
name|ZSTD_EndDirective
name|endOp
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_reset() :  *  Return a CCtx to clean state.  *  Useful after an error, or to interrupt an ongoing compression job and start a new one.  *  Any internal data not yet flushed is cancelled.  *  Dictionary (if any) is dropped.  *  All parameters are back to default values.  *  It's possible to modify compression parameters after a reset.  */
name|ZSTDLIB_API
name|void
name|ZSTD_CCtx_reset
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
comment|/* Not ready yet ! */
comment|/*! ZSTD_compress_generic_simpleArgs() :  *  Same as ZSTD_compress_generic(),  *  but using only integral types as arguments.  *  Argument list is larger than ZSTD_{in,out}Buffer,  *  but can be helpful for binders from dynamic languages  *  which have troubles handling structures containing memory pointers.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_generic_simpleArgs
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|size_t
modifier|*
name|dstPos
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|size_t
modifier|*
name|srcPos
parameter_list|,
name|ZSTD_EndDirective
name|endOp
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_params :  *  Quick howto :  *  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure  *  - ZSTD_CCtxParam_setParameter() : Push parameters one by one into  *                                    an existing ZSTD_CCtx_params structure.  *                                    This is similar to  *                                    ZSTD_CCtx_setParameter().  *  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to  *                                    an existing CCtx.  *                                    These parameters will be applied to  *                                    all subsequent compression jobs.  *  - ZSTD_compress_generic() : Do compression using the CCtx.  *  - ZSTD_freeCCtxParams() : Free the memory.  *  *  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()  *  for static allocation for single-threaded compression.  */
name|ZSTDLIB_API
name|ZSTD_CCtx_params
modifier|*
name|ZSTD_createCCtxParams
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*! ZSTD_resetCCtxParams() :  *  Reset params to default, with the default compression level.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_resetCCtxParams
parameter_list|(
name|ZSTD_CCtx_params
modifier|*
name|params
parameter_list|)
function_decl|;
comment|/*! ZSTD_initCCtxParams() :  *  Initializes the compression parameters of cctxParams according to  *  compression level. All other parameters are reset to their default values.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCCtxParams
parameter_list|(
name|ZSTD_CCtx_params
modifier|*
name|cctxParams
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_initCCtxParams_advanced() :  *  Initializes the compression and frame parameters of cctxParams according to  *  params. All other parameters are reset to their default values.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCCtxParams_advanced
parameter_list|(
name|ZSTD_CCtx_params
modifier|*
name|cctxParams
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCCtxParams
parameter_list|(
name|ZSTD_CCtx_params
modifier|*
name|params
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtxParam_setParameter() :  *  Similar to ZSTD_CCtx_setParameter.  *  Set one compression parameter, selected by enum ZSTD_cParameter.  *  Parameters must be applied to a ZSTD_CCtx using ZSTD_CCtx_setParametersUsingCCtxParams().  *  Note : when `value` is an enum, cast it to unsigned for proper type checking.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtxParam_setParameter
parameter_list|(
name|ZSTD_CCtx_params
modifier|*
name|params
parameter_list|,
name|ZSTD_cParameter
name|param
parameter_list|,
name|unsigned
name|value
parameter_list|)
function_decl|;
comment|/*! ZSTD_CCtx_setParametersUsingCCtxParams() :  *  Apply a set of ZSTD_CCtx_params to the compression context.  *  This must be done before the dictionary is loaded.  *  The pledgedSrcSize is treated as unknown.  *  Multithreading parameters are applied only if nbThreads> 1.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CCtx_setParametersUsingCCtxParams
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CCtx_params
modifier|*
name|params
parameter_list|)
function_decl|;
comment|/*===   Advanced parameters for decompression API  ===*/
comment|/* The following parameters must be set after creating a ZSTD_DCtx* (or ZSTD_DStream*) object,  * but before starting decompression of a frame.  */
comment|/*! ZSTD_DCtx_loadDictionary() :  *  Create an internal DDict from dict buffer,  *  to be used to decompress next frames.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,  *            meaning "return to no-dictionary mode".  *  Note 1 : `dict` content will be copied internally.  *            Use ZSTD_DCtx_loadDictionary_byReference()  *            to reference dictionary content instead.  *            In which case, the dictionary buffer must outlive its users.  *  Note 2 : Loading a dictionary involves building tables,  *           which has a non-negligible impact on CPU usage and latency.  *  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to select  *           how dictionary content will be interpreted and loaded.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_loadDictionary
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/* not implemented */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_loadDictionary_byReference
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/* not implemented */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_loadDictionary_advanced
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_dictLoadMethod_e
name|dictLoadMethod
parameter_list|,
name|ZSTD_dictMode_e
name|dictMode
parameter_list|)
function_decl|;
comment|/* not implemented */
comment|/*! ZSTD_DCtx_refDDict() :  *  Reference a prepared dictionary, to be used to decompress next frames.  *  The dictionary remains active for decompression of future frames using same DCtx.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Note 1 : Currently, only one dictionary can be managed.  *           Referencing a new dictionary effectively "discards" any previous one.  *  Special : adding a NULL DDict means "return to no-dictionary mode".  *  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_refDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/* not implemented */
comment|/*! ZSTD_DCtx_refPrefix() :  *  Reference a prefix (single-usage dictionary) for next compression job.  *  Prefix is **only used once**. It must be explicitly referenced before each frame.  *  If there is a need to use same prefix multiple times, consider embedding it into a ZSTD_DDict instead.  * @result : 0, or an error code (which can be tested with ZSTD_isError()).  *  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary  *  Note 2 : Prefix buffer is referenced. It must outlive compression job.  *  Note 3 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent).  *           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode.  *  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_refPrefix
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefixSize
parameter_list|)
function_decl|;
comment|/* not implemented */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_refPrefix_advanced
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|prefix
parameter_list|,
name|size_t
name|prefixSize
parameter_list|,
name|ZSTD_dictMode_e
name|dictMode
parameter_list|)
function_decl|;
comment|/* not implemented */
comment|/*! ZSTD_DCtx_setMaxWindowSize() :  *  Refuses allocating internal buffers for frames requiring a window size larger than provided limit.  *  This is useful to prevent a decoder context from reserving too much memory for itself (potential attack scenario).  *  This parameter is only useful in streaming mode, since no internal buffer is allocated in direct mode.  *  By default, a decompression context accepts all window sizes<= (1<< ZSTD_WINDOWLOG_MAX)  * @return : 0, or an error code (which can be tested using ZSTD_isError()).  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_setMaxWindowSize
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|size_t
name|maxWindowSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_DCtx_setFormat() :  *  Instruct the decoder context about what kind of data to decode next.  *  This instruction is mandatory to decode data without a fully-formed header,  *  such ZSTD_f_zstd1_magicless for example.  * @return : 0, or an error code (which can be tested using ZSTD_isError()).  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DCtx_setFormat
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|ZSTD_format_e
name|format
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress_generic() :  *  Behave the same as ZSTD_decompressStream.  *  Decompression parameters cannot be changed once decompression is started.  * @return : an error code, which can be tested using ZSTD_isError()  *           if>0, a hint, nb of expected input bytes for next invocation.  *           `0` means : a frame has just been fully decoded and flushed.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress_generic
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress_generic_simpleArgs() :  *  Same as ZSTD_decompress_generic(),  *  but using only integral types as arguments.  *  Argument list is larger than ZSTD_{in,out}Buffer,  *  but can be helpful for binders from dynamic languages  *  which have troubles handling structures containing memory pointers.  */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress_generic_simpleArgs
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|size_t
modifier|*
name|dstPos
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|size_t
modifier|*
name|srcPos
parameter_list|)
function_decl|;
comment|/*! ZSTD_DCtx_reset() :  *  Return a DCtx to clean state.  *  If a decompression was ongoing, any internal data not yet flushed is cancelled.  *  All parameters are back to default values, including sticky ones.  *  Dictionary (if any) is dropped.  *  Parameters can be modified again after a reset.  */
name|ZSTDLIB_API
name|void
name|ZSTD_DCtx_reset
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
comment|/* ============================ */
comment|/**       Block level API       */
comment|/* ============================ */
comment|/*!     Block functions produce and decode raw zstd blocks, without frame metadata.     Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes).     User will have to take in charge required information to regenerate data, such as compressed and content sizes.      A few rules to respect :     - Compressing and decompressing require a context structure       + Use ZSTD_createCCtx() and ZSTD_createDCtx()     - It is necessary to init context before starting       + compression : any ZSTD_compressBegin*() variant, including with dictionary       + decompression : any ZSTD_decompressBegin*() variant, including with dictionary       + copyCCtx() and copyDCtx() can be used too     - Block size is limited, it must be<= ZSTD_getBlockSize()<= ZSTD_BLOCKSIZE_MAX == 128 KB       + If input is larger than a block size, it's necessary to split input data into multiple blocks       + For inputs larger than a single block size, consider using the regular ZSTD_compress() instead.         Frame metadata is not that costly, and quickly becomes negligible as source size grows larger.     - When a block is considered not compressible enough, ZSTD_compressBlock() result will be zero.       In which case, nothing is produced into `dst`.       + User must test for such outcome and deal directly with uncompressed data       + ZSTD_decompressBlock() doesn't accept uncompressed data as input !!!       + In case of multiple successive blocks, should some of them be uncompressed,         decoder must be informed of their existence in order to follow proper history.         Use ZSTD_insertBlock() for such a case. */
define|#
directive|define
name|ZSTD_BLOCKSIZELOG_MAX
value|17
define|#
directive|define
name|ZSTD_BLOCKSIZE_MAX
value|(1<<ZSTD_BLOCKSIZELOG_MAX)
comment|/* define, for static allocation */
comment|/*=====   Raw zstd block functions  =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_getBlockSize
parameter_list|(
specifier|const
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBlock
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_insertBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|blockStart
parameter_list|,
name|size_t
name|blockSize
parameter_list|)
function_decl|;
comment|/**< insert uncompressed block into `dctx` history. Useful for multi-blocks decompression */
endif|#
directive|endif
comment|/* ZSTD_H_ZSTD_STATIC_LINKING_ONLY */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

end_unit

