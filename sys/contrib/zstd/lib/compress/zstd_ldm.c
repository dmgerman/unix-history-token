begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  */
end_comment

begin_include
include|#
directive|include
file|"zstd_ldm.h"
end_include

begin_include
include|#
directive|include
file|"zstd_fast.h"
end_include

begin_comment
comment|/* ZSTD_fillHashTable() */
end_comment

begin_include
include|#
directive|include
file|"zstd_double_fast.h"
end_include

begin_comment
comment|/* ZSTD_fillDoubleHashTable() */
end_comment

begin_define
define|#
directive|define
name|LDM_BUCKET_SIZE_LOG
value|3
end_define

begin_define
define|#
directive|define
name|LDM_MIN_MATCH_LENGTH
value|64
end_define

begin_define
define|#
directive|define
name|LDM_HASH_RLOG
value|7
end_define

begin_define
define|#
directive|define
name|LDM_HASH_CHAR_OFFSET
value|10
end_define

begin_function
name|size_t
name|ZSTD_ldm_initializeParameters
parameter_list|(
name|ldmParams_t
modifier|*
name|params
parameter_list|,
name|U32
name|enableLdm
parameter_list|)
block|{
name|ZSTD_STATIC_ASSERT
argument_list|(
name|LDM_BUCKET_SIZE_LOG
operator|<=
name|ZSTD_LDM_BUCKETSIZELOG_MAX
argument_list|)
expr_stmt|;
name|params
operator|->
name|enableLdm
operator|=
name|enableLdm
operator|>
literal|0
expr_stmt|;
name|params
operator|->
name|hashLog
operator|=
literal|0
expr_stmt|;
name|params
operator|->
name|bucketSizeLog
operator|=
name|LDM_BUCKET_SIZE_LOG
expr_stmt|;
name|params
operator|->
name|minMatchLength
operator|=
name|LDM_MIN_MATCH_LENGTH
expr_stmt|;
name|params
operator|->
name|hashEveryLog
operator|=
name|ZSTD_LDM_HASHEVERYLOG_NOTSET
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ZSTD_ldm_adjustParameters
parameter_list|(
name|ldmParams_t
modifier|*
name|params
parameter_list|,
name|U32
name|windowLog
parameter_list|)
block|{
if|if
condition|(
name|params
operator|->
name|hashLog
operator|==
literal|0
condition|)
block|{
name|params
operator|->
name|hashLog
operator|=
name|MAX
argument_list|(
name|ZSTD_HASHLOG_MIN
argument_list|,
name|windowLog
operator|-
name|LDM_HASH_RLOG
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|params
operator|->
name|hashLog
operator|<=
name|ZSTD_HASHLOG_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|hashEveryLog
operator|==
name|ZSTD_LDM_HASHEVERYLOG_NOTSET
condition|)
block|{
name|params
operator|->
name|hashEveryLog
operator|=
name|windowLog
operator|<
name|params
operator|->
name|hashLog
condition|?
literal|0
else|:
name|windowLog
operator|-
name|params
operator|->
name|hashLog
expr_stmt|;
block|}
name|params
operator|->
name|bucketSizeLog
operator|=
name|MIN
argument_list|(
name|params
operator|->
name|bucketSizeLog
argument_list|,
name|params
operator|->
name|hashLog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_ldm_getTableSize
parameter_list|(
name|U32
name|hashLog
parameter_list|,
name|U32
name|bucketSizeLog
parameter_list|)
block|{
name|size_t
specifier|const
name|ldmHSize
init|=
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|)
operator|<<
name|hashLog
decl_stmt|;
name|size_t
specifier|const
name|ldmBucketSizeLog
init|=
name|MIN
argument_list|(
name|bucketSizeLog
argument_list|,
name|hashLog
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|ldmBucketSize
init|=
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|)
operator|<<
operator|(
name|hashLog
operator|-
name|ldmBucketSizeLog
operator|)
decl_stmt|;
return|return
name|ldmBucketSize
operator|+
operator|(
name|ldmHSize
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ldmEntry_t
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_getSmallHash() :  *  numBits should be<= 32  *  If numBits==0, returns 0.  *  @return : the most significant numBits of value. */
end_comment

begin_function
specifier|static
name|U32
name|ZSTD_ldm_getSmallHash
parameter_list|(
name|U64
name|value
parameter_list|,
name|U32
name|numBits
parameter_list|)
block|{
name|assert
argument_list|(
name|numBits
operator|<=
literal|32
argument_list|)
expr_stmt|;
return|return
name|numBits
operator|==
literal|0
condition|?
literal|0
else|:
call|(
name|U32
call|)
argument_list|(
name|value
operator|>>
operator|(
literal|64
operator|-
name|numBits
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_getChecksum() :  *  numBitsToDiscard should be<= 32  *  @return : the next most significant 32 bits after numBitsToDiscard */
end_comment

begin_function
specifier|static
name|U32
name|ZSTD_ldm_getChecksum
parameter_list|(
name|U64
name|hash
parameter_list|,
name|U32
name|numBitsToDiscard
parameter_list|)
block|{
name|assert
argument_list|(
name|numBitsToDiscard
operator|<=
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|>>
operator|(
literal|64
operator|-
literal|32
operator|-
name|numBitsToDiscard
operator|)
operator|)
operator|&
literal|0xFFFFFFFF
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_getTag() ;  *  Given the hash, returns the most significant numTagBits bits  *  after (32 + hbits) bits.  *  *  If there are not enough bits remaining, return the last  *  numTagBits bits. */
end_comment

begin_function
specifier|static
name|U32
name|ZSTD_ldm_getTag
parameter_list|(
name|U64
name|hash
parameter_list|,
name|U32
name|hbits
parameter_list|,
name|U32
name|numTagBits
parameter_list|)
block|{
name|assert
argument_list|(
name|numTagBits
operator|<
literal|32
operator|&&
name|hbits
operator|<=
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
literal|32
operator|-
name|hbits
operator|<
name|numTagBits
condition|)
block|{
return|return
name|hash
operator|&
operator|(
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|numTagBits
operator|)
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|hash
operator|>>
operator|(
literal|32
operator|-
name|hbits
operator|-
name|numTagBits
operator|)
operator|)
operator|&
operator|(
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|numTagBits
operator|)
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_getBucket() :  *  Returns a pointer to the start of the bucket associated with hash. */
end_comment

begin_function
specifier|static
name|ldmEntry_t
modifier|*
name|ZSTD_ldm_getBucket
parameter_list|(
name|ldmState_t
modifier|*
name|ldmState
parameter_list|,
name|size_t
name|hash
parameter_list|,
name|ldmParams_t
specifier|const
name|ldmParams
parameter_list|)
block|{
return|return
name|ldmState
operator|->
name|hashTable
operator|+
operator|(
name|hash
operator|<<
name|ldmParams
operator|.
name|bucketSizeLog
operator|)
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_insertEntry() :  *  Insert the entry with corresponding hash into the hash table */
end_comment

begin_function
specifier|static
name|void
name|ZSTD_ldm_insertEntry
parameter_list|(
name|ldmState_t
modifier|*
name|ldmState
parameter_list|,
name|size_t
specifier|const
name|hash
parameter_list|,
specifier|const
name|ldmEntry_t
name|entry
parameter_list|,
name|ldmParams_t
specifier|const
name|ldmParams
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|bucketOffsets
init|=
name|ldmState
operator|->
name|bucketOffsets
decl_stmt|;
operator|*
operator|(
name|ZSTD_ldm_getBucket
argument_list|(
name|ldmState
argument_list|,
name|hash
argument_list|,
name|ldmParams
argument_list|)
operator|+
name|bucketOffsets
index|[
name|hash
index|]
operator|)
operator|=
name|entry
expr_stmt|;
name|bucketOffsets
index|[
name|hash
index|]
operator|++
expr_stmt|;
name|bucketOffsets
index|[
name|hash
index|]
operator|&=
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|ldmParams
operator|.
name|bucketSizeLog
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_makeEntryAndInsertByTag() :  *  *  Gets the small hash, checksum, and tag from the rollingHash.  *  *  If the tag matches (1<< ldmParams.hashEveryLog)-1, then  *  creates an ldmEntry from the offset, and inserts it into the hash table.  *  *  hBits is the length of the small hash, which is the most significant hBits  *  of rollingHash. The checksum is the next 32 most significant bits, followed  *  by ldmParams.hashEveryLog bits that make up the tag. */
end_comment

begin_function
specifier|static
name|void
name|ZSTD_ldm_makeEntryAndInsertByTag
parameter_list|(
name|ldmState_t
modifier|*
name|ldmState
parameter_list|,
name|U64
specifier|const
name|rollingHash
parameter_list|,
name|U32
specifier|const
name|hBits
parameter_list|,
name|U32
specifier|const
name|offset
parameter_list|,
name|ldmParams_t
specifier|const
name|ldmParams
parameter_list|)
block|{
name|U32
specifier|const
name|tag
init|=
name|ZSTD_ldm_getTag
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|,
name|ldmParams
operator|.
name|hashEveryLog
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|tagMask
init|=
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|ldmParams
operator|.
name|hashEveryLog
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|tagMask
condition|)
block|{
name|U32
specifier|const
name|hash
init|=
name|ZSTD_ldm_getSmallHash
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|checksum
init|=
name|ZSTD_ldm_getChecksum
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|)
decl_stmt|;
name|ldmEntry_t
name|entry
decl_stmt|;
name|entry
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|entry
operator|.
name|checksum
operator|=
name|checksum
expr_stmt|;
name|ZSTD_ldm_insertEntry
argument_list|(
name|ldmState
argument_list|,
name|hash
argument_list|,
name|entry
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_getRollingHash() :  *  Get a 64-bit hash using the first len bytes from buf.  *  *  Giving bytes s = s_1, s_2, ... s_k, the hash is defined to be  *  H(s) = s_1*(a^(k-1)) + s_2*(a^(k-2)) + ... + s_k*(a^0)  *  *  where the constant a is defined to be prime8bytes.  *  *  The implementation adds an offset to each byte, so  *  H(s) = (s_1 + HASH_CHAR_OFFSET)*(a^(k-1)) + ... */
end_comment

begin_function
specifier|static
name|U64
name|ZSTD_ldm_getRollingHash
parameter_list|(
specifier|const
name|BYTE
modifier|*
name|buf
parameter_list|,
name|U32
name|len
parameter_list|)
block|{
name|U64
name|ret
init|=
literal|0
decl_stmt|;
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|*=
name|prime8bytes
expr_stmt|;
name|ret
operator|+=
name|buf
index|[
name|i
index|]
operator|+
name|LDM_HASH_CHAR_OFFSET
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_ipow() :  *  Return base^exp. */
end_comment

begin_function
specifier|static
name|U64
name|ZSTD_ldm_ipow
parameter_list|(
name|U64
name|base
parameter_list|,
name|U64
name|exp
parameter_list|)
block|{
name|U64
name|ret
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|exp
condition|)
block|{
if|if
condition|(
name|exp
operator|&
literal|1
condition|)
block|{
name|ret
operator|*=
name|base
expr_stmt|;
block|}
name|exp
operator|>>=
literal|1
expr_stmt|;
name|base
operator|*=
name|base
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|U64
name|ZSTD_ldm_getHashPower
parameter_list|(
name|U32
name|minMatchLength
parameter_list|)
block|{
name|assert
argument_list|(
name|minMatchLength
operator|>=
name|ZSTD_LDM_MINMATCH_MIN
argument_list|)
expr_stmt|;
return|return
name|ZSTD_ldm_ipow
argument_list|(
name|prime8bytes
argument_list|,
name|minMatchLength
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_updateHash() :  *  Updates hash by removing toRemove and adding toAdd. */
end_comment

begin_function
specifier|static
name|U64
name|ZSTD_ldm_updateHash
parameter_list|(
name|U64
name|hash
parameter_list|,
name|BYTE
name|toRemove
parameter_list|,
name|BYTE
name|toAdd
parameter_list|,
name|U64
name|hashPower
parameter_list|)
block|{
name|hash
operator|-=
operator|(
operator|(
name|toRemove
operator|+
name|LDM_HASH_CHAR_OFFSET
operator|)
operator|*
name|hashPower
operator|)
expr_stmt|;
name|hash
operator|*=
name|prime8bytes
expr_stmt|;
name|hash
operator|+=
name|toAdd
operator|+
name|LDM_HASH_CHAR_OFFSET
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_countBackwardsMatch() :  *  Returns the number of bytes that match backwards before pIn and pMatch.  *  *  We count only bytes where pMatch>= pBase and pIn>= pAnchor. */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_ldm_countBackwardsMatch
parameter_list|(
specifier|const
name|BYTE
modifier|*
name|pIn
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|pAnchor
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|pMatch
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|pBase
parameter_list|)
block|{
name|size_t
name|matchLength
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pIn
operator|>
name|pAnchor
operator|&&
name|pMatch
operator|>
name|pBase
operator|&&
name|pIn
index|[
operator|-
literal|1
index|]
operator|==
name|pMatch
index|[
operator|-
literal|1
index|]
condition|)
block|{
name|pIn
operator|--
expr_stmt|;
name|pMatch
operator|--
expr_stmt|;
name|matchLength
operator|++
expr_stmt|;
block|}
return|return
name|matchLength
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_fillFastTables() :  *  *  Fills the relevant tables for the ZSTD_fast and ZSTD_dfast strategies.  *  This is similar to ZSTD_loadDictionaryContent.  *  *  The tables for the other strategies are filled within their  *  block compressors. */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_ldm_fillFastTables
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|void
modifier|*
name|end
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|end
decl_stmt|;
specifier|const
name|U32
name|mls
init|=
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|searchLength
decl_stmt|;
switch|switch
condition|(
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|strategy
condition|)
block|{
case|case
name|ZSTD_fast
case|:
name|ZSTD_fillHashTable
argument_list|(
name|zc
argument_list|,
name|iend
argument_list|,
name|mls
argument_list|)
expr_stmt|;
name|zc
operator|->
name|nextToUpdate
operator|=
call|(
name|U32
call|)
argument_list|(
name|iend
operator|-
name|zc
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZSTD_dfast
case|:
name|ZSTD_fillDoubleHashTable
argument_list|(
name|zc
argument_list|,
name|iend
argument_list|,
name|mls
argument_list|)
expr_stmt|;
name|zc
operator|->
name|nextToUpdate
operator|=
call|(
name|U32
call|)
argument_list|(
name|iend
operator|-
name|zc
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZSTD_greedy
case|:
case|case
name|ZSTD_lazy
case|:
case|case
name|ZSTD_lazy2
case|:
case|case
name|ZSTD_btlazy2
case|:
case|case
name|ZSTD_btopt
case|:
case|case
name|ZSTD_btultra
case|:
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* not possible : not a valid strategy id */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_fillLdmHashTable() :  *  *  Fills hashTable from (lastHashed + 1) to iend (non-inclusive).  *  lastHash is the rolling hash that corresponds to lastHashed.  *  *  Returns the rolling hash corresponding to position iend-1. */
end_comment

begin_function
specifier|static
name|U64
name|ZSTD_ldm_fillLdmHashTable
parameter_list|(
name|ldmState_t
modifier|*
name|state
parameter_list|,
name|U64
name|lastHash
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|lastHashed
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|iend
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|base
parameter_list|,
name|U32
name|hBits
parameter_list|,
name|ldmParams_t
specifier|const
name|ldmParams
parameter_list|)
block|{
name|U64
name|rollingHash
init|=
name|lastHash
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|cur
init|=
name|lastHashed
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|iend
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_updateHash
argument_list|(
name|rollingHash
argument_list|,
name|cur
index|[
operator|-
literal|1
index|]
argument_list|,
name|cur
index|[
name|ldmParams
operator|.
name|minMatchLength
operator|-
literal|1
index|]
argument_list|,
name|state
operator|->
name|hashPower
argument_list|)
expr_stmt|;
name|ZSTD_ldm_makeEntryAndInsertByTag
argument_list|(
name|state
argument_list|,
name|rollingHash
argument_list|,
name|hBits
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|cur
operator|-
name|base
argument_list|)
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
operator|++
name|cur
expr_stmt|;
block|}
return|return
name|rollingHash
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_ldm_limitTableUpdate() :  *  *  Sets cctx->nextToUpdate to a position corresponding closer to anchor  *  if it is far way  *  (after a long match, only update tables a limited amount). */
end_comment

begin_function
specifier|static
name|void
name|ZSTD_ldm_limitTableUpdate
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|anchor
parameter_list|)
block|{
name|U32
specifier|const
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|anchor
operator|-
name|cctx
operator|->
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|>
name|cctx
operator|->
name|nextToUpdate
operator|+
literal|1024
condition|)
block|{
name|cctx
operator|->
name|nextToUpdate
operator|=
name|current
operator|-
name|MIN
argument_list|(
literal|512
argument_list|,
name|current
operator|-
name|cctx
operator|->
name|nextToUpdate
operator|-
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|ZSTD_blockCompressor
function_decl|)
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* defined in zstd_compress.c */
end_comment

begin_function_decl
name|ZSTD_blockCompressor
name|ZSTD_selectBlockCompressor
parameter_list|(
name|ZSTD_strategy
name|strat
parameter_list|,
name|int
name|extDict
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|FORCE_INLINE_TEMPLATE
name|size_t
name|ZSTD_compressBlock_ldm_generic
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|ldmState_t
modifier|*
specifier|const
name|ldmState
init|=
operator|&
operator|(
name|cctx
operator|->
name|ldmState
operator|)
decl_stmt|;
specifier|const
name|ldmParams_t
name|ldmParams
init|=
name|cctx
operator|->
name|appliedParams
operator|.
name|ldmParams
decl_stmt|;
specifier|const
name|U64
name|hashPower
init|=
name|ldmState
operator|->
name|hashPower
decl_stmt|;
specifier|const
name|U32
name|hBits
init|=
name|ldmParams
operator|.
name|hashLog
operator|-
name|ldmParams
operator|.
name|bucketSizeLog
decl_stmt|;
specifier|const
name|U32
name|ldmBucketSize
init|=
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|ldmParams
operator|.
name|bucketSizeLog
operator|)
decl_stmt|;
specifier|const
name|U32
name|ldmTagMask
init|=
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|ldmParams
operator|.
name|hashEveryLog
operator|)
operator|-
literal|1
decl_stmt|;
name|seqStore_t
modifier|*
specifier|const
name|seqStorePtr
init|=
operator|&
operator|(
name|cctx
operator|->
name|seqStore
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|cctx
operator|->
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|anchor
init|=
name|istart
decl_stmt|;
specifier|const
name|U32
name|lowestIndex
init|=
name|cctx
operator|->
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|lowest
init|=
name|base
operator|+
name|lowestIndex
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ilimit
init|=
name|iend
operator|-
name|MAX
argument_list|(
name|ldmParams
operator|.
name|minMatchLength
argument_list|,
name|HASH_READ_SIZE
argument_list|)
decl_stmt|;
specifier|const
name|ZSTD_blockCompressor
name|blockCompressor
init|=
name|ZSTD_selectBlockCompressor
argument_list|(
name|cctx
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|strategy
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|U32
modifier|*
specifier|const
name|repToConfirm
init|=
name|seqStorePtr
operator|->
name|repToConfirm
decl_stmt|;
name|U32
name|savedRep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
name|U64
name|rollingHash
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|lastHashed
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|lastLiterals
decl_stmt|;
comment|/* Save seqStorePtr->rep and copy repToConfirm */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|savedRep
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
index|]
operator|=
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
expr_stmt|;
comment|/* Main Search Loop */
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
comment|/*< instead of<=, because repcode check at (ip+1) */
name|size_t
name|mLength
decl_stmt|;
name|U32
specifier|const
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
name|size_t
name|forwardMatchLength
init|=
literal|0
decl_stmt|,
name|backwardMatchLength
init|=
literal|0
decl_stmt|;
name|ldmEntry_t
modifier|*
name|bestEntry
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
name|istart
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_updateHash
argument_list|(
name|rollingHash
argument_list|,
name|lastHashed
index|[
literal|0
index|]
argument_list|,
name|lastHashed
index|[
name|ldmParams
operator|.
name|minMatchLength
index|]
argument_list|,
name|hashPower
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_getRollingHash
argument_list|(
name|ip
argument_list|,
name|ldmParams
operator|.
name|minMatchLength
argument_list|)
expr_stmt|;
block|}
name|lastHashed
operator|=
name|ip
expr_stmt|;
comment|/* Do not insert and do not look for a match */
if|if
condition|(
name|ZSTD_ldm_getTag
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|,
name|ldmParams
operator|.
name|hashEveryLog
argument_list|)
operator|!=
name|ldmTagMask
condition|)
block|{
name|ip
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Get the best entry and compute the match lengths */
block|{
name|ldmEntry_t
modifier|*
specifier|const
name|bucket
init|=
name|ZSTD_ldm_getBucket
argument_list|(
name|ldmState
argument_list|,
name|ZSTD_ldm_getSmallHash
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|)
argument_list|,
name|ldmParams
argument_list|)
decl_stmt|;
name|ldmEntry_t
modifier|*
name|cur
decl_stmt|;
name|size_t
name|bestMatchLength
init|=
literal|0
decl_stmt|;
name|U32
specifier|const
name|checksum
init|=
name|ZSTD_ldm_getChecksum
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|)
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|bucket
init|;
name|cur
operator|<
name|bucket
operator|+
name|ldmBucketSize
condition|;
operator|++
name|cur
control|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|pMatch
init|=
name|cur
operator|->
name|offset
operator|+
name|base
decl_stmt|;
name|size_t
name|curForwardMatchLength
decl_stmt|,
name|curBackwardMatchLength
decl_stmt|,
name|curTotalMatchLength
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|checksum
operator|!=
name|checksum
operator|||
name|cur
operator|->
name|offset
operator|<=
name|lowestIndex
condition|)
block|{
continue|continue;
block|}
name|curForwardMatchLength
operator|=
name|ZSTD_count
argument_list|(
name|ip
argument_list|,
name|pMatch
argument_list|,
name|iend
argument_list|)
expr_stmt|;
if|if
condition|(
name|curForwardMatchLength
operator|<
name|ldmParams
operator|.
name|minMatchLength
condition|)
block|{
continue|continue;
block|}
name|curBackwardMatchLength
operator|=
name|ZSTD_ldm_countBackwardsMatch
argument_list|(
name|ip
argument_list|,
name|anchor
argument_list|,
name|pMatch
argument_list|,
name|lowest
argument_list|)
expr_stmt|;
name|curTotalMatchLength
operator|=
name|curForwardMatchLength
operator|+
name|curBackwardMatchLength
expr_stmt|;
if|if
condition|(
name|curTotalMatchLength
operator|>
name|bestMatchLength
condition|)
block|{
name|bestMatchLength
operator|=
name|curTotalMatchLength
expr_stmt|;
name|forwardMatchLength
operator|=
name|curForwardMatchLength
expr_stmt|;
name|backwardMatchLength
operator|=
name|curBackwardMatchLength
expr_stmt|;
name|bestEntry
operator|=
name|cur
expr_stmt|;
block|}
block|}
block|}
comment|/* No match found -- continue searching */
if|if
condition|(
name|bestEntry
operator|==
name|NULL
condition|)
block|{
name|ZSTD_ldm_makeEntryAndInsertByTag
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|hBits
argument_list|,
name|current
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|ip
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Match found */
name|mLength
operator|=
name|forwardMatchLength
operator|+
name|backwardMatchLength
expr_stmt|;
name|ip
operator|-=
name|backwardMatchLength
expr_stmt|;
comment|/* Call the block compressor on the remaining literals */
block|{
name|U32
specifier|const
name|matchIndex
init|=
name|bestEntry
operator|->
name|offset
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|match
init|=
name|base
operator|+
name|matchIndex
operator|-
name|backwardMatchLength
decl_stmt|;
name|U32
specifier|const
name|offset
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|match
argument_list|)
decl_stmt|;
comment|/* Overwrite rep codes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
index|]
expr_stmt|;
comment|/* Fill tables for block compressor */
name|ZSTD_ldm_limitTableUpdate
argument_list|(
name|cctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|ZSTD_ldm_fillFastTables
argument_list|(
name|cctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
comment|/* Call block compressor and get remaining literals */
name|lastLiterals
operator|=
name|blockCompressor
argument_list|(
name|cctx
argument_list|,
name|anchor
argument_list|,
name|ip
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|nextToUpdate
operator|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
expr_stmt|;
comment|/* Update repToConfirm with the new offset */
for|for
control|(
name|i
operator|=
name|ZSTD_REP_NUM
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|repToConfirm
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|repToConfirm
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
comment|/* Store the sequence with the leftover literals */
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
name|lastLiterals
argument_list|,
name|ip
operator|-
name|lastLiterals
argument_list|,
name|offset
operator|+
name|ZSTD_REP_MOVE
argument_list|,
name|mLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the current entry into the hash table */
name|ZSTD_ldm_makeEntryAndInsertByTag
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|hBits
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|lastHashed
operator|-
name|base
argument_list|)
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ip
operator|+
name|backwardMatchLength
operator|==
name|lastHashed
argument_list|)
expr_stmt|;
comment|/* Fill the hash table from lastHashed+1 to ip+mLength*/
comment|/* Heuristic: don't need to fill the entire table at end of block */
if|if
condition|(
name|ip
operator|+
name|mLength
operator|<
name|ilimit
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_fillLdmHashTable
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|lastHashed
argument_list|,
name|ip
operator|+
name|mLength
argument_list|,
name|base
argument_list|,
name|hBits
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|lastHashed
operator|=
name|ip
operator|+
name|mLength
operator|-
literal|1
expr_stmt|;
block|}
name|ip
operator|+=
name|mLength
expr_stmt|;
name|anchor
operator|=
name|ip
expr_stmt|;
comment|/* Check immediate repcode */
while|while
condition|(
operator|(
name|ip
operator|<
name|ilimit
operator|)
operator|&&
operator|(
operator|(
name|repToConfirm
index|[
literal|1
index|]
operator|>
literal|0
operator|)
operator|&&
operator|(
name|repToConfirm
index|[
literal|1
index|]
operator|<=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|lowest
argument_list|)
operator|)
operator|&&
operator|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
operator|-
name|repToConfirm
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|size_t
specifier|const
name|rLength
init|=
name|ZSTD_count
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|ip
operator|+
literal|4
operator|-
name|repToConfirm
index|[
literal|1
index|]
argument_list|,
name|iend
argument_list|)
operator|+
literal|4
decl_stmt|;
comment|/* Swap repToConfirm[1]<=> repToConfirm[0] */
block|{
name|U32
specifier|const
name|tmpOff
init|=
name|repToConfirm
index|[
literal|1
index|]
decl_stmt|;
name|repToConfirm
index|[
literal|1
index|]
operator|=
name|repToConfirm
index|[
literal|0
index|]
expr_stmt|;
name|repToConfirm
index|[
literal|0
index|]
operator|=
name|tmpOff
expr_stmt|;
block|}
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
literal|0
argument_list|,
name|anchor
argument_list|,
literal|0
argument_list|,
name|rLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
comment|/* Fill the  hash table from lastHashed+1 to ip+rLength*/
if|if
condition|(
name|ip
operator|+
name|rLength
operator|<
name|ilimit
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_fillLdmHashTable
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|lastHashed
argument_list|,
name|ip
operator|+
name|rLength
argument_list|,
name|base
argument_list|,
name|hBits
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|lastHashed
operator|=
name|ip
operator|+
name|rLength
operator|-
literal|1
expr_stmt|;
block|}
name|ip
operator|+=
name|rLength
expr_stmt|;
name|anchor
operator|=
name|ip
expr_stmt|;
block|}
block|}
comment|/* Overwrite rep */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
index|]
expr_stmt|;
name|ZSTD_ldm_limitTableUpdate
argument_list|(
name|cctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|ZSTD_ldm_fillFastTables
argument_list|(
name|cctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|lastLiterals
operator|=
name|blockCompressor
argument_list|(
name|cctx
argument_list|,
name|anchor
argument_list|,
name|iend
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|cctx
operator|->
name|nextToUpdate
operator|=
call|(
name|U32
call|)
argument_list|(
name|iend
operator|-
name|base
argument_list|)
expr_stmt|;
comment|/* Restore seqStorePtr->rep */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|savedRep
index|[
name|i
index|]
expr_stmt|;
comment|/* Return the last literals size */
return|return
name|lastLiterals
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_ldm
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_ldm_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_compressBlock_ldm_extDict_generic
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|ldmState_t
modifier|*
specifier|const
name|ldmState
init|=
operator|&
operator|(
name|ctx
operator|->
name|ldmState
operator|)
decl_stmt|;
specifier|const
name|ldmParams_t
name|ldmParams
init|=
name|ctx
operator|->
name|appliedParams
operator|.
name|ldmParams
decl_stmt|;
specifier|const
name|U64
name|hashPower
init|=
name|ldmState
operator|->
name|hashPower
decl_stmt|;
specifier|const
name|U32
name|hBits
init|=
name|ldmParams
operator|.
name|hashLog
operator|-
name|ldmParams
operator|.
name|bucketSizeLog
decl_stmt|;
specifier|const
name|U32
name|ldmBucketSize
init|=
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|ldmParams
operator|.
name|bucketSizeLog
operator|)
decl_stmt|;
specifier|const
name|U32
name|ldmTagMask
init|=
operator|(
operator|(
name|U32
operator|)
literal|1
operator|<<
name|ldmParams
operator|.
name|hashEveryLog
operator|)
operator|-
literal|1
decl_stmt|;
name|seqStore_t
modifier|*
specifier|const
name|seqStorePtr
init|=
operator|&
operator|(
name|ctx
operator|->
name|seqStore
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|ctx
operator|->
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictBase
init|=
name|ctx
operator|->
name|dictBase
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|anchor
init|=
name|istart
decl_stmt|;
specifier|const
name|U32
name|lowestIndex
init|=
name|ctx
operator|->
name|lowLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictStart
init|=
name|dictBase
operator|+
name|lowestIndex
decl_stmt|;
specifier|const
name|U32
name|dictLimit
init|=
name|ctx
operator|->
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|lowPrefixPtr
init|=
name|base
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictBase
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ilimit
init|=
name|iend
operator|-
name|MAX
argument_list|(
name|ldmParams
operator|.
name|minMatchLength
argument_list|,
name|HASH_READ_SIZE
argument_list|)
decl_stmt|;
specifier|const
name|ZSTD_blockCompressor
name|blockCompressor
init|=
name|ZSTD_selectBlockCompressor
argument_list|(
name|ctx
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|strategy
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|U32
modifier|*
specifier|const
name|repToConfirm
init|=
name|seqStorePtr
operator|->
name|repToConfirm
decl_stmt|;
name|U32
name|savedRep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
name|U64
name|rollingHash
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|lastHashed
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|lastLiterals
decl_stmt|;
comment|/* Save seqStorePtr->rep and copy repToConfirm */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
block|{
name|savedRep
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
index|]
operator|=
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Search Loop */
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
comment|/*< instead of<=, because (ip+1) */
name|size_t
name|mLength
decl_stmt|;
specifier|const
name|U32
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
name|size_t
name|forwardMatchLength
init|=
literal|0
decl_stmt|,
name|backwardMatchLength
init|=
literal|0
decl_stmt|;
name|ldmEntry_t
modifier|*
name|bestEntry
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
name|istart
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_updateHash
argument_list|(
name|rollingHash
argument_list|,
name|lastHashed
index|[
literal|0
index|]
argument_list|,
name|lastHashed
index|[
name|ldmParams
operator|.
name|minMatchLength
index|]
argument_list|,
name|hashPower
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_getRollingHash
argument_list|(
name|ip
argument_list|,
name|ldmParams
operator|.
name|minMatchLength
argument_list|)
expr_stmt|;
block|}
name|lastHashed
operator|=
name|ip
expr_stmt|;
if|if
condition|(
name|ZSTD_ldm_getTag
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|,
name|ldmParams
operator|.
name|hashEveryLog
argument_list|)
operator|!=
name|ldmTagMask
condition|)
block|{
comment|/* Don't insert and don't look for a match */
name|ip
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Get the best entry and compute the match lengths */
block|{
name|ldmEntry_t
modifier|*
specifier|const
name|bucket
init|=
name|ZSTD_ldm_getBucket
argument_list|(
name|ldmState
argument_list|,
name|ZSTD_ldm_getSmallHash
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|)
argument_list|,
name|ldmParams
argument_list|)
decl_stmt|;
name|ldmEntry_t
modifier|*
name|cur
decl_stmt|;
name|size_t
name|bestMatchLength
init|=
literal|0
decl_stmt|;
name|U32
specifier|const
name|checksum
init|=
name|ZSTD_ldm_getChecksum
argument_list|(
name|rollingHash
argument_list|,
name|hBits
argument_list|)
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|bucket
init|;
name|cur
operator|<
name|bucket
operator|+
name|ldmBucketSize
condition|;
operator|++
name|cur
control|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|curMatchBase
init|=
name|cur
operator|->
name|offset
operator|<
name|dictLimit
condition|?
name|dictBase
else|:
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|pMatch
init|=
name|curMatchBase
operator|+
name|cur
operator|->
name|offset
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|matchEnd
init|=
name|cur
operator|->
name|offset
operator|<
name|dictLimit
condition|?
name|dictEnd
else|:
name|iend
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|lowMatchPtr
init|=
name|cur
operator|->
name|offset
operator|<
name|dictLimit
condition|?
name|dictStart
else|:
name|lowPrefixPtr
decl_stmt|;
name|size_t
name|curForwardMatchLength
decl_stmt|,
name|curBackwardMatchLength
decl_stmt|,
name|curTotalMatchLength
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|checksum
operator|!=
name|checksum
operator|||
name|cur
operator|->
name|offset
operator|<=
name|lowestIndex
condition|)
block|{
continue|continue;
block|}
name|curForwardMatchLength
operator|=
name|ZSTD_count_2segments
argument_list|(
name|ip
argument_list|,
name|pMatch
argument_list|,
name|iend
argument_list|,
name|matchEnd
argument_list|,
name|lowPrefixPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|curForwardMatchLength
operator|<
name|ldmParams
operator|.
name|minMatchLength
condition|)
block|{
continue|continue;
block|}
name|curBackwardMatchLength
operator|=
name|ZSTD_ldm_countBackwardsMatch
argument_list|(
name|ip
argument_list|,
name|anchor
argument_list|,
name|pMatch
argument_list|,
name|lowMatchPtr
argument_list|)
expr_stmt|;
name|curTotalMatchLength
operator|=
name|curForwardMatchLength
operator|+
name|curBackwardMatchLength
expr_stmt|;
if|if
condition|(
name|curTotalMatchLength
operator|>
name|bestMatchLength
condition|)
block|{
name|bestMatchLength
operator|=
name|curTotalMatchLength
expr_stmt|;
name|forwardMatchLength
operator|=
name|curForwardMatchLength
expr_stmt|;
name|backwardMatchLength
operator|=
name|curBackwardMatchLength
expr_stmt|;
name|bestEntry
operator|=
name|cur
expr_stmt|;
block|}
block|}
block|}
comment|/* No match found -- continue searching */
if|if
condition|(
name|bestEntry
operator|==
name|NULL
condition|)
block|{
name|ZSTD_ldm_makeEntryAndInsertByTag
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|hBits
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|lastHashed
operator|-
name|base
argument_list|)
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|ip
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Match found */
name|mLength
operator|=
name|forwardMatchLength
operator|+
name|backwardMatchLength
expr_stmt|;
name|ip
operator|-=
name|backwardMatchLength
expr_stmt|;
comment|/* Call the block compressor on the remaining literals */
block|{
comment|/* ip = current - backwardMatchLength              * The match is at (bestEntry->offset - backwardMatchLength) */
name|U32
specifier|const
name|matchIndex
init|=
name|bestEntry
operator|->
name|offset
decl_stmt|;
name|U32
specifier|const
name|offset
init|=
name|current
operator|-
name|matchIndex
decl_stmt|;
comment|/* Overwrite rep codes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
index|]
expr_stmt|;
comment|/* Fill the hash table for the block compressor */
name|ZSTD_ldm_limitTableUpdate
argument_list|(
name|ctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|ZSTD_ldm_fillFastTables
argument_list|(
name|ctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
comment|/* Call block compressor and get remaining literals  */
name|lastLiterals
operator|=
name|blockCompressor
argument_list|(
name|ctx
argument_list|,
name|anchor
argument_list|,
name|ip
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|nextToUpdate
operator|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
expr_stmt|;
comment|/* Update repToConfirm with the new offset */
for|for
control|(
name|i
operator|=
name|ZSTD_REP_NUM
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|repToConfirm
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|repToConfirm
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
comment|/* Store the sequence with the leftover literals */
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
name|lastLiterals
argument_list|,
name|ip
operator|-
name|lastLiterals
argument_list|,
name|offset
operator|+
name|ZSTD_REP_MOVE
argument_list|,
name|mLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the current entry into the hash table */
name|ZSTD_ldm_makeEntryAndInsertByTag
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|hBits
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|lastHashed
operator|-
name|base
argument_list|)
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
comment|/* Fill the hash table from lastHashed+1 to ip+mLength */
name|assert
argument_list|(
name|ip
operator|+
name|backwardMatchLength
operator|==
name|lastHashed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|+
name|mLength
operator|<
name|ilimit
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_fillLdmHashTable
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|lastHashed
argument_list|,
name|ip
operator|+
name|mLength
argument_list|,
name|base
argument_list|,
name|hBits
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|lastHashed
operator|=
name|ip
operator|+
name|mLength
operator|-
literal|1
expr_stmt|;
block|}
name|ip
operator|+=
name|mLength
expr_stmt|;
name|anchor
operator|=
name|ip
expr_stmt|;
comment|/* check immediate repcode */
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
name|U32
specifier|const
name|current2
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|repIndex2
init|=
name|current2
operator|-
name|repToConfirm
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|repMatch2
init|=
name|repIndex2
operator|<
name|dictLimit
condition|?
name|dictBase
operator|+
name|repIndex2
else|:
name|base
operator|+
name|repIndex2
decl_stmt|;
if|if
condition|(
operator|(
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|dictLimit
operator|-
literal|1
operator|)
operator|-
name|repIndex2
argument_list|)
operator|>=
literal|3
operator|)
operator|&
operator|(
name|repIndex2
operator|>
name|lowestIndex
operator|)
operator|)
comment|/* intentional overflow */
operator|&&
operator|(
name|MEM_read32
argument_list|(
name|repMatch2
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|repEnd2
init|=
name|repIndex2
operator|<
name|dictLimit
condition|?
name|dictEnd
else|:
name|iend
decl_stmt|;
name|size_t
specifier|const
name|repLength2
init|=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|repMatch2
operator|+
literal|4
argument_list|,
name|iend
argument_list|,
name|repEnd2
argument_list|,
name|lowPrefixPtr
argument_list|)
operator|+
literal|4
decl_stmt|;
name|U32
name|tmpOffset
init|=
name|repToConfirm
index|[
literal|1
index|]
decl_stmt|;
name|repToConfirm
index|[
literal|1
index|]
operator|=
name|repToConfirm
index|[
literal|0
index|]
expr_stmt|;
name|repToConfirm
index|[
literal|0
index|]
operator|=
name|tmpOffset
expr_stmt|;
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
literal|0
argument_list|,
name|anchor
argument_list|,
literal|0
argument_list|,
name|repLength2
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
comment|/* Fill the  hash table from lastHashed+1 to ip+repLength2*/
if|if
condition|(
name|ip
operator|+
name|repLength2
operator|<
name|ilimit
condition|)
block|{
name|rollingHash
operator|=
name|ZSTD_ldm_fillLdmHashTable
argument_list|(
name|ldmState
argument_list|,
name|rollingHash
argument_list|,
name|lastHashed
argument_list|,
name|ip
operator|+
name|repLength2
argument_list|,
name|base
argument_list|,
name|hBits
argument_list|,
name|ldmParams
argument_list|)
expr_stmt|;
name|lastHashed
operator|=
name|ip
operator|+
name|repLength2
operator|-
literal|1
expr_stmt|;
block|}
name|ip
operator|+=
name|repLength2
expr_stmt|;
name|anchor
operator|=
name|ip
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
comment|/* Overwrite rep */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|repToConfirm
index|[
name|i
index|]
expr_stmt|;
name|ZSTD_ldm_limitTableUpdate
argument_list|(
name|ctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|ZSTD_ldm_fillFastTables
argument_list|(
name|ctx
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
comment|/* Call the block compressor one last time on the last literals */
name|lastLiterals
operator|=
name|blockCompressor
argument_list|(
name|ctx
argument_list|,
name|anchor
argument_list|,
name|iend
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|nextToUpdate
operator|=
call|(
name|U32
call|)
argument_list|(
name|iend
operator|-
name|base
argument_list|)
expr_stmt|;
comment|/* Restore seqStorePtr->rep */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqStorePtr
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|savedRep
index|[
name|i
index|]
expr_stmt|;
comment|/* Return the last literals size */
return|return
name|lastLiterals
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_ldm_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_ldm_extDict_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
end_function

end_unit

