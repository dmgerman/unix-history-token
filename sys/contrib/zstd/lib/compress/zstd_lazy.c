begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  * You may select, at your option, one of the above-listed licenses.  */
end_comment

begin_include
include|#
directive|include
file|"zstd_lazy.h"
end_include

begin_comment
comment|/*-************************************* *  Binary Tree search ***************************************/
end_comment

begin_comment
comment|/** ZSTD_insertBt1() : add one or multiple positions to tree. *   ip : assumed<= iend-8 . *   @return : nb of positions added */
end_comment

begin_function
specifier|static
name|U32
name|ZSTD_insertBt1
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
parameter_list|,
name|U32
name|nbCompares
parameter_list|,
name|U32
name|extDict
parameter_list|)
block|{
name|U32
modifier|*
specifier|const
name|hashTable
init|=
name|zc
operator|->
name|hashTable
decl_stmt|;
name|U32
specifier|const
name|hashLog
init|=
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|hashLog
decl_stmt|;
name|size_t
specifier|const
name|h
init|=
name|ZSTD_hashPtr
argument_list|(
name|ip
argument_list|,
name|hashLog
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|U32
modifier|*
specifier|const
name|bt
init|=
name|zc
operator|->
name|chainTable
decl_stmt|;
name|U32
specifier|const
name|btLog
init|=
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|chainLog
operator|-
literal|1
decl_stmt|;
name|U32
specifier|const
name|btMask
init|=
operator|(
literal|1
operator|<<
name|btLog
operator|)
operator|-
literal|1
decl_stmt|;
name|U32
name|matchIndex
init|=
name|hashTable
index|[
name|h
index|]
decl_stmt|;
name|size_t
name|commonLengthSmaller
init|=
literal|0
decl_stmt|,
name|commonLengthLarger
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|zc
operator|->
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictBase
init|=
name|zc
operator|->
name|dictBase
decl_stmt|;
specifier|const
name|U32
name|dictLimit
init|=
name|zc
operator|->
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictBase
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|prefixStart
init|=
name|base
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
decl_stmt|;
specifier|const
name|U32
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
specifier|const
name|U32
name|btLow
init|=
name|btMask
operator|>=
name|current
condition|?
literal|0
else|:
name|current
operator|-
name|btMask
decl_stmt|;
name|U32
modifier|*
name|smallerPtr
init|=
name|bt
operator|+
literal|2
operator|*
operator|(
name|current
operator|&
name|btMask
operator|)
decl_stmt|;
name|U32
modifier|*
name|largerPtr
init|=
name|smallerPtr
operator|+
literal|1
decl_stmt|;
name|U32
name|dummy32
decl_stmt|;
comment|/* to be nullified at the end */
name|U32
specifier|const
name|windowLow
init|=
name|zc
operator|->
name|lowLimit
decl_stmt|;
name|U32
name|matchEndIdx
init|=
name|current
operator|+
literal|8
decl_stmt|;
name|size_t
name|bestLength
init|=
literal|8
decl_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_C_PREDICT
name|U32
name|predictedSmall
init|=
operator|*
operator|(
name|bt
operator|+
literal|2
operator|*
operator|(
operator|(
name|current
operator|-
literal|1
operator|)
operator|&
name|btMask
operator|)
operator|+
literal|0
operator|)
decl_stmt|;
name|U32
name|predictedLarge
init|=
operator|*
operator|(
name|bt
operator|+
literal|2
operator|*
operator|(
operator|(
name|current
operator|-
literal|1
operator|)
operator|&
name|btMask
operator|)
operator|+
literal|1
operator|)
decl_stmt|;
name|predictedSmall
operator|+=
operator|(
name|predictedSmall
operator|>
literal|0
operator|)
expr_stmt|;
name|predictedLarge
operator|+=
operator|(
name|predictedLarge
operator|>
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZSTD_C_PREDICT */
name|assert
argument_list|(
name|ip
operator|<=
name|iend
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* required for h calculation */
name|hashTable
index|[
name|h
index|]
operator|=
name|current
expr_stmt|;
comment|/* Update Hash Table */
while|while
condition|(
name|nbCompares
operator|--
operator|&&
operator|(
name|matchIndex
operator|>
name|windowLow
operator|)
condition|)
block|{
name|U32
modifier|*
specifier|const
name|nextPtr
init|=
name|bt
operator|+
literal|2
operator|*
operator|(
name|matchIndex
operator|&
name|btMask
operator|)
decl_stmt|;
name|size_t
name|matchLength
init|=
name|MIN
argument_list|(
name|commonLengthSmaller
argument_list|,
name|commonLengthLarger
argument_list|)
decl_stmt|;
comment|/* guaranteed minimum nb of common bytes */
ifdef|#
directive|ifdef
name|ZSTD_C_PREDICT
comment|/* note : can create issues when hlog small<= 11 */
specifier|const
name|U32
modifier|*
name|predictPtr
init|=
name|bt
operator|+
literal|2
operator|*
operator|(
operator|(
name|matchIndex
operator|-
literal|1
operator|)
operator|&
name|btMask
operator|)
decl_stmt|;
comment|/* written this way, as bt is a roll buffer */
if|if
condition|(
name|matchIndex
operator|==
name|predictedSmall
condition|)
block|{
comment|/* no need to check length, result known */
operator|*
name|smallerPtr
operator|=
name|matchIndex
expr_stmt|;
if|if
condition|(
name|matchIndex
operator|<=
name|btLow
condition|)
block|{
name|smallerPtr
operator|=
operator|&
name|dummy32
expr_stmt|;
break|break;
block|}
comment|/* beyond tree size, stop the search */
name|smallerPtr
operator|=
name|nextPtr
operator|+
literal|1
expr_stmt|;
comment|/* new "smaller" => larger of match */
name|matchIndex
operator|=
name|nextPtr
index|[
literal|1
index|]
expr_stmt|;
comment|/* new matchIndex larger than previous (closer to current) */
name|predictedSmall
operator|=
name|predictPtr
index|[
literal|1
index|]
operator|+
operator|(
name|predictPtr
index|[
literal|1
index|]
operator|>
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|matchIndex
operator|==
name|predictedLarge
condition|)
block|{
operator|*
name|largerPtr
operator|=
name|matchIndex
expr_stmt|;
if|if
condition|(
name|matchIndex
operator|<=
name|btLow
condition|)
block|{
name|largerPtr
operator|=
operator|&
name|dummy32
expr_stmt|;
break|break;
block|}
comment|/* beyond tree size, stop the search */
name|largerPtr
operator|=
name|nextPtr
expr_stmt|;
name|matchIndex
operator|=
name|nextPtr
index|[
literal|0
index|]
expr_stmt|;
name|predictedLarge
operator|=
name|predictPtr
index|[
literal|0
index|]
operator|+
operator|(
name|predictPtr
index|[
literal|0
index|]
operator|>
literal|0
operator|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|!
name|extDict
operator|)
operator|||
operator|(
name|matchIndex
operator|+
name|matchLength
operator|>=
name|dictLimit
operator|)
condition|)
block|{
name|match
operator|=
name|base
operator|+
name|matchIndex
expr_stmt|;
if|if
condition|(
name|match
index|[
name|matchLength
index|]
operator|==
name|ip
index|[
name|matchLength
index|]
condition|)
name|matchLength
operator|+=
name|ZSTD_count
argument_list|(
name|ip
operator|+
name|matchLength
operator|+
literal|1
argument_list|,
name|match
operator|+
name|matchLength
operator|+
literal|1
argument_list|,
name|iend
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|match
operator|=
name|dictBase
operator|+
name|matchIndex
expr_stmt|;
name|matchLength
operator|+=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
name|matchLength
argument_list|,
name|match
operator|+
name|matchLength
argument_list|,
name|iend
argument_list|,
name|dictEnd
argument_list|,
name|prefixStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchIndex
operator|+
name|matchLength
operator|>=
name|dictLimit
condition|)
name|match
operator|=
name|base
operator|+
name|matchIndex
expr_stmt|;
comment|/* to prepare for next usage of match[matchLength] */
block|}
if|if
condition|(
name|matchLength
operator|>
name|bestLength
condition|)
block|{
name|bestLength
operator|=
name|matchLength
expr_stmt|;
if|if
condition|(
name|matchLength
operator|>
name|matchEndIdx
operator|-
name|matchIndex
condition|)
name|matchEndIdx
operator|=
name|matchIndex
operator|+
operator|(
name|U32
operator|)
name|matchLength
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|+
name|matchLength
operator|==
name|iend
condition|)
comment|/* equal : no way to know if inf or sup */
break|break;
comment|/* drop , to guarantee consistency ; miss a bit of compression, but other solutions can corrupt tree */
if|if
condition|(
name|match
index|[
name|matchLength
index|]
operator|<
name|ip
index|[
name|matchLength
index|]
condition|)
block|{
comment|/* necessarily within buffer */
comment|/* match+1 is smaller than current */
operator|*
name|smallerPtr
operator|=
name|matchIndex
expr_stmt|;
comment|/* update smaller idx */
name|commonLengthSmaller
operator|=
name|matchLength
expr_stmt|;
comment|/* all smaller will now have at least this guaranteed common length */
if|if
condition|(
name|matchIndex
operator|<=
name|btLow
condition|)
block|{
name|smallerPtr
operator|=
operator|&
name|dummy32
expr_stmt|;
break|break;
block|}
comment|/* beyond tree size, stop searching */
name|smallerPtr
operator|=
name|nextPtr
operator|+
literal|1
expr_stmt|;
comment|/* new "smaller" => larger of match */
name|matchIndex
operator|=
name|nextPtr
index|[
literal|1
index|]
expr_stmt|;
comment|/* new matchIndex larger than previous (closer to current) */
block|}
else|else
block|{
comment|/* match is larger than current */
operator|*
name|largerPtr
operator|=
name|matchIndex
expr_stmt|;
name|commonLengthLarger
operator|=
name|matchLength
expr_stmt|;
if|if
condition|(
name|matchIndex
operator|<=
name|btLow
condition|)
block|{
name|largerPtr
operator|=
operator|&
name|dummy32
expr_stmt|;
break|break;
block|}
comment|/* beyond tree size, stop searching */
name|largerPtr
operator|=
name|nextPtr
expr_stmt|;
name|matchIndex
operator|=
name|nextPtr
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
operator|*
name|smallerPtr
operator|=
operator|*
name|largerPtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bestLength
operator|>
literal|384
condition|)
return|return
name|MIN
argument_list|(
literal|192
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|bestLength
operator|-
literal|384
argument_list|)
argument_list|)
return|;
comment|/* speed optimization */
if|if
condition|(
name|matchEndIdx
operator|>
name|current
operator|+
literal|8
condition|)
return|return
name|matchEndIdx
operator|-
operator|(
name|current
operator|+
literal|8
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_insertBtAndFindBestMatch
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
name|U32
name|nbCompares
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|,
name|U32
name|extDict
parameter_list|)
block|{
name|U32
modifier|*
specifier|const
name|hashTable
init|=
name|zc
operator|->
name|hashTable
decl_stmt|;
name|U32
specifier|const
name|hashLog
init|=
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|hashLog
decl_stmt|;
name|size_t
specifier|const
name|h
init|=
name|ZSTD_hashPtr
argument_list|(
name|ip
argument_list|,
name|hashLog
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|U32
modifier|*
specifier|const
name|bt
init|=
name|zc
operator|->
name|chainTable
decl_stmt|;
name|U32
specifier|const
name|btLog
init|=
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|chainLog
operator|-
literal|1
decl_stmt|;
name|U32
specifier|const
name|btMask
init|=
operator|(
literal|1
operator|<<
name|btLog
operator|)
operator|-
literal|1
decl_stmt|;
name|U32
name|matchIndex
init|=
name|hashTable
index|[
name|h
index|]
decl_stmt|;
name|size_t
name|commonLengthSmaller
init|=
literal|0
decl_stmt|,
name|commonLengthLarger
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|zc
operator|->
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictBase
init|=
name|zc
operator|->
name|dictBase
decl_stmt|;
specifier|const
name|U32
name|dictLimit
init|=
name|zc
operator|->
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictBase
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|prefixStart
init|=
name|base
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|U32
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
specifier|const
name|U32
name|btLow
init|=
name|btMask
operator|>=
name|current
condition|?
literal|0
else|:
name|current
operator|-
name|btMask
decl_stmt|;
specifier|const
name|U32
name|windowLow
init|=
name|zc
operator|->
name|lowLimit
decl_stmt|;
name|U32
modifier|*
name|smallerPtr
init|=
name|bt
operator|+
literal|2
operator|*
operator|(
name|current
operator|&
name|btMask
operator|)
decl_stmt|;
name|U32
modifier|*
name|largerPtr
init|=
name|bt
operator|+
literal|2
operator|*
operator|(
name|current
operator|&
name|btMask
operator|)
operator|+
literal|1
decl_stmt|;
name|U32
name|matchEndIdx
init|=
name|current
operator|+
literal|8
decl_stmt|;
name|U32
name|dummy32
decl_stmt|;
comment|/* to be nullified at the end */
name|size_t
name|bestLength
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|ip
operator|<=
name|iend
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* required for h calculation */
name|hashTable
index|[
name|h
index|]
operator|=
name|current
expr_stmt|;
comment|/* Update Hash Table */
while|while
condition|(
name|nbCompares
operator|--
operator|&&
operator|(
name|matchIndex
operator|>
name|windowLow
operator|)
condition|)
block|{
name|U32
modifier|*
specifier|const
name|nextPtr
init|=
name|bt
operator|+
literal|2
operator|*
operator|(
name|matchIndex
operator|&
name|btMask
operator|)
decl_stmt|;
name|size_t
name|matchLength
init|=
name|MIN
argument_list|(
name|commonLengthSmaller
argument_list|,
name|commonLengthLarger
argument_list|)
decl_stmt|;
comment|/* guaranteed minimum nb of common bytes */
specifier|const
name|BYTE
modifier|*
name|match
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|extDict
operator|)
operator|||
operator|(
name|matchIndex
operator|+
name|matchLength
operator|>=
name|dictLimit
operator|)
condition|)
block|{
name|match
operator|=
name|base
operator|+
name|matchIndex
expr_stmt|;
if|if
condition|(
name|match
index|[
name|matchLength
index|]
operator|==
name|ip
index|[
name|matchLength
index|]
condition|)
name|matchLength
operator|+=
name|ZSTD_count
argument_list|(
name|ip
operator|+
name|matchLength
operator|+
literal|1
argument_list|,
name|match
operator|+
name|matchLength
operator|+
literal|1
argument_list|,
name|iend
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|match
operator|=
name|dictBase
operator|+
name|matchIndex
expr_stmt|;
name|matchLength
operator|+=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
name|matchLength
argument_list|,
name|match
operator|+
name|matchLength
argument_list|,
name|iend
argument_list|,
name|dictEnd
argument_list|,
name|prefixStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchIndex
operator|+
name|matchLength
operator|>=
name|dictLimit
condition|)
name|match
operator|=
name|base
operator|+
name|matchIndex
expr_stmt|;
comment|/* to prepare for next usage of match[matchLength] */
block|}
if|if
condition|(
name|matchLength
operator|>
name|bestLength
condition|)
block|{
if|if
condition|(
name|matchLength
operator|>
name|matchEndIdx
operator|-
name|matchIndex
condition|)
name|matchEndIdx
operator|=
name|matchIndex
operator|+
operator|(
name|U32
operator|)
name|matchLength
expr_stmt|;
if|if
condition|(
operator|(
literal|4
operator|*
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|-
name|bestLength
argument_list|)
operator|)
operator|>
call|(
name|int
call|)
argument_list|(
name|ZSTD_highbit32
argument_list|(
name|current
operator|-
name|matchIndex
operator|+
literal|1
argument_list|)
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offsetPtr
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
name|bestLength
operator|=
name|matchLength
operator|,
operator|*
name|offsetPtr
operator|=
name|ZSTD_REP_MOVE
operator|+
name|current
operator|-
name|matchIndex
expr_stmt|;
if|if
condition|(
name|ip
operator|+
name|matchLength
operator|==
name|iend
condition|)
comment|/* equal : no way to know if inf or sup */
break|break;
comment|/* drop, to guarantee consistency (miss a little bit of compression) */
block|}
if|if
condition|(
name|match
index|[
name|matchLength
index|]
operator|<
name|ip
index|[
name|matchLength
index|]
condition|)
block|{
comment|/* match is smaller than current */
operator|*
name|smallerPtr
operator|=
name|matchIndex
expr_stmt|;
comment|/* update smaller idx */
name|commonLengthSmaller
operator|=
name|matchLength
expr_stmt|;
comment|/* all smaller will now have at least this guaranteed common length */
if|if
condition|(
name|matchIndex
operator|<=
name|btLow
condition|)
block|{
name|smallerPtr
operator|=
operator|&
name|dummy32
expr_stmt|;
break|break;
block|}
comment|/* beyond tree size, stop the search */
name|smallerPtr
operator|=
name|nextPtr
operator|+
literal|1
expr_stmt|;
comment|/* new "smaller" => larger of match */
name|matchIndex
operator|=
name|nextPtr
index|[
literal|1
index|]
expr_stmt|;
comment|/* new matchIndex larger than previous (closer to current) */
block|}
else|else
block|{
comment|/* match is larger than current */
operator|*
name|largerPtr
operator|=
name|matchIndex
expr_stmt|;
name|commonLengthLarger
operator|=
name|matchLength
expr_stmt|;
if|if
condition|(
name|matchIndex
operator|<=
name|btLow
condition|)
block|{
name|largerPtr
operator|=
operator|&
name|dummy32
expr_stmt|;
break|break;
block|}
comment|/* beyond tree size, stop the search */
name|largerPtr
operator|=
name|nextPtr
expr_stmt|;
name|matchIndex
operator|=
name|nextPtr
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
operator|*
name|smallerPtr
operator|=
operator|*
name|largerPtr
operator|=
literal|0
expr_stmt|;
name|zc
operator|->
name|nextToUpdate
operator|=
operator|(
name|matchEndIdx
operator|>
name|current
operator|+
literal|8
operator|)
condition|?
name|matchEndIdx
operator|-
literal|8
else|:
name|current
operator|+
literal|1
expr_stmt|;
return|return
name|bestLength
return|;
block|}
end_function

begin_function
name|void
name|ZSTD_updateTree
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
parameter_list|,
specifier|const
name|U32
name|nbCompares
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|zc
operator|->
name|base
decl_stmt|;
specifier|const
name|U32
name|target
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
name|U32
name|idx
init|=
name|zc
operator|->
name|nextToUpdate
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|target
condition|)
name|idx
operator|+=
name|ZSTD_insertBt1
argument_list|(
name|zc
argument_list|,
name|base
operator|+
name|idx
argument_list|,
name|mls
argument_list|,
name|iend
argument_list|,
name|nbCompares
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** ZSTD_BtFindBestMatch() : Tree updater, providing best match */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_BtFindBestMatch
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|<
name|zc
operator|->
name|base
operator|+
name|zc
operator|->
name|nextToUpdate
condition|)
return|return
literal|0
return|;
comment|/* skipped area */
name|ZSTD_updateTree
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|maxNbAttempts
argument_list|,
name|mls
argument_list|)
expr_stmt|;
return|return
name|ZSTD_insertBtAndFindBestMatch
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
name|mls
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_BtFindBestMatch_selectMLS
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
comment|/* Index table will be updated */
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|matchLengthSearch
parameter_list|)
block|{
switch|switch
condition|(
name|matchLengthSearch
condition|)
block|{
default|default :
comment|/* includes case 3 */
case|case
literal|4
case|:
return|return
name|ZSTD_BtFindBestMatch
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|4
argument_list|)
return|;
case|case
literal|5
case|:
return|return
name|ZSTD_BtFindBestMatch
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|5
argument_list|)
return|;
case|case
literal|7
case|:
case|case
literal|6
case|:
return|return
name|ZSTD_BtFindBestMatch
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|6
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|ZSTD_updateTree_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
parameter_list|,
specifier|const
name|U32
name|nbCompares
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|zc
operator|->
name|base
decl_stmt|;
specifier|const
name|U32
name|target
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
name|U32
name|idx
init|=
name|zc
operator|->
name|nextToUpdate
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|target
condition|)
name|idx
operator|+=
name|ZSTD_insertBt1
argument_list|(
name|zc
argument_list|,
name|base
operator|+
name|idx
argument_list|,
name|mls
argument_list|,
name|iend
argument_list|,
name|nbCompares
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Tree updater, providing best match */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_BtFindBestMatch_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|<
name|zc
operator|->
name|base
operator|+
name|zc
operator|->
name|nextToUpdate
condition|)
return|return
literal|0
return|;
comment|/* skipped area */
name|ZSTD_updateTree_extDict
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|maxNbAttempts
argument_list|,
name|mls
argument_list|)
expr_stmt|;
return|return
name|ZSTD_insertBtAndFindBestMatch
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
name|mls
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_BtFindBestMatch_selectMLS_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
comment|/* Index table will be updated */
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|matchLengthSearch
parameter_list|)
block|{
switch|switch
condition|(
name|matchLengthSearch
condition|)
block|{
default|default :
comment|/* includes case 3 */
case|case
literal|4
case|:
return|return
name|ZSTD_BtFindBestMatch_extDict
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|4
argument_list|)
return|;
case|case
literal|5
case|:
return|return
name|ZSTD_BtFindBestMatch_extDict
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|5
argument_list|)
return|;
case|case
literal|7
case|:
case|case
literal|6
case|:
return|return
name|ZSTD_BtFindBestMatch_extDict
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|6
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************* *  Hash Chain ***********************************/
end_comment

begin_define
define|#
directive|define
name|NEXT_IN_CHAIN
parameter_list|(
name|d
parameter_list|,
name|mask
parameter_list|)
value|chainTable[(d)& mask]
end_define

begin_comment
comment|/* Update chains up to ip (excluded)    Assumption : always within prefix (i.e. not within extDict) */
end_comment

begin_function
name|U32
name|ZSTD_insertAndFindFirstIndex
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
name|U32
name|mls
parameter_list|)
block|{
name|U32
modifier|*
specifier|const
name|hashTable
init|=
name|zc
operator|->
name|hashTable
decl_stmt|;
specifier|const
name|U32
name|hashLog
init|=
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|hashLog
decl_stmt|;
name|U32
modifier|*
specifier|const
name|chainTable
init|=
name|zc
operator|->
name|chainTable
decl_stmt|;
specifier|const
name|U32
name|chainMask
init|=
operator|(
literal|1
operator|<<
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|chainLog
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|zc
operator|->
name|base
decl_stmt|;
specifier|const
name|U32
name|target
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
name|U32
name|idx
init|=
name|zc
operator|->
name|nextToUpdate
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|target
condition|)
block|{
comment|/* catch up */
name|size_t
specifier|const
name|h
init|=
name|ZSTD_hashPtr
argument_list|(
name|base
operator|+
name|idx
argument_list|,
name|hashLog
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|NEXT_IN_CHAIN
argument_list|(
name|idx
argument_list|,
name|chainMask
argument_list|)
operator|=
name|hashTable
index|[
name|h
index|]
expr_stmt|;
name|hashTable
index|[
name|h
index|]
operator|=
name|idx
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|zc
operator|->
name|nextToUpdate
operator|=
name|target
expr_stmt|;
return|return
name|hashTable
index|[
name|ZSTD_hashPtr
argument_list|(
name|ip
argument_list|,
name|hashLog
argument_list|,
name|mls
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* inlining is important to hardwire a hot branch (template emulation) */
end_comment

begin_function
name|FORCE_INLINE_TEMPLATE
name|size_t
name|ZSTD_HcFindBestMatch_generic
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
comment|/* Index table will be updated */
specifier|const
name|BYTE
modifier|*
specifier|const
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|mls
parameter_list|,
specifier|const
name|U32
name|extDict
parameter_list|)
block|{
name|U32
modifier|*
specifier|const
name|chainTable
init|=
name|zc
operator|->
name|chainTable
decl_stmt|;
specifier|const
name|U32
name|chainSize
init|=
operator|(
literal|1
operator|<<
name|zc
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|chainLog
operator|)
decl_stmt|;
specifier|const
name|U32
name|chainMask
init|=
name|chainSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|zc
operator|->
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictBase
init|=
name|zc
operator|->
name|dictBase
decl_stmt|;
specifier|const
name|U32
name|dictLimit
init|=
name|zc
operator|->
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|prefixStart
init|=
name|base
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictBase
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|U32
name|lowLimit
init|=
name|zc
operator|->
name|lowLimit
decl_stmt|;
specifier|const
name|U32
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
specifier|const
name|U32
name|minChain
init|=
name|current
operator|>
name|chainSize
condition|?
name|current
operator|-
name|chainSize
else|:
literal|0
decl_stmt|;
name|int
name|nbAttempts
init|=
name|maxNbAttempts
decl_stmt|;
name|size_t
name|ml
init|=
literal|4
operator|-
literal|1
decl_stmt|;
comment|/* HC4 match finder */
name|U32
name|matchIndex
init|=
name|ZSTD_insertAndFindFirstIndex
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|mls
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|(
name|matchIndex
operator|>
name|lowLimit
operator|)
operator|&
operator|(
name|nbAttempts
operator|>
literal|0
operator|)
condition|;
name|nbAttempts
operator|--
control|)
block|{
specifier|const
name|BYTE
modifier|*
name|match
decl_stmt|;
name|size_t
name|currentMl
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|extDict
operator|)
operator|||
name|matchIndex
operator|>=
name|dictLimit
condition|)
block|{
name|match
operator|=
name|base
operator|+
name|matchIndex
expr_stmt|;
if|if
condition|(
name|match
index|[
name|ml
index|]
operator|==
name|ip
index|[
name|ml
index|]
condition|)
comment|/* potentially better */
name|currentMl
operator|=
name|ZSTD_count
argument_list|(
name|ip
argument_list|,
name|match
argument_list|,
name|iLimit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|match
operator|=
name|dictBase
operator|+
name|matchIndex
expr_stmt|;
if|if
condition|(
name|MEM_read32
argument_list|(
name|match
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
argument_list|)
condition|)
comment|/* assumption : matchIndex<= dictLimit-4 (by table construction) */
name|currentMl
operator|=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|match
operator|+
literal|4
argument_list|,
name|iLimit
argument_list|,
name|dictEnd
argument_list|,
name|prefixStart
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
comment|/* save best solution */
if|if
condition|(
name|currentMl
operator|>
name|ml
condition|)
block|{
name|ml
operator|=
name|currentMl
expr_stmt|;
operator|*
name|offsetPtr
operator|=
name|current
operator|-
name|matchIndex
operator|+
name|ZSTD_REP_MOVE
expr_stmt|;
if|if
condition|(
name|ip
operator|+
name|currentMl
operator|==
name|iLimit
condition|)
break|break;
comment|/* best possible, avoids read overflow on next attempt */
block|}
if|if
condition|(
name|matchIndex
operator|<=
name|minChain
condition|)
break|break;
name|matchIndex
operator|=
name|NEXT_IN_CHAIN
argument_list|(
name|matchIndex
argument_list|,
name|chainMask
argument_list|)
expr_stmt|;
block|}
return|return
name|ml
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|size_t
name|ZSTD_HcFindBestMatch_selectMLS
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|matchLengthSearch
parameter_list|)
block|{
switch|switch
condition|(
name|matchLengthSearch
condition|)
block|{
default|default :
comment|/* includes case 3 */
case|case
literal|4
case|:
return|return
name|ZSTD_HcFindBestMatch_generic
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|5
case|:
return|return
name|ZSTD_HcFindBestMatch_generic
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|7
case|:
case|case
literal|6
case|:
return|return
name|ZSTD_HcFindBestMatch_generic
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|size_t
name|ZSTD_HcFindBestMatch_extDict_selectMLS
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
specifier|const
name|U32
name|maxNbAttempts
parameter_list|,
specifier|const
name|U32
name|matchLengthSearch
parameter_list|)
block|{
switch|switch
condition|(
name|matchLengthSearch
condition|)
block|{
default|default :
comment|/* includes case 3 */
case|case
literal|4
case|:
return|return
name|ZSTD_HcFindBestMatch_generic
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
return|;
case|case
literal|5
case|:
return|return
name|ZSTD_HcFindBestMatch_generic
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
return|;
case|case
literal|7
case|:
case|case
literal|6
case|:
return|return
name|ZSTD_HcFindBestMatch_generic
argument_list|(
name|zc
argument_list|,
name|ip
argument_list|,
name|iLimit
argument_list|,
name|offsetPtr
argument_list|,
name|maxNbAttempts
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ******************************* *  Common parser - lazy strategy *********************************/
end_comment

begin_function
name|FORCE_INLINE_TEMPLATE
name|size_t
name|ZSTD_compressBlock_lazy_generic
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|U32
name|searchMethod
parameter_list|,
specifier|const
name|U32
name|depth
parameter_list|)
block|{
name|seqStore_t
modifier|*
name|seqStorePtr
init|=
operator|&
operator|(
name|ctx
operator|->
name|seqStore
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|anchor
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ilimit
init|=
name|iend
operator|-
literal|8
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|ctx
operator|->
name|base
operator|+
name|ctx
operator|->
name|dictLimit
decl_stmt|;
name|U32
specifier|const
name|maxSearches
init|=
literal|1
operator|<<
name|ctx
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|searchLog
decl_stmt|;
name|U32
specifier|const
name|mls
init|=
name|ctx
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|searchLength
decl_stmt|;
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|searchMax_f
function_decl|)
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
name|U32
name|maxNbAttempts
parameter_list|,
name|U32
name|matchLengthSearch
parameter_list|)
function_decl|;
name|searchMax_f
specifier|const
name|searchMax
init|=
name|searchMethod
condition|?
name|ZSTD_BtFindBestMatch_selectMLS
else|:
name|ZSTD_HcFindBestMatch_selectMLS
decl_stmt|;
name|U32
name|offset_1
init|=
name|seqStorePtr
operator|->
name|rep
index|[
literal|0
index|]
decl_stmt|,
name|offset_2
init|=
name|seqStorePtr
operator|->
name|rep
index|[
literal|1
index|]
decl_stmt|,
name|savedOffset
init|=
literal|0
decl_stmt|;
comment|/* init */
name|ip
operator|+=
operator|(
name|ip
operator|==
name|base
operator|)
expr_stmt|;
name|ctx
operator|->
name|nextToUpdate3
operator|=
name|ctx
operator|->
name|nextToUpdate
expr_stmt|;
block|{
name|U32
specifier|const
name|maxRep
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset_2
operator|>
name|maxRep
condition|)
name|savedOffset
operator|=
name|offset_2
operator|,
name|offset_2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset_1
operator|>
name|maxRep
condition|)
name|savedOffset
operator|=
name|offset_1
operator|,
name|offset_1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Match Loop */
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
name|size_t
name|matchLength
init|=
literal|0
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|start
init|=
name|ip
operator|+
literal|1
decl_stmt|;
comment|/* check repCode */
if|if
condition|(
operator|(
name|offset_1
operator|>
literal|0
operator|)
operator|&
operator|(
name|MEM_read32
argument_list|(
name|ip
operator|+
literal|1
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
operator|+
literal|1
operator|-
name|offset_1
argument_list|)
operator|)
condition|)
block|{
comment|/* repcode : we take it */
name|matchLength
operator|=
name|ZSTD_count
argument_list|(
name|ip
operator|+
literal|1
operator|+
literal|4
argument_list|,
name|ip
operator|+
literal|1
operator|+
literal|4
operator|-
name|offset_1
argument_list|,
name|iend
argument_list|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
goto|goto
name|_storeSequence
goto|;
block|}
comment|/* first search (depth 0) */
block|{
name|size_t
name|offsetFound
init|=
literal|99999999
decl_stmt|;
name|size_t
specifier|const
name|ml2
init|=
name|searchMax
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|iend
argument_list|,
operator|&
name|offsetFound
argument_list|,
name|maxSearches
argument_list|,
name|mls
argument_list|)
decl_stmt|;
if|if
condition|(
name|ml2
operator|>
name|matchLength
condition|)
name|matchLength
operator|=
name|ml2
operator|,
name|start
operator|=
name|ip
operator|,
name|offset
operator|=
name|offsetFound
expr_stmt|;
block|}
if|if
condition|(
name|matchLength
operator|<
literal|4
condition|)
block|{
name|ip
operator|+=
operator|(
operator|(
name|ip
operator|-
name|anchor
operator|)
operator|>>
name|g_searchStrength
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* jump faster over incompressible sections */
continue|continue;
block|}
comment|/* let's try to find a better solution */
if|if
condition|(
name|depth
operator|>=
literal|1
condition|)
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|)
operator|&&
operator|(
operator|(
name|offset_1
operator|>
literal|0
operator|)
operator|&
operator|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
operator|-
name|offset_1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|size_t
specifier|const
name|mlRep
init|=
name|ZSTD_count
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|ip
operator|+
literal|4
operator|-
name|offset_1
argument_list|,
name|iend
argument_list|)
operator|+
literal|4
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|mlRep
operator|*
literal|3
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|3
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mlRep
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
name|matchLength
operator|=
name|mlRep
operator|,
name|offset
operator|=
literal|0
operator|,
name|start
operator|=
name|ip
expr_stmt|;
block|}
block|{
name|size_t
name|offset2
init|=
literal|99999999
decl_stmt|;
name|size_t
specifier|const
name|ml2
init|=
name|searchMax
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|iend
argument_list|,
operator|&
name|offset2
argument_list|,
name|maxSearches
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|ml2
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset2
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* raw approx */
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ml2
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
block|{
name|matchLength
operator|=
name|ml2
operator|,
name|offset
operator|=
name|offset2
operator|,
name|start
operator|=
name|ip
expr_stmt|;
continue|continue;
comment|/* search a better one */
block|}
block|}
comment|/* let's find an even better one */
if|if
condition|(
operator|(
name|depth
operator|==
literal|2
operator|)
operator|&&
operator|(
name|ip
operator|<
name|ilimit
operator|)
condition|)
block|{
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|)
operator|&&
operator|(
operator|(
name|offset_1
operator|>
literal|0
operator|)
operator|&
operator|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
operator|-
name|offset_1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|size_t
specifier|const
name|ml2
init|=
name|ZSTD_count
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|ip
operator|+
literal|4
operator|-
name|offset_1
argument_list|,
name|iend
argument_list|)
operator|+
literal|4
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|ml2
operator|*
literal|4
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ml2
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
name|matchLength
operator|=
name|ml2
operator|,
name|offset
operator|=
literal|0
operator|,
name|start
operator|=
name|ip
expr_stmt|;
block|}
block|{
name|size_t
name|offset2
init|=
literal|99999999
decl_stmt|;
name|size_t
specifier|const
name|ml2
init|=
name|searchMax
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|iend
argument_list|,
operator|&
name|offset2
argument_list|,
name|maxSearches
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|ml2
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset2
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* raw approx */
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|7
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ml2
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
block|{
name|matchLength
operator|=
name|ml2
operator|,
name|offset
operator|=
name|offset2
operator|,
name|start
operator|=
name|ip
expr_stmt|;
continue|continue;
block|}
block|}
block|}
break|break;
comment|/* nothing found : store previous solution */
block|}
comment|/* NOTE:          * start[-offset+ZSTD_REP_MOVE-1] is undefined behavior.          * (-offset+ZSTD_REP_MOVE-1) is unsigned, and is added to start, which          * overflows the pointer, which is undefined behavior.          */
comment|/* catch up */
if|if
condition|(
name|offset
condition|)
block|{
while|while
condition|(
operator|(
name|start
operator|>
name|anchor
operator|)
operator|&&
operator|(
name|start
operator|>
name|base
operator|+
name|offset
operator|-
name|ZSTD_REP_MOVE
operator|)
operator|&&
operator|(
name|start
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|start
operator|-
name|offset
operator|+
name|ZSTD_REP_MOVE
operator|)
index|[
operator|-
literal|1
index|]
operator|)
condition|)
comment|/* only search for offset within prefix */
block|{
name|start
operator|--
expr_stmt|;
name|matchLength
operator|++
expr_stmt|;
block|}
name|offset_2
operator|=
name|offset_1
expr_stmt|;
name|offset_1
operator|=
call|(
name|U32
call|)
argument_list|(
name|offset
operator|-
name|ZSTD_REP_MOVE
argument_list|)
expr_stmt|;
block|}
comment|/* store sequence */
name|_storeSequence
label|:
block|{
name|size_t
specifier|const
name|litLength
init|=
name|start
operator|-
name|anchor
decl_stmt|;
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
name|litLength
argument_list|,
name|anchor
argument_list|,
operator|(
name|U32
operator|)
name|offset
argument_list|,
name|matchLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|ip
operator|=
name|start
operator|+
name|matchLength
expr_stmt|;
block|}
comment|/* check immediate repcode */
while|while
condition|(
operator|(
name|ip
operator|<=
name|ilimit
operator|)
operator|&&
operator|(
operator|(
name|offset_2
operator|>
literal|0
operator|)
operator|&
operator|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|ip
operator|-
name|offset_2
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* store sequence */
name|matchLength
operator|=
name|ZSTD_count
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|ip
operator|+
literal|4
operator|-
name|offset_2
argument_list|,
name|iend
argument_list|)
operator|+
literal|4
expr_stmt|;
name|offset
operator|=
name|offset_2
expr_stmt|;
name|offset_2
operator|=
name|offset_1
expr_stmt|;
name|offset_1
operator|=
operator|(
name|U32
operator|)
name|offset
expr_stmt|;
comment|/* swap repcodes */
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
literal|0
argument_list|,
name|anchor
argument_list|,
literal|0
argument_list|,
name|matchLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|matchLength
expr_stmt|;
name|anchor
operator|=
name|ip
expr_stmt|;
continue|continue;
comment|/* faster when present ... (?) */
block|}
block|}
comment|/* Save reps for next block */
name|seqStorePtr
operator|->
name|repToConfirm
index|[
literal|0
index|]
operator|=
name|offset_1
condition|?
name|offset_1
else|:
name|savedOffset
expr_stmt|;
name|seqStorePtr
operator|->
name|repToConfirm
index|[
literal|1
index|]
operator|=
name|offset_2
condition|?
name|offset_2
else|:
name|savedOffset
expr_stmt|;
comment|/* Return the last literals size */
return|return
name|iend
operator|-
name|anchor
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_btlazy2
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_lazy2
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_lazy
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_greedy
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|size_t
name|ZSTD_compressBlock_lazy_extDict_generic
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|U32
name|searchMethod
parameter_list|,
specifier|const
name|U32
name|depth
parameter_list|)
block|{
name|seqStore_t
modifier|*
name|seqStorePtr
init|=
operator|&
operator|(
name|ctx
operator|->
name|seqStore
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|anchor
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ilimit
init|=
name|iend
operator|-
literal|8
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|ctx
operator|->
name|base
decl_stmt|;
specifier|const
name|U32
name|dictLimit
init|=
name|ctx
operator|->
name|dictLimit
decl_stmt|;
specifier|const
name|U32
name|lowestIndex
init|=
name|ctx
operator|->
name|lowLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|prefixStart
init|=
name|base
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictBase
init|=
name|ctx
operator|->
name|dictBase
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictBase
operator|+
name|dictLimit
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictStart
init|=
name|dictBase
operator|+
name|ctx
operator|->
name|lowLimit
decl_stmt|;
specifier|const
name|U32
name|maxSearches
init|=
literal|1
operator|<<
name|ctx
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|searchLog
decl_stmt|;
specifier|const
name|U32
name|mls
init|=
name|ctx
operator|->
name|appliedParams
operator|.
name|cParams
operator|.
name|searchLength
decl_stmt|;
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|searchMax_f
function_decl|)
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|ip
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|iLimit
parameter_list|,
name|size_t
modifier|*
name|offsetPtr
parameter_list|,
name|U32
name|maxNbAttempts
parameter_list|,
name|U32
name|matchLengthSearch
parameter_list|)
function_decl|;
name|searchMax_f
name|searchMax
init|=
name|searchMethod
condition|?
name|ZSTD_BtFindBestMatch_selectMLS_extDict
else|:
name|ZSTD_HcFindBestMatch_extDict_selectMLS
decl_stmt|;
name|U32
name|offset_1
init|=
name|seqStorePtr
operator|->
name|rep
index|[
literal|0
index|]
decl_stmt|,
name|offset_2
init|=
name|seqStorePtr
operator|->
name|rep
index|[
literal|1
index|]
decl_stmt|;
comment|/* init */
name|ctx
operator|->
name|nextToUpdate3
operator|=
name|ctx
operator|->
name|nextToUpdate
expr_stmt|;
name|ip
operator|+=
operator|(
name|ip
operator|==
name|prefixStart
operator|)
expr_stmt|;
comment|/* Match Loop */
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
name|size_t
name|matchLength
init|=
literal|0
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|start
init|=
name|ip
operator|+
literal|1
decl_stmt|;
name|U32
name|current
init|=
call|(
name|U32
call|)
argument_list|(
name|ip
operator|-
name|base
argument_list|)
decl_stmt|;
comment|/* check repCode */
block|{
specifier|const
name|U32
name|repIndex
init|=
call|(
name|U32
call|)
argument_list|(
name|current
operator|+
literal|1
operator|-
name|offset_1
argument_list|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repBase
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictBase
else|:
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repMatch
init|=
name|repBase
operator|+
name|repIndex
decl_stmt|;
if|if
condition|(
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|dictLimit
operator|-
literal|1
operator|)
operator|-
name|repIndex
argument_list|)
operator|>=
literal|3
operator|)
operator|&
operator|(
name|repIndex
operator|>
name|lowestIndex
operator|)
condition|)
comment|/* intentional overflow */
if|if
condition|(
name|MEM_read32
argument_list|(
name|ip
operator|+
literal|1
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|repMatch
argument_list|)
condition|)
block|{
comment|/* repcode detected we should take it */
specifier|const
name|BYTE
modifier|*
specifier|const
name|repEnd
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictEnd
else|:
name|iend
decl_stmt|;
name|matchLength
operator|=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
literal|1
operator|+
literal|4
argument_list|,
name|repMatch
operator|+
literal|4
argument_list|,
name|iend
argument_list|,
name|repEnd
argument_list|,
name|prefixStart
argument_list|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
goto|goto
name|_storeSequence
goto|;
block|}
block|}
comment|/* first search (depth 0) */
block|{
name|size_t
name|offsetFound
init|=
literal|99999999
decl_stmt|;
name|size_t
specifier|const
name|ml2
init|=
name|searchMax
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|iend
argument_list|,
operator|&
name|offsetFound
argument_list|,
name|maxSearches
argument_list|,
name|mls
argument_list|)
decl_stmt|;
if|if
condition|(
name|ml2
operator|>
name|matchLength
condition|)
name|matchLength
operator|=
name|ml2
operator|,
name|start
operator|=
name|ip
operator|,
name|offset
operator|=
name|offsetFound
expr_stmt|;
block|}
if|if
condition|(
name|matchLength
operator|<
literal|4
condition|)
block|{
name|ip
operator|+=
operator|(
operator|(
name|ip
operator|-
name|anchor
operator|)
operator|>>
name|g_searchStrength
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* jump faster over incompressible sections */
continue|continue;
block|}
comment|/* let's try to find a better solution */
if|if
condition|(
name|depth
operator|>=
literal|1
condition|)
while|while
condition|(
name|ip
operator|<
name|ilimit
condition|)
block|{
name|ip
operator|++
expr_stmt|;
name|current
operator|++
expr_stmt|;
comment|/* check repCode */
if|if
condition|(
name|offset
condition|)
block|{
specifier|const
name|U32
name|repIndex
init|=
call|(
name|U32
call|)
argument_list|(
name|current
operator|-
name|offset_1
argument_list|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repBase
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictBase
else|:
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repMatch
init|=
name|repBase
operator|+
name|repIndex
decl_stmt|;
if|if
condition|(
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|dictLimit
operator|-
literal|1
operator|)
operator|-
name|repIndex
argument_list|)
operator|>=
literal|3
operator|)
operator|&
operator|(
name|repIndex
operator|>
name|lowestIndex
operator|)
condition|)
comment|/* intentional overflow */
if|if
condition|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|repMatch
argument_list|)
condition|)
block|{
comment|/* repcode detected */
specifier|const
name|BYTE
modifier|*
specifier|const
name|repEnd
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictEnd
else|:
name|iend
decl_stmt|;
name|size_t
specifier|const
name|repLength
init|=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|repMatch
operator|+
literal|4
argument_list|,
name|iend
argument_list|,
name|repEnd
argument_list|,
name|prefixStart
argument_list|)
operator|+
literal|4
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|repLength
operator|*
literal|3
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|3
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|repLength
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
name|matchLength
operator|=
name|repLength
operator|,
name|offset
operator|=
literal|0
operator|,
name|start
operator|=
name|ip
expr_stmt|;
block|}
block|}
comment|/* search match, depth 1 */
block|{
name|size_t
name|offset2
init|=
literal|99999999
decl_stmt|;
name|size_t
specifier|const
name|ml2
init|=
name|searchMax
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|iend
argument_list|,
operator|&
name|offset2
argument_list|,
name|maxSearches
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|ml2
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset2
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* raw approx */
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ml2
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
block|{
name|matchLength
operator|=
name|ml2
operator|,
name|offset
operator|=
name|offset2
operator|,
name|start
operator|=
name|ip
expr_stmt|;
continue|continue;
comment|/* search a better one */
block|}
block|}
comment|/* let's find an even better one */
if|if
condition|(
operator|(
name|depth
operator|==
literal|2
operator|)
operator|&&
operator|(
name|ip
operator|<
name|ilimit
operator|)
condition|)
block|{
name|ip
operator|++
expr_stmt|;
name|current
operator|++
expr_stmt|;
comment|/* check repCode */
if|if
condition|(
name|offset
condition|)
block|{
specifier|const
name|U32
name|repIndex
init|=
call|(
name|U32
call|)
argument_list|(
name|current
operator|-
name|offset_1
argument_list|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repBase
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictBase
else|:
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repMatch
init|=
name|repBase
operator|+
name|repIndex
decl_stmt|;
if|if
condition|(
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|dictLimit
operator|-
literal|1
operator|)
operator|-
name|repIndex
argument_list|)
operator|>=
literal|3
operator|)
operator|&
operator|(
name|repIndex
operator|>
name|lowestIndex
operator|)
condition|)
comment|/* intentional overflow */
if|if
condition|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|repMatch
argument_list|)
condition|)
block|{
comment|/* repcode detected */
specifier|const
name|BYTE
modifier|*
specifier|const
name|repEnd
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictEnd
else|:
name|iend
decl_stmt|;
name|size_t
specifier|const
name|repLength
init|=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|repMatch
operator|+
literal|4
argument_list|,
name|iend
argument_list|,
name|repEnd
argument_list|,
name|prefixStart
argument_list|)
operator|+
literal|4
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|repLength
operator|*
literal|4
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|repLength
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
name|matchLength
operator|=
name|repLength
operator|,
name|offset
operator|=
literal|0
operator|,
name|start
operator|=
name|ip
expr_stmt|;
block|}
block|}
comment|/* search match, depth 2 */
block|{
name|size_t
name|offset2
init|=
literal|99999999
decl_stmt|;
name|size_t
specifier|const
name|ml2
init|=
name|searchMax
argument_list|(
name|ctx
argument_list|,
name|ip
argument_list|,
name|iend
argument_list|,
operator|&
name|offset2
argument_list|,
name|maxSearches
argument_list|,
name|mls
argument_list|)
decl_stmt|;
name|int
specifier|const
name|gain2
init|=
call|(
name|int
call|)
argument_list|(
name|ml2
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset2
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* raw approx */
name|int
specifier|const
name|gain1
init|=
call|(
name|int
call|)
argument_list|(
name|matchLength
operator|*
literal|4
operator|-
name|ZSTD_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|offset
operator|+
literal|1
argument_list|)
operator|+
literal|7
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ml2
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|gain2
operator|>
name|gain1
operator|)
condition|)
block|{
name|matchLength
operator|=
name|ml2
operator|,
name|offset
operator|=
name|offset2
operator|,
name|start
operator|=
name|ip
expr_stmt|;
continue|continue;
block|}
block|}
block|}
break|break;
comment|/* nothing found : store previous solution */
block|}
comment|/* catch up */
if|if
condition|(
name|offset
condition|)
block|{
name|U32
specifier|const
name|matchIndex
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|start
operator|-
name|base
operator|)
operator|-
operator|(
name|offset
operator|-
name|ZSTD_REP_MOVE
operator|)
argument_list|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
operator|(
name|matchIndex
operator|<
name|dictLimit
operator|)
condition|?
name|dictBase
operator|+
name|matchIndex
else|:
name|base
operator|+
name|matchIndex
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|mStart
init|=
operator|(
name|matchIndex
operator|<
name|dictLimit
operator|)
condition|?
name|dictStart
else|:
name|prefixStart
decl_stmt|;
while|while
condition|(
operator|(
name|start
operator|>
name|anchor
operator|)
operator|&&
operator|(
name|match
operator|>
name|mStart
operator|)
operator|&&
operator|(
name|start
index|[
operator|-
literal|1
index|]
operator|==
name|match
index|[
operator|-
literal|1
index|]
operator|)
condition|)
block|{
name|start
operator|--
expr_stmt|;
name|match
operator|--
expr_stmt|;
name|matchLength
operator|++
expr_stmt|;
block|}
comment|/* catch up */
name|offset_2
operator|=
name|offset_1
expr_stmt|;
name|offset_1
operator|=
call|(
name|U32
call|)
argument_list|(
name|offset
operator|-
name|ZSTD_REP_MOVE
argument_list|)
expr_stmt|;
block|}
comment|/* store sequence */
name|_storeSequence
label|:
block|{
name|size_t
specifier|const
name|litLength
init|=
name|start
operator|-
name|anchor
decl_stmt|;
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
name|litLength
argument_list|,
name|anchor
argument_list|,
operator|(
name|U32
operator|)
name|offset
argument_list|,
name|matchLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|ip
operator|=
name|start
operator|+
name|matchLength
expr_stmt|;
block|}
comment|/* check immediate repcode */
while|while
condition|(
name|ip
operator|<=
name|ilimit
condition|)
block|{
specifier|const
name|U32
name|repIndex
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|ip
operator|-
name|base
operator|)
operator|-
name|offset_2
argument_list|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repBase
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictBase
else|:
name|base
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|repMatch
init|=
name|repBase
operator|+
name|repIndex
decl_stmt|;
if|if
condition|(
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|dictLimit
operator|-
literal|1
operator|)
operator|-
name|repIndex
argument_list|)
operator|>=
literal|3
operator|)
operator|&
operator|(
name|repIndex
operator|>
name|lowestIndex
operator|)
condition|)
comment|/* intentional overflow */
if|if
condition|(
name|MEM_read32
argument_list|(
name|ip
argument_list|)
operator|==
name|MEM_read32
argument_list|(
name|repMatch
argument_list|)
condition|)
block|{
comment|/* repcode detected we should take it */
specifier|const
name|BYTE
modifier|*
specifier|const
name|repEnd
init|=
name|repIndex
operator|<
name|dictLimit
condition|?
name|dictEnd
else|:
name|iend
decl_stmt|;
name|matchLength
operator|=
name|ZSTD_count_2segments
argument_list|(
name|ip
operator|+
literal|4
argument_list|,
name|repMatch
operator|+
literal|4
argument_list|,
name|iend
argument_list|,
name|repEnd
argument_list|,
name|prefixStart
argument_list|)
operator|+
literal|4
expr_stmt|;
name|offset
operator|=
name|offset_2
expr_stmt|;
name|offset_2
operator|=
name|offset_1
expr_stmt|;
name|offset_1
operator|=
operator|(
name|U32
operator|)
name|offset
expr_stmt|;
comment|/* swap offset history */
name|ZSTD_storeSeq
argument_list|(
name|seqStorePtr
argument_list|,
literal|0
argument_list|,
name|anchor
argument_list|,
literal|0
argument_list|,
name|matchLength
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|matchLength
expr_stmt|;
name|anchor
operator|=
name|ip
expr_stmt|;
continue|continue;
comment|/* faster when present ... (?) */
block|}
break|break;
block|}
block|}
comment|/* Save reps for next block */
name|seqStorePtr
operator|->
name|repToConfirm
index|[
literal|0
index|]
operator|=
name|offset_1
expr_stmt|;
name|seqStorePtr
operator|->
name|repToConfirm
index|[
literal|1
index|]
operator|=
name|offset_2
expr_stmt|;
comment|/* Return the last literals size */
return|return
name|iend
operator|-
name|anchor
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_greedy_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_extDict_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_lazy_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_extDict_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_lazy2_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_extDict_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_compressBlock_btlazy2_extDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_compressBlock_lazy_extDict_generic
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

end_unit

