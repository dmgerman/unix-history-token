begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    xxHash - Extremely Fast Hash algorithm    Header File    Copyright (C) 2012-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - xxHash source repository : https://github.com/Cyan4973/xxHash */
end_comment

begin_comment
comment|/* Notice extracted from xxHash homepage :  xxHash is an extremely fast Hash algorithm, running at RAM speed limits. It also successfully passes all tests from the SMHasher suite.  Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)  Name            Speed       Q.Score   Author xxHash          5.4 GB/s     10 CrapWow         3.2 GB/s      2       Andrew MumurHash 3a    2.7 GB/s     10       Austin Appleby SpookyHash      2.0 GB/s     10       Bob Jenkins SBox            1.4 GB/s      9       Bret Mulvey Lookup3         1.2 GB/s      9       Bob Jenkins SuperFastHash   1.2 GB/s      1       Paul Hsieh CityHash64      1.05 GB/s    10       Pike& Alakuijala FNV             0.55 GB/s     5       Fowler, Noll, Vo CRC32           0.43 GB/s     9 MD5-32          0.33 GB/s    10       Ronald L. Rivest SHA1-32         0.28 GB/s    10  Q.Score is a measure of quality of the hash function. It depends on successfully passing SMHasher test set. 10 is a perfect score.  A 64-bits version, named XXH64, is available since r35. It offers much better speed, but for 64-bits applications only. Name     Speed on 64 bits    Speed on 32 bits XXH64       13.8 GB/s            1.9 GB/s XXH32        6.8 GB/s            6.0 GB/s */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|XXHASH_H_5627135585666179
define|#
directive|define
name|XXHASH_H_5627135585666179
value|1
comment|/* **************************** *  Definitions ******************************/
include|#
directive|include
file|<stddef.h>
comment|/* size_t */
typedef|typedef
enum|enum
block|{
name|XXH_OK
init|=
literal|0
block|,
name|XXH_ERROR
block|}
name|XXH_errorcode
typedef|;
comment|/* **************************** *  API modifier ******************************/
comment|/** XXH_PRIVATE_API *   This is useful if you want to include xxhash functions in `static` mode *   in order to inline them, and remove their symbol from the public list. *   Methodology : *     #define XXH_PRIVATE_API *     #include "xxhash.h" *   `xxhash.c` is automatically included. *   It's not useful to compile and link it as a separate module anymore. */
ifdef|#
directive|ifdef
name|XXH_PRIVATE_API
ifndef|#
directive|ifndef
name|XXH_STATIC_LINKING_ONLY
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|XXH_PUBLIC_API
value|static __inline __attribute__((unused))
elif|#
directive|elif
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
define|#
directive|define
name|XXH_PUBLIC_API
value|static inline
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|XXH_PUBLIC_API
value|static __inline
else|#
directive|else
define|#
directive|define
name|XXH_PUBLIC_API
value|static
comment|/* this version may generate warnings for unused static functions; disable the relevant warning */
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|XXH_PUBLIC_API
comment|/* do nothing */
endif|#
directive|endif
comment|/* XXH_PRIVATE_API */
comment|/*!XXH_NAMESPACE, aka Namespace Emulation :  If you want to include _and expose_ xxHash functions from within your own library, but also want to avoid symbol collisions with another library which also includes xxHash,  you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library with the value of XXH_NAMESPACE (so avoid to keep it NULL and avoid numeric values).  Note that no change is required within the calling program as long as it includes `xxhash.h` : regular symbol name will be automatically translated by this header. */
ifdef|#
directive|ifdef
name|XXH_NAMESPACE
define|#
directive|define
name|XXH_CAT
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|A##B
define|#
directive|define
name|XXH_NAME2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|XXH_CAT(A,B)
define|#
directive|define
name|XXH32
value|XXH_NAME2(XXH_NAMESPACE, XXH32)
define|#
directive|define
name|XXH64
value|XXH_NAME2(XXH_NAMESPACE, XXH64)
define|#
directive|define
name|XXH_versionNumber
value|XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)
define|#
directive|define
name|XXH32_createState
value|XXH_NAME2(XXH_NAMESPACE, XXH32_createState)
define|#
directive|define
name|XXH64_createState
value|XXH_NAME2(XXH_NAMESPACE, XXH64_createState)
define|#
directive|define
name|XXH32_freeState
value|XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)
define|#
directive|define
name|XXH64_freeState
value|XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)
define|#
directive|define
name|XXH32_reset
value|XXH_NAME2(XXH_NAMESPACE, XXH32_reset)
define|#
directive|define
name|XXH64_reset
value|XXH_NAME2(XXH_NAMESPACE, XXH64_reset)
define|#
directive|define
name|XXH32_update
value|XXH_NAME2(XXH_NAMESPACE, XXH32_update)
define|#
directive|define
name|XXH64_update
value|XXH_NAME2(XXH_NAMESPACE, XXH64_update)
define|#
directive|define
name|XXH32_digest
value|XXH_NAME2(XXH_NAMESPACE, XXH32_digest)
define|#
directive|define
name|XXH64_digest
value|XXH_NAME2(XXH_NAMESPACE, XXH64_digest)
define|#
directive|define
name|XXH32_copyState
value|XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)
define|#
directive|define
name|XXH64_copyState
value|XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)
define|#
directive|define
name|XXH32_canonicalFromHash
value|XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)
define|#
directive|define
name|XXH64_canonicalFromHash
value|XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)
define|#
directive|define
name|XXH32_hashFromCanonical
value|XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)
define|#
directive|define
name|XXH64_hashFromCanonical
value|XXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)
endif|#
directive|endif
comment|/* ************************************* *  Version ***************************************/
define|#
directive|define
name|XXH_VERSION_MAJOR
value|0
define|#
directive|define
name|XXH_VERSION_MINOR
value|6
define|#
directive|define
name|XXH_VERSION_RELEASE
value|2
define|#
directive|define
name|XXH_VERSION_NUMBER
value|(XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
name|XXH_PUBLIC_API
name|unsigned
name|XXH_versionNumber
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* **************************** *  Simple Hash Functions ******************************/
typedef|typedef
name|unsigned
name|int
name|XXH32_hash_t
typedef|;
typedef|typedef
name|unsigned
name|long
name|long
name|XXH64_hash_t
typedef|;
name|XXH_PUBLIC_API
name|XXH32_hash_t
name|XXH32
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|length
parameter_list|,
name|unsigned
name|int
name|seed
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH64_hash_t
name|XXH64
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|length
parameter_list|,
name|unsigned
name|long
name|long
name|seed
parameter_list|)
function_decl|;
comment|/*! XXH32() :     Calculate the 32-bits hash of sequence "length" bytes stored at memory address "input".     The memory between input& input+length must be valid (allocated and read-accessible).     "seed" can be used to alter the result predictably.     Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s XXH64() :     Calculate the 64-bits hash of sequence of length "len" stored at memory address "input".     "seed" can be used to alter the result predictably.     This function runs 2x faster on 64-bits systems, but slower on 32-bits systems (see benchmark). */
comment|/* **************************** *  Streaming Hash Functions ******************************/
typedef|typedef
name|struct
name|XXH32_state_s
name|XXH32_state_t
typedef|;
comment|/* incomplete type */
typedef|typedef
name|struct
name|XXH64_state_s
name|XXH64_state_t
typedef|;
comment|/* incomplete type */
comment|/*! State allocation, compatible with dynamic libraries */
name|XXH_PUBLIC_API
name|XXH32_state_t
modifier|*
name|XXH32_createState
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH32_freeState
parameter_list|(
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH64_state_t
modifier|*
name|XXH64_createState
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH64_freeState
parameter_list|(
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|)
function_decl|;
comment|/* hash streaming */
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH32_reset
parameter_list|(
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|,
name|unsigned
name|int
name|seed
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH32_update
parameter_list|(
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH32_hash_t
name|XXH32_digest
parameter_list|(
specifier|const
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH64_reset
parameter_list|(
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|,
name|unsigned
name|long
name|long
name|seed
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH64_update
parameter_list|(
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH64_hash_t
name|XXH64_digest
parameter_list|(
specifier|const
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|)
function_decl|;
comment|/* These functions generate the xxHash of an input provided in multiple segments. Note that, for small input, they are slower than single-call functions, due to state management. For small input, prefer `XXH32()` and `XXH64()` .  XXH state must first be allocated, using XXH*_createState() .  Start a new hash by initializing state with a seed, using XXH*_reset().  Then, feed the hash state by calling XXH*_update() as many times as necessary. Obviously, input must be allocated and read accessible. The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.  Finally, a hash value can be produced anytime, by using XXH*_digest(). This function returns the nn-bits hash as an int or long long.  It's still possible to continue inserting input into the hash state after a digest, and generate some new hashes later on, by calling again XXH*_digest().  When done, free XXH state space if it was allocated dynamically. */
comment|/* ************************** *  Utils ****************************/
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
operator|)
comment|/* ! C99 */
define|#
directive|define
name|restrict
comment|/* disable restrict */
endif|#
directive|endif
name|XXH_PUBLIC_API
name|void
name|XXH32_copyState
parameter_list|(
name|XXH32_state_t
modifier|*
specifier|restrict
name|dst_state
parameter_list|,
specifier|const
name|XXH32_state_t
modifier|*
specifier|restrict
name|src_state
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|void
name|XXH64_copyState
parameter_list|(
name|XXH64_state_t
modifier|*
specifier|restrict
name|dst_state
parameter_list|,
specifier|const
name|XXH64_state_t
modifier|*
specifier|restrict
name|src_state
parameter_list|)
function_decl|;
comment|/* ************************** *  Canonical representation ****************************/
comment|/* Default result type for XXH functions are primitive unsigned 32 and 64 bits. *  The canonical representation uses human-readable write convention, aka big-endian (large digits first). *  These functions allow transformation of hash result into and from its canonical format. *  This way, hash values can be written into a file / memory, and remain comparable on different systems and programs. */
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|digest
index|[
literal|4
index|]
decl_stmt|;
block|}
name|XXH32_canonical_t
typedef|;
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|digest
index|[
literal|8
index|]
decl_stmt|;
block|}
name|XXH64_canonical_t
typedef|;
name|XXH_PUBLIC_API
name|void
name|XXH32_canonicalFromHash
parameter_list|(
name|XXH32_canonical_t
modifier|*
name|dst
parameter_list|,
name|XXH32_hash_t
name|hash
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|void
name|XXH64_canonicalFromHash
parameter_list|(
name|XXH64_canonical_t
modifier|*
name|dst
parameter_list|,
name|XXH64_hash_t
name|hash
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH32_hash_t
name|XXH32_hashFromCanonical
parameter_list|(
specifier|const
name|XXH32_canonical_t
modifier|*
name|src
parameter_list|)
function_decl|;
name|XXH_PUBLIC_API
name|XXH64_hash_t
name|XXH64_hashFromCanonical
parameter_list|(
specifier|const
name|XXH64_canonical_t
modifier|*
name|src
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* XXHASH_H_5627135585666179 */
comment|/* ================================================================================================    This section contains definitions which are not guaranteed to remain stable.    They may change in future versions, becoming incompatible with a different version of the library.    They shall only be used with static linking.    Never use these definitions in association with dynamic linking ! =================================================================================================== */
if|#
directive|if
name|defined
argument_list|(
name|XXH_STATIC_LINKING_ONLY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XXH_STATIC_H_3543687687345
argument_list|)
define|#
directive|define
name|XXH_STATIC_H_3543687687345
comment|/* These definitions are only meant to allow allocation of XXH state    statically, on stack, or in a struct for example.    Do not use members directly. */
struct|struct
name|XXH32_state_s
block|{
name|unsigned
name|total_len_32
decl_stmt|;
name|unsigned
name|large_len
decl_stmt|;
name|unsigned
name|v1
decl_stmt|;
name|unsigned
name|v2
decl_stmt|;
name|unsigned
name|v3
decl_stmt|;
name|unsigned
name|v4
decl_stmt|;
name|unsigned
name|mem32
index|[
literal|4
index|]
decl_stmt|;
comment|/* buffer defined as U32 for alignment */
name|unsigned
name|memsize
decl_stmt|;
name|unsigned
name|reserved
decl_stmt|;
comment|/* never read nor write, will be removed in a future version */
block|}
struct|;
comment|/* typedef'd to XXH32_state_t */
struct|struct
name|XXH64_state_s
block|{
name|unsigned
name|long
name|long
name|total_len
decl_stmt|;
name|unsigned
name|long
name|long
name|v1
decl_stmt|;
name|unsigned
name|long
name|long
name|v2
decl_stmt|;
name|unsigned
name|long
name|long
name|v3
decl_stmt|;
name|unsigned
name|long
name|long
name|v4
decl_stmt|;
name|unsigned
name|long
name|long
name|mem64
index|[
literal|4
index|]
decl_stmt|;
comment|/* buffer defined as U64 for alignment */
name|unsigned
name|memsize
decl_stmt|;
name|unsigned
name|reserved
index|[
literal|2
index|]
decl_stmt|;
comment|/* never read nor write, will be removed in a future version */
block|}
struct|;
comment|/* typedef'd to XXH64_state_t */
ifdef|#
directive|ifdef
name|XXH_PRIVATE_API
include|#
directive|include
file|"xxhash.c"
comment|/* include xxhash functions as `static`, for inlining */
endif|#
directive|endif
endif|#
directive|endif
comment|/* XXH_STATIC_LINKING_ONLY&& XXH_STATIC_H_3543687687345 */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

end_unit

