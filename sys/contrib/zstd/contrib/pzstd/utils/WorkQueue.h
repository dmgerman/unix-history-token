begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|once
end_pragma

begin_include
include|#
directive|include
file|"utils/Buffer.h"
end_include

begin_include
include|#
directive|include
file|<atomic>
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<condition_variable>
end_include

begin_include
include|#
directive|include
file|<cstddef>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_include
include|#
directive|include
file|<queue>
end_include

begin_decl_stmt
name|namespace
name|pzstd
block|{
comment|/// Unbounded thread-safe work queue.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|WorkQueue
block|{
comment|// Protects all member variable access
name|std
operator|::
name|mutex
name|mutex_
block|;
name|std
operator|::
name|condition_variable
name|readerCv_
block|;
name|std
operator|::
name|condition_variable
name|writerCv_
block|;
name|std
operator|::
name|condition_variable
name|finishCv_
block|;
name|std
operator|::
name|queue
operator|<
name|T
operator|>
name|queue_
block|;
name|bool
name|done_
block|;
name|std
operator|::
name|size_t
name|maxSize_
block|;
comment|// Must have lock to call this function
name|bool
name|full
argument_list|()
specifier|const
block|{
if|if
condition|(
name|maxSize_
operator|==
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|queue_
operator|.
name|size
argument_list|()
operator|>=
name|maxSize_
return|;
block|}
name|public
operator|:
comment|/**    * Constructs an empty work queue with an optional max size.    * If `maxSize == 0` the queue size is unbounded.    *    * @param maxSize The maximum allowed size of the work queue.    */
name|WorkQueue
argument_list|(
argument|std::size_t maxSize =
literal|0
argument_list|)
operator|:
name|done_
argument_list|(
name|false
argument_list|)
block|,
name|maxSize_
argument_list|(
argument|maxSize
argument_list|)
block|{}
comment|/**    * Push an item onto the work queue.  Notify a single thread that work is    * available.  If `finish()` has been called, do nothing and return false.    * If `push()` returns false, then `item` has not been moved from.    *    * @param item  Item to push onto the queue.    * @returns     True upon success, false if `finish()` has been called.  An    *               item was pushed iff `push()` returns true.    */
name|bool
name|push
argument_list|(
argument|T&& item
argument_list|)
block|{
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|mutex_
argument_list|)
block|;
while|while
condition|(
name|full
argument_list|()
operator|&&
operator|!
name|done_
condition|)
block|{
name|writerCv_
operator|.
name|wait
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done_
condition|)
block|{
return|return
name|false
return|;
block|}
name|queue_
operator|.
name|push
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|readerCv_
operator|.
name|notify_one
argument_list|()
block|;
return|return
name|true
return|;
block|}
comment|/**    * Attempts to pop an item off the work queue.  It will block until data is    * available or `finish()` has been called.    *    * @param[out] item  If `pop` returns `true`, it contains the popped item.    *                    If `pop` returns `false`, it is unmodified.    * @returns          True upon success.  False if the queue is empty and    *                    `finish()` has been called.    */
name|bool
name|pop
argument_list|(
argument|T& item
argument_list|)
block|{
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|mutex_
argument_list|)
block|;
while|while
condition|(
name|queue_
operator|.
name|empty
argument_list|()
operator|&&
operator|!
name|done_
condition|)
block|{
name|readerCv_
operator|.
name|wait
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queue_
operator|.
name|empty
argument_list|()
condition|)
block|{
name|assert
argument_list|(
name|done_
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|item
operator|=
name|std
operator|::
name|move
argument_list|(
name|queue_
operator|.
name|front
argument_list|()
argument_list|)
expr_stmt|;
name|queue_
operator|.
name|pop
argument_list|()
block|;     }
name|writerCv_
operator|.
name|notify_one
argument_list|()
block|;
return|return
name|true
return|;
block|}
comment|/**    * Sets the maximum queue size.  If `maxSize == 0` then it is unbounded.    *    * @param maxSize The new maximum queue size.    */
name|void
name|setMaxSize
argument_list|(
name|std
operator|::
name|size_t
name|maxSize
argument_list|)
block|{
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|mutex_
argument_list|)
expr_stmt|;
name|maxSize_
operator|=
name|maxSize
expr_stmt|;
block|}
name|writerCv_
operator|.
name|notify_all
argument_list|()
expr_stmt|;
block|}
comment|/**    * Promise that `push()` won't be called again, so once the queue is empty    * there will never any more work.    */
name|void
name|finish
parameter_list|()
block|{
block|{
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|mutex_
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|done_
argument_list|)
expr_stmt|;
name|done_
operator|=
name|true
expr_stmt|;
block|}
name|readerCv_
operator|.
name|notify_all
argument_list|()
expr_stmt|;
name|writerCv_
operator|.
name|notify_all
argument_list|()
expr_stmt|;
name|finishCv_
operator|.
name|notify_all
argument_list|()
expr_stmt|;
block|}
comment|/// Blocks until `finish()` has been called (but the queue may not be empty).
name|void
name|waitUntilFinished
parameter_list|()
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|mutex_
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done_
condition|)
block|{
name|finishCv_
operator|.
name|wait
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// Work queue for `Buffer`s that knows the total number of bytes in the queue.
end_comment

begin_decl_stmt
name|class
name|BufferWorkQueue
block|{
name|WorkQueue
operator|<
name|Buffer
operator|>
name|queue_
expr_stmt|;
name|std
operator|::
name|atomic
operator|<
name|std
operator|::
name|size_t
operator|>
name|size_
expr_stmt|;
name|public
label|:
name|BufferWorkQueue
argument_list|(
argument|std::size_t maxSize =
literal|0
argument_list|)
block|:
name|queue_
argument_list|(
name|maxSize
argument_list|)
operator|,
name|size_
argument_list|(
literal|0
argument_list|)
block|{}
name|void
name|push
argument_list|(
argument|Buffer buffer
argument_list|)
block|{
name|size_
operator|.
name|fetch_add
argument_list|(
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
block|;
name|queue_
operator|.
name|push
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|buffer
argument_list|)
argument_list|)
block|;   }
name|bool
name|pop
argument_list|(
argument|Buffer& buffer
argument_list|)
block|{
name|bool
name|result
operator|=
name|queue_
operator|.
name|pop
argument_list|(
name|buffer
argument_list|)
block|;
if|if
condition|(
name|result
condition|)
block|{
name|size_
operator|.
name|fetch_sub
argument_list|(
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|void
name|setMaxSize
argument_list|(
name|std
operator|::
name|size_t
name|maxSize
argument_list|)
block|{
name|queue_
operator|.
name|setMaxSize
argument_list|(
name|maxSize
argument_list|)
expr_stmt|;
block|}
name|void
name|finish
parameter_list|()
block|{
name|queue_
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
comment|/**    * Blocks until `finish()` has been called.    *    * @returns The total number of bytes of all the `Buffer`s currently in the    *           queue.    */
name|std
operator|::
name|size_t
name|size
argument_list|()
block|{
name|queue_
operator|.
name|waitUntilFinished
argument_list|()
block|;
return|return
name|size_
operator|.
name|load
argument_list|()
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

unit|}
end_unit

