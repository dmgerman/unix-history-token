begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  * You may select, at your option, one of the above-listed licenses.  */
end_comment

begin_comment
comment|/* ************************************** *  Compiler Warnings ****************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Includes ***************************************/
end_comment

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* Large Files support */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* UTIL_getFileSize, UTIL_getTotalFileSize */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen, ftello64 */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock_t, clock, CLOCKS_PER_SEC */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* errno */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|/* read */
end_comment

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_include
include|#
directive|include
file|"dibio.h"
end_include

begin_comment
comment|/*-************************************* *  Constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|SAMPLESIZE_MAX
value|(128 KB)
end_define

begin_define
define|#
directive|define
name|MEMMULT
value|11
end_define

begin_comment
comment|/* rough estimation : memory cost to analyze 1 byte of sample */
end_comment

begin_define
define|#
directive|define
name|COVER_MEMMULT
value|9
end_define

begin_comment
comment|/* rough estimation : memory cost to analyze 1 byte of sample */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|g_maxMemory
init|=
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
operator|)
condition|?
operator|(
literal|2
name|GB
operator|-
literal|64
name|MB
operator|)
else|:
operator|(
call|(
name|size_t
call|)
argument_list|(
literal|512
name|MB
argument_list|)
operator|<<
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOISELENGTH
value|32
end_define

begin_comment
comment|/*-************************************* *  Console display ***************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (displayLevel>=l) { \             if ((DIB_clockSpan(g_time)> refreshRate) || (displayLevel>=4)) \             { g_time = clock(); DISPLAY(__VA_ARGS__); \             if (displayLevel>=4) fflush(stderr); } }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|2
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|clock_t
name|DIB_clockSpan
parameter_list|(
name|clock_t
name|nPrevious
parameter_list|)
block|{
return|return
name|clock
argument_list|()
operator|-
name|nPrevious
return|;
block|}
end_function

begin_comment
comment|/*-************************************* *  Exceptions ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGOUTPUT
parameter_list|(
modifier|...
parameter_list|)
value|if (DEBUG) DISPLAY(__VA_ARGS__);
end_define

begin_define
define|#
directive|define
name|EXM_THROW
parameter_list|(
name|error
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{                                                                         \     DEBUGOUTPUT("Error defined at %s, line %i : \n", __FILE__, __LINE__); \     DISPLAY("Error %i : ", error);                                        \     DISPLAY(__VA_ARGS__);                                                 \     DISPLAY("\n");                                                        \     exit(error);                                                          \ }
end_define

begin_comment
comment|/* ******************************************************** *  Helper functions **********************************************************/
end_comment

begin_function
name|unsigned
name|DiB_isError
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|DiB_getErrorName
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* ******************************************************** *  File related operations **********************************************************/
end_comment

begin_comment
comment|/** DiB_loadFiles() :  *  load samples from files listed in fileNamesTable into buffer.  *  works even if buffer is too small to load all samples.  *  Also provides the size of each sample into sampleSizes table  *  which must be sized correctly, using DiB_fileStats().  * @return : nb of samples effectively loaded into `buffer`  * *bufferSizePtr is modified, it provides the amount data loaded within buffer.  *  sampleSizes is filled with the size of each sample.  */
end_comment

begin_function
specifier|static
name|unsigned
name|DiB_loadFiles
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|bufferSizePtr
parameter_list|,
name|size_t
modifier|*
name|sampleSizes
parameter_list|,
name|unsigned
name|sstSize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
name|size_t
name|targetChunkSize
parameter_list|,
name|unsigned
name|displayLevel
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|buff
init|=
operator|(
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|unsigned
name|nbLoadedChunks
init|=
literal|0
decl_stmt|,
name|fileIndex
decl_stmt|;
for|for
control|(
name|fileIndex
operator|=
literal|0
init|;
name|fileIndex
operator|<
name|nbFiles
condition|;
name|fileIndex
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|fileName
init|=
name|fileNamesTable
index|[
name|fileIndex
index|]
decl_stmt|;
name|unsigned
name|long
name|long
specifier|const
name|fs64
init|=
name|UTIL_getFileSize
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|long
name|remainingToLoad
init|=
name|fs64
decl_stmt|;
name|U32
specifier|const
name|nbChunks
init|=
name|targetChunkSize
condition|?
call|(
name|U32
call|)
argument_list|(
operator|(
name|fs64
operator|+
operator|(
name|targetChunkSize
operator|-
literal|1
operator|)
operator|)
operator|/
name|targetChunkSize
argument_list|)
else|:
literal|1
decl_stmt|;
name|U64
specifier|const
name|chunkSize
init|=
name|targetChunkSize
condition|?
name|MIN
argument_list|(
name|targetChunkSize
argument_list|,
name|fs64
argument_list|)
else|:
name|fs64
decl_stmt|;
name|size_t
specifier|const
name|maxChunkSize
init|=
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|chunkSize
argument_list|,
name|SAMPLESIZE_MAX
argument_list|)
decl_stmt|;
name|U32
name|cnb
decl_stmt|;
name|FILE
modifier|*
specifier|const
name|f
init|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|10
argument_list|,
literal|"zstd: dictBuilder: %s %s "
argument_list|,
name|fileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"Loading %s...       \r"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
for|for
control|(
name|cnb
operator|=
literal|0
init|;
name|cnb
operator|<
name|nbChunks
condition|;
name|cnb
operator|++
control|)
block|{
name|size_t
specifier|const
name|toLoad
init|=
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|maxChunkSize
argument_list|,
name|remainingToLoad
argument_list|)
decl_stmt|;
if|if
condition|(
name|toLoad
operator|>
operator|*
name|bufferSizePtr
operator|-
name|pos
condition|)
break|break;
block|{
name|size_t
specifier|const
name|readSize
init|=
name|fread
argument_list|(
name|buff
operator|+
name|pos
argument_list|,
literal|1
argument_list|,
name|toLoad
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|readSize
operator|!=
name|toLoad
condition|)
name|EXM_THROW
argument_list|(
literal|11
argument_list|,
literal|"Pb reading %s"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|readSize
expr_stmt|;
name|sampleSizes
index|[
name|nbLoadedChunks
operator|++
index|]
operator|=
name|toLoad
expr_stmt|;
name|remainingToLoad
operator|-=
name|targetChunkSize
expr_stmt|;
if|if
condition|(
name|nbLoadedChunks
operator|==
name|sstSize
condition|)
block|{
comment|/* no more space left in sampleSizes table */
name|fileIndex
operator|=
name|nbFiles
expr_stmt|;
comment|/* stop there */
break|break;
block|}
if|if
condition|(
name|toLoad
operator|<
name|targetChunkSize
condition|)
block|{
name|fseek
argument_list|(
name|f
argument_list|,
call|(
name|long
call|)
argument_list|(
name|targetChunkSize
operator|-
name|toLoad
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|bufferSizePtr
operator|=
name|pos
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"loaded : %u KB \n"
argument_list|,
argument|(U32)(pos>>
literal|10
argument|)
argument_list|)
return|return
name|nbLoadedChunks
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DiB_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_function
specifier|static
name|U32
name|DiB_rand
parameter_list|(
name|U32
modifier|*
name|src
parameter_list|)
block|{
specifier|static
specifier|const
name|U32
name|prime1
init|=
literal|2654435761U
decl_stmt|;
specifier|static
specifier|const
name|U32
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|U32
name|rand32
init|=
operator|*
name|src
decl_stmt|;
name|rand32
operator|*=
name|prime1
expr_stmt|;
name|rand32
operator|^=
name|prime2
expr_stmt|;
name|rand32
operator|=
name|DiB_rotl32
argument_list|(
name|rand32
argument_list|,
literal|13
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|rand32
expr_stmt|;
return|return
name|rand32
operator|>>
literal|5
return|;
block|}
end_function

begin_comment
comment|/* DiB_shuffle() :  * shuffle a table of file names in a semi-random way  * It improves dictionary quality by reducing "locality" impact, so if sample set is very large,  * it will load random elements from it, instead of just the first ones. */
end_comment

begin_function
specifier|static
name|void
name|DiB_shuffle
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|U32
name|seed
init|=
literal|0xFD2FB528
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nbFiles
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unsigned
specifier|const
name|j
init|=
name|DiB_rand
argument_list|(
operator|&
name|seed
argument_list|)
operator|%
operator|(
name|i
operator|+
literal|1
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|tmp
init|=
name|fileNamesTable
index|[
name|j
index|]
decl_stmt|;
name|fileNamesTable
index|[
name|j
index|]
operator|=
name|fileNamesTable
index|[
name|i
index|]
expr_stmt|;
name|fileNamesTable
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-******************************************************** *  Dictionary training functions **********************************************************/
end_comment

begin_function
specifier|static
name|size_t
name|DiB_findMaxMem
parameter_list|(
name|unsigned
name|long
name|long
name|requiredMem
parameter_list|)
block|{
name|size_t
specifier|const
name|step
init|=
literal|8
name|MB
decl_stmt|;
name|void
modifier|*
name|testmem
init|=
name|NULL
decl_stmt|;
name|requiredMem
operator|=
operator|(
operator|(
operator|(
name|requiredMem
operator|>>
literal|23
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|23
operator|)
expr_stmt|;
name|requiredMem
operator|+=
name|step
expr_stmt|;
if|if
condition|(
name|requiredMem
operator|>
name|g_maxMemory
condition|)
name|requiredMem
operator|=
name|g_maxMemory
expr_stmt|;
while|while
condition|(
operator|!
name|testmem
condition|)
block|{
name|testmem
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|requiredMem
argument_list|)
expr_stmt|;
name|requiredMem
operator|-=
name|step
expr_stmt|;
block|}
name|free
argument_list|(
name|testmem
argument_list|)
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|requiredMem
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DiB_fillNoise
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|unsigned
specifier|const
name|prime1
init|=
literal|2654435761U
decl_stmt|;
name|unsigned
specifier|const
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|unsigned
name|acc
init|=
name|prime1
decl_stmt|;
name|size_t
name|p
init|=
literal|0
decl_stmt|;
empty_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|length
condition|;
name|p
operator|++
control|)
block|{
name|acc
operator|*=
name|prime2
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
operator|)
index|[
name|p
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|acc
operator|>>
literal|21
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|DiB_saveDict
parameter_list|(
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|buffSize
parameter_list|)
block|{
name|FILE
modifier|*
specifier|const
name|f
init|=
name|fopen
argument_list|(
name|dictFileName
argument_list|,
literal|"wb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|3
argument_list|,
literal|"cannot open %s "
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|n
init|=
name|fwrite
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|buffSize
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|buffSize
condition|)
name|EXM_THROW
argument_list|(
literal|4
argument_list|,
literal|"%s : write error"
argument_list|,
argument|dictFileName
argument_list|)
block|}
block|{
name|size_t
specifier|const
name|n
init|=
operator|(
name|size_t
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|5
argument_list|,
literal|"%s : flush error"
argument_list|,
argument|dictFileName
argument_list|)
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|U64
name|totalSizeToLoad
decl_stmt|;
name|unsigned
name|oneSampleTooLarge
decl_stmt|;
name|unsigned
name|nbSamples
decl_stmt|;
block|}
name|fileStats
typedef|;
end_typedef

begin_comment
comment|/*! DiB_fileStats() :  *  Given a list of files, and a chunkSize (0 == no chunk, whole files)  *  provides the amount of data to be loaded and the resulting nb of samples.  *  This is useful primarily for allocation purpose => sample buffer, and sample sizes table.  */
end_comment

begin_function
specifier|static
name|fileStats
name|DiB_fileStats
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
name|size_t
name|chunkSize
parameter_list|,
name|unsigned
name|displayLevel
parameter_list|)
block|{
name|fileStats
name|fs
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbFiles
condition|;
name|n
operator|++
control|)
block|{
name|U64
specifier|const
name|fileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|nbSamples
init|=
call|(
name|U32
call|)
argument_list|(
name|chunkSize
condition|?
operator|(
name|fileSize
operator|+
operator|(
name|chunkSize
operator|-
literal|1
operator|)
operator|)
operator|/
name|chunkSize
else|:
literal|1
argument_list|)
decl_stmt|;
name|U64
specifier|const
name|chunkToLoad
init|=
name|chunkSize
condition|?
name|MIN
argument_list|(
name|chunkSize
argument_list|,
name|fileSize
argument_list|)
else|:
name|fileSize
decl_stmt|;
name|size_t
specifier|const
name|cappedChunkSize
init|=
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|chunkToLoad
argument_list|,
name|SAMPLESIZE_MAX
argument_list|)
decl_stmt|;
name|fs
operator|.
name|totalSizeToLoad
operator|+=
name|cappedChunkSize
operator|*
name|nbSamples
expr_stmt|;
name|fs
operator|.
name|oneSampleTooLarge
operator||=
operator|(
name|chunkSize
operator|>
literal|2
operator|*
name|SAMPLESIZE_MAX
operator|)
expr_stmt|;
name|fs
operator|.
name|nbSamples
operator|+=
name|nbSamples
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Preparing to load : %u KB \n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|fs
operator|.
name|totalSizeToLoad
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
end_function

begin_comment
comment|/*! ZDICT_trainFromBuffer_unsafe_legacy() :     Strictly Internal use only !!     Same as ZDICT_trainFromBuffer_legacy(), but does not control `samplesBuffer`.     `samplesBuffer` must be followed by noisy guard band to avoid out-of-buffer reads.     @return : size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)               or an error code. */
end_comment

begin_function_decl
name|size_t
name|ZDICT_trainFromBuffer_unsafe_legacy
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_legacy_params_t
name|parameters
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|DiB_trainFromFiles
parameter_list|(
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|unsigned
name|maxDictSize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
name|size_t
name|chunkSize
parameter_list|,
name|ZDICT_legacy_params_t
modifier|*
name|params
parameter_list|,
name|ZDICT_cover_params_t
modifier|*
name|coverParams
parameter_list|,
name|int
name|optimizeCover
parameter_list|)
block|{
name|unsigned
specifier|const
name|displayLevel
init|=
name|params
condition|?
name|params
operator|->
name|zParams
operator|.
name|notificationLevel
else|:
name|coverParams
condition|?
name|coverParams
operator|->
name|zParams
operator|.
name|notificationLevel
else|:
literal|0
decl_stmt|;
comment|/* should never happen */
name|void
modifier|*
specifier|const
name|dictBuffer
init|=
name|malloc
argument_list|(
name|maxDictSize
argument_list|)
decl_stmt|;
name|fileStats
specifier|const
name|fs
init|=
name|DiB_fileStats
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|,
name|chunkSize
argument_list|,
name|displayLevel
argument_list|)
decl_stmt|;
name|size_t
modifier|*
specifier|const
name|sampleSizes
init|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|fs
operator|.
name|nbSamples
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|memMult
init|=
name|params
condition|?
name|MEMMULT
else|:
name|COVER_MEMMULT
decl_stmt|;
name|size_t
specifier|const
name|maxMem
init|=
name|DiB_findMaxMem
argument_list|(
name|fs
operator|.
name|totalSizeToLoad
operator|*
name|memMult
argument_list|)
operator|/
name|memMult
decl_stmt|;
name|size_t
name|loadedSize
init|=
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
operator|(
name|unsigned
name|long
name|long
operator|)
name|maxMem
argument_list|,
name|fs
operator|.
name|totalSizeToLoad
argument_list|)
decl_stmt|;
name|void
modifier|*
specifier|const
name|srcBuffer
init|=
name|malloc
argument_list|(
name|loadedSize
operator|+
name|NOISELENGTH
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Checks */
if|if
condition|(
operator|(
operator|!
name|sampleSizes
operator|)
operator|||
operator|(
operator|!
name|srcBuffer
operator|)
operator|||
operator|(
operator|!
name|dictBuffer
operator|)
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"not enough memory for DiB_trainFiles"
argument_list|)
expr_stmt|;
comment|/* should not happen */
if|if
condition|(
name|fs
operator|.
name|oneSampleTooLarge
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Warning : some sample(s) are very large \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Note that dictionary is only useful for small samples. \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  As a consequence, only the first %u bytes of each sample are loaded \n"
argument_list|,
name|SAMPLESIZE_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|nbSamples
operator|<
literal|5
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Warning : nb of samples too low for proper processing ! \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Please provide _one file per sample_. \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Alternatively, split files into fixed-size blocks representative of samples, with -B# \n"
argument_list|)
expr_stmt|;
name|EXM_THROW
argument_list|(
literal|14
argument_list|,
literal|"nb of samples too low"
argument_list|)
expr_stmt|;
comment|/* we now clearly forbid this case */
block|}
if|if
condition|(
name|fs
operator|.
name|totalSizeToLoad
operator|<
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
literal|8
operator|*
name|maxDictSize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Warning : data size of samples too small for target dictionary size \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Samples should be about 100x larger than target dictionary size \n"
argument_list|)
expr_stmt|;
block|}
comment|/* init */
if|if
condition|(
name|loadedSize
operator|<
name|fs
operator|.
name|totalSizeToLoad
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Not enough memory; training on %u MB only...\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|loadedSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load input buffer */
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"Shuffling input files\n"
argument_list|)
expr_stmt|;
name|DiB_shuffle
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
name|nbFiles
operator|=
name|DiB_loadFiles
argument_list|(
name|srcBuffer
argument_list|,
operator|&
name|loadedSize
argument_list|,
name|sampleSizes
argument_list|,
name|fs
operator|.
name|nbSamples
argument_list|,
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|,
name|chunkSize
argument_list|,
name|displayLevel
argument_list|)
expr_stmt|;
block|{
name|size_t
name|dictSize
decl_stmt|;
if|if
condition|(
name|params
condition|)
block|{
name|DiB_fillNoise
argument_list|(
operator|(
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|loadedSize
argument_list|,
name|NOISELENGTH
argument_list|)
expr_stmt|;
comment|/* guard band, for end of buffer condition */
name|dictSize
operator|=
name|ZDICT_trainFromBuffer_unsafe_legacy
argument_list|(
name|dictBuffer
argument_list|,
name|maxDictSize
argument_list|,
name|srcBuffer
argument_list|,
name|sampleSizes
argument_list|,
name|fs
operator|.
name|nbSamples
argument_list|,
operator|*
name|params
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optimizeCover
condition|)
block|{
name|dictSize
operator|=
name|ZDICT_optimizeTrainFromBuffer_cover
argument_list|(
name|dictBuffer
argument_list|,
name|maxDictSize
argument_list|,
name|srcBuffer
argument_list|,
name|sampleSizes
argument_list|,
name|fs
operator|.
name|nbSamples
argument_list|,
name|coverParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZDICT_isError
argument_list|(
name|dictSize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"k=%u\nd=%u\nsteps=%u\n"
argument_list|,
name|coverParams
operator|->
name|k
argument_list|,
name|coverParams
operator|->
name|d
argument_list|,
name|coverParams
operator|->
name|steps
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dictSize
operator|=
name|ZDICT_trainFromBuffer_cover
argument_list|(
name|dictBuffer
argument_list|,
name|maxDictSize
argument_list|,
name|srcBuffer
argument_list|,
name|sampleSizes
argument_list|,
name|fs
operator|.
name|nbSamples
argument_list|,
operator|*
name|coverParams
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ZDICT_isError
argument_list|(
name|dictSize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"dictionary training failed : %s \n"
argument_list|,
name|ZDICT_getErrorName
argument_list|(
name|dictSize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* should not happen */
name|result
operator|=
literal|1
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
comment|/* save dict */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Save dictionary of size %u into file %s \n"
argument_list|,
operator|(
name|U32
operator|)
name|dictSize
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
name|DiB_saveDict
argument_list|(
name|dictFileName
argument_list|,
name|dictBuffer
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|_cleanup
label|:
name|free
argument_list|(
name|srcBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sampleSizes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dictBuffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

