begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fitblk.c: example of fitting compressed output to a specified size    Not copyrighted -- provided to the public domain    Version 1.1  25 November 2004  Mark Adler */
end_comment

begin_comment
comment|/* Version history:    1.0  24 Nov 2004  First version    1.1  25 Nov 2004  Change deflateInit2() to deflateInit()                      Use fixed-size, stack-allocated raw buffers                      Simplify code moving compression to subroutines                      Use assert() for internal errors                      Add detailed description of approach  */
end_comment

begin_comment
comment|/* Approach to just fitting a requested compressed size:     fitblk performs three compression passes on a portion of the input    data in order to determine how much of that input will compress to    nearly the requested output block size.  The first pass generates    enough deflate blocks to produce output to fill the requested    output size plus a specfied excess amount (see the EXCESS define    below).  The last deflate block may go quite a bit past that, but    is discarded.  The second pass decompresses and recompresses just    the compressed data that fit in the requested plus excess sized    buffer.  The deflate process is terminated after that amount of    input, which is less than the amount consumed on the first pass.    The last deflate block of the result will be of a comparable size    to the final product, so that the header for that deflate block and    the compression ratio for that block will be about the same as in    the final product.  The third compression pass decompresses the    result of the second step, but only the compressed data up to the    requested size minus an amount to allow the compressed stream to    complete (see the MARGIN define below).  That will result in a    final compressed stream whose length is less than or equal to the    requested size.  Assuming sufficient input and a requested size    greater than a few hundred bytes, the shortfall will typically be    less than ten bytes.     If the input is short enough that the first compression completes    before filling the requested output size, then that compressed    stream is return with no recompression.     EXCESS is chosen to be just greater than the shortfall seen in a    two pass approach similar to the above.  That shortfall is due to    the last deflate block compressing more efficiently with a smaller    header on the second pass.  EXCESS is set to be large enough so    that there is enough uncompressed data for the second pass to fill    out the requested size, and small enough so that the final deflate    block of the second pass will be close in size to the final deflate    block of the third and final pass.  MARGIN is chosen to be just    large enough to assure that the final compression has enough room    to complete in all cases.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* print nastygram and leave */
end_comment

begin_function
name|local
name|void
name|quit
parameter_list|(
name|char
modifier|*
name|why
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fitblk abort: %s\n"
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RAWLEN
value|4096
end_define

begin_comment
comment|/* intermediate uncompressed buffer size */
end_comment

begin_comment
comment|/* compress from file to def until provided buffer is full or end of    input reached; return last deflate() return value, or Z_ERRNO if    there was read error on the file */
end_comment

begin_function
name|local
name|int
name|partcompress
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|,
name|z_streamp
name|def
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|flush
decl_stmt|;
name|unsigned
name|char
name|raw
index|[
name|RAWLEN
index|]
decl_stmt|;
name|flush
operator|=
name|Z_NO_FLUSH
expr_stmt|;
do|do
block|{
name|def
operator|->
name|avail_in
operator|=
name|fread
argument_list|(
name|raw
argument_list|,
literal|1
argument_list|,
name|RAWLEN
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|in
argument_list|)
condition|)
return|return
name|Z_ERRNO
return|;
name|def
operator|->
name|next_in
operator|=
name|raw
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|in
argument_list|)
condition|)
name|flush
operator|=
name|Z_FINISH
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
name|def
argument_list|,
name|flush
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|def
operator|->
name|avail_out
operator|!=
literal|0
operator|&&
name|flush
operator|==
name|Z_NO_FLUSH
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* recompress from inf's input to def's output; the input for inf and    the output for def are set in those structures before calling;    return last deflate() return value, or Z_MEM_ERROR if inflate()    was not able to allocate enough memory when it needed to */
end_comment

begin_function
name|local
name|int
name|recompress
parameter_list|(
name|z_streamp
name|inf
parameter_list|,
name|z_streamp
name|def
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|flush
decl_stmt|;
name|unsigned
name|char
name|raw
index|[
name|RAWLEN
index|]
decl_stmt|;
name|flush
operator|=
name|Z_NO_FLUSH
expr_stmt|;
do|do
block|{
comment|/* decompress */
name|inf
operator|->
name|avail_out
operator|=
name|RAWLEN
expr_stmt|;
name|inf
operator|->
name|next_out
operator|=
name|raw
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
name|inf
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
operator|&&
name|ret
operator|!=
name|Z_DATA_ERROR
operator|&&
name|ret
operator|!=
name|Z_NEED_DICT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
condition|)
return|return
name|ret
return|;
comment|/* compress what was decompresed until done or no room */
name|def
operator|->
name|avail_in
operator|=
name|RAWLEN
operator|-
name|inf
operator|->
name|avail_out
expr_stmt|;
name|def
operator|->
name|next_in
operator|=
name|raw
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|avail_out
operator|!=
literal|0
condition|)
name|flush
operator|=
name|Z_FINISH
expr_stmt|;
name|ret
operator|=
name|deflate
argument_list|(
name|def
argument_list|,
name|flush
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
name|Z_STREAM_END
operator|&&
name|def
operator|->
name|avail_out
operator|!=
literal|0
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EXCESS
value|256
end_define

begin_comment
comment|/* empirically determined stream overage */
end_comment

begin_define
define|#
directive|define
name|MARGIN
value|8
end_define

begin_comment
comment|/* amount to back off for completion */
end_comment

begin_comment
comment|/* compress from stdin to fixed-size block on stdout */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* return code */
name|unsigned
name|size
decl_stmt|;
comment|/* requested fixed output block size */
name|unsigned
name|have
decl_stmt|;
comment|/* bytes written by deflate() call */
name|unsigned
name|char
modifier|*
name|blk
decl_stmt|;
comment|/* intermediate and final stream */
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* close to desired size stream */
name|z_stream
name|def
decl_stmt|,
name|inf
decl_stmt|;
comment|/* zlib deflate and inflate states */
comment|/* get requested output size */
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|quit
argument_list|(
literal|"need one argument: size of output block"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|quit
argument_list|(
literal|"argument must be a number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|8
condition|)
comment|/* 8 is minimum zlib stream size */
name|quit
argument_list|(
literal|"need positive size of 8 or greater"
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|unsigned
operator|)
name|ret
expr_stmt|;
comment|/* allocate memory for buffers and compression engine */
name|blk
operator|=
name|malloc
argument_list|(
name|size
operator|+
name|EXCESS
argument_list|)
expr_stmt|;
name|def
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|def
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|def
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|deflateInit
argument_list|(
operator|&
name|def
argument_list|,
name|Z_DEFAULT_COMPRESSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|||
name|blk
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* compress from stdin until output full, or no more input */
name|def
operator|.
name|avail_out
operator|=
name|size
operator|+
name|EXCESS
expr_stmt|;
name|def
operator|.
name|next_out
operator|=
name|blk
expr_stmt|;
name|ret
operator|=
name|partcompress
argument_list|(
name|stdin
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_ERRNO
condition|)
name|quit
argument_list|(
literal|"error reading input"
argument_list|)
expr_stmt|;
comment|/* if it all fit, then size was undersubscribed -- done! */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
operator|&&
name|def
operator|.
name|avail_out
operator|>=
name|EXCESS
condition|)
block|{
comment|/* write block to stdout */
name|have
operator|=
name|size
operator|+
name|EXCESS
operator|-
name|def
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|blk
argument_list|,
literal|1
argument_list|,
name|have
argument_list|,
name|stdout
argument_list|)
operator|!=
name|have
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|quit
argument_list|(
literal|"error writing output"
argument_list|)
expr_stmt|;
comment|/* clean up and print results to stderr */
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u bytes unused out of %u requested (all input)\n"
argument_list|,
name|size
operator|-
name|have
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* it didn't all fit -- set up for recompression */
name|inf
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|inf
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|inf
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
name|size
operator|+
name|EXCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|||
name|tmp
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|deflateReset
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
comment|/* do first recompression close to the right amount */
name|inf
operator|.
name|avail_in
operator|=
name|size
operator|+
name|EXCESS
expr_stmt|;
name|inf
operator|.
name|next_in
operator|=
name|blk
expr_stmt|;
name|def
operator|.
name|avail_out
operator|=
name|size
operator|+
name|EXCESS
expr_stmt|;
name|def
operator|.
name|next_out
operator|=
name|tmp
expr_stmt|;
name|ret
operator|=
name|recompress
argument_list|(
operator|&
name|inf
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
condition|)
name|quit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* set up for next reocmpression */
name|ret
operator|=
name|inflateReset
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|deflateReset
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
comment|/* do second and final recompression (third compression) */
name|inf
operator|.
name|avail_in
operator|=
name|size
operator|-
name|MARGIN
expr_stmt|;
comment|/* assure stream will complete */
name|inf
operator|.
name|next_in
operator|=
name|tmp
expr_stmt|;
name|def
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
name|def
operator|.
name|next_out
operator|=
name|blk
expr_stmt|;
name|ret
operator|=
name|recompress
argument_list|(
operator|&
name|inf
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
condition|)
name|quit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|Z_STREAM_END
argument_list|)
expr_stmt|;
comment|/* otherwise MARGIN too small */
comment|/* done -- write block to stdout */
name|have
operator|=
name|size
operator|-
name|def
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|blk
argument_list|,
literal|1
argument_list|,
name|have
argument_list|,
name|stdout
argument_list|)
operator|!=
name|have
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|quit
argument_list|(
literal|"error writing output"
argument_list|)
expr_stmt|;
comment|/* clean up and print results to stderr */
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|inf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u bytes unused out of %u requested (%lu input)\n"
argument_list|,
name|size
operator|-
name|have
argument_list|,
name|size
argument_list|,
name|def
operator|.
name|total_in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

