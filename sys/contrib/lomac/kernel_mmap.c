begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 Networks Associates Technology, Inc.  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah $Hdr: vm_mmap.c 1.6 91/10/21$  *  *	@(#)vm_mmap.c	8.4 (Berkeley) 1/12/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|"kernel_interface.h"
end_include

begin_include
include|#
directive|include
file|"kernel_mediate.h"
end_include

begin_include
include|#
directive|include
file|"kernel_monitor.h"
end_include

begin_include
include|#
directive|include
file|"kernel_util.h"
end_include

begin_include
include|#
directive|include
file|"lomacfs.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|max_proc_mmap
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|lomac_mmap
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|mmap_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * Memory Map (mmap) system call.  Note that the file offset  * and address are allowed to be NOT page aligned, though if  * the MAP_FIXED flag it set, both must have the same remainder  * modulo the PAGE_SIZE (POSIX 1003.1b).  If the address is not  * page-aligned, the actual mapping starts at trunc_page(addr)  * and the return value is adjusted up by the page offset.  *  * Generally speaking, only character devices which are themselves  * memory-based, such as a video framebuffer, can be mmap'd.  Otherwise  * there would be no cache coherency between a descriptor and a VM mapping  * both to the same character device.  *  * Block devices can be mmap'd no matter what they represent.  Cache coherency  * is maintained as long as you do not write directly to the underlying  * character device.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|mmap_args
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|pad
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mmap
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|mmap_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|origvp
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|pageoff
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|,
name|maxprot
decl_stmt|;
name|void
modifier|*
name|handle
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|;
name|int
name|disablexworkaround
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vms
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|lomac_object_t
name|lobj
decl_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|prot
operator|=
name|uap
operator|->
name|prot
operator|&
name|VM_PROT_ALL
expr_stmt|;
name|flags
operator|=
name|uap
operator|->
name|flags
expr_stmt|;
name|pos
operator|=
name|uap
operator|->
name|pos
expr_stmt|;
name|origvp
operator|=
name|NULL
expr_stmt|;
comment|/* make sure mapping fits into numeric range etc */
if|if
condition|(
operator|(
name|ssize_t
operator|)
name|uap
operator|->
name|len
operator|<
literal|0
operator|||
operator|(
operator|(
name|flags
operator|&
name|MAP_ANON
operator|)
operator|&&
name|uap
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|MAP_STACK
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|prot
operator|&
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator|)
operator|)
operator|!=
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|flags
operator||=
name|MAP_ANON
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Align the file position to a page boundary, 	 * and save its page offset component. 	 */
name|pageoff
operator|=
operator|(
name|pos
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|pos
operator|-=
name|pageoff
expr_stmt|;
comment|/* Adjust size for rounding (on both ends). */
name|size
operator|+=
name|pageoff
expr_stmt|;
comment|/* low end... */
name|size
operator|=
operator|(
name|vm_size_t
operator|)
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* hi end */
comment|/* 	 * Check for illegal addresses.  Watch out for address wrap... Note 	 * that VM_*_ADDRESS are not constants due to casts (argh). 	 */
if|if
condition|(
name|flags
operator|&
name|MAP_FIXED
condition|)
block|{
comment|/* 		 * The specified address must have the same remainder 		 * as the file offset taken modulo PAGE_SIZE, so it 		 * should be aligned after adjustment by pageoff. 		 */
name|addr
operator|-=
name|pageoff
expr_stmt|;
if|if
condition|(
name|addr
operator|&
name|PAGE_MASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Address range must be all in user VM space. */
if|if
condition|(
name|VM_MAXUSER_ADDRESS
operator|>
literal|0
operator|&&
name|addr
operator|+
name|size
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifndef|#
directive|ifndef
name|i386
if|if
condition|(
name|VM_MIN_ADDRESS
operator|>
literal|0
operator|&&
name|addr
operator|<
name|VM_MIN_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|addr
operator|+
name|size
operator|<
name|addr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * XXX for non-fixed mappings where no hint is provided or 	 * the hint would fall in the potential heap space, 	 * place it after the end of the largest possible heap. 	 * 	 * There should really be a pmap call to determine a reasonable 	 * location. 	 */
elseif|else
if|if
condition|(
name|addr
operator|==
literal|0
operator|||
operator|(
name|addr
operator|>=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vms
operator|->
name|vm_taddr
argument_list|)
operator|&&
name|addr
operator|<
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
operator|)
condition|)
name|addr
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vms
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* syscall marked mp-safe but isn't */
if|if
condition|(
name|flags
operator|&
name|MAP_ANON
condition|)
block|{
comment|/* 		 * Mapping blank space is trivial. 		 */
name|handle
operator|=
name|NULL
expr_stmt|;
name|maxprot
operator|=
name|VM_PROT_ALL
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Mapping file, get fp for validation. Obtain vnode and make 		 * sure it is of appropriate type. 		 */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|fd
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * don't let the descriptor disappear on us if we block 		 */
name|fhold
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 		 * POSIX shared-memory objects are defined to have 		 * kernel persistence, and are not defined to support 		 * read(2)/write(2) -- or even open(2).  Thus, we can 		 * use MAP_ASYNC to trade on-disk coherence for speed. 		 * The shm_open(3) library routine turns on the FPOSIXSHM 		 * flag to request this behavior. 		 */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|FPOSIXSHM
condition|)
name|flags
operator||=
name|MAP_NOSYNC
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
comment|/* 			 * Get the proper underlying object 			 */
if|if
condition|(
name|VOP_GETVOBJECT
argument_list|(
name|vp
argument_list|,
operator|&
name|obj
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|origvp
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|obj
operator|->
name|handle
expr_stmt|;
block|}
comment|/* 		 * XXX hack to handle use of /dev/zero to map anon memory (ala 		 * SunOS). 		 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_rdev
operator|->
name|si_devsw
operator|->
name|d_flags
operator|&
name|D_MMAP_ANON
operator|)
condition|)
block|{
name|handle
operator|=
name|NULL
expr_stmt|;
name|maxprot
operator|=
name|VM_PROT_ALL
expr_stmt|;
name|flags
operator||=
name|MAP_ANON
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * cdevs does not provide private mappings of any kind. 			 */
comment|/* 			 * However, for XIG X server to continue to work, 			 * we should allow the superuser to do it anyway. 			 * We only allow it at securelevel< 1. 			 * (Because the XIG X server writes directly to video 			 * memory via /dev/mem, it should never work at any 			 * other securelevel. 			 * XXX this will have to go 			 */
if|if
condition|(
name|securelevel
operator|>=
literal|1
condition|)
name|disablexworkaround
operator|=
literal|1
expr_stmt|;
else|else
name|disablexworkaround
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|&&
name|disablexworkaround
operator|&&
operator|(
name|flags
operator|&
operator|(
name|MAP_PRIVATE
operator||
name|MAP_COPY
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * Ensure that file and memory protections are 			 * compatible.  Note that we only worry about 			 * writability if mapping is shared; in this case, 			 * current and max prot are dictated by the open file. 			 * XXX use the vnode instead?  Problem is: what 			 * credentials do we use for determination? What if 			 * proc does a setuid? 			 */
name|maxprot
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
comment|/* ??? */
if|if
condition|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
condition|)
block|{
name|maxprot
operator||=
name|VM_PROT_READ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prot
operator|&
name|PROT_READ
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * If we are sharing potential changes (either via 			 * MAP_SHARED or via the implicit sharing of character 			 * device mappings), and we are trying to get write 			 * permission although we opened it without asking 			 * for it, bail out.  Check for superuser, only if 			 * we're at securelevel< 1, to allow the XIG X server 			 * to continue to work. 			 */
if|if
condition|(
operator|(
name|flags
operator|&
name|MAP_SHARED
operator|)
operator|!=
literal|0
operator|||
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|&&
name|disablexworkaround
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|vattr
name|va
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|va
operator|.
name|va_flags
operator|&
operator|(
name|SF_SNAPSHOT
operator||
name|IMMUTABLE
operator||
name|APPEND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|maxprot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prot
operator|&
name|PROT_WRITE
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|prot
operator|&
name|PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|maxprot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
block|}
name|handle
operator|=
operator|(
name|void
operator|*
operator|)
name|vp
expr_stmt|;
name|origvp
operator|=
name|vp
expr_stmt|;
block|}
block|}
comment|/* 	 * Do not allow more then a certain number of vm_map_entry structures 	 * per process.  Scale with the number of rforks sharing the map 	 * to make the limit reasonable for threads. 	 */
if|if
condition|(
name|max_proc_mmap
operator|&&
name|vms
operator|->
name|vm_map
operator|.
name|nentries
operator|>=
name|max_proc_mmap
operator|*
name|vms
operator|->
name|vm_refcnt
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
name|NULL
operator|&&
name|VISLOMAC
argument_list|(
name|origvp
argument_list|)
condition|)
block|{
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_LVNODE
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vnode
operator|=
name|origvp
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MAP_SHARED
operator|&&
name|maxprot
operator|&
name|VM_PROT_WRITE
operator|&&
operator|!
name|mediate_subject_object
argument_list|(
literal|"mmap"
argument_list|,
name|p
argument_list|,
operator|&
name|lobj
argument_list|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|maxprot
operator|&
name|VM_PROT_READ
condition|)
name|error
operator|=
name|monitor_read_object
argument_list|(
name|p
argument_list|,
operator|&
name|lobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vms
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|size
argument_list|,
name|prot
argument_list|,
name|maxprot
argument_list|,
name|flags
argument_list|,
name|handle
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
call|(
name|register_t
call|)
argument_list|(
name|addr
operator|+
name|pageoff
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|fp
condition|)
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vm_drop_perms_recurse
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vm_map
modifier|*
name|map
parameter_list|,
name|lattr_t
modifier|*
name|lattr
parameter_list|)
block|{
name|struct
name|vm_map_entry
modifier|*
name|vme
decl_stmt|;
for|for
control|(
name|vme
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|vme
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|vme
operator|=
name|vme
operator|->
name|next
control|)
block|{
if|if
condition|(
name|vme
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
condition|)
block|{
name|vm_map_lock_read
argument_list|(
name|vme
operator|->
name|object
operator|.
name|sub_map
argument_list|)
expr_stmt|;
name|vm_drop_perms_recurse
argument_list|(
name|td
argument_list|,
name|vme
operator|->
name|object
operator|.
name|sub_map
argument_list|,
name|lattr
argument_list|)
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|vme
operator|->
name|object
operator|.
name|sub_map
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|vme
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NOSYNC
operator|)
operator|)
operator|==
literal|0
operator|&&
name|vme
operator|->
name|max_protection
operator|&
name|VM_PROT_WRITE
condition|)
block|{
name|vm_object_t
name|object
decl_stmt|;
name|vm_ooffset_t
name|offset
decl_stmt|;
name|lomac_object_t
name|lobj
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|lattr_t
name|olattr
decl_stmt|;
name|offset
operator|=
name|vme
operator|->
name|offset
expr_stmt|;
name|object
operator|=
name|vme
operator|->
name|object
operator|.
name|vm_object
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
name|object
operator|->
name|backing_object
condition|)
block|{
name|object
operator|=
name|object
operator|->
name|backing_object
expr_stmt|;
name|offset
operator|+=
name|object
operator|->
name|backing_object_offset
expr_stmt|;
block|}
comment|/* 			 * Regular objects (swap, etc.) inherit from 			 * their creator.  Vnodes inherit from their 			 * underlying on-disk object. 			 */
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
condition|)
continue|continue;
if|if
condition|(
name|object
operator|->
name|type
operator|==
name|OBJT_VNODE
condition|)
block|{
name|vp
operator|=
name|lobj
operator|.
name|lo_object
operator|.
name|vnode
operator|=
name|object
operator|->
name|handle
expr_stmt|;
comment|/* 				 * For the foreseeable future, an OBJT_VNODE 				 * is always !VISLOMAC(). 				 */
name|lobj
operator|.
name|lo_type
operator|=
name|VISLOMAC
argument_list|(
name|vp
argument_list|)
condition|?
name|LO_TYPE_LVNODE
else|:
name|LO_TYPE_UVNODE
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|NULL
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_VM_OBJECT
expr_stmt|;
block|}
name|get_object_lattr
argument_list|(
operator|&
name|lobj
argument_list|,
operator|&
name|olattr
argument_list|)
expr_stmt|;
comment|/* 			 * Revoke write access only to files with a higher 			 * level than the process or which have a possibly- 			 * undeterminable level (interpreted as "lowest"). 			 */
if|if
condition|(
name|lomac_must_deny
argument_list|(
name|lattr
argument_list|,
operator|&
name|olattr
argument_list|)
condition|)
continue|continue;
name|vm_map_lock_upgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
comment|/* 			 * If it's a private, non-file-backed mapping and 			 * not mapped anywhere else, we can just take it 			 * down with us. 			 */
if|if
condition|(
name|vp
operator|==
name|NULL
operator|&&
name|object
operator|->
name|flags
operator|&
name|OBJ_ONEMAPPING
condition|)
block|{
name|olattr
operator|.
name|level
operator|=
name|lattr
operator|->
name|level
expr_stmt|;
name|set_object_lattr
argument_list|(
operator|&
name|lobj
argument_list|,
name|olattr
argument_list|)
expr_stmt|;
goto|goto
name|downgrade
goto|;
block|}
if|if
condition|(
operator|(
name|vme
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|vme
operator|->
name|max_protection
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
else|else
block|{
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|object
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|offset
operator|+
name|vme
operator|->
name|end
operator|-
name|vme
operator|->
name|start
operator|+
name|PAGE_MASK
argument_list|)
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vme
operator|->
name|eflags
operator||=
name|MAP_ENTRY_COW
operator||
name|MAP_ENTRY_NEEDS_COPY
expr_stmt|;
name|pmap_protect
argument_list|(
name|map
operator|->
name|pmap
argument_list|,
name|vme
operator|->
name|start
argument_list|,
name|vme
operator|->
name|end
argument_list|,
name|vme
operator|->
name|protection
operator|&
operator|~
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|vm_map_simplify_entry
argument_list|(
name|map
argument_list|,
name|vme
argument_list|)
expr_stmt|;
block|}
name|downgrade
label|:
name|vm_map_lock_downgrade
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|kernel_vm_drop_perms
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|lattr_t
modifier|*
name|newlattr
parameter_list|)
block|{
name|struct
name|vm_map
modifier|*
name|map
init|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|vm_drop_perms_recurse
argument_list|(
name|td
argument_list|,
name|map
argument_list|,
name|newlattr
argument_list|)
expr_stmt|;
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the level of new vm_objects from the parent subject's level.  */
end_comment

begin_function
specifier|static
name|void
name|vm_object_init_lattr
parameter_list|(
name|vm_object_t
name|object
parameter_list|)
block|{
name|lomac_object_t
name|lobj
decl_stmt|;
name|lattr_t
name|lattr
decl_stmt|;
name|get_subject_lattr
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
operator|&
name|lattr
argument_list|)
expr_stmt|;
name|lattr
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|lobj
operator|.
name|lo_type
operator|=
name|LO_TYPE_VM_OBJECT
expr_stmt|;
name|lobj
operator|.
name|lo_object
operator|.
name|vm_object
operator|=
name|object
expr_stmt|;
name|set_object_lattr
argument_list|(
operator|&
name|lobj
argument_list|,
name|lattr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PGO_ALLOC_REPLACEMENT
parameter_list|(
name|n
parameter_list|)
define|\
value|static vm_object_t (*old_pgo_alloc_##n)(void *, vm_ooffset_t,		\     vm_prot_t, vm_ooffset_t);						\ 									\ static vm_object_t							\ pgo_alloc_##n(void *handle, vm_ooffset_t size, vm_prot_t prot,		\     vm_ooffset_t off) {							\ 	vm_object_t newobj = NULL;					\ 									\ 	newobj = old_pgo_alloc_##n(handle, size, prot, off);		\ 	if (newobj != NULL)						\ 		vm_object_init_lattr(newobj);				\ 	return (newobj);						\ }
end_define

begin_define
define|#
directive|define
name|PGO_ALLOC_REPLACE
parameter_list|(
name|n
parameter_list|)
define|\
value|do {								\ 		old_pgo_alloc_##n = pagertab[n]->pgo_alloc;		\ 		if (pagertab[n]->pgo_alloc != NULL)			\ 			pagertab[n]->pgo_alloc = pgo_alloc_##n;		\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|PGO_ALLOC_UNREPLACE
parameter_list|(
name|n
parameter_list|)
define|\
value|do {								\ 		pagertab[n]->pgo_alloc = old_pgo_alloc_##n;		\ 	} while (0)
end_define

begin_expr_stmt
name|PGO_ALLOC_REPLACEMENT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PGO_ALLOC_REPLACEMENT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PGO_ALLOC_REPLACEMENT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PGO_ALLOC_REPLACEMENT
argument_list|(
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PGO_ALLOC_REPLACEMENT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PGO_ALLOC_REPLACEMENT
argument_list|(
literal|5
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|npagers
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|lomac_initialize_vm
parameter_list|(
name|void
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|npagers
operator|!=
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"LOMAC: number of pagers %d not expected 6!\n"
argument_list|,
name|npagers
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDOM
operator|)
return|;
block|}
name|PGO_ALLOC_REPLACE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PGO_ALLOC_REPLACE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PGO_ALLOC_REPLACE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PGO_ALLOC_REPLACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|PGO_ALLOC_REPLACE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|PGO_ALLOC_REPLACE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lomac_uninitialize_vm
parameter_list|(
name|void
parameter_list|)
block|{
name|GIANT_REQUIRED
expr_stmt|;
name|PGO_ALLOC_UNREPLACE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PGO_ALLOC_UNREPLACE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PGO_ALLOC_UNREPLACE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|PGO_ALLOC_UNREPLACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|PGO_ALLOC_UNREPLACE
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|PGO_ALLOC_UNREPLACE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

