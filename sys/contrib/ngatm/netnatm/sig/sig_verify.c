begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * $Begemot: libunimsg/netnatm/sig/sig_verify.c,v 1.19 2004/07/08 08:22:23 brandt Exp $  *  * Message verification with explicit action indicators.  */
end_comment

begin_include
include|#
directive|include
file|<netnatm/unimsg.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/saal/sscfudef.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unistruct.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unimsglib.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/uni.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/unipriv.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/unimkmsg.h>
end_include

begin_function
name|void
name|uni_mandate_ie
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|,
name|enum
name|uni_ietype
name|ie
parameter_list|)
block|{
name|struct
name|uni_ierr
modifier|*
name|e
decl_stmt|;
name|FOREACH_ERR
argument_list|(
argument|e
argument_list|,
argument|uni
argument_list|)
if|if
condition|(
name|e
operator|->
name|ie
operator|==
name|ie
condition|)
block|{
name|e
operator|->
name|man
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|UNI_SAVE_IERR
argument_list|(
operator|&
name|uni
operator|->
name|cx
argument_list|,
name|ie
argument_list|,
name|UNI_IEACT_DEFAULT
argument_list|,
name|UNI_IERR_MIS
argument_list|)
condition|)
name|uni
operator|->
name|cx
operator|.
name|err
index|[
name|uni
operator|->
name|cx
operator|.
name|errcnt
operator|-
literal|1
index|]
operator|.
name|man
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This special handling is required for ADD PARTY, PARTY ALERTING and  * ADD PARTY ACKNOWLEDGE by Q.2971 9.5.3.2.1.  * It means, that the EPREF should be handled as mandatory only if  * no other IEs have explicit action indicators.  */
end_comment

begin_function
name|void
name|uni_mandate_epref
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|,
name|struct
name|uni_ie_epref
modifier|*
name|epref
parameter_list|)
block|{
name|struct
name|uni_ierr
modifier|*
name|e
decl_stmt|;
name|int
name|maxact
decl_stmt|;
if|if
condition|(
operator|!
name|IE_ISPRESENT
argument_list|(
operator|*
name|epref
argument_list|)
condition|)
block|{
comment|/* 		 * 9.5.3.2.1 -- missing endpoint reference 		 */
comment|/* 		 * a) if any unrecognized or IE with error has a CLEAR 		 *    action indicator, this takes precedence. 		 * b) if any unrecognized or IE with error has a 		 *    discard message and report action indicator, this takes 		 *    precedence. 		 * c) if any unrecognized or IE with error has a 		 *    discard message action indicator, this takes 		 *    precedence. 		 * 		 * In any of these cases we must remove the EPREF IE 		 * if it has CLEAR, otherwise the CLEAR would take over. 		 */
name|maxact
operator|=
operator|-
literal|1
expr_stmt|;
name|FOREACH_ERR
argument_list|(
argument|e
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|ie
operator|==
name|UNI_IE_EPREF
condition|)
continue|continue;
if|if
condition|(
name|e
operator|->
name|act
operator|==
name|UNI_IEACT_CLEAR
condition|)
name|maxact
operator|=
name|UNI_IEACT_CLEAR
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_REPORT
condition|)
block|{
if|if
condition|(
name|maxact
operator|==
operator|-
literal|1
operator|&&
name|maxact
operator|!=
name|UNI_IEACT_CLEAR
condition|)
name|maxact
operator|=
name|UNI_IEACT_MSG_REPORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_IGNORE
condition|)
block|{
if|if
condition|(
name|maxact
operator|==
operator|-
literal|1
condition|)
name|maxact
operator|=
name|UNI_IEACT_MSG_IGNORE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxact
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* ok, second pass to remove UNI_IE_EPREF */
name|FOREACH_ERR
argument_list|(
argument|e
argument_list|,
argument|uni
argument_list|)
if|if
condition|(
name|e
operator|->
name|ie
operator|==
name|UNI_IE_EPREF
condition|)
block|{
name|memmove
argument_list|(
name|e
argument_list|,
name|e
operator|+
literal|1
argument_list|,
operator|(
name|uni
operator|->
name|cx
operator|.
name|errcnt
operator|-
operator|(
name|e
operator|-
name|uni
operator|->
name|cx
operator|.
name|err
operator|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uni
operator|->
name|cx
operator|.
name|err
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|uni
operator|->
name|cx
operator|.
name|errcnt
operator|--
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|/* 		 * d) if nothing of the above, the IE is mandatory 		 */
name|uni_mandate_ie
argument_list|(
name|uni
argument_list|,
name|UNI_IE_EPREF
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IE_ISGOOD
argument_list|(
operator|*
name|epref
argument_list|)
condition|)
return|return;
comment|/* 	 * It has an error obviously 	 * 9.5.3.2.2 	 * 	 * It turns out, that Q.2931 handling just does the right thing 	 * if we don't mandate the IE. 	 */
return|return;
block|}
end_function

begin_comment
comment|/*  * Look, what to do with this message. We assume, that the message itself is  * recognized.  *  * This is rather complicated. We must use the information provided in the  * fields of the context, because IEs with length errors may not be set  * altogether.  */
end_comment

begin_function
name|enum
name|verify
name|uni_verify
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|,
name|enum
name|uni_msgact
name|msgact
parameter_list|)
block|{
name|struct
name|uni_ierr
modifier|*
name|e1
decl_stmt|;
if|if
condition|(
name|uni
operator|->
name|debug
index|[
name|UNI_FAC_VERIFY
index|]
operator|>=
literal|2
condition|)
block|{
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|2
argument_list|,
literal|"ie=%02x err=%u man=%d"
literal|" act=%u"
argument_list|,
name|e1
operator|->
name|ie
argument_list|,
name|e1
operator|->
name|err
argument_list|,
name|e1
operator|->
name|man
argument_list|,
name|e1
operator|->
name|act
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Look for missing mandatory IEs. The action indicator is ignored 	 * according to 5.6.7.1. If IEs are missing the action is to 	 * ignore the message and report status for all messages except 	 * RELEASE, RELEASE_COMPLETE and SETUP. Because we must differentiate 	 * this RAI from other RAIs in this case, use another return code. 	 * Note, that mandatory IEs with errors are not handled here. 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_MIS
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_MANDAT
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAIM"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAIM
operator|)
return|;
block|}
block|}
comment|/* 	 * When any IE with error specifies a CLR action indicator, this 	 * takes precedence obviously. There are two cases here: 	 * unrecognized IEs and IEs with error. So we look through the 	 * error array twice and send only one STATUS. Unrecognized will 	 * take precedence. 	 * 	 * 5.7.2a) 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_CLEAR
operator|&&
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_UNK
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_NIMPL
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"CLR1"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_CLR
operator|)
return|;
block|}
block|}
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_CLEAR
operator|&&
operator|(
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_LEN
operator|||
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_BAD
operator|||
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_ACC
operator|)
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_INV
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"CLR2"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_CLR
operator|)
return|;
block|}
block|}
comment|/* 	 * Now check, whether anybody wants to explicitly ignore the message 	 * and report status. 	 * 	 * 5.7.2a) 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_REPORT
operator|&&
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_UNK
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_NIMPL
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAI"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAI
operator|)
return|;
block|}
block|}
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_REPORT
operator|&&
operator|(
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_LEN
operator|||
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_BAD
operator|||
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_ACC
operator|)
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_INV
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAI"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAI
operator|)
return|;
block|}
block|}
comment|/* 	 * Now look whether some IE wants to explicitely ignore the message 	 * without any report. 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_IGNORE
condition|)
block|{
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"I1"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_I
operator|)
return|;
block|}
block|}
comment|/* 	 * At this point we have left only 	 *  mandatory and non-mandatory IEs with error that want the IE to be 	 *  ignored or ignored with report or defaulted. 	 * Because a mandatory IE with errors lead to 	 * the message beeing ignored, we make this of higher 	 * precedence, than the rest. 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|man
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_MANDAT
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAI"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAI
operator|)
return|;
block|}
block|}
comment|/* 	 * Now look for ignoring the IE and reporting. This takes precedence 	 * over simply ignoring it. We also collect defaulted (non-mandatory) 	 * IEs. 	 * 	 * 5.7.2d) and 5.6.8.1 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
operator|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_DEFAULT
operator|||
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_REPORT
operator|)
operator|&&
name|e1
operator|->
name|err
operator|!=
name|UNI_IERR_UNK
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_INV
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAP"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAP
operator|)
return|;
block|}
block|}
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
operator|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_DEFAULT
operator|||
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_REPORT
operator|)
operator|&&
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_UNK
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_NIMPL
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAPU"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAPU
operator|)
return|;
block|}
block|}
comment|/* 	 * This leaves us with IEs, that want to be ignored. Among these may 	 * be mandatory IEs. If we have an mandatory IEs here in the error 	 * array, then the message wil not contain enough information and 	 * must be handled according to 5.8 as either in 5.6.7.1 (this 	 * means, that mandatory IEs cannot really be ignored) or 5.7.1. 	 */
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|man
condition|)
block|{
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_MANDAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgact
operator|==
name|UNI_MSGACT_CLEAR
condition|)
block|{
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"CLR3"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_CLR
operator|)
return|;
block|}
if|if
condition|(
name|msgact
operator|==
name|UNI_MSGACT_IGNORE
condition|)
block|{
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"I2"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_I
operator|)
return|;
block|}
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"RAI"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_RAI
operator|)
return|;
block|}
block|}
comment|/* 	 * Now only non-mandatory IEs are left, that want to be explicitely 	 * ignored. 	 */
if|if
condition|(
name|uni
operator|->
name|cx
operator|.
name|errcnt
operator|!=
literal|0
condition|)
name|MK_IE_CAUSE
argument_list|(
name|uni
operator|->
name|cause
argument_list|,
name|UNI_CAUSE_LOC_USER
argument_list|,
name|UNI_CAUSE_IE_INV
argument_list|)
expr_stmt|;
name|VERBOSE
argument_list|(
name|uni
argument_list|,
name|UNI_FAC_VERIFY
argument_list|,
literal|1
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VFY_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect the IE identifiers for some of the known cause codes.  */
end_comment

begin_function
name|void
name|uni_vfy_collect_ies
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|)
block|{
name|struct
name|uni_ierr
modifier|*
name|e
decl_stmt|;
define|#
directive|define
name|STUFF_IE
parameter_list|(
name|IE
parameter_list|)
define|\
value|uni->cause.u.ie.ie[uni->cause.u.ie.len++] = (IE);	\ 	if (uni->cause.u.ie.len == UNI_CAUSE_IE_N)		\ 		break;
name|uni
operator|->
name|cause
operator|.
name|u
operator|.
name|ie
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uni
operator|->
name|cause
operator|.
name|cause
operator|==
name|UNI_CAUSE_MANDAT
condition|)
block|{
name|FOREACH_ERR
argument_list|(
argument|e
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|err
operator|==
name|UNI_IERR_MIS
operator|||
name|e
operator|->
name|man
operator|!=
literal|0
condition|)
block|{
name|STUFF_IE
argument_list|(
name|e
operator|->
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|uni
operator|->
name|cause
operator|.
name|cause
operator|==
name|UNI_CAUSE_IE_NIMPL
condition|)
block|{
name|FOREACH_ERR
argument_list|(
argument|e
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|err
operator|==
name|UNI_IERR_UNK
condition|)
block|{
name|STUFF_IE
argument_list|(
name|e
operator|->
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|uni
operator|->
name|cause
operator|.
name|cause
operator|==
name|UNI_CAUSE_IE_INV
condition|)
block|{
name|FOREACH_ERR
argument_list|(
argument|e
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|err
operator|==
name|UNI_IERR_LEN
operator|||
name|e
operator|->
name|err
operator|==
name|UNI_IERR_BAD
operator|||
name|e
operator|->
name|err
operator|==
name|UNI_IERR_ACC
condition|)
block|{
name|STUFF_IE
argument_list|(
name|e
operator|->
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
return|return;
if|if
condition|(
name|uni
operator|->
name|cause
operator|.
name|u
operator|.
name|ie
operator|.
name|len
operator|!=
literal|0
condition|)
name|uni
operator|->
name|cause
operator|.
name|h
operator|.
name|present
operator||=
name|UNI_CAUSE_IE_P
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uni_respond_status_verify
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|,
name|struct
name|uni_cref
modifier|*
name|cref
parameter_list|,
name|enum
name|uni_callstate
name|cs
parameter_list|,
name|struct
name|uni_ie_epref
modifier|*
name|epref
parameter_list|,
name|enum
name|uni_epstate
name|ps
parameter_list|)
block|{
name|struct
name|uni_all
modifier|*
name|resp
decl_stmt|;
if|if
condition|(
operator|(
name|resp
operator|=
name|UNI_ALLOC
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
name|uni_vfy_collect_ies
argument_list|(
name|uni
argument_list|)
expr_stmt|;
name|MK_MSG_RESP
argument_list|(
name|resp
argument_list|,
name|UNI_STATUS
argument_list|,
name|cref
argument_list|)
expr_stmt|;
name|MK_IE_CALLSTATE
argument_list|(
name|resp
operator|->
name|u
operator|.
name|status
operator|.
name|callstate
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|resp
operator|->
name|u
operator|.
name|status
operator|.
name|cause
operator|=
name|uni
operator|->
name|cause
expr_stmt|;
if|if
condition|(
name|epref
operator|&&
name|IE_ISGOOD
argument_list|(
operator|*
name|epref
argument_list|)
condition|)
block|{
name|MK_IE_EPREF
argument_list|(
name|resp
operator|->
name|u
operator|.
name|status
operator|.
name|epref
argument_list|,
name|epref
operator|->
name|epref
argument_list|,
operator|!
name|epref
operator|->
name|flag
argument_list|)
expr_stmt|;
name|MK_IE_EPSTATE
argument_list|(
name|resp
operator|->
name|u
operator|.
name|status
operator|.
name|epstate
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
name|uni_send_output
argument_list|(
name|resp
argument_list|,
name|uni
argument_list|)
expr_stmt|;
name|UNI_FREE
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handling of Q.2971 9.5.8.1:  */
end_comment

begin_function
name|void
name|uni_vfy_remove_unknown
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|)
block|{
name|struct
name|uni_ierr
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e0
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|FOREACH_ERR
argument_list|(
argument|e1
argument_list|,
argument|uni
argument_list|)
block|{
if|if
condition|(
name|e1
operator|->
name|err
operator|==
name|UNI_IERR_UNK
condition|)
block|{
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_CLEAR
operator|||
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_IGNORE
operator|||
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_MSG_REPORT
condition|)
return|return;
if|if
condition|(
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_REPORT
operator|||
name|e1
operator|->
name|act
operator|==
name|UNI_IEACT_DEFAULT
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
condition|)
return|return;
name|e0
operator|=
name|e1
operator|=
name|uni
operator|->
name|cx
operator|.
name|err
expr_stmt|;
while|while
condition|(
name|e1
operator|<
name|uni
operator|->
name|cx
operator|.
name|err
operator|+
name|uni
operator|->
name|cx
operator|.
name|errcnt
condition|)
block|{
if|if
condition|(
name|e1
operator|->
name|err
operator|!=
name|UNI_IERR_UNK
condition|)
block|{
if|if
condition|(
name|e0
operator|!=
name|e1
condition|)
operator|*
name|e0
operator|=
operator|*
name|e1
expr_stmt|;
name|e0
operator|++
expr_stmt|;
block|}
name|e1
operator|++
expr_stmt|;
block|}
name|uni
operator|->
name|cx
operator|.
name|errcnt
operator|=
name|e0
operator|-
name|uni
operator|->
name|cx
operator|.
name|err
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handling for ADD_PARTY_REJ and DROP_PARTY_ACK with bad cause  */
end_comment

begin_function
name|void
name|uni_vfy_remove_cause
parameter_list|(
name|struct
name|uni
modifier|*
name|uni
parameter_list|)
block|{
name|struct
name|uni_ierr
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e0
decl_stmt|;
name|e0
operator|=
name|e1
operator|=
name|uni
operator|->
name|cx
operator|.
name|err
expr_stmt|;
while|while
condition|(
name|e1
operator|<
name|uni
operator|->
name|cx
operator|.
name|err
operator|+
name|uni
operator|->
name|cx
operator|.
name|errcnt
condition|)
block|{
if|if
condition|(
name|e1
operator|->
name|ie
operator|!=
name|UNI_IE_CAUSE
condition|)
block|{
if|if
condition|(
name|e0
operator|!=
name|e1
condition|)
operator|*
name|e0
operator|=
operator|*
name|e1
expr_stmt|;
name|e0
operator|++
expr_stmt|;
block|}
name|e1
operator|++
expr_stmt|;
block|}
name|uni
operator|->
name|cx
operator|.
name|errcnt
operator|=
name|e0
operator|-
name|uni
operator|->
name|cx
operator|.
name|err
expr_stmt|;
block|}
end_function

end_unit

