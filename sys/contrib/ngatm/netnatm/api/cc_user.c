begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2004  *	Hartmut Brandt  *	All rights reserved.  *  * Copyright (c) 2001-2002  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *  * Redistribution of this software and documentation and use in source and  * binary forms, with or without modification, are permitted provided that  * the following conditions are met:  *  * 1. Redistributions of source code or documentation must retain the above  *    copyright notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE AUTHOR  * AND ITS CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * THE AUTHOR OR ITS CONTRIBUTORS  BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Begemot: libunimsg/netnatm/api/cc_user.c,v 1.2 2004/07/08 09:17:18 brandt Exp $  *  * ATM API as defined per af-saa-0108  *  * User side (upper half)  */
end_comment

begin_include
include|#
directive|include
file|<netnatm/unimsg.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unistruct.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unimsglib.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/unisap.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/unidef.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/atmapi.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccatm.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccpriv.h>
end_include

begin_comment
comment|/* * This file handles messages to a USER. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|stab
index|[]
init|=
block|{
define|#
directive|define
name|DEF
parameter_list|(
name|N
parameter_list|)
value|[N] = #N,
name|USER_STATES
undef|#
directive|undef
name|DEF
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|cc_user_state2str
parameter_list|(
name|u_int
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|>=
sizeof|sizeof
argument_list|(
name|stab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|stab
index|[
literal|0
index|]
argument_list|)
operator|||
name|stab
index|[
name|s
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"?"
operator|)
return|;
return|return
operator|(
name|stab
index|[
name|s
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|set_state
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|enum
name|user_state
name|ns
parameter_list|)
block|{
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|ns
condition|)
block|{
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_STATE
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"%s -> %s"
argument_list|,
name|stab
index|[
name|user
operator|->
name|state
index|]
argument_list|,
name|stab
index|[
name|ns
index|]
argument_list|)
expr_stmt|;
name|user
operator|->
name|state
operator|=
name|ns
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cc_user_send
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|u_int
name|op
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|user
operator|->
name|cc
operator|->
name|funcs
operator|->
name|send_user
argument_list|(
name|user
argument_list|,
name|user
operator|->
name|uarg
argument_list|,
name|op
argument_list|,
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cc_user_ok
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|u_int
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|user
operator|->
name|cc
operator|->
name|funcs
operator|->
name|respond_user
argument_list|(
name|user
argument_list|,
name|user
operator|->
name|uarg
argument_list|,
name|ATMERR_OK
argument_list|,
name|data
argument_list|,
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cc_user_err
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|user
operator|->
name|cc
operator|->
name|funcs
operator|->
name|respond_user
argument_list|(
name|user
argument_list|,
name|user
operator|->
name|uarg
argument_list|,
name|err
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** * * INSTANCE MANAGEMENT */
end_comment

begin_comment
comment|/* * New endpoint created */
end_comment

begin_function
name|struct
name|ccuser
modifier|*
name|cc_user_create
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|,
name|void
modifier|*
name|uarg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ccuser
modifier|*
name|user
decl_stmt|;
name|user
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|user
operator|->
name|cc
operator|=
name|cc
expr_stmt|;
name|user
operator|->
name|state
operator|=
name|USER_NULL
expr_stmt|;
name|user
operator|->
name|uarg
operator|=
name|uarg
expr_stmt|;
name|strncpy
argument_list|(
name|user
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|user
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|user
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|cc
operator|->
name|user_list
argument_list|,
name|user
argument_list|,
name|node_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_INST
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"created with name '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|user
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a user instance  */
end_comment

begin_function
specifier|static
name|void
name|cc_user_reset
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
name|CCASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
argument_list|,
operator|(
literal|"connq not empty"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|sap
operator|!=
name|NULL
condition|)
block|{
name|CCFREE
argument_list|(
name|user
operator|->
name|sap
argument_list|)
expr_stmt|;
name|user
operator|->
name|sap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|user
operator|->
name|accepted
operator|!=
name|NULL
condition|)
block|{
name|user
operator|->
name|accepted
operator|->
name|acceptor
operator|=
name|NULL
expr_stmt|;
name|user
operator|->
name|accepted
operator|=
name|NULL
expr_stmt|;
block|}
name|user
operator|->
name|config
operator|=
name|USER_P2P
expr_stmt|;
name|user
operator|->
name|queue_act
operator|=
literal|0
expr_stmt|;
name|user
operator|->
name|queue_max
operator|=
literal|0
expr_stmt|;
name|user
operator|->
name|aborted
operator|=
literal|0
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_NULL
argument_list|)
expr_stmt|;
name|cc_user_sig_flush
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cc_user_abort
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|uni_ie_cause
modifier|*
name|cause
parameter_list|)
block|{
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
comment|/* 	 * Although the standard state that 'all connections 	 * associated with this endpoint are aborted' we only 	 * have to abort the head one, because in state A6 	 * (call present) the endpoint is only associated to the 	 * head connection - the others are 'somewhere else' and 	 * need to be redispatched. 	 * 	 * First bring user into a state that the connections 	 * are not dispatched back to it. 	 */
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user
operator|->
name|aborted
condition|)
block|{
if|if
condition|(
operator|(
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|conn
operator|->
name|cause
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conn
operator|->
name|cause
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cause
operator|!=
name|NULL
condition|)
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
operator|*
name|cause
expr_stmt|;
name|cc_conn_reset_acceptor
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cc_disconnect_from_user
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_USER_ABORT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* these should be in C21 */
name|cc_disconnect_from_user
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cc_conn_dispatch
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
name|cc_user_reset
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Application has closed this endpoint. Clean up all user resources and  * abort all connections. This can be called in any state.  */
end_comment

begin_function
name|void
name|cc_user_destroy
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_INST
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"destroy '%s'"
argument_list|,
name|user
operator|->
name|name
argument_list|)
expr_stmt|;
name|cc_user_abort
argument_list|(
name|user
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|sap
operator|!=
name|NULL
condition|)
name|CCFREE
argument_list|(
name|user
operator|->
name|sap
argument_list|)
expr_stmt|;
name|cc_user_sig_flush
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|user
argument_list|,
name|node_link
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  * OUTGOING CALLS  */
end_comment

begin_comment
comment|/*  * Return true when the calling address of the connection matches the address.  */
end_comment

begin_function
specifier|static
name|int
name|addr_matches
parameter_list|(
specifier|const
name|struct
name|ccaddr
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IE_ISPRESENT
argument_list|(
name|conn
operator|->
name|calling
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|addr
operator|->
name|addr
operator|.
name|type
operator|==
name|conn
operator|->
name|calling
operator|.
name|addr
operator|.
name|type
operator|&&
name|addr
operator|->
name|addr
operator|.
name|plan
operator|==
name|conn
operator|->
name|calling
operator|.
name|addr
operator|.
name|plan
operator|&&
name|addr
operator|->
name|addr
operator|.
name|len
operator|==
name|conn
operator|->
name|calling
operator|.
name|addr
operator|.
name|len
operator|&&
name|memcmp
argument_list|(
name|addr
operator|->
name|addr
operator|.
name|addr
argument_list|,
name|conn
operator|->
name|calling
operator|.
name|addr
operator|.
name|addr
argument_list|,
name|addr
operator|->
name|addr
operator|.
name|len
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the user's SAP (given he is in the right state) and  * the given SAP overlap  */
end_comment

begin_function
specifier|static
name|int
name|check_overlap
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|struct
name|uni_sap
modifier|*
name|sap
parameter_list|)
block|{
return|return
operator|(
operator|(
name|user
operator|->
name|state
operator|==
name|USER_IN_PREPARING
operator|||
name|user
operator|->
name|state
operator|==
name|USER_IN_WAITING
operator|)
operator|&&
name|unisve_overlap_sap
argument_list|(
name|user
operator|->
name|sap
argument_list|,
name|sap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send arrival notification to user  */
end_comment

begin_function
specifier|static
name|void
name|do_arrival
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|user
operator|->
name|aborted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_ARRIVED
argument_list|)
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_ARRIVAL_OF_INCOMING_CALL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_ARRIVAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  *  * ATTRIBUTES  */
end_comment

begin_comment
comment|/*  * Query an attribute. This is possible only in some states: preparation  * of an outgoing call, after an incoming call was offered to the application  * and in the three active states (P2P, P2PLeaf, P2PRoot).  */
end_comment

begin_function
specifier|static
name|struct
name|ccconn
modifier|*
name|cc_query_check
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_PREPARING
case|:
case|case
name|USER_IN_ARRIVED
case|:
case|case
name|USER_ACTIVE
case|:
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
operator|)
return|;
case|case
name|USER_NULL
case|:
comment|/* if we are waiting for the SETUP_confirm, we are in 		 * the NULL state still (we are the new endpoint), but 		 * have a connection in 'accepted' that is in the 		 * CONN_IN_WAIT_ACCEPT_OK state. 		 */
if|if
condition|(
name|user
operator|->
name|accepted
operator|!=
name|NULL
operator|&&
name|user
operator|->
name|accepted
operator|->
name|state
operator|==
name|CONN_IN_WAIT_ACCEPT_OK
condition|)
return|return
operator|(
name|user
operator|->
name|accepted
operator|)
return|;
comment|/* FALLTHRU */
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Query attributes  */
end_comment

begin_function
specifier|static
name|void
name|cc_attr_query
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|uint32_t
modifier|*
name|attr
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|void
modifier|*
name|val
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|total
decl_stmt|,
name|len
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|atab
decl_stmt|;
comment|/* determine the length of the total attribute buffer */
name|total
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|atm_attribute
operator|)
name|attr
index|[
name|i
index|]
condition|)
block|{
case|case
name|ATM_ATTR_NONE
case|:
break|break;
case|case
name|ATM_ATTR_BLLI_SELECTOR
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_BLLI
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_blli
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_BEARER
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_bearer
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_TRAFFIC
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_traffic
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_QOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_qos
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EXQOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_exqos
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLED
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_called
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLEDSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calledsub
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLING
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calling
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLINGSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_callingsub
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_AAL
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_aal
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EPREF
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_epref
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNED
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_conned
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNEDSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connedsub
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EETD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_eetd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRSETUP
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abrsetup
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRADD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abradd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNID
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_MDCR
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_mdcr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_ATTR
argument_list|)
expr_stmt|;
return|return;
block|}
name|total
operator|+=
name|len
expr_stmt|;
block|}
comment|/* allocate buffer */
name|val
operator|=
name|CCMALLOC
argument_list|(
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return;
name|atab
operator|=
name|val
expr_stmt|;
name|atab
index|[
literal|0
index|]
operator|=
name|count
expr_stmt|;
comment|/* fill */
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|val
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|atab
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|attr
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|attr
index|[
name|i
index|]
condition|)
block|{
case|case
name|ATM_ATTR_NONE
case|:
break|break;
case|case
name|ATM_ATTR_BLLI_SELECTOR
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|blli_selector
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_BLLI
case|:
comment|/* in A6 the blli_selector may be 0 when 			 * there was no blli in the SETUP. 			 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_blli
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|blli_selector
operator|==
literal|0
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|blli
index|[
name|conn
operator|->
name|blli_selector
operator|-
literal|1
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_BEARER
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_bearer
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|bearer
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_TRAFFIC
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_traffic
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|traffic
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_QOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_qos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|qos
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EXQOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_exqos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|exqos
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLED
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_called
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|called
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLEDSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calledsub
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|calledsub
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLING
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calling
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|calling
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLINGSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_callingsub
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|callingsub
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_AAL
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_aal
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|aal
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EPREF
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_epref
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|epref
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNED
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_conned
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|conned
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNEDSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connedsub
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|connedsub
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EETD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_eetd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|eetd
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRSETUP
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abrsetup
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|abrsetup
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRADD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abradd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|abradd
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNID
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|connid
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_MDCR
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_mdcr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|conn
operator|->
name|mdcr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ptr
operator|+
name|len
expr_stmt|;
block|}
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_ATTRS
argument_list|,
name|val
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check whether the state is ok and return the connection  */
end_comment

begin_function
specifier|static
name|struct
name|ccconn
modifier|*
name|cc_set_check
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_PREPARING
case|:
case|case
name|USER_IN_ARRIVED
case|:
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set connection attribute(s)  */
end_comment

begin_function
specifier|static
name|void
name|cc_attr_set
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|uint32_t
modifier|*
name|attr
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_char
modifier|*
name|val
parameter_list|,
name|size_t
name|vallen
parameter_list|)
block|{
name|size_t
name|total
decl_stmt|,
name|len
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
comment|/* determine the length of the total attribute buffer */
name|total
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|atm_attribute
operator|)
name|attr
index|[
name|i
index|]
condition|)
block|{
case|case
name|ATM_ATTR_NONE
case|:
break|break;
case|case
name|ATM_ATTR_BLLI_SELECTOR
case|:
block|{
name|uint32_t
name|sel
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|memcpy
argument_list|(
operator|&
name|sel
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sel
operator|==
literal|0
operator|||
name|sel
operator|>
name|UNI_NUM_IE_BLLI
condition|)
goto|goto
name|bad_val
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ATM_ATTR_BLLI
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_blli
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_BEARER
case|:
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_bearer
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_TRAFFIC
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_traffic
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_QOS
case|:
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_qos
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EXQOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_exqos
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLED
case|:
goto|goto
name|rdonly
goto|;
case|case
name|ATM_ATTR_CALLEDSUB
case|:
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calledsub
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLING
case|:
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calling
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLINGSUB
case|:
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_callingsub
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_AAL
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_aal
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EPREF
case|:
goto|goto
name|rdonly
goto|;
case|case
name|ATM_ATTR_CONNED
case|:
goto|goto
name|rdonly
goto|;
case|case
name|ATM_ATTR_CONNEDSUB
case|:
goto|goto
name|rdonly
goto|;
case|case
name|ATM_ATTR_EETD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_eetd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRSETUP
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abrsetup
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRADD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abradd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNID
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_MDCR
case|:
if|if
condition|(
name|conn
operator|->
name|state
operator|!=
name|CONN_OUT_PREPARING
condition|)
goto|goto
name|rdonly
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_mdcr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_ATTR
argument_list|)
expr_stmt|;
return|return;
block|}
name|total
operator|+=
name|len
expr_stmt|;
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
comment|/* check the length */
if|if
condition|(
name|vallen
operator|!=
name|total
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_ARGS
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
expr|enum
name|atm_attribute
operator|)
name|attr
index|[
name|i
index|]
condition|)
block|{
case|case
name|ATM_ATTR_NONE
case|:
break|break;
case|case
name|ATM_ATTR_BLLI_SELECTOR
case|:
block|{
name|uint32_t
name|sel
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|sel
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|conn
operator|->
name|blli_selector
operator|=
name|sel
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ATM_ATTR_BLLI
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_blli
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|blli
index|[
name|conn
operator|->
name|blli_selector
operator|-
literal|1
index|]
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_BLLI
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_BEARER
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_bearer
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|bearer
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_TRAFFIC
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_traffic
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|traffic
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_TRAFFIC
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_QOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_qos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|qos
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EXQOS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_exqos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|exqos
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_EXQOS
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLED
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_called
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLEDSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calledsub
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|calledsub
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLING
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_calling
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|calling
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CALLINGSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_callingsub
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|callingsub
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_AAL
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_aal
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|aal
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_AAL
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EPREF
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_epref
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNED
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_conned
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNEDSUB
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connedsub
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_EETD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_eetd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|eetd
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_EETD
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRSETUP
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abrsetup
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|abrsetup
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_ABRSETUP
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_ABRADD
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_abradd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|abradd
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_ABRADD
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_CONNID
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_connid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|connid
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conn
operator|->
name|dirty_attr
operator||=
name|CCDIRTY_CONNID
expr_stmt|;
break|break;
case|case
name|ATM_ATTR_MDCR
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uni_ie_mdcr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|conn
operator|->
name|mdcr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|bad_val
label|:
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_VALUE
argument_list|)
expr_stmt|;
return|return;
name|rdonly
label|:
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_RDONLY
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CCATM_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|op_names
index|[]
init|=
block|{
define|#
directive|define
name|S
parameter_list|(
name|OP
parameter_list|)
value|[ATMOP_##OP] = #OP
name|S
argument_list|(
name|RESP
argument_list|)
block|,
name|S
argument_list|(
name|ABORT_CONNECTION
argument_list|)
block|,
name|S
argument_list|(
name|ACCEPT_INCOMING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|ADD_PARTY
argument_list|)
block|,
name|S
argument_list|(
name|ADD_PARTY_REJECT
argument_list|)
block|,
name|S
argument_list|(
name|ADD_PARTY_SUCCESS
argument_list|)
block|,
name|S
argument_list|(
name|ARRIVAL_OF_INCOMING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|CALL_RELEASE
argument_list|)
block|,
name|S
argument_list|(
name|CONNECT_OUTGOING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|DROP_PARTY
argument_list|)
block|,
name|S
argument_list|(
name|GET_LOCAL_PORT_INFO
argument_list|)
block|,
name|S
argument_list|(
name|P2MP_CALL_ACTIVE
argument_list|)
block|,
name|S
argument_list|(
name|P2P_CALL_ACTIVE
argument_list|)
block|,
name|S
argument_list|(
name|PREPARE_INCOMING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|PREPARE_OUTGOING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|QUERY_CONNECTION_ATTRIBUTES
argument_list|)
block|,
name|S
argument_list|(
name|REJECT_INCOMING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|SET_CONNECTION_ATTRIBUTES
argument_list|)
block|,
name|S
argument_list|(
name|WAIT_ON_INCOMING_CALL
argument_list|)
block|,
name|S
argument_list|(
name|SET_CONNECTION_ATTRIBUTES_X
argument_list|)
block|,
name|S
argument_list|(
name|QUERY_CONNECTION_ATTRIBUTES_X
argument_list|)
block|,
name|S
argument_list|(
name|QUERY_STATE
argument_list|)
block|,
undef|#
directive|undef
name|S
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Signal from user - map this to our internal signals and queue  * the mapped signal.  */
end_comment

begin_function
name|int
name|cc_user_signal
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|enum
name|atmop
name|sig
parameter_list|,
name|struct
name|uni_msg
modifier|*
name|msg
parameter_list|)
block|{
name|size_t
name|len
init|=
name|uni_msg_len
argument_list|(
name|msg
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_SIG
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"signal %s to user"
argument_list|,
name|op_names
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|sig
operator|>
name|ATMOP_QUERY_STATE
condition|)
goto|goto
name|bad_signal
goto|;
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|ATMOP_ABORT_CONNECTION
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_abort_connection
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_ABORT_CONNECTION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_ACCEPT_INCOMING_CALL
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_accept_incoming_call
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_ACCEPT_INCOMING
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_ADD_PARTY
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_add_party
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_ADD_PARTY
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_CALL_RELEASE
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_call_release
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_CALL_RELEASE
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_CONNECT_OUTGOING_CALL
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_connect_outgoing_call
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_CONNECT_OUTGOING
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_DROP_PARTY
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_drop_party
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_DROP_PARTY
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_GET_LOCAL_PORT_INFO
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_get_local_port_info
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_GET_LOCAL_PORT_INFO
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_PREPARE_INCOMING_CALL
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_prepare_incoming_call
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_PREPARE_INCOMING
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_PREPARE_OUTGOING_CALL
case|:
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad_len
goto|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err
operator|=
name|cc_user_sig
argument_list|(
name|user
argument_list|,
name|USER_SIG_PREPARE_OUTGOING
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_QUERY_CONNECTION_ATTRIBUTES
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_query_connection_attributes
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_QUERY_ATTR
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_REJECT_INCOMING_CALL
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|atm_reject_incoming_call
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_REJECT_INCOMING
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_SET_CONNECTION_ATTRIBUTES
case|:
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|atm_set_connection_attributes
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_SET_ATTR
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_WAIT_ON_INCOMING_CALL
case|:
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad_len
goto|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err
operator|=
name|cc_user_sig
argument_list|(
name|user
argument_list|,
name|USER_SIG_WAIT_ON_INCOMING
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_QUERY_CONNECTION_ATTRIBUTES_X
case|:
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|atm_set_connection_attributes_x
argument_list|)
operator|||
name|len
operator|!=
name|offsetof
argument_list|(
expr|struct
name|atm_set_connection_attributes_x
argument_list|,
name|attr
argument_list|)
operator|+
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_set_connection_attributes_x
operator|*
argument_list|)
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_QUERY_ATTR_X
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_SET_CONNECTION_ATTRIBUTES_X
case|:
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|atm_set_connection_attributes_x
argument_list|)
condition|)
goto|goto
name|bad_len
goto|;
name|err
operator|=
name|cc_user_sig_msg
argument_list|(
name|user
argument_list|,
name|USER_SIG_SET_ATTR_X
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_QUERY_STATE
case|:
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad_len
goto|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|err
operator|=
name|cc_user_sig
argument_list|(
name|user
argument_list|,
name|USER_SIG_QUERY_STATE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMOP_RESP
case|:
case|case
name|ATMOP_ADD_PARTY_REJECT
case|:
case|case
name|ATMOP_ADD_PARTY_SUCCESS
case|:
case|case
name|ATMOP_ARRIVAL_OF_INCOMING_CALL
case|:
case|case
name|ATMOP_P2MP_CALL_ACTIVE
case|:
case|case
name|ATMOP_P2P_CALL_ACTIVE
case|:
name|bad_signal
label|:
comment|/* bad signal */
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_SIG
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"bad signal %u"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_OP
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
name|bad_len
label|:
comment|/* bad argument length */
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_SIG
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"signal %s had bad len=%zu"
argument_list|,
name|op_names
index|[
name|sig
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_ARGS
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send active signal to user  */
end_comment

begin_function
specifier|static
name|void
name|cc_user_active
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|ccconn
modifier|*
name|conn
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
decl_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|bearer
operator|.
name|cfg
operator|==
name|UNI_BEARER_P2P
condition|)
block|{
name|struct
name|atm_p2p_call_active
modifier|*
name|act
decl_stmt|;
name|user
operator|->
name|config
operator|=
name|USER_P2P
expr_stmt|;
name|act
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|NULL
condition|)
return|return;
name|act
operator|->
name|connid
operator|=
name|conn
operator|->
name|connid
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_P2P_CALL_ACTIVE
argument_list|,
name|act
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|atm_p2mp_call_active
modifier|*
name|act
decl_stmt|;
name|user
operator|->
name|config
operator|=
name|USER_ROOT
expr_stmt|;
name|act
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|NULL
condition|)
return|return;
name|act
operator|->
name|connid
operator|=
name|conn
operator|->
name|connid
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_P2MP_CALL_ACTIVE
argument_list|,
name|act
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* * Handle a signal to this user */
end_comment

begin_function
name|void
name|cc_user_sig_handle
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|enum
name|user_sig
name|sig
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_int
name|arg2
parameter_list|)
block|{
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_SIG
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"signal %s to user state %s"
argument_list|,
name|cc_user_sigtab
index|[
name|sig
index|]
argument_list|,
name|stab
index|[
name|user
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|USER_SIG_PREPARE_OUTGOING
case|:
block|{
comment|/* 		 * Here we create a connection for the call we soon will make. 		 * We put this call on the list of orphaned connections, 		 * because we don't know yet, which port will get the 		 * connection. It is assigned, when the user issues the call 		 * to connect. 		 */
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
goto|goto
name|bad_state
goto|;
block|}
name|conn
operator|=
name|cc_conn_create
argument_list|(
name|user
operator|->
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_NOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_OUT_PREPARING
argument_list|)
expr_stmt|;
name|cc_conn_set_state
argument_list|(
name|conn
argument_list|,
name|CONN_OUT_PREPARING
argument_list|)
expr_stmt|;
name|conn
operator|->
name|blli_selector
operator|=
literal|1
expr_stmt|;
name|cc_connect_to_user
argument_list|(
name|conn
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_CONNECT_OUTGOING
case|:
block|{
comment|/* 		 * Request to connect that call 		 * 		 * Here we assign the connection to a port. 		 */
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_connect_outgoing_call
modifier|*
name|req
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_connect_outgoing_call
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ccdata
modifier|*
name|priv
init|=
name|user
operator|->
name|cc
decl_stmt|;
name|struct
name|ccport
modifier|*
name|port
decl_stmt|;
name|struct
name|ccaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_OUT_PREPARING
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
goto|goto
name|bad_state
goto|;
block|}
if|if
condition|(
operator|!
name|IE_ISPRESENT
argument_list|(
name|req
operator|->
name|called
argument_list|)
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_ARGS
argument_list|)
expr_stmt|;
return|return;
block|}
name|CCASSERT
argument_list|(
name|conn
operator|->
name|port
operator|==
name|NULL
argument_list|,
operator|(
literal|"connection still on port"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|port_list
argument_list|)
condition|)
block|{
comment|/* 			 * We have no ports - reject 			 */
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_PORT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Find the correct port 		 * Routing of outgoing calls goes to the lowest numbered port 		 * with a matching address or, if no address match is found to 		 * the lowest numbered port. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&priv->port_list
argument_list|,
argument|node_link
argument_list|)
name|TAILQ_FOREACH
argument_list|(
argument|addr
argument_list|,
argument|&port->addr_list
argument_list|,
argument|port_link
argument_list|)
if|if
condition|(
name|addr_matches
argument_list|(
name|addr
argument_list|,
name|conn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
name|port
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|port_list
argument_list|)
expr_stmt|;
name|cc_conn_ins_port
argument_list|(
name|conn
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|conn
operator|->
name|called
operator|=
name|req
operator|->
name|called
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* 		 * Now move the state 		 */
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_OUT_WAIT_OK
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_CONNECT_OUTGOING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_CONNECT_OUTGOING_ERR
case|:
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_WAIT_OK
case|:
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_OUT_PREPARING
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REL_WAIT_CONN
case|:
block|{
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|!=
name|NULL
condition|)
block|{
name|cc_disconnect_from_user
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|cc_conn_destroy
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
name|cc_user_reset
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
goto|goto
name|bad_state
goto|;
block|}
return|return;
case|case
name|USER_SIG_CONNECT_OUTGOING_OK
case|:
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_WAIT_OK
case|:
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_OUT_WAIT_CONF
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REL_WAIT_CONN
case|:
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_REL_WAIT_SCONF
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_state
goto|;
block|}
return|return;
case|case
name|USER_SIG_SETUP_CONFIRM
case|:
comment|/* 		 * SETUP.confirm from UNI stack. 		 */
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_WAIT_CONF
case|:
name|cc_user_active
argument_list|(
name|user
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REL_WAIT_SCONF
case|:
comment|/* now try to release */
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_REL_WAIT_CONF
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
argument_list|,
name|CONN_SIG_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_state
goto|;
block|}
return|return;
case|case
name|USER_SIG_PREPARE_INCOMING
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|ccuser
modifier|*
name|ptr
decl_stmt|;
name|struct
name|atm_prepare_incoming_call
modifier|*
name|prep
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_prepare_incoming_call
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_NULL
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
goto|goto
name|bad_state
goto|;
block|}
comment|/* 		 * Check the SAP 		 */
if|if
condition|(
name|unisve_check_sap
argument_list|(
operator|&
name|prep
operator|->
name|sap
argument_list|)
operator|!=
name|UNISVE_OK
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_SAP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Loop through all incoming calls and check whether there 		 * is an overlap in SAP space. 		 */
name|LIST_FOREACH
argument_list|(
argument|ptr
argument_list|,
argument|&user->cc->user_list
argument_list|,
argument|node_link
argument_list|)
block|{
if|if
condition|(
name|check_overlap
argument_list|(
name|ptr
argument_list|,
operator|&
name|prep
operator|->
name|sap
argument_list|)
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_OVERLAP
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 		 * Save info and set state 		 */
name|user
operator|->
name|sap
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uni_sap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|sap
operator|==
name|NULL
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_NOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|user
operator|->
name|sap
operator|=
name|prep
operator|->
name|sap
expr_stmt|;
name|user
operator|->
name|queue_max
operator|=
name|prep
operator|->
name|queue_size
expr_stmt|;
name|user
operator|->
name|queue_act
operator|=
literal|0
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_PREPARING
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_WAIT_ON_INCOMING
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_PREPARING
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
goto|goto
name|bad_state
goto|;
block|}
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_SETUP_IND
case|:
comment|/* 		 * New connection queued up in the queue. If this is the 		 * first one, inform the application of the arrival. 		 */
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_IN_WAITING
case|:
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_IN_ARRIVED
case|:
case|case
name|USER_IN_WAIT_REJ
case|:
case|case
name|USER_IN_WAIT_ACC
case|:
break|break;
default|default:
goto|goto
name|bad_state
goto|;
block|}
return|return;
case|case
name|USER_SIG_REJECT_INCOMING
case|:
block|{
comment|/* 		 * User rejects call. This is done on the OLD user 		 * (i.e. the one sending the arrival). 		 */
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_reject_incoming_call
modifier|*
name|rej
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_reject_incoming_call
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_ARRIVED
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
goto|goto
name|bad_state
goto|;
block|}
if|if
condition|(
name|user
operator|->
name|aborted
condition|)
block|{
comment|/* connection has disappeared. Send an ok 			 * to the user and lock whether there is another 			 * connection at this endpoint */
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
name|rej
operator|->
name|cause
expr_stmt|;
name|memset
argument_list|(
operator|&
name|conn
operator|->
name|cause
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conn
operator|->
name|cause
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAIT_REJ
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_REJECT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_REJECT_OK
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_WAIT_REJ
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_REJECT_ERR
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_WAIT_REJ
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_ARRIVED
argument_list|)
expr_stmt|;
else|else
block|{
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|USER_SIG_ACCEPT_INCOMING
case|:
block|{
comment|/* 		 * User accepts call. This is done on the OLD user (i.e. the one 		 * sending the arrival), the message contains a pointer to the 		 * new endpoint. 		 */
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_accept_incoming_call
modifier|*
name|acc
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_accept_incoming_call
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ccuser
modifier|*
name|newep
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_ARRIVED
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|user
operator|->
name|aborted
condition|)
block|{
comment|/* connection has disappeared. Send an error 			 * to the user and lock whether there is another 			 * connection at this endpoint */
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_PREVIOUSLY_ABORTED
argument_list|)
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
name|acc
operator|->
name|newep
index|[
sizeof|sizeof
argument_list|(
name|acc
operator|->
name|newep
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|newep
argument_list|,
argument|&user->cc->user_list
argument_list|,
argument|node_link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|acc
operator|->
name|newep
argument_list|,
name|newep
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|newep
operator|==
name|NULL
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_ENDPOINT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|newep
operator|->
name|state
operator|!=
name|USER_NULL
operator|||
name|newep
operator|->
name|accepted
operator|!=
name|NULL
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAIT_ACC
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
argument_list|,
name|CONN_SIG_ACCEPT
argument_list|,
name|newep
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_ACCEPT_OK
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_WAIT_ACC
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_ACCEPT_ERR
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_WAIT_ACC
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
block|{
comment|/* arg used as flag! */
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_ARRIVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_WAITING
argument_list|)
expr_stmt|;
name|do_arrival
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|USER_SIG_ACCEPTING
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_NULL
condition|)
goto|goto
name|bad_state
goto|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_ACCEPTING
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_SETUP_COMPL
case|:
block|{
name|struct
name|ccconn
modifier|*
name|conn
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_IN_ACCEPTING
condition|)
goto|goto
name|bad_state
goto|;
name|user
operator|->
name|state
operator|=
name|USER_ACTIVE
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|bearer
operator|.
name|cfg
operator|==
name|UNI_BEARER_P2P
condition|)
block|{
name|struct
name|atm_p2p_call_active
modifier|*
name|act
decl_stmt|;
name|user
operator|->
name|config
operator|=
name|USER_P2P
expr_stmt|;
name|act
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|NULL
condition|)
return|return;
name|act
operator|->
name|connid
operator|=
name|conn
operator|->
name|connid
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_P2P_CALL_ACTIVE
argument_list|,
name|act
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|atm_p2mp_call_active
modifier|*
name|act
decl_stmt|;
name|user
operator|->
name|config
operator|=
name|USER_LEAF
expr_stmt|;
name|act
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|NULL
condition|)
return|return;
name|act
operator|->
name|connid
operator|=
name|conn
operator|->
name|connid
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_P2MP_CALL_ACTIVE
argument_list|,
name|act
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|USER_SIG_CALL_RELEASE
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_call_release
modifier|*
name|api
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_call_release
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_WAIT_OK
case|:
comment|/* U2/A3 */
comment|/* wait for CONN_OK first */
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|0
index|]
expr_stmt|;
name|conn
operator|->
name|cause
index|[
literal|1
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|1
index|]
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_REL_WAIT_CONN
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_OUT_WAIT_CONF
case|:
comment|/* U3/A3 */
comment|/* wait for SETUP.confirm first */
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|0
index|]
expr_stmt|;
name|conn
operator|->
name|cause
index|[
literal|1
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|1
index|]
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_REL_WAIT_SCONF
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_IN_ACCEPTING
case|:
comment|/* U11/A7 */
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|0
index|]
expr_stmt|;
name|conn
operator|->
name|cause
index|[
literal|1
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|1
index|]
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_REL_WAIT_SCOMP
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_ACTIVE
case|:
comment|/* U4/A8,A9,A10 */
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|0
index|]
expr_stmt|;
name|conn
operator|->
name|cause
index|[
literal|1
index|]
operator|=
name|api
operator|->
name|cause
index|[
literal|1
index|]
expr_stmt|;
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_REL_WAIT
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
goto|goto
name|bad_state
goto|;
block|}
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_RELEASE_CONFIRM
case|:
block|{
name|struct
name|atm_call_release
modifier|*
name|ind
decl_stmt|;
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_OUT_WAIT_CONF
case|:
comment|/* U3/A3 */
case|case
name|USER_ACTIVE
case|:
comment|/* U4/A8,A9,A10 */
name|cc_user_reset
argument_list|(
name|user
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REL_WAIT
case|:
comment|/* U5 /A8,A9,A10 */
case|case
name|USER_REL_WAIT_SCOMP
case|:
comment|/* U12/A7 */
case|case
name|USER_REL_WAIT_SCONF
case|:
comment|/* U13/A3 */
case|case
name|USER_REL_WAIT_CONF
case|:
comment|/* U14/A3 */
name|cc_user_reset
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_IN_ACCEPTING
case|:
comment|/* U11/A7 */
name|cc_user_reset
argument_list|(
name|user
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_state
goto|;
block|}
name|ind
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|ind
operator|->
name|cause
argument_list|,
name|user
operator|->
name|cause
argument_list|,
sizeof|sizeof
argument_list|(
name|ind
operator|->
name|cause
argument_list|)
argument_list|)
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_CALL_RELEASE
argument_list|,
name|ind
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ind
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|ind
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_RELEASE_ERR
case|:
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_REL_WAIT
case|:
comment|/* U5/A8,A9,A10 */
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_ACTIVE
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATM_MKUNIERR
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REL_WAIT_CONF
case|:
comment|/* U14/A3 */
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATM_MKUNIERR
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|cc_user_active
argument_list|(
name|user
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REL_WAIT_SCOMP
case|:
comment|/* U12/A7 */
name|set_state
argument_list|(
name|user
argument_list|,
name|USER_IN_ACCEPTING
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATM_MKUNIERR
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_state
goto|;
block|}
return|return;
case|case
name|USER_SIG_ADD_PARTY
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_add_party
modifier|*
name|add
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_add_party
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
operator|||
name|user
operator|->
name|config
operator|!=
name|USER_ROOT
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|add
operator|->
name|leaf_ident
operator|==
literal|0
operator|||
name|add
operator|->
name|leaf_ident
operator|>=
literal|32786
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_LEAF_IDENT
argument_list|)
expr_stmt|;
return|return;
block|}
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
expr_stmt|;
name|conn
operator|->
name|called
operator|=
name|add
operator|->
name|called
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_ADD_PARTY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|add
operator|->
name|leaf_ident
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_ADD_PARTY_ERR
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_ADD_PARTY_OK
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_ADD_PARTY_ACK
case|:
block|{
name|u_int
name|leaf_ident
init|=
name|arg2
decl_stmt|;
name|struct
name|atm_add_party_success
modifier|*
name|succ
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|succ
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|succ
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|succ
operator|==
name|NULL
condition|)
return|return;
name|succ
operator|->
name|leaf_ident
operator|=
name|leaf_ident
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_ADD_PARTY_SUCCESS
argument_list|,
name|succ
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|succ
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|succ
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_ADD_PARTY_REJ
case|:
block|{
name|u_int
name|leaf_ident
init|=
name|arg2
decl_stmt|;
name|struct
name|atm_add_party_reject
modifier|*
name|reject
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|reject
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reject
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
operator|==
name|NULL
condition|)
return|return;
name|reject
operator|->
name|leaf_ident
operator|=
name|leaf_ident
expr_stmt|;
name|reject
operator|->
name|cause
operator|=
name|user
operator|->
name|cause
index|[
literal|0
index|]
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_ADD_PARTY_REJECT
argument_list|,
name|reject
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reject
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|reject
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_DROP_PARTY
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_drop_party
modifier|*
name|drop
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_drop_party
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
operator|||
name|user
operator|->
name|config
operator|!=
name|USER_ROOT
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|drop
operator|->
name|leaf_ident
operator|>=
literal|32786
condition|)
block|{
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_LEAF_IDENT
argument_list|)
expr_stmt|;
return|return;
block|}
name|conn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|user
operator|->
name|connq
argument_list|)
expr_stmt|;
name|conn
operator|->
name|cause
index|[
literal|0
index|]
operator|=
name|drop
operator|->
name|cause
expr_stmt|;
name|memset
argument_list|(
operator|&
name|conn
operator|->
name|cause
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conn
operator|->
name|cause
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cc_conn_sig
argument_list|(
name|conn
argument_list|,
name|CONN_SIG_DROP_PARTY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|drop
operator|->
name|leaf_ident
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_DROP_PARTY_ERR
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_DROP_PARTY_OK
case|:
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|USER_SIG_DROP_PARTY_IND
case|:
block|{
name|u_int
name|leaf_ident
init|=
name|arg2
decl_stmt|;
name|struct
name|atm_drop_party
modifier|*
name|drop
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|state
operator|!=
name|USER_ACTIVE
condition|)
goto|goto
name|bad_state
goto|;
name|drop
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|drop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop
operator|==
name|NULL
condition|)
return|return;
name|drop
operator|->
name|leaf_ident
operator|=
name|leaf_ident
expr_stmt|;
name|drop
operator|->
name|cause
operator|=
name|user
operator|->
name|cause
index|[
literal|0
index|]
expr_stmt|;
name|cc_user_send
argument_list|(
name|user
argument_list|,
name|ATMOP_DROP_PARTY
argument_list|,
name|drop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drop
argument_list|)
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|drop
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_QUERY_ATTR
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_query_connection_attributes
modifier|*
name|req
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|aborted
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_PREVIOUSLY_ABORTED
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|conn
operator|=
name|cc_query_check
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_query_connection_attributes
operator|*
argument_list|)
expr_stmt|;
name|cc_attr_query
argument_list|(
name|user
argument_list|,
name|conn
argument_list|,
operator|&
name|req
operator|->
name|attr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_QUERY_ATTR_X
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_query_connection_attributes_x
modifier|*
name|req
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|conn
operator|=
name|cc_query_check
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_query_connection_attributes_x
operator|*
argument_list|)
expr_stmt|;
name|cc_attr_query
argument_list|(
name|user
argument_list|,
name|conn
argument_list|,
name|req
operator|->
name|attr
argument_list|,
name|req
operator|->
name|count
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_SET_ATTR
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_set_connection_attributes
modifier|*
name|req
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
if|if
condition|(
name|user
operator|->
name|aborted
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_PREVIOUSLY_ABORTED
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|conn
operator|=
name|cc_set_check
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_set_connection_attributes
operator|*
argument_list|)
expr_stmt|;
name|cc_attr_set
argument_list|(
name|user
argument_list|,
name|conn
argument_list|,
operator|&
name|req
operator|->
name|attr
argument_list|,
literal|1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|(
name|req
operator|+
literal|1
operator|)
argument_list|,
name|uni_msg_len
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_SET_ATTR_X
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_set_connection_attributes_x
modifier|*
name|req
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|conn
operator|=
name|cc_set_check
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_BAD_STATE
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_set_connection_attributes_x
operator|*
argument_list|)
expr_stmt|;
name|cc_attr_set
argument_list|(
name|user
argument_list|,
name|conn
argument_list|,
name|req
operator|->
name|attr
argument_list|,
name|req
operator|->
name|count
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|req
operator|->
name|attr
operator|+
name|req
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|req
operator|->
name|attr
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|uni_msg_len
argument_list|(
name|msg
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|atm_set_connection_attributes_x
argument_list|,
name|attr
argument_list|)
operator|-
name|req
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|req
operator|->
name|attr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_QUERY_STATE
case|:
block|{
name|struct
name|atm_epstate
name|state
decl_stmt|;
name|strcpy
argument_list|(
name|state
operator|.
name|name
argument_list|,
name|user
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|user
operator|->
name|state
condition|)
block|{
case|case
name|USER_NULL
case|:
if|if
condition|(
name|user
operator|->
name|accepted
operator|!=
name|NULL
condition|)
name|state
operator|.
name|state
operator|=
name|ATM_A7
expr_stmt|;
else|else
name|state
operator|.
name|state
operator|=
name|ATM_A1
expr_stmt|;
break|break;
case|case
name|USER_OUT_PREPARING
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A2
expr_stmt|;
break|break;
case|case
name|USER_OUT_WAIT_OK
case|:
case|case
name|USER_OUT_WAIT_CONF
case|:
case|case
name|USER_REL_WAIT_SCONF
case|:
case|case
name|USER_REL_WAIT_CONF
case|:
case|case
name|USER_REL_WAIT_CONN
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A3
expr_stmt|;
break|break;
case|case
name|USER_ACTIVE
case|:
case|case
name|USER_REL_WAIT
case|:
switch|switch
condition|(
name|user
operator|->
name|config
condition|)
block|{
case|case
name|USER_P2P
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A8
expr_stmt|;
break|break;
case|case
name|USER_ROOT
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A9
expr_stmt|;
break|break;
case|case
name|USER_LEAF
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A10
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|USER_IN_PREPARING
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A4
expr_stmt|;
break|break;
case|case
name|USER_IN_WAITING
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A5
expr_stmt|;
break|break;
case|case
name|USER_IN_ARRIVED
case|:
case|case
name|USER_IN_WAIT_REJ
case|:
case|case
name|USER_IN_WAIT_ACC
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A6
expr_stmt|;
break|break;
case|case
name|USER_IN_ACCEPTING
case|:
case|case
name|USER_REL_WAIT_SCOMP
case|:
name|state
operator|.
name|state
operator|=
name|ATM_A7
expr_stmt|;
break|break;
block|}
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_STATE
argument_list|,
operator|&
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_GET_LOCAL_PORT_INFO
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_port_list
modifier|*
name|list
decl_stmt|;
name|size_t
name|list_len
decl_stmt|;
name|list
operator|=
name|cc_get_local_port_info
argument_list|(
name|user
operator|->
name|cc
argument_list|,
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_get_local_port_info
operator|*
argument_list|)
operator|->
name|port
argument_list|,
operator|&
name|list_len
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|cc_user_err
argument_list|(
name|user
argument_list|,
name|ATMERR_NOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_PORTS
argument_list|,
name|list
argument_list|,
name|list_len
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|USER_SIG_ABORT_CONNECTION
case|:
block|{
name|struct
name|uni_msg
modifier|*
name|msg
init|=
name|arg
decl_stmt|;
name|struct
name|atm_abort_connection
modifier|*
name|abo
init|=
name|uni_msg_rptr
argument_list|(
name|msg
argument_list|,
expr|struct
name|atm_abort_connection
operator|*
argument_list|)
decl_stmt|;
name|cc_user_abort
argument_list|(
name|user
argument_list|,
operator|&
name|abo
operator|->
name|cause
argument_list|)
expr_stmt|;
name|uni_msg_destroy
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cc_user_ok
argument_list|(
name|user
argument_list|,
name|ATMRESP_NONE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_SIG
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"bad signal=%u in state=%u"
argument_list|,
name|sig
argument_list|,
name|user
operator|->
name|state
argument_list|)
expr_stmt|;
return|return;
name|bad_state
label|:
if|if
condition|(
name|user
operator|->
name|cc
operator|->
name|log
operator|&
name|CCLOG_USER_SIG
condition|)
name|cc_user_log
argument_list|(
name|user
argument_list|,
literal|"bad state=%u for signal=%u"
argument_list|,
name|user
operator|->
name|state
argument_list|,
name|sig
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

