begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* * Copyright (c) 2004 *	Hartmut Brandt *	All rights reserved. * * Author: Harti Brandt<harti@freebsd.org> * * Redistribution of this software and documentation and use in source and * binary forms, with or without modification, are permitted provided that * the following conditions are met: * * 1. Redistributions of source code or documentation must retain the above *    copyright notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE AUTHOR * AND ITS CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL * THE AUTHOR OR ITS CONTRIBUTORS  BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * $Begemot: libunimsg/netnatm/api/cc_sig.c,v 1.1 2004/07/08 08:21:54 brandt Exp $ * * ATM API as defined per af-saa-0108 * * Generic signal handling */
end_comment

begin_include
include|#
directive|include
file|<netnatm/unimsg.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unistruct.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unimsglib.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/unisap.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/unidef.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/atmapi.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccatm.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccpriv.h>
end_include

begin_enum
enum|enum
block|{
name|SIG_USER
block|,
name|SIG_CONN
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ccsig
block|{
name|u_char
name|type
decl_stmt|;
comment|/* type of target */
name|u_char
name|has_msg
decl_stmt|;
comment|/* arg1 is a message */
name|void
modifier|*
name|target
decl_stmt|;
comment|/* target instance */
name|u_int
name|sig
decl_stmt|;
comment|/* signal */
name|void
modifier|*
name|arg1
decl_stmt|;
comment|/* argument */
name|u_int
name|arg2
decl_stmt|;
comment|/* argument */
name|TAILQ_ENTRY
argument_list|(
argument|ccsig
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<
literal|3
end_if

begin_define
define|#
directive|define
name|cc_sig_log
parameter_list|(
name|CC
parameter_list|,
name|FMT
parameter_list|,
name|ARGS
modifier|...
parameter_list|)
value|do {				\ 	if ((CC)->log& CCLOG_SIGS)					\ 		(CC)->funcs->log("%s: " FMT, __FUNCTION__ , ## ARGS);	\     } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cc_sig_log
parameter_list|(
name|CC
parameter_list|,
name|FMT
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if ((CC)->log& CCLOG_SIGS)					\ 		(CC)->funcs->log("%s: " FMT, __func__, __VA_ARGS__);	\     } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|cc_user_sigtab
index|[]
init|=
block|{
define|#
directive|define
name|DEF
parameter_list|(
name|N
parameter_list|)
value|[USER_SIG_##N] = #N,
name|USER_SIGS
undef|#
directive|undef
name|DEF
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|cc_conn_sigtab
index|[]
init|=
block|{
define|#
directive|define
name|DEF
parameter_list|(
name|N
parameter_list|)
value|[CONN_SIG_##N] = #N,
name|CONN_SIGS
undef|#
directive|undef
name|DEF
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate and populate a signal  */
end_comment

begin_function
specifier|static
comment|/* __inline */
name|struct
name|ccsig
modifier|*
name|sig_alloc
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|,
name|u_int
name|type
parameter_list|,
name|void
modifier|*
name|target
parameter_list|,
name|u_int
name|has_msg
parameter_list|,
name|u_int
name|sig
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|u_int
name|arg2
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|CCZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ccsig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|cc_log
argument_list|(
name|cc
argument_list|,
literal|"signal %u/%u lost - ENOMEM"
argument_list|,
name|type
argument_list|,
name|sig
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|s
operator|->
name|has_msg
operator|=
name|has_msg
expr_stmt|;
name|s
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|s
operator|->
name|sig
operator|=
name|sig
expr_stmt|;
name|s
operator|->
name|arg1
operator|=
name|arg1
expr_stmt|;
name|s
operator|->
name|arg2
operator|=
name|arg2
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a signal to this user  */
end_comment

begin_function
name|int
name|cc_user_sig
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|enum
name|user_sig
name|sig
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|u_int
name|arg2
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|sig_alloc
argument_list|(
name|user
operator|->
name|cc
argument_list|,
name|SIG_USER
argument_list|,
name|user
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|user
operator|->
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|user
operator|->
name|cc
argument_list|,
literal|"queuing sig %s to user %p"
argument_list|,
name|cc_user_sigtab
index|[
name|sig
index|]
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Queue a signal with message to this user */
end_comment

begin_function
name|int
name|cc_user_sig_msg
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|,
name|enum
name|user_sig
name|sig
parameter_list|,
name|struct
name|uni_msg
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|sig_alloc
argument_list|(
name|user
operator|->
name|cc
argument_list|,
name|SIG_USER
argument_list|,
name|user
argument_list|,
name|msg
operator|!=
name|NULL
argument_list|,
name|sig
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|user
operator|->
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|user
operator|->
name|cc
argument_list|,
literal|"queuing sig %s to user %p"
argument_list|,
name|cc_user_sigtab
index|[
name|sig
index|]
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal to connection  */
end_comment

begin_function
specifier|static
name|int
name|sig_conn
parameter_list|(
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|enum
name|conn_sig
name|sig
parameter_list|,
name|u_int
name|has_msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|ccreq
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|s
operator|=
name|sig_alloc
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
name|SIG_CONN
argument_list|,
name|conn
argument_list|,
name|has_msg
argument_list|,
name|sig
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|conn
operator|->
name|port
operator|!=
name|NULL
condition|)
block|{
comment|/* argh */
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&conn->port->cookies
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|r
operator|->
name|conn
operator|==
name|conn
condition|)
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
literal|"queuing sig %s to conn %p"
argument_list|,
name|cc_conn_sigtab
index|[
name|sig
index|]
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|def_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
literal|"queuing defered sig %s to conn %p"
argument_list|,
name|cc_conn_sigtab
index|[
name|sig
index|]
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a signal to a connection.  */
end_comment

begin_function
name|int
name|cc_conn_sig
parameter_list|(
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|enum
name|conn_sig
name|sig
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|)
block|{
return|return
operator|(
name|sig_conn
argument_list|(
name|conn
argument_list|,
name|sig
argument_list|,
literal|0
argument_list|,
name|arg1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * signal with message to connection  */
end_comment

begin_function
name|int
name|cc_conn_sig_msg
parameter_list|(
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|enum
name|conn_sig
name|sig
parameter_list|,
name|struct
name|uni_msg
modifier|*
name|msg
parameter_list|)
block|{
return|return
operator|(
name|sig_conn
argument_list|(
name|conn
argument_list|,
name|sig
argument_list|,
operator|(
name|msg
operator|!=
name|NULL
operator|)
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cc_conn_sig_msg_nodef
parameter_list|(
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|enum
name|conn_sig
name|sig
parameter_list|,
name|struct
name|uni_msg
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|sig_alloc
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
name|SIG_CONN
argument_list|,
name|conn
argument_list|,
operator|(
name|msg
operator|!=
name|NULL
operator|)
argument_list|,
name|sig
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
literal|"queuing sig %s to conn %p"
argument_list|,
name|cc_conn_sigtab
index|[
name|sig
index|]
argument_list|,
name|conn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a response signal to a connection.  */
end_comment

begin_function
name|int
name|cc_conn_resp
parameter_list|(
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
name|enum
name|conn_sig
name|sig
parameter_list|,
name|u_int
name|cookie
name|__unused
parameter_list|,
name|u_int
name|reason
parameter_list|,
name|u_int
name|state
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|s
operator|=
name|sig_alloc
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
name|SIG_CONN
argument_list|,
name|conn
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
name|NULL
argument_list|,
operator|(
operator|(
name|reason
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|state
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
literal|"queuing response %s to conn %p"
argument_list|,
name|cc_conn_sigtab
index|[
name|sig
index|]
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|s1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|def_sigs
argument_list|)
expr_stmt|;
while|while
condition|(
name|s1
operator|!=
name|NULL
condition|)
block|{
name|s2
operator|=
name|TAILQ_NEXT
argument_list|(
name|s1
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|->
name|type
operator|==
name|SIG_CONN
operator|&&
name|s1
operator|->
name|target
operator|==
name|conn
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|def_sigs
argument_list|,
name|s1
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|conn
operator|->
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|s1
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cc_sig_log
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
literal|"undefering sig %s to conn %p"
argument_list|,
name|cc_conn_sigtab
index|[
name|s1
operator|->
name|sig
index|]
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
block|}
name|s1
operator|=
name|s2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all signals to a given target from both queues  */
end_comment

begin_function
specifier|static
comment|/* __inline */
name|void
name|sig_flush
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|,
name|u_int
name|type
parameter_list|,
name|void
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s1
operator|=
name|TAILQ_NEXT
argument_list|(
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|type
operator|&&
name|s
operator|->
name|target
operator|==
name|target
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|has_msg
condition|)
name|uni_msg_destroy
argument_list|(
operator|(
expr|struct
name|uni_msg
operator|*
operator|)
name|s
operator|->
name|arg1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s1
expr_stmt|;
block|}
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|def_sigs
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s1
operator|=
name|TAILQ_NEXT
argument_list|(
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|type
operator|&&
name|s
operator|->
name|target
operator|==
name|target
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|has_msg
condition|)
name|uni_msg_destroy
argument_list|(
operator|(
expr|struct
name|uni_msg
operator|*
operator|)
name|s
operator|->
name|arg1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|def_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flush all signals to this user  */
end_comment

begin_function
name|void
name|cc_user_sig_flush
parameter_list|(
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
name|cc_sig_log
argument_list|(
name|user
operator|->
name|cc
argument_list|,
literal|"flushing signals to user %p"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|sig_flush
argument_list|(
name|user
operator|->
name|cc
argument_list|,
name|SIG_USER
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush all signals to this connection  */
end_comment

begin_function
name|void
name|cc_conn_sig_flush
parameter_list|(
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|)
block|{
name|cc_sig_log
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
literal|"flushing signals to conn %p"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|sig_flush
argument_list|(
name|conn
operator|->
name|cc
argument_list|,
name|SIG_CONN
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the work  */
end_comment

begin_function
name|void
name|cc_work
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
name|cc_sig_log
argument_list|(
name|cc
argument_list|,
literal|"start %s"
argument_list|,
literal|"work"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|SIG_USER
condition|)
name|cc_user_sig_handle
argument_list|(
name|s
operator|->
name|target
argument_list|,
name|s
operator|->
name|sig
argument_list|,
name|s
operator|->
name|arg1
argument_list|,
name|s
operator|->
name|arg2
argument_list|)
expr_stmt|;
else|else
block|{
name|cc_conn_sig_handle
argument_list|(
name|s
operator|->
name|target
argument_list|,
name|s
operator|->
name|sig
argument_list|,
name|s
operator|->
name|arg1
argument_list|,
name|s
operator|->
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|has_msg
condition|)
name|uni_msg_destroy
argument_list|(
name|s
operator|->
name|arg1
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|cc_sig_log
argument_list|(
name|cc
argument_list|,
literal|"end %s"
argument_list|,
literal|"work"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * flush all signals  */
end_comment

begin_function
name|void
name|cc_sig_flush_all
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|)
block|{
name|struct
name|ccsig
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|has_msg
condition|)
name|uni_msg_destroy
argument_list|(
operator|(
expr|struct
name|uni_msg
operator|*
operator|)
name|s
operator|->
name|arg1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|def_sigs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|has_msg
condition|)
name|uni_msg_destroy
argument_list|(
operator|(
expr|struct
name|uni_msg
operator|*
operator|)
name|s
operator|->
name|arg1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|def_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|s
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cc
operator|->
name|free_sigs
argument_list|,
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

