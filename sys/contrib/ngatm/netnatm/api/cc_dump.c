begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2004  *	Hartmut Brandt  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *  * Redistribution of this software and documentation and use in source and  * binary forms, with or without modification, are permitted provided that  * the following conditions are met:  *  * 1. Redistributions of source code or documentation must retain the above  *    copyright notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE AUTHOR  * AND ITS CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * THE AUTHOR OR ITS CONTRIBUTORS  BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Begemot: libunimsg/netnatm/api/cc_dump.c,v 1.1 2004/07/08 08:21:51 brandt Exp $  *  * ATM API as defined per af-saa-0108  */
end_comment

begin_include
include|#
directive|include
file|<netnatm/unimsg.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unistruct.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/msg/unimsglib.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/unisap.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/sig/unidef.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/atmapi.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccatm.h>
end_include

begin_include
include|#
directive|include
file|<netnatm/api/ccpriv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_KERNEL */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * local structure to reduce number of arguments to functions  */
end_comment

begin_struct
struct|struct
name|dump
block|{
name|struct
name|ccdata
modifier|*
name|cc
decl_stmt|;
comment|/* what to dump */
name|size_t
name|maxsiz
decl_stmt|;
comment|/* size of user buffer */
name|cc_dump_f
name|func
decl_stmt|;
comment|/* user function */
name|void
modifier|*
name|uarg
decl_stmt|;
comment|/* user supplied argument */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* user buffer */
name|size_t
name|len
decl_stmt|;
comment|/* current string length */
name|int
name|ret
decl_stmt|;
comment|/* return code */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|cc_dumpf
parameter_list|(
name|struct
name|dump
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|cc_dumpf
parameter_list|(
name|struct
name|dump
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|ret
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|len
operator|>=
name|d
operator|->
name|maxsiz
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|ret
operator|=
name|d
operator|->
name|func
argument_list|(
name|d
operator|->
name|cc
argument_list|,
name|d
operator|->
name|uarg
argument_list|,
name|d
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ret
operator|!=
literal|0
condition|)
return|return;
name|d
operator|->
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|n
operator|=
name|vsnprintf
argument_list|(
name|d
operator|->
name|buf
operator|+
name|d
operator|->
name|len
argument_list|,
name|d
operator|->
name|maxsiz
operator|-
name|d
operator|->
name|len
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|ret
operator|=
name|errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|n
operator|<
name|d
operator|->
name|maxsiz
operator|-
name|d
operator|->
name|len
condition|)
block|{
name|d
operator|->
name|len
operator|+=
name|n
expr_stmt|;
return|return;
block|}
comment|/* undo the vsnprintf() and flush */
name|d
operator|->
name|buf
index|[
name|d
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|->
name|ret
operator|=
name|d
operator|->
name|func
argument_list|(
name|d
operator|->
name|cc
argument_list|,
name|d
operator|->
name|uarg
argument_list|,
name|d
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ret
operator|!=
literal|0
condition|)
return|return;
name|d
operator|->
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|n
operator|=
name|vsnprintf
argument_list|(
name|d
operator|->
name|buf
argument_list|,
name|d
operator|->
name|maxsiz
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|ret
operator|=
name|errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|n
operator|>=
name|d
operator|->
name|maxsiz
condition|)
block|{
comment|/* ok, truncate */
name|d
operator|->
name|len
operator|=
name|d
operator|->
name|maxsiz
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|len
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a SAP  */
end_comment

begin_function
specifier|static
name|void
name|cc_dump_sap
parameter_list|(
name|struct
name|dump
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|uni_sap
modifier|*
name|sap
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tagtab
index|[]
init|=
block|{
index|[
name|UNISVE_ABSENT
index|]
literal|"absent"
block|,
index|[
name|UNISVE_ANY
index|]
literal|"any"
block|,
index|[
name|UNISVE_PRESENT
index|]
literal|"present"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|plantab
index|[]
init|=
block|{
index|[
name|UNI_ADDR_E164
index|]
literal|"E164"
block|,
index|[
name|UNI_ADDR_ATME
index|]
literal|"ATME"
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|hlitab
index|[]
init|=
block|{
index|[
name|UNI_BHLI_ISO
index|]
literal|"ISO"
block|,
index|[
name|UNI_BHLI_VENDOR
index|]
literal|"VENDOR"
block|,
index|[
name|UNI_BHLI_USER
index|]
literal|"USER"
block|}
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"  sap(%p):\n"
argument_list|,
name|sap
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"    addr=%s"
argument_list|,
name|tagtab
index|[
name|sap
operator|->
name|addr
operator|.
name|tag
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|addr
operator|.
name|tag
operator|==
name|UNISVE_PRESENT
condition|)
block|{
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|" %s %u "
argument_list|,
name|plantab
index|[
name|sap
operator|->
name|addr
operator|.
name|plan
index|]
argument_list|,
name|sap
operator|->
name|addr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|addr
operator|.
name|plan
operator|==
name|UNI_ADDR_E164
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sap
operator|->
name|addr
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%c"
argument_list|,
name|sap
operator|->
name|addr
operator|.
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sap
operator|->
name|addr
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%02x"
argument_list|,
name|sap
operator|->
name|addr
operator|.
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"    selector=%s"
argument_list|,
name|tagtab
index|[
name|sap
operator|->
name|selector
operator|.
name|tag
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|selector
operator|.
name|tag
operator|==
name|UNISVE_PRESENT
condition|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|" %02x"
argument_list|,
name|sap
operator|->
name|selector
operator|.
name|selector
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"    blli_id2=%s"
argument_list|,
name|tagtab
index|[
name|sap
operator|->
name|blli_id2
operator|.
name|tag
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|blli_id2
operator|.
name|tag
operator|==
name|UNISVE_PRESENT
condition|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|" %02x %02x"
argument_list|,
name|sap
operator|->
name|blli_id2
operator|.
name|proto
argument_list|,
name|sap
operator|->
name|blli_id2
operator|.
name|user
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"    blli_id3=%s"
argument_list|,
name|tagtab
index|[
name|sap
operator|->
name|blli_id3
operator|.
name|tag
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|blli_id3
operator|.
name|tag
operator|==
name|UNISVE_PRESENT
condition|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|" %02x,%02x, %02x(%d),%03x,%02x"
argument_list|,
name|sap
operator|->
name|blli_id3
operator|.
name|proto
argument_list|,
name|sap
operator|->
name|blli_id3
operator|.
name|user
argument_list|,
name|sap
operator|->
name|blli_id3
operator|.
name|ipi
argument_list|,
name|sap
operator|->
name|blli_id3
operator|.
name|noipi
argument_list|,
name|sap
operator|->
name|blli_id3
operator|.
name|oui
argument_list|,
name|sap
operator|->
name|blli_id3
operator|.
name|pid
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"    bhli=%s"
argument_list|,
name|tagtab
index|[
name|sap
operator|->
name|bhli
operator|.
name|tag
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sap
operator|->
name|bhli
operator|.
name|tag
operator|==
name|UNISVE_PRESENT
condition|)
block|{
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|" %s "
argument_list|,
name|hlitab
index|[
name|sap
operator|->
name|bhli
operator|.
name|type
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sap
operator|->
name|bhli
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%02x"
argument_list|,
name|sap
operator|->
name|bhli
operator|.
name|info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a user.  */
end_comment

begin_function
specifier|static
name|void
name|cc_dump_user
parameter_list|(
name|struct
name|dump
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|ccuser
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"user(%p): %s '%s' %s\n"
argument_list|,
name|user
argument_list|,
name|cc_user_state2str
argument_list|(
name|user
operator|->
name|state
argument_list|)
argument_list|,
name|user
operator|->
name|name
argument_list|,
operator|(
name|user
operator|->
name|config
operator|==
name|USER_P2P
operator|)
condition|?
literal|"p2p"
else|:
operator|(
name|user
operator|->
name|config
operator|==
name|USER_ROOT
operator|)
condition|?
literal|"root"
else|:
operator|(
name|user
operator|->
name|config
operator|==
name|USER_LEAF
operator|)
condition|?
literal|"leaf"
else|:
literal|"?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|->
name|sap
condition|)
name|cc_dump_sap
argument_list|(
name|d
argument_list|,
name|user
operator|->
name|sap
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"  queue=%u/%u accepted=%p aborted=%u\n"
argument_list|,
name|user
operator|->
name|queue_max
argument_list|,
name|user
operator|->
name|queue_act
argument_list|,
name|user
operator|->
name|accepted
argument_list|,
name|user
operator|->
name|aborted
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"  connq:"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|conn
argument_list|,
argument|&user->connq
argument_list|,
argument|connq_link
argument_list|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%p"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a party  */
end_comment

begin_function
specifier|static
name|void
name|cc_dump_party
parameter_list|(
name|struct
name|dump
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|ccparty
modifier|*
name|party
parameter_list|,
specifier|const
name|char
modifier|*
name|pfx
parameter_list|)
block|{
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%s  party(%p): %u.%u %s\n"
argument_list|,
name|pfx
argument_list|,
name|party
argument_list|,
name|party
operator|->
name|epref
operator|.
name|flag
argument_list|,
name|party
operator|->
name|epref
operator|.
name|epref
argument_list|,
name|cc_party_state2str
argument_list|(
name|party
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a connection  */
end_comment

begin_function
specifier|static
name|void
name|cc_dump_conn
parameter_list|(
name|struct
name|dump
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|ccconn
modifier|*
name|conn
parameter_list|,
specifier|const
name|char
modifier|*
name|pfx
parameter_list|)
block|{
specifier|const
name|struct
name|ccparty
modifier|*
name|party
decl_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%sconn(%p): %s\n"
argument_list|,
name|pfx
argument_list|,
name|conn
argument_list|,
name|cc_conn_state2str
argument_list|(
name|conn
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%s  user=%p cref=%u.%u acceptor=%p\n"
argument_list|,
name|pfx
argument_list|,
name|conn
operator|->
name|user
argument_list|,
name|conn
operator|->
name|cref
operator|.
name|cref
argument_list|,
name|conn
operator|->
name|cref
operator|.
name|flag
argument_list|,
name|conn
operator|->
name|acceptor
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%s  blli_sel=%u\n"
argument_list|,
name|pfx
argument_list|,
name|conn
operator|->
name|blli_selector
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|party
argument_list|,
argument|&conn->parties
argument_list|,
argument|link
argument_list|)
name|cc_dump_party
argument_list|(
name|d
argument_list|,
name|party
argument_list|,
name|pfx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a port  */
end_comment

begin_function
specifier|static
name|void
name|cc_dump_port
parameter_list|(
name|struct
name|dump
modifier|*
name|d
parameter_list|,
specifier|const
name|struct
name|ccport
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
specifier|const
name|struct
name|ccaddr
modifier|*
name|a
decl_stmt|;
specifier|const
name|struct
name|ccconn
modifier|*
name|c
decl_stmt|;
specifier|const
name|struct
name|ccreq
modifier|*
name|r
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ttab
index|[]
init|=
block|{
index|[
name|UNI_ADDR_UNKNOWN
index|]
operator|=
literal|"unknown"
block|,
index|[
name|UNI_ADDR_INTERNATIONAL
index|]
operator|=
literal|"international"
block|,
index|[
name|UNI_ADDR_NATIONAL
index|]
operator|=
literal|"national"
block|,
index|[
name|UNI_ADDR_NETWORK
index|]
operator|=
literal|"network"
block|,
index|[
name|UNI_ADDR_SUBSCR
index|]
operator|=
literal|"subscr"
block|,
index|[
name|UNI_ADDR_ABBR
index|]
operator|=
literal|"abbr"
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ptab
index|[]
init|=
block|{
index|[
name|UNI_ADDR_UNKNOWN
index|]
operator|=
literal|"unknown"
block|,
index|[
name|UNI_ADDR_E164
index|]
operator|=
literal|"e164"
block|,
index|[
name|UNI_ADDR_ATME
index|]
operator|=
literal|"atme"
block|,
index|[
name|UNI_ADDR_DATA
index|]
operator|=
literal|"data"
block|,
index|[
name|UNI_ADDR_PRIVATE
index|]
operator|=
literal|"private"
block|, 	}
decl_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"port(%p) %u: %s\n"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|param
operator|.
name|port
argument_list|,
operator|(
name|p
operator|->
name|admin
operator|==
name|CCPORT_STOPPED
operator|)
condition|?
literal|"STOPPED"
else|:
operator|(
name|p
operator|->
name|admin
operator|==
name|CCPORT_RUNNING
operator|)
condition|?
literal|"RUNNING"
else|:
literal|"????"
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"  pcr=%u bits=%u.%u ids=%u/%u/%u esi=%02x:%02x:"
literal|"%02x:%02x:%02x:%02x naddrs=%u\n"
argument_list|,
name|p
operator|->
name|param
operator|.
name|pcr
argument_list|,
name|p
operator|->
name|param
operator|.
name|max_vpi_bits
argument_list|,
name|p
operator|->
name|param
operator|.
name|max_vci_bits
argument_list|,
name|p
operator|->
name|param
operator|.
name|max_svpc_vpi
argument_list|,
name|p
operator|->
name|param
operator|.
name|max_svcc_vpi
argument_list|,
name|p
operator|->
name|param
operator|.
name|min_svcc_vci
argument_list|,
name|p
operator|->
name|param
operator|.
name|esi
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|param
operator|.
name|esi
index|[
literal|1
index|]
argument_list|,
name|p
operator|->
name|param
operator|.
name|esi
index|[
literal|2
index|]
argument_list|,
name|p
operator|->
name|param
operator|.
name|esi
index|[
literal|3
index|]
argument_list|,
name|p
operator|->
name|param
operator|.
name|esi
index|[
literal|4
index|]
argument_list|,
name|p
operator|->
name|param
operator|.
name|esi
index|[
literal|5
index|]
argument_list|,
name|p
operator|->
name|param
operator|.
name|num_addrs
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"  cookies:"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&p->cookies
argument_list|,
argument|link
argument_list|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|" %u(%p,%u)"
argument_list|,
name|r
operator|->
name|cookie
argument_list|,
name|r
operator|->
name|conn
argument_list|,
name|r
operator|->
name|req
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|a
argument_list|,
argument|&p->addr_list
argument_list|,
argument|port_link
argument_list|)
block|{
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"  addr(%p): %s %s %u "
argument_list|,
name|a
argument_list|,
operator|(
name|a
operator|->
name|addr
operator|.
name|type
operator|<
sizeof|sizeof
argument_list|(
name|ttab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ttab
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ttab
index|[
name|a
operator|->
name|addr
operator|.
name|type
index|]
operator|!=
name|NULL
operator|)
condition|?
name|ttab
index|[
name|a
operator|->
name|addr
operator|.
name|type
index|]
else|:
literal|"?"
argument_list|,
operator|(
name|a
operator|->
name|addr
operator|.
name|plan
operator|<
sizeof|sizeof
argument_list|(
name|ptab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ptab
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ptab
index|[
name|a
operator|->
name|addr
operator|.
name|plan
index|]
operator|!=
name|NULL
operator|)
condition|?
name|ptab
index|[
name|a
operator|->
name|addr
operator|.
name|plan
index|]
else|:
literal|"?"
argument_list|,
name|a
operator|->
name|addr
operator|.
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|addr
operator|.
name|len
condition|;
name|i
operator|++
control|)
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"%02x"
argument_list|,
name|a
operator|->
name|addr
operator|.
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
name|d
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|c
argument_list|,
argument|&p->conn_list
argument_list|,
argument|port_link
argument_list|)
name|cc_dump_conn
argument_list|(
name|d
argument_list|,
name|c
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Produce a textual dump of the state  */
end_comment

begin_function
name|int
name|cc_dump
parameter_list|(
name|struct
name|ccdata
modifier|*
name|cc
parameter_list|,
name|size_t
name|maxsiz
parameter_list|,
name|cc_dump_f
name|func
parameter_list|,
name|void
modifier|*
name|uarg
parameter_list|)
block|{
name|struct
name|dump
name|d
decl_stmt|;
name|struct
name|ccuser
modifier|*
name|user
decl_stmt|;
name|struct
name|ccconn
modifier|*
name|conn
decl_stmt|;
name|struct
name|ccport
modifier|*
name|port
decl_stmt|;
name|d
operator|.
name|ret
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|uarg
operator|=
name|uarg
expr_stmt|;
name|d
operator|.
name|maxsiz
operator|=
name|maxsiz
expr_stmt|;
name|d
operator|.
name|cc
operator|=
name|cc
expr_stmt|;
name|d
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|d
operator|.
name|buf
operator|=
name|CCMALLOC
argument_list|(
name|maxsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|d
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|cc_dumpf
argument_list|(
operator|&
name|d
argument_list|,
literal|"dump of node %p\n"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|port
argument_list|,
argument|&cc->port_list
argument_list|,
argument|node_link
argument_list|)
name|cc_dump_port
argument_list|(
operator|&
name|d
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|user
argument_list|,
argument|&cc->user_list
argument_list|,
argument|node_link
argument_list|)
name|cc_dump_user
argument_list|(
operator|&
name|d
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|cc_dumpf
argument_list|(
operator|&
name|d
argument_list|,
literal|"orphaned conns:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|conn
argument_list|,
argument|&cc->orphaned_conns
argument_list|,
argument|port_link
argument_list|)
name|cc_dump_conn
argument_list|(
operator|&
name|d
argument_list|,
name|conn
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|len
operator|>
literal|0
operator|&&
name|d
operator|.
name|ret
operator|==
literal|0
condition|)
name|d
operator|.
name|ret
operator|=
name|d
operator|.
name|func
argument_list|(
name|d
operator|.
name|cc
argument_list|,
name|d
operator|.
name|uarg
argument_list|,
name|d
operator|.
name|buf
argument_list|)
expr_stmt|;
name|CCFREE
argument_list|(
name|d
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|.
name|ret
operator|)
return|;
block|}
end_function

end_unit

