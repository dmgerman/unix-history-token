begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Semihalf.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<dev/dpaa/bman.h>
end_include

begin_include
include|#
directive|include
file|<dev/dpaa/qman.h>
end_include

begin_include
include|#
directive|include
file|<dev/dpaa/portals.h>
end_include

begin_include
include|#
directive|include
file|<powerpc/mpc85xx/mpc85xx.h>
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"list_ext.h"
end_include

begin_include
include|#
directive|include
file|"mm_ext.h"
end_include

begin_comment
comment|/* Configuration */
end_comment

begin_comment
comment|/* Define the number of dTSEC ports active in system */
end_comment

begin_define
define|#
directive|define
name|MALLOCSMART_DTSEC_IN_USE
value|4
end_define

begin_comment
comment|/*  * Calculate malloc's pool size for dTSEC's buffers.  * We reserve 1MB pool for each dTSEC port.  */
end_comment

begin_define
define|#
directive|define
name|MALLOCSMART_POOL_SIZE
define|\
value|(MALLOCSMART_DTSEC_IN_USE * 1024 * 1024)
end_define

begin_define
define|#
directive|define
name|MALLOCSMART_SLICE_SIZE
value|(PAGE_SIZE / 2)
end_define

begin_comment
comment|/* 2kB */
end_comment

begin_comment
comment|/* Defines */
end_comment

begin_define
define|#
directive|define
name|MALLOCSMART_SIZE_TO_SLICE
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x) + MALLOCSMART_SLICE_SIZE - 1) / MALLOCSMART_SLICE_SIZE)
end_define

begin_define
define|#
directive|define
name|MALLOCSMART_SLICES
define|\
value|MALLOCSMART_SIZE_TO_SLICE(MALLOCSMART_POOL_SIZE)
end_define

begin_comment
comment|/* Malloc Pool for NetCommSW */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETCOMMSW
argument_list|,
literal|"NetCommSW"
argument_list|,
literal|"NetCommSW software stack"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETCOMMSW_MT
argument_list|,
literal|"NetCommSWTrack"
argument_list|,
literal|"NetCommSW software allocation tracker"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* MallocSmart data structures */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|XX_MallocSmartPool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|XX_MallocSmartMap
index|[
name|MALLOCSMART_SLICES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|XX_MallocSmartLock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|XX_MallocTrackLock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|XX_MallocSmartLockInit
argument_list|,
operator|&
name|XX_MallocSmartLock
argument_list|,
literal|"NetCommSW MallocSmart Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|XX_MallocTrackLockInit
argument_list|,
operator|&
name|XX_MallocTrackLock
argument_list|,
literal|"NetCommSW MallocTrack Lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Interrupt info */
end_comment

begin_define
define|#
directive|define
name|XX_INTR_FLAG_PREALLOCATED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|XX_INTR_FLAG_BOUND
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|XX_INTR_FLAG_FMAN_FIX
value|(1<< 2)
end_define

begin_struct
struct|struct
name|XX_IntrInfo
block|{
name|driver_intr_t
modifier|*
name|handler
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|XX_IntrInfo
name|XX_IntrInfo
index|[
name|INTR_VECTORS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Portal type identifiers */
end_comment

begin_enum
enum|enum
name|XX_PortalIdent
block|{
name|BM_PORTAL
init|=
literal|0
block|,
name|QM_PORTAL
block|, }
enum|;
end_enum

begin_comment
comment|/* Structure to store portals' properties */
end_comment

begin_struct
struct|struct
name|XX_PortalInfo
block|{
name|vm_paddr_t
name|portal_ce_pa
index|[
literal|2
index|]
index|[
name|MAXCPU
index|]
decl_stmt|;
name|vm_paddr_t
name|portal_ci_pa
index|[
literal|2
index|]
index|[
name|MAXCPU
index|]
decl_stmt|;
name|uint32_t
name|portal_ce_size
index|[
literal|2
index|]
index|[
name|MAXCPU
index|]
decl_stmt|;
name|uint32_t
name|portal_ci_size
index|[
literal|2
index|]
index|[
name|MAXCPU
index|]
decl_stmt|;
name|vm_offset_t
name|portal_ce_va
index|[
literal|2
index|]
decl_stmt|;
name|vm_offset_t
name|portal_ci_va
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|portal_intr
index|[
literal|2
index|]
index|[
name|MAXCPU
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|XX_PortalInfo
name|XX_PInfo
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|XX_Exit
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|panic
argument_list|(
literal|"NetCommSW: Exit called with status %i"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XX_Print
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|str
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|XX_Malloc
parameter_list|(
name|uint32_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
operator|(
name|malloc
argument_list|(
name|size
argument_list|,
name|M_NETCOMMSW
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|XX_MallocSmartMapCheck
parameter_list|(
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|slices
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|slices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XX_MallocSmartMap
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|XX_MallocSmartMapSet
parameter_list|(
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|slices
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|slices
condition|;
name|i
operator|++
control|)
name|XX_MallocSmartMap
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|i
operator|==
name|start
operator|)
condition|?
name|slices
else|:
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|XX_MallocSmartMapClear
parameter_list|(
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|slices
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|start
operator|+
name|slices
condition|;
name|i
operator|++
control|)
name|XX_MallocSmartMap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|XX_MallocSmartInit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|E_OK
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|XX_MallocSmartPool
condition|)
goto|goto
name|out
goto|;
comment|/* Allocate MallocSmart pool */
name|XX_MallocSmartPool
operator|=
name|contigmalloc
argument_list|(
name|MALLOCSMART_POOL_SIZE
argument_list|,
name|M_NETCOMMSW
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|0xFFFFFFFFFull
argument_list|,
name|MALLOCSMART_POOL_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XX_MallocSmartPool
condition|)
block|{
name|error
operator|=
name|E_NO_MEMORY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|XX_MallocSmart
parameter_list|(
name|uint32_t
name|size
parameter_list|,
name|int
name|memPartitionId
parameter_list|,
name|uint32_t
name|alignment
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* Convert alignment and size to number of slices */
name|alignment
operator|=
name|MALLOCSMART_SIZE_TO_SLICE
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|size
operator|=
name|MALLOCSMART_SIZE_TO_SLICE
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Lock resources */
name|mtx_lock
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|)
expr_stmt|;
comment|/* Allocate region */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
name|size
operator|<=
name|MALLOCSMART_SLICES
condition|;
name|i
operator|+=
name|alignment
control|)
block|{
if|if
condition|(
name|XX_MallocSmartMapCheck
argument_list|(
name|i
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|XX_MallocSmartMapSet
argument_list|(
name|i
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|XX_MallocSmartPool
operator|+
operator|(
name|i
operator|*
name|MALLOCSMART_SLICE_SIZE
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Unlock resources */
name|mtx_unlock
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_FreeSmart
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|start
decl_stmt|,
name|slices
decl_stmt|;
comment|/* Calculate first slice of region */
name|start
operator|=
name|MALLOCSMART_SIZE_TO_SLICE
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|p
argument_list|)
operator|-
operator|(
name|vm_offset_t
operator|)
name|XX_MallocSmartPool
argument_list|)
expr_stmt|;
comment|/* Lock resources */
name|mtx_lock
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|XX_MallocSmartMap
index|[
name|start
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"XX_FreeSmart: Double or mid-block free!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Free region */
name|slices
operator|=
name|XX_MallocSmartMap
index|[
name|start
index|]
expr_stmt|;
name|XX_MallocSmartMapClear
argument_list|(
name|start
argument_list|,
name|slices
argument_list|)
expr_stmt|;
comment|/* Unlock resources */
name|mtx_unlock
argument_list|(
operator|&
name|XX_MallocSmartLock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XX_Free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|,
name|M_NETCOMMSW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|XX_DisableAllIntr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|intr_disable
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_RestoreAllIntr
parameter_list|(
name|uint32_t
name|flags
parameter_list|)
block|{
name|intr_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|XX_Call
parameter_list|(
name|uint32_t
name|qid
parameter_list|,
name|t_Error
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|t_Handle
parameter_list|)
parameter_list|,
name|t_Handle
name|id
parameter_list|,
name|t_Handle
name|appId
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|XX_IsPortalIntr
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|,
name|type
decl_stmt|;
comment|/* Check interrupt numbers of all available portals */
for|for
control|(
name|cpu
operator|=
literal|0
operator|,
name|type
operator|=
literal|0
init|;
name|XX_PInfo
operator|.
name|portal_intr
index|[
name|type
index|]
index|[
name|cpu
index|]
operator|!=
literal|0
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|irq
operator|==
name|XX_PInfo
operator|.
name|portal_intr
index|[
name|type
index|]
index|[
name|cpu
index|]
condition|)
block|{
comment|/* Found it! */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|XX_PInfo
operator|.
name|portal_intr
index|[
name|type
index|]
index|[
name|cpu
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|type
operator|++
expr_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_FmanFixIntr
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|flags
operator||=
name|XX_INTR_FLAG_FMAN_FIX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|XX_FmanNeedsIntrFix
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
if|if
condition|(
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|flags
operator|&
name|XX_INTR_FLAG_FMAN_FIX
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|XX_Dispatch
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|XX_IntrInfo
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|arg
expr_stmt|;
comment|/* Bind this thread to proper CPU when SMP has been already started. */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|XX_INTR_FLAG_BOUND
operator|)
operator|==
literal|0
operator|&&
name|smp_started
operator|&&
name|info
operator|->
name|cpu
operator|>=
literal|0
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|info
operator|->
name|cpu
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|XX_INTR_FLAG_BOUND
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|handler
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): IRQ handler is NULL!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|->
name|handler
argument_list|(
name|info
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|XX_PreallocAndBindIntr
parameter_list|(
name|uintptr_t
name|irq
parameter_list|,
name|unsigned
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|unsigned
name|int
name|inum
decl_stmt|;
name|t_Error
name|error
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|resource
operator|*
operator|)
name|irq
expr_stmt|;
name|inum
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|error
operator|=
name|XX_SetIntr
argument_list|(
name|irq
argument_list|,
name|XX_Dispatch
argument_list|,
operator|&
name|XX_IntrInfo
index|[
name|inum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|XX_IntrInfo
index|[
name|inum
index|]
operator|.
name|flags
operator|=
name|XX_INTR_FLAG_PREALLOCATED
expr_stmt|;
name|XX_IntrInfo
index|[
name|inum
index|]
operator|.
name|cpu
operator|=
name|cpu
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_DeallocIntr
parameter_list|(
name|uintptr_t
name|irq
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|unsigned
name|int
name|inum
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|resource
operator|*
operator|)
name|irq
expr_stmt|;
name|inum
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XX_IntrInfo
index|[
name|inum
index|]
operator|.
name|flags
operator|&
name|XX_INTR_FLAG_PREALLOCATED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|E_INVALID_STATE
operator|)
return|;
name|XX_IntrInfo
index|[
name|inum
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|XX_FreeIntr
argument_list|(
name|irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_SetIntr
parameter_list|(
name|uintptr_t
name|irq
parameter_list|,
name|t_Isr
modifier|*
name|f_Isr
parameter_list|,
name|t_Handle
name|handle
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|resource
operator|*
operator|)
name|irq
expr_stmt|;
name|dev
operator|=
name|rman_get_device
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Handle preallocated interrupts */
if|if
condition|(
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|flags
operator|&
name|XX_INTR_FLAG_PREALLOCATED
condition|)
block|{
if|if
condition|(
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|handler
operator|!=
name|NULL
condition|)
return|return
operator|(
name|E_BUSY
operator|)
return|;
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|handler
operator|=
name|f_Isr
expr_stmt|;
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|arg
operator|=
name|handle
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
name|flags
operator|=
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
expr_stmt|;
comment|/* BMAN/QMAN Portal interrupts must be exlusive */
if|if
condition|(
name|XX_IsPortalIntr
argument_list|(
name|irq
argument_list|)
condition|)
name|flags
operator||=
name|INTR_EXCL
expr_stmt|;
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|r
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|f_Isr
argument_list|,
name|handle
argument_list|,
operator|&
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|finish
goto|;
comment|/* 	 * XXX: Bind FMan IRQ to CPU0. Current interrupt subsystem directs each 	 * interrupt to all CPUs. Race between an interrupt assertion and 	 * masking may occur and interrupt handler may be called multiple times 	 * per one interrupt. FMan doesn't support such a situation. Workaround 	 * is to bind FMan interrupt to one CPU0 only. 	 */
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|XX_FmanNeedsIntrFix
argument_list|(
name|irq
argument_list|)
condition|)
name|err
operator|=
name|powerpc_bind_intr
argument_list|(
name|irq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|finish
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_FreeIntr
parameter_list|(
name|uintptr_t
name|irq
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|resource
operator|*
operator|)
name|irq
expr_stmt|;
name|dev
operator|=
name|rman_get_device
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|irq
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Handle preallocated interrupts */
if|if
condition|(
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|flags
operator|&
name|XX_INTR_FLAG_PREALLOCATED
condition|)
block|{
if|if
condition|(
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|handler
operator|==
name|NULL
condition|)
return|return
operator|(
name|E_INVALID_STATE
operator|)
return|;
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|handler
operator|=
name|NULL
expr_stmt|;
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|arg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
return|return
operator|(
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|r
argument_list|,
name|XX_IntrInfo
index|[
name|irq
index|]
operator|.
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_EnableIntr
parameter_list|(
name|uintptr_t
name|irq
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|resource
operator|*
operator|)
name|irq
expr_stmt|;
name|irq
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|powerpc_intr_unmask
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_DisableIntr
parameter_list|(
name|uintptr_t
name|irq
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|resource
operator|*
operator|)
name|irq
expr_stmt|;
name|irq
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|powerpc_intr_mask
argument_list|(
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_TaskletHandle
name|XX_InitTasklet
parameter_list|(
name|void
function_decl|(
modifier|*
name|routine
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_FreeTasklet
parameter_list|(
name|t_TaskletHandle
name|h_Tasklet
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|XX_ScheduleTask
parameter_list|(
name|t_TaskletHandle
name|h_Tasklet
parameter_list|,
name|int
name|immediate
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_FlushScheduledTasks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|XX_TaskletIsQueued
parameter_list|(
name|t_TaskletHandle
name|h_Tasklet
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_SetTaskletData
parameter_list|(
name|t_TaskletHandle
name|h_Tasklet
parameter_list|,
name|t_Handle
name|data
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Handle
name|XX_GetTaskletData
parameter_list|(
name|t_TaskletHandle
name|h_Tasklet
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|t_Handle
name|XX_InitSpinlock
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|,
name|M_NETCOMMSW
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_init
argument_list|(
name|m
argument_list|,
literal|"NetCommSW Lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_FreeSpinlock
parameter_list|(
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|h_Spinlock
expr_stmt|;
name|mtx_destroy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|,
name|M_NETCOMMSW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XX_LockSpinlock
parameter_list|(
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|h_Spinlock
expr_stmt|;
name|mtx_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XX_UnlockSpinlock
parameter_list|(
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|h_Spinlock
expr_stmt|;
name|mtx_unlock
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|XX_LockIntrSpinlock
parameter_list|(
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|XX_LockSpinlock
argument_list|(
name|h_Spinlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_UnlockIntrSpinlock
parameter_list|(
name|t_Handle
name|h_Spinlock
parameter_list|,
name|uint32_t
name|intrFlags
parameter_list|)
block|{
name|XX_UnlockSpinlock
argument_list|(
name|h_Spinlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|XX_CurrentTime
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|t_Handle
name|XX_CreateTimer
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_FreeTimer
parameter_list|(
name|t_Handle
name|h_Timer
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XX_StartTimer
parameter_list|(
name|t_Handle
name|h_Timer
parameter_list|,
name|uint32_t
name|msecs
parameter_list|,
name|bool
name|periodic
parameter_list|,
name|void
function_decl|(
modifier|*
name|f_TimerExpired
function_decl|)
parameter_list|(
name|t_Handle
parameter_list|)
parameter_list|,
name|t_Handle
name|h_Arg
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|XX_GetExpirationTime
parameter_list|(
name|t_Handle
name|h_Timer
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_StopTimer
parameter_list|(
name|t_Handle
name|h_Timer
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|XX_ModTimer
parameter_list|(
name|t_Handle
name|h_Timer
parameter_list|,
name|uint32_t
name|msecs
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|XX_TimerIsActive
parameter_list|(
name|t_Handle
name|h_Timer
parameter_list|)
block|{
comment|/* Not referenced */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|XX_Sleep
parameter_list|(
name|uint32_t
name|msecs
parameter_list|)
block|{
name|XX_UDelay
argument_list|(
literal|1000
operator|*
name|msecs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_UDelay
parameter_list|(
name|uint32_t
name|usecs
parameter_list|)
block|{
name|DELAY
argument_list|(
name|usecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|XX_IpcRegisterMsgHandler
parameter_list|(
name|char
name|addr
index|[
name|XX_IPC_MAX_ADDR_NAME_LENGTH
index|]
parameter_list|,
name|t_IpcMsgHandler
modifier|*
name|f_MsgHandler
parameter_list|,
name|t_Handle
name|h_Module
parameter_list|,
name|uint32_t
name|replyLength
parameter_list|)
block|{
comment|/* 	 * This function returns fake E_OK status and does nothing 	 * as NetCommSW IPC is not used by FreeBSD drivers. 	 */
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_IpcUnregisterMsgHandler
parameter_list|(
name|char
name|addr
index|[
name|XX_IPC_MAX_ADDR_NAME_LENGTH
index|]
parameter_list|)
block|{
comment|/* 	 * This function returns fake E_OK status and does nothing 	 * as NetCommSW IPC is not used by FreeBSD drivers. 	 */
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_IpcSendMessage
parameter_list|(
name|t_Handle
name|h_Session
parameter_list|,
name|uint8_t
modifier|*
name|p_Msg
parameter_list|,
name|uint32_t
name|msgLength
parameter_list|,
name|uint8_t
modifier|*
name|p_Reply
parameter_list|,
name|uint32_t
modifier|*
name|p_ReplyLength
parameter_list|,
name|t_IpcMsgCompletion
modifier|*
name|f_Completion
parameter_list|,
name|t_Handle
name|h_Arg
parameter_list|)
block|{
comment|/* Should not be called */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_Handle
name|XX_IpcInitSession
parameter_list|(
name|char
name|destAddr
index|[
name|XX_IPC_MAX_ADDR_NAME_LENGTH
index|]
parameter_list|,
name|char
name|srcAddr
index|[
name|XX_IPC_MAX_ADDR_NAME_LENGTH
index|]
parameter_list|)
block|{
comment|/* Should not be called */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|XX_IpcFreeSession
parameter_list|(
name|t_Handle
name|h_Session
parameter_list|)
block|{
comment|/* Should not be called */
name|printf
argument_list|(
literal|"NetCommSW: Unimplemented function %s() called!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_function
name|physAddress_t
name|XX_VirtToPhys
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* Handle NULL address */
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Check CCSR */
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|>=
name|ccsrbar_va
operator|&&
operator|(
name|vm_offset_t
operator|)
name|addr
operator|<
name|ccsrbar_va
operator|+
name|ccsrbar_size
condition|)
return|return
operator|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|-
name|ccsrbar_va
operator|)
operator|+
name|ccsrbar_pa
operator|)
return|;
comment|/* Handle BMAN mappings */
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|BM_PORTAL
index|]
operator|)
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|BM_PORTAL
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ce_size
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
operator|(
name|vm_offset_t
operator|)
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|BM_PORTAL
index|]
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|BM_PORTAL
index|]
operator|)
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|BM_PORTAL
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ci_size
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
operator|(
name|vm_offset_t
operator|)
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|BM_PORTAL
index|]
operator|)
return|;
comment|/* Handle QMAN mappings */
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|QM_PORTAL
index|]
operator|)
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|QM_PORTAL
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ce_size
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
operator|(
name|vm_offset_t
operator|)
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|QM_PORTAL
index|]
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|QM_PORTAL
index|]
operator|)
operator|&&
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|QM_PORTAL
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ci_size
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
operator|(
name|vm_offset_t
operator|)
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|QM_PORTAL
index|]
operator|)
return|;
name|paddr
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"NetCommSW: "
literal|"Unable to translate virtual address 0x%08X!\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|pmap_track_page
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|paddr
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|XX_PhysToVirt
parameter_list|(
name|physAddress_t
name|addr
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|vm_page_t
name|page
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* Check CCSR */
if|if
condition|(
name|addr
operator|>=
name|ccsrbar_pa
operator|&&
name|addr
operator|<
name|ccsrbar_pa
operator|+
name|ccsrbar_size
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|addr
operator|-
name|ccsrbar_pa
argument_list|)
operator|+
name|ccsrbar_va
operator|)
operator|)
return|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* Handle BMAN mappings */
if|if
condition|(
operator|(
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
operator|&&
operator|(
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ce_size
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|BM_PORTAL
index|]
operator|+
call|(
name|vm_offset_t
call|)
argument_list|(
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
argument_list|)
operator|)
operator|)
return|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
operator|&&
operator|(
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ci_size
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|BM_PORTAL
index|]
operator|+
call|(
name|vm_offset_t
call|)
argument_list|(
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|BM_PORTAL
index|]
index|[
name|cpu
index|]
argument_list|)
operator|)
operator|)
return|;
comment|/* Handle QMAN mappings */
if|if
condition|(
operator|(
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
operator|&&
operator|(
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ce_size
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|QM_PORTAL
index|]
operator|+
call|(
name|vm_offset_t
call|)
argument_list|(
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
argument_list|)
operator|)
operator|)
return|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
operator|&&
operator|(
name|addr
operator|<
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|+
name|XX_PInfo
operator|.
name|portal_ci_size
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
operator|)
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|QM_PORTAL
index|]
operator|+
call|(
name|vm_offset_t
call|)
argument_list|(
name|addr
operator|-
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|QM_PORTAL
index|]
index|[
name|cpu
index|]
argument_list|)
operator|)
operator|)
return|;
name|page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|page
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|pv
operator|->
name|pv_va
operator|+
operator|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|&
name|PAGE_MASK
operator|)
operator|)
operator|)
return|;
name|printf
argument_list|(
literal|"NetCommSW: "
literal|"Unable to translate physical address 0x%08llX!\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|XX_PortalSetInfo
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|dev_name
decl_stmt|;
name|struct
name|dpaa_portals_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|type
decl_stmt|,
name|len
decl_stmt|;
name|dev_name
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dev_name
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
literal|"bman-portals"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dev_name
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|dev_name
argument_list|,
literal|"bman-portals"
argument_list|,
name|len
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|dev_name
argument_list|,
literal|"qman-portals"
argument_list|,
name|len
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|strncmp
argument_list|(
name|dev_name
argument_list|,
literal|"bman-portals"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|BM_PORTAL
expr_stmt|;
else|else
name|type
operator|=
name|QM_PORTAL
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sc
operator|->
name|sc_dp
index|[
name|i
index|]
operator|.
name|dp_ce_pa
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|XX_PInfo
operator|.
name|portal_ce_pa
index|[
name|type
index|]
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_dp
index|[
name|i
index|]
operator|.
name|dp_ce_pa
expr_stmt|;
name|XX_PInfo
operator|.
name|portal_ci_pa
index|[
name|type
index|]
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_dp
index|[
name|i
index|]
operator|.
name|dp_ci_pa
expr_stmt|;
name|XX_PInfo
operator|.
name|portal_ce_size
index|[
name|type
index|]
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_dp
index|[
name|i
index|]
operator|.
name|dp_ce_size
expr_stmt|;
name|XX_PInfo
operator|.
name|portal_ci_size
index|[
name|type
index|]
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_dp
index|[
name|i
index|]
operator|.
name|dp_ci_size
expr_stmt|;
name|XX_PInfo
operator|.
name|portal_intr
index|[
name|type
index|]
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_dp
index|[
name|i
index|]
operator|.
name|dp_intr_num
expr_stmt|;
block|}
name|XX_PInfo
operator|.
name|portal_ce_va
index|[
name|type
index|]
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_rres
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XX_PInfo
operator|.
name|portal_ci_va
index|[
name|type
index|]
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_rres
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|end
label|:
name|free
argument_list|(
name|dev_name
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

