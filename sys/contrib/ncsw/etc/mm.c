begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"sprint_ext.h"
end_include

begin_include
include|#
directive|include
file|"part_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"mm.h"
end_include

begin_comment
comment|/**********************************************************************  *                     MM internal routines set                       *  **********************************************************************/
end_comment

begin_comment
comment|/****************************************************************  *  Routine:   CreateBusyBlock  *  *  Description:  *      Initializes a new busy block of "size" bytes and started  *      rom "base" address. Each busy block has a name that  *      specified the purpose of the memory allocation.  *  *  Arguments:  *      base      - base address of the busy block  *      size      - size of the busy block  *      name      - name that specified the busy block  *  *  Return value:  *      A pointer to new created structure returned on success;  *      Otherwise, NULL.  ****************************************************************/
end_comment

begin_function
specifier|static
name|t_BusyBlock
modifier|*
name|CreateBusyBlock
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|t_BusyBlock
modifier|*
name|p_BusyBlock
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|p_BusyBlock
operator|=
operator|(
name|t_BusyBlock
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_BusyBlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_BusyBlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_BusyBlock
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|p_BusyBlock
operator|->
name|end
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|MM_MAX_NAME_LEN
condition|)
name|n
operator|=
name|MM_MAX_NAME_LEN
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|p_BusyBlock
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|MM_MAX_NAME_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_BusyBlock
operator|->
name|name
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_BusyBlock
operator|->
name|p_Next
operator|=
literal|0
expr_stmt|;
return|return
name|p_BusyBlock
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:   CreateNewBlock  *  *  Description:  *      Initializes a new memory block of "size" bytes and started  *      from "base" address.  *  *  Arguments:  *      base    - base address of the memory block  *      size    - size of the memory block  *  *  Return value:  *      A pointer to new created structure returned on success;  *      Otherwise, NULL.  ****************************************************************/
end_comment

begin_function
specifier|static
name|t_MemBlock
modifier|*
name|CreateNewBlock
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|t_MemBlock
modifier|*
name|p_MemBlock
decl_stmt|;
name|p_MemBlock
operator|=
operator|(
name|t_MemBlock
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_MemBlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_MemBlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_MemBlock
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|p_MemBlock
operator|->
name|end
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|p_MemBlock
operator|->
name|p_Next
operator|=
literal|0
expr_stmt|;
return|return
name|p_MemBlock
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:   CreateFreeBlock  *  *  Description:  *      Initializes a new free block of of "size" bytes and  *      started from "base" address.  *  *  Arguments:  *      base      - base address of the free block  *      size      - size of the free block  *  *  Return value:  *      A pointer to new created structure returned on success;  *      Otherwise, NULL.  ****************************************************************/
end_comment

begin_function
specifier|static
name|t_FreeBlock
modifier|*
name|CreateFreeBlock
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|t_FreeBlock
modifier|*
name|p_FreeBlock
decl_stmt|;
name|p_FreeBlock
operator|=
operator|(
name|t_FreeBlock
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FreeBlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FreeBlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FreeBlock
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|p_FreeBlock
operator|->
name|end
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|p_FreeBlock
operator|->
name|p_Next
operator|=
literal|0
expr_stmt|;
return|return
name|p_FreeBlock
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:    AddFree  *  *  Description:  *      Adds a new free block to the free lists. It updates each  *      free list to include a new free block.  *      Note, that all free block in each free list are ordered  *      by their base address.  *  *  Arguments:  *      p_MM  - pointer to the MM object  *      base  - base address of a given free block  *      end   - end address of a given free block  *  *  Return value:  *  *  ****************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|AddFree
parameter_list|(
name|t_MM
modifier|*
name|p_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|end
parameter_list|)
block|{
name|t_FreeBlock
modifier|*
name|p_PrevB
decl_stmt|,
modifier|*
name|p_CurrB
decl_stmt|,
modifier|*
name|p_NewB
decl_stmt|;
name|uint64_t
name|alignment
decl_stmt|;
name|uint64_t
name|alignBase
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Updates free lists to include  a just released block */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MM_MAX_ALIGNMENT
condition|;
name|i
operator|++
control|)
block|{
name|p_PrevB
operator|=
name|p_NewB
operator|=
literal|0
expr_stmt|;
name|p_CurrB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
expr_stmt|;
name|alignment
operator|=
call|(
name|uint64_t
call|)
argument_list|(
literal|0x1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|alignBase
operator|=
name|MAKE_ALIGNED
argument_list|(
name|base
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
comment|/* Goes to the next free list if there is no block to free */
if|if
condition|(
name|alignBase
operator|>=
name|end
condition|)
continue|continue;
comment|/* Looks for a free block that should be updated */
while|while
condition|(
name|p_CurrB
condition|)
block|{
if|if
condition|(
name|alignBase
operator|<=
name|p_CurrB
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|end
operator|>
name|p_CurrB
operator|->
name|end
condition|)
block|{
name|t_FreeBlock
modifier|*
name|p_NextB
decl_stmt|;
while|while
condition|(
name|p_CurrB
operator|->
name|p_Next
operator|&&
name|end
operator|>
name|p_CurrB
operator|->
name|p_Next
operator|->
name|end
condition|)
block|{
name|p_NextB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|p_CurrB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_NextB
argument_list|)
expr_stmt|;
block|}
name|p_NextB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
if|if
condition|(
operator|!
name|p_NextB
operator|||
operator|(
name|p_NextB
operator|&&
name|end
operator|<
name|p_NextB
operator|->
name|base
operator|)
condition|)
block|{
name|p_CurrB
operator|->
name|end
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
name|p_CurrB
operator|->
name|end
operator|=
name|p_NextB
operator|->
name|end
expr_stmt|;
name|p_CurrB
operator|->
name|p_Next
operator|=
name|p_NextB
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_NextB
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|end
operator|<
name|p_CurrB
operator|->
name|base
operator|)
operator|&&
operator|(
operator|(
name|end
operator|-
name|alignBase
operator|)
operator|>=
name|alignment
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_NewB
operator|=
name|CreateFreeBlock
argument_list|(
name|alignBase
argument_list|,
name|end
operator|-
name|alignBase
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_NewB
operator|->
name|p_Next
operator|=
name|p_CurrB
expr_stmt|;
if|if
condition|(
name|p_PrevB
condition|)
name|p_PrevB
operator|->
name|p_Next
operator|=
name|p_NewB
expr_stmt|;
else|else
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
operator|=
name|p_NewB
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|alignBase
operator|<
name|p_CurrB
operator|->
name|base
operator|)
operator|&&
operator|(
name|end
operator|>=
name|p_CurrB
operator|->
name|base
operator|)
condition|)
block|{
name|p_CurrB
operator|->
name|base
operator|=
name|alignBase
expr_stmt|;
block|}
comment|/* if size of the free block is less then alignment                  * deletes that free block from the free list. */
if|if
condition|(
operator|(
name|p_CurrB
operator|->
name|end
operator|-
name|p_CurrB
operator|->
name|base
operator|)
operator|<
name|alignment
condition|)
block|{
if|if
condition|(
name|p_PrevB
condition|)
name|p_PrevB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
else|else
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_CurrB
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|p_PrevB
operator|=
name|p_CurrB
expr_stmt|;
name|p_CurrB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
block|}
block|}
comment|/* If no free block found to be updated, insert a new free block          * to the end of the free list.          */
if|if
condition|(
operator|!
name|p_CurrB
operator|&&
operator|(
operator|(
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|end
operator|-
name|base
argument_list|)
operator|)
operator|&
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|alignment
operator|-
literal|1
argument_list|)
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_NewB
operator|=
name|CreateFreeBlock
argument_list|(
name|alignBase
argument_list|,
name|end
operator|-
name|base
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_PrevB
condition|)
name|p_PrevB
operator|->
name|p_Next
operator|=
name|p_NewB
expr_stmt|;
else|else
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
operator|=
name|p_NewB
expr_stmt|;
block|}
comment|/* Update boundaries of the new free block */
if|if
condition|(
operator|(
name|alignment
operator|==
literal|1
operator|)
operator|&&
operator|!
name|p_NewB
condition|)
block|{
if|if
condition|(
name|p_CurrB
operator|&&
name|base
operator|>
name|p_CurrB
operator|->
name|base
condition|)
name|base
operator|=
name|p_CurrB
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|p_CurrB
operator|&&
name|end
operator|<
name|p_CurrB
operator|->
name|end
condition|)
name|end
operator|=
name|p_CurrB
operator|->
name|end
expr_stmt|;
block|}
block|}
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:      CutFree  *  *  Description:  *      Cuts a free block from holdBase to holdEnd from the free lists.  *      That is, it updates all free lists of the MM object do  *      not include a block of memory from holdBase to holdEnd.  *      For each free lists it seek for a free block that holds  *      either holdBase or holdEnd. If such block is found it updates it.  *  *  Arguments:  *      p_MM            - pointer to the MM object  *      holdBase        - base address of the allocated block  *      holdEnd         - end address of the allocated block  *  *  Return value:  *      E_OK is returned on success,  *      otherwise returns an error code.  *  ****************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CutFree
parameter_list|(
name|t_MM
modifier|*
name|p_MM
parameter_list|,
name|uint64_t
name|holdBase
parameter_list|,
name|uint64_t
name|holdEnd
parameter_list|)
block|{
name|t_FreeBlock
modifier|*
name|p_PrevB
decl_stmt|,
modifier|*
name|p_CurrB
decl_stmt|,
modifier|*
name|p_NewB
decl_stmt|;
name|uint64_t
name|alignBase
decl_stmt|,
name|base
decl_stmt|,
name|end
decl_stmt|;
name|uint64_t
name|alignment
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MM_MAX_ALIGNMENT
condition|;
name|i
operator|++
control|)
block|{
name|p_PrevB
operator|=
name|p_NewB
operator|=
literal|0
expr_stmt|;
name|p_CurrB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
expr_stmt|;
name|alignment
operator|=
call|(
name|uint64_t
call|)
argument_list|(
literal|0x1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|alignBase
operator|=
name|MAKE_ALIGNED
argument_list|(
name|holdEnd
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_CurrB
condition|)
block|{
name|base
operator|=
name|p_CurrB
operator|->
name|base
expr_stmt|;
name|end
operator|=
name|p_CurrB
operator|->
name|end
expr_stmt|;
if|if
condition|(
operator|(
name|holdBase
operator|<=
name|base
operator|)
operator|&&
operator|(
name|holdEnd
operator|<=
name|end
operator|)
operator|&&
operator|(
name|holdEnd
operator|>
name|base
operator|)
condition|)
block|{
if|if
condition|(
name|alignBase
operator|>=
name|end
operator|||
operator|(
name|alignBase
operator|<
name|end
operator|&&
operator|(
operator|(
name|end
operator|-
name|alignBase
operator|)
operator|<
name|alignment
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p_PrevB
condition|)
name|p_PrevB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
else|else
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_CurrB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_CurrB
operator|->
name|base
operator|=
name|alignBase
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|holdBase
operator|>
name|base
operator|)
operator|&&
operator|(
name|holdEnd
operator|<=
name|end
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|holdBase
operator|-
name|base
operator|)
operator|>=
name|alignment
condition|)
block|{
if|if
condition|(
operator|(
name|alignBase
operator|<
name|end
operator|)
operator|&&
operator|(
operator|(
name|end
operator|-
name|alignBase
operator|)
operator|>=
name|alignment
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_NewB
operator|=
name|CreateFreeBlock
argument_list|(
name|alignBase
argument_list|,
name|end
operator|-
name|alignBase
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_NewB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|p_CurrB
operator|->
name|p_Next
operator|=
name|p_NewB
expr_stmt|;
block|}
name|p_CurrB
operator|->
name|end
operator|=
name|holdBase
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|alignBase
operator|<
name|end
operator|)
operator|&&
operator|(
operator|(
name|end
operator|-
name|alignBase
operator|)
operator|>=
name|alignment
operator|)
condition|)
block|{
name|p_CurrB
operator|->
name|base
operator|=
name|alignBase
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_PrevB
condition|)
name|p_PrevB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
else|else
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_CurrB
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|p_PrevB
operator|=
name|p_CurrB
expr_stmt|;
name|p_CurrB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:     AddBusy  *  *  Description:  *      Adds a new busy block to the list of busy blocks. Note,  *      that all busy blocks are ordered by their base address in  *      the busy list.  *  *  Arguments:  *      MM              - handler to the MM object  *      p_NewBusyB      - pointer to the a busy block  *  *  Return value:  *      None.  *  ****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AddBusy
parameter_list|(
name|t_MM
modifier|*
name|p_MM
parameter_list|,
name|t_BusyBlock
modifier|*
name|p_NewBusyB
parameter_list|)
block|{
name|t_BusyBlock
modifier|*
name|p_CurrBusyB
decl_stmt|,
modifier|*
name|p_PrevBusyB
decl_stmt|;
comment|/* finds a place of a new busy block in the list of busy blocks */
name|p_PrevBusyB
operator|=
literal|0
expr_stmt|;
name|p_CurrBusyB
operator|=
name|p_MM
operator|->
name|busyBlocks
expr_stmt|;
while|while
condition|(
name|p_CurrBusyB
operator|&&
name|p_NewBusyB
operator|->
name|base
operator|>
name|p_CurrBusyB
operator|->
name|base
condition|)
block|{
name|p_PrevBusyB
operator|=
name|p_CurrBusyB
expr_stmt|;
name|p_CurrBusyB
operator|=
name|p_CurrBusyB
operator|->
name|p_Next
expr_stmt|;
block|}
comment|/* insert the new busy block into the list of busy blocks */
if|if
condition|(
name|p_CurrBusyB
condition|)
name|p_NewBusyB
operator|->
name|p_Next
operator|=
name|p_CurrBusyB
expr_stmt|;
if|if
condition|(
name|p_PrevBusyB
condition|)
name|p_PrevBusyB
operator|->
name|p_Next
operator|=
name|p_NewBusyB
expr_stmt|;
else|else
name|p_MM
operator|->
name|busyBlocks
operator|=
name|p_NewBusyB
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:    CutBusy  *  *  Description:  *      Cuts a block from base to end from the list of busy blocks.  *      This is done by updating the list of busy blocks do not  *      include a given block, that block is going to be free. If a  *      given block is a part of some other busy block, so that  *      busy block is updated. If there are number of busy blocks  *      included in the given block, so all that blocks are removed  *      from the busy list and the end blocks are updated.  *      If the given block devides some block into two parts, a new  *      busy block is added to the busy list.  *  *  Arguments:  *      p_MM  - pointer to the MM object  *      base  - base address of a given busy block  *      end   - end address of a given busy block  *  *  Return value:  *      E_OK on success, E_NOMEMORY otherwise.  *  ****************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CutBusy
parameter_list|(
name|t_MM
modifier|*
name|p_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|end
parameter_list|)
block|{
name|t_BusyBlock
modifier|*
name|p_CurrB
decl_stmt|,
modifier|*
name|p_PrevB
decl_stmt|,
modifier|*
name|p_NewB
decl_stmt|;
name|p_CurrB
operator|=
name|p_MM
operator|->
name|busyBlocks
expr_stmt|;
name|p_PrevB
operator|=
name|p_NewB
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p_CurrB
condition|)
block|{
if|if
condition|(
name|base
operator|<
name|p_CurrB
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|end
operator|>
name|p_CurrB
operator|->
name|end
condition|)
block|{
name|t_BusyBlock
modifier|*
name|p_NextB
decl_stmt|;
while|while
condition|(
name|p_CurrB
operator|->
name|p_Next
operator|&&
name|end
operator|>=
name|p_CurrB
operator|->
name|p_Next
operator|->
name|end
condition|)
block|{
name|p_NextB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|p_CurrB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_NextB
argument_list|)
expr_stmt|;
block|}
name|p_NextB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
if|if
condition|(
name|p_NextB
operator|&&
name|end
operator|>
name|p_NextB
operator|->
name|base
condition|)
block|{
name|p_NextB
operator|->
name|base
operator|=
name|end
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base
operator|<=
name|p_CurrB
operator|->
name|base
condition|)
block|{
if|if
condition|(
name|end
operator|<
name|p_CurrB
operator|->
name|end
operator|&&
name|end
operator|>
name|p_CurrB
operator|->
name|base
condition|)
block|{
name|p_CurrB
operator|->
name|base
operator|=
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|>=
name|p_CurrB
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|p_PrevB
condition|)
name|p_PrevB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
else|else
name|p_MM
operator|->
name|busyBlocks
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_CurrB
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|end
operator|<
name|p_CurrB
operator|->
name|end
operator|&&
name|end
operator|>
name|p_CurrB
operator|->
name|base
condition|)
block|{
if|if
condition|(
operator|(
name|p_NewB
operator|=
name|CreateBusyBlock
argument_list|(
name|end
argument_list|,
name|p_CurrB
operator|->
name|end
operator|-
name|end
argument_list|,
name|p_CurrB
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_NewB
operator|->
name|p_Next
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
name|p_CurrB
operator|->
name|p_Next
operator|=
name|p_NewB
expr_stmt|;
block|}
name|p_CurrB
operator|->
name|end
operator|=
name|base
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|p_PrevB
operator|=
name|p_CurrB
expr_stmt|;
name|p_CurrB
operator|=
name|p_CurrB
operator|->
name|p_Next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************  *  Routine:     MmGetGreaterAlignment  *  *  Description:  *      Allocates a block of memory according to the given size  *      and the alignment. That routine is called from the MM_Get  *      routine if the required alignment is greater then MM_MAX_ALIGNMENT.  *      In that case, it goes over free blocks of 64 byte align list  *      and checks if it has the required size of bytes of the required  *      alignment. If no blocks found returns ILLEGAL_BASE.  *      After the block is found and data is allocated, it calls  *      the internal CutFree routine to update all free lists  *      do not include a just allocated block. Of course, each  *      free list contains a free blocks with the same alignment.  *      It is also creates a busy block that holds  *      information about an allocated block.  *  *  Arguments:  *      MM              - handle to the MM object  *      size            - size of the MM  *      alignment       - index as a power of two defines  *                        a required alignment that is greater then 64.  *      name            - the name that specifies an allocated block.  *  *  Return value:  *      base address of an allocated block.  *      ILLEGAL_BASE if can't allocate a block  *  ****************************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|MmGetGreaterAlignment
parameter_list|(
name|t_MM
modifier|*
name|p_MM
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|t_FreeBlock
modifier|*
name|p_FreeB
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_NewBusyB
decl_stmt|;
name|uint64_t
name|holdBase
decl_stmt|,
name|holdEnd
decl_stmt|,
name|alignBase
init|=
literal|0
decl_stmt|;
comment|/* goes over free blocks of the 64 byte alignment list        and look for a block of the suitable size and        base address according to the alignment. */
name|p_FreeB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|MM_MAX_ALIGNMENT
index|]
expr_stmt|;
while|while
condition|(
name|p_FreeB
condition|)
block|{
name|alignBase
operator|=
name|MAKE_ALIGNED
argument_list|(
name|p_FreeB
operator|->
name|base
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
comment|/* the block is found if the aligned base inside the block          * and has the anough size. */
if|if
condition|(
name|alignBase
operator|>=
name|p_FreeB
operator|->
name|base
operator|&&
name|alignBase
operator|<
name|p_FreeB
operator|->
name|end
operator|&&
name|size
operator|<=
operator|(
name|p_FreeB
operator|->
name|end
operator|-
name|alignBase
operator|)
condition|)
break|break;
else|else
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
block|}
comment|/* If such block isn't found */
if|if
condition|(
operator|!
name|p_FreeB
condition|)
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
name|holdBase
operator|=
name|alignBase
expr_stmt|;
name|holdEnd
operator|=
name|alignBase
operator|+
name|size
expr_stmt|;
comment|/* init a new busy block */
if|if
condition|(
operator|(
name|p_NewBusyB
operator|=
name|CreateBusyBlock
argument_list|(
name|holdBase
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
comment|/* calls Update routine to update a lists of free blocks */
if|if
condition|(
name|CutFree
argument_list|(
name|p_MM
argument_list|,
name|holdBase
argument_list|,
name|holdEnd
argument_list|)
operator|!=
name|E_OK
condition|)
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
comment|/* insert the new busy block into the list of busy blocks */
name|AddBusy
argument_list|(
name|p_MM
argument_list|,
name|p_NewBusyB
argument_list|)
expr_stmt|;
return|return
operator|(
name|holdBase
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *                     MM API routines set                            *  **********************************************************************/
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|MM_Init
parameter_list|(
name|t_Handle
modifier|*
name|h_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
decl_stmt|;
name|uint64_t
name|newBase
decl_stmt|,
name|newSize
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Size (should be positive)"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initializes a new MM object */
name|p_MM
operator|=
operator|(
name|t_MM
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_MM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_MM
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_MM
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_MM
operator|->
name|h_Spinlock
condition|)
block|{
name|XX_Free
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MM spinlock!"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* initializes a new memory block */
if|if
condition|(
operator|(
name|p_MM
operator|->
name|memBlocks
operator|=
name|CreateNewBlock
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* A busy list is empty */
name|p_MM
operator|->
name|busyBlocks
operator|=
literal|0
expr_stmt|;
comment|/*Initializes a new free block for each free list*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MM_MAX_ALIGNMENT
condition|;
name|i
operator|++
control|)
block|{
name|newBase
operator|=
name|MAKE_ALIGNED
argument_list|(
name|base
argument_list|,
operator|(
literal|0x1
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
name|newSize
operator|=
name|size
operator|-
operator|(
name|newBase
operator|-
name|base
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
operator|=
name|CreateFreeBlock
argument_list|(
name|newBase
argument_list|,
name|newSize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
operator|*
name|h_MM
operator|=
name|p_MM
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|MM_Free
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_MemBlock
modifier|*
name|p_MemBlock
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_BusyBlock
decl_stmt|;
name|t_FreeBlock
modifier|*
name|p_FreeBlock
decl_stmt|;
name|void
modifier|*
name|p_Block
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
comment|/* release memory allocated for busy blocks */
name|p_BusyBlock
operator|=
name|p_MM
operator|->
name|busyBlocks
expr_stmt|;
while|while
condition|(
name|p_BusyBlock
condition|)
block|{
name|p_Block
operator|=
name|p_BusyBlock
expr_stmt|;
name|p_BusyBlock
operator|=
name|p_BusyBlock
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Block
argument_list|)
expr_stmt|;
block|}
comment|/* release memory allocated for free blocks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MM_MAX_ALIGNMENT
condition|;
name|i
operator|++
control|)
block|{
name|p_FreeBlock
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p_FreeBlock
condition|)
block|{
name|p_Block
operator|=
name|p_FreeBlock
expr_stmt|;
name|p_FreeBlock
operator|=
name|p_FreeBlock
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* release memory allocated for memory blocks */
name|p_MemBlock
operator|=
name|p_MM
operator|->
name|memBlocks
expr_stmt|;
while|while
condition|(
name|p_MemBlock
condition|)
block|{
name|p_Block
operator|=
name|p_MemBlock
expr_stmt|;
name|p_MemBlock
operator|=
name|p_MemBlock
operator|->
name|p_Next
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_MM
operator|->
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
comment|/* release memory allocated for MM object itself */
name|XX_Free
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_Get
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_FreeBlock
modifier|*
name|p_FreeB
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_NewBusyB
decl_stmt|;
name|uint64_t
name|holdBase
decl_stmt|,
name|holdEnd
decl_stmt|,
name|j
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_MM
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
name|uint64_t
operator|)
name|ILLEGAL_BASE
argument_list|)
expr_stmt|;
comment|/* checks that alignment value is greater then zero */
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
block|{
name|alignment
operator|=
literal|1
expr_stmt|;
block|}
name|j
operator|=
name|alignment
expr_stmt|;
comment|/* checks if alignment is a power of two, if it correct and if the        required size is multiple of the given alignment. */
while|while
condition|(
operator|(
name|j
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|j
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* if the given alignment isn't power of two, returns an error */
if|if
condition|(
name|j
operator|!=
literal|1
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"alignment (should be power of 2)"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint64_t
operator|)
name|ILLEGAL_BASE
return|;
block|}
if|if
condition|(
name|i
operator|>
name|MM_MAX_ALIGNMENT
condition|)
block|{
return|return
operator|(
name|MmGetGreaterAlignment
argument_list|(
name|p_MM
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
comment|/* look for a block of the size greater or equal to the required size. */
name|p_FreeB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p_FreeB
operator|&&
operator|(
name|p_FreeB
operator|->
name|end
operator|-
name|p_FreeB
operator|->
name|base
operator|)
operator|<
name|size
condition|)
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
comment|/* If such block is found */
if|if
condition|(
operator|!
name|p_FreeB
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
name|holdBase
operator|=
name|p_FreeB
operator|->
name|base
expr_stmt|;
name|holdEnd
operator|=
name|holdBase
operator|+
name|size
expr_stmt|;
comment|/* init a new busy block */
if|if
condition|(
operator|(
name|p_NewBusyB
operator|=
name|CreateBusyBlock
argument_list|(
name|holdBase
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* calls Update routine to update a lists of free blocks */
if|if
condition|(
name|CutFree
argument_list|(
name|p_MM
argument_list|,
name|holdBase
argument_list|,
name|holdEnd
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* insert the new busy block into the list of busy blocks */
name|AddBusy
argument_list|(
name|p_MM
argument_list|,
name|p_NewBusyB
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|holdBase
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_GetForce
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_FreeBlock
modifier|*
name|p_FreeB
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_NewBusyB
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|bool
name|blockIsFree
init|=
name|FALSE
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|p_FreeB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
literal|0
index|]
expr_stmt|;
comment|/* The biggest free blocks are in the                                       free list with alignment 1 */
while|while
condition|(
name|p_FreeB
condition|)
block|{
if|if
condition|(
name|base
operator|>=
name|p_FreeB
operator|->
name|base
operator|&&
operator|(
name|base
operator|+
name|size
operator|)
operator|<=
name|p_FreeB
operator|->
name|end
condition|)
block|{
name|blockIsFree
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|blockIsFree
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* init a new busy block */
if|if
condition|(
operator|(
name|p_NewBusyB
operator|=
name|CreateBusyBlock
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* calls Update routine to update a lists of free blocks */
if|if
condition|(
name|CutFree
argument_list|(
name|p_MM
argument_list|,
name|base
argument_list|,
name|base
operator|+
name|size
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* insert the new busy block into the list of busy blocks */
name|AddBusy
argument_list|(
name|p_MM
argument_list|,
name|p_NewBusyB
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_GetForceMin
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|uint64_t
name|min
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_FreeBlock
modifier|*
name|p_FreeB
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_NewBusyB
decl_stmt|;
name|uint64_t
name|holdBase
decl_stmt|,
name|holdEnd
decl_stmt|,
name|j
init|=
name|alignment
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
comment|/* checks if alignment is a power of two, if it correct and if the        required size is multiple of the given alignment. */
while|while
condition|(
operator|(
name|j
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|j
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|!=
literal|1
operator|)
operator|||
operator|(
name|i
operator|>
name|MM_MAX_ALIGNMENT
operator|)
condition|)
block|{
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|p_FreeB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
expr_stmt|;
comment|/* look for the first block that contains the minimum        base address. If the whole required size may be fit        into it, use that block, otherwise look for the next        block of size greater or equal to the required size. */
while|while
condition|(
name|p_FreeB
operator|&&
operator|(
name|min
operator|>=
name|p_FreeB
operator|->
name|end
operator|)
condition|)
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
comment|/* If such block is found */
if|if
condition|(
operator|!
name|p_FreeB
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* if this block is large enough, use this block */
name|holdBase
operator|=
operator|(
name|min
operator|<=
name|p_FreeB
operator|->
name|base
operator|)
condition|?
name|p_FreeB
operator|->
name|base
else|:
name|min
expr_stmt|;
if|if
condition|(
operator|(
name|holdBase
operator|+
name|size
operator|)
operator|<=
name|p_FreeB
operator|->
name|end
condition|)
block|{
name|holdEnd
operator|=
name|holdBase
operator|+
name|size
expr_stmt|;
block|}
else|else
block|{
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
while|while
condition|(
name|p_FreeB
operator|&&
operator|(
operator|(
name|p_FreeB
operator|->
name|end
operator|-
name|p_FreeB
operator|->
name|base
operator|)
operator|<
name|size
operator|)
condition|)
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
comment|/* If such block is found */
if|if
condition|(
operator|!
name|p_FreeB
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
name|holdBase
operator|=
name|p_FreeB
operator|->
name|base
expr_stmt|;
name|holdEnd
operator|=
name|holdBase
operator|+
name|size
expr_stmt|;
block|}
comment|/* init a new busy block */
if|if
condition|(
operator|(
name|p_NewBusyB
operator|=
name|CreateBusyBlock
argument_list|(
name|holdBase
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* calls Update routine to update a lists of free blocks */
if|if
condition|(
name|CutFree
argument_list|(
name|p_MM
argument_list|,
name|holdBase
argument_list|,
name|holdEnd
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
name|ILLEGAL_BASE
argument_list|)
return|;
block|}
comment|/* insert the new busy block into the list of busy blocks */
name|AddBusy
argument_list|(
name|p_MM
argument_list|,
name|p_NewBusyB
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|holdBase
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_Put
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_BusyB
decl_stmt|,
modifier|*
name|p_PrevBusyB
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
comment|/* Look for a busy block that have the given base value.      * That block will be returned back to the memory.      */
name|p_PrevBusyB
operator|=
literal|0
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|p_BusyB
operator|=
name|p_MM
operator|->
name|busyBlocks
expr_stmt|;
while|while
condition|(
name|p_BusyB
operator|&&
name|base
operator|!=
name|p_BusyB
operator|->
name|base
condition|)
block|{
name|p_PrevBusyB
operator|=
name|p_BusyB
expr_stmt|;
name|p_BusyB
operator|=
name|p_BusyB
operator|->
name|p_Next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_BusyB
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|AddFree
argument_list|(
name|p_MM
argument_list|,
name|p_BusyB
operator|->
name|base
argument_list|,
name|p_BusyB
operator|->
name|end
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* removes a busy block form the list of busy blocks */
if|if
condition|(
name|p_PrevBusyB
condition|)
name|p_PrevBusyB
operator|->
name|p_Next
operator|=
name|p_BusyB
operator|->
name|p_Next
expr_stmt|;
else|else
name|p_MM
operator|->
name|busyBlocks
operator|=
name|p_BusyB
operator|->
name|p_Next
expr_stmt|;
name|size
operator|=
name|p_BusyB
operator|->
name|end
operator|-
name|p_BusyB
operator|->
name|base
expr_stmt|;
name|XX_Free
argument_list|(
name|p_BusyB
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_PutForce
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|uint64_t
name|end
init|=
name|base
operator|+
name|size
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|CutBusy
argument_list|(
name|p_MM
argument_list|,
name|base
argument_list|,
name|end
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|AddFree
argument_list|(
name|p_MM
argument_list|,
name|base
argument_list|,
name|end
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|MM_Add
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_MemBlock
modifier|*
name|p_MemB
decl_stmt|,
modifier|*
name|p_NewMemB
decl_stmt|;
name|t_Error
name|errCode
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
comment|/* find a last block in the list of memory blocks to insert a new      * memory block      */
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|p_MemB
operator|=
name|p_MM
operator|->
name|memBlocks
expr_stmt|;
while|while
condition|(
name|p_MemB
operator|->
name|p_Next
condition|)
block|{
if|if
condition|(
name|base
operator|>=
name|p_MemB
operator|->
name|base
operator|&&
name|base
operator|<
name|p_MemB
operator|->
name|end
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_MemB
operator|=
name|p_MemB
operator|->
name|p_Next
expr_stmt|;
block|}
comment|/* check for a last memory block */
if|if
condition|(
name|base
operator|>=
name|p_MemB
operator|->
name|base
operator|&&
name|base
operator|<
name|p_MemB
operator|->
name|end
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* create a new memory block */
if|if
condition|(
operator|(
name|p_NewMemB
operator|=
name|CreateNewBlock
argument_list|(
name|base
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* append a new memory block to the end of the list of memory blocks */
name|p_MemB
operator|->
name|p_Next
operator|=
name|p_NewMemB
expr_stmt|;
comment|/* add a new free block to the free lists */
name|errCode
operator|=
name|AddFree
argument_list|(
name|p_MM
argument_list|,
name|base
argument_list|,
name|base
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|p_MemB
operator|->
name|p_Next
operator|=
literal|0
expr_stmt|;
name|XX_Free
argument_list|(
name|p_NewMemB
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|t_Error
operator|)
name|errCode
operator|)
return|;
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_MM
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_GetMemBlock
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_MemBlock
modifier|*
name|p_MemBlock
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
name|p_MemBlock
operator|=
name|p_MM
operator|->
name|memBlocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
name|p_MemBlock
operator|=
name|p_MemBlock
operator|->
name|p_Next
expr_stmt|;
if|if
condition|(
name|p_MemBlock
condition|)
return|return
operator|(
name|p_MemBlock
operator|->
name|base
operator|)
return|;
else|else
return|return
operator|(
name|uint64_t
operator|)
name|ILLEGAL_BASE
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint64_t
name|MM_GetBase
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_MemBlock
modifier|*
name|p_MemBlock
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
name|p_MemBlock
operator|=
name|p_MM
operator|->
name|memBlocks
expr_stmt|;
return|return
name|p_MemBlock
operator|->
name|base
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|bool
name|MM_InRange
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_MemBlock
modifier|*
name|p_MemBlock
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MM
argument_list|)
expr_stmt|;
name|p_MemBlock
operator|=
name|p_MM
operator|->
name|memBlocks
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|>=
name|p_MemBlock
operator|->
name|base
operator|)
operator|&&
operator|(
name|addr
operator|<
name|p_MemBlock
operator|->
name|end
operator|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|MM_Dump
parameter_list|(
name|t_Handle
name|h_MM
parameter_list|,
name|void
modifier|*
name|buff
parameter_list|)
block|{
name|t_MM
modifier|*
name|p_MM
init|=
operator|(
name|t_MM
operator|*
operator|)
name|h_MM
decl_stmt|;
name|t_FreeBlock
modifier|*
name|p_FreeB
decl_stmt|;
name|t_BusyBlock
modifier|*
name|p_BusyB
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p_BusyB
operator|=
name|p_MM
operator|->
name|busyBlocks
expr_stmt|;
name|Sprint
argument_list|(
name|buff
argument_list|,
literal|"List of busy blocks:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_BusyB
condition|)
block|{
name|Sprint
argument_list|(
name|buff
argument_list|,
literal|"\t0x%p: (%s: b=0x%lx, e=0x%lx)\n"
argument_list|,
name|p_BusyB
argument_list|,
name|p_BusyB
operator|->
name|name
argument_list|,
name|p_BusyB
operator|->
name|base
argument_list|,
name|p_BusyB
operator|->
name|end
argument_list|)
expr_stmt|;
name|p_BusyB
operator|=
name|p_BusyB
operator|->
name|p_Next
expr_stmt|;
block|}
name|Sprint
argument_list|(
name|buff
argument_list|,
literal|"\nLists of free blocks according to alignment:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MM_MAX_ALIGNMENT
condition|;
name|i
operator|++
control|)
block|{
name|Sprint
argument_list|(
name|buff
argument_list|,
literal|"%d alignment:\n"
argument_list|,
operator|(
literal|0x1
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
name|p_FreeB
operator|=
name|p_MM
operator|->
name|freeBlocks
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p_FreeB
condition|)
block|{
name|Sprint
argument_list|(
name|buff
argument_list|,
literal|"\t0x%p: (b=0x%lx, e=0x%lx)\n"
argument_list|,
name|p_FreeB
argument_list|,
name|p_FreeB
operator|->
name|base
argument_list|,
name|p_FreeB
operator|->
name|end
argument_list|)
expr_stmt|;
name|p_FreeB
operator|=
name|p_FreeB
operator|->
name|p_Next
expr_stmt|;
block|}
name|Sprint
argument_list|(
name|buff
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

