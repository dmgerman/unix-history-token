begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************   Â© 1995-2003, 2004, 2005-2011 Freescale Semiconductor, Inc.  All rights reserved.   This is proprietary source code of Freescale Semiconductor Inc.,  and its use is subject to the NetComm Device Drivers EULA.  The copyright notice above does not evidence any actual or intended  publication of such source code.   ALTERNATIVELY, redistribution and use in source and binary forms, with  or without modification, are permitted provided that the following  conditions are met:      * Redistributions of source code must retain the above copyright        notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.      * Neither the name of Freescale Semiconductor nor the        names of its contributors may be used to endorse or promote products        derived from this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"part_ext.h"
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"mem_ext.h"
end_include

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_define
define|#
directive|define
name|PAD_ALIGNMENT
parameter_list|(
name|align
parameter_list|,
name|x
parameter_list|)
value|(((x)%(align)) ? ((align)-((x)%(align))) : 0)
end_define

begin_define
define|#
directive|define
name|ALIGN_BLOCK
parameter_list|(
name|p_Block
parameter_list|,
name|prefixSize
parameter_list|,
name|alignment
parameter_list|)
define|\
value|do {                                                            \         p_Block += (prefixSize);                                    \         p_Block += PAD_ALIGNMENT((alignment), (uintptr_t)(p_Block)); \     } while (0)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|GET_CALLER_ADDR
define|\
value|__asm__ ("mflr  %0" : "=r" (callerAddr))
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
end_elif

begin_comment
comment|/* NOTE: This implementation is only valid for CodeWarrior for PowerPC */
end_comment

begin_define
define|#
directive|define
name|GET_CALLER_ADDR
define|\
value|__asm__("add  %0, 0, %0" : : "r" (callerAddr))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__GNUC__) */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|__inline__
name|void
modifier|*
name|MemGet
parameter_list|(
name|t_MemorySegment
modifier|*
name|p_Mem
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p_Block
decl_stmt|;
comment|/* check if there is an available block */
if|if
condition|(
name|p_Mem
operator|->
name|current
operator|==
name|p_Mem
operator|->
name|num
condition|)
block|{
name|p_Mem
operator|->
name|getFailures
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get the block */
name|p_Block
operator|=
name|p_Mem
operator|->
name|p_BlocksStack
index|[
name|p_Mem
operator|->
name|current
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|p_Mem
operator|->
name|p_BlocksStack
index|[
name|p_Mem
operator|->
name|current
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* advance current index */
name|p_Mem
operator|->
name|current
operator|++
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|p_Block
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|__inline__
name|t_Error
name|MemPut
parameter_list|(
name|t_MemorySegment
modifier|*
name|p_Mem
parameter_list|,
name|void
modifier|*
name|p_Block
parameter_list|)
block|{
comment|/* check if blocks stack is full */
if|if
condition|(
name|p_Mem
operator|->
name|current
operator|>
literal|0
condition|)
block|{
comment|/* decrease current index */
name|p_Mem
operator|->
name|current
operator|--
expr_stmt|;
comment|/* put the block */
name|p_Mem
operator|->
name|p_BlocksStack
index|[
name|p_Mem
operator|->
name|current
index|]
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|p_Block
expr_stmt|;
return|return
name|E_OK
return|;
block|}
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
end_ifdef

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|InitMemDebugDatabase
parameter_list|(
name|t_MemorySegment
modifier|*
name|p_Mem
parameter_list|)
block|{
name|p_Mem
operator|->
name|p_MemDbg
operator|=
operator|(
name|void
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_MemDbg
argument_list|)
operator|*
name|p_Mem
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|p_MemDbg
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory debug object"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Mem
operator|->
name|p_MemDbg
argument_list|,
name|ILLEGAL_BASE
argument_list|,
sizeof|sizeof
argument_list|(
name|t_MemDbg
argument_list|)
operator|*
name|p_Mem
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|DebugMemGet
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|,
name|void
modifier|*
name|p_Block
parameter_list|,
name|uintptr_t
name|ownerAddress
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|t_MemDbg
modifier|*
name|p_MemDbg
init|=
operator|(
name|t_MemDbg
operator|*
operator|)
name|p_Mem
operator|->
name|p_MemDbg
decl_stmt|;
name|uint32_t
name|blockIndex
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|ownerAddress
operator|!=
name|ILLEGAL_BASE
argument_list|)
expr_stmt|;
comment|/* Find block num */
if|if
condition|(
name|p_Mem
operator|->
name|consecutiveMem
condition|)
block|{
name|blockIndex
operator|=
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Block
operator|-
operator|(
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
operator|+
name|p_Mem
operator|->
name|blockOffset
operator|)
operator|)
operator|/
name|p_Mem
operator|->
name|blockSize
operator|)
expr_stmt|;
block|}
else|else
block|{
name|blockIndex
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Block
operator|-
literal|4
operator|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|blockIndex
operator|<
name|p_Mem
operator|->
name|num
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_MemDbg
index|[
name|blockIndex
index|]
operator|.
name|ownerAddress
operator|==
name|ILLEGAL_BASE
argument_list|)
expr_stmt|;
name|p_MemDbg
index|[
name|blockIndex
index|]
operator|.
name|ownerAddress
operator|=
name|ownerAddress
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|DebugMemPut
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|,
name|void
modifier|*
name|p_Block
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|t_MemDbg
modifier|*
name|p_MemDbg
init|=
operator|(
name|t_MemDbg
operator|*
operator|)
name|p_Mem
operator|->
name|p_MemDbg
decl_stmt|;
name|uint32_t
name|blockIndex
decl_stmt|;
name|uint8_t
modifier|*
name|p_Temp
decl_stmt|;
comment|/* Find block num */
if|if
condition|(
name|p_Mem
operator|->
name|consecutiveMem
condition|)
block|{
name|blockIndex
operator|=
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Block
operator|-
operator|(
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
operator|+
name|p_Mem
operator|->
name|blockOffset
operator|)
operator|)
operator|/
name|p_Mem
operator|->
name|blockSize
operator|)
expr_stmt|;
if|if
condition|(
name|blockIndex
operator|>=
name|p_Mem
operator|->
name|num
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_ADDRESS
argument_list|,
operator|(
literal|"Freed address (0x%08x) does not belong to this pool"
operator|,
name|p_Block
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|blockIndex
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Block
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|blockIndex
operator|>=
name|p_Mem
operator|->
name|num
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_ADDRESS
argument_list|,
operator|(
literal|"Freed address (0x%08x) does not belong to this pool"
operator|,
name|p_Block
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Verify that the block matches the corresponding base */
name|p_Temp
operator|=
name|p_Mem
operator|->
name|p_Bases
index|[
name|blockIndex
index|]
expr_stmt|;
name|ALIGN_BLOCK
argument_list|(
name|p_Temp
argument_list|,
name|p_Mem
operator|->
name|prefixSize
argument_list|,
name|p_Mem
operator|->
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Temp
operator|==
name|p_Mem
operator|->
name|p_Bases
index|[
name|blockIndex
index|]
condition|)
name|p_Temp
operator|+=
name|p_Mem
operator|->
name|alignment
expr_stmt|;
if|if
condition|(
name|p_Temp
operator|!=
name|p_Block
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_ADDRESS
argument_list|,
operator|(
literal|"Freed address (0x%08x) does not belong to this pool"
operator|,
name|p_Block
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_MemDbg
index|[
name|blockIndex
index|]
operator|.
name|ownerAddress
operator|==
name|ILLEGAL_BASE
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_FREE
argument_list|,
operator|(
literal|"Attempt to free unallocated address (0x%08x)"
operator|,
name|p_Block
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_MemDbg
index|[
name|blockIndex
index|]
operator|.
name|ownerAddress
operator|=
operator|(
name|uintptr_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_MEM_LEAKS */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint32_t
name|MEM_ComputePartitionSize
parameter_list|(
name|uint32_t
name|num
parameter_list|,
name|uint16_t
name|dataSize
parameter_list|,
name|uint16_t
name|prefixSize
parameter_list|,
name|uint16_t
name|postfixSize
parameter_list|,
name|uint16_t
name|alignment
parameter_list|)
block|{
name|uint32_t
name|blockSize
init|=
literal|0
decl_stmt|,
name|pad1
init|=
literal|0
decl_stmt|,
name|pad2
init|=
literal|0
decl_stmt|;
comment|/* Make sure that the alignment is at least 4 */
if|if
condition|(
name|alignment
operator|<
literal|4
condition|)
block|{
name|alignment
operator|=
literal|4
expr_stmt|;
block|}
name|pad1
operator|=
operator|(
name|uint32_t
operator|)
name|PAD_ALIGNMENT
argument_list|(
literal|4
argument_list|,
name|prefixSize
argument_list|)
expr_stmt|;
comment|/* Block size not including 2nd padding */
name|blockSize
operator|=
name|pad1
operator|+
name|prefixSize
operator|+
name|dataSize
operator|+
name|postfixSize
expr_stmt|;
name|pad2
operator|=
name|PAD_ALIGNMENT
argument_list|(
name|alignment
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
comment|/* Block size including 2nd padding */
name|blockSize
operator|+=
name|pad2
expr_stmt|;
return|return
operator|(
operator|(
name|num
operator|*
name|blockSize
operator|)
operator|+
name|alignment
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|MEM_Init
parameter_list|(
name|char
name|name
index|[]
parameter_list|,
name|t_Handle
modifier|*
name|p_Handle
parameter_list|,
name|uint32_t
name|num
parameter_list|,
name|uint16_t
name|dataSize
parameter_list|,
name|uint16_t
name|prefixSize
parameter_list|,
name|uint16_t
name|postfixSize
parameter_list|,
name|uint16_t
name|alignment
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p_Memory
decl_stmt|;
name|uint32_t
name|allocSize
decl_stmt|;
name|t_Error
name|errCode
decl_stmt|;
name|allocSize
operator|=
name|MEM_ComputePartitionSize
argument_list|(
name|num
argument_list|,
name|dataSize
argument_list|,
name|prefixSize
argument_list|,
name|postfixSize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|p_Memory
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|allocSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memory
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment"
operator|)
argument_list|)
expr_stmt|;
block|}
name|errCode
operator|=
name|MEM_InitByAddress
argument_list|(
name|name
argument_list|,
name|p_Handle
argument_list|,
name|num
argument_list|,
name|dataSize
argument_list|,
name|prefixSize
argument_list|,
name|postfixSize
argument_list|,
name|alignment
argument_list|,
name|p_Memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|t_MemorySegment
operator|*
operator|)
operator|(
operator|*
name|p_Handle
operator|)
operator|)
operator|->
name|allocOwner
operator|=
name|e_MEM_ALLOC_OWNER_LOCAL
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|MEM_InitByAddress
parameter_list|(
name|char
name|name
index|[]
parameter_list|,
name|t_Handle
modifier|*
name|p_Handle
parameter_list|,
name|uint32_t
name|num
parameter_list|,
name|uint16_t
name|dataSize
parameter_list|,
name|uint16_t
name|prefixSize
parameter_list|,
name|uint16_t
name|postfixSize
parameter_list|,
name|uint16_t
name|alignment
parameter_list|,
name|uint8_t
modifier|*
name|p_Memory
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|blockSize
decl_stmt|;
name|uint16_t
name|alignPad
decl_stmt|,
name|endPad
decl_stmt|;
name|uint8_t
modifier|*
name|p_Blocks
decl_stmt|;
comment|/* prepare in case of error */
operator|*
name|p_Handle
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memory
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NULL_POINTER
argument_list|,
operator|(
literal|"Memory blocks"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Blocks
operator|=
name|p_Memory
expr_stmt|;
comment|/* make sure that the alignment is at least 4 and power of 2 */
if|if
condition|(
name|alignment
operator|<
literal|4
condition|)
block|{
name|alignment
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|alignment
argument_list|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Alignment (should be power of 2)"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* first allocate the segment descriptor */
name|p_Mem
operator|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_MemorySegment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment structure"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* allocate the blocks stack */
name|p_Mem
operator|->
name|p_BlocksStack
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|p_BlocksStack
condition|)
block|{
name|XX_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment block pointers stack"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* allocate the blocks bases array */
name|p_Mem
operator|->
name|p_Bases
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|p_Bases
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment base pointers array"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Mem
operator|->
name|p_Bases
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store info about this segment */
name|p_Mem
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|p_Mem
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|p_Mem
operator|->
name|dataSize
operator|=
name|dataSize
expr_stmt|;
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
operator|=
name|p_Blocks
expr_stmt|;
name|p_Mem
operator|->
name|getFailures
operator|=
literal|0
expr_stmt|;
name|p_Mem
operator|->
name|allocOwner
operator|=
name|e_MEM_ALLOC_OWNER_EXTERNAL
expr_stmt|;
name|p_Mem
operator|->
name|consecutiveMem
operator|=
name|TRUE
expr_stmt|;
name|p_Mem
operator|->
name|prefixSize
operator|=
name|prefixSize
expr_stmt|;
name|p_Mem
operator|->
name|postfixSize
operator|=
name|postfixSize
expr_stmt|;
name|p_Mem
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
comment|/* store name */
name|strncpy
argument_list|(
name|p_Mem
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|MEM_MAX_NAME_LENGTH
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_Mem
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|h_Spinlock
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't create spinlock!"
operator|)
argument_list|)
expr_stmt|;
block|}
name|alignPad
operator|=
operator|(
name|uint16_t
operator|)
name|PAD_ALIGNMENT
argument_list|(
literal|4
argument_list|,
name|prefixSize
argument_list|)
expr_stmt|;
comment|/* Make sure the entire size is a multiple of alignment */
name|endPad
operator|=
operator|(
name|uint16_t
operator|)
name|PAD_ALIGNMENT
argument_list|(
name|alignment
argument_list|,
operator|(
name|alignPad
operator|+
name|prefixSize
operator|+
name|dataSize
operator|+
name|postfixSize
operator|)
argument_list|)
expr_stmt|;
comment|/* The following manipulation places the data of block[0] in an aligned address,        since block size is aligned the following block datas will all be aligned */
name|ALIGN_BLOCK
argument_list|(
name|p_Blocks
argument_list|,
name|prefixSize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|blockSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|alignPad
operator|+
name|prefixSize
operator|+
name|dataSize
operator|+
name|postfixSize
operator|+
name|endPad
argument_list|)
expr_stmt|;
comment|/* initialize the blocks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|p_Mem
operator|->
name|p_BlocksStack
index|[
name|i
index|]
operator|=
name|p_Blocks
expr_stmt|;
name|p_Blocks
operator|+=
name|blockSize
expr_stmt|;
block|}
comment|/* return handle to caller */
operator|*
name|p_Handle
operator|=
operator|(
name|t_Handle
operator|)
name|p_Mem
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
block|{
name|t_Error
name|errCode
init|=
name|InitMemDebugDatabase
argument_list|(
name|p_Mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_Mem
operator|->
name|blockOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Mem
operator|->
name|p_BlocksStack
index|[
literal|0
index|]
operator|-
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p_Mem
operator|->
name|blockSize
operator|=
name|blockSize
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|MEM_InitSmart
parameter_list|(
name|char
name|name
index|[]
parameter_list|,
name|t_Handle
modifier|*
name|p_Handle
parameter_list|,
name|uint32_t
name|num
parameter_list|,
name|uint16_t
name|dataSize
parameter_list|,
name|uint16_t
name|prefixSize
parameter_list|,
name|uint16_t
name|postfixSize
parameter_list|,
name|uint16_t
name|alignment
parameter_list|,
name|uint8_t
name|memPartitionId
parameter_list|,
name|bool
name|consecutiveMem
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|blockSize
decl_stmt|;
name|uint16_t
name|alignPad
decl_stmt|,
name|endPad
decl_stmt|;
comment|/* prepare in case of error */
operator|*
name|p_Handle
operator|=
name|NULL
expr_stmt|;
comment|/* make sure that size is always a multiple of 4 */
if|if
condition|(
name|dataSize
operator|&
literal|3
condition|)
block|{
name|dataSize
operator|&=
operator|~
literal|3
expr_stmt|;
name|dataSize
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* make sure that the alignment is at least 4 and power of 2 */
if|if
condition|(
name|alignment
operator|<
literal|4
condition|)
block|{
name|alignment
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|alignment
argument_list|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Alignment (should be power of 2)"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* first allocate the segment descriptor */
name|p_Mem
operator|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_MemorySegment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment structure"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* allocate the blocks stack */
name|p_Mem
operator|->
name|p_BlocksStack
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|p_BlocksStack
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment block pointers stack"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* allocate the blocks bases array */
name|p_Mem
operator|->
name|p_Bases
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|XX_Malloc
argument_list|(
operator|(
name|consecutiveMem
condition|?
literal|1
else|:
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|p_Bases
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment base pointers array"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Mem
operator|->
name|p_Bases
argument_list|,
literal|0
argument_list|,
operator|(
name|consecutiveMem
condition|?
literal|1
else|:
name|num
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store info about this segment */
name|p_Mem
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|p_Mem
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|p_Mem
operator|->
name|dataSize
operator|=
name|dataSize
expr_stmt|;
name|p_Mem
operator|->
name|getFailures
operator|=
literal|0
expr_stmt|;
name|p_Mem
operator|->
name|allocOwner
operator|=
name|e_MEM_ALLOC_OWNER_LOCAL_SMART
expr_stmt|;
name|p_Mem
operator|->
name|consecutiveMem
operator|=
name|consecutiveMem
expr_stmt|;
name|p_Mem
operator|->
name|prefixSize
operator|=
name|prefixSize
expr_stmt|;
name|p_Mem
operator|->
name|postfixSize
operator|=
name|postfixSize
expr_stmt|;
name|p_Mem
operator|->
name|alignment
operator|=
name|alignment
expr_stmt|;
name|p_Mem
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_Mem
operator|->
name|h_Spinlock
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't create spinlock!"
operator|)
argument_list|)
expr_stmt|;
block|}
name|alignPad
operator|=
operator|(
name|uint16_t
operator|)
name|PAD_ALIGNMENT
argument_list|(
literal|4
argument_list|,
name|prefixSize
argument_list|)
expr_stmt|;
comment|/* Make sure the entire size is a multiple of alignment */
name|endPad
operator|=
operator|(
name|uint16_t
operator|)
name|PAD_ALIGNMENT
argument_list|(
name|alignment
argument_list|,
name|alignPad
operator|+
name|prefixSize
operator|+
name|dataSize
operator|+
name|postfixSize
argument_list|)
expr_stmt|;
comment|/* Calculate blockSize */
name|blockSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|alignPad
operator|+
name|prefixSize
operator|+
name|dataSize
operator|+
name|postfixSize
operator|+
name|endPad
argument_list|)
expr_stmt|;
comment|/* Now allocate the blocks */
if|if
condition|(
name|p_Mem
operator|->
name|consecutiveMem
condition|)
block|{
comment|/* |alignment - 1| bytes at most will be discarded in the beginning of the            received segment for alignment reasons, therefore the allocation is of:            (alignment + (num * block size)). */
name|uint8_t
modifier|*
name|p_Blocks
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|XX_MallocSmart
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|num
operator|*
name|blockSize
operator|)
operator|+
name|alignment
argument_list|)
argument_list|,
name|memPartitionId
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_Blocks
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment blocks"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store the memory segment address */
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
operator|=
name|p_Blocks
expr_stmt|;
comment|/* The following manipulation places the data of block[0] in an aligned address,            since block size is aligned the following block datas will all be aligned.*/
name|ALIGN_BLOCK
argument_list|(
name|p_Blocks
argument_list|,
name|prefixSize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
comment|/* initialize the blocks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|p_Mem
operator|->
name|p_BlocksStack
index|[
name|i
index|]
operator|=
name|p_Blocks
expr_stmt|;
name|p_Blocks
operator|+=
name|blockSize
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
name|p_Mem
operator|->
name|blockOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Mem
operator|->
name|p_BlocksStack
index|[
literal|0
index|]
operator|-
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p_Mem
operator|->
name|blockSize
operator|=
name|blockSize
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
block|}
else|else
block|{
comment|/* |alignment - 1| bytes at most will be discarded in the beginning of the            received segment for alignment reasons, therefore the allocation is of:            (alignment + block size). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|p_Block
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|XX_MallocSmart
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|blockSize
operator|+
name|alignment
argument_list|)
argument_list|,
name|memPartitionId
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_Block
condition|)
block|{
name|MEM_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory segment blocks"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store the memory segment address */
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
operator|=
name|p_Block
expr_stmt|;
comment|/* The following places the data of each block in an aligned address */
name|ALIGN_BLOCK
argument_list|(
name|p_Block
argument_list|,
name|prefixSize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
comment|/* Need 4 bytes before the meaningful bytes to store the block index.                We know we have them because alignment is at least 4 bytes. */
if|if
condition|(
name|p_Block
operator|==
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
condition|)
name|p_Block
operator|+=
name|alignment
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|p_Block
operator|-
literal|4
operator|)
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
name|p_Mem
operator|->
name|p_BlocksStack
index|[
name|i
index|]
operator|=
name|p_Block
expr_stmt|;
block|}
block|}
comment|/* store name */
name|strncpy
argument_list|(
name|p_Mem
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|MEM_MAX_NAME_LENGTH
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* return handle to caller */
operator|*
name|p_Handle
operator|=
operator|(
name|t_Handle
operator|)
name|p_Mem
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
block|{
name|t_Error
name|errCode
init|=
name|InitMemDebugDatabase
argument_list|(
name|p_Mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|MEM_Free
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|uint32_t
name|num
decl_stmt|,
name|i
decl_stmt|;
comment|/* Check MEM leaks */
name|MEM_CheckLeaks
argument_list|(
name|h_Mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Mem
condition|)
block|{
name|num
operator|=
name|p_Mem
operator|->
name|consecutiveMem
condition|?
literal|1
else|:
name|p_Mem
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|p_Mem
operator|->
name|allocOwner
operator|==
name|e_MEM_ALLOC_OWNER_LOCAL_SMART
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
condition|)
block|{
name|XX_FreeSmart
argument_list|(
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|p_Mem
operator|->
name|allocOwner
operator|==
name|e_MEM_ALLOC_OWNER_LOCAL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
condition|)
block|{
name|XX_Free
argument_list|(
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p_Mem
operator|->
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Mem
operator|->
name|p_Bases
condition|)
name|XX_Free
argument_list|(
name|p_Mem
operator|->
name|p_Bases
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Mem
operator|->
name|p_BlocksStack
condition|)
name|XX_Free
argument_list|(
name|p_Mem
operator|->
name|p_BlocksStack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
if|if
condition|(
name|p_Mem
operator|->
name|p_MemDbg
condition|)
name|XX_Free
argument_list|(
name|p_Mem
operator|->
name|p_MemDbg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
name|XX_Free
argument_list|(
name|p_Mem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
modifier|*
name|MEM_Get
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|uint8_t
modifier|*
name|p_Block
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
name|uintptr_t
name|callerAddr
init|=
literal|0
decl_stmt|;
name|GET_CALLER_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
name|ASSERT_COND
argument_list|(
name|h_Mem
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
comment|/* check if there is an available block */
if|if
condition|(
operator|(
name|p_Block
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|MemGet
argument_list|(
name|p_Mem
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
name|DebugMemGet
argument_list|(
name|p_Mem
argument_list|,
name|p_Block
argument_list|,
name|callerAddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|p_Block
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|uint16_t
name|MEM_GetN
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|,
name|uint32_t
name|num
parameter_list|,
name|void
modifier|*
name|array
index|[]
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|uint32_t
name|availableBlocks
decl_stmt|;
specifier|register
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
name|uintptr_t
name|callerAddr
init|=
literal|0
decl_stmt|;
name|GET_CALLER_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
name|ASSERT_COND
argument_list|(
name|h_Mem
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
comment|/* check how many blocks are available */
name|availableBlocks
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Mem
operator|->
name|num
operator|-
name|p_Mem
operator|->
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|availableBlocks
condition|)
block|{
name|num
operator|=
name|availableBlocks
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* get pointer to block */
if|if
condition|(
operator|(
name|array
index|[
name|i
index|]
operator|=
name|MemGet
argument_list|(
name|p_Mem
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
name|DebugMemGet
argument_list|(
name|p_Mem
argument_list|,
name|array
index|[
name|i
index|]
argument_list|,
name|callerAddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|i
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|MEM_Put
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|,
name|void
modifier|*
name|p_Block
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|t_Error
name|rc
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Mem
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
comment|/* check if blocks stack is full */
if|if
condition|(
operator|(
name|rc
operator|=
name|MemPut
argument_list|(
name|p_Mem
argument_list|,
name|p_Block
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|rc
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
name|DebugMemPut
argument_list|(
name|p_Mem
argument_list|,
name|p_Block
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_MEM_LEAKS */
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_Mem
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_MEM_LEAKS
end_ifdef

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|MEM_CheckLeaks
parameter_list|(
name|t_Handle
name|h_Mem
parameter_list|)
block|{
name|t_MemorySegment
modifier|*
name|p_Mem
init|=
operator|(
name|t_MemorySegment
operator|*
operator|)
name|h_Mem
decl_stmt|;
name|t_MemDbg
modifier|*
name|p_MemDbg
init|=
operator|(
name|t_MemDbg
operator|*
operator|)
name|p_Mem
operator|->
name|p_MemDbg
decl_stmt|;
name|uint8_t
modifier|*
name|p_Block
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Mem
operator|->
name|consecutiveMem
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Mem
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_MemDbg
index|[
name|i
index|]
operator|.
name|ownerAddress
operator|!=
name|ILLEGAL_BASE
condition|)
block|{
comment|/* Find the block address */
name|p_Block
operator|=
operator|(
operator|(
name|p_Mem
operator|->
name|p_Bases
index|[
literal|0
index|]
operator|+
name|p_Mem
operator|->
name|blockOffset
operator|)
operator|+
operator|(
name|i
operator|*
name|p_Mem
operator|->
name|blockSize
operator|)
operator|)
expr_stmt|;
name|XX_Print
argument_list|(
literal|"MEM leak: 0x%08x, Caller address: 0x%08x\n"
argument_list|,
name|p_Block
argument_list|,
name|p_MemDbg
index|[
name|i
index|]
operator|.
name|ownerAddress
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Mem
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_MemDbg
index|[
name|i
index|]
operator|.
name|ownerAddress
operator|!=
name|ILLEGAL_BASE
condition|)
block|{
comment|/* Find the block address */
name|p_Block
operator|=
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
expr_stmt|;
name|ALIGN_BLOCK
argument_list|(
name|p_Block
argument_list|,
name|p_Mem
operator|->
name|prefixSize
argument_list|,
name|p_Mem
operator|->
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Block
operator|==
name|p_Mem
operator|->
name|p_Bases
index|[
name|i
index|]
condition|)
name|p_Block
operator|+=
name|p_Mem
operator|->
name|alignment
expr_stmt|;
name|XX_Print
argument_list|(
literal|"MEM leak: 0x%08x, Caller address: 0x%08x\n"
argument_list|,
name|p_Block
argument_list|,
name|p_MemDbg
index|[
name|i
index|]
operator|.
name|ownerAddress
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_MEM_LEAKS */
end_comment

end_unit

