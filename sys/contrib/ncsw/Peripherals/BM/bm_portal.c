begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************   Â© 1995-2003, 2004, 2005-2011 Freescale Semiconductor, Inc.  All rights reserved.   This is proprietary source code of Freescale Semiconductor Inc.,  and its use is subject to the NetComm Device Drivers EULA.  The copyright notice above does not evidence any actual or intended  publication of such source code.   ALTERNATIVELY, redistribution and use in source and binary forms, with  or without modification, are permitted provided that the following  conditions are met:      * Redistributions of source code must retain the above copyright        notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.      * Neither the name of Freescale Semiconductor nor the        names of its contributors may be used to endorse or promote products        derived from this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  @File          bm.c   @Description   BM */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"mem_ext.h"
end_include

begin_include
include|#
directive|include
file|"core_ext.h"
end_include

begin_include
include|#
directive|include
file|"bm.h"
end_include

begin_define
define|#
directive|define
name|__ERR_MODULE__
value|MODULE_BM
end_define

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|__poll_portal_slow
parameter_list|(
name|t_BmPortal
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__poll_portal_fast
parameter_list|(
name|t_BmPortal
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Portal interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|portal_isr
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|portal
init|=
name|ptr
decl_stmt|;
comment|/* Only do fast-path handling if it's required */
if|if
condition|(
name|portal
operator|->
name|flags
operator|&
name|BMAN_PORTAL_FLAG_IRQ_FAST
condition|)
name|__poll_portal_fast
argument_list|(
name|portal
argument_list|)
expr_stmt|;
name|__poll_portal_slow
argument_list|(
name|portal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * bman_create_portal - Manage a Bman s/w portal  * @portal: the s/w corenet portal to use  * @flags: bit-mask of BMAN_PORTAL_FLAG_*** options  * @pools: bit-array of buffer pools available to this portal  * @portal_ctx: opaque user-supplied data to be associated with the portal  *  * Creates a managed portal object. @irq is only used if @flags specifies  * BMAN_PORTAL_FLAG_IRQ. @pools is copied, so the caller can do as they please  * with it after the function returns. It will only be possible to configure  * buffer pool objects as "suppliers" if they are specified in @pools, and the  * driver will only track depletion state changes to the same subset of buffer  * pools. If @pools is NULL, buffer pool depletion state will not be tracked.  * If the BMAN_PORTAL_FLAG_RECOVER flag is specified, then the function will  * attempt to expire any existing RCR entries, otherwise the function will fail  * if RCR is non-empty. If the BMAN_PORTAL_FLAG_WAIT flag is set, the function  * is allowed to block waiting for expiration of RCR. BMAN_PORTAL_FLAG_WAIT_INT  * makes any blocking interruptible.  */
end_comment

begin_function
specifier|static
name|t_Error
name|bman_create_portal
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
specifier|const
name|struct
name|bman_depletion
modifier|*
name|pools
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uint8_t
name|bpid
init|=
literal|0
decl_stmt|;
name|e_BmPortalRcrConsumeMode
name|rcr_cmode
decl_stmt|;
name|e_BmPortalProduceMode
name|pmode
decl_stmt|;
name|pmode
operator|=
name|e_BmPortalPVB
expr_stmt|;
name|rcr_cmode
operator|=
operator|(
name|flags
operator|&
name|BMAN_PORTAL_FLAG_CACHE
operator|)
condition|?
name|e_BmPortalRcrCCE
else|:
name|e_BmPortalRcrCCI
expr_stmt|;
switch|switch
condition|(
name|pmode
condition|)
block|{
case|case
name|e_BmPortalPCI
case|:
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmCommitCb
operator|=
name|bm_rcr_pci_commit
expr_stmt|;
break|break;
case|case
name|e_BmPortalPCE
case|:
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmCommitCb
operator|=
name|bm_rcr_pce_commit
expr_stmt|;
break|break;
case|case
name|e_BmPortalPVB
case|:
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmCommitCb
operator|=
name|bm_rcr_pvb_commit
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|rcr_cmode
condition|)
block|{
case|case
name|e_BmPortalRcrCCI
case|:
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmUpdateCb
operator|=
name|bm_rcr_cci_update
expr_stmt|;
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmPrefetchCb
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|e_BmPortalRcrCCE
case|:
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmUpdateCb
operator|=
name|bm_rcr_cce_update
expr_stmt|;
name|p_BmPortal
operator|->
name|cbs
index|[
name|BM_RCR_RING
index|]
operator|.
name|f_BmPrefetchCb
operator|=
name|bm_rcr_cce_prefetch
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bm_rcr_init
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|pmode
argument_list|,
name|rcr_cmode
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"RCR initialization failed"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_rcr
goto|;
block|}
if|if
condition|(
name|bm_mc_init
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"MC initialization failed"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_mc
goto|;
block|}
name|p_BmPortal
operator|->
name|pools
index|[
literal|0
index|]
operator|=
operator|*
name|pools
expr_stmt|;
name|bman_depletion_init
argument_list|(
operator|&
name|p_BmPortal
operator|->
name|pools
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bpid
operator|<
name|BM_MAX_NUM_OF_POOLS
condition|)
block|{
comment|/* Default to all BPIDs disabled, we enable as required          * at run-time. */
name|bm_isr_bscn_mask
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|bpid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bpid
operator|++
expr_stmt|;
block|}
name|p_BmPortal
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|p_BmPortal
operator|->
name|slowpoll
operator|=
literal|0
expr_stmt|;
name|p_BmPortal
operator|->
name|rcrProd
operator|=
name|p_BmPortal
operator|->
name|rcrCons
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p_BmPortal
operator|->
name|depletionPoolsTable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p_BmPortal
operator|->
name|depletionPoolsTable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write-to-clear any stale interrupt status bits */
name|bm_isr_disable_write
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bm_isr_status_clear
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bm_isr_enable_write
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|BM_PIRQ_RCRI
operator||
name|BM_PIRQ_BSCN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BMAN_PORTAL_FLAG_IRQ
condition|)
block|{
name|XX_SetIntr
argument_list|(
name|p_BmPortal
operator|->
name|irq
argument_list|,
name|portal_isr
argument_list|,
name|p_BmPortal
argument_list|)
expr_stmt|;
name|XX_EnableIntr
argument_list|(
name|p_BmPortal
operator|->
name|irq
argument_list|)
expr_stmt|;
comment|/* Enable the bits that make sense */
name|bm_isr_uninhibit
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* without IRQ, we can't block */
name|flags
operator|&=
operator|~
name|BMAN_PORTAL_FLAG_WAIT
expr_stmt|;
comment|/* Need RCR to be empty before continuing */
name|bm_isr_disable_write
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
operator|(
name|uint32_t
operator|)
operator|~
name|BM_PIRQ_RCRI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BMAN_PORTAL_FLAG_RECOVER
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|BMAN_PORTAL_FLAG_WAIT
operator|)
condition|)
name|ret
operator|=
name|bm_rcr_get_fill
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"RCR unclean, need recovery"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail_rcr_empty
goto|;
block|}
name|bm_isr_disable_write
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
name|fail_rcr_empty
label|:
name|bm_mc_finish
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|fail_mc
label|:
name|bm_rcr_finish
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|fail_rcr
label|:
name|XX_Free
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_INVALID_STATE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bman_destroy_portal
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|)
block|{
name|BmUpdate
argument_list|(
name|p_BmPortal
argument_list|,
name|BM_RCR_RING
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_BmPortal
operator|->
name|flags
operator|&
name|BMAN_PORTAL_FLAG_IRQ
condition|)
block|{
name|XX_DisableIntr
argument_list|(
name|p_BmPortal
operator|->
name|irq
argument_list|)
expr_stmt|;
name|XX_FreeIntr
argument_list|(
name|p_BmPortal
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
name|bm_mc_finish
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|bm_rcr_finish
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When release logic waits on available RCR space, we need a global waitqueue  * in the case of "affine" use (as the waits wake on different cpus which means  * different portals - so we can't wait on any per-portal waitqueue). */
end_comment

begin_function
specifier|static
name|uint32_t
name|__poll_portal_slow
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|)
block|{
name|struct
name|bman_depletion
name|tmp
decl_stmt|;
name|t_BmPool
modifier|*
name|p_BmPool
decl_stmt|;
name|uint32_t
name|ret
decl_stmt|,
name|is
init|=
name|bm_isr_status_read
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
decl_stmt|;
name|ret
operator|=
name|is
expr_stmt|;
comment|/* There is a gotcha to be aware of. If we do the query before clearing      * the status register, we may miss state changes that occur between the      * two. If we write to clear the status register before the query, the      * cache-enabled query command may overtake the status register write      * unless we use a heavyweight sync (which we don't want). Instead, we      * write-to-clear the status register then *read it back* before doing      * the query, hence the odd while loop with the 'is' accumulation. */
if|if
condition|(
name|is
operator|&
name|BM_PIRQ_BSCN
condition|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
name|__is
decl_stmt|;
name|bm_isr_status_clear
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|BM_PIRQ_BSCN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|__is
operator|=
name|bm_isr_status_read
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
operator|)
operator|&
name|BM_PIRQ_BSCN
condition|)
block|{
name|is
operator||=
name|__is
expr_stmt|;
name|bm_isr_status_clear
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|BM_PIRQ_BSCN
argument_list|)
expr_stmt|;
block|}
name|is
operator|&=
operator|~
name|BM_PIRQ_BSCN
expr_stmt|;
name|BmPortalQuery
argument_list|(
name|p_BmPortal
argument_list|,
operator|&
name|tmp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|idx
init|=
name|i
operator|*
literal|32
decl_stmt|;
comment|/* tmp is a mask of currently-depleted pools.              * pools[0] is mask of those we care about.              * pools[1] is our previous view (we only want to              * be told about changes). */
name|tmp
operator|.
name|__state
index|[
name|i
index|]
operator|&=
name|p_BmPortal
operator|->
name|pools
index|[
literal|0
index|]
operator|.
name|__state
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|__state
index|[
name|i
index|]
operator|==
name|p_BmPortal
operator|->
name|pools
index|[
literal|1
index|]
operator|.
name|__state
index|[
name|i
index|]
condition|)
comment|/* fast-path, nothing to see, move along */
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|31
condition|;
name|j
operator|++
operator|,
name|idx
operator|++
control|)
block|{
name|int
name|b4
init|=
name|bman_depletion_get
argument_list|(
operator|&
name|p_BmPortal
operator|->
name|pools
index|[
literal|1
index|]
argument_list|,
operator|(
name|uint8_t
operator|)
name|idx
argument_list|)
decl_stmt|;
name|int
name|af
init|=
name|bman_depletion_get
argument_list|(
operator|&
name|tmp
argument_list|,
operator|(
name|uint8_t
operator|)
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|b4
operator|==
name|af
condition|)
continue|continue;
name|p_BmPool
operator|=
name|p_BmPortal
operator|->
name|depletionPoolsTable
index|[
name|idx
index|]
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_BmPool
operator|->
name|f_Depletion
argument_list|)
expr_stmt|;
name|p_BmPool
operator|->
name|f_Depletion
argument_list|(
name|p_BmPool
operator|->
name|h_App
argument_list|,
operator|(
name|bool
operator|)
name|af
argument_list|)
expr_stmt|;
block|}
block|}
name|p_BmPortal
operator|->
name|pools
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|&
name|BM_PIRQ_RCRI
condition|)
block|{
name|NCSW_PLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|rcrCons
operator|+=
name|BmUpdate
argument_list|(
name|p_BmPortal
argument_list|,
name|BM_RCR_RING
argument_list|)
expr_stmt|;
name|bm_rcr_set_ithresh
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PUNLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|bm_isr_status_clear
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|BM_PIRQ_RCRI
argument_list|)
expr_stmt|;
name|is
operator|&=
operator|~
name|BM_PIRQ_RCRI
expr_stmt|;
block|}
comment|/* There should be no status register bits left undefined */
name|ASSERT_COND
argument_list|(
operator|!
name|is
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__poll_portal_fast
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
comment|/* nothing yet, this is where we'll put optimised RCR consumption      * tracking */
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|rel_set_thresh
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|,
name|int
name|check
parameter_list|)
block|{
if|if
condition|(
operator|!
name|check
operator|||
operator|!
name|bm_rcr_get_ithresh
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
condition|)
name|bm_rcr_set_ithresh
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|RCR_ITHRESH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used as a wait_event() expression. If it returns non-NULL, any lock will  * remain held. */
end_comment

begin_function
specifier|static
name|struct
name|bm_rcr_entry
modifier|*
name|try_rel_start
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|)
block|{
name|struct
name|bm_rcr_entry
modifier|*
name|r
decl_stmt|;
name|NCSW_PLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
if|if
condition|(
name|bm_rcr_get_avail
argument_list|(
operator|(
name|p_BmPortal
operator|)
operator|->
name|p_BmPortalLow
argument_list|)
operator|<
name|RCR_THRESH
condition|)
name|BmUpdate
argument_list|(
name|p_BmPortal
argument_list|,
name|BM_RCR_RING
argument_list|)
expr_stmt|;
name|r
operator|=
name|bm_rcr_start
argument_list|(
operator|(
name|p_BmPortal
operator|)
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|rel_set_thresh
argument_list|(
name|p_BmPortal
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUNLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|t_Error
name|wait_rel_start
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|,
name|struct
name|bm_rcr_entry
modifier|*
modifier|*
name|rel
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|tries
init|=
literal|100
decl_stmt|;
name|UNUSED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|rel
operator|=
name|try_rel_start
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|XX_Sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|*
name|rel
operator|&&
operator|--
name|tries
condition|)
do|;
if|if
condition|(
operator|!
operator|(
operator|*
name|rel
operator|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* This copies Qman's eqcr_completed() routine, see that for details */
end_comment

begin_function
specifier|static
name|int
name|rel_completed
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|,
name|uint32_t
name|rcr_poll
parameter_list|)
block|{
name|uint32_t
name|tr_cons
init|=
name|p_BmPortal
operator|->
name|rcrCons
decl_stmt|;
if|if
condition|(
name|rcr_poll
operator|&
literal|0xc0000000
condition|)
block|{
name|rcr_poll
operator|&=
literal|0x7fffffff
expr_stmt|;
name|tr_cons
operator|^=
literal|0x80000000
expr_stmt|;
block|}
if|if
condition|(
name|tr_cons
operator|>=
name|rcr_poll
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|rcr_poll
operator|-
name|tr_cons
operator|)
operator|>
name|BM_RCR_SIZE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|bm_rcr_get_fill
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
condition|)
comment|/* If RCR is empty, we must have completed */
return|return
literal|1
return|;
name|rel_set_thresh
argument_list|(
name|p_BmPortal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|rel_commit
parameter_list|(
name|t_BmPortal
modifier|*
name|p_BmPortal
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|uint8_t
name|num
parameter_list|)
block|{
name|uint32_t
name|rcr_poll
decl_stmt|;
name|BmCommit
argument_list|(
name|p_BmPortal
argument_list|,
name|BM_RCR_RING
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|BM_RCR_VERB_CMD_BPID_SINGLE
operator||
operator|(
name|num
operator|&
name|BM_RCR_VERB_BUFCOUNT_MASK
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* increment the producer count and capture it for SYNC */
name|rcr_poll
operator|=
operator|++
name|p_BmPortal
operator|->
name|rcrProd
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BMAN_RELEASE_FLAG_WAIT_SYNC
operator|)
operator|==
name|BMAN_RELEASE_FLAG_WAIT_SYNC
condition|)
name|rel_set_thresh
argument_list|(
name|p_BmPortal
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PUNLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BMAN_RELEASE_FLAG_WAIT_SYNC
operator|)
operator|!=
name|BMAN_RELEASE_FLAG_WAIT_SYNC
condition|)
return|return;
name|rel_completed
argument_list|(
name|p_BmPortal
argument_list|,
name|rcr_poll
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       Inter-Module functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/**  * bman_release - Release buffer(s) to the buffer pool  * @p_BmPool: the buffer pool object to release to  * @bufs: an array of buffers to release  * @num: the number of buffers in @bufs (1-8)  * @flags: bit-mask of BMAN_RELEASE_FLAG_*** options  *  * Adds the given buffers to RCR entries. If the portal @p_BmPortal was created with the  * "COMPACT" flag, then it will be using a compaction algorithm to improve  * utilization of RCR. As such, these buffers may join an existing ring entry  * and/or it may not be issued right away so as to allow future releases to join  * the same ring entry. Use the BMAN_RELEASE_FLAG_NOW flag to override this  * behavior by committing the RCR entry (or entries) right away. If the RCR  * ring is full, the function will return -EBUSY unless BMAN_RELEASE_FLAG_WAIT  * is selected, in which case it will sleep waiting for space to become  * available in RCR. If the function receives a signal before such time (and  * BMAN_RELEASE_FLAG_WAIT_INT is set), the function returns -EINTR. Otherwise,  * it returns zero.  */
end_comment

begin_function
name|t_Error
name|BmPortalRelease
parameter_list|(
name|t_Handle
name|h_BmPortal
parameter_list|,
name|uint8_t
name|bpid
parameter_list|,
name|struct
name|bm_buffer
modifier|*
name|bufs
parameter_list|,
name|uint8_t
name|num
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
init|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|h_BmPortal
decl_stmt|;
name|struct
name|bm_rcr_entry
modifier|*
name|r
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_BmPortal
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* TODO: I'm ignoring BMAN_PORTAL_FLAG_COMPACT for now. */
name|r
operator|=
name|try_rel_start
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|BMAN_RELEASE_FLAG_WAIT
condition|)
block|{
name|t_Error
name|ret
init|=
name|wait_rel_start
argument_list|(
name|p_BmPortal
argument_list|,
operator|&
name|r
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|ASSERT_COND
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|bpid
operator|=
name|bpid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|hi
operator|=
name|bufs
index|[
name|i
index|]
operator|.
name|hi
expr_stmt|;
name|r
operator|->
name|bufs
index|[
name|i
index|]
operator|.
name|lo
operator|=
name|bufs
index|[
name|i
index|]
operator|.
name|lo
expr_stmt|;
block|}
comment|/* Issue the release command and wait for sync if requested. NB: the      * commit can't fail, only waiting can. Don't propagate any failure if a      * signal arrives, otherwise the caller can't distinguish whether the      * release was issued or not. Code for user-space can check      * signal_pending() after we return. */
name|rel_commit
argument_list|(
name|p_BmPortal
argument_list|,
name|flags
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint8_t
name|BmPortalAcquire
parameter_list|(
name|t_Handle
name|h_BmPortal
parameter_list|,
name|uint8_t
name|bpid
parameter_list|,
name|struct
name|bm_buffer
modifier|*
name|bufs
parameter_list|,
name|uint8_t
name|num
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
init|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|h_BmPortal
decl_stmt|;
name|struct
name|bm_mc_command
modifier|*
name|mcc
decl_stmt|;
name|struct
name|bm_mc_result
modifier|*
name|mcr
decl_stmt|;
name|uint8_t
name|ret
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_BmPortal
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NCSW_PLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|mcc
operator|=
name|bm_mc_start
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|mcc
operator|->
name|acquire
operator|.
name|bpid
operator|=
name|bpid
expr_stmt|;
name|bm_mc_commit
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|BM_MCC_VERB_CMD_ACQUIRE
operator||
operator|(
name|num
operator|&
name|BM_MCC_VERB_ACQUIRE_BUFCOUNT
operator|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|mcr
operator|=
name|bm_mc_result
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
operator|)
condition|)
empty_stmt|;
name|ret
operator|=
name|num
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mcr
operator|->
name|verb
operator|&
name|BM_MCR_VERB_ACQUIRE_BUFCOUNT
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|num
operator|<=
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|bufs
index|[
name|num
index|]
operator|.
name|bpid
operator|=
name|bpid
expr_stmt|;
name|bufs
index|[
name|num
index|]
operator|.
name|hi
operator|=
name|mcr
operator|->
name|acquire
operator|.
name|bufs
index|[
name|num
index|]
operator|.
name|hi
expr_stmt|;
name|bufs
index|[
name|num
index|]
operator|.
name|lo
operator|=
name|mcr
operator|->
name|acquire
operator|.
name|bufs
index|[
name|num
index|]
operator|.
name|lo
expr_stmt|;
block|}
name|PUNLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|t_Error
name|BmPortalQuery
parameter_list|(
name|t_Handle
name|h_BmPortal
parameter_list|,
name|struct
name|bman_depletion
modifier|*
name|p_Pools
parameter_list|,
name|bool
name|depletion
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
init|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|h_BmPortal
decl_stmt|;
name|struct
name|bm_mc_result
modifier|*
name|mcr
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_BmPortal
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|NCSW_PLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|bm_mc_start
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|bm_mc_commit
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
name|BM_MCC_VERB_CMD_QUERY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|mcr
operator|=
name|bm_mc_result
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|depletion
condition|)
operator|*
name|p_Pools
operator|=
name|mcr
operator|->
name|query
operator|.
name|ds
operator|.
name|state
expr_stmt|;
else|else
operator|*
name|p_Pools
operator|=
name|mcr
operator|->
name|query
operator|.
name|as
operator|.
name|state
expr_stmt|;
name|PUNLOCK
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|BM_PORTAL_Config
parameter_list|(
name|t_BmPortalParam
modifier|*
name|p_BmPortalParam
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_BmPortalParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_BmPortalParam
operator|->
name|h_Bm
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_BmPortal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_BmPortal
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Bm Portal obj!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_BmPortal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_BmPortal
argument_list|)
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|=
operator|(
expr|struct
name|bm_portal
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bm_portal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_BmPortal
operator|->
name|p_BmPortalLow
condition|)
block|{
name|XX_Free
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Low bm portal obj!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bm_portal
argument_list|)
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|=
operator|(
name|t_BmPortalDriverParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_BmPortalDriverParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
condition|)
block|{
name|XX_Free
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Bm Portal driver parameters"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_BmPortalDriverParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|->
name|addr
operator|.
name|addr_ce
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_BmPortalParam
operator|->
name|ceBaseAddress
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|->
name|addr
operator|.
name|addr_ci
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_BmPortalParam
operator|->
name|ciBaseAddress
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|cpu
operator|=
operator|(
name|int
operator|)
name|p_BmPortalParam
operator|->
name|swPortalId
expr_stmt|;
name|p_BmPortal
operator|->
name|irq
operator|=
name|p_BmPortalParam
operator|->
name|irq
expr_stmt|;
name|p_BmPortal
operator|->
name|h_Bm
operator|=
name|p_BmPortalParam
operator|->
name|h_Bm
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|->
name|hwExtStructsMemAttr
operator|=
name|DEFAULT_memAttr
expr_stmt|;
name|bman_depletion_fill
argument_list|(
operator|&
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|->
name|mask
argument_list|)
expr_stmt|;
return|return
name|p_BmPortal
return|;
block|}
end_function

begin_function
name|t_Error
name|BM_PORTAL_Init
parameter_list|(
name|t_Handle
name|h_BmPortal
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
init|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|h_BmPortal
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_BmPortal
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|flags
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_BmPortal
operator|->
name|irq
operator|!=
name|NO_IRQ
operator|)
condition|?
name|BMAN_PORTAL_FLAG_IRQ
else|:
literal|0
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
operator|(
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|->
name|hwExtStructsMemAttr
operator|&
name|MEMORY_ATTR_CACHEABLE
operator|)
condition|?
name|BMAN_PORTAL_FLAG_CACHE
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|bman_create_portal
argument_list|(
name|p_BmPortal
argument_list|,
name|flags
argument_list|,
operator|&
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|->
name|mask
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|BM_PORTAL_Free
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NULL_POINTER
argument_list|,
operator|(
literal|"create portal failed"
operator|)
argument_list|)
expr_stmt|;
block|}
name|BmSetPortalHandle
argument_list|(
name|p_BmPortal
operator|->
name|h_Bm
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_BmPortal
argument_list|,
operator|(
name|e_DpaaSwPortal
operator|)
name|p_BmPortal
operator|->
name|cpu
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|=
name|NULL
expr_stmt|;
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Bman-Portal (%d) @ %p:%p\n"
operator|,
name|p_BmPortal
operator|->
name|cpu
operator|,
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|->
name|addr
operator|.
name|addr_ce
operator|,
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|->
name|addr
operator|.
name|addr_ci
operator|)
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Bman-Portal (%d) @ 0x%016llx:0x%016llx"
operator|,
name|p_BmPortal
operator|->
name|cpu
operator|,
operator|(
name|uint64_t
operator|)
name|XX_VirtToPhys
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|->
name|addr
operator|.
name|addr_ce
argument_list|)
operator|,
operator|(
name|uint64_t
operator|)
name|XX_VirtToPhys
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalLow
operator|->
name|addr
operator|.
name|addr_ci
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|BM_PORTAL_Free
parameter_list|(
name|t_Handle
name|h_BmPortal
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
init|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|h_BmPortal
decl_stmt|;
if|if
condition|(
operator|!
name|p_BmPortal
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_INVALID_HANDLE
argument_list|)
return|;
name|BmSetPortalHandle
argument_list|(
name|p_BmPortal
operator|->
name|h_Bm
argument_list|,
name|NULL
argument_list|,
operator|(
name|e_DpaaSwPortal
operator|)
name|p_BmPortal
operator|->
name|cpu
argument_list|)
expr_stmt|;
name|bman_destroy_portal
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_BmPortal
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|BM_PORTAL_ConfigMemAttr
parameter_list|(
name|t_Handle
name|h_BmPortal
parameter_list|,
name|uint32_t
name|hwExtStructsMemAttr
parameter_list|)
block|{
name|t_BmPortal
modifier|*
name|p_BmPortal
init|=
operator|(
name|t_BmPortal
operator|*
operator|)
name|h_BmPortal
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_BmPortal
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_BmPortal
operator|->
name|p_BmPortalDriverParams
operator|->
name|hwExtStructsMemAttr
operator|=
name|hwExtStructsMemAttr
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

end_unit

