begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************   Â© 1995-2003, 2004, 2005-2011 Freescale Semiconductor, Inc.  All rights reserved.   This is proprietary source code of Freescale Semiconductor Inc.,  and its use is subject to the NetComm Device Drivers EULA.  The copyright notice above does not evidence any actual or intended  publication of such source code.   ALTERNATIVELY, redistribution and use in source and binary forms, with  or without modification, are permitted provided that the following  conditions are met:      * Redistributions of source code must retain the above copyright        notice, this list of conditions and the following disclaimer.      * Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.      * Neither the name of Freescale Semiconductor nor the        names of its contributors may be used to endorse or promote products        derived from this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   **************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  @File          bman_low.c   @Description   BM low-level implementation */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"core_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"bman_private.h"
end_include

begin_comment
comment|/***************************/
end_comment

begin_comment
comment|/* Portal register assists */
end_comment

begin_comment
comment|/***************************/
end_comment

begin_comment
comment|/* Cache-inhibited register offsets */
end_comment

begin_define
define|#
directive|define
name|REG_RCR_PI_CINH
value|0x0000
end_define

begin_define
define|#
directive|define
name|REG_RCR_CI_CINH
value|0x0004
end_define

begin_define
define|#
directive|define
name|REG_RCR_ITR
value|0x0008
end_define

begin_define
define|#
directive|define
name|REG_CFG
value|0x0100
end_define

begin_define
define|#
directive|define
name|REG_SCN
parameter_list|(
name|n
parameter_list|)
value|(0x0200 + ((n)<< 2))
end_define

begin_define
define|#
directive|define
name|REG_ISR
value|0x0e00
end_define

begin_define
define|#
directive|define
name|REG_IER
value|0x0e04
end_define

begin_define
define|#
directive|define
name|REG_ISDR
value|0x0e08
end_define

begin_define
define|#
directive|define
name|REG_IIR
value|0x0e0c
end_define

begin_comment
comment|/* Cache-enabled register offsets */
end_comment

begin_define
define|#
directive|define
name|CL_CR
value|0x0000
end_define

begin_define
define|#
directive|define
name|CL_RR0
value|0x0100
end_define

begin_define
define|#
directive|define
name|CL_RR1
value|0x0140
end_define

begin_define
define|#
directive|define
name|CL_RCR
value|0x1000
end_define

begin_define
define|#
directive|define
name|CL_RCR_PI_CENA
value|0x3000
end_define

begin_define
define|#
directive|define
name|CL_RCR_CI_CENA
value|0x3100
end_define

begin_comment
comment|/* The h/w design requires mappings to be size-aligned so that "add"s can be  * reduced to "or"s. The primitives below do the same for s/w. */
end_comment

begin_function
specifier|static
name|__inline__
name|void
modifier|*
name|ptr_ADD
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|a
operator|+
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bitwise-OR two pointers */
end_comment

begin_function
specifier|static
name|__inline__
name|void
modifier|*
name|ptr_OR
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|a
operator||
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Cache-inhibited register access */
end_comment

begin_function
specifier|static
name|__inline__
name|uint32_t
name|__bm_in
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tmp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ci
argument_list|,
name|offset
argument_list|)
decl_stmt|;
return|return
name|GET_UINT32
argument_list|(
operator|*
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|__bm_out
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tmp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ci
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|tmp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|bm_in
parameter_list|(
name|reg
parameter_list|)
value|__bm_in(&portal->addr, REG_##reg)
end_define

begin_define
define|#
directive|define
name|bm_out
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
value|__bm_out(&portal->addr, REG_##reg, val)
end_define

begin_comment
comment|/* Convert 'n' cachelines to a pointer value for bitwise OR */
end_comment

begin_define
define|#
directive|define
name|bm_cl
parameter_list|(
name|n
parameter_list|)
value|(void *)((n)<< 6)
end_define

begin_comment
comment|/* Cache-enabled (index) register access */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|__bm_cl_touch_ro
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|)
block|{
name|dcbt_ro
argument_list|(
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ce
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|__bm_cl_touch_rw
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|)
block|{
name|dcbt_rw
argument_list|(
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ce
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|uint32_t
name|__bm_cl_in
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tmp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ce
argument_list|,
name|offset
argument_list|)
decl_stmt|;
return|return
name|GET_UINT32
argument_list|(
operator|*
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|__bm_cl_out
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tmp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ce
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|tmp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|dcbf
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|__bm_cl_invalidate
parameter_list|(
name|struct
name|bm_addr
modifier|*
name|bm
parameter_list|,
name|uintptr_t
name|offset
parameter_list|)
block|{
name|dcbi
argument_list|(
name|ptr_ADD
argument_list|(
name|bm
operator|->
name|addr_ce
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|bm_cl_touch_ro
parameter_list|(
name|reg
parameter_list|)
value|__bm_cl_touch_ro(&portal->addr, CL_##reg##_CENA)
end_define

begin_define
define|#
directive|define
name|bm_cl_touch_rw
parameter_list|(
name|reg
parameter_list|)
value|__bm_cl_touch_rw(&portal->addr, CL_##reg##_CENA)
end_define

begin_define
define|#
directive|define
name|bm_cl_in
parameter_list|(
name|reg
parameter_list|)
value|__bm_cl_in(&portal->addr, CL_##reg##_CENA)
end_define

begin_define
define|#
directive|define
name|bm_cl_out
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
value|__bm_cl_out(&portal->addr, CL_##reg##_CENA, val)
end_define

begin_define
define|#
directive|define
name|bm_cl_invalidate
parameter_list|(
name|reg
parameter_list|)
value|__bm_cl_invalidate(&portal->addr, CL_##reg##_CENA)
end_define

begin_comment
comment|/* Cyclic helper for rings. TODO: once we are able to do fine-grain perf  * analysis, look at using the "extra" bit in the ring index registers to avoid  * cyclic issues. */
end_comment

begin_function
specifier|static
name|__inline__
name|uint8_t
name|cyc_diff
parameter_list|(
name|uint8_t
name|ringsize
parameter_list|,
name|uint8_t
name|first
parameter_list|,
name|uint8_t
name|last
parameter_list|)
block|{
comment|/* 'first' is included, 'last' is excluded */
if|if
condition|(
name|first
operator|<=
name|last
condition|)
return|return
call|(
name|uint8_t
call|)
argument_list|(
name|last
operator|-
name|first
argument_list|)
return|;
return|return
call|(
name|uint8_t
call|)
argument_list|(
name|ringsize
operator|+
name|last
operator|-
name|first
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------- */
end_comment

begin_comment
comment|/* --- RCR API --- */
end_comment

begin_comment
comment|/* It's safer to code in terms of the 'rcr' object than the 'portal' object,  * because the latter runs the risk of copy-n-paste errors from other code where  * we could manipulate some other structure within 'portal'. */
end_comment

begin_comment
comment|/* #define RCR_API_START()      register struct bm_rcr *rcr =&portal->rcr */
end_comment

begin_comment
comment|/* Bit-wise logic to wrap a ring pointer by clearing the "carry bit" */
end_comment

begin_define
define|#
directive|define
name|RCR_CARRYCLEAR
parameter_list|(
name|p
parameter_list|)
define|\
value|(void *)((uintptr_t)(p)& (~(uintptr_t)(BM_RCR_SIZE<< 6)))
end_define

begin_comment
comment|/* Bit-wise logic to convert a ring pointer to a ring index */
end_comment

begin_function
specifier|static
name|__inline__
name|uint8_t
name|RCR_PTR2IDX
parameter_list|(
name|struct
name|bm_rcr_entry
modifier|*
name|e
parameter_list|)
block|{
return|return
call|(
name|uint8_t
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|e
operator|>>
literal|6
operator|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Increment the 'cursor' ring pointer, taking 'vbit' into account */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|RCR_INC
parameter_list|(
name|struct
name|bm_rcr
modifier|*
name|rcr
parameter_list|)
block|{
comment|/* NB: this is odd-looking, but experiments show that it generates      * fast code with essentially no branching overheads. We increment to      * the next RCR pointer and handle overflow and 'vbit'. */
name|struct
name|bm_rcr_entry
modifier|*
name|partial
init|=
name|rcr
operator|->
name|cursor
operator|+
literal|1
decl_stmt|;
name|rcr
operator|->
name|cursor
operator|=
name|RCR_CARRYCLEAR
argument_list|(
name|partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
operator|!=
name|rcr
operator|->
name|cursor
condition|)
name|rcr
operator|->
name|vbit
operator|^=
name|BM_RCR_VERB_VBIT
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|bm_rcr_init
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|e_BmPortalProduceMode
name|pmode
parameter_list|,
name|e_BmPortalRcrConsumeMode
name|cmode
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|uint32_t
name|cfg
decl_stmt|;
name|uint8_t
name|pi
decl_stmt|;
name|rcr
operator|->
name|ring
operator|=
name|ptr_ADD
argument_list|(
name|portal
operator|->
name|addr
operator|.
name|addr_ce
argument_list|,
name|CL_RCR
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|ci
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bm_in
argument_list|(
name|RCR_CI_CINH
argument_list|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|pi
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bm_in
argument_list|(
name|RCR_PI_CINH
argument_list|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|cursor
operator|=
name|rcr
operator|->
name|ring
operator|+
name|pi
expr_stmt|;
name|rcr
operator|->
name|vbit
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|bm_in
argument_list|(
name|RCR_PI_CINH
argument_list|)
operator|&
name|BM_RCR_SIZE
operator|)
condition|?
name|BM_RCR_VERB_VBIT
else|:
literal|0
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|-
name|cyc_diff
argument_list|(
name|BM_RCR_SIZE
argument_list|,
name|rcr
operator|->
name|ci
argument_list|,
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|ithresh
operator|=
operator|(
name|uint8_t
operator|)
name|bm_in
argument_list|(
name|RCR_ITR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|rcr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|rcr
operator|->
name|pmode
operator|=
name|pmode
expr_stmt|;
name|rcr
operator|->
name|cmode
operator|=
name|cmode
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|cmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
name|cfg
operator|=
operator|(
name|bm_in
argument_list|(
name|CFG
argument_list|)
operator|&
literal|0xffffffe0
operator|)
operator||
operator|(
name|pmode
operator|&
literal|0x3
operator|)
expr_stmt|;
comment|/* BCSP_CFG::RPM */
name|bm_out
argument_list|(
name|CFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bm_rcr_finish
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|uint8_t
name|pi
init|=
call|(
name|uint8_t
call|)
argument_list|(
name|bm_in
argument_list|(
name|RCR_PI_CINH
argument_list|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|uint8_t
name|ci
init|=
call|(
name|uint8_t
call|)
argument_list|(
name|bm_in
argument_list|(
name|RCR_CI_CINH
argument_list|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|ASSERT_COND
argument_list|(
operator|!
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|RCR_PTR2IDX
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
condition|)
name|REPORT_ERROR
argument_list|(
name|WARNING
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"losing uncommitted RCR entries"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|!=
name|rcr
operator|->
name|ci
condition|)
name|REPORT_ERROR
argument_list|(
name|WARNING
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"missing existing RCR completions"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcr
operator|->
name|ci
operator|!=
name|RCR_PTR2IDX
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
condition|)
name|REPORT_ERROR
argument_list|(
name|WARNING
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"RCR destroyed unquiesced"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bm_rcr_entry
modifier|*
name|bm_rcr_start
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|ASSERT_COND
argument_list|(
operator|!
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcr
operator|->
name|available
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|rcr
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
name|dcbz_64
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
expr_stmt|;
return|return
name|rcr
operator|->
name|cursor
return|;
block|}
end_function

begin_function
name|void
name|bm_rcr_abort
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|rcr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|rcr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|struct
name|bm_rcr_entry
modifier|*
name|bm_rcr_pend_and_next
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|myverb
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|pmode
operator|!=
name|e_BmPortalPVB
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcr
operator|->
name|available
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
name|rcr
operator|->
name|cursor
operator|->
name|__dont_write_directly__verb
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|myverb
operator||
name|rcr
operator|->
name|vbit
argument_list|)
expr_stmt|;
name|dcbf_64
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|RCR_INC
argument_list|(
name|rcr
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|--
expr_stmt|;
name|dcbz_64
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
expr_stmt|;
return|return
name|rcr
operator|->
name|cursor
return|;
block|}
end_function

begin_function
name|void
name|bm_rcr_pci_commit
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|myverb
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|pmode
operator|==
name|e_BmPortalPCI
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|cursor
operator|->
name|__dont_write_directly__verb
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|myverb
operator||
name|rcr
operator|->
name|vbit
argument_list|)
expr_stmt|;
name|RCR_INC
argument_list|(
name|rcr
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|--
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|bm_out
argument_list|(
name|RCR_PI_CINH
argument_list|,
name|RCR_PTR2IDX
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|rcr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|void
name|bm_rcr_pce_prefetch
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
operator|(
operator|(
expr|struct
name|bm_rcr
operator|*
operator|)
operator|&
name|portal
operator|->
name|rcr
operator|)
operator|->
name|pmode
operator|==
name|e_BmPortalPCE
argument_list|)
expr_stmt|;
name|bm_cl_invalidate
argument_list|(
name|RCR_PI
argument_list|)
expr_stmt|;
name|bm_cl_touch_rw
argument_list|(
name|RCR_PI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bm_rcr_pce_commit
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|myverb
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|pmode
operator|==
name|e_BmPortalPCE
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|cursor
operator|->
name|__dont_write_directly__verb
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|myverb
operator||
name|rcr
operator|->
name|vbit
argument_list|)
expr_stmt|;
name|RCR_INC
argument_list|(
name|rcr
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|--
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|bm_cl_out
argument_list|(
name|RCR_PI
argument_list|,
name|RCR_PTR2IDX
argument_list|(
name|rcr
operator|->
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|rcr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|void
name|bm_rcr_pvb_commit
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|myverb
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|struct
name|bm_rcr_entry
modifier|*
name|rcursor
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|busy
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|pmode
operator|==
name|e_BmPortalPVB
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|rcursor
operator|=
name|rcr
operator|->
name|cursor
expr_stmt|;
name|rcursor
operator|->
name|__dont_write_directly__verb
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|myverb
operator||
name|rcr
operator|->
name|vbit
argument_list|)
expr_stmt|;
name|dcbf_64
argument_list|(
name|rcursor
argument_list|)
expr_stmt|;
name|RCR_INC
argument_list|(
name|rcr
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|rcr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|uint8_t
name|bm_rcr_cci_update
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|uint8_t
name|diff
decl_stmt|,
name|old_ci
init|=
name|rcr
operator|->
name|ci
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|cmode
operator|==
name|e_BmPortalRcrCCI
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|ci
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bm_in
argument_list|(
name|RCR_CI_CINH
argument_list|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|diff
operator|=
name|cyc_diff
argument_list|(
name|BM_RCR_SIZE
argument_list|,
name|old_ci
argument_list|,
name|rcr
operator|->
name|ci
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|+=
name|diff
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_function
name|void
name|bm_rcr_cce_prefetch
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
operator|(
operator|(
expr|struct
name|bm_rcr
operator|*
operator|)
operator|&
name|portal
operator|->
name|rcr
operator|)
operator|->
name|cmode
operator|==
name|e_BmPortalRcrCCE
argument_list|)
expr_stmt|;
name|bm_cl_touch_ro
argument_list|(
name|RCR_CI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|bm_rcr_cce_update
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|uint8_t
name|diff
decl_stmt|,
name|old_ci
init|=
name|rcr
operator|->
name|ci
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|rcr
operator|->
name|cmode
operator|==
name|e_BmPortalRcrCCE
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|ci
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bm_cl_in
argument_list|(
name|RCR_CI
argument_list|)
operator|&
operator|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bm_cl_invalidate
argument_list|(
name|RCR_CI
argument_list|)
expr_stmt|;
name|diff
operator|=
name|cyc_diff
argument_list|(
name|BM_RCR_SIZE
argument_list|,
name|old_ci
argument_list|,
name|rcr
operator|->
name|ci
argument_list|)
expr_stmt|;
name|rcr
operator|->
name|available
operator|+=
name|diff
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_function
name|uint8_t
name|bm_rcr_get_ithresh
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
return|return
name|rcr
operator|->
name|ithresh
return|;
block|}
end_function

begin_function
name|void
name|bm_rcr_set_ithresh
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|ithresh
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
name|rcr
operator|->
name|ithresh
operator|=
name|ithresh
expr_stmt|;
name|bm_out
argument_list|(
name|RCR_ITR
argument_list|,
name|ithresh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|bm_rcr_get_avail
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
return|return
name|rcr
operator|->
name|available
return|;
block|}
end_function

begin_function
name|uint8_t
name|bm_rcr_get_fill
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_rcr
modifier|*
name|rcr
init|=
operator|&
name|portal
operator|->
name|rcr
decl_stmt|;
return|return
call|(
name|uint8_t
call|)
argument_list|(
name|BM_RCR_SIZE
operator|-
literal|1
operator|-
name|rcr
operator|->
name|available
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------ */
end_comment

begin_comment
comment|/* --- Management command API --- */
end_comment

begin_comment
comment|/* It's safer to code in terms of the 'mc' object than the 'portal' object,  * because the latter runs the risk of copy-n-paste errors from other code where  * we could manipulate some other structure within 'portal'. */
end_comment

begin_comment
comment|/* #define MC_API_START()      register struct bm_mc *mc =&portal->mc */
end_comment

begin_function
name|t_Error
name|bm_mc_init
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_mc
modifier|*
name|mc
init|=
operator|&
name|portal
operator|->
name|mc
decl_stmt|;
name|mc
operator|->
name|cr
operator|=
name|ptr_ADD
argument_list|(
name|portal
operator|->
name|addr
operator|.
name|addr_ce
argument_list|,
name|CL_CR
argument_list|)
expr_stmt|;
name|mc
operator|->
name|rr
operator|=
name|ptr_ADD
argument_list|(
name|portal
operator|->
name|addr
operator|.
name|addr_ce
argument_list|,
name|CL_RR0
argument_list|)
expr_stmt|;
name|mc
operator|->
name|rridx
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|mc
operator|->
name|cr
operator|->
name|__dont_write_directly__verb
operator|&
name|BM_MCC_VERB_VBIT
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|mc
operator|->
name|vbit
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mc
operator|->
name|rridx
condition|?
name|BM_MCC_VERB_VBIT
else|:
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|mc
operator|->
name|state
operator|=
name|mc_idle
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bm_mc_finish
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_mc
modifier|*
name|mc
init|=
operator|&
name|portal
operator|->
name|mc
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|mc
operator|->
name|state
operator|==
name|mc_idle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
if|if
condition|(
name|mc
operator|->
name|state
operator|!=
name|mc_idle
condition|)
name|REPORT_ERROR
argument_list|(
name|WARNING
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Losing incomplete MC command"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|mc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|struct
name|bm_mc_command
modifier|*
name|bm_mc_start
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_mc
modifier|*
name|mc
init|=
operator|&
name|portal
operator|->
name|mc
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|mc
operator|->
name|state
operator|==
name|mc_idle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|mc
operator|->
name|state
operator|=
name|mc_user
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
name|dcbz_64
argument_list|(
name|mc
operator|->
name|cr
argument_list|)
expr_stmt|;
return|return
name|mc
operator|->
name|cr
return|;
block|}
end_function

begin_function
name|void
name|bm_mc_abort
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_mc
modifier|*
name|mc
init|=
operator|&
name|portal
operator|->
name|mc
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|mc
operator|->
name|state
operator|==
name|mc_user
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|mc
operator|->
name|state
operator|=
name|mc_idle
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|mc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|void
name|bm_mc_commit
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|myverb
parameter_list|)
block|{
specifier|register
name|struct
name|bm_mc
modifier|*
name|mc
init|=
operator|&
name|portal
operator|->
name|mc
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|mc
operator|->
name|state
operator|==
name|mc_user
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|mc
operator|->
name|cr
operator|->
name|__dont_write_directly__verb
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|myverb
operator||
name|mc
operator|->
name|vbit
argument_list|)
expr_stmt|;
name|dcbf_64
argument_list|(
name|mc
operator|->
name|cr
argument_list|)
expr_stmt|;
name|dcbit_ro
argument_list|(
name|mc
operator|->
name|rr
operator|+
name|mc
operator|->
name|rridx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|mc
operator|->
name|state
operator|=
name|mc_hw
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
block|}
end_function

begin_function
name|struct
name|bm_mc_result
modifier|*
name|bm_mc_result
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|)
block|{
specifier|register
name|struct
name|bm_mc
modifier|*
name|mc
init|=
operator|&
name|portal
operator|->
name|mc
decl_stmt|;
name|struct
name|bm_mc_result
modifier|*
name|rr
init|=
name|mc
operator|->
name|rr
operator|+
name|mc
operator|->
name|rridx
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|mc
operator|->
name|state
operator|==
name|mc_hw
argument_list|)
expr_stmt|;
comment|/* The inactive response register's verb byte always returns zero until      * its command is submitted and completed. This includes the valid-bit,      * in case you were wondering... */
if|if
condition|(
operator|!
name|rr
operator|->
name|verb
condition|)
block|{
name|dcbit_ro
argument_list|(
name|rr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mc
operator|->
name|rridx
operator|^=
literal|1
expr_stmt|;
name|mc
operator|->
name|vbit
operator|^=
name|BM_MCC_VERB_VBIT
expr_stmt|;
ifdef|#
directive|ifdef
name|BM_CHECKING
name|mc
operator|->
name|state
operator|=
name|mc_idle
expr_stmt|;
endif|#
directive|endif
comment|/* BM_CHECKING */
return|return
name|rr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------- */
end_comment

begin_comment
comment|/* --- Portal interrupt register API --- */
end_comment

begin_define
define|#
directive|define
name|SCN_REG
parameter_list|(
name|bpid
parameter_list|)
value|REG_SCN((bpid) / 32)
end_define

begin_define
define|#
directive|define
name|SCN_BIT
parameter_list|(
name|bpid
parameter_list|)
value|(0x80000000>> (bpid& 31))
end_define

begin_function
name|void
name|bm_isr_bscn_mask
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|uint8_t
name|bpid
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|bpid
operator|<
name|BM_MAX_NUM_OF_POOLS
argument_list|)
expr_stmt|;
comment|/* REG_SCN for bpid=0..31, REG_SCN+4 for bpid=32..63 */
name|val
operator|=
name|__bm_in
argument_list|(
operator|&
name|portal
operator|->
name|addr
argument_list|,
name|SCN_REG
argument_list|(
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|val
operator||=
name|SCN_BIT
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|SCN_BIT
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
name|__bm_out
argument_list|(
operator|&
name|portal
operator|->
name|addr
argument_list|,
name|SCN_REG
argument_list|(
name|bpid
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|__bm_isr_read
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|enum
name|bm_isr_reg
name|n
parameter_list|)
block|{
return|return
name|__bm_in
argument_list|(
operator|&
name|portal
operator|->
name|addr
argument_list|,
name|REG_ISR
operator|+
operator|(
name|n
operator|<<
literal|2
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|__bm_isr_write
parameter_list|(
name|struct
name|bm_portal
modifier|*
name|portal
parameter_list|,
name|enum
name|bm_isr_reg
name|n
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|__bm_out
argument_list|(
operator|&
name|portal
operator|->
name|addr
argument_list|,
name|REG_ISR
operator|+
operator|(
name|n
operator|<<
literal|2
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

