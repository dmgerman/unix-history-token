begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"common/general.h"
end_include

begin_include
include|#
directive|include
file|"fman_common.h"
end_include

begin_include
include|#
directive|include
file|"fsl_fman_port.h"
end_include

begin_comment
comment|/* problem Eyal: the following should not be here*/
end_comment

begin_define
define|#
directive|define
name|NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME
value|0x00000028
end_define

begin_function
specifier|static
name|uint32_t
name|get_no_pcd_nia_bmi_ac_enc_frame
parameter_list|(
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
name|cfg
operator|->
name|errata_A006675
condition|)
return|return
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME
return|;
else|else
return|return
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_bmi_rx
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|fman_port_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|fman_port_rx_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
comment|/* Rx Configuration register */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|im_en
condition|)
name|tmp
operator||=
name|BMI_PORT_CFG_IM
expr_stmt|;
elseif|else
if|if
condition|(
name|cfg
operator|->
name|discard_override
condition|)
name|tmp
operator||=
name|BMI_PORT_CFG_FDOVR
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rcfg
argument_list|)
expr_stmt|;
comment|/* DMA attributes */
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|dma_swap_data
operator|<<
name|BMI_DMA_ATTR_SWP_SHIFT
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_ic_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_IC_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_header_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_HDR_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_sg_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_SG_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_write_optimize
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_WRITE_OPTIMIZE
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rda
argument_list|)
expr_stmt|;
comment|/* Rx FIFO parameters */
name|tmp
operator|=
operator|(
name|cfg
operator|->
name|rx_pri_elevation
operator|/
name|FMAN_PORT_BMI_FIFO_UNITS
operator|-
literal|1
operator|)
operator|<<
name|BMI_RX_FIFO_PRI_ELEVATION_SHIFT
expr_stmt|;
name|tmp
operator||=
name|cfg
operator|->
name|rx_fifo_thr
operator|/
name|FMAN_PORT_BMI_FIFO_UNITS
operator|-
literal|1
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|excessive_threshold_register
condition|)
comment|/* always allow access to the extra resources */
name|iowrite32be
argument_list|(
name|BMI_RX_FIFO_THRESHOLD_ETHE
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_reth
argument_list|)
expr_stmt|;
comment|/* Frame end data */
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|checksum_bytes_ignore
operator|<<
name|BMI_RX_FRAME_END_CS_IGNORE_SHIFT
expr_stmt|;
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|rx_cut_end_bytes
operator|<<
name|BMI_RX_FRAME_END_CUT_SHIFT
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|errata_A006320
condition|)
name|tmp
operator|&=
literal|0xffe0ffff
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfed
argument_list|)
expr_stmt|;
comment|/* Internal context parameters */
name|tmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ic_ext_offset
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_TO_EXT_SHIFT
expr_stmt|;
name|tmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ic_int_offset
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_FROM_INT_SHIFT
expr_stmt|;
name|tmp
operator||=
name|cfg
operator|->
name|ic_size
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ricp
argument_list|)
expr_stmt|;
comment|/* Internal buffer offset */
name|tmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|int_buf_start_margin
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_INT_BUF_MARG_SHIFT
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rim
argument_list|)
expr_stmt|;
comment|/* External buffer margins */
if|if
condition|(
operator|!
name|port
operator|->
name|im_en
condition|)
block|{
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ext_buf_start_margin
operator|<<
name|BMI_EXT_BUF_MARG_START_SHIFT
expr_stmt|;
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ext_buf_end_margin
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|fmbm_rebm_has_sgd
operator|&&
name|cfg
operator|->
name|no_scatter_gather
condition|)
name|tmp
operator||=
name|BMI_SG_DISABLE
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rebm
argument_list|)
expr_stmt|;
block|}
comment|/* Frame attributes */
name|tmp
operator|=
name|BMI_CMD_RX_MR_DEF
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|im_en
condition|)
block|{
name|tmp
operator||=
name|BMI_CMD_ATTR_ORDER
expr_stmt|;
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|color
operator|<<
name|BMI_CMD_ATTR_COLOR_SHIFT
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|sync_req
condition|)
name|tmp
operator||=
name|BMI_CMD_ATTR_SYNC
expr_stmt|;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfca
argument_list|)
expr_stmt|;
comment|/* NIA */
if|if
condition|(
name|port
operator|->
name|im_en
condition|)
name|tmp
operator|=
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_IND_MODE_RX
expr_stmt|;
else|else
block|{
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|rx_fd_bits
operator|<<
name|BMI_NEXT_ENG_FD_BITS_SHIFT
expr_stmt|;
name|tmp
operator||=
name|get_no_pcd_nia_bmi_ac_enc_frame
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfne
argument_list|)
expr_stmt|;
comment|/* Enqueue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfene
argument_list|)
expr_stmt|;
comment|/* Default/error queues */
if|if
condition|(
operator|!
name|port
operator|->
name|im_en
condition|)
block|{
name|iowrite32be
argument_list|(
operator|(
name|params
operator|->
name|dflt_fqid
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfqid
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
operator|(
name|params
operator|->
name|err_fqid
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_refqid
argument_list|)
expr_stmt|;
block|}
comment|/* Discard/error masks */
name|iowrite32be
argument_list|(
name|params
operator|->
name|discard_mask
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfsdm
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|params
operator|->
name|err_mask
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rfsem
argument_list|)
expr_stmt|;
comment|/* Statistics counters */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|stats_counters_enable
condition|)
name|tmp
operator|=
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rstc
argument_list|)
expr_stmt|;
comment|/* Performance counters */
name|fman_port_set_perf_cnt_params
argument_list|(
name|port
argument_list|,
operator|&
name|cfg
operator|->
name|perf_cnt_params
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|perf_counters_enable
condition|)
name|tmp
operator|=
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_rpc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_bmi_tx
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|fman_port_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|fman_port_tx_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
comment|/* Tx Configuration register */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|im_en
condition|)
name|tmp
operator||=
name|BMI_PORT_CFG_IM
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tcfg
argument_list|)
expr_stmt|;
comment|/* DMA attributes */
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|dma_swap_data
operator|<<
name|BMI_DMA_ATTR_SWP_SHIFT
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_ic_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_IC_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_header_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_HDR_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_sg_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_SG_STASH_ON
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tda
argument_list|)
expr_stmt|;
comment|/* Tx FIFO parameters */
name|tmp
operator|=
operator|(
name|cfg
operator|->
name|tx_fifo_min_level
operator|/
name|FMAN_PORT_BMI_FIFO_UNITS
operator|)
operator|<<
name|BMI_TX_FIFO_MIN_FILL_SHIFT
expr_stmt|;
name|tmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|tx_fifo_deq_pipeline_depth
operator|-
literal|1
operator|)
operator|<<
name|BMI_FIFO_PIPELINE_DEPTH_SHIFT
expr_stmt|;
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|cfg
operator|->
name|tx_fifo_low_comf_level
operator|/
name|FMAN_PORT_BMI_FIFO_UNITS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfp
argument_list|)
expr_stmt|;
comment|/* Frame end data */
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|checksum_bytes_ignore
operator|<<
name|BMI_FRAME_END_CS_IGNORE_SHIFT
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfed
argument_list|)
expr_stmt|;
comment|/* Internal context parameters */
if|if
condition|(
operator|!
name|port
operator|->
name|im_en
condition|)
block|{
name|tmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ic_ext_offset
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_TO_EXT_SHIFT
expr_stmt|;
name|tmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ic_int_offset
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_FROM_INT_SHIFT
expr_stmt|;
name|tmp
operator||=
name|cfg
operator|->
name|ic_size
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ticp
argument_list|)
expr_stmt|;
block|}
comment|/* Frame attributes */
name|tmp
operator|=
name|BMI_CMD_TX_MR_DEF
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|im_en
condition|)
name|tmp
operator||=
name|BMI_CMD_MR_DEAS
expr_stmt|;
else|else
block|{
name|tmp
operator||=
name|BMI_CMD_ATTR_ORDER
expr_stmt|;
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|color
operator|<<
name|BMI_CMD_ATTR_COLOR_SHIFT
expr_stmt|;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfca
argument_list|)
expr_stmt|;
comment|/* Dequeue NIA + enqueue NIA */
if|if
condition|(
name|port
operator|->
name|im_en
condition|)
block|{
name|iowrite32be
argument_list|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_IND_MODE_TX
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfdne
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_IND_MODE_TX
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfene
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iowrite32be
argument_list|(
name|NIA_ENG_QMI_DEQ
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfdne
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfene
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|fmbm_tfne_has_features
condition|)
name|iowrite32be
argument_list|(
operator|!
name|params
operator|->
name|dflt_fqid
condition|?
name|BMI_EBD_EN
operator||
name|NIA_BMI_AC_FETCH_ALL_FRAME
else|:
name|NIA_BMI_AC_FETCH_ALL_FRAME
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfne
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|dflt_fqid
operator|&&
name|params
operator|->
name|dont_release_buf
condition|)
block|{
name|iowrite32be
argument_list|(
literal|0x00FFFFFF
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tcfqid
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX_RELEASE
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfene
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|fmbm_tfne_has_features
condition|)
name|iowrite32be
argument_list|(
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmbm_tfne
argument_list|)
operator|&
operator|~
name|BMI_EBD_EN
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tfne
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Confirmation/error queues */
if|if
condition|(
operator|!
name|port
operator|->
name|im_en
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|dflt_fqid
operator|||
operator|!
name|params
operator|->
name|dont_release_buf
condition|)
name|iowrite32be
argument_list|(
name|params
operator|->
name|dflt_fqid
operator|&
literal|0x00FFFFFF
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tcfqid
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
operator|(
name|params
operator|->
name|err_fqid
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tefqid
argument_list|)
expr_stmt|;
block|}
comment|/* Statistics counters */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|stats_counters_enable
condition|)
name|tmp
operator|=
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tstc
argument_list|)
expr_stmt|;
comment|/* Performance counters */
name|fman_port_set_perf_cnt_params
argument_list|(
name|port
argument_list|,
operator|&
name|cfg
operator|->
name|perf_cnt_params
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|perf_counters_enable
condition|)
name|tmp
operator|=
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_tpc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_bmi_oh
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|fman_port_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|fman_port_oh_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
comment|/* OP Configuration register */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|discard_override
condition|)
name|tmp
operator||=
name|BMI_PORT_CFG_FDOVR
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ocfg
argument_list|)
expr_stmt|;
comment|/* DMA attributes */
name|tmp
operator|=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|dma_swap_data
operator|<<
name|BMI_DMA_ATTR_SWP_SHIFT
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_ic_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_IC_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_header_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_HDR_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_sg_stash_on
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_SG_STASH_ON
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dma_write_optimize
condition|)
name|tmp
operator||=
name|BMI_DMA_ATTR_WRITE_OPTIMIZE
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_oda
argument_list|)
expr_stmt|;
comment|/* Tx FIFO parameters */
name|tmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|tx_fifo_deq_pipeline_depth
operator|-
literal|1
operator|)
operator|<<
name|BMI_FIFO_PIPELINE_DEPTH_SHIFT
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofp
argument_list|)
expr_stmt|;
comment|/* Internal context parameters */
name|tmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ic_ext_offset
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_TO_EXT_SHIFT
expr_stmt|;
name|tmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|ic_int_offset
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_FROM_INT_SHIFT
expr_stmt|;
name|tmp
operator||=
name|cfg
operator|->
name|ic_size
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_oicp
argument_list|)
expr_stmt|;
comment|/* Frame attributes */
name|tmp
operator|=
name|BMI_CMD_OP_MR_DEF
expr_stmt|;
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|color
operator|<<
name|BMI_CMD_ATTR_COLOR_SHIFT
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|sync_req
condition|)
name|tmp
operator||=
name|BMI_CMD_ATTR_SYNC
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_OP
condition|)
name|tmp
operator||=
name|BMI_CMD_ATTR_ORDER
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofca
argument_list|)
expr_stmt|;
comment|/* Internal buffer offset */
name|tmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|cfg
operator|->
name|int_buf_start_margin
operator|/
name|FMAN_PORT_IC_OFFSET_UNITS
operator|)
operator|<<
name|BMI_INT_BUF_MARG_SHIFT
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_oim
argument_list|)
expr_stmt|;
comment|/* Dequeue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_QMI_DEQ
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofdne
argument_list|)
expr_stmt|;
comment|/* NIA and Enqueue NIA */
if|if
condition|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_HC
condition|)
block|{
name|iowrite32be
argument_list|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_HC
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofne
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|NIA_ENG_QMI_ENQ
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofene
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iowrite32be
argument_list|(
name|get_no_pcd_nia_bmi_ac_enc_frame
argument_list|(
name|cfg
argument_list|)
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofne
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofene
argument_list|)
expr_stmt|;
block|}
comment|/* Default/error queues */
name|iowrite32be
argument_list|(
operator|(
name|params
operator|->
name|dflt_fqid
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofqid
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
operator|(
name|params
operator|->
name|err_fqid
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_oefqid
argument_list|)
expr_stmt|;
comment|/* Discard/error masks */
if|if
condition|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_OP
condition|)
block|{
name|iowrite32be
argument_list|(
name|params
operator|->
name|discard_mask
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofsdm
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|params
operator|->
name|err_mask
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ofsem
argument_list|)
expr_stmt|;
block|}
comment|/* Statistics counters */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|stats_counters_enable
condition|)
name|tmp
operator|=
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_ostc
argument_list|)
expr_stmt|;
comment|/* Performance counters */
name|fman_port_set_perf_cnt_params
argument_list|(
name|port
argument_list|,
operator|&
name|cfg
operator|->
name|perf_cnt_params
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|perf_counters_enable
condition|)
name|tmp
operator|=
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmbm_opc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_qmi
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|fman_port_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|fman_port_qmi_regs
modifier|*
name|regs
init|=
name|port
operator|->
name|qmi_regs
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|queue_counters_enable
condition|)
name|tmp
operator||=
name|QMI_PORT_CFG_EN_COUNTERS
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pnc
argument_list|)
expr_stmt|;
comment|/* Rx port configuration */
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* Enqueue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_RELEASE
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pnen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Continue with Tx and O/H port configuration */
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_TX_10G
operator|)
condition|)
block|{
comment|/* Enqueue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX_RELEASE
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pnen
argument_list|)
expr_stmt|;
comment|/* Dequeue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pndn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enqueue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_RELEASE
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pnen
argument_list|)
expr_stmt|;
comment|/* Dequeue NIA */
name|iowrite32be
argument_list|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_FETCH
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pndn
argument_list|)
expr_stmt|;
block|}
comment|/* Dequeue Configuration register */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|deq_high_pri
condition|)
name|tmp
operator||=
name|QMI_DEQ_CFG_PRI
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|deq_type
condition|)
block|{
case|case
name|E_FMAN_PORT_DEQ_BY_PRI
case|:
name|tmp
operator||=
name|QMI_DEQ_CFG_TYPE1
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_DEQ_ACTIVE_FQ
case|:
name|tmp
operator||=
name|QMI_DEQ_CFG_TYPE2
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS
case|:
name|tmp
operator||=
name|QMI_DEQ_CFG_TYPE3
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|cfg
operator|->
name|qmi_deq_options_support
condition|)
block|{
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_HC
operator|)
operator|&&
operator|(
name|cfg
operator|->
name|deq_prefetch_opt
operator|!=
name|E_FMAN_PORT_DEQ_NO_PREFETCH
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
switch|switch
condition|(
name|cfg
operator|->
name|deq_prefetch_opt
condition|)
block|{
case|case
name|E_FMAN_PORT_DEQ_NO_PREFETCH
case|:
break|break;
case|case
name|E_FMAN_PORT_DEQ_PART_PREFETCH
case|:
name|tmp
operator||=
name|QMI_DEQ_CFG_PREFETCH_PARTIAL
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_DEQ_FULL_PREFETCH
case|:
name|tmp
operator||=
name|QMI_DEQ_CFG_PREFETCH_FULL
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|params
operator|->
name|deq_sp
operator|&
name|QMI_DEQ_CFG_SP_MASK
argument_list|)
operator|<<
name|QMI_DEQ_CFG_SP_SHIFT
expr_stmt|;
name|tmp
operator||=
name|cfg
operator|->
name|deq_byte_cnt
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmqm_pndc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_rx_stats_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_stats_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|stats_reg
parameter_list|)
block|{
name|struct
name|fman_port_rx_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_STATS_CNT_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rfrc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DISCARD
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rfdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DEALLOC_BUF
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rbdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rfbc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rlfc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rodc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_FILTERED_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rffc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DMA_ERR
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rfldec
expr_stmt|;
break|break;
default|default:
operator|*
name|stats_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_tx_stats_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_stats_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|stats_reg
parameter_list|)
block|{
name|struct
name|fman_port_tx_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_STATS_CNT_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tfrc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DISCARD
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tfdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DEALLOC_BUF
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tbdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_LEN_ERR
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tfledc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tfufdc
expr_stmt|;
break|break;
default|default:
operator|*
name|stats_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_oh_stats_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_stats_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|stats_reg
parameter_list|)
block|{
name|struct
name|fman_port_oh_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_STATS_CNT_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofrc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DISCARD
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DEALLOC_BUF
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_obdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_FILTERED_FRAME
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_offc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_DMA_ERR
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofldec
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_LEN_ERR
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofledc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofufdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_STATS_CNT_WRED_DISCARD
case|:
operator|*
name|stats_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofwdc
expr_stmt|;
break|break;
default|default:
operator|*
name|stats_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_rx_perf_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_perf_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|perf_reg
parameter_list|)
block|{
name|struct
name|fman_port_rx_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_PERF_CNT_CYCLE
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rccn
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_TASK_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rtuc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_QUEUE_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rrquc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_DMA_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rduc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_FIFO_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rfuc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_RX_PAUSE
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_rpac
expr_stmt|;
break|break;
default|default:
operator|*
name|perf_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_tx_perf_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_perf_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|perf_reg
parameter_list|)
block|{
name|struct
name|fman_port_tx_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_PERF_CNT_CYCLE
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tccn
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_TASK_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ttuc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_QUEUE_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ttcquc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_DMA_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tduc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_FIFO_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_tfuc
expr_stmt|;
break|break;
default|default:
operator|*
name|perf_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_oh_perf_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_perf_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|perf_reg
parameter_list|)
block|{
name|struct
name|fman_port_oh_bmi_regs
modifier|*
name|regs
init|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_PERF_CNT_CYCLE
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_occn
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_TASK_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_otuc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_DMA_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_oduc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_PERF_CNT_FIFO_UTIL
case|:
operator|*
name|perf_reg
operator|=
operator|&
name|regs
operator|->
name|fmbm_ofuc
expr_stmt|;
break|break;
default|default:
operator|*
name|perf_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_qmi_counter_reg
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_qmi_counters
name|counter
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|queue_reg
parameter_list|)
block|{
name|struct
name|fman_port_qmi_regs
modifier|*
name|regs
init|=
name|port
operator|->
name|qmi_regs
decl_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|E_FMAN_PORT_ENQ_TOTAL
case|:
operator|*
name|queue_reg
operator|=
operator|&
name|regs
operator|->
name|fmqm_pnetfc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_DEQ_TOTAL
case|:
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX_10G
operator|)
condition|)
comment|/* Counter not available for Rx ports */
operator|*
name|queue_reg
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|queue_reg
operator|=
operator|&
name|regs
operator|->
name|fmqm_pndtfc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_DEQ_FROM_DFLT
case|:
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX_10G
operator|)
condition|)
comment|/* Counter not available for Rx ports */
operator|*
name|queue_reg
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|queue_reg
operator|=
operator|&
name|regs
operator|->
name|fmqm_pndfdc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_DEQ_CONFIRM
case|:
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_RX_10G
operator|)
condition|)
comment|/* Counter not available for Rx ports */
operator|*
name|queue_reg
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|queue_reg
operator|=
operator|&
name|regs
operator|->
name|fmqm_pndcc
expr_stmt|;
break|break;
default|default:
operator|*
name|queue_reg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fman_port_defconfig
parameter_list|(
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|,
name|enum
name|fman_port_type
name|type
parameter_list|)
block|{
name|cfg
operator|->
name|dma_swap_data
operator|=
name|E_FMAN_PORT_DMA_NO_SWAP
expr_stmt|;
name|cfg
operator|->
name|dma_ic_stash_on
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|dma_header_stash_on
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|dma_sg_stash_on
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|dma_write_optimize
operator|=
name|TRUE
expr_stmt|;
name|cfg
operator|->
name|color
operator|=
name|E_FMAN_PORT_COLOR_GREEN
expr_stmt|;
name|cfg
operator|->
name|discard_override
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|checksum_bytes_ignore
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|rx_cut_end_bytes
operator|=
literal|4
expr_stmt|;
name|cfg
operator|->
name|rx_pri_elevation
operator|=
operator|(
operator|(
literal|0x3FF
operator|+
literal|1
operator|)
operator|*
name|FMAN_PORT_BMI_FIFO_UNITS
operator|)
expr_stmt|;
name|cfg
operator|->
name|rx_fifo_thr
operator|=
operator|(
operator|(
literal|0x3FF
operator|+
literal|1
operator|)
operator|*
name|FMAN_PORT_BMI_FIFO_UNITS
operator|)
expr_stmt|;
name|cfg
operator|->
name|rx_fd_bits
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|ic_ext_offset
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|ic_int_offset
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|ic_size
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|int_buf_start_margin
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|ext_buf_start_margin
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|ext_buf_end_margin
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|tx_fifo_min_level
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|tx_fifo_low_comf_level
operator|=
operator|(
literal|5
operator|*
name|KILOBYTE
operator|)
expr_stmt|;
name|cfg
operator|->
name|stats_counters_enable
operator|=
name|TRUE
expr_stmt|;
name|cfg
operator|->
name|perf_counters_enable
operator|=
name|TRUE
expr_stmt|;
name|cfg
operator|->
name|deq_type
operator|=
name|E_FMAN_PORT_DEQ_BY_PRI
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|E_FMAN_PORT_TYPE_HC
condition|)
block|{
name|cfg
operator|->
name|sync_req
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|deq_prefetch_opt
operator|=
name|E_FMAN_PORT_DEQ_NO_PREFETCH
expr_stmt|;
block|}
else|else
block|{
name|cfg
operator|->
name|sync_req
operator|=
name|TRUE
expr_stmt|;
name|cfg
operator|->
name|deq_prefetch_opt
operator|=
name|E_FMAN_PORT_DEQ_FULL_PREFETCH
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|E_FMAN_PORT_TYPE_TX_10G
condition|)
block|{
name|cfg
operator|->
name|tx_fifo_deq_pipeline_depth
operator|=
literal|4
expr_stmt|;
name|cfg
operator|->
name|deq_high_pri
operator|=
name|TRUE
expr_stmt|;
name|cfg
operator|->
name|deq_byte_cnt
operator|=
literal|0x1400
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|type
operator|==
name|E_FMAN_PORT_TYPE_HC
operator|)
operator|||
operator|(
name|type
operator|==
name|E_FMAN_PORT_TYPE_OP
operator|)
condition|)
name|cfg
operator|->
name|tx_fifo_deq_pipeline_depth
operator|=
literal|2
expr_stmt|;
else|else
name|cfg
operator|->
name|tx_fifo_deq_pipeline_depth
operator|=
literal|1
expr_stmt|;
name|cfg
operator|->
name|deq_high_pri
operator|=
name|FALSE
expr_stmt|;
name|cfg
operator|->
name|deq_byte_cnt
operator|=
literal|0x400
expr_stmt|;
block|}
name|cfg
operator|->
name|no_scatter_gather
operator|=
name|DEFAULT_FMAN_SP_NO_SCATTER_GATHER
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|fman_port_find_bpool
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint8_t
name|bpid
parameter_list|)
block|{
name|uint32_t
modifier|*
name|bp_reg
decl_stmt|,
name|tmp
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|id
decl_stmt|;
comment|/* Find the pool */
name|bp_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_ebmpi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|port
operator|->
name|ext_pools_num
operator|&&
operator|(
name|i
operator|<
name|FMAN_PORT_MAX_EXT_POOLS_NUM
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|bp_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|id
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|BMI_EXT_BUF_POOL_ID_MASK
operator|)
operator|>>
name|BMI_EXT_BUF_POOL_ID_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|bpid
condition|)
break|break;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|fman_port_init
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|fman_port_params
modifier|*
name|params
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* Init BMI registers */
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|err
operator|=
name|init_bmi_rx
argument_list|(
name|port
argument_list|,
name|cfg
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|err
operator|=
name|init_bmi_tx
argument_list|(
name|port
argument_list|,
name|cfg
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|err
operator|=
name|init_bmi_oh
argument_list|(
name|port
argument_list|,
name|cfg
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Init QMI registers */
if|if
condition|(
operator|!
name|port
operator|->
name|im_en
condition|)
block|{
name|err
operator|=
name|init_qmi
argument_list|(
name|port
argument_list|,
name|cfg
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_enable
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|)
block|{
name|uint32_t
modifier|*
name|bmi_cfg_reg
decl_stmt|,
name|tmp
decl_stmt|;
name|bool
name|rx_port
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|bmi_cfg_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rcfg
expr_stmt|;
name|rx_port
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|bmi_cfg_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tcfg
expr_stmt|;
name|rx_port
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|bmi_cfg_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ocfg
expr_stmt|;
name|rx_port
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Enable QMI */
if|if
condition|(
operator|!
name|rx_port
condition|)
block|{
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
operator||
name|QMI_PORT_CFG_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
expr_stmt|;
block|}
comment|/* Enable BMI */
name|tmp
operator|=
name|ioread32be
argument_list|(
name|bmi_cfg_reg
argument_list|)
operator||
name|BMI_PORT_CFG_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|bmi_cfg_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_disable
parameter_list|(
specifier|const
name|struct
name|fman_port
modifier|*
name|port
parameter_list|)
block|{
name|uint32_t
modifier|*
name|bmi_cfg_reg
decl_stmt|,
modifier|*
name|bmi_status_reg
decl_stmt|,
name|tmp
decl_stmt|;
name|bool
name|rx_port
decl_stmt|,
name|failure
init|=
name|FALSE
decl_stmt|;
name|int
name|count
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|bmi_cfg_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rcfg
expr_stmt|;
name|bmi_status_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rst
expr_stmt|;
name|rx_port
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|bmi_cfg_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tcfg
expr_stmt|;
name|bmi_status_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tst
expr_stmt|;
name|rx_port
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|bmi_cfg_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ocfg
expr_stmt|;
name|bmi_status_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ost
expr_stmt|;
name|rx_port
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Disable QMI */
if|if
condition|(
operator|!
name|rx_port
condition|)
block|{
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
operator|~
name|QMI_PORT_CFG_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
expr_stmt|;
comment|/* Wait for QMI to finish FD handling */
name|count
operator|=
literal|100
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pns
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmp
operator|&
name|QMI_PORT_STATUS_DEQ_FD_BSY
operator|)
operator|&&
operator|--
name|count
condition|)
do|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* Timeout */
name|failure
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Disable BMI */
name|tmp
operator|=
name|ioread32be
argument_list|(
name|bmi_cfg_reg
argument_list|)
operator|&
operator|~
name|BMI_PORT_CFG_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|bmi_cfg_reg
argument_list|)
expr_stmt|;
comment|/* Wait for graceful stop end */
name|count
operator|=
literal|500
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|ioread32be
argument_list|(
name|bmi_status_reg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tmp
operator|&
name|BMI_PORT_STATUS_BSY
operator|)
operator|&&
operator|--
name|count
condition|)
do|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* Timeout */
name|failure
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|failure
condition|)
return|return
operator|-
name|EBUSY
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_bpools
parameter_list|(
specifier|const
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
specifier|const
name|struct
name|fman_port_bpools
modifier|*
name|bp
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|,
modifier|*
name|bp_reg
decl_stmt|,
modifier|*
name|bp_depl_reg
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|max_bp_num
decl_stmt|;
name|bool
name|grp_depl_used
init|=
name|FALSE
decl_stmt|,
name|rx_port
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|max_bp_num
operator|=
name|port
operator|->
name|ext_pools_num
expr_stmt|;
name|rx_port
operator|=
name|TRUE
expr_stmt|;
name|bp_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_ebmpi
expr_stmt|;
name|bp_depl_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_mpd
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
if|if
condition|(
name|port
operator|->
name|fm_rev_maj
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|max_bp_num
operator|=
name|FMAN_PORT_OBS_EXT_POOLS_NUM
expr_stmt|;
name|rx_port
operator|=
name|FALSE
expr_stmt|;
name|bp_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_oebmpi
expr_stmt|;
name|bp_depl_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ompd
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|rx_port
condition|)
block|{
comment|/* Check buffers are provided in ascending order */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|bp
operator|->
name|count
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|<
name|FMAN_PORT_MAX_EXT_POOLS_NUM
operator|-
literal|1
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|size
operator|>
name|bp
operator|->
name|bpool
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
comment|/* Set up external buffers pools */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|BMI_EXT_BUF_POOL_VALID
expr_stmt|;
name|tmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|bpid
operator|<<
name|BMI_EXT_BUF_POOL_ID_SHIFT
operator|)
operator|&
name|BMI_EXT_BUF_POOL_ID_MASK
expr_stmt|;
if|if
condition|(
name|rx_port
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|counters_enable
condition|)
name|tmp
operator||=
name|BMI_EXT_BUF_POOL_EN_COUNTER
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|is_backup
condition|)
name|tmp
operator||=
name|BMI_EXT_BUF_POOL_BACKUP
expr_stmt|;
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|bp_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Clear unused pools */
for|for
control|(
name|i
operator|=
name|bp
operator|->
name|count
init|;
name|i
operator|<
name|max_bp_num
condition|;
name|i
operator|++
control|)
name|iowrite32be
argument_list|(
literal|0
argument_list|,
operator|&
name|bp_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Pools depletion */
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FMAN_PORT_MAX_EXT_POOLS_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|grp_bp_depleted
condition|)
block|{
name|grp_depl_used
operator|=
name|TRUE
expr_stmt|;
name|tmp
operator||=
literal|0x80000000
operator|>>
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|single_bp_depleted
condition|)
name|tmp
operator||=
literal|0x80
operator|>>
name|i
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bpool
index|[
name|i
index|]
operator|.
name|pfc_priorities_en
condition|)
name|tmp
operator||=
literal|0x0100
operator|<<
name|i
expr_stmt|;
block|}
if|if
condition|(
name|grp_depl_used
condition|)
name|tmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|bp
operator|->
name|grp_bp_depleted_num
operator|-
literal|1
operator|)
operator|<<
name|BMI_POOL_DEP_NUM_OF_POOLS_SHIFT
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|bp_depl_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_rate_limiter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_rate_limiter
modifier|*
name|rate_limiter
parameter_list|)
block|{
name|uint32_t
modifier|*
name|rate_limit_reg
decl_stmt|,
modifier|*
name|rate_limit_scale_reg
decl_stmt|;
name|uint32_t
name|granularity
decl_stmt|,
name|tmp
decl_stmt|;
name|uint8_t
name|usec_bit
decl_stmt|,
name|factor
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|rate_limit_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_trlmt
expr_stmt|;
name|rate_limit_scale_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_trlmts
expr_stmt|;
name|granularity
operator|=
name|BMI_RATE_LIMIT_GRAN_TX
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
name|rate_limit_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_orlmt
expr_stmt|;
name|rate_limit_scale_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_orlmts
expr_stmt|;
name|granularity
operator|=
name|BMI_RATE_LIMIT_GRAN_OP
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Factor is per 1 usec count */
name|factor
operator|=
literal|1
expr_stmt|;
name|usec_bit
operator|=
name|rate_limiter
operator|->
name|count_1micro_bit
expr_stmt|;
comment|/* If rate limit is too small for an 1usec factor, adjust timestamp      * scale and multiply the factor */
while|while
condition|(
name|rate_limiter
operator|->
name|rate
operator|<
operator|(
name|granularity
operator|/
name|factor
operator|)
condition|)
block|{
if|if
condition|(
name|usec_bit
operator|==
literal|31
condition|)
comment|/* Can't configure rate limiter - rate is too small */
return|return
operator|-
name|EINVAL
return|;
name|usec_bit
operator|++
expr_stmt|;
name|factor
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* Figure out register value. The "while" above quarantees that      * (rate_limiter->rate * factor / granularity)>= 1 */
name|tmp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|rate_limiter
operator|->
name|rate
operator|*
name|factor
operator|/
name|granularity
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Check rate limit isn't too large */
if|if
condition|(
name|tmp
operator|>=
name|BMI_RATE_LIMIT_MAX_RATE_IN_GRAN_UNITS
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Check burst size is in allowed range */
if|if
condition|(
operator|(
name|rate_limiter
operator|->
name|burst_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|rate_limiter
operator|->
name|burst_size
operator|>
name|BMI_RATE_LIMIT_MAX_BURST_SIZE
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|rate_limiter
operator|->
name|burst_size
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_RATE_LIMIT_MAX_BURST_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_OP
operator|)
operator|&&
operator|(
name|port
operator|->
name|fm_rev_maj
operator|==
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|rate_limiter
operator|->
name|high_burst_size_gran
condition|)
name|tmp
operator||=
name|BMI_RATE_LIMIT_HIGH_BURST_SIZE_GRAN
expr_stmt|;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|rate_limit_reg
argument_list|)
expr_stmt|;
comment|/* Set up rate limiter scale register */
name|tmp
operator|=
name|BMI_RATE_LIMIT_SCALE_EN
expr_stmt|;
name|tmp
operator||=
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|usec_bit
operator|)
operator|<<
name|BMI_RATE_LIMIT_SCALE_TSBS_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|->
name|type
operator|==
name|E_FMAN_PORT_TYPE_OP
operator|)
operator|&&
operator|(
name|port
operator|->
name|fm_rev_maj
operator|==
literal|4
operator|)
condition|)
name|tmp
operator||=
name|rate_limiter
operator|->
name|rate_factor
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|rate_limit_scale_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_delete_rate_limiter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|)
block|{
name|uint32_t
modifier|*
name|rate_limit_scale_reg
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|rate_limit_scale_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_trlmts
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
name|rate_limit_scale_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_orlmts
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|iowrite32be
argument_list|(
literal|0
argument_list|,
name|rate_limit_scale_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_err_mask
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|err_mask
parameter_list|)
block|{
name|uint32_t
modifier|*
name|err_mask_reg
decl_stmt|;
comment|/* Obtain register address */
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|err_mask_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfsem
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
name|err_mask_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofsem
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|iowrite32be
argument_list|(
name|err_mask
argument_list|,
name|err_mask_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_discard_mask
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|discard_mask
parameter_list|)
block|{
name|uint32_t
modifier|*
name|discard_mask_reg
decl_stmt|;
comment|/* Obtain register address */
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|discard_mask_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfsdm
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
name|discard_mask_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofsdm
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|iowrite32be
argument_list|(
name|discard_mask
argument_list|,
name|discard_mask_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_modify_rx_fd_bits
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint8_t
name|rx_fd_bits
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|tmp
operator||=
operator|(
name|uint32_t
operator|)
name|rx_fd_bits
operator|<<
name|BMI_NEXT_ENG_FD_BITS_SHIFT
expr_stmt|;
else|else
name|tmp
operator|&=
operator|~
operator|(
operator|(
name|uint32_t
operator|)
name|rx_fd_bits
operator|<<
name|BMI_NEXT_ENG_FD_BITS_SHIFT
operator|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_perf_cnt_params
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|struct
name|fman_port_perf_cnt_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
modifier|*
name|pcp_reg
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Obtain register address and check parameters are in range */
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|pcp_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rpcp
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|queue_val
operator|==
literal|0
operator|)
operator|||
operator|(
name|params
operator|->
name|queue_val
operator|>
name|MAX_PERFORMANCE_RX_QUEUE_COMP
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|pcp_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tpcp
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|queue_val
operator|==
literal|0
operator|)
operator|||
operator|(
name|params
operator|->
name|queue_val
operator|>
name|MAX_PERFORMANCE_TX_QUEUE_COMP
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|pcp_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_opcp
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|queue_val
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|params
operator|->
name|task_val
operator|==
literal|0
operator|)
operator|||
operator|(
name|params
operator|->
name|task_val
operator|>
name|MAX_PERFORMANCE_TASK_COMP
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|(
name|params
operator|->
name|dma_val
operator|==
literal|0
operator|)
operator|||
operator|(
name|params
operator|->
name|dma_val
operator|>
name|MAX_PERFORMANCE_DMA_COMP
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|(
name|params
operator|->
name|fifo_val
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|params
operator|->
name|fifo_val
operator|/
name|FMAN_PORT_BMI_FIFO_UNITS
operator|)
operator|>
name|MAX_PERFORMANCE_FIFO_COMP
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|params
operator|->
name|task_val
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_TASK_COMP_SHIFT
expr_stmt|;
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|params
operator|->
name|dma_val
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_DMA_COMP_SHIFT
expr_stmt|;
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|params
operator|->
name|fifo_val
operator|/
name|FMAN_PORT_BMI_FIFO_UNITS
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|params
operator|->
name|queue_val
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_QUEUE_COMP_SHIFT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|pcp_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_stats_cnt_mode
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_reg
decl_stmt|,
name|tmp
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|stats_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rstc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|stats_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tstc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|stats_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ostc
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|tmp
operator|=
name|ioread32be
argument_list|(
name|stats_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmp
operator||=
name|BMI_COUNTERS_EN
expr_stmt|;
else|else
name|tmp
operator|&=
operator|~
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|stats_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_perf_cnt_mode
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_reg
decl_stmt|,
name|tmp
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|stats_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rpc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|stats_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tpc
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|stats_reg
operator|=
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_opc
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|tmp
operator|=
name|ioread32be
argument_list|(
name|stats_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmp
operator||=
name|BMI_COUNTERS_EN
expr_stmt|;
else|else
name|tmp
operator|&=
operator|~
name|BMI_COUNTERS_EN
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
name|stats_reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_queue_cnt_mode
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmp
operator||=
name|QMI_PORT_CFG_EN_COUNTERS
expr_stmt|;
else|else
name|tmp
operator|&=
operator|~
name|QMI_PORT_CFG_EN_COUNTERS
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|port
operator|->
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_set_bpool_cnt_mode
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint8_t
name|bpid
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint8_t
name|index
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Find the pool */
name|index
operator|=
name|fman_port_find_bpool
argument_list|(
name|port
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|port
operator|->
name|ext_pools_num
operator|||
name|index
operator|==
name|FMAN_PORT_MAX_EXT_POOLS_NUM
condition|)
comment|/* Not found */
return|return
operator|-
name|EINVAL
return|;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_ebmpi
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmp
operator||=
name|BMI_EXT_BUF_POOL_EN_COUNTER
expr_stmt|;
else|else
name|tmp
operator|&=
operator|~
name|BMI_EXT_BUF_POOL_EN_COUNTER
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_ebmpi
index|[
name|index
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint32_t
name|fman_port_get_stats_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_stats_counters
name|counter
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_reg
decl_stmt|,
name|ret_val
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|get_rx_stats_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|get_tx_stats_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|get_oh_stats_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|stats_reg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|stats_reg
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ret_val
operator|=
name|ioread32be
argument_list|(
name|stats_reg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|void
name|fman_port_set_stats_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_stats_counters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_reg
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|get_rx_stats_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|get_tx_stats_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|get_oh_stats_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|stats_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|stats_reg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|stats_reg
operator|==
name|NULL
condition|)
return|return;
name|iowrite32be
argument_list|(
name|value
argument_list|,
name|stats_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|fman_port_get_perf_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_perf_counters
name|counter
parameter_list|)
block|{
name|uint32_t
modifier|*
name|perf_reg
decl_stmt|,
name|ret_val
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|get_rx_perf_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|perf_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|get_tx_perf_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|perf_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|get_oh_perf_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|perf_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perf_reg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|perf_reg
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ret_val
operator|=
name|ioread32be
argument_list|(
name|perf_reg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|void
name|fman_port_set_perf_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_perf_counters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
modifier|*
name|perf_reg
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
name|get_rx_perf_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|perf_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_TX
case|:
case|case
name|E_FMAN_PORT_TYPE_TX_10G
case|:
name|get_tx_perf_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|perf_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
case|case
name|E_FMAN_PORT_TYPE_HC
case|:
name|get_oh_perf_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|perf_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perf_reg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|perf_reg
operator|==
name|NULL
condition|)
return|return;
name|iowrite32be
argument_list|(
name|value
argument_list|,
name|perf_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|fman_port_get_qmi_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_qmi_counters
name|counter
parameter_list|)
block|{
name|uint32_t
modifier|*
name|queue_reg
decl_stmt|,
name|ret_val
decl_stmt|;
name|get_qmi_counter_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|queue_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_reg
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ret_val
operator|=
name|ioread32be
argument_list|(
name|queue_reg
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|void
name|fman_port_set_qmi_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|enum
name|fman_port_qmi_counters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
modifier|*
name|queue_reg
decl_stmt|;
name|get_qmi_counter_reg
argument_list|(
name|port
argument_list|,
name|counter
argument_list|,
operator|&
name|queue_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue_reg
operator|==
name|NULL
condition|)
return|return;
name|iowrite32be
argument_list|(
name|value
argument_list|,
name|queue_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|fman_port_get_bpool_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint8_t
name|bpid
parameter_list|)
block|{
name|uint8_t
name|index
decl_stmt|;
name|uint32_t
name|ret_val
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Find the pool */
name|index
operator|=
name|fman_port_find_bpool
argument_list|(
name|port
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|port
operator|->
name|ext_pools_num
operator|||
name|index
operator|==
name|FMAN_PORT_MAX_EXT_POOLS_NUM
condition|)
comment|/* Not found */
return|return
literal|0
return|;
name|ret_val
operator|=
name|ioread32be
argument_list|(
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_acnt
index|[
name|index
index|]
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|void
name|fman_port_set_bpool_counter
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint8_t
name|bpid
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint8_t
name|index
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
break|break;
default|default:
return|return;
block|}
comment|/* Find the pool */
name|index
operator|=
name|fman_port_find_bpool
argument_list|(
name|port
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|port
operator|->
name|ext_pools_num
operator|||
name|index
operator|==
name|FMAN_PORT_MAX_EXT_POOLS_NUM
condition|)
comment|/* Not found */
return|return;
name|iowrite32be
argument_list|(
name|value
argument_list|,
operator|&
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_acnt
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fman_port_add_congestion_grps
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|grps_map
index|[
name|FMAN_PORT_CG_MAP_NUM
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|,
modifier|*
name|grp_map_reg
decl_stmt|;
name|uint8_t
name|max_grp_map_num
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
if|if
condition|(
name|port
operator|->
name|fm_rev_maj
operator|==
literal|4
condition|)
name|max_grp_map_num
operator|=
literal|1
expr_stmt|;
else|else
name|max_grp_map_num
operator|=
name|FMAN_PORT_CG_MAP_NUM
expr_stmt|;
name|grp_map_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rcgm
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
name|max_grp_map_num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|fm_rev_maj
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|grp_map_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ocgm
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|max_grp_map_num
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|grps_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|grp_map_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tmp
operator||=
name|grps_map
index|[
name|i
index|]
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|grp_map_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_port_remove_congestion_grps
parameter_list|(
name|struct
name|fman_port
modifier|*
name|port
parameter_list|,
name|uint32_t
name|grps_map
index|[
name|FMAN_PORT_CG_MAP_NUM
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|,
modifier|*
name|grp_map_reg
decl_stmt|;
name|uint8_t
name|max_grp_map_num
decl_stmt|;
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
case|case
name|E_FMAN_PORT_TYPE_RX
case|:
case|case
name|E_FMAN_PORT_TYPE_RX_10G
case|:
if|if
condition|(
name|port
operator|->
name|fm_rev_maj
operator|==
literal|4
condition|)
name|max_grp_map_num
operator|=
literal|1
expr_stmt|;
else|else
name|max_grp_map_num
operator|=
name|FMAN_PORT_CG_MAP_NUM
expr_stmt|;
name|grp_map_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rcgm
expr_stmt|;
break|break;
case|case
name|E_FMAN_PORT_TYPE_OP
case|:
name|max_grp_map_num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|fm_rev_maj
operator|!=
literal|4
condition|)
return|return
operator|-
name|EINVAL
return|;
name|grp_map_reg
operator|=
name|port
operator|->
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ocgm
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|max_grp_map_num
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|grps_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|grp_map_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|grps_map
index|[
name|i
index|]
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|grp_map_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

