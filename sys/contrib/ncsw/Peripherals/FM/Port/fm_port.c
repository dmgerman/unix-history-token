begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_port.c   @Description   FM driver routines implementation. */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"sprint_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_port.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CheckInitParameters
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortDriverParam
modifier|*
name|p_Params
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
decl_stmt|;
name|t_Error
name|ans
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|unusedMask
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|bool
name|found
decl_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
operator|(
name|ans
operator|=
name|FmPortImCheckInitParameters
argument_list|(
name|p_FmPort
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|ans
argument_list|)
return|;
block|}
else|else
block|{
comment|/****************************************/
comment|/*   Rx only                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* external buffer pools */
if|if
condition|(
operator|!
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
operator|>
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfPoolsUsed can't be larger than %d"
operator|,
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_Params
operator|->
name|extBufPools
operator|.
name|extBufPool
index|[
name|i
index|]
operator|.
name|id
operator|>=
name|BM_MAX_NUM_OF_POOLS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"extBufPools.extBufPool[%d].id can't be larger than %d"
operator|,
name|i
operator|,
name|BM_MAX_NUM_OF_POOLS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Params
operator|->
name|extBufPools
operator|.
name|extBufPool
index|[
name|i
index|]
operator|.
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"extBufPools.extBufPool[%d].size is 0"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* backup BM pools indication is valid only for some chip deriviatives                (limited by the config routine) */
if|if
condition|(
name|p_Params
operator|->
name|p_BackupBmPools
condition|)
block|{
if|if
condition|(
name|p_Params
operator|->
name|p_BackupBmPools
operator|->
name|numOfBackupPools
operator|>=
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"p_BackupBmPools must be smaller than extBufPools.numOfPoolsUsed"
operator|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Params
operator|->
name|p_BackupBmPools
operator|->
name|numOfBackupPools
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p_Params
operator|->
name|p_BackupBmPools
operator|->
name|poolIds
index|[
name|i
index|]
operator|==
name|p_Params
operator|->
name|extBufPools
operator|.
name|extBufPool
index|[
name|j
index|]
operator|.
name|id
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* up to extBufPools.numOfPoolsUsed pools may be defined */
if|if
condition|(
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|numberOfPoolsModeEnable
condition|)
block|{
if|if
condition|(
operator|(
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|numOfPools
operator|>
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed"
operator|,
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|numOfPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check that part of IC that needs copying is small enough to enter start margin */
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|+
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|>
name|p_Params
operator|->
name|bufMargins
operator|.
name|startMargins
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.size is larger than start margins"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|liodnOffset
operator|&
operator|~
name|FM_LIODN_OFFSET_MASK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"liodnOffset is larger than %d"
operator|,
name|FM_LIODN_OFFSET_MASK
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PARTITION_ARRAY
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|p_Params
operator|->
name|liodnOffset
operator|>=
name|MAX_LIODN_OFFSET
condition|)
block|{
name|p_Params
operator|->
name|liodnOffset
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_Params
operator|->
name|liodnOffset
operator|&
operator|(
name|MAX_LIODN_OFFSET
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"liodnOffset number is out of rev1 range - MSB bits cleard."
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* FM_PARTITION_ARRAY */
block|}
comment|/****************************************/
comment|/*   Non Rx ports                       */
comment|/****************************************/
else|else
block|{
if|if
condition|(
name|p_Params
operator|->
name|deqSubPortal
operator|>=
name|MAX_QMI_DEQ_SUBPORTAL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" deqSubPortal has to be in the range of 0 - %d"
operator|,
name|MAX_QMI_DEQ_SUBPORTAL
operator|)
argument_list|)
expr_stmt|;
comment|/* to protect HW internal-context from overwrite */
if|if
condition|(
operator|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|)
operator|&&
operator|(
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|<
name|MIN_TX_INT_OFFSET
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"non-Rx intContext.intContextOffset can't be smaller than %d"
operator|,
name|MIN_TX_INT_OFFSET
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Rx Or Offline Parsing              */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_Params
operator|->
name|dfltFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"dfltFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
argument_list|)
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|manipExtraSpace
operator|%
literal|16
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufferPrefixContent.manipExtraSpace has to be devidable by 16"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(FM_CAPWAP_SUPPORT)&& ... */
block|}
comment|/****************************************/
comment|/*   All ports                          */
comment|/****************************************/
comment|/* common BMI registers values */
comment|/* Check that Queue Id is not larger than 2^24, and is not 0 */
if|if
condition|(
operator|(
name|p_Params
operator|->
name|errFqid
operator|&
operator|~
literal|0x00FFFFFF
operator|)
operator|||
operator|!
name|p_Params
operator|->
name|errFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"errFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|dfltFqid
operator|&
operator|~
literal|0x00FFFFFF
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"dfltFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Rx only                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* Check that divisible by 256 and not larger than 256 */
if|if
condition|(
name|p_Params
operator|->
name|rxFifoPriElevationLevel
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoPriElevationLevel has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Params
operator|->
name|rxFifoPriElevationLevel
operator|||
operator|(
name|p_Params
operator|->
name|rxFifoPriElevationLevel
operator|>
name|BMI_MAX_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoPriElevationLevel has to be in the range of 256 - %d"
operator|,
name|BMI_MAX_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|rxFifoThreshold
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoThreshold has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Params
operator|->
name|rxFifoThreshold
operator|||
operator|(
name|p_Params
operator|->
name|rxFifoThreshold
operator|>
name|BMI_MAX_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoThreshold has to be in the range of 256 - %d"
operator|,
name|BMI_MAX_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that not larger than 16 */
if|if
condition|(
name|p_Params
operator|->
name|cutBytesFromEnd
operator|>
name|FRAME_END_DATA_SIZE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"cutBytesFromEnd can't be larger than %d"
operator|,
name|FRAME_END_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* Check the margin definition */
if|if
condition|(
name|p_Params
operator|->
name|bufMargins
operator|.
name|startMargins
operator|>
name|MAX_EXT_BUFFER_OFFSET
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufMargins.startMargins can't be larger than %d"
operator|,
name|MAX_EXT_BUFFER_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|bufMargins
operator|.
name|endMargins
operator|>
name|MAX_EXT_BUFFER_OFFSET
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufMargins.endMargins can't be larger than %d"
operator|,
name|MAX_EXT_BUFFER_OFFSET
operator|)
argument_list|)
expr_stmt|;
comment|/* extra FIFO size (allowed only to Rx ports) */
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoBufs.extra has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|numberOfPoolsModeEnable
operator|&&
operator|!
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|numOfPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_CSI_CFED_LIMIT
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
block|{
comment|/* Check that not larger than 16 */
if|if
condition|(
name|p_Params
operator|->
name|cutBytesFromEnd
operator|+
name|p_Params
operator|->
name|cheksumLastBytesIgnore
operator|>
name|FRAME_END_DATA_SIZE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d"
operator|,
name|FRAME_END_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FM_CSI_CFED_LIMIT */
block|}
comment|/****************************************/
comment|/*   Non Rx ports                       */
comment|/****************************************/
elseif|else
comment|/* extra FIFO size (allowed only to Rx ports) */
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" No fifoBufs.extra for non Rx ports"
operator|)
argument_list|)
expr_stmt|;
comment|/****************************************/
comment|/*   Rx& Tx                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* Check that not larger than 16 */
if|if
condition|(
name|p_Params
operator|->
name|cheksumLastBytesIgnore
operator|>
name|FRAME_END_DATA_SIZE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"cheksumLastBytesIgnore can't be larger than %d"
operator|,
name|FRAME_END_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Tx only                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
block|{
comment|/* Check that divisible by 256 and not larger than 256 */
if|if
condition|(
name|p_Params
operator|->
name|txFifoMinFillLevel
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoMinFillLevel has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|txFifoMinFillLevel
operator|>
operator|(
name|BMI_MAX_FIFO_SIZE
operator|-
literal|256
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoMinFillLevel has to be in the range of 0 - %d"
operator|,
name|BMI_MAX_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|txFifoLowComfLevel
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoLowComfLevel has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Params
operator|->
name|txFifoLowComfLevel
operator|||
operator|(
name|p_Params
operator|->
name|txFifoLowComfLevel
operator|>
name|BMI_MAX_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoLowComfLevel has to be in the range of 256 - %d"
operator|,
name|BMI_MAX_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that not larger than 8 */
if|if
condition|(
operator|(
operator|!
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|>
name|MAX_FIFO_PIPELINE_DEPTH
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoDeqPipelineDepth can't be larger than %d"
operator|,
name|MAX_FIFO_PIPELINE_DEPTH
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
condition|)
if|if
condition|(
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|>
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoDeqPipelineDepth for !G can't be larger than 2"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/****************************************/
comment|/*   Non Tx Ports                       */
comment|/****************************************/
block|{
comment|/* If discard override was selected , no frames may be discarded. */
if|if
condition|(
name|p_Params
operator|->
name|frmDiscardOverride
operator|&&
name|p_Params
operator|->
name|errorsToDiscard
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Rx and Offline parsing             */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|unusedMask
operator|=
name|BMI_STATUS_OP_MASK_UNUSED
expr_stmt|;
else|else
name|unusedMask
operator|=
name|BMI_STATUS_RX_MASK_UNUSED
expr_stmt|;
comment|/* Check that no common bits with BMI_STATUS_MASK_UNUSED */
if|if
condition|(
name|p_Params
operator|->
name|errorsToDiscard
operator|&
name|unusedMask
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"errorsToDiscard contains undefined bits"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   All ports                          */
comment|/****************************************/
comment|/* Check that divisible by 16 and not larger than 240 */
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|>
name|MAX_INT_OFFSET
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.intContextOffset can't be larger than %d"
operator|,
name|MAX_INT_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|%
name|OFFSET_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.intContextOffset has to be divisible by %d"
operator|,
name|OFFSET_UNITS
operator|)
argument_list|)
expr_stmt|;
comment|/* check that ic size+ic internal offset, does not exceed ic block size */
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|+
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|>
name|MAX_IC_SIZE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.size + intContext.intContextOffset has to be smaller than %d"
operator|,
name|MAX_IC_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that divisible by 16 and not larger than 256 */
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|%
name|OFFSET_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.size  has to be divisible by %d"
operator|,
name|OFFSET_UNITS
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that divisible by 16 and not larger than 4K */
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|>
name|MAX_EXT_OFFSET
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.extBufOffset can't be larger than %d"
operator|,
name|MAX_EXT_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|%
name|OFFSET_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.extBufOffset  has to be divisible by %d"
operator|,
name|OFFSET_UNITS
operator|)
argument_list|)
expr_stmt|;
comment|/* common BMI registers values */
if|if
condition|(
operator|(
operator|!
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|>
name|MAX_NUM_OF_TASKS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"tasks.num can't be larger than %d"
operator|,
name|MAX_NUM_OF_TASKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"tasks.extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_TASKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|>
name|MAX_NUM_OF_DMAS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas.num can't be larger than %d"
operator|,
name|MAX_NUM_OF_DMAS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_DMAS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas.extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_DMAS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|||
operator|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|>
name|BMI_MAX_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoBufs.num has to be in the range of 256 - %d"
operator|,
name|BMI_MAX_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoBufs.num has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FmPortDriverParamFree
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetExtBufferPools
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortExtPools
modifier|*
name|p_ExtBufPools
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
decl_stmt|;
name|t_FmPortBufPoolDepletion
modifier|*
name|p_BufPoolDepletion
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufPoolDepletion
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_ExtBufRegs
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BufPoolDepletionReg
decl_stmt|;
name|bool
name|rxPort
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|uint8_t
name|orderedArray
index|[
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
index|]
decl_stmt|;
name|uint16_t
name|sizesArray
index|[
name|BM_MAX_NUM_OF_POOLS
index|]
decl_stmt|;
name|uint8_t
name|count
init|=
literal|0
decl_stmt|;
name|uint8_t
name|numOfPools
decl_stmt|;
name|uint16_t
name|bufSize
init|=
literal|0
decl_stmt|,
name|largestBufSize
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|,
name|vector
decl_stmt|,
name|minFifoSizeRequired
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|orderedArray
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sizesArray
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|BM_MAX_NUM_OF_POOLS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|extBufPools
argument_list|,
name|p_ExtBufPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortExtPools
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_ExtBufRegs
operator|=
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
expr_stmt|;
name|p_BufPoolDepletionReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_mpd
expr_stmt|;
name|rxPort
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_ExtBufRegs
operator|=
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_oebmpi
expr_stmt|;
name|p_BufPoolDepletionReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ompd
expr_stmt|;
name|rxPort
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* First we copy the external buffers pools information to an ordered local array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|i
operator|++
control|)
block|{
comment|/* get pool size */
name|bufSize
operator|=
name|p_ExtBufPools
operator|->
name|extBufPool
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
comment|/* keep sizes in an array according to poolId for direct access */
name|sizesArray
index|[
name|p_ExtBufPools
operator|->
name|extBufPool
index|[
name|i
index|]
operator|.
name|id
index|]
operator|=
name|bufSize
expr_stmt|;
comment|/* save poolId in an ordered array according to size */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
block|{
comment|/* this is the next free place in the array */
if|if
condition|(
name|j
operator|==
name|i
condition|)
name|orderedArray
index|[
name|i
index|]
operator|=
name|p_ExtBufPools
operator|->
name|extBufPool
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
else|else
block|{
comment|/* find the right place for this poolId */
if|if
condition|(
name|bufSize
operator|<
name|sizesArray
index|[
name|orderedArray
index|[
name|j
index|]
index|]
condition|)
block|{
comment|/* move the poolIds one place ahead to make room for this poolId */
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|--
control|)
name|orderedArray
index|[
name|k
index|]
operator|=
name|orderedArray
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
comment|/* now k==j, this is the place for the new size */
name|orderedArray
index|[
name|k
index|]
operator|=
name|p_ExtBufPools
operator|->
name|extBufPool
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* build the register value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|i
operator|++
control|)
block|{
name|tmpReg
operator|=
name|BMI_EXT_BUF_POOL_VALID
operator||
name|BMI_EXT_BUF_POOL_EN_COUNTER
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|orderedArray
index|[
name|i
index|]
operator|<<
name|BMI_EXT_BUF_POOL_ID_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
name|sizesArray
index|[
name|orderedArray
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* functionality available only for some deriviatives (limited by config) */
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
operator|->
name|numOfBackupPools
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|orderedArray
index|[
name|i
index|]
operator|==
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
operator|->
name|poolIds
index|[
name|j
index|]
condition|)
block|{
name|tmpReg
operator||=
name|BMI_EXT_BUF_POOL_BACKUP
expr_stmt|;
break|break;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_ExtBufRegs
operator|+
name|i
operator|)
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
argument_list|)
expr_stmt|;
name|numOfPools
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|rxPort
condition|?
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
else|:
name|FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS
argument_list|)
expr_stmt|;
comment|/* clear unused pools */
for|for
control|(
name|i
operator|=
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
init|;
name|i
operator|<
name|numOfPools
condition|;
name|i
operator|++
control|)
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_ExtBufRegs
operator|+
name|i
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
operator|=
name|largestBufSize
operator|=
name|sizesArray
index|[
name|orderedArray
index|[
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
operator|-
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FM_FIFO_ALLOCATION_OLD_ALG
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
block|{
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|largestBufSize
operator|%
name|BMI_FIFO_UNITS
operator|)
condition|?
operator|(
operator|(
name|largestBufSize
operator|/
name|BMI_FIFO_UNITS
operator|+
literal|1
operator|)
operator|*
name|BMI_FIFO_UNITS
operator|)
else|:
name|largestBufSize
operator|)
operator|+
operator|(
literal|7
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* FM_FIFO_ALLOCATION_OLD_ALG */
block|{
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|numOfPools
operator|=
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
expr_stmt|;
if|if
condition|(
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
operator|==
literal|1
condition|)
name|minFifoSizeRequired
operator|=
literal|8
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
else|else
block|{
name|uint16_t
name|secondLargestBufSize
init|=
name|sizesArray
index|[
name|orderedArray
index|[
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
operator|-
literal|2
index|]
index|]
decl_stmt|;
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|secondLargestBufSize
operator|=
name|secondLargestBufSize
expr_stmt|;
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|secondLargestBufSize
operator|%
name|BMI_FIFO_UNITS
operator|)
condition|?
operator|(
operator|(
name|secondLargestBufSize
operator|/
name|BMI_FIFO_UNITS
operator|+
literal|1
operator|)
operator|*
name|BMI_FIFO_UNITS
operator|)
else|:
name|secondLargestBufSize
operator|)
operator|+
operator|(
literal|7
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|<
name|minFifoSizeRequired
condition|)
block|{
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|minFifoSizeRequired
expr_stmt|;
name|DBG
argument_list|(
name|INFO
argument_list|,
operator|(
literal|"FIFO size for Rx port enlarged to %d"
operator|,
name|minFifoSizeRequired
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check if pool size is not too big */
comment|/* This is a definition problem in which if the fifo for the RX port        is lower than the largest pool size the hardware will allocate scatter gather        buffers even though the frame size can fit in a single buffer. */
if|if
condition|(
name|largestBufSize
operator|>
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"Frame larger than port Fifo size (%u) will be split to more than a single buffer (S/G) even if shorter than largest buffer size (%u)"
operator|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|,
name|largestBufSize
operator|)
argument_list|)
expr_stmt|;
comment|/* pool depletion */
name|tmpReg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|numberOfPoolsModeEnable
condition|)
block|{
comment|/* calculate vector for number of pools depletion */
name|found
operator|=
name|FALSE
expr_stmt|;
name|vector
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BM_MAX_NUM_OF_POOLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|poolsToConsider
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|orderedArray
index|[
name|j
index|]
condition|)
block|{
name|vector
operator||=
literal|0x80000000
operator|>>
name|j
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Pools selected for depletion are not used."
operator|)
argument_list|)
expr_stmt|;
else|else
name|found
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|<
name|p_BufPoolDepletion
operator|->
name|numOfPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufPoolDepletion.numOfPools is larger than the number of pools defined."
operator|)
argument_list|)
expr_stmt|;
comment|/* configure num of pools and vector for number of pools mode */
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_BufPoolDepletion
operator|->
name|numOfPools
operator|-
literal|1
operator|)
operator|<<
name|BMI_POOL_DEP_NUM_OF_POOLS_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
name|vector
expr_stmt|;
block|}
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|singlePoolModeEnable
condition|)
block|{
comment|/* calculate vector for number of pools depletion */
name|found
operator|=
name|FALSE
expr_stmt|;
name|vector
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BM_MAX_NUM_OF_POOLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|poolsToConsiderForSingleMode
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|orderedArray
index|[
name|j
index|]
condition|)
block|{
name|vector
operator||=
literal|0x00000080
operator|>>
name|j
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Pools selected for depletion are not used."
operator|)
argument_list|)
expr_stmt|;
else|else
name|found
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|count
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"No pools defined for single buffer mode pool depletion."
operator|)
argument_list|)
expr_stmt|;
comment|/* configure num of pools and vector for number of pools mode */
name|tmpReg
operator||=
name|vector
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BufPoolDepletionReg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|ClearPerfCnts
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiRxPortInit
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortRxBmiRegs
modifier|*
name|p_Regs
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|t_FmPortDriverParam
modifier|*
name|p_Params
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
decl_stmt|;
name|uint32_t
name|errorsToEnq
init|=
literal|0
decl_stmt|;
name|t_FmPortPerformanceCnt
name|performanceContersParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* check that port is not busy */
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rcfg
argument_list|)
operator|&
name|BMI_PORT_CFG_EN
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Port(%d,%d) is already enabled"
operator|,
name|p_FmPort
operator|->
name|portType
operator|,
name|p_FmPort
operator|->
name|portId
operator|)
argument_list|)
expr_stmt|;
comment|/* Set Config register */
name|tmpReg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|tmpReg
operator||=
name|BMI_PORT_CFG_IM
expr_stmt|;
comment|/* No discard - all error frames go to error queue */
elseif|else
if|if
condition|(
name|p_Params
operator|->
name|frmDiscardOverride
condition|)
name|tmpReg
operator||=
name|BMI_PORT_CFG_FDOVR
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rcfg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* Configure dma attributes */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaSwapData
operator|<<
name|BMI_DMA_ATTR_SWP_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaIntContextCacheAttr
operator|<<
name|BMI_DMA_ATTR_IC_CACHE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaHeaderCacheAttr
operator|<<
name|BMI_DMA_ATTR_HDR_CACHE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaScatterGatherCacheAttr
operator|<<
name|BMI_DMA_ATTR_SG_CACHE_SHIFT
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|dmaWriteOptimize
condition|)
name|tmpReg
operator||=
name|BMI_DMA_ATTR_WRITE_OPTIMIZE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rda
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* Configure Rx Fifo params */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|p_Params
operator|->
name|rxFifoPriElevationLevel
operator|/
name|BMI_FIFO_UNITS
operator|-
literal|1
operator|)
operator|<<
name|BMI_RX_FIFO_PRI_ELEVATION_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|p_Params
operator|->
name|rxFifoThreshold
operator|/
name|BMI_FIFO_UNITS
operator|-
literal|1
operator|)
operator|<<
name|BMI_RX_FIFO_THRESHOLD_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfp
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|FM_NO_THRESHOLD_REG
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|>
literal|1
condition|)
endif|#
directive|endif
comment|/* FM_NO_THRESHOLD_REG */
comment|/* always allow access to the extra resources */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_reth
argument_list|,
name|BMI_RX_FIFO_THRESHOLD_BC
argument_list|)
expr_stmt|;
block|}
comment|/* frame end parameters */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|cheksumLastBytesIgnore
operator|<<
name|BMI_RX_FRAME_END_CS_IGNORE_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|cutBytesFromEnd
operator|<<
name|BMI_RX_FRAME_END_CUT_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfed
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* IC parameters */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_TO_EXT_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_FROM_INT_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_SIZE_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ricp
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
comment|/* check if the largest external buffer pool is large enough */
if|if
condition|(
name|p_Params
operator|->
name|bufMargins
operator|.
name|startMargins
operator|+
name|MIN_EXT_BUF_SIZE
operator|+
name|p_Params
operator|->
name|bufMargins
operator|.
name|endMargins
operator|>
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)"
operator|,
name|p_Params
operator|->
name|bufMargins
operator|.
name|startMargins
operator|,
name|p_Params
operator|->
name|bufMargins
operator|.
name|endMargins
operator|,
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
operator|)
argument_list|)
expr_stmt|;
comment|/* buffer margins */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|bufMargins
operator|.
name|startMargins
operator|)
operator|<<
name|BMI_EXT_BUF_MARG_START_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|bufMargins
operator|.
name|endMargins
operator|)
operator|<<
name|BMI_EXT_BUF_MARG_END_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rebm
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|internalBufferOffset
condition|)
block|{
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|%
name|OFFSET_UNITS
operator|)
condition|?
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|/
name|OFFSET_UNITS
operator|+
literal|1
operator|)
else|:
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|/
name|OFFSET_UNITS
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|internalBufferOffset
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|tmpReg
operator|*
name|OFFSET_UNITS
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rim
argument_list|,
name|tmpReg
operator|<<
name|BMI_IM_FOF_SHIFT
argument_list|)
expr_stmt|;
block|}
comment|/* NIA */
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfne
argument_list|,
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_IND_MODE_RX
argument_list|)
expr_stmt|;
else|else
block|{
name|tmpReg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|forwardReuseIntContext
condition|)
name|tmpReg
operator||=
name|BMI_PORT_RFNE_FRWD_RPD
expr_stmt|;
comment|/* L3/L4 checksum verify is enabled by default. */
comment|/*tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;*/
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfne
argument_list|,
name|tmpReg
operator||
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfene
argument_list|,
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|)
expr_stmt|;
comment|/* command attribute */
name|tmpReg
operator|=
name|BMI_CMD_RX_MR_DEF
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
name|tmpReg
operator||=
name|BMI_CMD_ATTR_ORDER
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|syncReq
condition|)
name|tmpReg
operator||=
name|BMI_CMD_ATTR_SYNC
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|color
operator|<<
name|BMI_CMD_ATTR_COLOR_SHIFT
operator|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfca
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* default queues */
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfqid
argument_list|,
name|p_Params
operator|->
name|dfltFqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_refqid
argument_list|,
name|p_Params
operator|->
name|errFqid
argument_list|)
expr_stmt|;
block|}
comment|/* set counters */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rstc
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
name|performanceContersParams
operator|.
name|taskCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
name|performanceContersParams
operator|.
name|queueCompVal
operator|=
literal|1
expr_stmt|;
name|performanceContersParams
operator|.
name|dmaCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|performanceContersParams
operator|.
name|fifoCompVal
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|performanceContersParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rpc
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
comment|/* error/status mask  - check that if discard OV is set, no        discard is required for specific errors.*/
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfsdm
argument_list|,
name|p_Params
operator|->
name|errorsToDiscard
argument_list|)
expr_stmt|;
name|errorsToEnq
operator|=
operator|(
name|RX_ERRS_TO_ENQ
operator|&
operator|~
name|p_Params
operator|->
name|errorsToDiscard
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfsem
argument_list|,
name|errorsToEnq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_BMI_TO_RISC_ENQ_ERRATA_FMANc
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_rfene
argument_list|)
operator|&&
name|NIA_ENG_MASK
operator|)
operator|==
name|NIA_ENG_FM_CTL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"NIA not supported at this stage"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_BMI_TO_RISC_ENQ_ERRATA_FMANc */
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiTxPortInit
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortTxBmiRegs
modifier|*
name|p_Regs
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|t_FmPortDriverParam
modifier|*
name|p_Params
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
decl_stmt|;
comment|/*uint32_t            rateCountUnit;*/
name|t_FmPortPerformanceCnt
name|performanceContersParams
decl_stmt|;
comment|/* check that port is not busy */
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tcfg
argument_list|)
operator|&
name|BMI_PORT_CFG_EN
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Port is already enabled"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|tmpReg
operator||=
name|BMI_PORT_CFG_IM
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tcfg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* Configure dma attributes */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaSwapData
operator|<<
name|BMI_DMA_ATTR_SWP_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaIntContextCacheAttr
operator|<<
name|BMI_DMA_ATTR_IC_CACHE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaHeaderCacheAttr
operator|<<
name|BMI_DMA_ATTR_HDR_CACHE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaScatterGatherCacheAttr
operator|<<
name|BMI_DMA_ATTR_SG_CACHE_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tda
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* Configure Tx Fifo params */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|p_Params
operator|->
name|txFifoMinFillLevel
operator|/
name|BMI_FIFO_UNITS
operator|)
operator|<<
name|BMI_TX_FIFO_MIN_FILL_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|-
literal|1
operator|)
operator|<<
name|BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|p_Params
operator|->
name|txFifoLowComfLevel
operator|/
name|BMI_FIFO_UNITS
operator|-
literal|1
operator|)
operator|<<
name|BMI_TX_LOW_COMF_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfp
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* frame end parameters */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|cheksumLastBytesIgnore
operator|<<
name|BMI_TX_FRAME_END_CS_IGNORE_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfed
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
comment|/* IC parameters */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_TO_EXT_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_FROM_INT_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_SIZE_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ticp
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
comment|/* NIA */
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfne
argument_list|,
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_IND_MODE_TX
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfene
argument_list|,
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_IND_MODE_TX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfne
argument_list|,
name|NIA_ENG_QMI_DEQ
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfene
argument_list|,
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|)
expr_stmt|;
comment|/* The line bellow is a trick so the FM will not release the buffer            to BM nor will try to enq the frame to QM */
if|if
condition|(
operator|!
name|p_Params
operator|->
name|dfltFqid
operator|&&
name|p_Params
operator|->
name|dontReleaseBuf
condition|)
block|{
comment|/* override fmbm_tcfqid 0 with a false non-0 value. This will force FM to              * act acording to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release              * buffers to BM regardless of fmbm_tfene              */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tcfqid
argument_list|,
literal|0xFFFFFF
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfene
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* command attribute */
name|tmpReg
operator|=
name|BMI_CMD_TX_MR_DEF
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|tmpReg
operator||=
name|BMI_CMD_MR_DEAS
expr_stmt|;
else|else
block|{
name|tmpReg
operator||=
name|BMI_CMD_ATTR_ORDER
expr_stmt|;
comment|/* if we set syncReq, we may get stuck when HC command is running */
comment|/*if(p_Params->syncReq)             tmpReg |= BMI_CMD_ATTR_SYNC;*/
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|color
operator|<<
name|BMI_CMD_ATTR_COLOR_SHIFT
operator|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfca
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* default queues */
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
name|p_Params
operator|->
name|dfltFqid
operator|||
operator|!
name|p_Params
operator|->
name|dontReleaseBuf
condition|)
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tcfqid
argument_list|,
name|p_Params
operator|->
name|dfltFqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tfeqid
argument_list|,
name|p_Params
operator|->
name|errFqid
argument_list|)
expr_stmt|;
block|}
comment|/* statistics& performance counters */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tstc
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
name|performanceContersParams
operator|.
name|taskCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
name|performanceContersParams
operator|.
name|queueCompVal
operator|=
literal|1
expr_stmt|;
name|performanceContersParams
operator|.
name|dmaCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|performanceContersParams
operator|.
name|fifoCompVal
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|performanceContersParams
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_tpc
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiOhPortInit
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortOhBmiRegs
modifier|*
name|p_Regs
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|,
name|errorsToEnq
init|=
literal|0
decl_stmt|;
name|t_FmPortDriverParam
modifier|*
name|p_Params
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
decl_stmt|;
name|t_FmPortPerformanceCnt
name|performanceContersParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* check that port is not busy */
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ocfg
argument_list|)
operator|&
name|BMI_PORT_CFG_EN
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Port is already enabled"
operator|)
argument_list|)
expr_stmt|;
comment|/* Configure dma attributes */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaSwapData
operator|<<
name|BMI_DMA_ATTR_SWP_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaIntContextCacheAttr
operator|<<
name|BMI_DMA_ATTR_IC_CACHE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaHeaderCacheAttr
operator|<<
name|BMI_DMA_ATTR_HDR_CACHE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|dmaScatterGatherCacheAttr
operator|<<
name|BMI_DMA_ATTR_SG_CACHE_SHIFT
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|dmaWriteOptimize
condition|)
name|tmpReg
operator||=
name|BMI_DMA_ATTR_WRITE_OPTIMIZE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_oda
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* IC parameters */
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_TO_EXT_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_FROM_INT_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|/
name|OFFSET_UNITS
operator|)
operator|<<
name|BMI_IC_SIZE_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_oicp
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* NIA */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofdne
argument_list|,
name|NIA_ENG_QMI_DEQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofene
argument_list|,
name|NIA_ENG_QMI_ENQ
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofene
argument_list|,
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|)
expr_stmt|;
comment|/* command attribute */
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|tmpReg
operator|=
name|BMI_CMD_MR_DEAS
operator||
name|BMI_CMD_MR_MA
expr_stmt|;
else|else
name|tmpReg
operator|=
name|BMI_CMD_ATTR_ORDER
operator||
name|BMI_CMD_MR_DEAS
operator||
name|BMI_CMD_MR_MA
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|syncReq
condition|)
name|tmpReg
operator||=
name|BMI_CMD_ATTR_SYNC
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|color
operator|<<
name|BMI_CMD_ATTR_COLOR_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofca
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* No discard - all error frames go to error queue */
if|if
condition|(
name|p_Params
operator|->
name|frmDiscardOverride
condition|)
name|tmpReg
operator|=
name|BMI_PORT_CFG_FDOVR
expr_stmt|;
else|else
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ocfg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofsdm
argument_list|,
name|p_Params
operator|->
name|errorsToDiscard
argument_list|)
expr_stmt|;
name|errorsToEnq
operator|=
operator|(
name|OP_ERRS_TO_ENQ
operator|&
operator|~
name|p_Params
operator|->
name|errorsToDiscard
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofsem
argument_list|,
name|errorsToEnq
argument_list|)
expr_stmt|;
comment|/* NIA */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofne
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|FM_NO_OP_OBSERVED_POOLS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
operator|&&
operator|(
name|p_Params
operator|->
name|enBufPoolDepletion
operator|)
condition|)
endif|#
directive|endif
comment|/* FM_NO_OP_OBSERVED_POOLS */
block|{
comment|/* define external buffer pools */
name|err
operator|=
name|SetExtBufferPools
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* NIA */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofne
argument_list|,
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_HC
argument_list|)
expr_stmt|;
comment|/* default queues */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ofqid
argument_list|,
name|p_Params
operator|->
name|dfltFqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_oefqid
argument_list|,
name|p_Params
operator|->
name|errFqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|internalBufferOffset
condition|)
block|{
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|%
name|OFFSET_UNITS
operator|)
condition|?
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|/
name|OFFSET_UNITS
operator|+
literal|1
operator|)
else|:
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|/
name|OFFSET_UNITS
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|internalBufferOffset
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|tmpReg
operator|*
name|OFFSET_UNITS
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_oim
argument_list|,
name|tmpReg
operator|<<
name|BMI_IM_FOF_SHIFT
argument_list|)
expr_stmt|;
block|}
comment|/* statistics& performance counters */
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_ostc
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
name|performanceContersParams
operator|.
name|taskCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
name|performanceContersParams
operator|.
name|queueCompVal
operator|=
literal|0
expr_stmt|;
name|performanceContersParams
operator|.
name|dmaCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|performanceContersParams
operator|.
name|fifoCompVal
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|performanceContersParams
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmbm_opc
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|QmiInit
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortDriverParam
modifier|*
name|p_Params
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|p_Params
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
expr_stmt|;
comment|/* check that port is not busy */
if|if
condition|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|)
operator|&&
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Port is already enabled"
operator|)
argument_list|)
expr_stmt|;
comment|/* enable& clear counters */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|,
name|QMI_PORT_CFG_EN_COUNTERS
argument_list|)
expr_stmt|;
comment|/* The following is  done for non-Rx ports only */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
block|{
comment|/* define dequeue NIA */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX
argument_list|)
expr_stmt|;
comment|/* define enqueue NIA */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX_RELEASE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* for HC& OP */
block|{
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_FETCH
argument_list|)
expr_stmt|;
comment|/* define enqueue NIA */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_RELEASE
argument_list|)
expr_stmt|;
block|}
comment|/* configure dequeue */
name|tmpReg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|deqHighPriority
condition|)
name|tmpReg
operator||=
name|QMI_DEQ_CFG_PRI
expr_stmt|;
switch|switch
condition|(
name|p_Params
operator|->
name|deqType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_DEQ_TYPE1
operator|)
case|:
name|tmpReg
operator||=
name|QMI_DEQ_CFG_TYPE1
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_DEQ_TYPE2
operator|)
case|:
name|tmpReg
operator||=
name|QMI_DEQ_CFG_TYPE2
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_DEQ_TYPE3
operator|)
case|:
name|tmpReg
operator||=
name|QMI_DEQ_CFG_TYPE3
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid dequeue type"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FM_QMI_DEQ_OPTIONS_SUPPORT
switch|switch
condition|(
name|p_Params
operator|->
name|deqPrefetchOption
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_DEQ_NO_PREFETCH
operator|)
case|:
comment|/* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
break|break;
case|case
operator|(
name|e_FM_PORT_DEQ_PARTIAL_PREFETCH
operator|)
case|:
name|tmpReg
operator||=
name|QMI_DEQ_CFG_PREFETCH_WAITING_TNUM
operator||
name|QMI_DEQ_CFG_PREFETCH_3_FRAMES
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_DEQ_FULL_PREFETCH
operator|)
case|:
name|tmpReg
operator||=
name|QMI_DEQ_CFG_PREFETCH_NO_TNUM
operator||
name|QMI_DEQ_CFG_PREFETCH_3_FRAMES
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid dequeue prefetch option"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_QMI_DEQ_OPTIONS_SUPPORT */
name|tmpReg
operator||=
name|p_Params
operator|->
name|deqByteCnt
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_Params
operator|->
name|deqSubPortal
operator|<<
name|QMI_DEQ_CFG_SUBPORTAL_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndc
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* rx port */
comment|/* define enqueue NIA */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_RELEASE
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiRxPortCheckAndGetCounterPtr
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
modifier|*
name|p_Ptr
parameter_list|)
block|{
name|t_FmPortRxBmiRegs
modifier|*
name|p_BmiRegs
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
decl_stmt|;
comment|/* check that counters are enabled */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION
operator|)
case|:
comment|/* performance counters - may be read when disabled */
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_BAD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LARGE_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_BmiRegs
operator|->
name|fmbm_rstc
argument_list|)
operator|&
name|BMI_COUNTERS_EN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rccn
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rtuc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rrquc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rduc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rfuc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rpac
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rfrc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rfcd
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_BAD_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rfbc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LARGE_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rlfc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rffc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
ifdef|#
directive|ifdef
name|FM_PORT_COUNTERS_ERRATA_FMANg
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Requested counter is not available in rev1"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_COUNTERS_ERRATA_FMANg */
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rfldec
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rodc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_rbdc
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiTxPortCheckAndGetCounterPtr
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
modifier|*
name|p_Ptr
parameter_list|)
block|{
name|t_FmPortTxBmiRegs
modifier|*
name|p_BmiRegs
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
decl_stmt|;
comment|/* check that counters are enabled */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
comment|/* performance counters - may be read when disabled */
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_BmiRegs
operator|->
name|fmbm_tstc
argument_list|)
operator|&
name|BMI_COUNTERS_EN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tccn
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ttuc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ttcquc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tduc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tfuc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tfrc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tfdc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tfledc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tfufdc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_tbdc
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiOhPortCheckAndGetCounterPtr
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
modifier|*
name|p_Ptr
parameter_list|)
block|{
name|t_FmPortOhBmiRegs
modifier|*
name|p_BmiRegs
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
decl_stmt|;
comment|/* check that counters are enabled */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
comment|/* performance counters - may be read when disabled */
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_WRED_DISCARD
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_BmiRegs
operator|->
name|fmbm_ostc
argument_list|)
operator|&
name|BMI_COUNTERS_EN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
comment|/* only valid for offline parsing */
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Host Command ports"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_BmiRegs
operator|->
name|fmbm_ostc
argument_list|)
operator|&
name|BMI_COUNTERS_EN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for O/H ports"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_occn
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_otuc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_oduc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofuc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofrc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofdc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_offc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
ifdef|#
directive|ifdef
name|FM_PORT_COUNTERS_ERRATA_FMANg
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Requested counter is not available in rev1"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_COUNTERS_ERRATA_FMANg */
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofldec
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_WRED_DISCARD
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofwdc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofledc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_ofufdc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
operator|*
name|p_Ptr
operator|=
operator|&
name|p_BmiRegs
operator|->
name|fmbm_obdc
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for O/H ports"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AdditionalPrsParams
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|t_FmPcdPrsAdditionalHdrParams
modifier|*
name|p_HdrParams
parameter_list|,
name|uint32_t
modifier|*
name|p_SoftSeqAttachReg
parameter_list|)
block|{
name|uint8_t
name|hdrNum
decl_stmt|,
name|Ipv4HdrNum
decl_stmt|;
name|u_FmPcdHdrPrsOpts
modifier|*
name|p_prsOpts
decl_stmt|;
name|uint32_t
name|tmpReg
init|=
literal|0
decl_stmt|,
name|tmpPrsOffset
decl_stmt|;
if|if
condition|(
name|IS_PRIVATE_HEADER
argument_list|(
name|p_HdrParams
operator|->
name|hdr
argument_list|)
operator|||
name|IS_SPECIAL_HEADER
argument_list|(
name|p_HdrParams
operator|->
name|hdr
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"No additional parameters for private or special headers."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_HdrParams
operator|->
name|errDisable
condition|)
name|tmpReg
operator||=
name|PRS_HDR_ERROR_DIS
expr_stmt|;
comment|/* Set parser options */
if|if
condition|(
name|p_HdrParams
operator|->
name|usePrsOpts
condition|)
block|{
name|p_prsOpts
operator|=
operator|&
name|p_HdrParams
operator|->
name|prsOpts
expr_stmt|;
switch|switch
condition|(
name|p_HdrParams
operator|->
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|mplsPrsOptions
operator|.
name|labelInterpretationEnable
condition|)
name|tmpReg
operator||=
name|PRS_HDR_MPLS_LBL_INTER_EN
expr_stmt|;
name|GET_PRS_HDR_NUM
argument_list|(
name|hdrNum
argument_list|,
name|p_prsOpts
operator|->
name|mplsPrsOptions
operator|.
name|nextParse
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|GET_PRS_HDR_NUM
argument_list|(
name|Ipv4HdrNum
argument_list|,
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|<
name|Ipv4HdrNum
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Header must be equal or higher than IPv4"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|hdrNum
operator|*
name|PRS_HDR_ENTRY_SIZE
operator|)
operator|<<
name|PRS_HDR_MPLS_NEXT_HDR_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|pppoePrsOptions
operator|.
name|enableMTUCheck
condition|)
block|{
ifdef|#
directive|ifdef
name|FM_PPPOE_NO_MTU_CHECK
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Invalid parser option"
operator|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* FM_PPPOE_NO_MTU_CHECK */
name|tmpReg
operator||=
name|PRS_HDR_PPPOE_MTU_CHECK_EN
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|ipv6PrsOptions
operator|.
name|routingHdrDisable
condition|)
name|tmpReg
operator||=
name|PRS_HDR_IPV6_ROUTE_HDR_DIS
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|tcpPrsOptions
operator|.
name|padIgnoreChecksum
condition|)
name|tmpReg
operator||=
name|PRS_HDR_TCP_PAD_REMOVAL
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|udpPrsOptions
operator|.
name|padIgnoreChecksum
condition|)
name|tmpReg
operator||=
name|PRS_HDR_TCP_PAD_REMOVAL
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid header"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set software parsing (address is devided in 2 since parser uses 2 byte access. */
if|if
condition|(
name|p_HdrParams
operator|->
name|swPrsEnable
condition|)
block|{
name|tmpPrsOffset
operator|=
name|FmPcdGetSwPrsOffset
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_HdrParams
operator|->
name|hdr
argument_list|,
name|p_HdrParams
operator|->
name|indexPerHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpPrsOffset
operator|==
name|ILLEGAL_BASE
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|tmpPrsOffset
operator|)
expr_stmt|;
block|}
operator|*
name|p_SoftSeqAttachReg
operator|=
name|tmpReg
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|GetPortSchemeBindParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_SchemeBind
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|walking1Mask
init|=
literal|0x80000000
decl_stmt|,
name|tmp
decl_stmt|;
name|uint8_t
name|idx
init|=
literal|0
decl_stmt|;
name|p_SchemeBind
operator|->
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|p_SchemeBind
operator|->
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|p_SchemeBind
operator|->
name|useClsPlan
operator|=
name|p_FmPort
operator|->
name|useClsPlan
expr_stmt|;
name|p_SchemeBind
operator|->
name|numOfSchemes
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|p_FmPort
operator|->
name|schemesPerPortVector
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|&
name|walking1Mask
condition|)
block|{
name|p_SchemeBind
operator|->
name|schemesIds
index|[
name|p_SchemeBind
operator|->
name|numOfSchemes
index|]
operator|=
name|FmPcdKgGetSchemeSwId
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|p_SchemeBind
operator|->
name|numOfSchemes
operator|++
expr_stmt|;
name|tmp
operator|&=
operator|~
name|walking1Mask
expr_stmt|;
block|}
name|walking1Mask
operator|>>=
literal|1
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildBufferStructure
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
comment|/* Align start of internal context data to 16 byte */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|privDataSize
operator|&
operator|(
name|OFFSET_UNITS
operator|-
literal|1
operator|)
operator|)
condition|?
operator|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|privDataSize
operator|+
name|OFFSET_UNITS
operator|)
operator|&
operator|~
call|(
name|uint16_t
call|)
argument_list|(
name|OFFSET_UNITS
operator|-
literal|1
argument_list|)
operator|)
else|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|privDataSize
argument_list|)
expr_stmt|;
comment|/* Translate margin and intContext params to FM parameters */
ifdef|#
directive|ifdef
name|FM_INCORRECT_CS_ERRATA_FMAN18
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
block|{
name|uint8_t
name|mod
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|%
literal|256
decl_stmt|;
if|if
condition|(
name|mod
condition|)
block|{
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|+=
operator|(
literal|256
operator|-
name|mod
operator|)
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"dataAlign modified to next 256 to conform with FMAN18 errata\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* FM_INCORRECT_CS_ERRATA_FMAN18 */
comment|/* Initialize with illegal value. Later we'll set legal values. */
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|=
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
operator|=
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
operator|=
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|pcdInfoOffset
operator|=
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|debugOffset
operator|=
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Internally the driver supports 4 options        1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll           relate to it as 1).        2. All IC context (from AD) except debug.        3. Debug information only.        4. All IC context (from AD) including debug.        Note, that if user asks for prsResult/timestamp/hashResult and Debug, we give them (4) */
comment|/* This 'if' covers options  2& 4. We copy from beginning of context with or without debug. */
comment|/* If passAllOtherPCDInfo explicitly requested, or passDebugInfo+prs/ts --> we also take passAllOtherPCDInfo */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passAllOtherPCDInfo
operator|)
ifdef|#
directive|ifdef
name|DEBUG
operator|||
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passDebugInfo
operator|&&
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
operator|||
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
operator|||
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passHashResult
operator|)
operator|)
endif|#
directive|endif
comment|/* DEBUG */
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passDebugInfo
condition|)
block|{
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|size
operator|=
literal|240
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|debugOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
literal|128
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEBUG */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|size
operator|=
literal|128
expr_stmt|;
comment|/* must be aligned to 16 */
comment|/* Start copying data after 16 bytes (FD) from the beginning of the internal context */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|intContextOffset
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passAllOtherPCDInfo
condition|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|pcdInfoOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
condition|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
condition|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
literal|48
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passHashResult
condition|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
literal|56
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passDebugInfo
condition|)
block|{
comment|/* This case covers option 3 */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|size
operator|=
literal|112
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|intContextOffset
operator|=
literal|144
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|debugOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* DEBUG */
block|{
comment|/* This case covers the options under 1 */
comment|/* Copy size must be in 16-byte granularity. */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
condition|?
literal|32
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
operator|||
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passHashResult
operator|)
condition|?
literal|16
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Align start of internal context data to 16 byte */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|intContextOffset
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
condition|?
literal|32
else|:
operator|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
operator|||
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passHashResult
operator|)
condition|?
literal|64
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
condition|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
condition|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
condition|?
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
sizeof|sizeof
argument_list|(
name|t_FmPrsResult
argument_list|)
operator|)
else|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passHashResult
condition|)
comment|/* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
condition|?
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
sizeof|sizeof
argument_list|(
name|t_FmPrsResult
argument_list|)
operator|+
literal|8
operator|)
else|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
literal|8
expr_stmt|;
block|}
block|}
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|startMargins
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|extBufOffset
operator|+
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
operator|.
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
comment|/* save extra space for manip in both external and internal buffers */
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|manipExtraSpace
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|manipExtraSpace
operator|+
name|FRAG_EXTRA_SPACE
operator|)
operator|>=
literal|256
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + 32 can not be equal or larger to 256"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|manipOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|startMargins
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|startMargins
operator|+=
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|manipExtraSpace
operator|+
name|FRAG_EXTRA_SPACE
operator|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|internalBufferOffset
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|manipExtraSpace
operator|+
name|FRAG_EXTRA_SPACE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
comment|/* align data start */
name|tmp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|startMargins
operator|%
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|startMargins
operator|+=
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|-
name|tmp
operator|)
expr_stmt|;
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|startMargins
expr_stmt|;
name|p_FmPort
operator|->
name|internalBufferOffset
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|internalBufferOffset
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetPcd
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortPcdParams
modifier|*
name|p_PcdParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsNia
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsStartOffset
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiInitPrsResult
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCcBase
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|hdrNum
decl_stmt|,
name|L3HdrNum
decl_stmt|,
name|greHdrNum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|isEmptyClsPlanGrp
decl_stmt|;
name|uint32_t
name|tmpHxs
index|[
name|FM_PCD_PRS_NUM_OF_HDRS
index|]
decl_stmt|;
name|uint16_t
name|absoluteProfileId
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|uint32_t
name|ccTreePhysOffset
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|netEnvId
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PcdParams
operator|->
name|h_NetEnv
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator|=
literal|0
expr_stmt|;
comment|/* initialize p_FmPort->pcdEngines field in port's structure */
switch|switch
condition|(
name|p_PcdParams
operator|->
name|pcdSupport
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_NONE
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_ONLY
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PLCR_ONLY
operator|)
case|:
if|if
condition|(
name|CHECK_FM_CTL_AC_POST_FETCH_PCD
argument_list|(
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"parser support is required"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_CC_ONLY
operator|)
case|:
if|if
condition|(
name|CHECK_FM_CTL_AC_POST_FETCH_PCD
argument_list|(
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"parser support is required"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG
operator|)
case|:
if|if
condition|(
name|CHECK_FM_CTL_AC_POST_FETCH_PCD
argument_list|(
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"parser support is required"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR
operator|)
case|:
if|if
condition|(
name|CHECK_FM_CTL_AC_POST_FETCH_PCD
argument_list|(
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"parser support is required"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid pcdSupport"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
operator|>
name|FM_PCD_PRS_NUM_OF_HDRS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Port parser numOfHdrsWithAdditionalParams may not exceed %d"
operator|,
name|FM_PCD_PRS_NUM_OF_HDRS
operator|)
argument_list|)
expr_stmt|;
comment|/* check that parameters exist for each and only each defined engine */
if|if
condition|(
operator|(
operator|!
operator|!
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|!=
operator|!
operator|!
name|p_PcdParams
operator|->
name|p_PrsParams
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
operator|)
operator|!=
operator|!
operator|!
name|p_PcdParams
operator|->
name|p_KgParams
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
operator|)
operator|!=
operator|!
operator|!
name|p_PcdParams
operator|->
name|p_CcParams
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"PCD initialization structure is not consistant with pcdSupport"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
name|p_BmiPrsNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfpne
expr_stmt|;
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rpso
expr_stmt|;
name|p_BmiInitPrsResult
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rprai
index|[
literal|0
index|]
expr_stmt|;
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rccb
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
name|p_BmiPrsNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofpne
expr_stmt|;
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_opso
expr_stmt|;
name|p_BmiInitPrsResult
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_oprai
index|[
literal|0
index|]
expr_stmt|;
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_occb
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
condition|)
block|{
if|if
condition|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For ports using Keygen, at lease one scheme must be bound. "
operator|)
argument_list|)
expr_stmt|;
comment|/* for each scheme */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|physicalSchemeId
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* build vector */
name|p_FmPort
operator|->
name|schemesPerPortVector
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|physicalSchemeId
operator|)
expr_stmt|;
block|}
name|err
operator|=
name|FmPcdKgSetOrBindToClsPlanGrp
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
name|p_FmPort
operator|->
name|optArray
argument_list|,
operator|&
name|p_FmPort
operator|->
name|clsPlanGrpId
argument_list|,
operator|&
name|isEmptyClsPlanGrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"FmPcdKgSetOrBindToClsPlanGrp failed. "
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|useClsPlan
operator|=
operator|!
name|isEmptyClsPlanGrp
expr_stmt|;
block|}
comment|/* set PCD port parameter */
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
condition|)
block|{
name|err
operator|=
name|FmPcdCcBindTree
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_PcdParams
operator|->
name|p_CcParams
operator|->
name|h_CcTree
argument_list|,
operator|&
name|ccTreePhysOffset
argument_list|,
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCcBase
argument_list|,
name|ccTreePhysOffset
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|ccTreeId
operator|=
name|p_PcdParams
operator|->
name|p_CcParams
operator|->
name|h_CcTree
expr_stmt|;
block|}
comment|/***************************/
comment|/* configure NIA after BMI */
comment|/***************************/
if|if
condition|(
operator|!
name|CHECK_FM_CTL_AC_POST_FETCH_PCD
argument_list|(
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
condition|)
comment|/* rfne may contain FDCS bits, so first we read them. */
name|p_FmPort
operator|->
name|savedBmiNia
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
expr_stmt|;
comment|/* If policer is used directly after BMI or PRS */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PLCR
operator|)
operator|&&
operator|(
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PLCR_ONLY
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
operator|)
operator|)
condition|)
block|{
name|absoluteProfileId
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PcdParams
operator|->
name|p_PlcrParams
operator|->
name|h_Profile
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Private port profile not valid."
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|absoluteProfileId
operator||
name|NIA_PLCR_ABSOLUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
comment|/* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
block|{
comment|/* update BMI HPNIA */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PLCR
operator||
name|tmpReg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* e_FM_PCD_SUPPORT_PLCR_ONLY */
comment|/* update BMI NIA */
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PLCR
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
comment|/* if CC is used directly after BMI */
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_CC_ONLY
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR
operator|)
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_CC
argument_list|)
expr_stmt|;
comment|/* check that prs start offset == RIM[FOF] */
block|}
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_PcdParams
operator|->
name|p_PrsParams
argument_list|)
expr_stmt|;
comment|/* if PRS is used it is always first */
name|GET_PRS_HDR_NUM
argument_list|(
name|hdrNum
argument_list|,
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|firstPrsHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Unsupported header."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHECK_FM_CTL_AC_POST_FETCH_PCD
argument_list|(
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
condition|)
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PRS
operator||
call|(
name|uint32_t
call|)
argument_list|(
name|hdrNum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set after parser NIA */
name|tmpReg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p_PcdParams
operator|->
name|pcdSupport
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_ONLY
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
operator|)
case|:
name|tmpReg
operator|=
name|NIA_KG_CC_EN
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR
operator|)
case|:
if|if
condition|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|directScheme
condition|)
block|{
name|physicalSchemeId
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_DirectScheme
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* check that this scheme was bound to this port */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_DirectScheme
operator|==
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Direct scheme is not one of the port selected schemes."
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_KG_DIRECT
operator||
name|physicalSchemeId
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
name|NIA_ENG_KG
operator||
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
operator|)
case|:
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid PCD support"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set start parsing offset */
comment|/* WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset); */
comment|/************************************/
comment|/* Parser port parameters           */
comment|/************************************/
comment|/* stop before configuring */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|,
name|PRS_CAC_STOP
argument_list|)
expr_stmt|;
comment|/* wait for parser to be in idle state */
while|while
condition|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|)
operator|&
name|PRS_CAC_ACTIVE
condition|)
empty_stmt|;
comment|/* set soft seq attachment register */
name|memset
argument_list|(
name|tmpHxs
argument_list|,
literal|0
argument_list|,
name|FM_PCD_PRS_NUM_OF_HDRS
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set protocol options */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p_FmPort
operator|->
name|optArray
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|p_FmPort
operator|->
name|optArray
index|[
name|i
index|]
condition|)
block|{
case|case
operator|(
name|ETH_BROADCAST
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_ETH
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_ETH_BC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|ETH_MULTICAST
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_ETH
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_ETH_MC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|VLAN_STACKED
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_VLAN
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_VLAN_STACKED_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|MPLS_STACKED
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_MPLS
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_MPLS_STACKED_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_BROADCAST_1
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv4
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_1_BC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_MULTICAST_1
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv4
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_1_MC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_UNICAST_2
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv4
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_2_UC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_MULTICAST_BROADCAST_2
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv4
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_2_MC_BC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_MULTICAST_1
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv6
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV6_1_MC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_UNICAST_2
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv6
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV6_2_UC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_MULTICAST_2
operator|)
case|:
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPv6
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV6_2_MC_SHIFT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|FmPcdNetEnvIsHdrExist
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
condition|)
block|{
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
index|]
operator|.
name|swPrsEnable
operator|=
name|TRUE
expr_stmt|;
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
operator|++
expr_stmt|;
block|}
comment|/* set MPLS default next header - HW reset workaround  */
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_MPLS
argument_list|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
name|PRS_HDR_MPLS_LBL_INTER_EN
expr_stmt|;
name|GET_PRS_HDR_NUM
argument_list|(
name|L3HdrNum
argument_list|,
name|HEADER_TYPE_USER_DEFINED_L3
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|uint32_t
operator|)
name|L3HdrNum
operator|<<
name|PRS_HDR_MPLS_NEXT_HDR_SHIFT
expr_stmt|;
comment|/* for GRE, disable errors */
name|GET_PRS_HDR_NUM
argument_list|(
name|greHdrNum
argument_list|,
name|HEADER_TYPE_GRE
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|greHdrNum
index|]
operator||=
name|PRS_HDR_ERROR_DIS
expr_stmt|;
comment|/* config additional params for specific headers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
condition|;
name|i
operator|++
control|)
block|{
name|GET_PRS_HDR_NUM
argument_list|(
name|hdrNum
argument_list|,
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|NO_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Private headers may not use additional parameters"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|AdditionalPrsParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
argument_list|,
operator|&
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
name|tmpReg
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FM_PRS_L4_SHELL_ERRATA_FMANb
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* link to sw parser code for L4 shells - only if no other code is applied. */
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_SCTP
argument_list|)
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|SCTP_SW_PATCH_START
operator|)
expr_stmt|;
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_DCCP
argument_list|)
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|DCCP_SW_PATCH_START
operator|)
expr_stmt|;
name|GET_PRS_HDR_NUM
argument_list|(
argument|hdrNum
argument_list|,
argument|HEADER_TYPE_IPSEC_AH
argument_list|)
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|IPSEC_SW_PATCH_START
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FM_PRS_L4_SHELL_ERRATA_FMANb */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_PRS_NUM_OF_HDRS
condition|;
name|i
operator|++
control|)
block|{
comment|/* For all header set LCV as taken from netEnv*/
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|hdrs
index|[
name|i
index|]
operator|.
name|lcv
argument_list|,
name|FmPcdGetLcv
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
operator|(
name|uint8_t
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set HXS register according to default+Additional params+protocol options */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|hdrs
index|[
name|i
index|]
operator|.
name|softSeqAttach
argument_list|,
name|tmpHxs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* set tpid. */
name|tmpReg
operator|=
name|PRS_TPID_DFLT
expr_stmt|;
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|setVlanTpid1
condition|)
block|{
name|tmpReg
operator|&=
name|PRS_TPID2_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|vlanTpid1
operator|<<
name|PRS_PCTPID_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|setVlanTpid2
condition|)
block|{
name|tmpReg
operator|&=
name|PRS_TPID1_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|vlanTpid2
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pctpid
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* enable parser */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|prsResultPrivateInfo
condition|)
name|p_FmPort
operator|->
name|privateInfo
operator|=
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|prsResultPrivateInfo
expr_stmt|;
block|}
comment|/* end parser */
else|else
name|p_FmPort
operator|->
name|privateInfo
operator|=
literal|0
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|)
operator|+
name|p_FmPort
operator|->
name|internalBufferOffset
argument_list|)
expr_stmt|;
comment|/* set initial parser result - used for all engines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_PRS_RESULT_NUM_OF_WORDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|i
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_BmiInitPrsResult
operator|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_FmPort
operator|->
name|privateInfo
operator|<<
name|BMI_PR_PORTID_SHIFT
operator|)
operator||
name|BMI_PRS_RESULT_HIGH
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|FM_PORT_PRS_RESULT_NUM_OF_WORDS
operator|/
literal|2
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_BmiInitPrsResult
operator|+
name|i
operator|)
argument_list|,
name|BMI_PRS_RESULT_HIGH
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_BmiInitPrsResult
operator|+
name|i
operator|)
argument_list|,
name|BMI_PRS_RESULT_LOW
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|DeletePcd
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|pcdEngines
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"called for non PCD port"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
operator|)
operator|!=
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"port has to be detached previousely"
operator|)
argument_list|)
expr_stmt|;
comment|/* "cut" PCD out of the port's flow - go to BMI */
comment|/* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia& BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator||
name|FM_PCD_PRS
condition|)
block|{
comment|/* stop parser */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|,
name|PRS_CAC_STOP
argument_list|)
expr_stmt|;
comment|/* wait for parser to be in idle state */
while|while
condition|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|)
operator|&
name|PRS_CAC_ACTIVE
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
condition|)
block|{
name|err
operator|=
name|FmPcdKgDeleteOrUnbindPortToClsPlanGrp
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|p_FmPort
operator|->
name|clsPlanGrpId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|useClsPlan
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
condition|)
block|{
comment|/* unbind - we need to get the treeId too */
name|err
operator|=
name|FmPcdCcUnbindTree
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|ccTreeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|pcdEngines
operator|=
literal|0
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/********************************************/
end_comment

begin_comment
comment|/*  Inter-module API                        */
end_comment

begin_comment
comment|/********************************************/
end_comment

begin_function
name|void
name|FmPortSetMacsecLcv
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCfgReg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|macsecEn
init|=
name|BMI_PORT_CFG_EN_MACSEC
decl_stmt|;
name|uint32_t
name|lcv
decl_stmt|,
name|walking1Mask
init|=
literal|0x80000000
decl_stmt|;
name|uint8_t
name|cnt
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"The routine is relevant for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rcfg
expr_stmt|;
comment|/* get LCV for MACSEC */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|h_FmPcd
operator|)
operator|&&
operator|(
operator|(
name|lcv
operator|=
name|FmPcdGetMacsecLcv
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|lcv
operator|&
name|walking1Mask
operator|)
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|walking1Mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|macsecEn
operator||=
operator|(
name|uint32_t
operator|)
name|cnt
operator|<<
name|BMI_PORT_CFG_MS_SEL_SHIFT
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator||
name|macsecEn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FmPortSetMacsecCmd
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|dfltSci
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCfgReg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"The routine is relevant for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tfca
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator|&
operator|~
name|BMI_CMD_ATTR_MACCMD_MASK
expr_stmt|;
name|tmpReg
operator||=
name|BMI_CMD_ATTR_MACCMD_SECURED
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|dfltSci
operator|<<
name|BMI_CMD_ATTR_MACCMD_SC_SHIFT
operator|)
operator|&
name|BMI_CMD_ATTR_MACCMD_SC_MASK
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|FmPortGetNetEnvId
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
operator|)
operator|->
name|netEnvId
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPortGetHardwarePortId
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
operator|)
operator|->
name|hardwarePortId
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPortGetPcdEngines
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
operator|)
operator|->
name|pcdEngines
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPortAttachPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
comment|/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree. pndn, pnen ... maybe were changed because of the Tree requirement*/
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
condition|)
if|if
condition|(
name|FmSetNumOfRiscsPerPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
literal|1
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* check that current NIA is BMI to BMI */
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
operator|~
name|BMI_RFNE_FDCS_MASK
operator|)
operator|!=
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"may be called only for ports in BMI-to-BMI state."
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNEN
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|p_FmPort
operator|->
name|savedQmiPnen
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNDN
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|,
name|p_FmPort
operator|->
name|savedNonRxQmiRegsPndn
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPortGetSetCcParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortGetSetCcParams
modifier|*
name|p_CcParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|tmpInt
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsStartOffset
init|=
name|NULL
decl_stmt|;
comment|/* this function called from Cc for pass and receive parameters port params between CC and PORT*/
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|!=
name|ILLEGAL_BASE
operator|)
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|prOffset
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|hardwarePortId
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|HW_PORT_ID
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
operator|!=
name|ILLEGAL_BASE
operator|)
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|dataOffset
operator|=
operator|(
name|uint16_t
operator|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|numOfTasks
operator|=
name|p_FmPort
operator|->
name|numOfTasks
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|NUM_OF_TASKS
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
condition|)
block|{
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|poolIndex
operator|<
name|p_FmPort
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|poolIdForManip
operator|=
name|p_FmPort
operator|->
name|extBufPools
operator|.
name|extBufPool
index|[
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|poolIndex
index|]
operator|.
name|id
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|BUFFER_POOL_ID_FOR_MANIP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNEN
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNEN
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedQmiPnen
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_PNEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNEN
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedQmiPnen
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"pnen was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNDN
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNDN
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedNonRxQmiRegsPndn
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_PNDN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNDN
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedNonRxQmiRegsPndn
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"pndn was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_PSO
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_PSO
operator|)
condition|)
block|{
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rpso
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_opso
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set start parsing offset */
name|tmpInt
operator|=
operator|(
name|int
operator|)
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|)
operator|+
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|psoSize
expr_stmt|;
if|if
condition|(
name|tmpInt
operator|>
literal|0
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpInt
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_PSO
expr_stmt|;
name|p_FmPort
operator|->
name|savedPrsStartOffset
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|psoSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_PSO
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedPrsStartOffset
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|psoSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"parser start offset was defoned previousley different"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/**********************************         End of inter-module routines ********************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PORT_Config
parameter_list|(
name|t_FmPortParams
modifier|*
name|p_FmPortParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
decl_stmt|;
name|uintptr_t
name|baseAddr
init|=
name|p_FmPortParams
operator|->
name|baseAddr
decl_stmt|;
comment|/* Allocate FM structure */
name|p_FmPort
operator|=
operator|(
name|t_FmPort
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPort
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Port driver structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPort
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPort
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the FM driver's parameters structure */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|=
operator|(
name|t_FmPortDriverParam
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPortDriverParam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Port driver parameters"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortDriverParam
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize FM port parameters which will be kept by the driver */
name|p_FmPort
operator|->
name|portType
operator|=
name|p_FmPortParams
operator|->
name|portType
expr_stmt|;
name|p_FmPort
operator|->
name|portId
operator|=
name|p_FmPortParams
operator|->
name|portId
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator|=
name|FM_PCD_NONE
expr_stmt|;
name|p_FmPort
operator|->
name|f_Exception
operator|=
name|p_FmPortParams
operator|->
name|f_Exception
expr_stmt|;
name|p_FmPort
operator|->
name|h_App
operator|=
name|p_FmPortParams
operator|->
name|h_App
expr_stmt|;
name|p_FmPort
operator|->
name|h_Fm
operator|=
name|p_FmPortParams
operator|->
name|h_Fm
expr_stmt|;
comment|/* calculate global portId number */
name|SW_PORT_ID_TO_HW_PORT_ID
argument_list|(
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPortParams
operator|->
name|portId
argument_list|)
expr_stmt|;
comment|/* Initialize FM port parameters for initialization phase only */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|baseAddr
operator|=
name|baseAddr
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|privDataSize
operator|=
name|DEFAULT_PORT_bufferPrefixContent_privDataSize
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
operator|=
name|DEFAULT_PORT_bufferPrefixContent_passPrsResult
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
operator|=
name|DEFAULT_PORT_bufferPrefixContent_passTimeStamp
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passAllOtherPCDInfo
operator|=
name|DEFAULT_PORT_bufferPrefixContent_passTimeStamp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passDebugInfo
operator|=
name|DEFAULT_PORT_bufferPrefixContent_debugInfo
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|=
name|DEFAULT_PORT_bufferPrefixContent_dataAlign
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaSwapData
operator|=
name|DEFAULT_PORT_dmaSwapData
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaIntContextCacheAttr
operator|=
name|DEFAULT_PORT_dmaIntContextCacheAttr
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaHeaderCacheAttr
operator|=
name|DEFAULT_PORT_dmaHeaderCacheAttr
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaScatterGatherCacheAttr
operator|=
name|DEFAULT_PORT_dmaScatterGatherCacheAttr
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaWriteOptimize
operator|=
name|DEFAULT_PORT_dmaWriteOptimize
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|liodnBase
operator|=
name|p_FmPortParams
operator|->
name|liodnBase
expr_stmt|;
comment|/* resource distribution. */
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|DEFAULT_PORT_sizeOfFifo
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
operator|=
name|DEFAULT_PORT_extraSizeOfFifo
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|=
name|DEFAULT_PORT_numOfOpenDmas
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|=
name|DEFAULT_PORT_extraNumOfOpenDmas
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|=
name|DEFAULT_PORT_numOfTasks
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
operator|=
name|DEFAULT_PORT_extraNumOfTasks
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|numOfTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|color
operator|=
name|DEFAULT_PORT_color
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|color
operator|=
name|e_FM_PORT_COLOR_OVERRIDE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21 */
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|syncReq
operator|=
name|DEFAULT_PORT_syncReqForHc
expr_stmt|;
else|else
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|syncReq
operator|=
name|DEFAULT_PORT_syncReq
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PORT_SYNC_ERRATA_FMAN6
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|syncReq
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_SYNC_ERRATA_FMAN6 */
comment|/* Port type specific initialization: */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|frmDiscardOverride
operator|=
name|DEFAULT_PORT_frmDiscardOverride
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
comment|/* Initialize FM port parameters for initialization phase only */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cutBytesFromEnd
operator|=
name|DEFAULT_PORT_cutBytesFromEnd
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|enBufPoolDepletion
operator|=
name|FALSE
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|frmDiscardOverride
operator|=
name|DEFAULT_PORT_frmDiscardOverride
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|rxFifoPriElevationLevel
operator|=
name|DEFAULT_PORT_rxFifoPriElevationLevel
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|rxFifoThreshold
operator|=
name|DEFAULT_PORT_rxFifoThreshold
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|endMargins
operator|=
name|DEFAULT_PORT_BufMargins_endMargins
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator|=
name|DEFAULT_PORT_errorsToDiscard
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cheksumLastBytesIgnore
operator|=
name|DEFAULT_PORT_cheksumLastBytesIgnore
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|forwardReuseIntContext
operator|=
name|DEFAULT_PORT_forwardIntContextReuse
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|=
name|DEFAULT_PORT_txFifoDeqPipelineDepth_1G
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dontReleaseBuf
operator|=
name|FALSE
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
condition|)
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|=
name|DEFAULT_PORT_txFifoDeqPipelineDepth_10G
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cheksumLastBytesIgnore
operator|=
name|DEFAULT_PORT_cheksumLastBytesIgnore
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|txFifoMinFillLevel
operator|=
name|DEFAULT_PORT_txFifoMinFillLevel
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|txFifoLowComfLevel
operator|=
name|DEFAULT_PORT_txFifoLowComfLevel
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqHighPriority
operator|=
name|DEFAULT_PORT_deqHighPriority
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqType
operator|=
name|DEFAULT_PORT_deqType
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_QMI_DEQ_OPTIONS_SUPPORT
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|=
name|DEFAULT_PORT_deqPrefetchOption
expr_stmt|;
endif|#
directive|endif
comment|/* FM_QMI_DEQ_OPTIONS_SUPPORT */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqByteCnt
operator|=
name|DEFAULT_PORT_deqByteCnt
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator|=
name|DEFAULT_PORT_errorsToDiscard
expr_stmt|;
break|break;
default|default:
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|FM_QMI_DEQ_OPTIONS_SUPPORT
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|=
name|DEFAULT_PORT_deqPrefetchOption_HC
expr_stmt|;
endif|#
directive|endif
comment|/* FM_QMI_DEQ_OPTIONS_SUPPORT */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|=
name|OH_PIPELINE_DEPTH
expr_stmt|;
name|p_FmPort
operator|->
name|imEn
operator|=
name|p_FmPortParams
operator|->
name|independentModeEnable
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|=
name|DEFAULT_PORT_txFifoDeqPipelineDepth_IM
expr_stmt|;
name|FmPortConfigIM
argument_list|(
name|p_FmPort
argument_list|,
name|p_FmPortParams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
comment|/* Initialize FM port parameters for initialization phase only */
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
argument_list|,
operator|&
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|extBufPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortExtPools
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|errFqid
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|dfltFqid
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|liodnOffset
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|liodnOffset
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
ifdef|#
directive|ifdef
name|FM_OP_PARTITION_ERRATA_FMANx8
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|liodnOffset
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|opLiodnOffset
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_OP_PARTITION_ERRATA_FMANx8 */
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|errFqid
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqSubPortal
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|qmChannel
operator|&
name|QMI_DEQ_CFG_SUBPORTAL_MASK
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|dfltFqid
expr_stmt|;
break|break;
default|default:
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|memset
argument_list|(
name|p_FmPort
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPort
operator|->
name|name
argument_list|,
literal|"FM-%d-port-%s-%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
argument_list|,
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
operator|)
condition|?
literal|"OH"
else|:
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
condition|?
literal|"1g-RX"
else|:
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
condition|?
literal|"1g-TX"
else|:
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
condition|?
literal|"10g-RX"
else|:
literal|"10g-TX"
operator|)
operator|)
operator|)
operator|)
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPort
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|h_Spinlock
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_FmPort
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/**  @Function      FM_PORT_Init   @Description   Initializes the FM module   @Param[in]     h_FmPort - FM module descriptor   @Return        E_OK on success; Error code otherwise. */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_Init
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPortDriverParam
modifier|*
name|p_Params
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmInterModulePortInitParams
name|fmParams
decl_stmt|;
name|uint32_t
name|minFifoSizeRequired
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|BuildBufferStructure
argument_list|(
name|p_FmPort
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|CHECK_INIT_PARAMETERS
argument_list|(
name|p_FmPort
argument_list|,
name|CheckInitParameters
argument_list|)
expr_stmt|;
name|p_Params
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
expr_stmt|;
comment|/* set memory map pointers */
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|=
operator|(
name|t_FmPortQmiRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_Params
operator|->
name|baseAddr
operator|+
name|QMI_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|=
operator|(
name|u_FmPortBmiRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_Params
operator|->
name|baseAddr
operator|+
name|BMI_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|=
operator|(
name|t_FmPortPrsRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_Params
operator|->
name|baseAddr
operator|+
name|PRS_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
comment|/* For O/H ports, check fifo size and update if necessary */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
block|{
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|+
literal|4
operator|)
operator|*
name|BMI_FIFO_UNITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|<
name|minFifoSizeRequired
condition|)
block|{
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|minFifoSizeRequired
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"FIFO size enlarged to %d due to txFifoDeqPipelineDepth size"
operator|,
name|minFifoSizeRequired
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For Rx Ports, call the external Buffer routine which also checks fifo        size and updates it if necessary */
if|if
condition|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|)
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
comment|/* define external buffer pools and pool depletion*/
name|err
operator|=
name|SetExtBufferPools
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/************************************************************/
comment|/* Call FM module routine for communicating parameters      */
comment|/************************************************************/
name|memset
argument_list|(
operator|&
name|fmParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fmParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmParams
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|fmParams
operator|.
name|portType
operator|=
operator|(
name|e_FmPortType
operator|)
name|p_FmPort
operator|->
name|portType
expr_stmt|;
name|fmParams
operator|.
name|numOfTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
name|fmParams
operator|.
name|numOfExtraTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
expr_stmt|;
name|fmParams
operator|.
name|numOfOpenDmas
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|fmParams
operator|.
name|numOfExtraOpenDmas
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
expr_stmt|;
name|fmParams
operator|.
name|sizeOfFifo
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
name|fmParams
operator|.
name|extraSizeOfFifo
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
expr_stmt|;
name|fmParams
operator|.
name|independentMode
operator|=
name|p_FmPort
operator|->
name|imEn
expr_stmt|;
name|fmParams
operator|.
name|liodnOffset
operator|=
name|p_Params
operator|->
name|liodnOffset
expr_stmt|;
name|fmParams
operator|.
name|liodnBase
operator|=
name|p_Params
operator|->
name|liodnBase
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|fmParams
operator|.
name|deqPipelineDepth
operator|=
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|FmGetSetPortParams
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|fmParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|=
name|fmParams
operator|.
name|numOfTasks
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
operator|=
name|fmParams
operator|.
name|numOfExtraTasks
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|=
name|fmParams
operator|.
name|numOfOpenDmas
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|=
name|fmParams
operator|.
name|numOfExtraOpenDmas
expr_stmt|;
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|fmParams
operator|.
name|sizeOfFifo
expr_stmt|;
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
operator|=
name|fmParams
operator|.
name|extraSizeOfFifo
expr_stmt|;
comment|/* get params for use in init */
name|p_Params
operator|->
name|fmMuramPhysBaseAddr
operator|=
call|(
name|uint64_t
call|)
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|fmParams
operator|.
name|fmMuramPhysBaseAddr
operator|.
name|low
argument_list|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|fmParams
operator|.
name|fmMuramPhysBaseAddr
operator|.
name|high
argument_list|)
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
comment|/**********************/
comment|/* Init BMI Registers */
comment|/**********************/
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|err
operator|=
name|BmiRxPortInit
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|err
operator|=
name|BmiTxPortInit
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|err
operator|=
name|BmiOhPortInit
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/**********************/
comment|/* Init QMI Registers */
comment|/**********************/
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
operator|&&
operator|(
operator|(
name|err
operator|=
name|QmiInit
argument_list|(
name|p_FmPort
argument_list|)
operator|)
operator|!=
name|E_OK
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
operator|&&
operator|(
operator|(
name|err
operator|=
name|FmPortImInit
argument_list|(
name|p_FmPort
argument_list|)
operator|)
operator|!=
name|E_OK
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|FmPortDriverParamFree
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/**  @Function      FM_PORT_Free   @Description   Frees all resources that were assigned to FM module.                  Calling this routine invalidates the descriptor.   @Param[in]     h_FmPort - FM module descriptor   @Return        E_OK on success; Error code otherwise. */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_Free
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmInterModulePortFreeParams
name|fmParams
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|enabled
condition|)
block|{
if|if
condition|(
name|FM_PORT_Disable
argument_list|(
name|p_FmPort
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"FM_PORT_Disable FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FmPortDriverParamFree
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|FmPortImFree
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|fmParams
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|fmParams
operator|.
name|portType
operator|=
operator|(
name|e_FmPortType
operator|)
name|p_FmPort
operator|->
name|portType
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_QMI_DEQ_OPTIONS_SUPPORT
name|fmParams
operator|.
name|deqPipelineDepth
operator|=
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
expr_stmt|;
endif|#
directive|endif
comment|/* FM_QMI_DEQ_OPTIONS_SUPPORT */
name|FmFreePortParams
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|fmParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*************************************************/
end_comment

begin_comment
comment|/*       API Advanced Init unit functions        */
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_ConfigDeqHighPriority
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|highPri
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqHighPriority
operator|=
name|highPri
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDeqType
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDeqType
name|deqType
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqType
operator|=
name|deqType
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FM_QMI_DEQ_OPTIONS_SUPPORT
end_ifdef

begin_function
name|t_Error
name|FM_PORT_ConfigDeqPrefetchOption
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDeqPrefetchOption
name|deqPrefetchOption
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|=
name|deqPrefetchOption
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FM_QMI_DEQ_OPTIONS_SUPPORT */
end_comment

begin_function
name|t_Error
name|FM_PORT_ConfigBackupPools
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortBackupBmPools
modifier|*
name|p_BackupBmPools
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
ifdef|#
directive|ifdef
name|FM_NO_BACKUP_POOLS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
endif|#
directive|endif
comment|/* FM_NO_BACKUP_POOLS */
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_NO_BACKUP_POOLS
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PORT_ConfigBackupPools"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_NO_BACKUP_POOLS */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
operator|=
operator|(
name|t_FmPortBackupBmPools
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPortBackupBmPools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"p_BackupBmPools allocation failed"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
argument_list|,
name|p_BackupBmPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortBackupBmPools
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDeqByteCnt
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint16_t
name|deqByteCnt
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqByteCnt
operator|=
name|deqByteCnt
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigBufferPrefixContent
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortBufferPrefixContent
modifier|*
name|p_FmPortBufferPrefixContent
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
argument_list|,
name|p_FmPortBufferPrefixContent
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortBufferPrefixContent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if dataAlign was not initialized by user, we return to driver's deafult */
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|=
name|DEFAULT_PORT_bufferPrefixContent_dataAlign
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigCheksumLastBytesIgnore
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|cheksumLastBytesIgnore
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx& Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cheksumLastBytesIgnore
operator|=
name|cheksumLastBytesIgnore
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigCutBytesFromEnd
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|cutBytesFromEnd
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cutBytesFromEnd
operator|=
name|cutBytesFromEnd
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigPoolDepletion
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortBufPoolDepletion
modifier|*
name|p_BufPoolDepletion
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|enBufPoolDepletion
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufPoolDepletion
argument_list|,
name|p_BufPoolDepletion
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortBufPoolDepletion
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigObservedPoolDepletion
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortObservedBufPoolDepletion
modifier|*
name|p_FmPortObservedBufPoolDepletion
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for OP ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|enBufPoolDepletion
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufPoolDepletion
argument_list|,
operator|&
name|p_FmPortObservedBufPoolDepletion
operator|->
name|poolDepletionParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortBufPoolDepletion
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
argument_list|,
operator|&
name|p_FmPortObservedBufPoolDepletion
operator|->
name|poolsParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortExtPools
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigExtBufPools
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortExtPools
modifier|*
name|p_FmPortExtPools
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for OP ports only"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
argument_list|,
name|p_FmPortExtPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortExtPools
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigRxFifoThreshold
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|fifoThreshold
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|rxFifoThreshold
operator|=
name|fifoThreshold
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigRxFifoPriElevationLevel
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|priElevationLevel
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|rxFifoPriElevationLevel
operator|=
name|priElevationLevel
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigTxFifoMinFillLevel
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|minFillLevel
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|txFifoMinFillLevel
operator|=
name|minFillLevel
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigTxFifoDeqPipelineDepth
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|deqPipelineDepth
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for IM ports!"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|=
name|deqPipelineDepth
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigTxFifoLowComfLevel
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|fifoLowComfLevel
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|txFifoLowComfLevel
operator|=
name|fifoLowComfLevel
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDontReleaseTxBufToBM
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dontReleaseBuf
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDfltColor
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortColor
name|color
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PORT_ConfigDfltColor!"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21 */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|color
operator|=
name|color
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigSyncReq
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|syncReq
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PORT_SYNC_ERRATA_FMAN6
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"port-sync!"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_SYNC_ERRATA_FMAN6 */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|syncReq
operator|=
name|syncReq
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigFrmDiscardOverride
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|override
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|frmDiscardOverride
operator|=
name|override
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigErrorsToDiscard
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|fmPortFrameErrSelect_t
name|errs
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator|=
name|errs
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaSwapData
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDmaSwap
name|swapData
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaSwapData
operator|=
name|swapData
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaIcCacheAttr
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDmaCache
name|intContextCacheAttr
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaIntContextCacheAttr
operator|=
name|intContextCacheAttr
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaHdrAttr
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDmaCache
name|headerCacheAttr
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaHeaderCacheAttr
operator|=
name|headerCacheAttr
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaScatterGatherAttr
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDmaCache
name|scatterGatherCacheAttr
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaScatterGatherCacheAttr
operator|=
name|scatterGatherCacheAttr
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaWriteOptimize
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|optimize
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dmaWriteOptimize
operator|=
name|optimize
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigForwardReuseIntContext
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|forwardReuse
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|forwardReuseIntContext
operator|=
name|forwardReuse
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/*       PCD Advaced config API                     */
end_comment

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/*       API Run-time Control unit functions        */
end_comment

begin_comment
comment|/****************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_SetNumOfOpenDmas
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_NumOfOpenDmas
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_NumOfOpenDmas
operator|->
name|extra
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"excessive resources"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
if|if
condition|(
operator|(
operator|!
name|p_NumOfOpenDmas
operator|->
name|num
operator|)
operator|||
operator|(
name|p_NumOfOpenDmas
operator|->
name|num
operator|>
name|MAX_NUM_OF_DMAS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas-num can't be larger than %d"
operator|,
name|MAX_NUM_OF_DMAS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_NumOfOpenDmas
operator|->
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_DMAS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas-extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_DMAS
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmSetNumOfOpenDmas
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|(
name|uint8_t
operator|)
name|p_NumOfOpenDmas
operator|->
name|num
argument_list|,
operator|(
name|uint8_t
operator|)
name|p_NumOfOpenDmas
operator|->
name|extra
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|openDmas
argument_list|,
name|p_NumOfOpenDmas
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetNumOfTasks
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_NumOfTasks
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"not available for host command port where number is always 1"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_NumOfTasks
operator|->
name|extra
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"excessive resources"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
if|if
condition|(
operator|(
operator|!
name|p_NumOfTasks
operator|->
name|num
operator|)
operator|||
operator|(
name|p_NumOfTasks
operator|->
name|num
operator|>
name|MAX_NUM_OF_TASKS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"NumOfTasks-num can't be larger than %d"
operator|,
name|MAX_NUM_OF_TASKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_NumOfTasks
operator|->
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"NumOfTasks-extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_TASKS
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmSetNumOfTasks
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|(
name|uint8_t
operator|)
name|p_NumOfTasks
operator|->
name|num
argument_list|,
operator|(
name|uint8_t
operator|)
name|p_NumOfTasks
operator|->
name|extra
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* update driver's struct */
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|tasks
argument_list|,
name|p_NumOfTasks
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetSizeOfFifo
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_SizeOfFifo
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmInterModulePortRxPoolsParams
name|rxPoolsParams
decl_stmt|;
name|uint32_t
name|minFifoSizeRequired
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_SizeOfFifo
operator|->
name|extra
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"excessive resources"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
if|if
condition|(
operator|!
name|p_SizeOfFifo
operator|->
name|num
operator|||
operator|(
name|p_SizeOfFifo
operator|->
name|num
operator|>
name|BMI_MAX_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"SizeOfFifo-num has to be in the range of 256 - %d"
operator|,
name|BMI_MAX_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SizeOfFifo
operator|->
name|num
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"SizeOfFifo-num has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* extra FIFO size (allowed only to Rx ports) */
if|if
condition|(
name|p_SizeOfFifo
operator|->
name|extra
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"SizeOfFifo-extra has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_SizeOfFifo
operator|->
name|extra
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" No SizeOfFifo-extra for non Rx ports"
operator|)
argument_list|)
expr_stmt|;
comment|/* For O/H ports, check fifo size and update if necessary */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
block|{
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
operator|+
literal|4
operator|)
operator|*
name|BMI_FIFO_UNITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|<
name|minFifoSizeRequired
condition|)
block|{
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|minFifoSizeRequired
expr_stmt|;
name|DBG
argument_list|(
name|INFO
argument_list|,
operator|(
literal|"FIFO size enlarged to %d"
operator|,
name|minFifoSizeRequired
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
operator|&
name|rxPoolsParams
argument_list|,
operator|&
name|p_FmPort
operator|->
name|rxPoolsParams
argument_list|,
sizeof|sizeof
argument_list|(
name|rxPoolsParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmSetSizeOfFifo
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPort
operator|->
name|imEn
argument_list|,
operator|&
name|p_SizeOfFifo
operator|->
name|num
argument_list|,
name|p_SizeOfFifo
operator|->
name|extra
argument_list|,
name|p_FmPort
operator|->
name|txFifoDeqPipelineDepth
argument_list|,
operator|&
name|rxPoolsParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* update driver's structure AFTER the FM routine, as it may change by the FM. */
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|fifoBufs
argument_list|,
name|p_SizeOfFifo
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PORT_GetBufferDataOffset
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|FM_PORT_GetBufferICInfo
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|pcdInfoOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|pcdInfoOffset
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|uint8_t
modifier|*
name|FM_PORT_GetBufferDebugInfo
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|debugOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|debugOffset
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
name|t_FmPrsResult
modifier|*
name|FM_PORT_GetBufferPrsResult
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|t_FmPrsResult
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|uint64_t
modifier|*
name|FM_PORT_GetBufferTimeStamp
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint64_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|FM_PORT_GetBufferHashResult
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_Disable
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCfgReg
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiStatusReg
init|=
name|NULL
decl_stmt|;
name|bool
name|rxPort
init|=
name|FALSE
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rcfg
expr_stmt|;
name|p_BmiStatusReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rst
expr_stmt|;
name|rxPort
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tcfg
expr_stmt|;
name|p_BmiStatusReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tst
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ocfg
expr_stmt|;
name|p_BmiStatusReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ost
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if port is already disabled */
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator|&
name|BMI_PORT_CFG_EN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|rxPort
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN
operator|)
condition|)
comment|/* port is disabled */
return|return
name|E_OK
return|;
else|else
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistency: Port's QMI is enabled but BMI disabled"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* port is disabled */
return|return
name|E_OK
return|;
block|}
comment|/* Disable QMI */
if|if
condition|(
operator|!
name|rxPort
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|,
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
operator|~
name|QMI_PORT_CFG_EN
argument_list|)
expr_stmt|;
comment|/* wait for QMI to finish Handling dequeue tnums */
name|tries
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pns
argument_list|)
operator|&
name|QMI_PORT_STATUS_DEQ_FD_BSY
operator|)
operator|&&
operator|--
name|tries
condition|)
name|XX_UDelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tries
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_BUSY
argument_list|,
operator|(
literal|"%s: can't disable!"
operator|,
name|p_FmPort
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Disable BMI */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator|&
operator|~
name|BMI_PORT_CFG_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|FmPortImDisable
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|tries
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiStatusReg
argument_list|)
operator|&
name|BMI_PORT_STATUS_BSY
operator|)
operator|&&
operator|--
name|tries
condition|)
name|XX_UDelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tries
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_BUSY
argument_list|,
operator|(
literal|"%s: can't disable!"
operator|,
name|p_FmPort
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_Enable
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCfgReg
init|=
name|NULL
decl_stmt|;
name|bool
name|rxPort
init|=
name|FALSE
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rcfg
expr_stmt|;
name|rxPort
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tcfg
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ocfg
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if port is already enabled */
if|if
condition|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator|&
name|BMI_PORT_CFG_EN
condition|)
block|{
if|if
condition|(
operator|!
name|rxPort
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN
condition|)
comment|/* port is enabled */
return|return
name|E_OK
return|;
else|else
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistency: Port's BMI is enabled but QMI disabled"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* port is enabled */
return|return
name|E_OK
return|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|FmPortImEnable
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
comment|/* Enable QMI */
if|if
condition|(
operator|!
name|rxPort
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|,
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator||
name|QMI_PORT_CFG_EN
argument_list|)
expr_stmt|;
comment|/* Enable BMI */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator||
name|BMI_PORT_CFG_EN
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetRateLimit
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRateLimit
modifier|*
name|p_RateLimit
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpRateLimit
decl_stmt|,
name|tmpRateLimitScale
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_RateLimitReg
decl_stmt|,
modifier|*
name|p_RateLimitScaleReg
decl_stmt|;
name|uint8_t
name|factor
decl_stmt|,
name|countUnitBit
decl_stmt|;
name|uint16_t
name|baseGran
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx and Offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_RateLimitReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_trlmt
expr_stmt|;
name|p_RateLimitScaleReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_trlmts
expr_stmt|;
name|baseGran
operator|=
literal|16000
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_RateLimitReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_orlmt
expr_stmt|;
name|p_RateLimitScaleReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_orlmts
expr_stmt|;
name|baseGran
operator|=
literal|10000
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|countUnitBit
operator|=
operator|(
name|uint8_t
operator|)
name|FmGetTimeStampScale
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
comment|/* TimeStamp per nano seconds units */
comment|/* normally, we use 1 usec as the reference count */
name|factor
operator|=
literal|1
expr_stmt|;
comment|/* if ratelimit is too small for a 1usec factor, multiply the factor */
while|while
condition|(
name|p_RateLimit
operator|->
name|rateLimit
operator|<
name|baseGran
operator|/
name|factor
condition|)
block|{
if|if
condition|(
name|countUnitBit
operator|==
literal|31
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Rate limit is too small"
operator|)
argument_list|)
expr_stmt|;
name|countUnitBit
operator|++
expr_stmt|;
name|factor
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
if|if
condition|(
name|p_RateLimit
operator|->
name|rateLimit
operator|>
operator|(
operator|(
name|uint32_t
operator|)
name|baseGran
operator|*
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|*
operator|(
name|uint32_t
operator|)
name|factor
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Rate limit is too large"
operator|)
argument_list|)
expr_stmt|;
name|tmpRateLimit
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_RateLimit
operator|->
name|rateLimit
operator|*
name|factor
operator|/
name|baseGran
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_RateLimit
operator|->
name|maxBurstSize
operator|||
operator|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|>
name|MAX_BURST_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxBurstSize must be between 1K and %dk"
operator|,
name|MAX_BURST_SIZE
operator|)
argument_list|)
expr_stmt|;
name|tmpRateLimitScale
operator|=
operator|(
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|countUnitBit
operator|)
operator|<<
name|BMI_COUNT_RATE_UNIT_SHIFT
operator|)
operator||
name|BMI_RATE_LIMIT_EN
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|tmpRateLimit
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_MAX_BURST_SHIFT
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|FM_NO_ADVANCED_RATE_LIMITER
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
block|{
switch|switch
condition|(
name|p_RateLimit
operator|->
name|rateLimitDivider
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_DUAL_RATE_LIMITER_NONE
operator|)
case|:
break|break;
case|case
operator|(
name|e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2
operator|)
case|:
name|tmpRateLimitScale
operator||=
name|BMI_RATE_LIMIT_SCALE_BY_2
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4
operator|)
case|:
name|tmpRateLimitScale
operator||=
name|BMI_RATE_LIMIT_SCALE_BY_4
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8
operator|)
case|:
name|tmpRateLimitScale
operator||=
name|BMI_RATE_LIMIT_SCALE_BY_8
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|tmpRateLimit
operator||=
name|BMI_RATE_LIMIT_BURST_SIZE_GRAN
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ! FM_NO_ADVANCED_RATE_LIMITER */
block|{
if|if
condition|(
name|p_RateLimit
operator|->
name|rateLimitDivider
operator|!=
name|e_FM_PORT_DUAL_RATE_LIMITER_NONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PORT_ConfigDualRateLimitScaleDown"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|%
literal|1000
condition|)
block|{
name|p_RateLimit
operator|->
name|maxBurstSize
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|/
literal|1000
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"rateLimit.maxBurstSize rounded up to %d"
operator|,
operator|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|/
literal|1000
operator|+
literal|1
operator|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p_RateLimit
operator|->
name|maxBurstSize
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|tmpRateLimit
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_MAX_BURST_SHIFT
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_RateLimitScaleReg
argument_list|,
name|tmpRateLimitScale
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_RateLimitReg
argument_list|,
name|tmpRateLimit
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_DeleteRateLimit
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_RateLimitReg
decl_stmt|,
modifier|*
name|p_RateLimitScaleReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx and Offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_RateLimitReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_trlmt
expr_stmt|;
name|p_RateLimitScaleReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_trlmts
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_RateLimitReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_orlmt
expr_stmt|;
name|p_RateLimitScaleReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_orlmts
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_RateLimitScaleReg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_RateLimitReg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetFrameQueueCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|QMI_PORT_CFG_EN_COUNTERS
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|QMI_PORT_CFG_EN_COUNTERS
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPerformanceCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPcReg
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiPcReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rpc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_BmiPcReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tpc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_BmiPcReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_opc
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPcReg
argument_list|,
name|BMI_COUNTERS_EN
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPcReg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPerformanceCountersParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortPerformanceCnt
modifier|*
name|p_FmPortPerformanceCnt
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPcpReg
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiPcpReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rpcp
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_BmiPcpReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tpcp
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_BmiPcpReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_opcp
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check parameters */
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
operator|>
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.taskCompVal has to be in the range of 1 - %d (current value)!"
operator|,
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
operator|>
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.dmaCompVal has to be in the range of 1 - %d (current value)!"
operator|,
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|>
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.fifoCompVal has to be in the range of 256 - %d (current value)!"
operator|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.fifoCompVal has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|>
name|MAX_PERFORMANCE_RX_QUEUE_COMP
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d"
operator|,
name|MAX_PERFORMANCE_RX_QUEUE_COMP
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|>
name|MAX_PERFORMANCE_TX_QUEUE_COMP
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d"
operator|,
name|MAX_PERFORMANCE_TX_QUEUE_COMP
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
if|if
condition|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.queueCompVal is not relevant for H/O ports."
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_PORT_COMP_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_DMA_COMP_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|/
name|BMI_FIFO_UNITS
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_FIFO_COMP_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|tmpReg
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
operator|-
literal|1
argument_list|)
operator|<<
name|BMI_PERFORMANCE_TASK_COMP_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPcpReg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_AnalyzePerformanceParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPortPerformanceCnt
name|currParams
decl_stmt|,
name|savedParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|bool
name|underTest
decl_stmt|,
name|failed
init|=
name|FALSE
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|XX_Print
argument_list|(
literal|"Analyzing Performance parameters for port (type %d, id%d)\n"
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|)
expr_stmt|;
name|currParams
operator|.
name|taskCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|currParams
operator|.
name|queueCompVal
operator|=
literal|0
expr_stmt|;
else|else
name|currParams
operator|.
name|queueCompVal
operator|=
literal|1
expr_stmt|;
name|currParams
operator|.
name|dmaCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|currParams
operator|.
name|fifoCompVal
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ClearPerfCnts
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|currParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|XX_UDelay
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
condition|)
block|{
name|XX_Print
argument_list|(
literal|"Max num of defined port tasks (%d) utilized - Please enlarge\n"
argument_list|,
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
argument_list|)
expr_stmt|;
name|failed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
condition|)
block|{
name|XX_Print
argument_list|(
literal|"Max num of defined port openDmas (%d) utilized - Please enlarge\n"
argument_list|,
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
argument_list|)
expr_stmt|;
name|failed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
condition|)
block|{
name|XX_Print
argument_list|(
literal|"Max size of defined port fifo (%d) utilized - Please enlarge\n"
argument_list|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|*
name|BMI_FIFO_UNITS
argument_list|)
expr_stmt|;
name|failed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|savedParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|savedParams
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|underTest
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|currParams
operator|.
name|taskCompVal
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|savedParams
operator|.
name|taskCompVal
condition|)
block|{
name|currParams
operator|.
name|taskCompVal
operator|--
expr_stmt|;
name|underTest
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|currParams
operator|.
name|dmaCompVal
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|savedParams
operator|.
name|dmaCompVal
condition|)
block|{
name|currParams
operator|.
name|dmaCompVal
operator|--
expr_stmt|;
name|underTest
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|currParams
operator|.
name|fifoCompVal
operator|!=
name|BMI_FIFO_UNITS
operator|)
operator|&&
operator|!
name|savedParams
operator|.
name|fifoCompVal
condition|)
block|{
name|currParams
operator|.
name|fifoCompVal
operator|-=
name|BMI_FIFO_UNITS
expr_stmt|;
name|underTest
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|underTest
condition|)
break|break;
name|ClearPerfCnts
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|currParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|XX_UDelay
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savedParams
operator|.
name|taskCompVal
operator|&&
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
condition|)
name|savedParams
operator|.
name|taskCompVal
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|currParams
operator|.
name|taskCompVal
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savedParams
operator|.
name|dmaCompVal
operator|&&
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
condition|)
name|savedParams
operator|.
name|dmaCompVal
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|currParams
operator|.
name|dmaCompVal
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savedParams
operator|.
name|fifoCompVal
operator|&&
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
condition|)
name|savedParams
operator|.
name|fifoCompVal
operator|=
name|currParams
operator|.
name|fifoCompVal
operator|+
literal|2
expr_stmt|;
block|}
name|XX_Print
argument_list|(
literal|"best vals: tasks %d, dmas %d, fifos %d\n"
argument_list|,
name|savedParams
operator|.
name|taskCompVal
argument_list|,
name|savedParams
operator|.
name|dmaCompVal
argument_list|,
name|savedParams
operator|.
name|fifoCompVal
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetStatisticsCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiStcReg
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiStcReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rstc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_BmiStcReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tstc
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_BmiStcReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ostc
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiStcReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|BMI_COUNTERS_EN
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|BMI_COUNTERS_EN
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiStcReg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetErrorsRoute
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|fmPortFrameErrSelect_t
name|errs
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_ErrQReg
decl_stmt|,
modifier|*
name|p_ErrDiscard
decl_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_ErrQReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsem
expr_stmt|;
name|p_ErrDiscard
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsdm
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_ErrQReg
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsem
expr_stmt|;
name|p_ErrDiscard
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsdm
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_UINT32
argument_list|(
operator|*
name|p_ErrDiscard
argument_list|)
operator|&
name|errs
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Selectd Errors that were configured to cause frame discard."
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_ErrQReg
argument_list|,
name|errs
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetAllocBufCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|poolId
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|poolId
operator|<
name|BM_MAX_NUM_OF_POOLS
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
condition|;
name|i
operator|++
control|)
block|{
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|tmpReg
operator|&
name|BMI_EXT_BUF_POOL_ID_MASK
operator|)
operator|>>
name|BMI_EXT_BUF_POOL_ID_SHIFT
argument_list|)
operator|==
name|poolId
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|BMI_EXT_BUF_POOL_EN_COUNTER
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|BMI_EXT_BUF_POOL_EN_COUNTER
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
index|[
name|i
index|]
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"poolId %d is not included in this ports pools"
operator|,
name|poolId
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PORT_GetCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|bool
name|bmiCounter
init|=
name|FALSE
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_Reg
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
comment|/* check that counter is available for the port type */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bmiCounter
operator|=
name|FALSE
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|bmiCounter
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* BMI counters (or error - will be checked in BMI routine )*/
name|bmiCounter
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bmiCounter
condition|)
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
if|if
condition|(
name|BmiRxPortCheckAndGetCounterPtr
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|p_Reg
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
if|if
condition|(
name|BmiTxPortCheckAndGetCounterPtr
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|p_Reg
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
if|if
condition|(
name|BmiOhPortCheckAndGetCounterPtr
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|p_Reg
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported port type"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|GET_UINT32
argument_list|(
operator|*
name|p_Reg
argument_list|)
return|;
block|}
else|else
comment|/* QMI counter */
block|{
comment|/* check that counters are enabled */
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN_COUNTERS
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnetfc
argument_list|)
return|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndtfc
argument_list|)
return|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndfdc
argument_list|)
return|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndcc
argument_list|)
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ModifyCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|bool
name|bmiCounter
init|=
name|FALSE
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_Reg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
comment|/* check that counter is available for the port type */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|bmiCounter
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* BMI counters (or error - will be checked in BMI routine )*/
name|bmiCounter
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bmiCounter
condition|)
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
if|if
condition|(
name|BmiRxPortCheckAndGetCounterPtr
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|p_Reg
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
if|if
condition|(
name|BmiTxPortCheckAndGetCounterPtr
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|p_Reg
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
if|if
condition|(
name|BmiOhPortCheckAndGetCounterPtr
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|p_Reg
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported port type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_Reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* QMI counter */
block|{
comment|/* check that counters are enabled */
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN_COUNTERS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnetfc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndtfc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndfdc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndcc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PORT_GetAllocBufCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|poolId
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|extPoolReg
decl_stmt|;
name|uint8_t
name|tmpPool
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for non-Rx ports"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
condition|;
name|i
operator|++
control|)
block|{
name|extPoolReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|extPoolReg
operator|&
name|BMI_EXT_BUF_POOL_VALID
condition|)
block|{
name|tmpPool
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|extPoolReg
operator|&
name|BMI_EXT_BUF_POOL_ID_MASK
operator|)
operator|>>
name|BMI_EXT_BUF_POOL_ID_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpPool
operator|==
name|poolId
condition|)
block|{
if|if
condition|(
name|extPoolReg
operator|&
name|BMI_EXT_BUF_POOL_EN_COUNTER
condition|)
return|return
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_acnt
index|[
name|i
index|]
argument_list|)
return|;
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not enabled"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Pool %d is not used"
operator|,
name|poolId
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ModifyAllocBufCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|poolId
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|extPoolReg
decl_stmt|;
name|uint8_t
name|tmpPool
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for non-Rx ports"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
condition|;
name|i
operator|++
control|)
block|{
name|extPoolReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|extPoolReg
operator|&
name|BMI_EXT_BUF_POOL_VALID
condition|)
block|{
name|tmpPool
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|extPoolReg
operator|&
name|BMI_EXT_BUF_POOL_ID_MASK
operator|)
operator|>>
name|BMI_EXT_BUF_POOL_ID_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpPool
operator|==
name|poolId
condition|)
block|{
if|if
condition|(
name|extPoolReg
operator|&
name|BMI_EXT_BUF_POOL_EN_COUNTER
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_acnt
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not enabled"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Pool %d is not used"
operator|,
name|poolId
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|FM_PORT_IsStalled
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|bool
name|isStalled
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmIsPortStalled
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|&
name|isStalled
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|isStalled
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ReleaseStalled
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
return|return
name|FmResumeStalledPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetRxL4ChecksumVerify
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|l4Checksum
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
argument_list|)
expr_stmt|;
if|if
condition|(
name|l4Checksum
condition|)
name|tmpReg
operator|&=
operator|~
name|BMI_PORT_RFNE_FRWD_DCL4C
expr_stmt|;
else|else
name|tmpReg
operator||=
name|BMI_PORT_RFNE_FRWD_DCL4C
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*       API Run-time PCD Control unit functions        */
end_comment

begin_function
name|t_Error
name|FM_PORT_PcdPlcrAllocProfiles
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|p_FmPort
operator|->
name|h_FmPcd
operator|=
name|FmGetPcdHandle
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfProfiles
condition|)
block|{
name|err
operator|=
name|FmPcdPlcrAllocProfiles
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|numOfProfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|FmPcdPortRegister
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdPlcrFreeProfiles
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|err
operator|=
name|FmPcdPlcrFreeProfiles
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdKgModifyInitialScheme
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdKgSchemeSelect
modifier|*
name|p_FmPcdKgScheme
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiHpnia
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
operator|)
condition|?
name|NIA_KG_CC_EN
else|:
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfpne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofpne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
comment|/* if we want to change to direct scheme, we need to check that this scheme is valid */
if|if
condition|(
name|p_FmPcdKgScheme
operator|->
name|direct
condition|)
block|{
name|physicalSchemeId
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_FmPcdKgScheme
operator|->
name|h_DirectScheme
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* check that this scheme is bound to this port */
if|if
condition|(
operator|!
operator|(
name|p_FmPort
operator|->
name|schemesPerPortVector
operator|&
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|physicalSchemeId
operator|)
argument_list|)
operator|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"called with a scheme that is not bound to this port"
operator|)
argument_list|)
expr_stmt|;
block|}
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|>=
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"called with invalid Scheme "
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|relativeSchemeId
argument_list|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"called with uninitialized Scheme "
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiHpnia
argument_list|,
name|NIA_ENG_KG
operator||
name|tmpReg
operator||
name|NIA_KG_DIRECT
operator||
operator|(
name|uint32_t
operator|)
name|physicalSchemeId
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* change to indirect scheme */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiHpnia
argument_list|,
name|NIA_ENG_KG
operator||
name|tmpReg
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdPlcrModifyInitialProfile
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_Profile
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiHpnia
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint16_t
name|absoluteProfileId
init|=
call|(
name|uint16_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|h_Profile
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PLCR
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* check relevancy of this routine  - only when policer is used     directly after BMI or Parser */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfpne
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofpne
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Invalid profile"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PLCR
operator||
name|NIA_PLCR_ABSOLUTE
operator||
name|absoluteProfileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
comment|/* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
block|{
comment|/* update BMI HPNIA */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiHpnia
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* e_FM_PCD_SUPPORT_PLCR_ONLY */
block|{
comment|/* rfne may contain FDCS bits, so first we read them. */
name|tmpReg
operator||=
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
operator|)
expr_stmt|;
comment|/* update BMI NIA */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdCcModifyTree
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_CcTree
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCcBase
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|ccTreePhysOffset
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check that current NIA is BMI to BMI */
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
operator|~
name|BMI_RFNE_FDCS_MASK
operator|)
operator|!=
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"may be called only for ports in BMI-to-BMI state."
operator|)
argument_list|)
expr_stmt|;
comment|/*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...          it has to be returned to the default state - initially*/
name|p_FmPort
operator|->
name|requiredAction
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
condition|)
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rccb
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_occb
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|err
operator|=
name|FmPcdCcBindTree
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|h_CcTree
argument_list|,
operator|&
name|ccTreePhysOffset
argument_list|,
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCcBase
argument_list|,
name|ccTreePhysOffset
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|ccTreeId
operator|=
name|h_CcTree
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Coarse CLassification not defined for this port."
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_AttachPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
comment|/* TODO - may add here checks for:         SP (or in sw: schemes)         CPP (or in sw clsPlan)         Parser enabled and configured(?)         Tree(?)         Profile - only if direct.         Scheme - only if direct     */
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|err
operator|=
name|FmPortAttachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_DetachPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
operator|(
name|p_FmPort
operator|->
name|savedBmiNia
operator|&
name|BMI_RFNE_FDCS_MASK
operator|)
operator||
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
argument_list|)
expr_stmt|;
comment|/*TODO - not atomic - it seems that port has to be disabled*/
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNEN
condition|)
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX_RELEASE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_RELEASE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Can not reach this stage"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNDN
condition|)
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_FETCH
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Can not reach this stage"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
condition|)
if|if
condition|(
name|FmSetNumOfRiscsPerPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
literal|2
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortPcdParams
modifier|*
name|p_PcdParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independent mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|p_FmPort
operator|->
name|h_FmPcd
operator|=
name|FmGetPcdHandle
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|err
operator|=
name|SetPcd
argument_list|(
name|h_FmPort
argument_list|,
name|p_PcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
condition|)
block|{
name|schemeBind
operator|.
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|schemeBind
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|schemeBind
operator|.
name|numOfSchemes
operator|=
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
expr_stmt|;
name|schemeBind
operator|.
name|useClsPlan
operator|=
name|p_FmPort
operator|->
name|useClsPlan
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schemeBind
operator|.
name|numOfSchemes
condition|;
name|i
operator|++
control|)
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgBindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|includeInPrsStatistics
operator|)
condition|)
name|FmPcdPrsIncludePortInStatistics
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FmPcdIncNetEnvOwners
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPortAttachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_DeletePCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|err
operator|=
name|FM_PORT_DetachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|FmPcdDecNetEnvOwners
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
comment|/* we do it anyway, instead of checking if included */
if|if
condition|(
name|FmIsMaster
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
condition|)
name|FmPcdPrsIncludePortInStatistics
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
condition|)
block|{
comment|/* unbind all schemes */
name|p_FmPort
operator|->
name|schemesPerPortVector
operator|=
name|GetPortSchemeBindParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgUnbindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|DeletePcd
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdKgBindSchemes
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdPortSchemesParams
modifier|*
name|p_PortScheme
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpScmVec
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|schemeBind
operator|.
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|schemeBind
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|schemeBind
operator|.
name|numOfSchemes
operator|=
name|p_PortScheme
operator|->
name|numOfSchemes
expr_stmt|;
name|schemeBind
operator|.
name|useClsPlan
operator|=
name|p_FmPort
operator|->
name|useClsPlan
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schemeBind
operator|.
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PortScheme
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* build vector */
name|tmpScmVec
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|err
operator|=
name|FmPcdKgBindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|E_OK
condition|)
name|p_FmPort
operator|->
name|schemesPerPortVector
operator||=
name|tmpScmVec
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdKgUnbindSchemes
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdPortSchemesParams
modifier|*
name|p_PortScheme
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpScmVec
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|schemeBind
operator|.
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|schemeBind
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|schemeBind
operator|.
name|numOfSchemes
operator|=
name|p_PortScheme
operator|->
name|numOfSchemes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schemeBind
operator|.
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|p_PortScheme
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* build vector */
name|tmpScmVec
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
name|err
operator|=
name|FmPcdKgUnbindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|E_OK
condition|)
name|p_FmPort
operator|->
name|schemesPerPortVector
operator|&=
operator|~
name|tmpScmVec
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdPrsModifyStartOffset
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdPrsStart
modifier|*
name|p_FmPcdPrsStart
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsStartOffset
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint8_t
name|hdrNum
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rpso
expr_stmt|;
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfne
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_opso
expr_stmt|;
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofne
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check that current NIA is BMI to BMI */
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
operator|~
name|BMI_RFNE_FDCS_MASK
operator|)
operator|!=
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"may be called only for ports in BMI-to-BMI state."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
comment|/* set the first header */
name|GET_PRS_HDR_NUM
argument_list|(
name|hdrNum
argument_list|,
name|p_FmPcdPrsStart
operator|->
name|firstPrsHdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
operator|)
operator|||
operator|(
name|hdrNum
operator|==
name|NO_HDR_NUM
operator|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Unsupported header."
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PRS
operator||
operator|(
name|uint32_t
operator|)
name|hdrNum
operator||
name|tmpReg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set start parsing offset */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPcdPrsStart
operator|->
name|parsingOffset
operator|+
name|p_FmPort
operator|->
name|internalBufferOffset
argument_list|)
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ERRORS
argument_list|)
operator|&&
operator|(
name|DEBUG_ERRORS
operator|>
literal|0
operator|)
operator|)
end_if

begin_function
name|t_Error
name|FM_PORT_DumpRegs
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|char
name|arr
index|[
literal|30
index|]
decl_stmt|;
name|uint8_t
name|flag
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|DECLARE_DUMP
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|strcpy
argument_list|(
name|arr
argument_list|,
literal|"PORT_TYPE_OFFLINE_PARSING"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|strcpy
argument_list|(
name|arr
argument_list|,
literal|"PORT_TYPE_HOST_COMMAND"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|strcpy
argument_list|(
name|arr
argument_list|,
literal|"PORT_TYPE_RX"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
name|strcpy
argument_list|(
name|arr
argument_list|,
literal|"PORT_TYPE_RX_10G"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|strcpy
argument_list|(
name|arr
argument_list|,
literal|"PORT_TYPE_TX"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
name|strcpy
argument_list|(
name|arr
argument_list|,
literal|"PORT_TYPE_TX_10G"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|ERROR_CODE
argument_list|(
name|E_INVALID_VALUE
argument_list|)
return|;
block|}
name|DUMP_TITLE
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
argument_list|,
operator|(
literal|"PortId for %s %d"
operator|,
name|arr
operator|,
name|p_FmPort
operator|->
name|portId
operator|)
argument_list|)
expr_stmt|;
name|DUMP_TITLE
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
argument_list|,
operator|(
literal|"Bmi Port Regs"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmDumpPortRegs
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
name|DUMP_SUBTITLE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ocfg
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ost
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_oda
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofdne
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofne
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofca
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofpne
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_opso
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_opp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_occb
argument_list|)
expr_stmt|;
name|DUMP_TITLE
argument_list|(
operator|&
operator|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_oprai
operator|)
argument_list|,
operator|(
literal|"fmbm_oprai"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
argument|FM_PORT_PRS_RESULT_NUM_OF_WORDS
argument_list|)
block|{
name|DUMP_MEMORY
argument_list|(
operator|&
operator|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_oprai
index|[
name|i
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_SUBTITLE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofqid
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_oefqid
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofsdm
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofsem
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofene
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_orlmts
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_orlmt
argument_list|)
expr_stmt|;
block|{
ifndef|#
directive|ifndef
name|FM_NO_OP_OBSERVED_POOLS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
endif|#
directive|endif
comment|/* !FM_NO_OP_OBSERVED_POOLS */
block|{
name|DUMP_TITLE
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_oebmpi
argument_list|,
operator|(
literal|"fmbm_oebmpi"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
argument|FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS
argument_list|)
block|{
name|DUMP_MEMORY
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_oebmpi
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ocgm
argument_list|)
expr_stmt|;
block|}
block|}
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ostc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofrc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofdc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofledc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofufdc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_offc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofwdc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofldec
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_opc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_opcp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_occn
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_otuc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_oduc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
argument_list|,
name|fmbm_ofuc
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|)
case|:
name|DUMP_SUBTITLE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rcfg
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rst
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rda
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_reth
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfed
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_ricp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rebm
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfne
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfca
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfpne
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rpso
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rpp
argument_list|)
expr_stmt|;
name|DUMP_TITLE
argument_list|(
operator|&
operator|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rprai
operator|)
argument_list|,
operator|(
literal|"fmbm_rprai"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
argument|FM_PORT_PRS_RESULT_NUM_OF_WORDS
argument_list|)
block|{
name|DUMP_MEMORY
argument_list|(
operator|&
operator|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rprai
index|[
name|i
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_SUBTITLE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfqid
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_refqid
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfsdm
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfsem
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfene
argument_list|)
expr_stmt|;
name|DUMP_TITLE
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
argument_list|,
operator|(
literal|"fmbm_ebmpi"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
argument|FM_PORT_MAX_NUM_OF_EXT_POOLS
argument_list|)
block|{
name|DUMP_MEMORY
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_ebmpi
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_TITLE
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_acnt
argument_list|,
operator|(
literal|"fmbm_acnt"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
argument|FM_PORT_MAX_NUM_OF_EXT_POOLS
argument_list|)
block|{
name|DUMP_MEMORY
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_acnt
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_TITLE
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_cgm
argument_list|,
operator|(
literal|"fmbm_cgm"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
argument|FM_PORT_NUM_OF_CONGESTION_GRPS/
literal|32
argument_list|)
block|{
name|DUMP_MEMORY
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_cgm
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_SUBTITLE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_mpd
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rstc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfrc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfbc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rlfc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rffc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfcd
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfldec
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rodc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rpc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rpcp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rccn
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rtuc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rrquc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rduc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rfuc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rpac
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
argument_list|,
name|fmbm_rdbg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|2
operator|)
case|:
name|DUMP_SUBTITLE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tcfg
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tst
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tda
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfed
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_ticp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfne
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfca
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tcfqid
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfeqid
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfene
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_trlmts
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_trlmt
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tstc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfrc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfdc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfledc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfufdc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tpc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tpcp
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tccn
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_ttuc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_ttcquc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tduc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
argument_list|,
name|fmbm_tfuc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid flag"
operator|)
argument_list|)
expr_stmt|;
block|}
name|DUMP_TITLE
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
operator|(
literal|"Qmi Port Regs"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
name|fmqm_pnc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
name|fmqm_pns
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
name|fmqm_pnts
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
name|fmqm_pnen
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
argument_list|,
name|fmqm_pnetfc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
literal|1
condition|)
block|{
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
argument_list|,
name|fmqm_pndn
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
argument_list|,
name|fmqm_pndc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
argument_list|,
name|fmqm_pndtfc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
argument_list|,
name|fmqm_pndfdc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
argument_list|,
name|fmqm_pndcc
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(DEBUG_ERRORS)&& ... */
end_comment

begin_function
name|t_Error
name|FM_PORT_AddCongestionGrps
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortCongestionGrps
modifier|*
name|p_CongestionGrps
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|bool
name|tmpArray
index|[
name|FM_PORT_NUM_OF_CONGESTION_GRPS
index|]
decl_stmt|,
name|opPort
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|mod
decl_stmt|;
name|uint32_t
name|tmpReg
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|FM_NO_OP_OBSERVED_CGS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* FM_NO_OP_OBSERVED_CGS */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx& OP ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
name|opPort
operator|=
call|(
name|bool
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
comment|/* to minimize memory access (groups may belong to the same regsiter, and may     be out of order), we first collect all information into a 256 booleans array,     representing each possible group. */
name|memset
argument_list|(
operator|&
name|tmpArray
argument_list|,
literal|0
argument_list|,
name|FM_PORT_NUM_OF_CONGESTION_GRPS
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CongestionGrps
operator|->
name|numOfCongestionGrpsToConsider
condition|;
name|i
operator|++
control|)
name|tmpArray
index|[
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_NUM_OF_CONGESTION_GRPS
condition|;
name|i
operator|++
control|)
block|{
name|mod
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|i
operator|%
literal|32
argument_list|)
expr_stmt|;
comment|/* each 32 congestion groups are represented by a register */
if|if
condition|(
name|mod
operator|==
literal|0
condition|)
comment|/* first in a 32 bunch of congestion groups, get the currest register state  */
name|tmpReg
operator|=
name|opPort
condition|?
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ocgm
argument_list|)
else|:
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_cgm
index|[
literal|7
operator|-
name|i
operator|/
literal|32
index|]
argument_list|)
expr_stmt|;
comment|/* set in the register, the bit representing the relevant congestion group. */
if|if
condition|(
name|tmpArray
index|[
name|i
index|]
condition|)
name|tmpReg
operator||=
operator|(
literal|0x00000001
operator|<<
operator|(
name|uint32_t
operator|)
name|mod
operator|)
expr_stmt|;
if|if
condition|(
name|mod
operator|==
literal|31
condition|)
comment|/* last in a 32 bunch of congestion groups - write the corresponding register */
block|{
if|if
condition|(
name|opPort
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ocgm
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_cgm
index|[
literal|7
operator|-
name|i
operator|/
literal|32
index|]
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_RemoveCongestionGrps
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortCongestionGrps
modifier|*
name|p_CongestionGrps
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|bool
name|tmpArray
index|[
name|FM_PORT_NUM_OF_CONGESTION_GRPS
index|]
decl_stmt|,
name|opPort
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|mod
decl_stmt|;
name|uint32_t
name|tmpReg
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|FM_NO_OP_OBSERVED_CGS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* FM_NO_OP_OBSERVED_CGS */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx& OP ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
name|opPort
operator|=
call|(
name|bool
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
comment|/* to minimize memory access (groups may belong to the same regsiter, and may     be out of order), we first collect all information into a 256 booleans array,     representing each possible group. */
name|memset
argument_list|(
operator|&
name|tmpArray
argument_list|,
literal|0
argument_list|,
name|FM_PORT_NUM_OF_CONGESTION_GRPS
operator|*
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CongestionGrps
operator|->
name|numOfCongestionGrpsToConsider
condition|;
name|i
operator|++
control|)
name|tmpArray
index|[
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_NUM_OF_CONGESTION_GRPS
condition|;
name|i
operator|++
control|)
block|{
name|mod
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|i
operator|%
literal|32
argument_list|)
expr_stmt|;
comment|/* each 32 congestion groups are represented by a register */
if|if
condition|(
name|mod
operator|==
literal|0
condition|)
comment|/* first in a 32 bunch of congestion groups, get the currest register state  */
name|tmpReg
operator|=
name|opPort
condition|?
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ocgm
argument_list|)
else|:
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_cgm
index|[
literal|7
operator|-
name|i
operator|/
literal|32
index|]
argument_list|)
expr_stmt|;
comment|/* set in the register, the bit representing the relevant congestion group. */
if|if
condition|(
name|tmpArray
index|[
name|i
index|]
condition|)
name|tmpReg
operator|&=
operator|~
operator|(
literal|0x00000001
operator|<<
operator|(
name|uint32_t
operator|)
name|mod
operator|)
expr_stmt|;
if|if
condition|(
name|mod
operator|==
literal|31
condition|)
comment|/* last in a 32 bunch of congestion groups - write the corresponding register */
block|{
if|if
condition|(
name|opPort
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ocgm
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_cgm
index|[
literal|7
operator|-
name|i
operator|/
literal|32
index|]
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

end_unit

