begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_port.c   @Description   FM driver routines implementation.  */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"sprint_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_muram_ext.h"
end_include

begin_include
include|#
directive|include
file|"fman_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_port.h"
end_include

begin_include
include|#
directive|include
file|"fm_port_dsar.h"
end_include

begin_include
include|#
directive|include
file|"common/general.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function_decl
specifier|static
name|t_Error
name|FmPortConfigAutoResForDeepSleepSupport1
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|t_Error
name|CheckInitParameters
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortDriverParam
modifier|*
name|p_Params
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
decl_stmt|;
name|struct
name|fman_port_cfg
modifier|*
name|p_DfltConfig
init|=
operator|&
name|p_Params
operator|->
name|dfltCfg
decl_stmt|;
name|t_Error
name|ans
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|unusedMask
decl_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
condition|)
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|>
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoDeqPipelineDepth for IM 10G can't be larger than 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ans
operator|=
name|FmPortImCheckInitParameters
argument_list|(
name|p_FmPort
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|ans
argument_list|)
return|;
block|}
else|else
block|{
comment|/****************************************/
comment|/*   Rx only                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* external buffer pools */
if|if
condition|(
operator|!
name|p_Params
operator|->
name|extBufPools
operator|.
name|numOfPoolsUsed
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmSpCheckBufPoolsParams
argument_list|(
operator|&
name|p_Params
operator|->
name|extBufPools
argument_list|,
name|p_Params
operator|->
name|p_BackupBmPools
argument_list|,
operator|&
name|p_Params
operator|->
name|bufPoolDepletion
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* Check that part of IC that needs copying is small enough to enter start margin */
if|if
condition|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|&&
operator|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|+
name|p_Params
operator|->
name|intContext
operator|.
name|extBufOffset
operator|>
name|p_Params
operator|->
name|bufMargins
operator|.
name|startMargins
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"intContext.size is larger than start margins"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Params
operator|->
name|liodnOffset
operator|!=
operator|(
name|uint16_t
operator|)
name|DPAA_LIODN_DONT_OVERRIDE
operator|)
operator|&&
operator|(
name|p_Params
operator|->
name|liodnOffset
operator|&
operator|~
name|FM_LIODN_OFFSET_MASK
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"liodnOffset is larger than %d"
operator|,
name|FM_LIODN_OFFSET_MASK
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_NO_BACKUP_POOLS
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
condition|)
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"BackupBmPools"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_NO_BACKUP_POOLS */
block|}
comment|/****************************************/
comment|/*   Non Rx ports                       */
comment|/****************************************/
else|else
block|{
if|if
condition|(
name|p_Params
operator|->
name|deqSubPortal
operator|>=
name|FM_MAX_NUM_OF_SUB_PORTALS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" deqSubPortal has to be in the range of 0 - %d"
operator|,
name|FM_MAX_NUM_OF_SUB_PORTALS
operator|)
argument_list|)
expr_stmt|;
comment|/* to protect HW internal-context from overwrite */
if|if
condition|(
operator|(
name|p_Params
operator|->
name|intContext
operator|.
name|size
operator|)
operator|&&
operator|(
name|p_Params
operator|->
name|intContext
operator|.
name|intContextOffset
operator|<
name|MIN_TX_INT_OFFSET
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"non-Rx intContext.intContextOffset can't be smaller than %d"
operator|,
name|MIN_TX_INT_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
comment|/* in O/H DEFAULT_notSupported indicates that it is not supported and should not be checked */
operator|||
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|!=
name|DEFAULT_notSupported
operator|)
condition|)
block|{
comment|/* Check that not larger than 8 */
if|if
condition|(
operator|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|>
name|MAX_FIFO_PIPELINE_DEPTH
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoDeqPipelineDepth can't be larger than %d"
operator|,
name|MAX_FIFO_PIPELINE_DEPTH
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/****************************************/
comment|/*   Rx Or Offline Parsing              */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_Params
operator|->
name|dfltFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"dfltFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
argument_list|)
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|manipExtraSpace
operator|%
literal|16
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufferPrefixContent.manipExtraSpace has to be devidable by 16"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(FM_CAPWAP_SUPPORT)&& ... */
block|}
comment|/****************************************/
comment|/*   All ports                          */
comment|/****************************************/
comment|/* common BMI registers values */
comment|/* Check that Queue Id is not larger than 2^24, and is not 0 */
if|if
condition|(
operator|(
name|p_Params
operator|->
name|errFqid
operator|&
operator|~
literal|0x00FFFFFF
operator|)
operator|||
operator|!
name|p_Params
operator|->
name|errFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"errFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|dfltFqid
operator|&
operator|~
literal|0x00FFFFFF
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"dfltFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Rx only                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
if|if
condition|(
name|p_DfltConfig
operator|->
name|rx_pri_elevation
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoPriElevationLevel has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_DfltConfig
operator|->
name|rx_pri_elevation
operator|<
name|BMI_FIFO_UNITS
operator|)
operator|||
operator|(
name|p_DfltConfig
operator|->
name|rx_pri_elevation
operator|>
name|MAX_PORT_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoPriElevationLevel has to be in the range of 256 - %d"
operator|,
name|MAX_PORT_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_DfltConfig
operator|->
name|rx_fifo_thr
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoThreshold has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_DfltConfig
operator|->
name|rx_fifo_thr
operator|<
name|BMI_FIFO_UNITS
operator|)
operator|||
operator|(
name|p_DfltConfig
operator|->
name|rx_fifo_thr
operator|>
name|MAX_PORT_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"rxFifoThreshold has to be in the range of 256 - %d"
operator|,
name|MAX_PORT_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* Check that not larger than 16 */
if|if
condition|(
name|p_DfltConfig
operator|->
name|rx_cut_end_bytes
operator|>
name|FRAME_END_DATA_SIZE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"cutBytesFromEnd can't be larger than %d"
operator|,
name|FRAME_END_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmSpCheckBufMargins
argument_list|(
operator|&
name|p_Params
operator|->
name|bufMargins
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* extra FIFO size (allowed only to Rx ports) */
if|if
condition|(
name|p_Params
operator|->
name|setSizeOfFifo
operator|&&
operator|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
operator|%
name|BMI_FIFO_UNITS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoBufs.extra has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|poolsGrpModeEnable
operator|&&
operator|!
name|p_Params
operator|->
name|bufPoolDepletion
operator|.
name|numOfPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufPoolDepletion.numOfPools can not be 0 when poolsGrpModeEnable=TRUE"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_CSI_CFED_LIMIT
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
block|{
comment|/* Check that not larger than 16 */
if|if
condition|(
name|p_DfltConfig
operator|->
name|rx_cut_end_bytes
operator|+
name|p_DfltConfig
operator|->
name|checksum_bytes_ignore
operator|>
name|FRAME_END_DATA_SIZE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d"
operator|,
name|FRAME_END_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_CSI_CFED_LIMIT */
block|}
comment|/****************************************/
comment|/*   Non Rx ports                       */
comment|/****************************************/
comment|/* extra FIFO size (allowed only to Rx ports) */
elseif|else
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" No fifoBufs.extra for non Rx ports"
operator|)
argument_list|)
expr_stmt|;
comment|/****************************************/
comment|/*   Tx only                            */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
block|{
if|if
condition|(
name|p_DfltConfig
operator|->
name|tx_fifo_min_level
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoMinFillLevel has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_DfltConfig
operator|->
name|tx_fifo_min_level
operator|>
operator|(
name|MAX_PORT_FIFO_SIZE
operator|-
literal|256
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoMinFillLevel has to be in the range of 0 - %d"
operator|,
operator|(
name|MAX_PORT_FIFO_SIZE
operator|-
literal|256
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_DfltConfig
operator|->
name|tx_fifo_low_comf_level
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoLowComfLevel has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_DfltConfig
operator|->
name|tx_fifo_low_comf_level
operator|<
name|BMI_FIFO_UNITS
operator|)
operator|||
operator|(
name|p_DfltConfig
operator|->
name|tx_fifo_low_comf_level
operator|>
name|MAX_PORT_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"txFifoLowComfLevel has to be in the range of 256 - %d"
operator|,
name|MAX_PORT_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
condition|)
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|>
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoDeqPipelineDepth for 1G can't be larger than 2"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Non Tx Ports                       */
comment|/****************************************/
comment|/* If discard override was selected , no frames may be discarded. */
elseif|else
if|if
condition|(
name|p_DfltConfig
operator|->
name|discard_override
operator|&&
name|p_Params
operator|->
name|errorsToDiscard
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."
operator|)
argument_list|)
expr_stmt|;
comment|/****************************************/
comment|/*   Rx and Offline parsing             */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|unusedMask
operator|=
name|BMI_STATUS_OP_MASK_UNUSED
expr_stmt|;
else|else
name|unusedMask
operator|=
name|BMI_STATUS_RX_MASK_UNUSED
expr_stmt|;
comment|/* Check that no common bits with BMI_STATUS_MASK_UNUSED */
if|if
condition|(
name|p_Params
operator|->
name|errorsToDiscard
operator|&
name|unusedMask
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"errorsToDiscard contains undefined bits"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/****************************************/
comment|/*   Offline Ports                      */
comment|/****************************************/
ifdef|#
directive|ifdef
name|FM_OP_OPEN_DMA_MIN_LIMIT
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|&&
name|p_Params
operator|->
name|setNumOfOpenDmas
operator|&&
operator|(
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|<
name|MIN_NUM_OF_OP_DMAS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For Offline port, openDmas.num can't be smaller than %d"
operator|,
name|MIN_NUM_OF_OP_DMAS
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_OP_OPEN_DMA_MIN_LIMIT */
comment|/****************************************/
comment|/*   Offline& HC Ports                 */
comment|/****************************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|FM_FRAME_END_PARAMS_FOR_OP
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cheksumLastBytesIgnore
operator|!=
name|DEFAULT_notSupported
operator|)
condition|)
comment|/* this is an indication that user called config for this mode which is not supported in this integration */
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"cheksumLastBytesIgnore is available for Rx& Tx ports only"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !FM_FRAME_END_PARAMS_FOR_OP */
ifndef|#
directive|ifndef
name|FM_DEQ_PIPELINE_PARAMS_FOR_OP
if|if
condition|(
operator|(
operator|!
operator|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
operator|)
operator|)
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|!=
name|DEFAULT_notSupported
operator|)
condition|)
comment|/* this is an indication that user called config for this mode which is not supported in this integration */
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"fifoDeqPipelineDepth is available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
block|}
comment|/****************************************/
comment|/*   All ports                          */
comment|/****************************************/
comment|/* Check that not larger than 16 */
if|if
condition|(
operator|(
name|p_Params
operator|->
name|cheksumLastBytesIgnore
operator|>
name|FRAME_END_DATA_SIZE
operator|)
operator|&&
operator|(
operator|(
name|p_Params
operator|->
name|cheksumLastBytesIgnore
operator|!=
name|DEFAULT_notSupported
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"cheksumLastBytesIgnore can't be larger than %d"
operator|,
name|FRAME_END_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmSpCheckIntContextParams
argument_list|(
operator|&
name|p_Params
operator|->
name|intContext
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* common BMI registers values */
if|if
condition|(
name|p_Params
operator|->
name|setNumOfTasks
operator|&&
operator|(
operator|(
operator|!
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|>
name|MAX_NUM_OF_TASKS
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"tasks.num can't be larger than %d"
operator|,
name|MAX_NUM_OF_TASKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|setNumOfTasks
operator|&&
operator|(
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_TASKS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"tasks.extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_TASKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|setNumOfOpenDmas
operator|&&
operator|(
operator|(
operator|!
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|>
name|MAX_NUM_OF_DMAS
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas.num can't be larger than %d"
operator|,
name|MAX_NUM_OF_DMAS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|setNumOfOpenDmas
operator|&&
operator|(
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_DMAS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas.extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_DMAS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|setSizeOfFifo
operator|&&
operator|(
operator|!
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|||
operator|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|>
name|MAX_PORT_FIFO_SIZE
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoBufs.num has to be in the range of 256 - %d"
operator|,
name|MAX_PORT_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Params
operator|->
name|setSizeOfFifo
operator|&&
operator|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|%
name|BMI_FIFO_UNITS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoBufs.num has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_QMI_NO_DEQ_OPTIONS_SUPPORT
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|!=
name|DEFAULT_notSupported
condition|)
comment|/* this is an indication that user called config for this mode which is not supported in this integration */
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"deqPrefetchOption"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|VerifySizeOfFifo
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|uint32_t
name|minFifoSizeRequired
init|=
literal|0
decl_stmt|,
name|optFifoSizeForB2B
init|=
literal|0
decl_stmt|;
comment|/*************************/
comment|/*    TX PORTS           */
comment|/*************************/
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
block|{
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ROUND_UP
argument_list|(
name|p_FmPort
operator|->
name|maxFrameLength
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
operator|+
operator|(
literal|3
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
name|minFifoSizeRequired
operator|+=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|optFifoSizeForB2B
operator|=
name|minFifoSizeRequired
expr_stmt|;
comment|/* Add some margin for back-to-back capability to improve performance,          allows the hardware to pipeline new frame dma while the previous          frame not yet transmitted. */
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
condition|)
name|optFifoSizeForB2B
operator|+=
literal|3
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
else|else
name|optFifoSizeForB2B
operator|+=
literal|2
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
block|}
comment|/*************************/
comment|/*    RX IM PORTS        */
comment|/*************************/
elseif|else
if|if
condition|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|)
operator|&&
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
name|optFifoSizeForB2B
operator|=
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ROUND_UP
argument_list|(
name|p_FmPort
operator|->
name|maxFrameLength
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
operator|+
operator|(
literal|4
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*************************/
comment|/*    RX non-IM PORTS    */
comment|/*************************/
elseif|else
if|if
condition|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|)
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|numOfPools
operator|==
literal|1
condition|)
name|minFifoSizeRequired
operator|=
literal|8
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
else|else
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ROUND_UP
argument_list|(
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|secondLargestBufSize
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
operator|+
operator|(
literal|7
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ROUND_UP
argument_list|(
name|p_FmPort
operator|->
name|maxFrameLength
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
operator|+
operator|(
literal|5
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
comment|/* 4 according to spec + 1 for FOF>0 */
else|#
directive|else
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ROUND_UP
argument_list|(
name|MIN
argument_list|(
name|p_FmPort
operator|->
name|maxFrameLength
argument_list|,
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
argument_list|)
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
operator|+
operator|(
literal|7
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
name|optFifoSizeForB2B
operator|=
name|minFifoSizeRequired
expr_stmt|;
comment|/* Add some margin for back-to-back capability to improve performance,                  allows the hardware to pipeline new frame dma while the previous                  frame not yet transmitted. */
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
condition|)
name|optFifoSizeForB2B
operator|+=
literal|8
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
else|else
name|optFifoSizeForB2B
operator|+=
literal|3
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
block|}
comment|/* For O/H ports, check fifo size and update if necessary */
elseif|else
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|optFifoSizeForB2B
operator|=
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ROUND_UP
argument_list|(
name|p_FmPort
operator|->
name|maxFrameLength
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
operator|+
operator|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|+
literal|5
operator|)
operator|*
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
comment|/* 4 according to spec + 1 for FOF>0 */
else|#
directive|else
name|optFifoSizeForB2B
operator|=
name|minFifoSizeRequired
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|+
literal|2
operator|)
operator|*
name|BMI_FIFO_UNITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
name|ASSERT_COND
argument_list|(
name|minFifoSizeRequired
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|optFifoSizeForB2B
operator|>=
name|minFifoSizeRequired
argument_list|)
expr_stmt|;
comment|/* Verify the size  */
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|<
name|minFifoSizeRequired
condition|)
name|DBG
argument_list|(
name|INFO
argument_list|,
operator|(
literal|"FIFO size is %d and should be enlarged to %d bytes"
operator|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|,
name|minFifoSizeRequired
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|<
name|optFifoSizeForB2B
condition|)
name|DBG
argument_list|(
name|INFO
argument_list|,
operator|(
literal|"For back-to-back frames processing, FIFO size is %d and needs to enlarge to %d bytes"
operator|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|,
name|optFifoSizeForB2B
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FmPortDriverParamFree
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetExtBufferPools
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmExtPools
modifier|*
name|p_ExtBufPools
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
decl_stmt|;
name|t_FmBufPoolDepletion
modifier|*
name|p_BufPoolDepletion
init|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufPoolDepletion
decl_stmt|;
name|uint8_t
name|orderedArray
index|[
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
index|]
decl_stmt|;
name|uint16_t
name|sizesArray
index|[
name|BM_MAX_NUM_OF_POOLS
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|fman_port_bpools
name|bpools
decl_stmt|;
name|memset
argument_list|(
operator|&
name|orderedArray
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|FM_PORT_MAX_NUM_OF_EXT_POOLS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sizesArray
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|BM_MAX_NUM_OF_POOLS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|extBufPools
argument_list|,
name|p_ExtBufPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmExtPools
argument_list|)
argument_list|)
expr_stmt|;
name|FmSpSetBufPoolsInAscOrderOfBufSizes
argument_list|(
name|p_ExtBufPools
argument_list|,
name|orderedArray
argument_list|,
name|sizesArray
argument_list|)
expr_stmt|;
comment|/* Prepare flibs bpools structure */
name|memset
argument_list|(
operator|&
name|bpools
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fman_port_bpools
argument_list|)
argument_list|)
expr_stmt|;
name|bpools
operator|.
name|count
operator|=
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
expr_stmt|;
name|bpools
operator|.
name|counters_enable
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|i
operator|++
control|)
block|{
name|bpools
operator|.
name|bpool
index|[
name|i
index|]
operator|.
name|bpid
operator|=
name|orderedArray
index|[
name|i
index|]
expr_stmt|;
name|bpools
operator|.
name|bpool
index|[
name|i
index|]
operator|.
name|size
operator|=
name|sizesArray
index|[
name|orderedArray
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* functionality available only for some derivatives (limited by config) */
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
operator|->
name|numOfBackupPools
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|orderedArray
index|[
name|i
index|]
operator|==
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
operator|->
name|poolIds
index|[
name|j
index|]
condition|)
block|{
name|bpools
operator|.
name|bpool
index|[
name|i
index|]
operator|.
name|is_backup
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* save pools parameters for later use */
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|numOfPools
operator|=
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
expr_stmt|;
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
operator|=
name|sizesArray
index|[
name|orderedArray
index|[
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
operator|-
literal|1
index|]
index|]
expr_stmt|;
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|secondLargestBufSize
operator|=
name|sizesArray
index|[
name|orderedArray
index|[
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
operator|-
literal|2
index|]
index|]
expr_stmt|;
comment|/* FMBM_RMPD reg. - pool depletion */
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|poolsGrpModeEnable
condition|)
block|{
name|bpools
operator|.
name|grp_bp_depleted_num
operator|=
name|p_BufPoolDepletion
operator|->
name|numOfPools
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BM_MAX_NUM_OF_POOLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|poolsToConsider
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|orderedArray
index|[
name|j
index|]
condition|)
block|{
name|bpools
operator|.
name|bpool
index|[
name|j
index|]
operator|.
name|grp_bp_depleted
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|singlePoolModeEnable
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BM_MAX_NUM_OF_POOLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|poolsToConsiderForSingleMode
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ExtBufPools
operator|->
name|numOfPoolsUsed
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|orderedArray
index|[
name|j
index|]
condition|)
block|{
name|bpools
operator|.
name|bpool
index|[
name|j
index|]
operator|.
name|single_bp_depleted
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
comment|/* fill QbbPEV */
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|poolsGrpModeEnable
operator|||
name|p_BufPoolDepletion
operator|->
name|singlePoolModeEnable
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PFC_PRIORITIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_BufPoolDepletion
operator|->
name|pfcPrioritiesEn
index|[
name|i
index|]
operator|==
name|TRUE
condition|)
block|{
name|bpools
operator|.
name|bpool
index|[
name|i
index|]
operator|.
name|pfc_priorities_en
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* Issue flibs function */
name|err
operator|=
name|fman_port_set_bpools
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
operator|&
name|bpools
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_bpools"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|ClearPerfCnts
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FM_PORT_ModifyCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|InitLowLevelDriver
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_FmPortDriverParam
modifier|*
name|p_DriverParams
init|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
decl_stmt|;
name|struct
name|fman_port_params
name|portParams
decl_stmt|;
name|uint32_t
name|tmpVal
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* Set up flibs parameters and issue init function */
name|memset
argument_list|(
operator|&
name|portParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fman_port_params
argument_list|)
argument_list|)
expr_stmt|;
name|portParams
operator|.
name|discard_mask
operator|=
name|p_DriverParams
operator|->
name|errorsToDiscard
expr_stmt|;
name|portParams
operator|.
name|dflt_fqid
operator|=
name|p_DriverParams
operator|->
name|dfltFqid
expr_stmt|;
name|portParams
operator|.
name|err_fqid
operator|=
name|p_DriverParams
operator|->
name|errFqid
expr_stmt|;
name|portParams
operator|.
name|deq_sp
operator|=
name|p_DriverParams
operator|->
name|deqSubPortal
expr_stmt|;
name|portParams
operator|.
name|dont_release_buf
operator|=
name|p_DriverParams
operator|->
name|dontReleaseBuf
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|portParams
operator|.
name|err_mask
operator|=
operator|(
name|RX_ERRS_TO_ENQ
operator|&
operator|~
name|portParams
operator|.
name|discard_mask
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
name|p_DriverParams
operator|->
name|forwardReuseIntContext
condition|)
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|rx_fd_bits
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|BMI_PORT_RFNE_FRWD_RPD
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|portParams
operator|.
name|err_mask
operator|=
operator|(
name|OP_ERRS_TO_ENQ
operator|&
operator|~
name|portParams
operator|.
name|discard_mask
operator|)
expr_stmt|;
break|break;
break|break;
default|default:
break|break;
block|}
name|tmpVal
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|%
name|OFFSET_UNITS
operator|)
condition|?
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|/
name|OFFSET_UNITS
operator|+
literal|1
operator|)
else|:
operator|(
name|p_FmPort
operator|->
name|internalBufferOffset
operator|/
name|OFFSET_UNITS
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|internalBufferOffset
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|tmpVal
operator|*
name|OFFSET_UNITS
argument_list|)
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|int_buf_start_margin
operator|=
name|p_FmPort
operator|->
name|internalBufferOffset
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|ext_buf_start_margin
operator|=
name|p_DriverParams
operator|->
name|bufMargins
operator|.
name|startMargins
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|ext_buf_end_margin
operator|=
name|p_DriverParams
operator|->
name|bufMargins
operator|.
name|endMargins
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|ic_ext_offset
operator|=
name|p_DriverParams
operator|->
name|intContext
operator|.
name|extBufOffset
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|ic_int_offset
operator|=
name|p_DriverParams
operator|->
name|intContext
operator|.
name|intContextOffset
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|ic_size
operator|=
name|p_DriverParams
operator|->
name|intContext
operator|.
name|size
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|stats_counters_enable
operator|=
name|TRUE
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|perf_counters_enable
operator|=
name|TRUE
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|queue_counters_enable
operator|=
name|TRUE
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|perf_cnt_params
operator|.
name|task_val
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|||
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|perf_cnt_params
operator|.
name|queue_val
operator|=
literal|0
expr_stmt|;
else|else
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|perf_cnt_params
operator|.
name|queue_val
operator|=
literal|1
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|perf_cnt_params
operator|.
name|dma_val
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|p_DriverParams
operator|->
name|dfltCfg
operator|.
name|perf_cnt_params
operator|.
name|fifo_val
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|fman_port_init
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
operator|&
name|p_DriverParams
operator|->
name|dfltCfg
argument_list|,
operator|&
name|portParams
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_DEVICE
argument_list|,
operator|(
literal|"fman_port_init"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
operator|&&
operator|(
operator|(
name|err
operator|=
name|FmPortImInit
argument_list|(
name|p_FmPort
argument_list|)
operator|)
operator|!=
name|E_OK
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
else|else
block|{
comment|//  from QMIInit
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
block|{
if|if
condition|(
name|p_DriverParams
operator|->
name|deqPrefetchOption
operator|==
name|e_FM_PORT_DEQ_NO_PREFETCH
condition|)
name|FmSetPortPreFetchConfiguration
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|FmSetPortPreFetchConfiguration
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The code bellow is a trick so the FM will not release the buffer      to BM nor will try to enqueue the frame to QM */
if|if
condition|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|)
operator|&&
operator|(
operator|!
name|p_FmPort
operator|->
name|imEn
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_DriverParams
operator|->
name|dfltFqid
operator|&&
name|p_DriverParams
operator|->
name|dontReleaseBuf
condition|)
block|{
comment|/* override fmbm_tcfqid 0 with a false non-0 value. This will force FM to              * act according to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release              * buffers to BM regardless of fmbm_tfene              */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tcfqid
argument_list|,
literal|0xFFFFFF
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tfene
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_TX_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|CheckRxBmiCounter
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_BAD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LARGE_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER
operator|)
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|CheckTxBmiCounter
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|CheckOhBmiCounter
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|)
block|{
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_WRED_DISCARD
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
return|return
name|TRUE
return|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
condition|)
return|return
name|FALSE
return|;
else|else
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BmiPortCheckAndGetCounterType
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|,
name|enum
name|fman_port_stats_counters
modifier|*
name|p_StatsType
parameter_list|,
name|enum
name|fman_port_perf_counters
modifier|*
name|p_PerfType
parameter_list|,
name|bool
modifier|*
name|p_IsStats
parameter_list|)
block|{
specifier|volatile
name|uint32_t
modifier|*
name|p_Reg
decl_stmt|;
name|bool
name|isValid
decl_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_Reg
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rstc
expr_stmt|;
name|isValid
operator|=
name|CheckRxBmiCounter
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_Reg
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tstc
expr_stmt|;
name|isValid
operator|=
name|CheckTxBmiCounter
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_Reg
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ostc
expr_stmt|;
name|isValid
operator|=
name|CheckOhBmiCounter
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isValid
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for this port type"
operator|)
argument_list|)
expr_stmt|;
comment|/* check that counters are enabled */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION
operator|)
case|:
comment|/* performance counters - may be read when disabled */
operator|*
name|p_IsStats
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_BAD_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LARGE_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_WRED_DISCARD
operator|)
case|:
operator|*
name|p_IsStats
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_Reg
argument_list|)
operator|&
name|BMI_COUNTERS_EN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_CYCLE
operator|)
case|:
operator|*
name|p_PerfType
operator|=
name|E_FMAN_PORT_PERF_CNT_CYCLE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_TASK_UTIL
operator|)
case|:
operator|*
name|p_PerfType
operator|=
name|E_FMAN_PORT_PERF_CNT_TASK_UTIL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
operator|)
case|:
operator|*
name|p_PerfType
operator|=
name|E_FMAN_PORT_PERF_CNT_QUEUE_UTIL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DMA_UTIL
operator|)
case|:
operator|*
name|p_PerfType
operator|=
name|E_FMAN_PORT_PERF_CNT_DMA_UTIL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FIFO_UTIL
operator|)
case|:
operator|*
name|p_PerfType
operator|=
name|E_FMAN_PORT_PERF_CNT_FIFO_UTIL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION
operator|)
case|:
operator|*
name|p_PerfType
operator|=
name|E_FMAN_PORT_PERF_CNT_RX_PAUSE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_FRAME
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_FRAME
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_DISCARD
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_DEALLOC_BUF
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_BAD_FRAME
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LARGE_FRAME
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_FILTERED_FRAME
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_DMA_ERR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_WRED_DISCARD
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_WRED_DISCARD
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_LENGTH_ERR
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_LEN_ERR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
operator|)
case|:
operator|*
name|p_StatsType
operator|=
name|E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AdditionalPrsParams
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|t_FmPcdPrsAdditionalHdrParams
modifier|*
name|p_HdrParams
parameter_list|,
name|uint32_t
modifier|*
name|p_SoftSeqAttachReg
parameter_list|)
block|{
name|uint8_t
name|hdrNum
decl_stmt|,
name|Ipv4HdrNum
decl_stmt|;
name|u_FmPcdHdrPrsOpts
modifier|*
name|p_prsOpts
decl_stmt|;
name|uint32_t
name|tmpReg
init|=
operator|*
name|p_SoftSeqAttachReg
decl_stmt|,
name|tmpPrsOffset
decl_stmt|;
if|if
condition|(
name|IS_PRIVATE_HEADER
argument_list|(
name|p_HdrParams
operator|->
name|hdr
argument_list|)
operator|||
name|IS_SPECIAL_HEADER
argument_list|(
name|p_HdrParams
operator|->
name|hdr
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"No additional parameters for private or special headers."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_HdrParams
operator|->
name|errDisable
condition|)
name|tmpReg
operator||=
name|PRS_HDR_ERROR_DIS
expr_stmt|;
comment|/* Set parser options */
if|if
condition|(
name|p_HdrParams
operator|->
name|usePrsOpts
condition|)
block|{
name|p_prsOpts
operator|=
operator|&
name|p_HdrParams
operator|->
name|prsOpts
expr_stmt|;
switch|switch
condition|(
name|p_HdrParams
operator|->
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|mplsPrsOptions
operator|.
name|labelInterpretationEnable
condition|)
name|tmpReg
operator||=
name|PRS_HDR_MPLS_LBL_INTER_EN
expr_stmt|;
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|p_prsOpts
operator|->
name|mplsPrsOptions
operator|.
name|nextParse
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|Ipv4HdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|<
name|Ipv4HdrNum
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Header must be equal or higher than IPv4"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|hdrNum
operator|*
name|PRS_HDR_ENTRY_SIZE
operator|)
operator|<<
name|PRS_HDR_MPLS_NEXT_HDR_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|pppoePrsOptions
operator|.
name|enableMTUCheck
condition|)
name|tmpReg
operator||=
name|PRS_HDR_PPPOE_MTU_CHECK_EN
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|ipv6PrsOptions
operator|.
name|routingHdrEnable
condition|)
name|tmpReg
operator||=
name|PRS_HDR_IPV6_ROUTE_HDR_EN
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|tcpPrsOptions
operator|.
name|padIgnoreChecksum
condition|)
name|tmpReg
operator||=
name|PRS_HDR_TCP_PAD_REMOVAL
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|PRS_HDR_TCP_PAD_REMOVAL
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
if|if
condition|(
name|p_prsOpts
operator|->
name|udpPrsOptions
operator|.
name|padIgnoreChecksum
condition|)
name|tmpReg
operator||=
name|PRS_HDR_UDP_PAD_REMOVAL
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|PRS_HDR_UDP_PAD_REMOVAL
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid header"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set software parsing (address is divided in 2 since parser uses 2 byte access. */
if|if
condition|(
name|p_HdrParams
operator|->
name|swPrsEnable
condition|)
block|{
name|tmpPrsOffset
operator|=
name|FmPcdGetSwPrsOffset
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_HdrParams
operator|->
name|hdr
argument_list|,
name|p_HdrParams
operator|->
name|indexPerHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpPrsOffset
operator|==
name|ILLEGAL_BASE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|tmpPrsOffset
operator|)
expr_stmt|;
block|}
operator|*
name|p_SoftSeqAttachReg
operator|=
name|tmpReg
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|GetPortSchemeBindParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_SchemeBind
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|walking1Mask
init|=
literal|0x80000000
decl_stmt|,
name|tmp
decl_stmt|;
name|uint8_t
name|idx
init|=
literal|0
decl_stmt|;
name|p_SchemeBind
operator|->
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|p_SchemeBind
operator|->
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|p_SchemeBind
operator|->
name|useClsPlan
operator|=
name|p_FmPort
operator|->
name|useClsPlan
expr_stmt|;
name|p_SchemeBind
operator|->
name|numOfSchemes
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|p_FmPort
operator|->
name|schemesPerPortVector
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|&
name|walking1Mask
condition|)
block|{
name|p_SchemeBind
operator|->
name|schemesIds
index|[
name|p_SchemeBind
operator|->
name|numOfSchemes
index|]
operator|=
name|idx
expr_stmt|;
name|p_SchemeBind
operator|->
name|numOfSchemes
operator|++
expr_stmt|;
name|tmp
operator|&=
operator|~
name|walking1Mask
expr_stmt|;
block|}
name|walking1Mask
operator|>>=
literal|1
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FmPortCheckNApplyMacsec
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCfgReg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|macsecEn
init|=
name|BMI_PORT_CFG_EN_MACSEC
decl_stmt|;
name|uint32_t
name|lcv
decl_stmt|,
name|walking1Mask
init|=
literal|0x80000000
decl_stmt|;
name|uint8_t
name|cnt
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
return|return;
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rcfg
expr_stmt|;
comment|/* get LCV for MACSEC */
if|if
condition|(
operator|(
name|lcv
operator|=
name|FmPcdGetMacsecLcv
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|lcv
operator|&
name|walking1Mask
operator|)
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|walking1Mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|macsecEn
operator||=
operator|(
name|uint32_t
operator|)
name|cnt
operator|<<
name|BMI_PORT_CFG_MS_SEL_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator||
name|macsecEn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetPcd
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|,
name|t_FmPortPcdParams
modifier|*
name|p_PcdParams
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsNia
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsStartOffset
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiInitPrsResult
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCcBase
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|hdrNum
decl_stmt|,
name|L3HdrNum
decl_stmt|,
name|greHdrNum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|isEmptyClsPlanGrp
decl_stmt|;
name|uint32_t
name|tmpHxs
index|[
name|FM_PCD_PRS_NUM_OF_HDRS
index|]
decl_stmt|;
name|uint16_t
name|absoluteProfileId
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|uint32_t
name|ccTreePhysOffset
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|uint32_t
name|initialSwPrs
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|netEnvId
operator|=
name|FmPcdGetNetEnvId
argument_list|(
name|p_PcdParams
operator|->
name|h_NetEnv
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator|=
literal|0
expr_stmt|;
comment|/* initialize p_FmPort->pcdEngines field in port's structure */
switch|switch
condition|(
name|p_PcdParams
operator|->
name|pcdSupport
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_NONE
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_ONLY
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PLCR_ONLY
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_CC
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PRS
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_CC_ONLY
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR
operator|)
case|:
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_KG
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_PLCR
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid pcdSupport"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
operator|>
name|FM_PCD_PRS_NUM_OF_HDRS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Port parser numOfHdrsWithAdditionalParams may not exceed %d"
operator|,
name|FM_PCD_PRS_NUM_OF_HDRS
operator|)
argument_list|)
expr_stmt|;
comment|/* check that parameters exist for each and only each defined engine */
if|if
condition|(
operator|(
operator|!
operator|!
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|!=
operator|!
operator|!
name|p_PcdParams
operator|->
name|p_PrsParams
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
operator|)
operator|!=
operator|!
operator|!
name|p_PcdParams
operator|->
name|p_KgParams
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
operator|)
operator|!=
operator|!
operator|!
name|p_PcdParams
operator|->
name|p_CcParams
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"PCD initialization structure is not consistent with pcdSupport"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
expr_stmt|;
name|p_BmiPrsNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfpne
expr_stmt|;
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rpso
expr_stmt|;
name|p_BmiInitPrsResult
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rprai
index|[
literal|0
index|]
expr_stmt|;
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rccb
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofne
expr_stmt|;
name|p_BmiPrsNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofpne
expr_stmt|;
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_opso
expr_stmt|;
name|p_BmiInitPrsResult
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_oprai
index|[
literal|0
index|]
expr_stmt|;
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_occb
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set PCD port parameter */
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
condition|)
block|{
name|err
operator|=
name|FmPcdCcBindTree
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_PcdParams
argument_list|,
name|p_PcdParams
operator|->
name|p_CcParams
operator|->
name|h_CcTree
argument_list|,
operator|&
name|ccTreePhysOffset
argument_list|,
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCcBase
argument_list|,
name|ccTreePhysOffset
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|ccTreeId
operator|=
name|p_PcdParams
operator|->
name|p_CcParams
operator|->
name|h_CcTree
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
condition|)
block|{
if|if
condition|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For ports using Keygen, at least one scheme must be bound. "
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgSetOrBindToClsPlanGrp
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
name|p_FmPort
operator|->
name|optArray
argument_list|,
operator|&
name|p_FmPort
operator|->
name|clsPlanGrpId
argument_list|,
operator|&
name|isEmptyClsPlanGrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"FmPcdKgSetOrBindToClsPlanGrp failed. "
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|useClsPlan
operator|=
operator|!
name|isEmptyClsPlanGrp
expr_stmt|;
name|schemeBind
operator|.
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|schemeBind
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|schemeBind
operator|.
name|numOfSchemes
operator|=
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
expr_stmt|;
name|schemeBind
operator|.
name|useClsPlan
operator|=
name|p_FmPort
operator|->
name|useClsPlan
expr_stmt|;
comment|/* for each scheme */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT_COND
argument_list|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|physicalSchemeId
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|=
name|physicalSchemeId
expr_stmt|;
comment|/* build vector */
name|p_FmPort
operator|->
name|schemesPerPortVector
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|physicalSchemeId
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
comment|/*because of the state that VSPE is defined per port - all PCD path should be according to this requirement              if !VSPE - in port, for relevant scheme VSPE can not be set*/
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|vspe
operator|&&
name|FmPcdKgGetVspe
argument_list|(
operator|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
operator|)
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"VSPE is not at port level"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
name|err
operator|=
name|FmPcdKgBindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/***************************/
comment|/* configure NIA after BMI */
comment|/***************************/
comment|/* rfne may contain FDCS bits, so first we read them. */
name|p_FmPort
operator|->
name|savedBmiNia
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
expr_stmt|;
comment|/* If policer is used directly after BMI or PRS */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PLCR
operator|)
operator|&&
operator|(
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PLCR_ONLY
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_PcdParams
operator|->
name|p_PlcrParams
operator|->
name|h_Profile
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Profile should be initialized"
operator|)
argument_list|)
expr_stmt|;
name|absoluteProfileId
operator|=
operator|(
name|uint16_t
operator|)
name|FmPcdPlcrProfileGetAbsoluteId
argument_list|(
name|p_PcdParams
operator|->
name|p_PlcrParams
operator|->
name|h_Profile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Private port profile not valid."
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|absoluteProfileId
operator||
name|NIA_PLCR_ABSOLUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
comment|/* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
comment|/* update BMI HPNIA */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PLCR
operator||
name|tmpReg
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* e_FM_PCD_SUPPORT_PLCR_ONLY */
comment|/* update BMI NIA */
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PLCR
argument_list|)
expr_stmt|;
block|}
comment|/* if CC is used directly after BMI */
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_CC_ONLY
operator|)
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR
operator|)
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_CC
argument_list|)
expr_stmt|;
comment|/* check that prs start offset == RIM[FOF] */
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_PcdParams
operator|->
name|p_PrsParams
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|firstPrsHdr
operator|==
name|HEADER_TYPE_CAPWAP
condition|)
name|hdrNum
operator|=
name|OFFLOAD_SW_PATCH_CAPWAP_LABEL
expr_stmt|;
else|else
block|{
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* if PRS is used it is always first */
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|firstPrsHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Unsupported header."
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PRS
operator||
call|(
name|uint32_t
call|)
argument_list|(
name|hdrNum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set after parser NIA */
name|tmpReg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p_PcdParams
operator|->
name|pcdSupport
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_ONLY
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
operator|)
case|:
name|tmpReg
operator|=
name|NIA_KG_CC_EN
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR
operator|)
case|:
if|if
condition|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|directScheme
condition|)
block|{
name|physicalSchemeId
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_DirectScheme
argument_list|)
expr_stmt|;
comment|/* check that this scheme was bound to this port */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_DirectScheme
operator|==
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Direct scheme is not one of the port selected schemes."
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_KG_DIRECT
operator||
name|physicalSchemeId
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
name|NIA_ENG_KG
operator||
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_CC
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsNia
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_CC
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
operator|)
case|:
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid PCD support"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set start parsing offset */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|parsingOffset
argument_list|)
expr_stmt|;
comment|/************************************/
comment|/* Parser port parameters           */
comment|/************************************/
comment|/* stop before configuring */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|,
name|PRS_CAC_STOP
argument_list|)
expr_stmt|;
comment|/* wait for parser to be in idle state */
while|while
condition|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|)
operator|&
name|PRS_CAC_ACTIVE
condition|)
empty_stmt|;
comment|/* set soft seq attachment register */
name|memset
argument_list|(
name|tmpHxs
argument_list|,
literal|0
argument_list|,
name|FM_PCD_PRS_NUM_OF_HDRS
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set protocol options */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p_FmPort
operator|->
name|optArray
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|p_FmPort
operator|->
name|optArray
index|[
name|i
index|]
condition|)
block|{
case|case
operator|(
name|ETH_BROADCAST
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_ETH
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_ETH_BC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|ETH_MULTICAST
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_ETH
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_ETH_MC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|VLAN_STACKED
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_VLAN
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_VLAN_STACKED_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|MPLS_STACKED
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_MPLS
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_MPLS_STACKED_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_BROADCAST_1
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_1_BC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_MULTICAST_1
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_1_MC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_UNICAST_2
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_2_UC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV4_MULTICAST_BROADCAST_2
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV4_2_MC_BC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_MULTICAST_1
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV6_1_MC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_UNICAST_2
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV6_2_UC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|IPV6_MULTICAST_2
operator|)
case|:
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|PRS_HDR_IPV6_2_MC_SHIFT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|FmPcdNetEnvIsHdrExist
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
operator|==
name|FM_PCD_PRS_NUM_OF_HDRS
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"If HEADER_TYPE_UDP_ENCAP_ESP is used, numOfHdrsWithAdditionalParams may be up to FM_PCD_PRS_NUM_OF_HDRS - 1"
operator|)
argument_list|)
expr_stmt|;
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
index|]
operator|.
name|swPrsEnable
operator|=
name|TRUE
expr_stmt|;
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
operator|++
expr_stmt|;
block|}
comment|/* set MPLS default next header - HW reset workaround  */
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_MPLS
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
name|PRS_HDR_MPLS_LBL_INTER_EN
expr_stmt|;
name|L3HdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_USER_DEFINED_L3
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|uint32_t
operator|)
name|L3HdrNum
operator|<<
name|PRS_HDR_MPLS_NEXT_HDR_SHIFT
expr_stmt|;
comment|/* for GRE, disable errors */
name|greHdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_GRE
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|greHdrNum
index|]
operator||=
name|PRS_HDR_ERROR_DIS
expr_stmt|;
comment|/* For UDP remove PAD from L4 checksum calculation */
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_UDP
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
name|PRS_HDR_UDP_PAD_REMOVAL
expr_stmt|;
comment|/* For TCP remove PAD from L4 checksum calculation */
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_TCP
argument_list|)
expr_stmt|;
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
name|PRS_HDR_TCP_PAD_REMOVAL
expr_stmt|;
comment|/* config additional params for specific headers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|numOfHdrsWithAdditionalParams
condition|;
name|i
operator|++
control|)
block|{
comment|/* case for using sw parser as the initial NIA address, before                * HW parsing                */
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_NONE
operator|)
operator|&&
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
operator|.
name|swPrsEnable
condition|)
block|{
name|initialSwPrs
operator|=
name|FmPcdGetSwPrsOffset
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|HEADER_TYPE_NONE
argument_list|,
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
operator|.
name|indexPerHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialSwPrs
operator|==
name|ILLEGAL_BASE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* clear parser first HXS */
name|p_FmPort
operator|->
name|savedBmiNia
operator|&=
operator|~
name|BMI_RFNE_HXS_MASK
expr_stmt|;
comment|/* 0x000000FF */
comment|/* rewrite with soft parser start */
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
name|initialSwPrs
expr_stmt|;
continue|continue;
block|}
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrNum
operator|==
name|NO_HDR_NUM
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Private headers may not use additional parameters"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|AdditionalPrsParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|additionalParams
index|[
name|i
index|]
argument_list|,
operator|&
name|tmpHxs
index|[
name|hdrNum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* Check if ip-reassembly port - need to link sw-parser code */
if|if
condition|(
name|p_FmPort
operator|->
name|h_IpReassemblyManip
condition|)
block|{
comment|/* link to sw parser code for IP Frag - only if no other code is applied. */
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|OFFLOAD_SW_PATCH_IPv4_IPR_LABEL
operator|)
expr_stmt|;
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|OFFLOAD_SW_PATCH_IPv6_IPR_LABEL
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FmPcdNetEnvIsHdrExist
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_LITE
argument_list|)
condition|)
block|{
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|OFFLOAD_SW_PATCH_IPv6_IPF_LABEL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|)
condition|)
block|{
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|OFFLOAD_SW_PATCH_IPv6_IPF_LABEL
operator|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|&&
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|)
if|if
condition|(
name|FmPcdNetEnvIsHdrExist
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_LITE
argument_list|)
condition|)
block|{
comment|/* link to sw parser code for udp lite - only if no other code is applied. */
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpHxs
index|[
name|hdrNum
index|]
operator|&
name|PRS_HDR_SW_PRS_EN
operator|)
condition|)
name|tmpHxs
index|[
name|hdrNum
index|]
operator||=
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|UDP_LITE_SW_PATCH_LABEL
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ((DPAA_VERSION == 10)&& defined(FM_CAPWAP_SUPPORT)) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_PRS_NUM_OF_HDRS
condition|;
name|i
operator|++
control|)
block|{
comment|/* For all header set LCV as taken from netEnv*/
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|hdrs
index|[
name|i
index|]
operator|.
name|lcv
argument_list|,
name|FmPcdGetLcv
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|,
operator|(
name|uint8_t
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set HXS register according to default+Additional params+protocol options */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|hdrs
index|[
name|i
index|]
operator|.
name|softSeqAttach
argument_list|,
name|tmpHxs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* set tpid. */
name|tmpReg
operator|=
name|PRS_TPID_DFLT
expr_stmt|;
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|setVlanTpid1
condition|)
block|{
name|tmpReg
operator|&=
name|PRS_TPID2_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|vlanTpid1
operator|<<
name|PRS_PCTPID_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|setVlanTpid2
condition|)
block|{
name|tmpReg
operator|&=
name|PRS_TPID1_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|vlanTpid2
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pctpid
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* enable parser */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|prsResultPrivateInfo
condition|)
name|p_FmPort
operator|->
name|privateInfo
operator|=
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|prsResultPrivateInfo
expr_stmt|;
block|}
comment|/* end parser */
else|else
block|{
if|if
condition|(
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
block|{
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|HEADER_TYPE_IPv6
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|hdrs
index|[
name|hdrNum
index|]
operator|.
name|softSeqAttach
argument_list|,
operator|(
name|PRS_HDR_SW_PRS_EN
operator||
name|OFFLOAD_SW_PATCH_IPv6_IPF_LABEL
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|privateInfo
operator|=
literal|0
expr_stmt|;
block|}
name|FmPortCheckNApplyMacsec
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|)
operator|+
name|p_FmPort
operator|->
name|internalBufferOffset
argument_list|)
expr_stmt|;
comment|/* set initial parser result - used for all engines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_PRS_RESULT_NUM_OF_WORDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|i
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_BmiInitPrsResult
operator|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|p_FmPort
operator|->
name|privateInfo
operator|<<
name|BMI_PR_PORTID_SHIFT
operator|)
operator||
name|BMI_PRS_RESULT_HIGH
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|<
name|FM_PORT_PRS_RESULT_NUM_OF_WORDS
operator|/
literal|2
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_BmiInitPrsResult
operator|+
name|i
operator|)
argument_list|,
name|BMI_PRS_RESULT_HIGH
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|p_BmiInitPrsResult
operator|+
name|i
operator|)
argument_list|,
name|BMI_PRS_RESULT_LOW
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|DeletePcd
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsStartOffset
init|=
name|NULL
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|pcdEngines
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"called for non PCD port"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
expr_stmt|;
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rpso
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofne
expr_stmt|;
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_opso
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME
argument_list|()
operator|)
operator|!=
name|GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME
argument_list|()
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"port has to be detached previousely"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "cut" PCD out of the port's flow - go to BMI */
comment|/* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia& BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
block|{
comment|/* stop parser */
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|,
name|PRS_CAC_STOP
argument_list|)
expr_stmt|;
comment|/* wait for parser to be in idle state */
while|while
condition|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|->
name|pcac
argument_list|)
operator|&
name|PRS_CAC_ACTIVE
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
condition|)
block|{
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
comment|/* unbind all schemes */
name|p_FmPort
operator|->
name|schemesPerPortVector
operator|=
name|GetPortSchemeBindParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgUnbindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgDeleteOrUnbindPortToClsPlanGrp
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|p_FmPort
operator|->
name|clsPlanGrpId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|useClsPlan
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
condition|)
block|{
comment|/* unbind - we need to get the treeId too */
name|err
operator|=
name|FmPcdCcUnbindTree
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|ccTreeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|pcdEngines
operator|=
literal|0
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AttachPCD
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofne
expr_stmt|;
else|else
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
expr_stmt|;
comment|/* check that current NIA is BMI to BMI */
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
operator|~
name|BMI_RFNE_FDCS_MASK
operator|)
operator|!=
name|GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME
argument_list|()
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"may be called only for ports in BMI-to-BMI state."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
condition|)
if|if
condition|(
name|FmSetNumOfRiscsPerPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
literal|1
argument_list|,
name|p_FmPort
operator|->
name|orFmanCtrl
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_CMNE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ocmne
argument_list|,
name|p_FmPort
operator|->
name|savedBmiCmne
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rcmne
argument_list|,
name|p_FmPort
operator|->
name|savedBmiCmne
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNEN
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|fmqm_pnen
argument_list|,
name|p_FmPort
operator|->
name|savedQmiPnen
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_FENE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofene
argument_list|,
name|p_FmPort
operator|->
name|savedBmiFene
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfene
argument_list|,
name|p_FmPort
operator|->
name|savedBmiFene
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_FPNE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofpne
argument_list|,
name|p_FmPort
operator|->
name|savedBmiFpne
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfpne
argument_list|,
name|p_FmPort
operator|->
name|savedBmiFpne
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_OFP_DPTE
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofp
argument_list|,
name|p_FmPort
operator|->
name|savedBmiOfp
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNDN
condition|)
block|{
name|p_FmPort
operator|->
name|origNonRxQmiRegsPndn
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|->
name|fmqm_pndn
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|->
name|fmqm_pndn
argument_list|,
name|p_FmPort
operator|->
name|savedNonRxQmiRegsPndn
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|DetachPCD
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNDN
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|->
name|fmqm_pndn
argument_list|,
name|p_FmPort
operator|->
name|origNonRxQmiRegsPndn
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofne
expr_stmt|;
else|else
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
operator|(
name|p_FmPort
operator|->
name|savedBmiNia
operator|&
name|BMI_RFNE_FDCS_MASK
operator|)
operator||
name|GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmPcdGetHcHandle
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
name|FmPcdHcSync
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_FENE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofene
argument_list|,
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfene
argument_list|,
name|NIA_ENG_QMI_ENQ
operator||
name|NIA_ORDER_RESTOR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNEN
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|->
name|fmqm_pnen
argument_list|,
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
condition|)
if|if
condition|(
name|FmSetNumOfRiscsPerPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
literal|2
argument_list|,
name|p_FmPort
operator|->
name|orFmanCtrl
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator|=
literal|0
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|FmPortSetMacsecCmd
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|dfltSci
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCfgReg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"The routine is relevant for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_BmiCfgReg
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|tx
operator|.
name|fmbm_tfca
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|)
operator|&
operator|~
name|BMI_CMD_ATTR_MACCMD_MASK
expr_stmt|;
name|tmpReg
operator||=
name|BMI_CMD_ATTR_MACCMD_SECURED
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|dfltSci
operator|<<
name|BMI_CMD_ATTR_MACCMD_SC_SHIFT
operator|)
operator|&
name|BMI_CMD_ATTR_MACCMD_SC_MASK
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCfgReg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|FmPortGetNetEnvId
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
operator|)
operator|->
name|netEnvId
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPortGetHardwarePortId
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
operator|)
operator|->
name|hardwarePortId
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPortGetPcdEngines
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
operator|)
operator|->
name|pcdEngines
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
name|t_Error
name|FmPortSetGprFunc
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortGprFuncType
name|gprFunc
parameter_list|,
name|void
modifier|*
modifier|*
name|p_Value
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|muramPageOffset
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|gprFunc
operator|!=
name|e_FM_PORT_GPR_EMPTY
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|gprFunc
operator|!=
name|gprFunc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"gpr was assigned with different func"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|gprFunc
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_GPR_MURAM_PAGE
operator|)
case|:
name|p_FmPort
operator|->
name|p_ParamsPage
operator|=
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPort
operator|->
name|h_FmMuram
argument_list|,
literal|256
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_ParamsPage
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for page"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_FmPort
operator|->
name|p_ParamsPage
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|muramPageOffset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_FmPort
operator|->
name|p_ParamsPage
argument_list|)
operator|-
name|p_FmPort
operator|->
name|fmMuramPhysBaseAddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rgpr
argument_list|,
name|muramPageOffset
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ogpr
argument_list|,
name|muramPageOffset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|gprFunc
operator|=
name|gprFunc
expr_stmt|;
block|}
switch|switch
condition|(
name|p_FmPort
operator|->
name|gprFunc
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_GPR_MURAM_PAGE
operator|)
case|:
operator|*
name|p_Value
operator|=
name|p_FmPort
operator|->
name|p_ParamsPage
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_function
name|t_Error
name|FmPortGetSetCcParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortGetSetCcParams
modifier|*
name|p_CcParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpInt
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiPrsStartOffset
init|=
name|NULL
decl_stmt|;
comment|/* this function called from Cc for pass and receive parameters port params between CC and PORT*/
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|!=
name|ILLEGAL_BASE
operator|)
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|prOffset
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|hardwarePortId
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|HW_PORT_ID
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
operator|!=
name|ILLEGAL_BASE
operator|)
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|dataOffset
operator|=
operator|(
name|uint16_t
operator|)
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|numOfTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|NUM_OF_TASKS
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_EXTRA_TASKS
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|numOfExtraTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|NUM_OF_EXTRA_TASKS
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|FM_REV
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|revInfo
operator|.
name|majorRev
operator|=
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|revInfo
operator|.
name|minorRev
operator|=
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|minorRev
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|FM_REV
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|DISCARD_MASK
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|discardMask
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsdm
argument_list|)
expr_stmt|;
else|else
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|discardMask
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsdm
argument_list|)
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|DISCARD_MASK
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|MANIP_EXTRA_SPACE
condition|)
block|{
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|internalBufferOffset
operator|=
name|p_FmPort
operator|->
name|internalBufferOffset
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|MANIP_EXTRA_SPACE
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|GET_NIA_FPNE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|nia
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofpne
argument_list|)
expr_stmt|;
else|else
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|nia
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfpne
argument_list|)
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|GET_NIA_FPNE
expr_stmt|;
block|}
if|if
condition|(
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&
name|GET_NIA_PNDN
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|nia
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|)
expr_stmt|;
name|p_CcParams
operator|->
name|getCcParams
operator|.
name|type
operator|&=
operator|~
name|GET_NIA_PNDN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
name|p_FmPort
operator|->
name|orFmanCtrl
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|orFmanCtrl
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNEN
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNEN
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedQmiPnen
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_PNEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNEN
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedQmiPnen
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"PNEN was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNDN
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_PNDN
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedNonRxQmiRegsPndn
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_PNDN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_PNDN
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedNonRxQmiRegsPndn
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"PNDN was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_FENE
operator|)
operator|&&
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|overwrite
operator|||
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_FENE
operator|)
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedBmiFene
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_FENE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_FENE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedBmiFene
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"xFENE was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_FPNE
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_FPNE
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedBmiFpne
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_FPNE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_FPNE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedBmiFpne
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"xFPNE was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_CMNE
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_NIA_CMNE
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|savedBmiCmne
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_NIA_CMNE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_NIA_CMNE
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedBmiCmne
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|nia
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"xCMNE was defined previously different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_PSO
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_PSO
operator|)
condition|)
block|{
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rpso
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiPrsStartOffset
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_opso
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* set start parsing offset */
name|tmpInt
operator|=
operator|(
name|int
operator|)
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|)
operator|+
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|psoSize
expr_stmt|;
if|if
condition|(
name|tmpInt
operator|>
literal|0
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiPrsStartOffset
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpInt
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_PSO
expr_stmt|;
name|p_FmPort
operator|->
name|savedPrsStartOffset
operator|=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|psoSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_PSO
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|savedPrsStartOffset
operator|!=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|psoSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"parser start offset was defoned previousley different"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|type
operator|&
name|UPDATE_OFP_DPTE
operator|)
operator|&&
operator|!
operator|(
name|p_FmPort
operator|->
name|requiredAction
operator|&
name|UPDATE_OFP_DPTE
operator|)
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|savedBmiOfp
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofp
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|savedBmiOfp
operator|&=
operator|~
name|BMI_FIFO_PIPELINE_DEPTH_MASK
expr_stmt|;
name|p_FmPort
operator|->
name|savedBmiOfp
operator||=
name|p_CcParams
operator|->
name|setCcParams
operator|.
name|ofpDpde
operator|<<
name|BMI_FIFO_PIPELINE_DEPTH_SHIFT
expr_stmt|;
name|p_FmPort
operator|->
name|requiredAction
operator||=
name|UPDATE_OFP_DPTE
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PORT_Config
parameter_list|(
name|t_FmPortParams
modifier|*
name|p_FmPortParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
decl_stmt|;
name|uintptr_t
name|baseAddr
init|=
name|p_FmPortParams
operator|->
name|baseAddr
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
comment|/* Allocate FM structure */
name|p_FmPort
operator|=
operator|(
name|t_FmPort
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPort
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Port driver structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPort
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPort
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the FM driver's parameters structure */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|=
operator|(
name|t_FmPortDriverParam
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPortDriverParam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Port driver parameters"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortDriverParam
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize FM port parameters which will be kept by the driver */
name|p_FmPort
operator|->
name|portType
operator|=
name|p_FmPortParams
operator|->
name|portType
expr_stmt|;
name|p_FmPort
operator|->
name|portId
operator|=
name|p_FmPortParams
operator|->
name|portId
expr_stmt|;
name|p_FmPort
operator|->
name|pcdEngines
operator|=
name|FM_PCD_NONE
expr_stmt|;
name|p_FmPort
operator|->
name|f_Exception
operator|=
name|p_FmPortParams
operator|->
name|f_Exception
expr_stmt|;
name|p_FmPort
operator|->
name|h_App
operator|=
name|p_FmPortParams
operator|->
name|h_App
expr_stmt|;
name|p_FmPort
operator|->
name|h_Fm
operator|=
name|p_FmPortParams
operator|->
name|h_Fm
expr_stmt|;
comment|/* get FM revision */
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|p_FmPort
operator|->
name|fmRevInfo
argument_list|)
expr_stmt|;
comment|/* calculate global portId number */
name|p_FmPort
operator|->
name|hardwarePortId
operator|=
name|SwPortIdToHwPortId
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPortParams
operator|->
name|portId
argument_list|,
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
argument_list|,
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|minorRev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
operator|&&
operator|(
name|p_FmPortParams
operator|->
name|portId
operator|!=
name|FM_OH_PORT_ID
operator|)
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"Port ID %d is recommended for HC port. Overwriting HW defaults to be suitable for HC."
operator|,
name|FM_OH_PORT_ID
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|&&
operator|(
name|p_FmPortParams
operator|->
name|portId
operator|==
name|FM_OH_PORT_ID
operator|)
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"Use non-zero portId for OP port due to insufficient resources on portId 0."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set up FM port parameters for initialization phase only */
comment|/* First, fill in flibs struct */
name|fman_port_defconfig
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
argument_list|,
operator|(
expr|enum
name|fman_port_type
operator|)
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
comment|/* Overwrite some integration specific parameters */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|rx_pri_elevation
operator|=
name|DEFAULT_PORT_rxFifoPriElevationLevel
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|rx_fifo_thr
operator|=
name|DEFAULT_PORT_rxFifoThreshold
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
argument_list|)
operator|||
name|defined
argument_list|(
name|FM_ERROR_VSP_NO_MATCH_SW006
argument_list|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|errata_A006675
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|errata_A006675
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|6
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|errata_A006320
operator|=
name|TRUE
expr_stmt|;
else|else
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|errata_A006320
operator|=
name|FALSE
expr_stmt|;
comment|/* Excessive Threshold register - exists for pre-FMv3 chips only */
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
condition|)
block|{
ifdef|#
directive|ifdef
name|FM_NO_RESTRICT_ON_ACCESS_RSRC
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|excessive_threshold_register
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|fmbm_rebm_has_sgd
operator|=
name|FALSE
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|fmbm_tfne_has_features
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|excessive_threshold_register
operator|=
name|FALSE
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|fmbm_rebm_has_sgd
operator|=
name|TRUE
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|fmbm_tfne_has_features
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|qmi_deq_options_support
operator|=
name|FALSE
expr_stmt|;
else|else
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|qmi_deq_options_support
operator|=
name|TRUE
expr_stmt|;
comment|/* Continue with other parameters */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|baseAddr
operator|=
name|baseAddr
expr_stmt|;
comment|/* set memory map pointers */
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|=
operator|(
name|t_FmPortQmiRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|baseAddr
operator|+
name|QMI_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|=
operator|(
name|u_FmPortBmiRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|baseAddr
operator|+
name|BMI_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|=
operator|(
name|t_FmPortPrsRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|baseAddr
operator|+
name|PRS_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|privDataSize
operator|=
name|DEFAULT_PORT_bufferPrefixContent_privDataSize
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passPrsResult
operator|=
name|DEFAULT_PORT_bufferPrefixContent_passPrsResult
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passTimeStamp
operator|=
name|DEFAULT_PORT_bufferPrefixContent_passTimeStamp
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|passAllOtherPCDInfo
operator|=
name|DEFAULT_PORT_bufferPrefixContent_passTimeStamp
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|=
name|DEFAULT_PORT_bufferPrefixContent_dataAlign
expr_stmt|;
comment|/*    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;      p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;      p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;      p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;      p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;      */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|liodnBase
operator|=
name|p_FmPortParams
operator|->
name|liodnBase
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cheksumLastBytesIgnore
operator|=
name|DEFAULT_PORT_cheksumLastBytesIgnore
expr_stmt|;
name|p_FmPort
operator|->
name|maxFrameLength
operator|=
name|DEFAULT_PORT_maxFrameLength
expr_stmt|;
comment|/* resource distribution. */
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|DEFAULT_PORT_numOfFifoBufs
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
operator|=
name|DEFAULT_PORT_extraNumOfFifoBufs
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|=
name|DEFAULT_PORT_numOfOpenDmas
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|=
name|DEFAULT_PORT_extraNumOfOpenDmas
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|=
name|DEFAULT_PORT_numOfTasks
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
operator|=
name|DEFAULT_PORT_extraNumOfTasks
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|6
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|=
literal|16
expr_stmt|;
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 */
comment|/* Port type specific initialization: */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
comment|/* Initialize FM port parameters for initialization phase only */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cutBytesFromEnd
operator|=
name|DEFAULT_PORT_cutBytesFromEnd
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|enBufPoolDepletion
operator|=
name|FALSE
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|frmDiscardOverride
operator|=
name|DEFAULT_PORT_frmDiscardOverride
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfp
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|rxFifoPriElevationLevel
operator|=
operator|(
operator|(
operator|(
name|tmpReg
operator|&
name|BMI_RX_FIFO_PRI_ELEVATION_MASK
operator|)
operator|>>
name|BMI_RX_FIFO_PRI_ELEVATION_SHIFT
operator|)
operator|+
literal|1
operator|)
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|rxFifoThreshold
operator|=
operator|(
operator|(
operator|(
name|tmpReg
operator|&
name|BMI_RX_FIFO_THRESHOLD_MASK
operator|)
operator|>>
name|BMI_RX_FIFO_THRESHOLD_SHIFT
operator|)
operator|+
literal|1
operator|)
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
operator|.
name|endMargins
operator|=
name|DEFAULT_PORT_BufMargins_endMargins
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator|=
name|DEFAULT_PORT_errorsToDiscard
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|forwardReuseIntContext
operator|=
name|DEFAULT_PORT_forwardIntContextReuse
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|noScatherGather
operator|=
name|DEFAULT_PORT_noScatherGather
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dontReleaseBuf
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
name|tmpReg
operator|=
literal|0x00001013
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tfp
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tfp
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|txFifoMinFillLevel
operator|=
operator|(
operator|(
name|tmpReg
operator|&
name|BMI_TX_FIFO_MIN_FILL_MASK
operator|)
operator|>>
name|BMI_TX_FIFO_MIN_FILL_SHIFT
operator|)
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
operator|(
name|tmpReg
operator|&
name|BMI_FIFO_PIPELINE_DEPTH_MASK
operator|)
operator|>>
name|BMI_FIFO_PIPELINE_DEPTH_SHIFT
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|txFifoLowComfLevel
operator|=
operator|(
operator|(
operator|(
name|tmpReg
operator|&
name|BMI_TX_LOW_COMF_MASK
operator|)
operator|>>
name|BMI_TX_LOW_COMF_SHIFT
operator|)
operator|+
literal|1
operator|)
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqType
operator|=
name|DEFAULT_PORT_deqType
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|=
name|DEFAULT_PORT_deqPrefetchOption
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqHighPriority
operator|=
call|(
name|bool
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|?
name|DEFAULT_PORT_deqHighPriority_1G
else|:
name|DEFAULT_PORT_deqHighPriority_10G
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqByteCnt
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|?
name|DEFAULT_PORT_deqByteCnt_1G
else|:
name|DEFAULT_PORT_deqByteCnt_10G
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator|=
name|DEFAULT_PORT_errorsToDiscard
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|noScatherGather
operator|=
name|DEFAULT_PORT_noScatherGather
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|=
name|DEFAULT_PORT_deqPrefetchOption_HC
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqHighPriority
operator|=
name|DEFAULT_PORT_deqHighPriority_1G
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqType
operator|=
name|DEFAULT_PORT_deqType
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqByteCnt
operator|=
name|DEFAULT_PORT_deqByteCnt_1G
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofp
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
operator|(
name|tmpReg
operator|&
name|BMI_FIFO_PIPELINE_DEPTH_MASK
operator|)
operator|>>
name|BMI_FIFO_PIPELINE_DEPTH_SHIFT
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
operator|&&
operator|(
name|p_FmPortParams
operator|->
name|portId
operator|!=
name|FM_OH_PORT_ID
operator|)
condition|)
block|{
comment|/* Overwrite HC defaults */
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|=
name|DEFAULT_PORT_fifoDeqPipelineDepth_OH
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FM_FRAME_END_PARAMS_FOR_OP
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|cheksumLastBytesIgnore
operator|=
name|DEFAULT_notSupported
expr_stmt|;
endif|#
directive|endif
comment|/* !FM_FRAME_END_PARAMS_FOR_OP */
ifndef|#
directive|ifndef
name|FM_DEQ_PIPELINE_PARAMS_FOR_OP
if|if
condition|(
operator|!
operator|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
operator|)
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|=
name|DEFAULT_notSupported
expr_stmt|;
endif|#
directive|endif
comment|/* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
break|break;
default|default:
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|FM_QMI_NO_DEQ_OPTIONS_SUPPORT
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqPrefetchOption
operator|=
operator|(
name|e_FmPortDeqPrefetchOption
operator|)
name|DEFAULT_notSupported
expr_stmt|;
endif|#
directive|endif
comment|/* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
name|p_FmPort
operator|->
name|imEn
operator|=
name|p_FmPortParams
operator|->
name|independentModeEnable
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|=
name|DEFAULT_PORT_fifoDeqPipelineDepth_IM
expr_stmt|;
name|FmPortConfigIM
argument_list|(
name|p_FmPort
argument_list|,
name|p_FmPortParams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
comment|/* Initialize FM port parameters for initialization phase only */
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
argument_list|,
operator|&
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|extBufPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmExtPools
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|errFqid
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|dfltFqid
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|liodnOffset
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|rxParams
operator|.
name|liodnOffset
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|errFqid
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|deqSubPortal
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|qmChannel
operator|&
name|QMI_DEQ_CFG_SUBPORTAL_MASK
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltFqid
operator|=
name|p_FmPortParams
operator|->
name|specificParams
operator|.
name|nonRxParams
operator|.
name|dfltFqid
expr_stmt|;
break|break;
default|default:
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|memset
argument_list|(
name|p_FmPort
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPort
operator|->
name|name
argument_list|,
literal|"FM-%d-port-%s-%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
argument_list|,
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
operator|)
condition|?
literal|"OH"
else|:
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
condition|?
literal|"1g-RX"
else|:
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
condition|?
literal|"1g-TX"
else|:
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
condition|?
literal|"10g-RX"
else|:
literal|"10g-TX"
operator|)
operator|)
operator|)
operator|)
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPort
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|h_Spinlock
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_FmPort
return|;
block|}
end_function

begin_decl_stmt
name|t_FmPort
modifier|*
name|rx_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|t_FmPort
modifier|*
name|tx_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/**  @Function      FM_PORT_Init   @Description   Initializes the FM module   @Param[in]     h_FmPort - FM module descriptor   @Return        E_OK on success; Error code otherwise.  */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_Init
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPortDriverParam
modifier|*
name|p_DriverParams
decl_stmt|;
name|t_Error
name|errCode
decl_stmt|;
name|t_FmInterModulePortInitParams
name|fmParams
decl_stmt|;
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|errCode
operator|=
name|FmSpBuildBufferStructure
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|intContext
argument_list|,
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
argument_list|,
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufMargins
argument_list|,
operator|&
name|p_FmPort
operator|->
name|bufferOffsets
argument_list|,
operator|&
name|p_FmPort
operator|->
name|internalBufferOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bcbWorkaround
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
block|{
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator||=
name|FM_PORT_FRM_ERR_PHYSICAL
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
condition|)
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|=
name|DEFAULT_PORT_numOfFifoBufs
argument_list|(
name|p_FmPort
operator|->
name|portType
argument_list|)
operator|*
name|BMI_FIFO_UNITS
expr_stmt|;
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|+=
literal|4
operator|*
name|KILOBYTE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
name|CHECK_INIT_PARAMETERS
argument_list|(
name|p_FmPort
argument_list|,
name|CheckInitParameters
argument_list|)
expr_stmt|;
name|p_DriverParams
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
expr_stmt|;
comment|/* Set up flibs port structure */
name|memset
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fman_port
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|type
operator|=
operator|(
expr|enum
name|fman_port_type
operator|)
name|p_FmPort
operator|->
name|portType
expr_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|fm_rev_maj
operator|=
name|revInfo
operator|.
name|majorRev
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|fm_rev_min
operator|=
name|revInfo
operator|.
name|minorRev
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|=
operator|(
expr|union
name|fman_port_bmi_regs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_DriverParams
operator|->
name|baseAddr
operator|+
name|BMI_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|=
operator|(
expr|struct
name|fman_port_qmi_regs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_DriverParams
operator|->
name|baseAddr
operator|+
name|QMI_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|ext_pools_num
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
condition|?
literal|4
else|:
literal|8
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|port
operator|.
name|im_en
operator|=
name|p_FmPort
operator|->
name|imEn
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortPrsRegs
operator|=
operator|(
name|t_FmPortPrsRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_DriverParams
operator|->
name|baseAddr
operator|+
name|PRS_PORT_REGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|)
operator|&&
operator|!
name|p_FmPort
operator|->
name|imEn
condition|)
block|{
comment|/* Call the external Buffer routine which also checks fifo          size and updates it if necessary */
comment|/* define external buffer pools and pool depletion*/
name|errCode
operator|=
name|SetExtBufferPools
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* check if the largest external buffer pool is large enough */
if|if
condition|(
name|p_DriverParams
operator|->
name|bufMargins
operator|.
name|startMargins
operator|+
name|MIN_EXT_BUF_SIZE
operator|+
name|p_DriverParams
operator|->
name|bufMargins
operator|.
name|endMargins
operator|>
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)"
operator|,
name|p_DriverParams
operator|->
name|bufMargins
operator|.
name|startMargins
operator|,
name|p_DriverParams
operator|->
name|bufMargins
operator|.
name|endMargins
operator|,
name|p_FmPort
operator|->
name|rxPoolsParams
operator|.
name|largestBufSize
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
block|{
block|{
ifdef|#
directive|ifdef
name|FM_NO_OP_OBSERVED_POOLS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
operator|&&
operator|(
name|p_DriverParams
operator|->
name|enBufPoolDepletion
operator|)
condition|)
endif|#
directive|endif
comment|/* FM_NO_OP_OBSERVED_POOLS */
block|{
comment|/* define external buffer pools */
name|errCode
operator|=
name|SetExtBufferPools
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/************************************************************/
comment|/* Call FM module routine for communicating parameters      */
comment|/************************************************************/
name|memset
argument_list|(
operator|&
name|fmParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fmParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmParams
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|fmParams
operator|.
name|portType
operator|=
operator|(
name|e_FmPortType
operator|)
name|p_FmPort
operator|->
name|portType
expr_stmt|;
name|fmParams
operator|.
name|numOfTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
name|fmParams
operator|.
name|numOfExtraTasks
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|extra
expr_stmt|;
name|fmParams
operator|.
name|numOfOpenDmas
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|fmParams
operator|.
name|numOfExtraOpenDmas
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|extra
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
condition|)
block|{
name|errCode
operator|=
name|VerifySizeOfFifo
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|fmParams
operator|.
name|sizeOfFifo
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
name|fmParams
operator|.
name|extraSizeOfFifo
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|extra
expr_stmt|;
name|fmParams
operator|.
name|independentMode
operator|=
name|p_FmPort
operator|->
name|imEn
expr_stmt|;
name|fmParams
operator|.
name|liodnOffset
operator|=
name|p_DriverParams
operator|->
name|liodnOffset
expr_stmt|;
name|fmParams
operator|.
name|liodnBase
operator|=
name|p_DriverParams
operator|->
name|liodnBase
expr_stmt|;
name|fmParams
operator|.
name|deqPipelineDepth
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
expr_stmt|;
name|fmParams
operator|.
name|maxFrameLength
operator|=
name|p_FmPort
operator|->
name|maxFrameLength
expr_stmt|;
ifndef|#
directive|ifndef
name|FM_DEQ_PIPELINE_PARAMS_FOR_OP
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
operator|)
operator|)
condition|)
comment|/* HC ports do not have fifoDeqPipelineDepth, but it is needed only          * for deq threshold calculation.          */
name|fmParams
operator|.
name|deqPipelineDepth
operator|=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
name|errCode
operator|=
name|FmGetSetPortParams
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|fmParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* get params for use in init */
name|p_FmPort
operator|->
name|fmMuramPhysBaseAddr
operator|=
call|(
name|uint64_t
call|)
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|fmParams
operator|.
name|fmMuramPhysBaseAddr
operator|.
name|low
argument_list|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|fmParams
operator|.
name|fmMuramPhysBaseAddr
operator|.
name|high
argument_list|)
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_FmMuram
operator|=
name|FmGetMuramHandle
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|errCode
operator|=
name|InitLowLevelDriver
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|FmPortDriverParamFree
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
block|{
name|t_FmPcdCtrlParamsPage
modifier|*
name|p_ParamsPage
decl_stmt|;
name|FmPortSetGprFunc
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_GPR_MURAM_PAGE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p_ParamsPage
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ParamsPage
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|,
name|FM_CTL_PARAMS_PAGE_ALWAYS_ON
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|)
operator||
name|FM_CTL_PARAMS_PAGE_OP_FIX_EN
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|discardMask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsdm
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675 */
ifdef|#
directive|ifdef
name|FM_ERROR_VSP_NO_MATCH_SW006
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|errorsDiscardMask
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsdm
argument_list|)
operator||
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsem
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|errorsDiscardMask
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsdm
argument_list|)
operator||
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsem
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_ERROR_VSP_NO_MATCH_SW006 */
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|p_FmPort
operator|->
name|deepSleepVars
operator|.
name|autoResMaxSizes
condition|)
name|FmPortConfigAutoResForDeepSleepSupport1
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/**  @Function      FM_PORT_Free   @Description   Frees all resources that were assigned to FM module.   Calling this routine invalidates the descriptor.   @Param[in]     h_FmPort - FM module descriptor   @Return        E_OK on success; Error code otherwise.  */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_Free
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmInterModulePortFreeParams
name|fmParams
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|enabled
condition|)
block|{
if|if
condition|(
name|FM_PORT_Disable
argument_list|(
name|p_FmPort
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"FM_PORT_Disable FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|FmPortImFree
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|FmPortDriverParamFree
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fmParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmParams
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|fmParams
operator|.
name|portType
operator|=
operator|(
name|e_FmPortType
operator|)
name|p_FmPort
operator|->
name|portType
expr_stmt|;
name|fmParams
operator|.
name|deqPipelineDepth
operator|=
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
expr_stmt|;
name|FmFreePortParams
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|fmParams
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|FmVSPFreeForPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"VSP free of port FAILED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|p_ParamsPage
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPort
operator|->
name|h_FmMuram
argument_list|,
name|p_FmPort
operator|->
name|p_ParamsPage
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|p_FmPort
operator|->
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*************************************************/
end_comment

begin_comment
comment|/*       API Advanced Init unit functions        */
end_comment

begin_comment
comment|/*************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_ConfigNumOfOpenDmas
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_OpenDmas
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|setNumOfOpenDmas
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|openDmas
argument_list|,
name|p_OpenDmas
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigNumOfTasks
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_NumOfTasks
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|tasks
argument_list|,
name|p_NumOfTasks
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|setNumOfTasks
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigSizeOfFifo
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_SizeOfFifo
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|setSizeOfFifo
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|fifoBufs
argument_list|,
name|p_SizeOfFifo
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDeqHighPriority
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|highPri
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|deq_high_pri
operator|=
name|highPri
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDeqType
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDeqType
name|deqType
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|deq_type
operator|=
operator|(
expr|enum
name|fman_port_deq_type
operator|)
name|deqType
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDeqPrefetchOption
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortDeqPrefetchOption
name|deqPrefetchOption
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|deq_prefetch_opt
operator|=
operator|(
expr|enum
name|fman_port_deq_prefetch
operator|)
name|deqPrefetchOption
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigBackupPools
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmBackupBmPools
modifier|*
name|p_BackupBmPools
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
operator|=
operator|(
name|t_FmBackupBmPools
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmBackupBmPools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"p_BackupBmPools allocation failed"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|p_BackupBmPools
argument_list|,
name|p_BackupBmPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmBackupBmPools
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDeqByteCnt
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint16_t
name|deqByteCnt
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|deq_byte_cnt
operator|=
name|deqByteCnt
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigBufferPrefixContent
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmBufferPrefixContent
modifier|*
name|p_FmBufferPrefixContent
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
argument_list|,
name|p_FmBufferPrefixContent
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmBufferPrefixContent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if dataAlign was not initialized by user, we return to driver's default */
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
condition|)
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufferPrefixContent
operator|.
name|dataAlign
operator|=
name|DEFAULT_PORT_bufferPrefixContent_dataAlign
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigCheksumLastBytesIgnore
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|checksumLastBytesIgnore
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|checksum_bytes_ignore
operator|=
name|checksumLastBytesIgnore
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigCutBytesFromEnd
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|cutBytesFromEnd
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|rx_cut_end_bytes
operator|=
name|cutBytesFromEnd
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigPoolDepletion
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmBufPoolDepletion
modifier|*
name|p_BufPoolDepletion
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|enBufPoolDepletion
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufPoolDepletion
argument_list|,
name|p_BufPoolDepletion
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmBufPoolDepletion
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigObservedPoolDepletion
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortObservedBufPoolDepletion
modifier|*
name|p_FmPortObservedBufPoolDepletion
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for OP ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|enBufPoolDepletion
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bufPoolDepletion
argument_list|,
operator|&
name|p_FmPortObservedBufPoolDepletion
operator|->
name|poolDepletionParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmBufPoolDepletion
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
argument_list|,
operator|&
name|p_FmPortObservedBufPoolDepletion
operator|->
name|poolsParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmExtPools
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigExtBufPools
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmExtPools
modifier|*
name|p_FmExtPools
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for OP ports only"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|extBufPools
argument_list|,
name|p_FmExtPools
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmExtPools
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDontReleaseTxBufToBM
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dontReleaseBuf
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDfltColor
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortColor
name|color
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|color
operator|=
operator|(
expr|enum
name|fman_port_color
operator|)
name|color
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigSyncReq
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|syncReq
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|sync_req
operator|=
name|syncReq
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigFrmDiscardOverride
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|override
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|discard_override
operator|=
name|override
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigErrorsToDiscard
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|fmPortFrameErrSelect_t
name|errs
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|errorsToDiscard
operator|=
name|errs
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaSwapData
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmDmaSwapOption
name|swapData
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|dma_swap_data
operator|=
operator|(
expr|enum
name|fman_port_dma_swap
operator|)
name|swapData
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaIcCacheAttr
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmDmaCacheOption
name|intContextCacheAttr
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|dma_ic_stash_on
operator|=
call|(
name|bool
call|)
argument_list|(
name|intContextCacheAttr
operator|==
name|e_FM_DMA_STASH
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaHdrAttr
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmDmaCacheOption
name|headerCacheAttr
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|dma_header_stash_on
operator|=
call|(
name|bool
call|)
argument_list|(
name|headerCacheAttr
operator|==
name|e_FM_DMA_STASH
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaScatterGatherAttr
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmDmaCacheOption
name|scatterGatherCacheAttr
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|dma_sg_stash_on
operator|=
call|(
name|bool
call|)
argument_list|(
name|scatterGatherCacheAttr
operator|==
name|e_FM_DMA_STASH
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigDmaWriteOptimize
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|optimize
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for Tx ports"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|dma_write_optimize
operator|=
name|optimize
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
name|t_Error
name|FM_PORT_ConfigNoScatherGather
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|noScatherGather
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|UNUSED
argument_list|(
name|noScatherGather
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|noScatherGather
operator|=
name|noScatherGather
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_function
name|t_Error
name|FM_PORT_ConfigForwardReuseIntContext
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|forwardReuse
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|forwardReuseIntContext
operator|=
name|forwardReuse
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigMaxFrameLength
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint16_t
name|length
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|maxFrameLength
operator|=
name|length
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
end_ifdef

begin_function
name|t_Error
name|FM_PORT_ConfigBCBWorkaround
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|bcbWorkaround
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
end_comment

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/*       Hidden-DEBUG Only API                      */
end_comment

begin_comment
comment|/****************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_ConfigTxFifoMinFillLevel
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|minFillLevel
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_min_level
operator|=
name|minFillLevel
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigFifoDeqPipelineDepth
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|deqPipelineDepth
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Not available for IM ports!"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_deq_pipeline_depth
operator|=
name|deqPipelineDepth
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigTxFifoLowComfLevel
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|fifoLowComfLevel
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|tx_fifo_low_comf_level
operator|=
name|fifoLowComfLevel
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigRxFifoThreshold
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|fifoThreshold
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|rx_fifo_thr
operator|=
name|fifoThreshold
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ConfigRxFifoPriElevationLevel
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
name|priElevationLevel
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|p_FmPortDriverParam
operator|->
name|dfltCfg
operator|.
name|rx_pri_elevation
operator|=
name|priElevationLevel
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************/
end_comment

begin_comment
comment|/*       API Run-time Control unit functions        */
end_comment

begin_comment
comment|/****************************************************/
end_comment

begin_function
name|t_Error
name|FM_PORT_SetNumOfOpenDmas
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_NumOfOpenDmas
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p_NumOfOpenDmas
operator|->
name|num
operator|)
operator|||
operator|(
name|p_NumOfOpenDmas
operator|->
name|num
operator|>
name|MAX_NUM_OF_DMAS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas-num can't be larger than %d"
operator|,
name|MAX_NUM_OF_DMAS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_NumOfOpenDmas
operator|->
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_DMAS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"openDmas-extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_DMAS
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmSetNumOfOpenDmas
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_NumOfOpenDmas
operator|->
name|num
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_NumOfOpenDmas
operator|->
name|extra
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|openDmas
argument_list|,
name|p_NumOfOpenDmas
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetNumOfTasks
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_NumOfTasks
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p_NumOfTasks
operator|->
name|num
operator|)
operator|||
operator|(
name|p_NumOfTasks
operator|->
name|num
operator|>
name|MAX_NUM_OF_TASKS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"NumOfTasks-num can't be larger than %d"
operator|,
name|MAX_NUM_OF_TASKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_NumOfTasks
operator|->
name|extra
operator|>
name|MAX_NUM_OF_EXTRA_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"NumOfTasks-extra can't be larger than %d"
operator|,
name|MAX_NUM_OF_EXTRA_TASKS
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmSetNumOfTasks
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_NumOfTasks
operator|->
name|num
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_NumOfTasks
operator|->
name|extra
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* update driver's struct */
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|tasks
argument_list|,
name|p_NumOfTasks
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetSizeOfFifo
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRsrc
modifier|*
name|p_SizeOfFifo
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SizeOfFifo
operator|->
name|num
operator|||
operator|(
name|p_SizeOfFifo
operator|->
name|num
operator|>
name|MAX_PORT_FIFO_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"SizeOfFifo-num has to be in the range of 256 - %d"
operator|,
name|MAX_PORT_FIFO_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SizeOfFifo
operator|->
name|num
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"SizeOfFifo-num has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
comment|/* extra FIFO size (allowed only to Rx ports) */
if|if
condition|(
name|p_SizeOfFifo
operator|->
name|extra
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"SizeOfFifo-extra has to be divisible by %d"
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_SizeOfFifo
operator|->
name|extra
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" No SizeOfFifo-extra for non Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPort
operator|->
name|fifoBufs
argument_list|,
name|p_SizeOfFifo
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortRsrc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we do not change user's parameter */
name|err
operator|=
name|VerifySizeOfFifo
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmSetSizeOfFifo
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|&
name|p_SizeOfFifo
operator|->
name|num
argument_list|,
operator|&
name|p_SizeOfFifo
operator|->
name|extra
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PORT_GetBufferDataOffset
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|dataOffset
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|FM_PORT_GetBufferICInfo
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|pcdInfoOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|pcdInfoOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|t_FmPrsResult
modifier|*
name|FM_PORT_GetBufferPrsResult
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|t_FmPrsResult
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|prsResultOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|uint64_t
modifier|*
name|FM_PORT_GetBufferTimeStamp
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint64_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|timeStampOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|FM_PORT_GetBufferHashResult
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|char
modifier|*
name|p_Data
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
operator|==
name|ILLEGAL_BASE
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Data
argument_list|,
name|p_FmPort
operator|->
name|bufferOffsets
operator|.
name|hashResultOffset
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_Disable
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|FmPortImDisable
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_disable
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EBUSY
condition|)
block|{
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"%s: BMI or QMI is Busy. Port forced down"
operator|,
name|p_FmPort
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_disable"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|enabled
operator|=
name|FALSE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_Enable
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* Used by FM_PORT_Free routine as indication      if to disable port. Thus set it to TRUE prior      to enabling itself. This way if part of enable      process fails there will be still things      to disable during Free. For example, if BMI      enable succeeded but QMI failed, still  BMI      needs to be disabled by Free. */
name|p_FmPort
operator|->
name|enabled
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|FmPortImEnable
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_enable
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_enable"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetRateLimit
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortRateLimit
modifier|*
name|p_RateLimit
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint8_t
name|factor
decl_stmt|,
name|countUnitBit
decl_stmt|;
name|uint16_t
name|baseGran
decl_stmt|;
name|struct
name|fman_port_rate_limiter
name|params
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
name|baseGran
operator|=
name|BMI_RATE_LIMIT_GRAN_TX
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|baseGran
operator|=
name|BMI_RATE_LIMIT_GRAN_OP
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx and Offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
name|countUnitBit
operator|=
operator|(
name|uint8_t
operator|)
name|FmGetTimeStampScale
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
comment|/* TimeStamp per nano seconds units */
comment|/* normally, we use 1 usec as the reference count */
name|factor
operator|=
literal|1
expr_stmt|;
comment|/* if ratelimit is too small for a 1usec factor, multiply the factor */
while|while
condition|(
name|p_RateLimit
operator|->
name|rateLimit
operator|<
name|baseGran
operator|/
name|factor
condition|)
block|{
if|if
condition|(
name|countUnitBit
operator|==
literal|31
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Rate limit is too small"
operator|)
argument_list|)
expr_stmt|;
name|countUnitBit
operator|++
expr_stmt|;
name|factor
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
if|if
condition|(
name|p_RateLimit
operator|->
name|rateLimit
operator|>
operator|(
operator|(
name|uint32_t
operator|)
name|baseGran
operator|*
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|*
operator|(
name|uint32_t
operator|)
name|factor
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Rate limit is too large"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_RateLimit
operator|->
name|maxBurstSize
operator|||
operator|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|>
name|BMI_RATE_LIMIT_MAX_BURST_SIZE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxBurstSize must be between 1K and %dk"
operator|,
name|BMI_RATE_LIMIT_MAX_BURST_SIZE
operator|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|count_1micro_bit
operator|=
operator|(
name|uint8_t
operator|)
name|FmGetTimeStampScale
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|params
operator|.
name|high_burst_size_gran
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|burst_size
operator|=
name|p_RateLimit
operator|->
name|maxBurstSize
expr_stmt|;
name|params
operator|.
name|rate
operator|=
name|p_RateLimit
operator|->
name|rateLimit
expr_stmt|;
name|params
operator|.
name|rate_factor
operator|=
name|E_FMAN_PORT_RATE_DOWN_NONE
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
block|{
ifndef|#
directive|ifndef
name|FM_NO_ADVANCED_RATE_LIMITER
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|4
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
operator|)
condition|)
block|{
name|params
operator|.
name|high_burst_size_gran
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ! FM_NO_ADVANCED_RATE_LIMITER */
block|{
if|if
condition|(
name|p_RateLimit
operator|->
name|rateLimitDivider
operator|!=
name|e_FM_PORT_DUAL_RATE_LIMITER_NONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PORT_ConfigDualRateLimitScaleDown"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|%
literal|1000
condition|)
block|{
name|p_RateLimit
operator|->
name|maxBurstSize
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|/
literal|1000
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"rateLimit.maxBurstSize rounded up to %d"
operator|,
operator|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|/
literal|1000
operator|+
literal|1
operator|)
operator|*
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p_RateLimit
operator|->
name|maxBurstSize
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_RateLimit
operator|->
name|maxBurstSize
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|rate_factor
operator|=
operator|(
expr|enum
name|fman_port_rate_limiter_scale_down
operator|)
name|p_RateLimit
operator|->
name|rateLimitDivider
expr_stmt|;
name|params
operator|.
name|burst_size
operator|=
name|p_RateLimit
operator|->
name|maxBurstSize
expr_stmt|;
block|}
name|err
operator|=
name|fman_port_set_rate_limiter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_rate_limiter"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_DeleteRateLimit
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Tx and Offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_delete_rate_limiter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_rate_limiter"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPfcPrioritiesMappingToQmanWQ
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|prio
parameter_list|,
name|uint8_t
name|wq
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint32_t
name|wqTmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"PFC mapping is available for Tx ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prio
operator|>
literal|7
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"PFC priority (%d) is out of range (0-7)"
operator|,
name|prio
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wq
operator|>
literal|7
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"WQ (%d) is out of range (0-7)"
operator|,
name|wq
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tpfcm
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmpReg
operator|&=
operator|~
operator|(
literal|0xf
operator|<<
operator|(
operator|(
literal|7
operator|-
name|prio
operator|)
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|wqTmpReg
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|wq
operator|<<
operator|(
operator|(
literal|7
operator|-
name|prio
operator|)
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|tmpReg
operator||=
name|wqTmpReg
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tpfcm
index|[
literal|0
index|]
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetFrameQueueCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_port_set_queue_cnt_mode
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPerformanceCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_set_perf_cnt_mode
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_perf_cnt_mode"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPerformanceCountersParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortPerformanceCnt
modifier|*
name|p_FmPortPerformanceCnt
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|struct
name|fman_port_perf_cnt_params
name|params
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* check parameters */
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
operator|>
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"taskCompVal (%d) has to be in the range of 1 - %d (current value)!"
operator|,
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
operator|,
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
operator|>
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"dmaCompVal (%d) has to be in the range of 1 - %d (current value)!"
operator|,
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
operator|,
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|>
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoCompVal (%d) has to be in the range of 256 - %d (current value)!"
operator|,
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|%
name|BMI_FIFO_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fifoCompVal (%d) has to be divisible by %d"
operator|,
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
operator|,
name|BMI_FIFO_UNITS
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|>
name|MAX_PERFORMANCE_RX_QUEUE_COMP
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d"
operator|,
name|MAX_PERFORMANCE_RX_QUEUE_COMP
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_TX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_TX
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|||
operator|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
operator|>
name|MAX_PERFORMANCE_TX_QUEUE_COMP
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d"
operator|,
name|MAX_PERFORMANCE_TX_QUEUE_COMP
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
case|:
if|if
condition|(
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"performanceCnt.queueCompVal is not relevant for H/O ports."
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|task_val
operator|=
name|p_FmPortPerformanceCnt
operator|->
name|taskCompVal
expr_stmt|;
name|params
operator|.
name|queue_val
operator|=
name|p_FmPortPerformanceCnt
operator|->
name|queueCompVal
expr_stmt|;
name|params
operator|.
name|dma_val
operator|=
name|p_FmPortPerformanceCnt
operator|->
name|dmaCompVal
expr_stmt|;
name|params
operator|.
name|fifo_val
operator|=
name|p_FmPortPerformanceCnt
operator|->
name|fifoCompVal
expr_stmt|;
name|err
operator|=
name|fman_port_set_perf_cnt_params
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_perf_cnt_params"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_AnalyzePerformanceParams
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPortPerformanceCnt
name|currParams
decl_stmt|,
name|savedParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|bool
name|underTest
decl_stmt|,
name|failed
init|=
name|FALSE
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|XX_Print
argument_list|(
literal|"Analyzing Performance parameters for port (type %d, id%d)\n"
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|)
expr_stmt|;
name|currParams
operator|.
name|taskCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_HOST_COMMAND
operator|)
condition|)
name|currParams
operator|.
name|queueCompVal
operator|=
literal|0
expr_stmt|;
else|else
name|currParams
operator|.
name|queueCompVal
operator|=
literal|1
expr_stmt|;
name|currParams
operator|.
name|dmaCompVal
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
expr_stmt|;
name|currParams
operator|.
name|fifoCompVal
operator|=
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ClearPerfCnts
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|currParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|XX_UDelay
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
condition|)
block|{
name|XX_Print
argument_list|(
literal|"Max num of defined port tasks (%d) utilized - Please enlarge\n"
argument_list|,
name|p_FmPort
operator|->
name|tasks
operator|.
name|num
argument_list|)
expr_stmt|;
name|failed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
condition|)
block|{
name|XX_Print
argument_list|(
literal|"Max num of defined port openDmas (%d) utilized - Please enlarge\n"
argument_list|,
name|p_FmPort
operator|->
name|openDmas
operator|.
name|num
argument_list|)
expr_stmt|;
name|failed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
condition|)
block|{
name|XX_Print
argument_list|(
literal|"Max size of defined port fifo (%d) utilized - Please enlarge\n"
argument_list|,
name|p_FmPort
operator|->
name|fifoBufs
operator|.
name|num
argument_list|)
expr_stmt|;
name|failed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|savedParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|savedParams
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|underTest
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|currParams
operator|.
name|taskCompVal
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|savedParams
operator|.
name|taskCompVal
condition|)
block|{
name|currParams
operator|.
name|taskCompVal
operator|--
expr_stmt|;
name|underTest
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|currParams
operator|.
name|dmaCompVal
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|savedParams
operator|.
name|dmaCompVal
condition|)
block|{
name|currParams
operator|.
name|dmaCompVal
operator|--
expr_stmt|;
name|underTest
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|currParams
operator|.
name|fifoCompVal
operator|!=
name|BMI_FIFO_UNITS
operator|)
operator|&&
operator|!
name|savedParams
operator|.
name|fifoCompVal
condition|)
block|{
name|currParams
operator|.
name|fifoCompVal
operator|-=
name|BMI_FIFO_UNITS
expr_stmt|;
name|underTest
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|underTest
condition|)
break|break;
name|ClearPerfCnts
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PORT_SetPerformanceCountersParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|currParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|XX_UDelay
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|FM_PORT_SetPerformanceCounters
argument_list|(
name|p_FmPort
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savedParams
operator|.
name|taskCompVal
operator|&&
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
condition|)
name|savedParams
operator|.
name|taskCompVal
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|currParams
operator|.
name|taskCompVal
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savedParams
operator|.
name|dmaCompVal
operator|&&
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
condition|)
name|savedParams
operator|.
name|dmaCompVal
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|currParams
operator|.
name|dmaCompVal
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savedParams
operator|.
name|fifoCompVal
operator|&&
name|FM_PORT_GetCounter
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
condition|)
name|savedParams
operator|.
name|fifoCompVal
operator|=
name|currParams
operator|.
name|fifoCompVal
operator|+
operator|(
literal|2
operator|*
name|BMI_FIFO_UNITS
operator|)
expr_stmt|;
block|}
name|XX_Print
argument_list|(
literal|"best vals: tasks %d, dmas %d, fifos %d\n"
argument_list|,
name|savedParams
operator|.
name|taskCompVal
argument_list|,
name|savedParams
operator|.
name|dmaCompVal
argument_list|,
name|savedParams
operator|.
name|fifoCompVal
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetStatisticsCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_set_stats_cnt_mode
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_stats_cnt_mode"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetErrorsRoute
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|fmPortFrameErrSelect_t
name|errs
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_ErrDiscard
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|UNUSED
argument_list|(
name|p_ErrDiscard
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_set_err_mask
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
operator|(
name|uint32_t
operator|)
name|errs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_err_mask"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_ERROR_VSP_NO_MATCH_SW006
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|>=
literal|6
condition|)
block|{
name|t_FmPcdCtrlParamsPage
modifier|*
name|p_ParamsPage
decl_stmt|;
name|FmPortSetGprFunc
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_GPR_MURAM_PAGE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p_ParamsPage
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ParamsPage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_ErrDiscard
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsdm
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_ErrDiscard
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsdm
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|errorsDiscardMask
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_ErrDiscard
argument_list|)
operator||
name|errs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_ERROR_VSP_NO_MATCH_SW006 */
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetAllocBufCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|poolId
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|poolId
operator|<
name|BM_MAX_NUM_OF_POOLS
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_port_set_bpool_cnt_mode
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|poolId
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_set_bpool_cnt_mode"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_GetBmiCounters
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortBmiStats
modifier|*
name|p_BmiStats
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
name|p_BmiStats
operator|->
name|cntCycle
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_CYCLE
argument_list|)
expr_stmt|;
comment|/* fmbm_rccn */
name|p_BmiStats
operator|->
name|cntTaskUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_rtuc */
name|p_BmiStats
operator|->
name|cntQueueUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_rrquc */
name|p_BmiStats
operator|->
name|cntDmaUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_rduc */
name|p_BmiStats
operator|->
name|cntFifoUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_rfuc */
name|p_BmiStats
operator|->
name|cntRxPauseActivation
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION
argument_list|)
expr_stmt|;
comment|/* fmbm_rpac */
name|p_BmiStats
operator|->
name|cntFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_rfrc */
name|p_BmiStats
operator|->
name|cntDiscardFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_rfdc */
name|p_BmiStats
operator|->
name|cntDeallocBuf
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
argument_list|)
expr_stmt|;
comment|/* fmbm_rbdc */
name|p_BmiStats
operator|->
name|cntRxBadFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_BAD_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_rfbc */
name|p_BmiStats
operator|->
name|cntRxLargeFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_LARGE_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_rlfc */
name|p_BmiStats
operator|->
name|cntRxFilterFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_rffc */
name|p_BmiStats
operator|->
name|cntRxListDmaErr
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
argument_list|)
expr_stmt|;
comment|/* fmbm_rfldec */
name|p_BmiStats
operator|->
name|cntRxOutOfBuffersDiscard
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
argument_list|)
expr_stmt|;
comment|/* fmbm_rodc */
name|p_BmiStats
operator|->
name|cntWredDiscard
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntLengthErr
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntUnsupportedFormat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_TX_10G
operator|)
condition|)
block|{
name|p_BmiStats
operator|->
name|cntCycle
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_CYCLE
argument_list|)
expr_stmt|;
comment|/* fmbm_tccn */
name|p_BmiStats
operator|->
name|cntTaskUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_ttuc */
name|p_BmiStats
operator|->
name|cntQueueUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_QUEUE_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_ttcquc */
name|p_BmiStats
operator|->
name|cntDmaUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_tduc */
name|p_BmiStats
operator|->
name|cntFifoUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_tfuc */
name|p_BmiStats
operator|->
name|cntRxPauseActivation
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_tfrc */
name|p_BmiStats
operator|->
name|cntDiscardFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_tfdc */
name|p_BmiStats
operator|->
name|cntDeallocBuf
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
argument_list|)
expr_stmt|;
comment|/* fmbm_tbdc */
name|p_BmiStats
operator|->
name|cntRxBadFrame
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntRxLargeFrame
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntRxFilterFrame
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntRxListDmaErr
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntRxOutOfBuffersDiscard
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntWredDiscard
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntLengthErr
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_LENGTH_ERR
argument_list|)
expr_stmt|;
comment|/* fmbm_tfledc */
name|p_BmiStats
operator|->
name|cntUnsupportedFormat
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
argument_list|)
expr_stmt|;
comment|/* fmbm_tfufdc */
block|}
elseif|else
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
block|{
name|p_BmiStats
operator|->
name|cntCycle
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_CYCLE
argument_list|)
expr_stmt|;
comment|/* fmbm_occn */
name|p_BmiStats
operator|->
name|cntTaskUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_TASK_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_otuc */
name|p_BmiStats
operator|->
name|cntQueueUtil
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntDmaUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DMA_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_oduc */
name|p_BmiStats
operator|->
name|cntFifoUtil
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FIFO_UTIL
argument_list|)
expr_stmt|;
comment|/* fmbm_ofuc*/
name|p_BmiStats
operator|->
name|cntRxPauseActivation
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_ofrc */
name|p_BmiStats
operator|->
name|cntDiscardFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DISCARD_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_ofdc */
name|p_BmiStats
operator|->
name|cntDeallocBuf
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_DEALLOC_BUF
argument_list|)
expr_stmt|;
comment|/* fmbm_obdc*/
name|p_BmiStats
operator|->
name|cntRxBadFrame
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntRxLargeFrame
operator|=
literal|0
expr_stmt|;
name|p_BmiStats
operator|->
name|cntRxFilterFrame
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_FILTER_FRAME
argument_list|)
expr_stmt|;
comment|/* fmbm_offc */
name|p_BmiStats
operator|->
name|cntRxListDmaErr
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR
argument_list|)
expr_stmt|;
comment|/* fmbm_ofldec */
name|p_BmiStats
operator|->
name|cntRxOutOfBuffersDiscard
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD
argument_list|)
expr_stmt|;
comment|/* fmbm_rodc */
name|p_BmiStats
operator|->
name|cntWredDiscard
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_WRED_DISCARD
argument_list|)
expr_stmt|;
comment|/* fmbm_ofwdc */
name|p_BmiStats
operator|->
name|cntLengthErr
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_LENGTH_ERR
argument_list|)
expr_stmt|;
comment|/* fmbm_ofledc */
name|p_BmiStats
operator|->
name|cntUnsupportedFormat
operator|=
name|FM_PORT_GetCounter
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT
argument_list|)
expr_stmt|;
comment|/* fmbm_ofufdc */
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PORT_GetCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|bool
name|bmiCounter
init|=
name|FALSE
decl_stmt|;
name|enum
name|fman_port_stats_counters
name|statsType
decl_stmt|;
name|enum
name|fman_port_perf_counters
name|perfType
decl_stmt|;
name|enum
name|fman_port_qmi_counters
name|queueType
decl_stmt|;
name|bool
name|isStats
decl_stmt|;
name|t_Error
name|errCode
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
comment|/* check that counter is available for the port type */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bmiCounter
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|bmiCounter
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* BMI counters (or error - will be checked in BMI routine )*/
name|bmiCounter
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bmiCounter
condition|)
block|{
name|errCode
operator|=
name|BmiPortCheckAndGetCounterType
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|statsType
argument_list|,
operator|&
name|perfType
argument_list|,
operator|&
name|isStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isStats
condition|)
return|return
name|fman_port_get_stats_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|statsType
argument_list|)
return|;
else|else
return|return
name|fman_port_get_perf_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|perfType
argument_list|)
return|;
block|}
else|else
comment|/* QMI counter */
block|{
comment|/* check that counters are enabled */
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN_COUNTERS
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_ENQ_TOTAL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_DEQ_TOTAL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_DEQ_FROM_DFLT
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_DEQ_CONFIRM
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|fman_port_get_qmi_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|queueType
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ModifyCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|e_FmPortCounters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|bool
name|bmiCounter
init|=
name|FALSE
decl_stmt|;
name|enum
name|fman_port_stats_counters
name|statsType
decl_stmt|;
name|enum
name|fman_port_perf_counters
name|perfType
decl_stmt|;
name|enum
name|fman_port_qmi_counters
name|queueType
decl_stmt|;
name|bool
name|isStats
decl_stmt|;
name|t_Error
name|errCode
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
comment|/* check that counter is available for the port type */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for Rx ports"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|bmiCounter
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* BMI counters (or error - will be checked in BMI routine )*/
name|bmiCounter
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bmiCounter
condition|)
block|{
name|errCode
operator|=
name|BmiPortCheckAndGetCounterType
argument_list|(
name|p_FmPort
argument_list|,
name|counter
argument_list|,
operator|&
name|statsType
argument_list|,
operator|&
name|perfType
argument_list|,
operator|&
name|isStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|errCode
operator|!=
name|E_OK
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|errCode
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isStats
condition|)
name|fman_port_set_stats_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|statsType
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|fman_port_set_perf_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|perfType
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* QMI counter */
block|{
comment|/* check that counters are enabled */
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|port
operator|.
name|qmi_regs
operator|->
name|fmqm_pnc
argument_list|)
operator|&
name|QMI_PORT_CFG_EN_COUNTERS
operator|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set counter */
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_COUNTERS_ENQ_TOTAL
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_ENQ_TOTAL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_TOTAL
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_DEQ_TOTAL
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_DEQ_FROM_DFLT
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_COUNTERS_DEQ_CONFIRM
operator|)
case|:
name|queueType
operator|=
name|E_FMAN_PORT_DEQ_CONFIRM
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fman_port_set_qmi_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|queueType
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PORT_GetAllocBufCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|poolId
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for non-Rx ports"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|fman_port_get_bpool_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|poolId
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ModifyAllocBufCounter
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|poolId
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter is not available for non-Rx ports"
operator|)
argument_list|)
expr_stmt|;
name|fman_port_set_bpool_counter
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|poolId
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|bool
name|FM_PORT_IsStalled
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|bool
name|isStalled
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmIsPortStalled
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
operator|&
name|isStalled
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|isStalled
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_ReleaseStalled
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
return|return
name|FmResumeStalledPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetRxL4ChecksumVerify
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|bool
name|l4Checksum
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l4Checksum
condition|)
name|err
operator|=
name|fman_port_modify_rx_fd_bits
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|BMI_PORT_RFNE_FRWD_DCL4C
operator|>>
literal|24
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|fman_port_modify_rx_fd_bits
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|BMI_PORT_RFNE_FRWD_DCL4C
operator|>>
literal|24
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_modify_rx_fd_bits"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*       API Run-time PCD Control unit functions                             */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
name|t_Error
name|FM_PORT_VSPAlloc
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortVSPAllocParams
modifier|*
name|p_VSPParams
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiStorageProfileId
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_BmiVspe
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
init|=
literal|0
decl_stmt|,
name|tmp
init|=
literal|0
decl_stmt|;
name|uint16_t
name|hwStoragePrflId
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/*for numOfProfiles = 0 don't call this function*/
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_VSPParams
operator|->
name|numOfProfiles
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
comment|/*dfltRelativeId should be in the range of numOfProfiles*/
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_VSPParams
operator|->
name|dfltRelativeId
operator|<
name|p_VSPParams
operator|->
name|numOfProfiles
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
comment|/*p_FmPort should be from Rx type or OP*/
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_RX
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
comment|/*port should be disabled*/
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|enabled
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/*if its called for Rx port relevant Tx Port should be passed (initialized) too and it should be disabled*/
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|p_VSPParams
operator|->
name|h_FmTxPort
operator|&&
operator|!
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
operator|(
name|p_VSPParams
operator|->
name|h_FmTxPort
operator|)
operator|)
operator|->
name|enabled
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
comment|/*should be called before SetPCD - this port should be without PCD*/
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|pcdEngines
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/*alloc window of VSPs for this port*/
name|err
operator|=
name|FmVSPAllocForPort
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|,
name|p_VSPParams
operator|->
name|numOfProfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/*get absolute VSP ID for dfltRelative*/
name|err
operator|=
name|FmVSPGetAbsoluteProfileId
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_FmPort
operator|->
name|portType
argument_list|,
name|p_FmPort
operator|->
name|portId
argument_list|,
name|p_VSPParams
operator|->
name|dfltRelativeId
argument_list|,
operator|&
name|hwStoragePrflId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/*fill relevant registers for p_FmPort and relative TxPort in the case p_FmPort from Rx type*/
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiStorageProfileId
operator|=
operator|&
operator|(
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
operator|(
name|p_VSPParams
operator|->
name|h_FmTxPort
operator|)
operator|)
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tcfqid
operator|)
expr_stmt|;
name|p_BmiVspe
operator|=
operator|&
operator|(
operator|(
operator|(
name|t_FmPort
operator|*
operator|)
operator|(
name|p_VSPParams
operator|->
name|h_FmTxPort
operator|)
operator|)
operator|->
name|p_FmPortBmiRegs
operator|->
name|txPortBmiRegs
operator|.
name|fmbm_tfne
operator|)
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiStorageProfileId
argument_list|)
operator|&
operator|~
name|BMI_SP_ID_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|hwStoragePrflId
operator|<<
name|BMI_SP_ID_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiStorageProfileId
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiVspe
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiVspe
argument_list|,
name|tmpReg
operator||
name|BMI_SP_EN
argument_list|)
expr_stmt|;
name|p_BmiStorageProfileId
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfqid
expr_stmt|;
name|p_BmiVspe
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rpp
expr_stmt|;
name|hwStoragePrflId
operator|=
name|p_VSPParams
operator|->
name|dfltRelativeId
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|tmpReg
operator|=
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_FETCH_ALL_FRAME
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortQmiRegs
operator|->
name|nonRxQmiRegs
operator|.
name|fmqm_pndn
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|p_BmiStorageProfileId
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofqid
expr_stmt|;
name|p_BmiVspe
operator|=
operator|&
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_opp
expr_stmt|;
name|tmp
operator||=
name|BMI_EBD_EN
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|vspe
operator|=
name|TRUE
expr_stmt|;
name|p_FmPort
operator|->
name|dfltRelativeId
operator|=
name|p_VSPParams
operator|->
name|dfltRelativeId
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiStorageProfileId
argument_list|)
operator|&
operator|~
name|BMI_SP_ID_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|hwStoragePrflId
operator|<<
name|BMI_SP_ID_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiStorageProfileId
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiVspe
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiVspe
argument_list|,
name|tmpReg
operator||
name|BMI_SP_EN
operator||
name|tmp
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_function
name|t_Error
name|FM_PORT_PcdPlcrAllocProfiles
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|p_FmPort
operator|->
name|h_FmPcd
operator|=
name|FmGetPcdHandle
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
if|if
condition|(
name|numOfProfiles
condition|)
block|{
name|err
operator|=
name|FmPcdPlcrAllocProfiles
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|numOfProfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* set the port handle within the PCD policer, even if no profiles defined */
name|FmPcdPortRegister
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdPlcrFreeProfiles
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdPlcrFreeProfiles
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdKgModifyInitialScheme
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdKgSchemeSelect
modifier|*
name|p_FmPcdKgScheme
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiHpnia
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
operator|)
condition|?
name|NIA_KG_CC_EN
else|:
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfpne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofpne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
comment|/* if we want to change to direct scheme, we need to check that this scheme is valid */
if|if
condition|(
name|p_FmPcdKgScheme
operator|->
name|direct
condition|)
block|{
name|physicalSchemeId
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_FmPcdKgScheme
operator|->
name|h_DirectScheme
argument_list|)
expr_stmt|;
comment|/* check that this scheme is bound to this port */
if|if
condition|(
operator|!
operator|(
name|p_FmPort
operator|->
name|schemesPerPortVector
operator|&
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|physicalSchemeId
operator|)
argument_list|)
operator|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"called with a scheme that is not bound to this port"
operator|)
argument_list|)
expr_stmt|;
block|}
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|>=
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"called with invalid Scheme "
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_FmPcdKgScheme
operator|->
name|h_DirectScheme
argument_list|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"called with uninitialized Scheme "
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiHpnia
argument_list|,
name|NIA_ENG_KG
operator||
name|tmpReg
operator||
name|NIA_KG_DIRECT
operator||
operator|(
name|uint32_t
operator|)
name|physicalSchemeId
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* change to indirect scheme */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiHpnia
argument_list|,
name|NIA_ENG_KG
operator||
name|tmpReg
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdPlcrModifyInitialProfile
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_Profile
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiHpnia
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint16_t
name|absoluteProfileId
init|=
name|FmPcdPlcrProfileGetAbsoluteId
argument_list|(
name|h_Profile
argument_list|)
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PLCR
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* check relevance of this routine  - only when policer is used      directly after BMI or Parser */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
expr_stmt|;
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfpne
expr_stmt|;
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofne
expr_stmt|;
name|p_BmiHpnia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofpne
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"Invalid profile"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|NIA_ENG_PLCR
operator||
name|NIA_PLCR_ABSOLUTE
operator||
name|absoluteProfileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
condition|)
comment|/* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
block|{
comment|/* update BMI HPNIA */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiHpnia
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* e_FM_PCD_SUPPORT_PLCR_ONLY */
block|{
comment|/* rfne may contain FDCS bits, so first we read them. */
name|tmpReg
operator||=
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
name|BMI_RFNE_FDCS_MASK
operator|)
expr_stmt|;
comment|/* update BMI NIA */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdCcModifyTree
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_CcTree
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiCcBase
init|=
name|NULL
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_BmiNia
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|ccTreePhysOffset
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_CcTree
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independent mode ports only"
operator|)
argument_list|)
expr_stmt|;
comment|/* get PCD registers pointers */
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rfne
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiNia
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_ofne
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check that current NIA is BMI to BMI */
if|if
condition|(
operator|(
name|GET_UINT32
argument_list|(
operator|*
name|p_BmiNia
argument_list|)
operator|&
operator|~
name|BMI_RFNE_FDCS_MASK
operator|)
operator|!=
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"may be called only for ports in BMI-to-BMI state."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_CC
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|h_IpReassemblyManip
condition|)
block|{
name|err
operator|=
name|FmPcdCcTreeAddIPR
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|h_CcTree
argument_list|,
name|NULL
argument_list|,
name|p_FmPort
operator|->
name|h_IpReassemblyManip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
condition|)
block|{
name|err
operator|=
name|FmPcdCcTreeAddCPR
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|h_CcTree
argument_list|,
name|NULL
argument_list|,
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|p_FmPort
operator|->
name|portType
condition|)
block|{
case|case
operator|(
name|e_FM_PORT_TYPE_RX_10G
operator|)
case|:
case|case
operator|(
name|e_FM_PORT_TYPE_RX
operator|)
case|:
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|rx
operator|.
name|fmbm_rccb
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
case|:
name|p_BmiCcBase
operator|=
operator|&
name|p_FmPort
operator|->
name|port
operator|.
name|bmi_regs
operator|->
name|oh
operator|.
name|fmbm_occb
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcBindTree
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|NULL
argument_list|,
name|h_CcTree
argument_list|,
operator|&
name|ccTreePhysOffset
argument_list|,
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_BmiCcBase
argument_list|,
name|ccTreePhysOffset
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|ccTreeId
operator|=
name|h_CcTree
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Coarse Classification not defined for this port."
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_AttachPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independent mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
name|p_FmPort
operator|->
name|pcdEngines
operator||=
name|FM_PCD_CC
expr_stmt|;
name|err
operator|=
name|AttachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_DetachPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independent mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|DetachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
name|p_FmPort
operator|->
name|pcdEngines
operator|&=
operator|~
name|FM_PCD_CC
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_SetPCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortPcdParams
modifier|*
name|p_PcdParam
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPortPcdParams
name|modifiedPcdParams
decl_stmt|,
modifier|*
name|p_PcdParams
decl_stmt|;
name|t_FmPcdCcTreeParams
modifier|*
name|p_FmPcdCcTreeParams
decl_stmt|;
name|t_FmPortPcdCcParams
name|fmPortPcdCcParams
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_PcdParam
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independent mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|p_FmPort
operator|->
name|h_FmPcd
operator|=
name|FmGetPcdHandle
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_PcdParam
operator|->
name|p_CcParams
operator|&&
operator|!
name|p_PcdParam
operator|->
name|p_CcParams
operator|->
name|h_CcTree
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"Tree handle must be given if CC is required"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|modifiedPcdParams
argument_list|,
name|p_PcdParam
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortPcdParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_PcdParams
operator|=
operator|&
name|modifiedPcdParams
expr_stmt|;
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|h_IpReassemblyManip
operator|)
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|h_CapwapReassemblyManip
operator|)
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
condition|)
block|{
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|!=
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|!=
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|!=
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|!=
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR
operator|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"pcdSupport must have KG for supporting Reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|h_IpReassemblyManip
operator|=
name|p_PcdParams
operator|->
name|h_IpReassemblyManip
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|h_IpReassemblyManip
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|h_CapwapReassemblyManip
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Either IP-R or CAPWAP-R is allowed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_PcdParams
operator|->
name|h_CapwapReassemblyManip
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"CAPWAP-R is allowed only on offline-port"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_PcdParams
operator|->
name|h_CapwapReassemblyManip
condition|)
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
operator|=
name|p_PcdParams
operator|->
name|h_CapwapReassemblyManip
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
operator|!
name|p_PcdParams
operator|->
name|p_CcParams
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
operator|)
operator|||
operator|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR
operator|)
operator|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"PCD initialization structure is not consistent with pcdSupport"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* No user-tree, need to build internal tree */
name|p_FmPcdCcTreeParams
operator|=
operator|(
name|t_FmPcdCcTreeParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcTreeParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdCcTreeParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"p_FmPcdCcTreeParams"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcdCcTreeParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcTreeParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcdCcTreeParams
operator|->
name|h_NetEnv
operator|=
name|p_PcdParams
operator|->
name|h_NetEnv
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|FM_PCD_CcRootBuild
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPcdCcTreeParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcdCcTreeParams
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"FM_PCD_CcBuildTree for Reassembly failed"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_PcdParams
operator|->
name|pcdSupport
operator|==
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG
condition|)
name|p_PcdParams
operator|->
name|pcdSupport
operator|=
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC
expr_stmt|;
else|else
name|p_PcdParams
operator|->
name|pcdSupport
operator|=
name|e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortPcdCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortPcdCcParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmPortPcdCcParams
operator|.
name|h_CcTree
operator|=
name|p_FmPort
operator|->
name|h_ReassemblyTree
expr_stmt|;
name|p_PcdParams
operator|->
name|p_CcParams
operator|=
operator|&
name|fmPortPcdCcParams
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcdCcTreeParams
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|h_IpReassemblyManip
condition|)
name|err
operator|=
name|FmPcdCcTreeAddIPR
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_PcdParams
operator|->
name|p_CcParams
operator|->
name|h_CcTree
argument_list|,
name|p_PcdParams
operator|->
name|h_NetEnv
argument_list|,
name|p_FmPort
operator|->
name|h_IpReassemblyManip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
elseif|else
if|if
condition|(
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
condition|)
name|err
operator|=
name|FmPcdCcTreeAddCPR
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_PcdParams
operator|->
name|p_CcParams
operator|->
name|h_CcTree
argument_list|,
name|p_PcdParams
operator|->
name|h_NetEnv
argument_list|,
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Try LockAll - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|SetPcd
argument_list|(
name|h_FmPort
argument_list|,
name|p_PcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|&&
operator|(
name|p_PcdParams
operator|->
name|p_PrsParams
operator|->
name|includeInPrsStatistics
operator|)
condition|)
block|{
name|err
operator|=
name|FmPcdPrsIncludePortInStatistics
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|includeInPrsStatistics
operator|=
name|TRUE
expr_stmt|;
block|}
name|FmPcdIncNetEnvOwners
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
block|{
ifdef|#
directive|ifdef
name|FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
comment|/* The following function must be locked */
name|FmPcdKgCcGetSetParams
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|,
name|UPDATE_KG_NIA_CC_WA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
block|{
name|t_FmPcdCtrlParamsPage
modifier|*
name|p_ParamsPage
decl_stmt|;
name|FmPortSetGprFunc
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_GPR_MURAM_PAGE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p_ParamsPage
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ParamsPage
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|postBmiFetchNia
argument_list|,
name|p_FmPort
operator|->
name|savedBmiNia
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* Set post-bmi-fetch nia */
name|p_FmPort
operator|->
name|savedBmiNia
operator|&=
name|BMI_RFNE_FDCS_MASK
expr_stmt|;
name|p_FmPort
operator|->
name|savedBmiNia
operator||=
operator|(
name|NIA_FM_CTL_AC_POST_BMI_FETCH
operator||
name|NIA_ENG_FM_CTL
operator|)
expr_stmt|;
comment|/* Set pre-bmi-fetch nia */
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNDN
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
operator|(
name|NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME
operator||
name|NIA_ENG_FM_CTL
operator|)
expr_stmt|;
else|#
directive|else
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
operator|(
name|NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER
operator||
name|NIA_ENG_FM_CTL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|p_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
comment|/* Set pop-to-next-step nia */
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
condition|)
block|{
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|GET_NIA_FPNE
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* Set post-bmi-prepare-to-enq nia */
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_FENE
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
operator|(
name|NIA_FM_CTL_AC_POST_BMI_ENQ
operator||
name|NIA_ENG_FM_CTL
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|h_IpReassemblyManip
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
condition|)
block|{
comment|/* Overwrite post-bmi-prepare-to-enq nia */
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_FENE
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
operator|(
name|NIA_FM_CTL_AC_POST_BMI_ENQ_ORR
operator||
name|NIA_ENG_FM_CTL
operator||
name|NIA_ORDER_RESTOR
operator|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|overwrite
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
comment|/* Set the ORR bit (for order-restoration) */
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_FPNE
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|nia
operator||
name|NIA_ORDER_RESTOR
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
block|{
name|t_FmPcdCtrlParamsPage
modifier|*
name|p_ParamsPage
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_CMNE
expr_stmt|;
if|if
condition|(
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
else|else
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|FmPortSetGprFunc
argument_list|(
name|p_FmPort
argument_list|,
name|e_FM_PORT_GPR_MURAM_PAGE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p_ParamsPage
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ParamsPage
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|,
name|GET_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|)
operator||
name|FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|h_IpReassemblyManip
operator|)
operator|||
operator|(
name|p_FmPort
operator|->
name|h_CapwapReassemblyManip
operator|)
condition|)
block|{
if|if
condition|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
condition|)
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|discardMask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|ohPortBmiRegs
operator|.
name|fmbm_ofsdm
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|discardMask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rfsdm
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FM_ERROR_VSP_NO_MATCH_SW006
if|if
condition|(
name|p_FmPort
operator|->
name|vspe
condition|)
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|,
name|GET_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|misc
argument_list|)
operator||
operator|(
name|p_FmPort
operator|->
name|dfltRelativeId
operator|&
name|FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_ERROR_VSP_NO_MATCH_SW006 */
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|err
operator|=
name|AttachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeletePcd
argument_list|(
name|p_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_DeletePCD
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|imEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for non-independant mode ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_OPERATION
argument_list|,
operator|(
literal|"available for Rx and offline parsing ports only"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|DetachPCD
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|FmPcdDecNetEnvOwners
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
comment|/* we do it anyway, instead of checking if included */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_PRS
operator|)
operator|&&
name|p_FmPort
operator|->
name|includeInPrsStatistics
condition|)
block|{
name|FmPcdPrsIncludePortInStatistics
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPort
operator|->
name|hardwarePortId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p_FmPort
operator|->
name|includeInPrsStatistics
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Try LockAll - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|DeletePcd
argument_list|(
name|h_FmPort
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
condition|)
block|{
name|err
operator|=
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPort
operator|->
name|h_ReassemblyTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_FmPort
operator|->
name|h_ReassemblyTree
operator|=
name|NULL
expr_stmt|;
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdKgBindSchemes
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdPortSchemesParams
modifier|*
name|p_PortScheme
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpScmVec
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|schemeBind
operator|.
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|schemeBind
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|schemeBind
operator|.
name|numOfSchemes
operator|=
name|p_PortScheme
operator|->
name|numOfSchemes
expr_stmt|;
name|schemeBind
operator|.
name|useClsPlan
operator|=
name|p_FmPort
operator|->
name|useClsPlan
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schemeBind
operator|.
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_PortScheme
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* build vector */
name|tmpScmVec
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdKgBindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|E_OK
condition|)
name|p_FmPort
operator|->
name|schemesPerPortVector
operator||=
name|tmpScmVec
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
if|if
condition|(
operator|(
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|)
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PortScheme
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
name|FmPcdKgCcGetSetParams
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
name|p_PortScheme
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|,
name|UPDATE_KG_NIA_CC_WA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_PcdKgUnbindSchemes
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdPortSchemesParams
modifier|*
name|p_PortScheme
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|t_FmPcdKgInterModuleBindPortToSchemes
name|schemeBind
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpScmVec
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPort
operator|->
name|p_FmPortDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|pcdEngines
operator|&
name|FM_PCD_KG
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|schemeBind
operator|.
name|netEnvId
operator|=
name|p_FmPort
operator|->
name|netEnvId
expr_stmt|;
name|schemeBind
operator|.
name|hardwarePortId
operator|=
name|p_FmPort
operator|->
name|hardwarePortId
expr_stmt|;
name|schemeBind
operator|.
name|numOfSchemes
operator|=
name|p_PortScheme
operator|->
name|numOfSchemes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|schemeBind
operator|.
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_PortScheme
operator|->
name|h_Schemes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* build vector */
name|tmpScmVec
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
operator|(
name|uint32_t
operator|)
name|schemeBind
operator|.
name|schemesIds
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPort
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPort
operator|->
name|lock
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FM Port Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdKgUnbindPortToSchemes
argument_list|(
name|p_FmPort
operator|->
name|h_FmPcd
argument_list|,
operator|&
name|schemeBind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|E_OK
condition|)
name|p_FmPort
operator|->
name|schemesPerPortVector
operator|&=
operator|~
name|tmpScmVec
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPort
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_AddCongestionGrps
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortCongestionGrps
modifier|*
name|p_CongestionGrps
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint8_t
name|priorityTmpArray
index|[
name|FM_PORT_NUM_OF_CONGESTION_GRPS
index|]
decl_stmt|;
name|uint8_t
name|mod
decl_stmt|,
name|index
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|grpsMap
index|[
name|FMAN_PORT_CG_MAP_NUM
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|int
name|j
decl_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* un-necessary check of the indexes; probably will be needed in the future when there      will be more CGs available ....      for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)      if (p_CongestionGrps->congestionGrpsToConsider[i]>= FM_PORT_NUM_OF_CONGESTION_GRPS)      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));      */
ifdef|#
directive|ifdef
name|FM_NO_OP_OBSERVED_CGS
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* FM_NO_OP_OBSERVED_CGS */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx& OP ports only"
operator|)
argument_list|)
expr_stmt|;
comment|/* Prepare groups map array */
name|memset
argument_list|(
name|grpsMap
argument_list|,
literal|0
argument_list|,
name|FMAN_PORT_CG_MAP_NUM
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CongestionGrps
operator|->
name|numOfCongestionGrpsToConsider
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
operator|/
literal|32
argument_list|)
expr_stmt|;
name|mod
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
operator|%
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
name|grpsMap
index|[
literal|7
operator|-
name|index
index|]
operator||=
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
name|mod
argument_list|)
expr_stmt|;
else|else
name|grpsMap
index|[
literal|0
index|]
operator||=
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
name|mod
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|priorityTmpArray
argument_list|,
literal|0
argument_list|,
name|FM_PORT_NUM_OF_CONGESTION_GRPS
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CongestionGrps
operator|->
name|numOfCongestionGrpsToConsider
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FM_MAX_NUM_OF_PFC_PRIORITIES
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p_CongestionGrps
operator|->
name|pfcPrioritiesEn
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
name|priorityTmpArray
index|[
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
index|]
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|FM_MAX_NUM_OF_PFC_PRIORITIES
operator|-
name|j
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PORT_NUM_OF_CONGESTION_GRPS
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|FmSetCongestionGroupPFCpriority
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|i
argument_list|,
name|priorityTmpArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|err
operator|=
name|fman_port_add_congestion_grps
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|grpsMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_add_congestion_grps"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PORT_RemoveCongestionGrps
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPortCongestionGrps
modifier|*
name|p_CongestionGrps
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|uint8_t
name|mod
decl_stmt|,
name|index
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|grpsMap
index|[
name|FMAN_PORT_CG_MAP_NUM
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|FM_NO_OP_OBSERVED_CGS
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|revInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* FM_NO_OP_OBSERVED_CGS */
if|if
condition|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX_10G
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_RX
operator|)
operator|&&
operator|(
name|p_FmPort
operator|->
name|portType
operator|!=
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Available for Rx& OP ports only"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare groups map array */
name|memset
argument_list|(
name|grpsMap
argument_list|,
literal|0
argument_list|,
name|FMAN_PORT_CG_MAP_NUM
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CongestionGrps
operator|->
name|numOfCongestionGrpsToConsider
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
operator|/
literal|32
argument_list|)
expr_stmt|;
name|mod
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
operator|%
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPort
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|!=
literal|4
condition|)
name|grpsMap
index|[
literal|7
operator|-
name|index
index|]
operator||=
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
name|mod
argument_list|)
expr_stmt|;
else|else
name|grpsMap
index|[
literal|0
index|]
operator||=
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
name|mod
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CongestionGrps
operator|->
name|numOfCongestionGrpsToConsider
condition|;
name|i
operator|++
control|)
block|{
name|t_Error
name|err
init|=
name|FmSetCongestionGroupPFCpriority
argument_list|(
name|p_FmPort
operator|->
name|h_Fm
argument_list|,
name|p_CongestionGrps
operator|->
name|congestionGrpsToConsider
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|err
operator|=
name|fman_port_remove_congestion_grps
argument_list|(
operator|&
name|p_FmPort
operator|->
name|port
argument_list|,
name|grpsMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fman_port_remove_congestion_grps"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
name|t_Error
name|FM_PORT_GetIPv4OptionsCount
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint32_t
modifier|*
name|p_Ipv4OptionsCount
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPort
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_FmPort
operator|->
name|portType
operator|==
name|e_FM_PORT_TYPE_OH_OFFLINE_PARSING
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPort
operator|->
name|p_ParamsPage
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Ipv4OptionsCount
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
operator|*
name|p_Ipv4OptionsCount
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_ParamsPage
operator|->
name|ipfOptionsCounter
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_function
name|t_Error
name|FM_PORT_ConfigDsarSupport
parameter_list|(
name|t_Handle
name|h_FmPortRx
parameter_list|,
name|t_FmPortDsarTablesSizes
modifier|*
name|params
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPortRx
decl_stmt|;
name|p_FmPort
operator|->
name|deepSleepVars
operator|.
name|autoResMaxSizes
operator|=
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|t_FmPortDsarTablesSizes
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_FmPort
operator|->
name|deepSleepVars
operator|.
name|autoResMaxSizes
argument_list|,
name|params
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|t_FmPortDsarTablesSizes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPortConfigAutoResForDeepSleepSupport1
parameter_list|(
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|uint32_t
modifier|*
name|param_page
decl_stmt|;
name|t_FmPortDsarTablesSizes
modifier|*
name|params
init|=
name|p_FmPort
operator|->
name|deepSleepVars
operator|.
name|autoResMaxSizes
decl_stmt|;
name|t_ArCommonDesc
modifier|*
name|ArCommonDescPtr
decl_stmt|;
name|uint32_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|t_ArCommonDesc
argument_list|)
decl_stmt|;
comment|// ARP
comment|// should put here if (params->max_num_of_arp_entries)?
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarArpDescriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarArpBindingEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfArpEntries
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarArpStatistics
argument_list|)
expr_stmt|;
comment|//ICMPV4
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV4Descriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV4BindingEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfEchoIpv4Entries
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV4Statistics
argument_list|)
expr_stmt|;
comment|//ICMPV6
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Descriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6BindingEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfEchoIpv6Entries
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Statistics
argument_list|)
expr_stmt|;
comment|//ND
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarNdDescriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6BindingEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfNdpEntries
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Statistics
argument_list|)
expr_stmt|;
comment|//SNMP
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarSnmpDescriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarSnmpIpv4AddrTblEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfSnmpIPV4Entries
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarSnmpIpv6AddrTblEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfSnmpIPV6Entries
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_OidsTblEntry
argument_list|)
operator|*
name|params
operator|->
name|maxNumOfSnmpOidEntries
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|maxNumOfSnmpOidChar
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Statistics
argument_list|)
expr_stmt|;
comment|//filters
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|maxNumOfIpProtFiltering
expr_stmt|;
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|maxNumOfUdpPortFiltering
operator|*
sizeof|sizeof
argument_list|(
name|t_PortTblEntry
argument_list|)
expr_stmt|;
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|maxNumOfTcpPortFiltering
operator|*
sizeof|sizeof
argument_list|(
name|t_PortTblEntry
argument_list|)
expr_stmt|;
comment|// add here for more protocols
comment|// statistics
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_ArStatistics
argument_list|)
expr_stmt|;
name|ArCommonDescPtr
operator|=
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPort
operator|->
name|h_FmMuram
argument_list|,
name|size
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|param_page
operator|=
name|XX_PhysToVirt
argument_list|(
name|p_FmPort
operator|->
name|fmMuramPhysBaseAddr
operator|+
name|GET_UINT32
argument_list|(
name|p_FmPort
operator|->
name|p_FmPortBmiRegs
operator|->
name|rxPortBmiRegs
operator|.
name|fmbm_rgpr
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|param_page
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|ArCommonDescPtr
argument_list|)
operator|-
name|p_FmPort
operator|->
name|fmMuramPhysBaseAddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_FmPortDsarTablesSizes
modifier|*
name|FM_PORT_GetDsarTablesMaxSizes
parameter_list|(
name|t_Handle
name|h_FmPortRx
parameter_list|)
block|{
name|t_FmPort
modifier|*
name|p_FmPort
init|=
operator|(
name|t_FmPort
operator|*
operator|)
name|h_FmPortRx
decl_stmt|;
return|return
name|p_FmPort
operator|->
name|deepSleepVars
operator|.
name|autoResMaxSizes
return|;
block|}
end_function

begin_struct
struct|struct
name|arOffsets
block|{
name|uint32_t
name|arp
decl_stmt|;
name|uint32_t
name|nd
decl_stmt|;
name|uint32_t
name|icmpv4
decl_stmt|;
name|uint32_t
name|icmpv6
decl_stmt|;
name|uint32_t
name|snmp
decl_stmt|;
name|uint32_t
name|stats
decl_stmt|;
name|uint32_t
name|filtIp
decl_stmt|;
name|uint32_t
name|filtUdp
decl_stmt|;
name|uint32_t
name|filtTcp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|uint32_t
name|AR_ComputeOffsets
parameter_list|(
name|struct
name|arOffsets
modifier|*
name|of
parameter_list|,
name|struct
name|t_FmPortDsarParams
modifier|*
name|params
parameter_list|,
name|t_FmPort
modifier|*
name|p_FmPort
parameter_list|)
block|{
name|uint32_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|t_ArCommonDesc
argument_list|)
decl_stmt|;
comment|// ARP
if|if
condition|(
name|params
operator|->
name|p_AutoResArpInfo
condition|)
block|{
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|arp
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarArpDescriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarArpBindingEntry
argument_list|)
operator|*
name|params
operator|->
name|p_AutoResArpInfo
operator|->
name|tableSize
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarArpStatistics
argument_list|)
expr_stmt|;
block|}
comment|// ICMPV4
if|if
condition|(
name|params
operator|->
name|p_AutoResEchoIpv4Info
condition|)
block|{
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|icmpv4
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV4Descriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV4BindingEntry
argument_list|)
operator|*
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|->
name|tableSize
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV4Statistics
argument_list|)
expr_stmt|;
block|}
comment|// ICMPV6
if|if
condition|(
name|params
operator|->
name|p_AutoResEchoIpv6Info
condition|)
block|{
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|icmpv6
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Descriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6BindingEntry
argument_list|)
operator|*
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|->
name|tableSize
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Statistics
argument_list|)
expr_stmt|;
block|}
comment|// ND
if|if
condition|(
name|params
operator|->
name|p_AutoResNdpInfo
condition|)
block|{
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|nd
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarNdDescriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6BindingEntry
argument_list|)
operator|*
operator|(
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeAssigned
operator|+
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeTmp
operator|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Statistics
argument_list|)
expr_stmt|;
block|}
comment|// SNMP
if|if
condition|(
name|params
operator|->
name|p_AutoResSnmpInfo
condition|)
block|{
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|snmp
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarSnmpDescriptor
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarSnmpIpv4AddrTblEntry
argument_list|)
operator|*
name|params
operator|->
name|p_AutoResSnmpInfo
operator|->
name|numOfIpv4Addresses
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarSnmpIpv6AddrTblEntry
argument_list|)
operator|*
name|params
operator|->
name|p_AutoResSnmpInfo
operator|->
name|numOfIpv6Addresses
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_OidsTblEntry
argument_list|)
operator|*
name|params
operator|->
name|p_AutoResSnmpInfo
operator|->
name|oidsTblSize
expr_stmt|;
name|size
operator|+=
name|p_FmPort
operator|->
name|deepSleepVars
operator|.
name|autoResMaxSizes
operator|->
name|maxNumOfSnmpOidChar
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_DsarIcmpV6Statistics
argument_list|)
expr_stmt|;
block|}
comment|//filters
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResFilteringInfo
condition|)
block|{
name|of
operator|->
name|filtIp
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|p_AutoResFilteringInfo
operator|->
name|ipProtTableSize
expr_stmt|;
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|filtUdp
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|p_AutoResFilteringInfo
operator|->
name|udpPortsTableSize
operator|*
sizeof|sizeof
argument_list|(
name|t_PortTblEntry
argument_list|)
expr_stmt|;
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|filtTcp
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|params
operator|->
name|p_AutoResFilteringInfo
operator|->
name|tcpPortsTableSize
operator|*
sizeof|sizeof
argument_list|(
name|t_PortTblEntry
argument_list|)
expr_stmt|;
block|}
comment|// add here for more protocols
comment|// statistics
name|size
operator|=
name|ROUND_UP
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|of
operator|->
name|stats
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|t_ArStatistics
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_decl_stmt
name|uint32_t
modifier|*
name|ARDesc
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|PrsEnable
parameter_list|(
name|t_Handle
name|p_FmPcd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|PrsDisable
parameter_list|(
name|t_Handle
name|p_FmPcd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|PrsIsEnabled
parameter_list|(
name|t_Handle
name|p_FmPcd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|t_Handle
name|FM_PCD_GetHcPort
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|t_Error
name|DsarCheckParams
parameter_list|(
name|t_FmPortDsarParams
modifier|*
name|params
parameter_list|,
name|t_FmPortDsarTablesSizes
modifier|*
name|sizes
parameter_list|)
block|{
name|bool
name|macInit
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|mac
index|[
literal|6
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// check table sizes
if|if
condition|(
name|params
operator|->
name|p_AutoResArpInfo
operator|&&
name|sizes
operator|->
name|maxNumOfArpEntries
operator|<
name|params
operator|->
name|p_AutoResArpInfo
operator|->
name|tableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Arp table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|&&
name|sizes
operator|->
name|maxNumOfEchoIpv4Entries
operator|<
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|->
name|tableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: EchoIpv4 table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResNdpInfo
operator|&&
name|sizes
operator|->
name|maxNumOfNdpEntries
operator|<
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeAssigned
operator|+
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeTmp
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: NDP table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|&&
name|sizes
operator|->
name|maxNumOfEchoIpv6Entries
operator|<
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|->
name|tableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: EchoIpv6 table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResSnmpInfo
operator|&&
name|sizes
operator|->
name|maxNumOfSnmpOidEntries
operator|<
name|params
operator|->
name|p_AutoResSnmpInfo
operator|->
name|oidsTblSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Snmp Oid table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResSnmpInfo
operator|&&
name|sizes
operator|->
name|maxNumOfSnmpIPV4Entries
operator|<
name|params
operator|->
name|p_AutoResSnmpInfo
operator|->
name|numOfIpv4Addresses
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Snmp ipv4 table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResSnmpInfo
operator|&&
name|sizes
operator|->
name|maxNumOfSnmpIPV6Entries
operator|<
name|params
operator|->
name|p_AutoResSnmpInfo
operator|->
name|numOfIpv6Addresses
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Snmp ipv6 table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|p_AutoResFilteringInfo
condition|)
block|{
if|if
condition|(
name|sizes
operator|->
name|maxNumOfIpProtFiltering
operator|<
name|params
operator|->
name|p_AutoResFilteringInfo
operator|->
name|ipProtTableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: ip filter table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizes
operator|->
name|maxNumOfTcpPortFiltering
operator|<
name|params
operator|->
name|p_AutoResFilteringInfo
operator|->
name|udpPortsTableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: udp filter table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizes
operator|->
name|maxNumOfUdpPortFiltering
operator|<
name|params
operator|->
name|p_AutoResFilteringInfo
operator|->
name|tcpPortsTableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: tcp filter table size exceeds the configured maximum size."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* check only 1 MAC address is configured (this is what ucode currently supports) */
if|if
condition|(
name|params
operator|->
name|p_AutoResArpInfo
operator|&&
name|params
operator|->
name|p_AutoResArpInfo
operator|->
name|tableSize
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResArpInfo
operator|->
name|p_AutoResTable
index|[
literal|0
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|macInit
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|params
operator|->
name|p_AutoResArpInfo
operator|->
name|tableSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResArpInfo
operator|->
name|p_AutoResTable
index|[
name|i
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Only 1 mac address is currently supported."
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|&&
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|->
name|tableSize
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|macInit
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|->
name|p_AutoResTable
index|[
literal|0
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|macInit
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|->
name|tableSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResEchoIpv4Info
operator|->
name|p_AutoResTable
index|[
name|i
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Only 1 mac address is currently supported."
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|&&
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|->
name|tableSize
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|macInit
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|->
name|p_AutoResTable
index|[
literal|0
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|macInit
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|->
name|tableSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResEchoIpv6Info
operator|->
name|p_AutoResTable
index|[
name|i
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Only 1 mac address is currently supported."
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|p_AutoResNdpInfo
operator|&&
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeAssigned
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|macInit
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|p_AutoResTableAssigned
index|[
literal|0
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|macInit
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeAssigned
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|p_AutoResTableAssigned
index|[
name|i
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Only 1 mac address is currently supported."
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|p_AutoResNdpInfo
operator|&&
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeTmp
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|macInit
condition|)
block|{
name|memcpy
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|p_AutoResTableTmp
index|[
literal|0
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|tableSizeTmp
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|mac
argument_list|,
name|params
operator|->
name|p_AutoResNdpInfo
operator|->
name|p_AutoResTableTmp
index|[
name|i
index|]
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"DSAR: Only 1 mac address is currently supported."
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|GetBERLen
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|*
name|buf
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buf
operator|&
literal|0x7F
operator|)
operator|==
literal|1
condition|)
return|return
name|buf
index|[
literal|1
index|]
return|;
else|else
return|return
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|buf
index|[
literal|1
index|]
return|;
comment|// assuming max len is 2
block|}
else|else
return|return
name|buf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TOTAL_BER_LEN
parameter_list|(
name|len
parameter_list|)
value|(len< 128) ? len + 2 : len + 3
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TODO_SOC_SUSPEND
end_ifdef

begin_comment
comment|// XXX
end_comment

begin_define
define|#
directive|define
name|SCFG_FMCLKDPSLPCR_ADDR
value|0xFFE0FC00C
end_define

begin_define
define|#
directive|define
name|SCFG_FMCLKDPSLPCR_DS_VAL
value|0x08402000
end_define

begin_define
define|#
directive|define
name|SCFG_FMCLKDPSLPCR_NORMAL_VAL
value|0x00402000
end_define

begin_function
specifier|static
name|int
name|fm_soc_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
modifier|*
name|fmclk
decl_stmt|,
name|tmp32
decl_stmt|;
name|fmclk
operator|=
name|ioremap
argument_list|(
name|SCFG_FMCLKDPSLPCR_ADDR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp32
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|fmclk
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|fmclk
argument_list|,
name|SCFG_FMCLKDPSLPCR_DS_VAL
argument_list|)
expr_stmt|;
name|tmp32
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|fmclk
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|fmclk
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fm_clk_down
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
modifier|*
name|fmclk
decl_stmt|,
name|tmp32
decl_stmt|;
name|fmclk
operator|=
name|ioremap
argument_list|(
name|SCFG_FMCLKDPSLPCR_ADDR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp32
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|fmclk
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|fmclk
argument_list|,
name|SCFG_FMCLKDPSLPCR_DS_VAL
operator||
literal|0x40000000
argument_list|)
expr_stmt|;
name|tmp32
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|fmclk
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|fmclk
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params) {     int i, j;     t_Error err;     uint32_t nia;     t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;     t_FmPort *p_FmPortTx = (t_FmPort *)params->h_FmPortTx;     t_DsarArpDescriptor *ArpDescriptor;     t_DsarIcmpV4Descriptor* ICMPV4Descriptor;     t_DsarIcmpV6Descriptor* ICMPV6Descriptor;     t_DsarNdDescriptor* NDDescriptor;      uint64_t fmMuramVirtBaseAddr = (uint64_t)PTR_TO_UINT(XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr));     uint32_t *param_page = XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));     t_ArCommonDesc *ArCommonDescPtr = (t_ArCommonDesc*)(XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(*param_page)));     struct arOffsets* of;     uint8_t tmp = 0;     t_FmGetSetParams fmGetSetParams;     memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));     fmGetSetParams.setParams.type = UPDATE_FPM_BRKC_SLP;     fmGetSetParams.setParams.sleep = 1;          err = DsarCheckParams(params, p_FmPort->deepSleepVars.autoResMaxSizes);     if (err != E_OK)         return err;      p_FmPort->deepSleepVars.autoResOffsets = XX_Malloc(sizeof(struct arOffsets));     of = (struct arOffsets *)p_FmPort->deepSleepVars.autoResOffsets;     IOMemSet32(ArCommonDescPtr, 0, AR_ComputeOffsets(of, params, p_FmPort));
comment|// common
end_comment

begin_comment
unit|WRITE_UINT8(ArCommonDescPtr->arTxPort, p_FmPortTx->hardwarePortId);     nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne);
comment|// bmi nia
end_comment

begin_comment
unit|if ((nia& 0x007C0000) == 0x00440000)
comment|// bmi nia is parser
end_comment

begin_comment
unit|WRITE_UINT32(ArCommonDescPtr->activeHPNIA, GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne));     else         WRITE_UINT32(ArCommonDescPtr->activeHPNIA, nia);     WRITE_UINT16(ArCommonDescPtr->snmpPort, 161);
comment|// ARP
end_comment

begin_comment
unit|if (params->p_AutoResArpInfo)     {         t_DsarArpBindingEntry* arp_bindings;         ArpDescriptor = (t_DsarArpDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->arp);         WRITE_UINT32(ArCommonDescPtr->p_ArpDescriptor, PTR_TO_UINT(ArpDescriptor) - fmMuramVirtBaseAddr);         arp_bindings = (t_DsarArpBindingEntry*)(PTR_TO_UINT(ArpDescriptor) + sizeof(t_DsarArpDescriptor)); 	if (params->p_AutoResArpInfo->enableConflictDetection) 	        WRITE_UINT16(ArpDescriptor->control, 1); 	else         WRITE_UINT16(ArpDescriptor->control, 0);         if (params->p_AutoResArpInfo->tableSize)         {             t_FmPortDsarArpEntry* arp_entry = params->p_AutoResArpInfo->p_AutoResTable;             WRITE_UINT16(*(uint16_t*)&ArCommonDescPtr->macStationAddr[0], *(uint16_t*)&arp_entry[0].mac[0]);             WRITE_UINT32(*(uint32_t*)&ArCommonDescPtr->macStationAddr[2], *(uint32_t*)&arp_entry[0].mac[2]);             WRITE_UINT16(ArpDescriptor->numOfBindings, params->p_AutoResArpInfo->tableSize);              for (i = 0; i< params->p_AutoResArpInfo->tableSize; i++)             {                 WRITE_UINT32(arp_bindings[i].ipv4Addr, arp_entry[i].ipAddress);                 if (arp_entry[i].isVlan)                     WRITE_UINT16(arp_bindings[i].vlanId, arp_entry[i].vid& 0xFFF);             }             WRITE_UINT32(ArpDescriptor->p_Bindings, PTR_TO_UINT(arp_bindings) - fmMuramVirtBaseAddr);         }         WRITE_UINT32(ArpDescriptor->p_Statistics, PTR_TO_UINT(arp_bindings) +             sizeof(t_DsarArpBindingEntry) * params->p_AutoResArpInfo->tableSize - fmMuramVirtBaseAddr);     }
comment|// ICMPV4
end_comment

begin_comment
unit|if (params->p_AutoResEchoIpv4Info)     {         t_DsarIcmpV4BindingEntry* icmpv4_bindings;         ICMPV4Descriptor = (t_DsarIcmpV4Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv4);         WRITE_UINT32(ArCommonDescPtr->p_IcmpV4Descriptor, PTR_TO_UINT(ICMPV4Descriptor) - fmMuramVirtBaseAddr);         icmpv4_bindings = (t_DsarIcmpV4BindingEntry*)(PTR_TO_UINT(ICMPV4Descriptor) + sizeof(t_DsarIcmpV4Descriptor));         WRITE_UINT16(ICMPV4Descriptor->control, 0);         if (params->p_AutoResEchoIpv4Info->tableSize)         {             t_FmPortDsarArpEntry* arp_entry = params->p_AutoResEchoIpv4Info->p_AutoResTable;             WRITE_UINT16(*(uint16_t*)&ArCommonDescPtr->macStationAddr[0], *(uint16_t*)&arp_entry[0].mac[0]);             WRITE_UINT32(*(uint32_t*)&ArCommonDescPtr->macStationAddr[2], *(uint32_t*)&arp_entry[0].mac[2]);             WRITE_UINT16(ICMPV4Descriptor->numOfBindings, params->p_AutoResEchoIpv4Info->tableSize);              for (i = 0; i< params->p_AutoResEchoIpv4Info->tableSize; i++)             {                 WRITE_UINT32(icmpv4_bindings[i].ipv4Addr, arp_entry[i].ipAddress);                 if (arp_entry[i].isVlan)                     WRITE_UINT16(icmpv4_bindings[i].vlanId, arp_entry[i].vid& 0xFFF);             }             WRITE_UINT32(ICMPV4Descriptor->p_Bindings, PTR_TO_UINT(icmpv4_bindings) - fmMuramVirtBaseAddr);         }         WRITE_UINT32(ICMPV4Descriptor->p_Statistics, PTR_TO_UINT(icmpv4_bindings) +             sizeof(t_DsarIcmpV4BindingEntry) * params->p_AutoResEchoIpv4Info->tableSize - fmMuramVirtBaseAddr);     }
comment|// ICMPV6
end_comment

begin_comment
unit|if (params->p_AutoResEchoIpv6Info)     {         t_DsarIcmpV6BindingEntry* icmpv6_bindings;         ICMPV6Descriptor = (t_DsarIcmpV6Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv6);         WRITE_UINT32(ArCommonDescPtr->p_IcmpV6Descriptor, PTR_TO_UINT(ICMPV6Descriptor) - fmMuramVirtBaseAddr);         icmpv6_bindings = (t_DsarIcmpV6BindingEntry*)(PTR_TO_UINT(ICMPV6Descriptor) + sizeof(t_DsarIcmpV6Descriptor));         WRITE_UINT16(ICMPV6Descriptor->control, 0);         if (params->p_AutoResEchoIpv6Info->tableSize)         {             t_FmPortDsarNdpEntry* ndp_entry = params->p_AutoResEchoIpv6Info->p_AutoResTable;             WRITE_UINT16(*(uint16_t*)&ArCommonDescPtr->macStationAddr[0], *(uint16_t*)&ndp_entry[0].mac[0]);             WRITE_UINT32(*(uint32_t*)&ArCommonDescPtr->macStationAddr[2], *(uint32_t*)&ndp_entry[0].mac[2]);             WRITE_UINT16(ICMPV6Descriptor->numOfBindings, params->p_AutoResEchoIpv6Info->tableSize);              for (i = 0; i< params->p_AutoResEchoIpv6Info->tableSize; i++)             {                 for (j = 0; j< 4; j++)                     WRITE_UINT32(icmpv6_bindings[i].ipv6Addr[j], ndp_entry[i].ipAddress[j]);                 if (ndp_entry[i].isVlan)                     WRITE_UINT16(*(uint16_t*)&icmpv6_bindings[i].ipv6Addr[4], ndp_entry[i].vid& 0xFFF);
comment|// writing vlan
end_comment

begin_comment
unit|}             WRITE_UINT32(ICMPV6Descriptor->p_Bindings, PTR_TO_UINT(icmpv6_bindings) - fmMuramVirtBaseAddr);         }         WRITE_UINT32(ICMPV6Descriptor->p_Statistics, PTR_TO_UINT(icmpv6_bindings) +             sizeof(t_DsarIcmpV6BindingEntry) * params->p_AutoResEchoIpv6Info->tableSize - fmMuramVirtBaseAddr);     }
comment|// ND
end_comment

begin_comment
unit|if (params->p_AutoResNdpInfo)     {         t_DsarIcmpV6BindingEntry* icmpv6_bindings;         NDDescriptor = (t_DsarNdDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->nd);         WRITE_UINT32(ArCommonDescPtr->p_NdDescriptor, PTR_TO_UINT(NDDescriptor) - fmMuramVirtBaseAddr);         icmpv6_bindings = (t_DsarIcmpV6BindingEntry*)(PTR_TO_UINT(NDDescriptor) + sizeof(t_DsarNdDescriptor)); 	if (params->p_AutoResNdpInfo->enableConflictDetection) 	        WRITE_UINT16(NDDescriptor->control, 1); 	else         WRITE_UINT16(NDDescriptor->control, 0);         if (params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp)         {             t_FmPortDsarNdpEntry* ndp_entry = params->p_AutoResNdpInfo->p_AutoResTableAssigned;             WRITE_UINT16(*(uint16_t*)&ArCommonDescPtr->macStationAddr[0], *(uint16_t*)&ndp_entry[0].mac[0]);             WRITE_UINT32(*(uint32_t*)&ArCommonDescPtr->macStationAddr[2], *(uint32_t*)&ndp_entry[0].mac[2]);             WRITE_UINT16(NDDescriptor->numOfBindings, params->p_AutoResNdpInfo->tableSizeAssigned                 + params->p_AutoResNdpInfo->tableSizeTmp);              for (i = 0; i< params->p_AutoResNdpInfo->tableSizeAssigned; i++)             {                 for (j = 0; j< 4; j++)                     WRITE_UINT32(icmpv6_bindings[i].ipv6Addr[j], ndp_entry[i].ipAddress[j]);                 if (ndp_entry[i].isVlan)                     WRITE_UINT16(*(uint16_t*)&icmpv6_bindings[i].ipv6Addr[4], ndp_entry[i].vid& 0xFFF);
comment|// writing vlan
end_comment

begin_comment
unit|}             ndp_entry = params->p_AutoResNdpInfo->p_AutoResTableTmp;             for (i = 0; i< params->p_AutoResNdpInfo->tableSizeTmp; i++)             {                 for (j = 0; j< 4; j++)                     WRITE_UINT32(icmpv6_bindings[i + params->p_AutoResNdpInfo->tableSizeAssigned].ipv6Addr[j], ndp_entry[i].ipAddress[j]);                 if (ndp_entry[i].isVlan)                     WRITE_UINT16(*(uint16_t*)&icmpv6_bindings[i + params->p_AutoResNdpInfo->tableSizeAssigned].ipv6Addr[4], ndp_entry[i].vid& 0xFFF);
comment|// writing vlan
end_comment

begin_comment
unit|}             WRITE_UINT32(NDDescriptor->p_Bindings, PTR_TO_UINT(icmpv6_bindings) - fmMuramVirtBaseAddr);         }         WRITE_UINT32(NDDescriptor->p_Statistics, PTR_TO_UINT(icmpv6_bindings) + sizeof(t_DsarIcmpV6BindingEntry)             * (params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp)             - fmMuramVirtBaseAddr);         WRITE_UINT32(NDDescriptor->solicitedAddr, 0xFFFFFFFF);     }
comment|// SNMP
end_comment

begin_comment
unit|if (params->p_AutoResSnmpInfo)     {         t_FmPortDsarSnmpInfo *snmpSrc = params->p_AutoResSnmpInfo;         t_DsarSnmpIpv4AddrTblEntry* snmpIpv4Addr;         t_DsarSnmpIpv6AddrTblEntry* snmpIpv6Addr;         t_OidsTblEntry* snmpOid;         uint8_t *charPointer;         int len;         t_DsarSnmpDescriptor* SnmpDescriptor = (t_DsarSnmpDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->snmp);         WRITE_UINT32(ArCommonDescPtr->p_SnmpDescriptor, PTR_TO_UINT(SnmpDescriptor) - fmMuramVirtBaseAddr);         WRITE_UINT16(SnmpDescriptor->control, snmpSrc->control);         WRITE_UINT16(SnmpDescriptor->maxSnmpMsgLength, snmpSrc->maxSnmpMsgLength);         snmpIpv4Addr = (t_DsarSnmpIpv4AddrTblEntry*)(PTR_TO_UINT(SnmpDescriptor) + sizeof(t_DsarSnmpDescriptor));         if (snmpSrc->numOfIpv4Addresses)         {             t_FmPortDsarSnmpIpv4AddrTblEntry* snmpIpv4AddrSrc = snmpSrc->p_Ipv4AddrTbl;             WRITE_UINT16(SnmpDescriptor->numOfIpv4Addresses, snmpSrc->numOfIpv4Addresses);             for (i = 0; i< snmpSrc->numOfIpv4Addresses; i++)             {                 WRITE_UINT32(snmpIpv4Addr[i].ipv4Addr, snmpIpv4AddrSrc[i].ipv4Addr);                 if (snmpIpv4AddrSrc[i].isVlan)                     WRITE_UINT16(snmpIpv4Addr[i].vlanId, snmpIpv4AddrSrc[i].vid& 0xFFF);             }             WRITE_UINT32(SnmpDescriptor->p_Ipv4AddrTbl, PTR_TO_UINT(snmpIpv4Addr) - fmMuramVirtBaseAddr);         }         snmpIpv6Addr = (t_DsarSnmpIpv6AddrTblEntry*)(PTR_TO_UINT(snmpIpv4Addr)                 + sizeof(t_DsarSnmpIpv4AddrTblEntry) * snmpSrc->numOfIpv4Addresses);         if (snmpSrc->numOfIpv6Addresses)         {             t_FmPortDsarSnmpIpv6AddrTblEntry* snmpIpv6AddrSrc = snmpSrc->p_Ipv6AddrTbl;             WRITE_UINT16(SnmpDescriptor->numOfIpv6Addresses, snmpSrc->numOfIpv6Addresses);             for (i = 0; i< snmpSrc->numOfIpv6Addresses; i++)             {                 for (j = 0; j< 4; j++)                     WRITE_UINT32(snmpIpv6Addr[i].ipv6Addr[j], snmpIpv6AddrSrc[i].ipv6Addr[j]);                 if (snmpIpv6AddrSrc[i].isVlan)                     WRITE_UINT16(snmpIpv6Addr[i].vlanId, snmpIpv6AddrSrc[i].vid& 0xFFF);             }             WRITE_UINT32(SnmpDescriptor->p_Ipv6AddrTbl, PTR_TO_UINT(snmpIpv6Addr) - fmMuramVirtBaseAddr);         }         snmpOid = (t_OidsTblEntry*)(PTR_TO_UINT(snmpIpv6Addr)                 + sizeof(t_DsarSnmpIpv6AddrTblEntry) * snmpSrc->numOfIpv6Addresses);         charPointer = (uint8_t*)(PTR_TO_UINT(snmpOid)                 + sizeof(t_OidsTblEntry) * snmpSrc->oidsTblSize);         len = TOTAL_BER_LEN(GetBERLen(&snmpSrc->p_RdOnlyCommunityStr[1]));         Mem2IOCpy32(charPointer, snmpSrc->p_RdOnlyCommunityStr, len);         WRITE_UINT32(SnmpDescriptor->p_RdOnlyCommunityStr, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);         charPointer += len;         len = TOTAL_BER_LEN(GetBERLen(&snmpSrc->p_RdWrCommunityStr[1]));         Mem2IOCpy32(charPointer, snmpSrc->p_RdWrCommunityStr, len);         WRITE_UINT32(SnmpDescriptor->p_RdWrCommunityStr, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);         charPointer += len;         WRITE_UINT32(SnmpDescriptor->oidsTblSize, snmpSrc->oidsTblSize);         WRITE_UINT32(SnmpDescriptor->p_OidsTbl, PTR_TO_UINT(snmpOid) - fmMuramVirtBaseAddr);         for (i = 0; i< snmpSrc->oidsTblSize; i++)         {             WRITE_UINT16(snmpOid->oidSize, snmpSrc->p_OidsTbl[i].oidSize);             WRITE_UINT16(snmpOid->resSize, snmpSrc->p_OidsTbl[i].resSize);             Mem2IOCpy32(charPointer, snmpSrc->p_OidsTbl[i].oidVal, snmpSrc->p_OidsTbl[i].oidSize);             WRITE_UINT32(snmpOid->p_Oid, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);             charPointer += snmpSrc->p_OidsTbl[i].oidSize;             if (snmpSrc->p_OidsTbl[i].resSize<= 4)                 WRITE_UINT32(snmpOid->resValOrPtr, *snmpSrc->p_OidsTbl[i].resVal);             else             {                 Mem2IOCpy32(charPointer, snmpSrc->p_OidsTbl[i].resVal, snmpSrc->p_OidsTbl[i].resSize);                 WRITE_UINT32(snmpOid->resValOrPtr, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);                 charPointer += snmpSrc->p_OidsTbl[i].resSize;             }             snmpOid++;         }         charPointer = UINT_TO_PTR(ROUND_UP(PTR_TO_UINT(charPointer),4));         WRITE_UINT32(SnmpDescriptor->p_Statistics, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);     }
comment|// filtering
end_comment

begin_comment
unit|if (params->p_AutoResFilteringInfo)     {         if (params->p_AutoResFilteringInfo->ipProtPassOnHit)             tmp |= IP_PROT_TBL_PASS_MASK;         if (params->p_AutoResFilteringInfo->udpPortPassOnHit)             tmp |= UDP_PORT_TBL_PASS_MASK;         if (params->p_AutoResFilteringInfo->tcpPortPassOnHit)             tmp |= TCP_PORT_TBL_PASS_MASK;         WRITE_UINT8(ArCommonDescPtr->filterControl, tmp);         WRITE_UINT16(ArCommonDescPtr->tcpControlPass, params->p_AutoResFilteringInfo->tcpFlagsMask);
comment|// ip filtering
end_comment

begin_comment
unit|if (params->p_AutoResFilteringInfo->ipProtTableSize)         {             uint8_t* ip_tbl = (uint8_t*)(PTR_TO_UINT(ArCommonDescPtr) + of->filtIp);             WRITE_UINT8(ArCommonDescPtr->ipProtocolTblSize, params->p_AutoResFilteringInfo->ipProtTableSize);             for (i = 0; i< params->p_AutoResFilteringInfo->ipProtTableSize; i++)                 WRITE_UINT8(ip_tbl[i], params->p_AutoResFilteringInfo->p_IpProtTablePtr[i]);             WRITE_UINT32(ArCommonDescPtr->p_IpProtocolFiltTbl, PTR_TO_UINT(ip_tbl) - fmMuramVirtBaseAddr);         }
comment|// udp filtering
end_comment

begin_comment
unit|if (params->p_AutoResFilteringInfo->udpPortsTableSize)         {             t_PortTblEntry* udp_tbl = (t_PortTblEntry*)(PTR_TO_UINT(ArCommonDescPtr) + of->filtUdp);             WRITE_UINT8(ArCommonDescPtr->udpPortTblSize, params->p_AutoResFilteringInfo->udpPortsTableSize);             for (i = 0; i< params->p_AutoResFilteringInfo->udpPortsTableSize; i++)             {                 WRITE_UINT32(udp_tbl[i].Ports,                     (params->p_AutoResFilteringInfo->p_UdpPortsTablePtr[i].srcPort<< 16) +                     params->p_AutoResFilteringInfo->p_UdpPortsTablePtr[i].dstPort);                 WRITE_UINT32(udp_tbl[i].PortsMask,                     (params->p_AutoResFilteringInfo->p_UdpPortsTablePtr[i].srcPortMask<< 16) +                     params->p_AutoResFilteringInfo->p_UdpPortsTablePtr[i].dstPortMask);             }             WRITE_UINT32(ArCommonDescPtr->p_UdpPortFiltTbl, PTR_TO_UINT(udp_tbl) - fmMuramVirtBaseAddr);         }
comment|// tcp filtering
end_comment

begin_comment
unit|if (params->p_AutoResFilteringInfo->tcpPortsTableSize)         {             t_PortTblEntry* tcp_tbl = (t_PortTblEntry*)(PTR_TO_UINT(ArCommonDescPtr) + of->filtTcp);             WRITE_UINT8(ArCommonDescPtr->tcpPortTblSize, params->p_AutoResFilteringInfo->tcpPortsTableSize);             for (i = 0; i< params->p_AutoResFilteringInfo->tcpPortsTableSize; i++)             {                 WRITE_UINT32(tcp_tbl[i].Ports,                     (params->p_AutoResFilteringInfo->p_TcpPortsTablePtr[i].srcPort<< 16) +                     params->p_AutoResFilteringInfo->p_TcpPortsTablePtr[i].dstPort);                 WRITE_UINT32(tcp_tbl[i].PortsMask,                     (params->p_AutoResFilteringInfo->p_TcpPortsTablePtr[i].srcPortMask<< 16) +                     params->p_AutoResFilteringInfo->p_TcpPortsTablePtr[i].dstPortMask);             }             WRITE_UINT32(ArCommonDescPtr->p_TcpPortFiltTbl, PTR_TO_UINT(tcp_tbl) - fmMuramVirtBaseAddr);         }     }
comment|// common stats
end_comment

begin_comment
unit|WRITE_UINT32(ArCommonDescPtr->p_ArStats, PTR_TO_UINT(ArCommonDescPtr) + of->stats - fmMuramVirtBaseAddr);
comment|// get into Deep Sleep sequence:
end_comment

begin_comment
comment|// Ensures that FMan do not enter the idle state. This is done by programing
end_comment

begin_comment
comment|// FMDPSLPCR[FM_STOP] to one.
end_comment

begin_comment
unit|fm_soc_suspend();      ARDesc = UINT_TO_PTR(XX_VirtToPhys(ArCommonDescPtr));     return E_OK;  }  void FM_ChangeClock(t_Handle h_Fm, int hardwarePortId); t_Error FM_PORT_EnterDsarFinal(t_Handle h_DsarRxPort, t_Handle h_DsarTxPort) { 	t_FmGetSetParams fmGetSetParams; 	t_FmPort *p_FmPort = (t_FmPort *)h_DsarRxPort; 	t_FmPort *p_FmPortTx = (t_FmPort *)h_DsarTxPort; 	t_Handle *h_FmPcd = FmGetPcd(p_FmPort->h_Fm); 	t_FmPort *p_FmPortHc = FM_PCD_GetHcPort(h_FmPcd); 	memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));         fmGetSetParams.setParams.type = UPDATE_FM_CLD;         FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams);
comment|/* Issue graceful stop to HC port */
end_comment

begin_comment
unit|FM_PORT_Disable(p_FmPortHc);
comment|// config tx port
end_comment

begin_comment
unit|p_FmPort->deepSleepVars.fmbm_tcfg = GET_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg);     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg, GET_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg) | BMI_PORT_CFG_IM | BMI_PORT_CFG_EN);
comment|// ????
end_comment

begin_comment
unit|p_FmPort->deepSleepVars.fmbm_tcmne = GET_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcmne);     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcmne, 0xE);
comment|// Stage 7:echo
end_comment

begin_comment
unit|p_FmPort->deepSleepVars.fmbm_rfpne = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, 0x2E);     if (!PrsIsEnabled(h_FmPcd))     {         p_FmPort->deepSleepVars.dsarEnabledParser = TRUE;         PrsEnable(h_FmPcd);     }     else         p_FmPort->deepSleepVars.dsarEnabledParser = FALSE;      p_FmPort->deepSleepVars.fmbm_rfne = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne);     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne, 0x440000);
comment|// save rcfg for restoring: accumulate mode is changed by ucode
end_comment

begin_comment
unit|p_FmPort->deepSleepVars.fmbm_rcfg = GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcfg);     WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcfg, p_FmPort->deepSleepVars.fmbm_rcfg | BMI_PORT_CFG_AM);         memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));         fmGetSetParams.setParams.type = UPDATE_FPM_BRKC_SLP;         fmGetSetParams.setParams.sleep = 1;         FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams);
comment|// ***** issue external request sync command
end_comment

begin_comment
unit|memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));         fmGetSetParams.setParams.type = UPDATE_FPM_EXTC;         FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams);
comment|// get
end_comment

begin_comment
unit|memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams)); 	fmGetSetParams.getParams.type = GET_FMFP_EXTC; 	FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams); 	if (fmGetSetParams.getParams.fmfp_extc != 0) 	{
comment|// clear
end_comment

begin_comment
unit|memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams)); 		fmGetSetParams.setParams.type = UPDATE_FPM_EXTC_CLEAR; 		FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams); }  	memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams)); 	fmGetSetParams.getParams.type = GET_FMFP_EXTC | GET_FM_NPI; 	do 	{ 		FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams); 	} while (fmGetSetParams.getParams.fmfp_extc != 0&& fmGetSetParams.getParams.fm_npi == 0); 	if (fmGetSetParams.getParams.fm_npi != 0) 		XX_Print("FM: Sync did not finish\n");
comment|// check that all stoped
end_comment

begin_comment
unit|memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));         fmGetSetParams.getParams.type = GET_FMQM_GS | GET_FM_NPI;         FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams); 	while (fmGetSetParams.getParams.fmqm_gs& 0xF0000000) 	        FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams); 	if (fmGetSetParams.getParams.fmqm_gs == 0&& fmGetSetParams.getParams.fm_npi == 0) 		XX_Print("FM: Sleeping\n");
comment|//	FM_ChangeClock(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
end_comment

begin_endif
unit|return E_OK; }  void FM_PORT_Dsar_DumpRegs() {     uint32_t* hh = XX_PhysToVirt(PTR_TO_UINT(ARDesc));     DUMP_MEMORY(hh, 0x220); }  void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx) {     t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;     t_FmPort *p_FmPortTx = (t_FmPort *)h_FmPortTx;     t_Handle *h_FmPcd = FmGetPcd(p_FmPort->h_Fm);     t_FmPort *p_FmPortHc = FM_PCD_GetHcPort(h_FmPcd);     t_FmGetSetParams fmGetSetParams;     memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));     fmGetSetParams.setParams.type = UPDATE_FPM_BRKC_SLP;     fmGetSetParams.setParams.sleep = 0;     if (p_FmPort->deepSleepVars.autoResOffsets)     {         XX_Free(p_FmPort->deepSleepVars.autoResOffsets);         p_FmPort->deepSleepVars.autoResOffsets = 0;     }      if (p_FmPort->deepSleepVars.dsarEnabledParser)         PrsDisable(FmGetPcd(p_FmPort->h_Fm));     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->deepSleepVars.fmbm_rfpne);     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne, p_FmPort->deepSleepVars.fmbm_rfne);     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg, p_FmPort->deepSleepVars.fmbm_rcfg);     FmGetSetParams(p_FmPort->h_Fm,&fmGetSetParams);     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcmne, p_FmPort->deepSleepVars.fmbm_tcmne);     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg, p_FmPort->deepSleepVars.fmbm_tcfg);     FM_PORT_Enable(p_FmPortHc); }  bool FM_PORT_IsInDsar(t_Handle h_FmPort) {     t_FmPort *p_FmPort = (t_FmPort *)h_FmPort;     return PTR_TO_UINT(p_FmPort->deepSleepVars.autoResOffsets); }  t_Error FM_PORT_GetDsarStats(t_Handle h_FmPortRx, t_FmPortDsarStats *stats) {     t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;     struct arOffsets *of = (struct arOffsets*)p_FmPort->deepSleepVars.autoResOffsets;     uint8_t* fmMuramVirtBaseAddr = XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr);     uint32_t *param_page = XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));     t_ArCommonDesc *ArCommonDescPtr = (t_ArCommonDesc*)(XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(*param_page)));     t_DsarArpDescriptor *ArpDescriptor = (t_DsarArpDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->arp);     t_DsarArpStatistics* arp_stats = (t_DsarArpStatistics*)(PTR_TO_UINT(ArpDescriptor->p_Statistics) + fmMuramVirtBaseAddr);     t_DsarIcmpV4Descriptor* ICMPV4Descriptor = (t_DsarIcmpV4Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv4);     t_DsarIcmpV4Statistics* icmpv4_stats = (t_DsarIcmpV4Statistics*)(PTR_TO_UINT(ICMPV4Descriptor->p_Statistics) + fmMuramVirtBaseAddr);     t_DsarNdDescriptor* NDDescriptor = (t_DsarNdDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->nd);     t_NdStatistics* nd_stats = (t_NdStatistics*)(PTR_TO_UINT(NDDescriptor->p_Statistics) + fmMuramVirtBaseAddr);     t_DsarIcmpV6Descriptor* ICMPV6Descriptor = (t_DsarIcmpV6Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv6);     t_DsarIcmpV6Statistics* icmpv6_stats = (t_DsarIcmpV6Statistics*)(PTR_TO_UINT(ICMPV6Descriptor->p_Statistics) + fmMuramVirtBaseAddr);     t_DsarSnmpDescriptor* SnmpDescriptor = (t_DsarSnmpDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->snmp);     t_DsarSnmpStatistics* snmp_stats = (t_DsarSnmpStatistics*)(PTR_TO_UINT(SnmpDescriptor->p_Statistics) + fmMuramVirtBaseAddr);     stats->arpArCnt = arp_stats->arCnt;     stats->echoIcmpv4ArCnt = icmpv4_stats->arCnt;     stats->ndpArCnt = nd_stats->arCnt;     stats->echoIcmpv6ArCnt = icmpv6_stats->arCnt;     stats->snmpGetCnt = snmp_stats->snmpGetReqCnt;     stats->snmpGetNextCnt = snmp_stats->snmpGetNextReqCnt;     return E_OK; }
endif|#
directive|endif
end_endif

end_unit

