begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2013 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"fsl_fman_rtc.h"
end_include

begin_function
name|void
name|fman_rtc_defconfig
parameter_list|(
name|struct
name|rtc_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cfg
operator|->
name|src_clk
operator|=
name|DEFAULT_SRC_CLOCK
expr_stmt|;
name|cfg
operator|->
name|invert_input_clk_phase
operator|=
name|DEFAULT_INVERT_INPUT_CLK_PHASE
expr_stmt|;
name|cfg
operator|->
name|invert_output_clk_phase
operator|=
name|DEFAULT_INVERT_OUTPUT_CLK_PHASE
expr_stmt|;
name|cfg
operator|->
name|pulse_realign
operator|=
name|DEFAULT_PULSE_REALIGN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FMAN_RTC_MAX_NUM_OF_ALARMS
condition|;
name|i
operator|++
control|)
name|cfg
operator|->
name|alarm_polarity
index|[
name|i
index|]
operator|=
name|DEFAULT_ALARM_POLARITY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FMAN_RTC_MAX_NUM_OF_EXT_TRIGGERS
condition|;
name|i
operator|++
control|)
name|cfg
operator|->
name|trigger_polarity
index|[
name|i
index|]
operator|=
name|DEFAULT_TRIGGER_POLARITY
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|fman_rtc_get_events
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_tevent
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|fman_rtc_get_event
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|ev_mask
parameter_list|)
block|{
return|return
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_tevent
argument_list|)
operator|&
name|ev_mask
return|;
block|}
end_function

begin_function
name|uint32_t
name|fman_rtc_get_interrupt_mask
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_temask
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_interrupt_mask
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|mask
argument_list|,
operator|&
name|regs
operator|->
name|tmr_temask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_ack_event
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|events
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|events
argument_list|,
operator|&
name|regs
operator|->
name|tmr_tevent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|fman_rtc_check_and_clear_event
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
name|uint32_t
name|event
decl_stmt|;
name|event
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_tevent
argument_list|)
expr_stmt|;
name|event
operator|&=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_temask
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
condition|)
name|iowrite32be
argument_list|(
name|event
argument_list|,
operator|&
name|regs
operator|->
name|tmr_tevent
argument_list|)
expr_stmt|;
return|return
name|event
return|;
block|}
end_function

begin_function
name|uint32_t
name|fman_rtc_get_frequency_compensation
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_add
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_frequency_compensation
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|val
argument_list|,
operator|&
name|regs
operator|->
name|tmr_add
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_enable_interupt
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|events
parameter_list|)
block|{
name|fman_rtc_set_interrupt_mask
argument_list|(
name|regs
argument_list|,
name|fman_rtc_get_interrupt_mask
argument_list|(
name|regs
argument_list|)
operator||
name|events
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_disable_interupt
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|events
parameter_list|)
block|{
name|fman_rtc_set_interrupt_mask
argument_list|(
name|regs
argument_list|,
name|fman_rtc_get_interrupt_mask
argument_list|(
name|regs
argument_list|)
operator|&
operator|~
name|events
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_timer_alarm_l
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|index
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|val
argument_list|,
operator|&
name|regs
operator|->
name|tmr_alarm
index|[
name|index
index|]
operator|.
name|tmr_alarm_l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_timer_fiper
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|index
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|val
argument_list|,
operator|&
name|regs
operator|->
name|tmr_fiper
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_timer_alarm
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|index
parameter_list|,
name|int64_t
name|val
parameter_list|)
block|{
name|iowrite32be
argument_list|(
operator|(
name|uint32_t
operator|)
name|val
argument_list|,
operator|&
name|regs
operator|->
name|tmr_alarm
index|[
name|index
index|]
operator|.
name|tmr_alarm_l
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|regs
operator|->
name|tmr_alarm
index|[
name|index
index|]
operator|.
name|tmr_alarm_h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_timer_offset
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int64_t
name|val
parameter_list|)
block|{
name|iowrite32be
argument_list|(
operator|(
name|uint32_t
operator|)
name|val
argument_list|,
operator|&
name|regs
operator|->
name|tmr_off_l
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|regs
operator|->
name|tmr_off_h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|fman_rtc_get_trigger_stamp
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint64_t
name|time
decl_stmt|;
comment|/* TMR_CNT_L must be read first to get an accurate value */
name|time
operator|=
operator|(
name|uint64_t
operator|)
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_etts
index|[
name|id
index|]
operator|.
name|tmr_etts_l
argument_list|)
expr_stmt|;
name|time
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_etts
index|[
name|id
index|]
operator|.
name|tmr_etts_h
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
return|return
name|time
return|;
block|}
end_function

begin_function
name|uint32_t
name|fman_rtc_get_timer_ctrl
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|tmr_ctrl
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_timer_ctrl
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|val
argument_list|,
operator|&
name|regs
operator|->
name|tmr_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_timers_soft_reset
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
name|FMAN_RTC_TMR_CTRL_TMSR
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_init
parameter_list|(
name|struct
name|rtc_cfg
modifier|*
name|cfg
parameter_list|,
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|num_alarms
parameter_list|,
name|int
name|num_fipers
parameter_list|,
name|int
name|num_ext_triggers
parameter_list|,
name|bool
name|init_freq_comp
parameter_list|,
name|uint32_t
name|freq_compensation
parameter_list|,
name|uint32_t
name|output_clock_divisor
parameter_list|)
block|{
name|uint32_t
name|tmr_ctrl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fman_rtc_timers_soft_reset
argument_list|(
name|regs
argument_list|)
expr_stmt|;
comment|/* Set the source clock */
switch|switch
condition|(
name|cfg
operator|->
name|src_clk
condition|)
block|{
case|case
name|E_FMAN_RTC_SOURCE_CLOCK_SYSTEM
case|:
name|tmr_ctrl
operator|=
name|FMAN_RTC_TMR_CTRL_CKSEL_MAC_CLK
expr_stmt|;
break|break;
case|case
name|E_FMAN_RTC_SOURCE_CLOCK_OSCILATOR
case|:
name|tmr_ctrl
operator|=
name|FMAN_RTC_TMR_CTRL_CKSEL_OSC_CLK
expr_stmt|;
break|break;
default|default:
comment|/* Use a clock from the External TMR reference clock.*/
name|tmr_ctrl
operator|=
name|FMAN_RTC_TMR_CTRL_CKSEL_EXT_CLK
expr_stmt|;
break|break;
block|}
comment|/* whatever period the user picked, the timestamp will advance in '1' 	* every time the period passed. */
name|tmr_ctrl
operator||=
operator|(
operator|(
literal|1
operator|<<
name|FMAN_RTC_TMR_CTRL_TCLK_PERIOD_SHIFT
operator|)
operator|&
name|FMAN_RTC_TMR_CTRL_TCLK_PERIOD_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|invert_input_clk_phase
condition|)
name|tmr_ctrl
operator||=
name|FMAN_RTC_TMR_CTRL_CIPH
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|invert_output_clk_phase
condition|)
name|tmr_ctrl
operator||=
name|FMAN_RTC_TMR_CTRL_COPH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_alarms
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfg
operator|->
name|alarm_polarity
index|[
name|i
index|]
operator|==
name|E_FMAN_RTC_ALARM_POLARITY_ACTIVE_LOW
condition|)
name|tmr_ctrl
operator||=
operator|(
name|FMAN_RTC_TMR_CTRL_ALMP1
operator|>>
name|i
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ext_triggers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cfg
operator|->
name|trigger_polarity
index|[
name|i
index|]
operator|==
name|E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE
condition|)
name|tmr_ctrl
operator||=
operator|(
name|FMAN_RTC_TMR_CTRL_ETEP1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
operator|->
name|timer_slave_mode
operator|&&
name|cfg
operator|->
name|bypass
condition|)
name|tmr_ctrl
operator||=
name|FMAN_RTC_TMR_CTRL_BYP
expr_stmt|;
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
name|tmr_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_freq_comp
condition|)
name|fman_rtc_set_frequency_compensation
argument_list|(
name|regs
argument_list|,
name|freq_compensation
argument_list|)
expr_stmt|;
comment|/* Clear TMR_ALARM registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_alarms
condition|;
name|i
operator|++
control|)
name|fman_rtc_set_timer_alarm
argument_list|(
name|regs
argument_list|,
name|i
argument_list|,
literal|0xFFFFFFFFFFFFFFFFLL
argument_list|)
expr_stmt|;
comment|/* Clear TMR_TEVENT */
name|fman_rtc_ack_event
argument_list|(
name|regs
argument_list|,
name|FMAN_RTC_TMR_TEVENT_ALL
argument_list|)
expr_stmt|;
comment|/* Initialize TMR_TEMASK */
name|fman_rtc_set_interrupt_mask
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear TMR_FIPER registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_fipers
condition|;
name|i
operator|++
control|)
name|fman_rtc_set_timer_fiper
argument_list|(
name|regs
argument_list|,
name|i
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Initialize TMR_PRSC */
name|iowrite32be
argument_list|(
name|output_clock_divisor
argument_list|,
operator|&
name|regs
operator|->
name|tmr_prsc
argument_list|)
expr_stmt|;
comment|/* Clear TMR_OFF */
name|fman_rtc_set_timer_offset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|fman_rtc_is_enabled
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
return|return
call|(
name|bool
call|)
argument_list|(
name|fman_rtc_get_timer_ctrl
argument_list|(
name|regs
argument_list|)
operator|&
name|FMAN_RTC_TMR_CTRL_TE
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|fman_rtc_enable
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|bool
name|reset_clock
parameter_list|)
block|{
name|uint32_t
name|tmr_ctrl
init|=
name|fman_rtc_get_timer_ctrl
argument_list|(
name|regs
argument_list|)
decl_stmt|;
comment|/* TODO check that no timestamping MACs are working in this stage. */
if|if
condition|(
name|reset_clock
condition|)
block|{
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
operator|(
name|tmr_ctrl
operator||
name|FMAN_RTC_TMR_CTRL_TMSR
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear TMR_OFF */
name|fman_rtc_set_timer_offset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
operator|(
name|tmr_ctrl
operator||
name|FMAN_RTC_TMR_CTRL_TE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_disable
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|)
block|{
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
operator|(
name|fman_rtc_get_timer_ctrl
argument_list|(
name|regs
argument_list|)
operator|&
operator|~
operator|(
name|FMAN_RTC_TMR_CTRL_TE
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_clear_periodic_pulse
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint32_t
name|tmp_reg
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmp_reg
operator|=
name|FMAN_RTC_TMR_TEVENT_PP1
expr_stmt|;
else|else
name|tmp_reg
operator|=
name|FMAN_RTC_TMR_TEVENT_PP2
expr_stmt|;
name|fman_rtc_disable_interupt
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
name|tmp_reg
operator|=
name|fman_rtc_get_timer_ctrl
argument_list|(
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_reg
operator|&
name|FMAN_RTC_TMR_CTRL_FS
condition|)
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
name|tmp_reg
operator|&
operator|~
name|FMAN_RTC_TMR_CTRL_FS
argument_list|)
expr_stmt|;
name|fman_rtc_set_timer_fiper
argument_list|(
name|regs
argument_list|,
name|id
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_clear_external_trigger
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|uint32_t
name|tmpReg
decl_stmt|,
name|tmp_ctrl
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_ETS1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_ETS2
expr_stmt|;
name|fman_rtc_disable_interupt
argument_list|(
name|regs
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|FMAN_RTC_TMR_CTRL_PP1L
expr_stmt|;
else|else
name|tmpReg
operator|=
name|FMAN_RTC_TMR_CTRL_PP2L
expr_stmt|;
name|tmp_ctrl
operator|=
name|fman_rtc_get_timer_ctrl
argument_list|(
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_ctrl
operator|&
name|tmpReg
condition|)
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
name|tmp_ctrl
operator|&
operator|~
name|tmpReg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_rtc_set_alarm
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|id
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint32_t
name|tmpReg
decl_stmt|;
name|fman_rtc_set_timer_alarm
argument_list|(
name|regs
argument_list|,
name|id
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_ALM1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_ALM2
expr_stmt|;
name|fman_rtc_enable_interupt
argument_list|(
name|regs
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fman_rtc_set_periodic_pulse
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|id
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint32_t
name|tmpReg
decl_stmt|;
name|fman_rtc_set_timer_fiper
argument_list|(
name|regs
argument_list|,
name|id
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_PP1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_PP2
expr_stmt|;
name|fman_rtc_enable_interupt
argument_list|(
name|regs
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fman_rtc_set_ext_trigger
parameter_list|(
name|struct
name|rtc_regs
modifier|*
name|regs
parameter_list|,
name|int
name|id
parameter_list|,
name|bool
name|enable
parameter_list|,
name|bool
name|use_pulse_as_input
parameter_list|)
block|{
name|uint32_t
name|tmpReg
decl_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_ETS1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|FMAN_RTC_TMR_TEVENT_ETS2
expr_stmt|;
name|fman_rtc_enable_interupt
argument_list|(
name|regs
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_pulse_as_input
condition|)
block|{
if|if
condition|(
name|id
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|FMAN_RTC_TMR_CTRL_PP1L
expr_stmt|;
else|else
name|tmpReg
operator|=
name|FMAN_RTC_TMR_CTRL_PP2L
expr_stmt|;
name|fman_rtc_set_timer_ctrl
argument_list|(
name|regs
argument_list|,
name|fman_rtc_get_timer_ctrl
argument_list|(
name|regs
argument_list|)
operator||
name|tmpReg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

