begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_rtc.c   @Description   FM RTC driver implementation.   @Cautions      None */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<linux/math64.h>
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"part_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"ncsw_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_rtc.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CheckInitParameters
parameter_list|(
name|t_FmRtc
modifier|*
name|p_Rtc
parameter_list|)
block|{
name|struct
name|rtc_cfg
modifier|*
name|p_RtcDriverParam
init|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p_RtcDriverParam
operator|->
name|src_clk
operator|!=
name|E_FMAN_RTC_SOURCE_CLOCK_EXTERNAL
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|src_clk
operator|!=
name|E_FMAN_RTC_SOURCE_CLOCK_SYSTEM
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|src_clk
operator|!=
name|E_FMAN_RTC_SOURCE_CLOCK_OSCILATOR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_CLOCK
argument_list|,
operator|(
literal|"Source clock undefined"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Rtc
operator|->
name|outputClockDivisor
operator|==
literal|0
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Divisor for output clock (should be positive)"
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_ALARMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_RtcDriverParam
operator|->
name|alarm_polarity
index|[
name|i
index|]
operator|!=
name|E_FMAN_RTC_ALARM_POLARITY_ACTIVE_LOW
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|alarm_polarity
index|[
name|i
index|]
operator|!=
name|E_FMAN_RTC_ALARM_POLARITY_ACTIVE_HIGH
operator|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm %d signal polarity"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_RtcDriverParam
operator|->
name|trigger_polarity
index|[
name|i
index|]
operator|!=
name|E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|trigger_polarity
index|[
name|i
index|]
operator|!=
name|E_FMAN_RTC_TRIGGER_ON_RISING_EDGE
operator|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Trigger %d signal polarity"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|RtcExceptions
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|struct
name|rtc_regs
modifier|*
name|p_MemMap
decl_stmt|;
specifier|register
name|uint32_t
name|events
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
name|p_MemMap
operator|=
name|p_Rtc
operator|->
name|p_MemMap
expr_stmt|;
name|events
operator|=
name|fman_rtc_check_and_clear_event
argument_list|(
name|p_MemMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|FMAN_RTC_TMR_TEVENT_ALM1
condition|)
block|{
if|if
condition|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|0
index|]
operator|.
name|clearOnExpiration
condition|)
block|{
name|fman_rtc_set_timer_alarm_l
argument_list|(
name|p_MemMap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fman_rtc_disable_interupt
argument_list|(
name|p_MemMap
argument_list|,
name|FMAN_RTC_TMR_TEVENT_ALM1
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|0
index|]
operator|.
name|f_AlarmCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|0
index|]
operator|.
name|f_AlarmCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|FMAN_RTC_TMR_TEVENT_ALM2
condition|)
block|{
if|if
condition|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|1
index|]
operator|.
name|clearOnExpiration
condition|)
block|{
name|fman_rtc_set_timer_alarm_l
argument_list|(
name|p_MemMap
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fman_rtc_disable_interupt
argument_list|(
name|p_MemMap
argument_list|,
name|FMAN_RTC_TMR_TEVENT_ALM2
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|1
index|]
operator|.
name|f_AlarmCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|1
index|]
operator|.
name|f_AlarmCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|FMAN_RTC_TMR_TEVENT_PP1
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|0
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|0
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|FMAN_RTC_TMR_TEVENT_PP2
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|1
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|1
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|FMAN_RTC_TMR_TEVENT_ETS1
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|0
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|0
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|FMAN_RTC_TMR_TEVENT_ETS2
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|1
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|1
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Handle
name|FM_RTC_Config
parameter_list|(
name|t_FmRtcParams
modifier|*
name|p_FmRtcParam
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmRtcParam
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate memory for the FM RTC driver parameters */
name|p_Rtc
operator|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmRtc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Rtc
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM RTC driver structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Rtc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmRtc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate memory for the FM RTC driver parameters */
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|=
operator|(
expr|struct
name|rtc_cfg
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtc_cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM RTC driver parameters"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtc_cfg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store RTC configuration parameters */
name|p_Rtc
operator|->
name|h_Fm
operator|=
name|p_FmRtcParam
operator|->
name|h_Fm
expr_stmt|;
comment|/* Set default RTC configuration parameters */
name|fman_rtc_defconfig
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|outputClockDivisor
operator|=
name|DEFAULT_OUTPUT_CLOCK_DIVISOR
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
operator|=
name|DEFAULT_BYPASS
expr_stmt|;
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|=
name|DEFAULT_CLOCK_PERIOD
expr_stmt|;
comment|/* 1 usec */
comment|/* Store RTC parameters in the RTC control structure */
name|p_Rtc
operator|->
name|p_MemMap
operator|=
operator|(
expr|struct
name|rtc_regs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_FmRtcParam
operator|->
name|baseAddress
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|h_App
operator|=
name|p_FmRtcParam
operator|->
name|h_App
expr_stmt|;
return|return
name|p_Rtc
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Init
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|struct
name|rtc_cfg
modifier|*
name|p_RtcDriverParam
decl_stmt|;
name|struct
name|rtc_regs
modifier|*
name|p_MemMap
decl_stmt|;
name|uint32_t
name|freqCompensation
init|=
literal|0
decl_stmt|;
name|uint64_t
name|tmpDouble
decl_stmt|;
name|bool
name|init_freq_comp
init|=
name|FALSE
decl_stmt|;
name|p_RtcDriverParam
operator|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
expr_stmt|;
name|p_MemMap
operator|=
name|p_Rtc
operator|->
name|p_MemMap
expr_stmt|;
if|if
condition|(
name|CheckInitParameters
argument_list|(
name|p_Rtc
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Init Parameters are not Valid"
operator|)
argument_list|)
expr_stmt|;
comment|/* TODO check that no timestamping MACs are working in this stage. */
comment|/* find source clock frequency in Mhz */
if|if
condition|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|src_clk
operator|!=
name|E_FMAN_RTC_SOURCE_CLOCK_SYSTEM
condition|)
name|p_Rtc
operator|->
name|srcClkFreqMhz
operator|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|ext_src_clk_freq
expr_stmt|;
else|else
name|p_Rtc
operator|->
name|srcClkFreqMhz
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|FmGetMacClockFreq
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if timer in Master mode Initialize TMR_CTRL */
comment|/* We want the counter (TMR_CNT) to count in nano-seconds */
if|if
condition|(
operator|!
name|p_RtcDriverParam
operator|->
name|timer_slave_mode
operator|&&
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
condition|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|=
operator|(
literal|1000
operator|/
name|p_Rtc
operator|->
name|srcClkFreqMhz
operator|)
expr_stmt|;
else|else
block|{
comment|/* Initialize TMR_ADD with the initial frequency compensation value:            freqCompensation = (2^32 / frequency ratio) */
comment|/* frequency ratio = sorce clock/rtc clock =          * (p_Rtc->srcClkFreqMhz*1000000))/ 1/(p_Rtc->clockPeriodNanoSec * 1000000000) */
name|init_freq_comp
operator|=
name|TRUE
expr_stmt|;
name|freqCompensation
operator|=
operator|(
name|uint32_t
operator|)
name|DIV_CEIL
argument_list|(
name|ACCUMULATOR_OVERFLOW
operator|*
literal|1000
argument_list|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|*
name|p_Rtc
operator|->
name|srcClkFreqMhz
argument_list|)
expr_stmt|;
block|}
comment|/* check the legality of the relation between source and destination clocks */
comment|/* should be larger than 1.0001 */
name|tmpDouble
operator|=
literal|10000
operator|*
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|*
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|srcClkFreqMhz
expr_stmt|;
if|if
condition|(
operator|(
name|tmpDouble
operator|)
operator|<=
literal|10001
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Invalid relation between source and destination clocks. Should be larger than 1.0001"
operator|)
argument_list|)
expr_stmt|;
name|fman_rtc_init
argument_list|(
name|p_RtcDriverParam
argument_list|,
name|p_MemMap
argument_list|,
name|FM_RTC_NUM_OF_ALARMS
argument_list|,
name|FM_RTC_NUM_OF_PERIODIC_PULSES
argument_list|,
name|FM_RTC_NUM_OF_EXT_TRIGGERS
argument_list|,
name|init_freq_comp
argument_list|,
name|freqCompensation
argument_list|,
name|p_Rtc
operator|->
name|outputClockDivisor
argument_list|)
expr_stmt|;
comment|/* Register the FM RTC interrupt */
name|FmRegisterIntr
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_TMR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|,
name|RtcExceptions
argument_list|,
name|p_Rtc
argument_list|)
expr_stmt|;
comment|/* Free parameters structures */
name|XX_Free
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|=
name|NULL
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Free
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FM_RTC_Disable
argument_list|(
name|h_FmRtc
argument_list|)
expr_stmt|;
block|}
comment|/* Unregister FM RTC interrupt */
name|FmUnregisterIntr
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_TMR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigSourceClock
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|e_FmSrcClk
name|srcClk
parameter_list|,
name|uint32_t
name|freqInMhz
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|src_clk
operator|=
operator|(
expr|enum
name|fman_src_clock
operator|)
name|srcClk
expr_stmt|;
if|if
condition|(
name|srcClk
operator|!=
name|e_FM_RTC_SOURCE_CLOCK_SYSTEM
condition|)
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|ext_src_clk_freq
operator|=
name|freqInMhz
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigPeriod
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
name|period
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|=
name|period
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigFrequencyBypass
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
operator|=
name|enabled
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigInvertedInputClockPhase
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|inverted
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|invert_input_clk_phase
operator|=
name|inverted
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigInvertedOutputClockPhase
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|inverted
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|invert_output_clk_phase
operator|=
name|inverted
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigOutputClockDivisor
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint16_t
name|divisor
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|outputClockDivisor
operator|=
name|divisor
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigPulseRealignment
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|pulse_realign
operator|=
name|enable
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigAlarmPolarity
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|alarmId
parameter_list|,
name|e_FmRtcAlarmPolarity
name|alarmPolarity
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|alarmId
operator|>=
name|FM_RTC_NUM_OF_ALARMS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm ID"
operator|)
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|alarm_polarity
index|[
name|alarmId
index|]
operator|=
operator|(
expr|enum
name|fman_rtc_alarm_polarity
operator|)
name|alarmPolarity
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigExternalTriggerPolarity
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|triggerId
parameter_list|,
name|e_FmRtcTriggerPolarity
name|triggerPolarity
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|triggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External trigger ID"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|trigger_polarity
index|[
name|triggerId
index|]
operator|=
operator|(
expr|enum
name|fman_rtc_trigger_polarity
operator|)
name|triggerPolarity
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Enable
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|resetClock
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_rtc_enable
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|resetClock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Disable
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* TODO A check must be added here, that no timestamping MAC's      * are working in this stage. */
name|fman_rtc_disable
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetClockOffset
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|int64_t
name|offset
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_rtc_set_timer_offset
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetAlarm
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|t_FmRtcAlarmParams
modifier|*
name|p_FmRtcAlarmParams
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint64_t
name|tmpAlarm
decl_stmt|;
name|bool
name|enable
init|=
name|FALSE
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|alarmId
operator|>=
name|FM_RTC_NUM_OF_ALARMS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm ID"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|alarmTime
operator|<
name|p_Rtc
operator|->
name|clockPeriodNanoSec
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm time must be equal or larger than RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
name|tmpAlarm
operator|=
name|p_FmRtcAlarmParams
operator|->
name|alarmTime
expr_stmt|;
if|if
condition|(
name|do_div
argument_list|(
name|tmpAlarm
argument_list|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm time must be a multiple of RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|f_AlarmCallback
condition|)
block|{
name|p_Rtc
operator|->
name|alarmParams
index|[
name|p_FmRtcAlarmParams
operator|->
name|alarmId
index|]
operator|.
name|f_AlarmCallback
operator|=
name|p_FmRtcAlarmParams
operator|->
name|f_AlarmCallback
expr_stmt|;
name|p_Rtc
operator|->
name|alarmParams
index|[
name|p_FmRtcAlarmParams
operator|->
name|alarmId
index|]
operator|.
name|clearOnExpiration
operator|=
name|p_FmRtcAlarmParams
operator|->
name|clearOnExpiration
expr_stmt|;
name|enable
operator|=
name|TRUE
expr_stmt|;
block|}
name|fman_rtc_set_alarm
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|p_FmRtcAlarmParams
operator|->
name|alarmId
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tmpAlarm
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetPeriodicPulse
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|t_FmRtcPeriodicPulseParams
modifier|*
name|p_FmRtcPeriodicPulseParams
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|bool
name|enable
init|=
name|FALSE
decl_stmt|;
name|uint64_t
name|tmpFiper
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
operator|>=
name|FM_RTC_NUM_OF_PERIODIC_PULSES
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse ID"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fman_rtc_is_enabled
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Can't set Periodic pulse when RTC is enabled."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulsePeriod
operator|<
name|p_Rtc
operator|->
name|clockPeriodNanoSec
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse must be equal or larger than RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
name|tmpFiper
operator|=
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulsePeriod
expr_stmt|;
if|if
condition|(
name|do_div
argument_list|(
name|tmpFiper
argument_list|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse must be a multiple of RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpFiper
operator|&
literal|0xffffffff00000000LL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse/RTC Period must be smaller than 4294967296"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|f_PeriodicPulseCallback
condition|)
block|{
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
index|]
operator|.
name|f_PeriodicPulseCallback
operator|=
name|p_FmRtcPeriodicPulseParams
operator|->
name|f_PeriodicPulseCallback
expr_stmt|;
name|enable
operator|=
name|TRUE
expr_stmt|;
block|}
name|fman_rtc_set_periodic_pulse
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpFiper
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ClearPeriodicPulse
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|periodicPulseId
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|periodicPulseId
operator|>=
name|FM_RTC_NUM_OF_PERIODIC_PULSES
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse ID"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
name|periodicPulseId
index|]
operator|.
name|f_PeriodicPulseCallback
operator|=
name|NULL
expr_stmt|;
name|fman_rtc_clear_periodic_pulse
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|periodicPulseId
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetExternalTrigger
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|t_FmRtcExternalTriggerParams
modifier|*
name|p_FmRtcExternalTriggerParams
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|bool
name|enable
init|=
name|FALSE
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External Trigger ID"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|f_ExternalTriggerCallback
condition|)
block|{
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
index|]
operator|.
name|f_ExternalTriggerCallback
operator|=
name|p_FmRtcExternalTriggerParams
operator|->
name|f_ExternalTriggerCallback
expr_stmt|;
name|enable
operator|=
name|TRUE
expr_stmt|;
block|}
name|fman_rtc_set_ext_trigger
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
argument_list|,
name|enable
argument_list|,
name|p_FmRtcExternalTriggerParams
operator|->
name|usePulseAsInput
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ClearExternalTrigger
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|externalTriggerId
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|externalTriggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External Trigger ID"
operator|)
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
name|externalTriggerId
index|]
operator|.
name|f_ExternalTriggerCallback
operator|=
name|NULL
expr_stmt|;
name|fman_rtc_clear_external_trigger
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|externalTriggerId
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_GetExternalTriggerTimeStamp
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|triggerId
parameter_list|,
name|uint64_t
modifier|*
name|p_TimeStamp
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|triggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External trigger ID"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_TimeStamp
operator|=
name|fman_rtc_get_trigger_stamp
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|triggerId
argument_list|)
operator|*
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_GetCurrentTime
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint64_t
modifier|*
name|p_Ts
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
operator|*
name|p_Ts
operator|=
name|fman_rtc_get_timer
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|)
operator|*
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetCurrentTime
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint64_t
name|ts
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|do_div
argument_list|(
name|ts
argument_list|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
argument_list|)
expr_stmt|;
name|fman_rtc_set_timer
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
operator|(
name|int64_t
operator|)
name|ts
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_GetFreqCompensation
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
modifier|*
name|p_Compensation
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
operator|*
name|p_Compensation
operator|=
name|fman_rtc_get_frequency_compensation
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetFreqCompensation
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
name|freqCompensation
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* set the new freqCompensation */
name|fman_rtc_set_frequency_compensation
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|freqCompensation
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PTP_1588_CLOCK_DPAA
end_ifdef

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_EnableInterrupt
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
name|events
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* enable interrupt */
name|fman_rtc_enable_interupt
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|events
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_DisableInterrupt
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
name|events
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* disable interrupt */
name|fman_rtc_disable_interupt
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
argument_list|,
name|events
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

