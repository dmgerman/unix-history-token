begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_rtc.c   @Description   FM RTC driver implementation.   @Cautions      None */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"part_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"ncsw_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_rtc.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|SetDefaultParam
parameter_list|(
name|t_FmRtc
modifier|*
name|p_Rtc
parameter_list|)
block|{
name|t_FmRtcDriverParam
modifier|*
name|p_RtcDriverParam
init|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p_Rtc
operator|->
name|outputClockDivisor
operator|=
name|DEFAULT_outputClockDivisor
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
operator|=
name|DEFAULT_bypass
expr_stmt|;
name|p_RtcDriverParam
operator|->
name|srcClk
operator|=
name|DEFAULT_srcClock
expr_stmt|;
name|p_RtcDriverParam
operator|->
name|invertInputClkPhase
operator|=
name|DEFAULT_invertInputClkPhase
expr_stmt|;
name|p_RtcDriverParam
operator|->
name|invertOutputClkPhase
operator|=
name|DEFAULT_invertOutputClkPhase
expr_stmt|;
name|p_RtcDriverParam
operator|->
name|pulseRealign
operator|=
name|DEFAULT_pulseRealign
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_ALARMS
condition|;
name|i
operator|++
control|)
block|{
name|p_RtcDriverParam
operator|->
name|alarmPolarity
index|[
name|i
index|]
operator|=
name|DEFAULT_alarmPolarity
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|;
name|i
operator|++
control|)
block|{
name|p_RtcDriverParam
operator|->
name|triggerPolarity
index|[
name|i
index|]
operator|=
name|DEFAULT_triggerPolarity
expr_stmt|;
block|}
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|=
name|DEFAULT_clockPeriod
expr_stmt|;
comment|/* 1 usec */
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CheckInitParameters
parameter_list|(
name|t_FmRtc
modifier|*
name|p_Rtc
parameter_list|)
block|{
name|t_FmRtcDriverParam
modifier|*
name|p_RtcDriverParam
init|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p_RtcDriverParam
operator|->
name|srcClk
operator|!=
name|e_FM_RTC_SOURCE_CLOCK_EXTERNAL
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|srcClk
operator|!=
name|e_FM_RTC_SOURCE_CLOCK_SYSTEM
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|srcClk
operator|!=
name|e_FM_RTC_SOURCE_CLOCK_OSCILATOR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_CLOCK
argument_list|,
operator|(
literal|"Source clock undefined"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Rtc
operator|->
name|outputClockDivisor
operator|==
literal|0
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Divisor for output clock (should be positive)"
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_ALARMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_RtcDriverParam
operator|->
name|alarmPolarity
index|[
name|i
index|]
operator|!=
name|e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|alarmPolarity
index|[
name|i
index|]
operator|!=
name|e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH
operator|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm %d signal polarity"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_RtcDriverParam
operator|->
name|triggerPolarity
index|[
name|i
index|]
operator|!=
name|e_FM_RTC_TRIGGER_ON_FALLING_EDGE
operator|)
operator|&&
operator|(
name|p_RtcDriverParam
operator|->
name|triggerPolarity
index|[
name|i
index|]
operator|!=
name|e_FM_RTC_TRIGGER_ON_RISING_EDGE
operator|)
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Trigger %d signal polarity"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FM_1588_SRC_CLK_ERRATA_FMAN1
block|{
name|t_FmRevisionInfo
name|revInfo
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|revInfo
operator|.
name|majorRev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|revInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|p_RtcDriverParam
operator|->
name|srcClk
operator|==
name|e_FM_RTC_SOURCE_CLOCK_SYSTEM
operator|)
operator|&&
name|p_RtcDriverParam
operator|->
name|invertInputClkPhase
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Can not use invertInputClkPhase when source clock is e_FM_RTC_SOURCE_CLOCK_SYSTEM"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_1588_SRC_CLK_ERRATA_FMAN1 */
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|RtcExceptions
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|t_FmRtcMemMap
modifier|*
name|p_MemMap
decl_stmt|;
specifier|register
name|uint32_t
name|events
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
name|p_MemMap
operator|=
name|p_Rtc
operator|->
name|p_MemMap
expr_stmt|;
comment|/* Get valid events */
name|events
operator|=
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_tevent
argument_list|)
expr_stmt|;
name|events
operator|&=
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
expr_stmt|;
comment|/* Clear event bits */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_tevent
argument_list|,
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|TMR_TEVENT_ALM1
condition|)
block|{
if|if
condition|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|0
index|]
operator|.
name|clearOnExpiration
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_alarm
index|[
literal|0
index|]
operator|.
name|tmr_alarm_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator|&
operator|~
name|TMR_TEVENT_ALM1
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|0
index|]
operator|.
name|f_AlarmCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|0
index|]
operator|.
name|f_AlarmCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|TMR_TEVENT_ALM2
condition|)
block|{
if|if
condition|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|1
index|]
operator|.
name|clearOnExpiration
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_alarm
index|[
literal|1
index|]
operator|.
name|tmr_alarm_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator|&
operator|~
name|TMR_TEVENT_ALM2
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|1
index|]
operator|.
name|f_AlarmCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|alarmParams
index|[
literal|1
index|]
operator|.
name|f_AlarmCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|TMR_TEVENT_PP1
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|0
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|0
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|TMR_TEVENT_PP2
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|1
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
literal|1
index|]
operator|.
name|f_PeriodicPulseCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|TMR_TEVENT_ETS1
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|0
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|0
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|TMR_TEVENT_ETS2
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|1
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
literal|1
index|]
operator|.
name|f_ExternalTriggerCallback
argument_list|(
name|p_Rtc
operator|->
name|h_App
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Handle
name|FM_RTC_Config
parameter_list|(
name|t_FmRtcParams
modifier|*
name|p_FmRtcParam
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmRtcParam
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate memory for the FM RTC driver parameters */
name|p_Rtc
operator|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmRtc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Rtc
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM RTC driver structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Rtc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmRtc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate memory for the FM RTC driver parameters */
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|=
operator|(
name|t_FmRtcDriverParam
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmRtcDriverParam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM RTC driver parameters"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmRtcDriverParam
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store RTC configuration parameters */
name|p_Rtc
operator|->
name|h_Fm
operator|=
name|p_FmRtcParam
operator|->
name|h_Fm
expr_stmt|;
comment|/* Set default RTC configuration parameters */
name|SetDefaultParam
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
comment|/* Store RTC parameters in the RTC control structure */
name|p_Rtc
operator|->
name|p_MemMap
operator|=
operator|(
name|t_FmRtcMemMap
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_FmRtcParam
operator|->
name|baseAddress
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|h_App
operator|=
name|p_FmRtcParam
operator|->
name|h_App
expr_stmt|;
return|return
name|p_Rtc
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Init
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|t_FmRtcDriverParam
modifier|*
name|p_RtcDriverParam
decl_stmt|;
name|t_FmRtcMemMap
modifier|*
name|p_MemMap
decl_stmt|;
name|uint32_t
name|freqCompensation
decl_stmt|;
name|uint32_t
name|tmrCtrl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|tmpDouble
decl_stmt|;
name|p_RtcDriverParam
operator|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
expr_stmt|;
name|p_MemMap
operator|=
name|p_Rtc
operator|->
name|p_MemMap
expr_stmt|;
if|if
condition|(
name|CheckInitParameters
argument_list|(
name|p_Rtc
argument_list|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Init Parameters are not Valid"
operator|)
argument_list|)
expr_stmt|;
comment|/* TODO A check must be added here, that no timestamping MAC's      * are working in this stage. */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
name|TMR_CTRL_TMSR
argument_list|)
expr_stmt|;
name|XX_UDelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the source clock */
switch|switch
condition|(
name|p_RtcDriverParam
operator|->
name|srcClk
condition|)
block|{
case|case
name|e_FM_RTC_SOURCE_CLOCK_SYSTEM
case|:
name|tmrCtrl
operator|=
name|TMR_CTRL_CKSEL_MAC_CLK
expr_stmt|;
break|break;
case|case
name|e_FM_RTC_SOURCE_CLOCK_OSCILATOR
case|:
name|tmrCtrl
operator|=
name|TMR_CTRL_CKSEL_OSC_CLK
expr_stmt|;
break|break;
default|default:
comment|/* Use a clock from the External TMR reference clock.*/
name|tmrCtrl
operator|=
name|TMR_CTRL_CKSEL_EXT_CLK
expr_stmt|;
break|break;
block|}
comment|/* whatever period the user picked, the timestamp will advance in '1' every time      * the period passed. */
name|tmrCtrl
operator||=
operator|(
operator|(
literal|1
operator|<<
name|TMR_CTRL_TCLK_PERIOD_SHIFT
operator|)
operator|&
name|TMR_CTRL_TCLK_PERIOD_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|p_RtcDriverParam
operator|->
name|invertInputClkPhase
condition|)
name|tmrCtrl
operator||=
name|TMR_CTRL_CIPH
expr_stmt|;
if|if
condition|(
name|p_RtcDriverParam
operator|->
name|invertOutputClkPhase
condition|)
name|tmrCtrl
operator||=
name|TMR_CTRL_COPH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_ALARMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_RtcDriverParam
operator|->
name|alarmPolarity
index|[
name|i
index|]
operator|==
name|e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW
condition|)
name|tmrCtrl
operator||=
operator|(
name|TMR_CTRL_ALMP1
operator|>>
name|i
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_RtcDriverParam
operator|->
name|triggerPolarity
index|[
name|i
index|]
operator|==
name|e_FM_RTC_TRIGGER_ON_FALLING_EDGE
condition|)
name|tmrCtrl
operator||=
operator|(
name|TMR_CTRL_ETEP1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_RtcDriverParam
operator|->
name|timerSlaveMode
operator|&&
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
condition|)
name|tmrCtrl
operator||=
name|TMR_CTRL_BYP
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
name|tmrCtrl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_RTC_NUM_OF_ALARMS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Clear TMR_ALARM registers */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_alarm
index|[
name|i
index|]
operator|.
name|tmr_alarm_l
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_alarm
index|[
name|i
index|]
operator|.
name|tmr_alarm_h
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
comment|/* Clear TMR_TEVENT */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_tevent
argument_list|,
name|TMR_TEVENT_ALL
argument_list|)
expr_stmt|;
comment|/* Initialize TMR_TEMASK */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find source clock frequency in Mhz */
if|if
condition|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|srcClk
operator|!=
name|e_FM_RTC_SOURCE_CLOCK_SYSTEM
condition|)
name|p_Rtc
operator|->
name|srcClkFreqMhz
operator|=
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|extSrcClkFreq
expr_stmt|;
else|else
name|p_Rtc
operator|->
name|srcClkFreqMhz
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|FmGetClockFreq
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* if timer in Master mode Initialize TMR_CTRL */
comment|/* We want the counter (TMR_CNT) to count in nano-seconds */
if|if
condition|(
operator|!
name|p_RtcDriverParam
operator|->
name|timerSlaveMode
operator|&&
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
condition|)
block|{
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|=
operator|(
literal|1000
operator|/
name|p_Rtc
operator|->
name|srcClkFreqMhz
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize TMR_ADD with the initial frequency compensation value:            freqCompensation = (2^32 / frequency ratio) */
comment|/* frequency ratio = sorce clock/rtc clock =          * (p_Rtc->srcClkFreqMhz*1000000))/ 1/(p_Rtc->clockPeriodNanoSec * 1000000000) */
name|freqCompensation
operator|=
operator|(
name|uint32_t
operator|)
name|DIV_CEIL
argument_list|(
name|ACCUMULATOR_OVERFLOW
operator|*
literal|1000
argument_list|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|*
name|p_Rtc
operator|->
name|srcClkFreqMhz
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_add
argument_list|,
name|freqCompensation
argument_list|)
expr_stmt|;
block|}
comment|/* check the legality of the relation between source and destination clocks */
comment|/* should be larger than 1.0001 */
name|tmpDouble
operator|=
literal|10000
operator|*
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|*
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|srcClkFreqMhz
expr_stmt|;
if|if
condition|(
operator|(
name|tmpDouble
operator|)
operator|<=
literal|10001
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Invalid relation between source and destination clocks. Should be larger than 1.0001"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
comment|/* Clear TMR_FIPER registers */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_fiper
index|[
name|i
index|]
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Initialize TMR_PRSC */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_prsc
argument_list|,
name|p_Rtc
operator|->
name|outputClockDivisor
argument_list|)
expr_stmt|;
comment|/* Clear TMR_OFF */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_off_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_off_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Register the FM RTC interrupt */
name|FmRegisterIntr
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_TMR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|,
name|RtcExceptions
argument_list|,
name|p_Rtc
argument_list|)
expr_stmt|;
comment|/* Free parameters structures */
name|XX_Free
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|=
name|NULL
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Free
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FM_RTC_Disable
argument_list|(
name|h_FmRtc
argument_list|)
expr_stmt|;
block|}
comment|/* Unregister FM RTC interrupt */
name|FmUnregisterIntr
argument_list|(
name|p_Rtc
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_TMR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Rtc
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigSourceClock
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|e_FmSrcClk
name|srcClk
parameter_list|,
name|uint32_t
name|freqInMhz
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|srcClk
operator|=
name|srcClk
expr_stmt|;
if|if
condition|(
name|srcClk
operator|!=
name|e_FM_RTC_SOURCE_CLOCK_SYSTEM
condition|)
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|extSrcClkFreq
operator|=
name|freqInMhz
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigPeriod
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
name|period
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|=
name|period
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigFrequencyBypass
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|enabled
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|bypass
operator|=
name|enabled
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigInvertedInputClockPhase
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|inverted
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|invertInputClkPhase
operator|=
name|inverted
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigInvertedOutputClockPhase
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|inverted
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|invertOutputClkPhase
operator|=
name|inverted
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigOutputClockDivisor
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint16_t
name|divisor
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|outputClockDivisor
operator|=
name|divisor
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigPulseRealignment
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|pulseRealign
operator|=
name|enable
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigAlarmPolarity
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|alarmId
parameter_list|,
name|e_FmRtcAlarmPolarity
name|alarmPolarity
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|alarmId
operator|>=
name|FM_RTC_NUM_OF_ALARMS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm ID"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|alarmPolarity
index|[
name|alarmId
index|]
operator|=
name|alarmPolarity
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ConfigExternalTriggerPolarity
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|triggerId
parameter_list|,
name|e_FmRtcTriggerPolarity
name|triggerPolarity
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|triggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External trigger ID"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Rtc
operator|->
name|p_RtcDriverParam
operator|->
name|triggerPolarity
index|[
name|triggerId
index|]
operator|=
name|triggerPolarity
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Enable
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|bool
name|resetClock
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint32_t
name|tmrCtrl
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|tmrCtrl
operator|=
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
expr_stmt|;
comment|/* TODO A check must be added here, that no timestamping MAC's      * are working in this stage. */
if|if
condition|(
name|resetClock
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
operator|(
name|tmrCtrl
operator||
name|TMR_CTRL_TMSR
operator|)
argument_list|)
expr_stmt|;
name|XX_UDelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear TMR_OFF */
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_off_l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_off_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
operator|(
name|tmrCtrl
operator||
name|TMR_CTRL_TE
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_Disable
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint32_t
name|tmrCtrl
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* TODO A check must be added here, that no timestamping MAC's      * are working in this stage. */
name|tmrCtrl
operator|=
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
operator|(
name|tmrCtrl
operator|&
operator|~
operator|(
name|TMR_CTRL_TE
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetClockOffset
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|int64_t
name|offset
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* TMR_OFF_L must be written first */
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_off_l
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_off_h
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|offset
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetAlarm
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|t_FmRtcAlarmParams
modifier|*
name|p_FmRtcAlarmParams
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|t_FmRtcMemMap
modifier|*
name|p_MemMap
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint64_t
name|tmpAlarm
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_MemMap
operator|=
name|p_Rtc
operator|->
name|p_MemMap
expr_stmt|;
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|alarmId
operator|>=
name|FM_RTC_NUM_OF_ALARMS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm ID"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|alarmTime
operator|<
name|p_Rtc
operator|->
name|clockPeriodNanoSec
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm time must be equal or larger than RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|alarmTime
operator|%
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Alarm time must be a multiple of RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
name|tmpAlarm
operator|=
name|p_FmRtcAlarmParams
operator|->
name|alarmTime
operator|/
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
comment|/* TMR_ALARM_L must be written first */
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_alarm
index|[
name|p_FmRtcAlarmParams
operator|->
name|alarmId
index|]
operator|.
name|tmr_alarm_l
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpAlarm
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_alarm
index|[
name|p_FmRtcAlarmParams
operator|->
name|alarmId
index|]
operator|.
name|tmr_alarm_h
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpAlarm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|f_AlarmCallback
condition|)
block|{
name|p_Rtc
operator|->
name|alarmParams
index|[
name|p_FmRtcAlarmParams
operator|->
name|alarmId
index|]
operator|.
name|f_AlarmCallback
operator|=
name|p_FmRtcAlarmParams
operator|->
name|f_AlarmCallback
expr_stmt|;
name|p_Rtc
operator|->
name|alarmParams
index|[
name|p_FmRtcAlarmParams
operator|->
name|alarmId
index|]
operator|.
name|clearOnExpiration
operator|=
name|p_FmRtcAlarmParams
operator|->
name|clearOnExpiration
expr_stmt|;
if|if
condition|(
name|p_FmRtcAlarmParams
operator|->
name|alarmId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_TEVENT_ALM1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_TEVENT_ALM2
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator||
name|tmpReg
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetPeriodicPulse
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|t_FmRtcPeriodicPulseParams
modifier|*
name|p_FmRtcPeriodicPulseParams
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|t_FmRtcMemMap
modifier|*
name|p_MemMap
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|uint64_t
name|tmpFiper
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_MemMap
operator|=
name|p_Rtc
operator|->
name|p_MemMap
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
operator|>=
name|FM_RTC_NUM_OF_PERIODIC_PULSES
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse ID"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
operator|&
name|TMR_CTRL_TE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Can't set Periodic pulse when RTC is enabled."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulsePeriod
operator|<
name|p_Rtc
operator|->
name|clockPeriodNanoSec
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse must be equal or larger than RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulsePeriod
operator|%
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse must be a multiple of RTC period - %d nanoseconds"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
name|tmpFiper
operator|=
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulsePeriod
operator|/
operator|(
name|uint64_t
operator|)
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
if|if
condition|(
name|tmpFiper
operator|&
literal|0xffffffff00000000LL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse/RTC Period must be smaller than 4294967296"
operator|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_fiper
index|[
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
index|]
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpFiper
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|f_PeriodicPulseCallback
condition|)
block|{
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
index|]
operator|.
name|f_PeriodicPulseCallback
operator|=
name|p_FmRtcPeriodicPulseParams
operator|->
name|f_PeriodicPulseCallback
expr_stmt|;
if|if
condition|(
name|p_FmRtcPeriodicPulseParams
operator|->
name|periodicPulseId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_TEVENT_PP1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_TEVENT_PP2
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator||
name|tmpReg
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ClearPeriodicPulse
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|periodicPulseId
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|periodicPulseId
operator|>=
name|FM_RTC_NUM_OF_PERIODIC_PULSES
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Periodic pulse ID"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Rtc
operator|->
name|periodicPulseParams
index|[
name|periodicPulseId
index|]
operator|.
name|f_PeriodicPulseCallback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|periodicPulseId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_TEVENT_PP1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_TEVENT_PP2
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator|&
operator|~
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
operator|&
name|TMR_CTRL_FS
condition|)
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
operator|&
operator|~
name|TMR_CTRL_FS
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_fiper
index|[
name|periodicPulseId
index|]
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetExternalTrigger
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|t_FmRtcExternalTriggerParams
modifier|*
name|p_FmRtcExternalTriggerParams
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External Trigger ID"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|f_ExternalTriggerCallback
condition|)
block|{
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
index|]
operator|.
name|f_ExternalTriggerCallback
operator|=
name|p_FmRtcExternalTriggerParams
operator|->
name|f_ExternalTriggerCallback
expr_stmt|;
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_TEVENT_ETS1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_TEVENT_ETS2
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator||
name|tmpReg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|usePulseAsInput
condition|)
block|{
if|if
condition|(
name|p_FmRtcExternalTriggerParams
operator|->
name|externalTriggerId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_CTRL_PP1L
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_CTRL_PP2L
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
operator||
name|tmpReg
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_ClearExternalTrigger
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|externalTriggerId
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|externalTriggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External Trigger ID"
operator|)
argument_list|)
expr_stmt|;
name|p_Rtc
operator|->
name|externalTriggerParams
index|[
name|externalTriggerId
index|]
operator|.
name|f_ExternalTriggerCallback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|externalTriggerId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_TEVENT_ETS1
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_TEVENT_ETS2
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_temask
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_temask
argument_list|)
operator|&
operator|~
name|tmpReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|externalTriggerId
operator|==
literal|0
condition|)
name|tmpReg
operator|=
name|TMR_CTRL_PP1L
expr_stmt|;
else|else
name|tmpReg
operator|=
name|TMR_CTRL_PP2L
expr_stmt|;
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
operator|&
name|tmpReg
condition|)
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_ctrl
argument_list|)
operator|&
operator|~
name|tmpReg
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_GetExternalTriggerTimeStamp
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint8_t
name|triggerId
parameter_list|,
name|uint64_t
modifier|*
name|p_TimeStamp
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint64_t
name|timeStamp
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|triggerId
operator|>=
name|FM_RTC_NUM_OF_EXT_TRIGGERS
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"External trigger ID"
operator|)
argument_list|)
expr_stmt|;
block|}
name|timeStamp
operator|=
operator|(
name|uint64_t
operator|)
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_etts
index|[
name|triggerId
index|]
operator|.
name|tmr_etts_l
argument_list|)
expr_stmt|;
name|timeStamp
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_etts
index|[
name|triggerId
index|]
operator|.
name|tmr_etts_h
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|timeStamp
operator|=
name|timeStamp
operator|*
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
operator|*
name|p_TimeStamp
operator|=
name|timeStamp
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_GetCurrentTime
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint64_t
modifier|*
name|p_Ts
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|uint64_t
name|time
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* TMR_CNT_L must be read first to get an accurate value */
name|time
operator|=
operator|(
name|uint64_t
operator|)
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_cnt_l
argument_list|)
expr_stmt|;
name|time
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|GET_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_cnt_h
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
name|time
operator|=
name|time
operator|*
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
operator|*
name|p_Ts
operator|=
name|time
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetCurrentTime
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint64_t
name|ts
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|ts
operator|=
name|ts
operator|/
name|p_Rtc
operator|->
name|clockPeriodNanoSec
expr_stmt|;
comment|/* TMR_CNT_L must be written first to get an accurate value */
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_cnt_l
argument_list|,
operator|(
name|uint32_t
operator|)
name|ts
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_cnt_h
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ts
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_GetFreqCompensation
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
modifier|*
name|p_Compensation
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
operator|*
name|p_Compensation
operator|=
operator|(
name|uint32_t
operator|)
name|DIV_CEIL
argument_list|(
name|ACCUMULATOR_OVERFLOW
operator|*
literal|1000
argument_list|,
name|p_Rtc
operator|->
name|clockPeriodNanoSec
operator|*
name|p_Rtc
operator|->
name|srcClkFreqMhz
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_RTC_SetFreqCompensation
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|,
name|uint32_t
name|freqCompensation
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Rtc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Rtc
operator|->
name|p_RtcDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* set the new freqCompensation */
name|WRITE_UINT32
argument_list|(
name|p_Rtc
operator|->
name|p_MemMap
operator|->
name|tmr_add
argument_list|,
name|freqCompensation
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ERRORS
argument_list|)
operator|&&
operator|(
name|DEBUG_ERRORS
operator|>
literal|0
operator|)
operator|)
end_if

begin_function
name|t_Error
name|FM_RTC_DumpRegs
parameter_list|(
name|t_Handle
name|h_FmRtc
parameter_list|)
block|{
name|t_FmRtc
modifier|*
name|p_Rtc
init|=
operator|(
name|t_FmRtc
operator|*
operator|)
name|h_FmRtc
decl_stmt|;
name|t_FmRtcMemMap
modifier|*
name|p_MemMap
init|=
name|p_Rtc
operator|->
name|p_MemMap
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|DECLARE_DUMP
expr_stmt|;
if|if
condition|(
name|p_MemMap
condition|)
block|{
name|DUMP_TITLE
argument_list|(
name|p_MemMap
argument_list|,
operator|(
literal|"RTC:"
operator|)
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_id
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_id2
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_ctrl
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_tevent
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_temask
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_cnt_h
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_cnt_l
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_ctrl
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_add
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_acc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_prsc
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_off_h
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_off_l
argument_list|)
expr_stmt|;
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
literal|2
argument_list|)
block|{
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_alarm
index|[
name|i
index|]
operator|.
name|tmr_alarm_h
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_alarm
index|[
name|i
index|]
operator|.
name|tmr_alarm_l
argument_list|)
expr_stmt|;
block|}
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
literal|2
argument_list|)
block|{
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_fiper
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_fiper
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DUMP_SUBSTRUCT_ARRAY
argument_list|(
argument|i
argument_list|,
literal|2
argument_list|)
block|{
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_etts
index|[
name|i
index|]
operator|.
name|tmr_etts_l
argument_list|)
expr_stmt|;
name|DUMP_VAR
argument_list|(
name|p_MemMap
argument_list|,
name|tmr_etts
index|[
name|i
index|]
operator|.
name|tmr_etts_l
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(DEBUG_ERRORS)&& ... */
end_comment

end_unit

