begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          memac.c   @Description   FM mEMAC driver */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"endian_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"memac.h"
end_include

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*                      Internal routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|uint32_t
name|GetMacAddrHashCode
parameter_list|(
name|uint64_t
name|ethAddr
parameter_list|)
block|{
name|uint64_t
name|mask1
decl_stmt|,
name|mask2
decl_stmt|;
name|uint32_t
name|xorVal
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|mask1
operator|=
name|ethAddr
operator|&
operator|(
name|uint64_t
operator|)
literal|0x01
expr_stmt|;
name|ethAddr
operator|>>=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
name|mask2
operator|=
name|ethAddr
operator|&
operator|(
name|uint64_t
operator|)
literal|0x01
expr_stmt|;
name|mask1
operator|^=
name|mask2
expr_stmt|;
name|ethAddr
operator|>>=
literal|1
expr_stmt|;
block|}
name|xorVal
operator||=
operator|(
name|mask1
operator|<<
operator|(
literal|5
operator|-
name|i
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|xorVal
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|void
name|SetupSgmiiInternalPhy
parameter_list|(
name|t_Memac
modifier|*
name|p_Memac
parameter_list|,
name|uint8_t
name|phyAddr
parameter_list|)
block|{
name|uint16_t
name|tmpReg16
decl_stmt|;
name|e_EnetMode
name|enetMode
decl_stmt|;
comment|/* In case the higher MACs are used (i.e. the MACs that should support 10G),         speed=10000 is provided for SGMII ports. Temporary modify enet mode         to 1G one, so MII functions can work correctly. */
name|enetMode
operator|=
name|p_Memac
operator|->
name|enetMode
expr_stmt|;
comment|/* SGMII mode + AN enable */
name|tmpReg16
operator|=
name|PHY_SGMII_IF_MODE_AN
operator||
name|PHY_SGMII_IF_MODE_SGMII
expr_stmt|;
if|if
condition|(
operator|(
name|p_Memac
operator|->
name|enetMode
operator|)
operator|==
name|e_ENET_MODE_SGMII_2500
condition|)
name|tmpReg16
operator|=
name|PHY_SGMII_CR_PHY_RESET
operator||
name|PHY_SGMII_IF_SPEED_GIGABIT
operator||
name|PHY_SGMII_IF_MODE_SGMII
expr_stmt|;
name|p_Memac
operator|->
name|enetMode
operator|=
name|MAKE_ENET_MODE
argument_list|(
name|ENET_INTERFACE_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
argument_list|,
name|e_ENET_SPEED_1000
argument_list|)
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x14
argument_list|,
name|tmpReg16
argument_list|)
expr_stmt|;
comment|/* Device ability according to SGMII specification */
name|tmpReg16
operator|=
name|PHY_SGMII_DEV_ABILITY_SGMII
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x4
argument_list|,
name|tmpReg16
argument_list|)
expr_stmt|;
comment|/* Adjust link timer for SGMII  -        According to Cisco SGMII specification the timer should be 1.6 ms.        The link_timer register is configured in units of the clock.        - When running as 1G SGMII, Serdes clock is 125 MHz, so          unit = 1 / (125*10^6 Hz) = 8 ns.          1.6 ms in units of 8 ns = 1.6ms / 8ns = 2 * 10^5 = 0x30d40        - When running as 2.5G SGMII, Serdes clock is 312.5 MHz, so          unit = 1 / (312.5*10^6 Hz) = 3.2 ns.          1.6 ms in units of 3.2 ns = 1.6ms / 3.2ns = 5 * 10^5 = 0x7a120.        Since link_timer value of 1G SGMII will be too short for 2.5 SGMII,        we always set up here a value of 2.5 SGMII. */
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x13
argument_list|,
literal|0x0007
argument_list|)
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x12
argument_list|,
literal|0xa120
argument_list|)
expr_stmt|;
comment|/* Restart AN */
name|tmpReg16
operator|=
name|PHY_SGMII_CR_DEF_VAL
operator||
name|PHY_SGMII_CR_RESET_AN
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x0
argument_list|,
name|tmpReg16
argument_list|)
expr_stmt|;
comment|/* Restore original enet mode */
name|p_Memac
operator|->
name|enetMode
operator|=
name|enetMode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|void
name|SetupSgmiiInternalPhyBaseX
parameter_list|(
name|t_Memac
modifier|*
name|p_Memac
parameter_list|,
name|uint8_t
name|phyAddr
parameter_list|)
block|{
name|uint16_t
name|tmpReg16
decl_stmt|;
name|e_EnetMode
name|enetMode
decl_stmt|;
comment|/* In case the higher MACs are used (i.e. the MACs that should support 10G),         speed=10000 is provided for SGMII ports. Temporary modify enet mode         to 1G one, so MII functions can work correctly. */
name|enetMode
operator|=
name|p_Memac
operator|->
name|enetMode
expr_stmt|;
name|p_Memac
operator|->
name|enetMode
operator|=
name|MAKE_ENET_MODE
argument_list|(
name|ENET_INTERFACE_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
argument_list|,
name|e_ENET_SPEED_1000
argument_list|)
expr_stmt|;
comment|/* 1000BaseX mode */
name|tmpReg16
operator|=
name|PHY_SGMII_IF_MODE_1000X
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x14
argument_list|,
name|tmpReg16
argument_list|)
expr_stmt|;
comment|/* AN Device capability  */
name|tmpReg16
operator|=
name|PHY_SGMII_DEV_ABILITY_1000X
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x4
argument_list|,
name|tmpReg16
argument_list|)
expr_stmt|;
comment|/* Adjust link timer for SGMII  -        For Serdes 1000BaseX auto-negotiation the timer should be 10 ms.        The link_timer register is configured in units of the clock.        - When running as 1G SGMII, Serdes clock is 125 MHz, so          unit = 1 / (125*10^6 Hz) = 8 ns.          10 ms in units of 8 ns = 10ms / 8ns = 1250000 = 0x1312d0        - When running as 2.5G SGMII, Serdes clock is 312.5 MHz, so          unit = 1 / (312.5*10^6 Hz) = 3.2 ns.          10 ms in units of 3.2 ns = 10ms / 3.2ns = 3125000 = 0x2faf08.        Since link_timer value of 1G SGMII will be too short for 2.5 SGMII,        we always set up here a value of 2.5 SGMII. */
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x13
argument_list|,
literal|0x002f
argument_list|)
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x12
argument_list|,
literal|0xaf08
argument_list|)
expr_stmt|;
comment|/* Restart AN */
name|tmpReg16
operator|=
name|PHY_SGMII_CR_DEF_VAL
operator||
name|PHY_SGMII_CR_RESET_AN
expr_stmt|;
name|MEMAC_MII_WritePhyReg
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|,
literal|0x0
argument_list|,
name|tmpReg16
argument_list|)
expr_stmt|;
comment|/* Restore original enet mode */
name|p_Memac
operator|->
name|enetMode
operator|=
name|enetMode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|CheckInitParameters
parameter_list|(
name|t_Memac
modifier|*
name|p_Memac
parameter_list|)
block|{
name|e_FmMacType
name|portType
decl_stmt|;
name|portType
operator|=
operator|(
operator|(
name|ENET_SPEED_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
operator|<
name|e_ENET_SPEED_10000
operator|)
condition|?
name|e_FM_MAC_1G
else|:
name|e_FM_MAC_10G
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|FM_MAX_NUM_OF_10G_MACS
operator|>
literal|0
operator|)
if|if
condition|(
operator|(
name|portType
operator|==
name|e_FM_MAC_10G
operator|)
operator|&&
operator|(
name|p_Memac
operator|->
name|macId
operator|>=
name|FM_MAX_NUM_OF_10G_MACS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"10G MAC ID must be less than %d"
operator|,
name|FM_MAX_NUM_OF_10G_MACS
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (FM_MAX_NUM_OF_10G_MACS> 0) */
if|if
condition|(
operator|(
name|portType
operator|==
name|e_FM_MAC_1G
operator|)
operator|&&
operator|(
name|p_Memac
operator|->
name|macId
operator|>=
name|FM_MAX_NUM_OF_1G_MACS
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"1G MAC ID must be less than %d"
operator|,
name|FM_MAX_NUM_OF_1G_MACS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Memac
operator|->
name|addr
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Ethernet MAC must have a valid MAC address"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memac
operator|->
name|f_Exception
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Uninitialized f_Exception"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memac
operator|->
name|f_Event
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Uninitialized f_Event"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LEN_CHECK_ERRATA_FMAN_SW002
if|if
condition|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|no_length_check_enable
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"LengthCheck!"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ........................................................................... */
end_comment

begin_function
specifier|static
name|void
name|MemacErrException
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint32_t
name|event
decl_stmt|,
name|imask
decl_stmt|;
name|event
operator|=
name|fman_memac_get_event
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|imask
operator|=
name|fman_memac_get_interrupt_mask
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|)
expr_stmt|;
comment|/* Imask include both error and notification/event bits.        Leaving only error bits enabled by imask.        The imask error bits are shifted by 16 bits offset from        their corresponding location in the ievent - hence the>> 16 */
name|event
operator|&=
operator|(
operator|(
name|imask
operator|&
name|MEMAC_ALL_ERRS_IMASK
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|fman_memac_ack_event
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|MEMAC_IEVNT_TS_ECC_ER
condition|)
name|p_Memac
operator|->
name|f_Exception
argument_list|(
name|p_Memac
operator|->
name|h_App
argument_list|,
name|e_FM_MAC_EX_TS_FIFO_ECC_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|MEMAC_IEVNT_TX_ECC_ER
condition|)
name|p_Memac
operator|->
name|f_Exception
argument_list|(
name|p_Memac
operator|->
name|h_App
argument_list|,
name|e_FM_MAC_EX_10G_1TX_ECC_ER
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|MEMAC_IEVNT_RX_ECC_ER
condition|)
name|p_Memac
operator|->
name|f_Exception
argument_list|(
name|p_Memac
operator|->
name|h_App
argument_list|,
name|e_FM_MAC_EX_10G_RX_ECC_ER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|MemacException
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint32_t
name|event
decl_stmt|,
name|imask
decl_stmt|;
name|event
operator|=
name|fman_memac_get_event
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|imask
operator|=
name|fman_memac_get_interrupt_mask
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|)
expr_stmt|;
comment|/* Imask include both error and notification/event bits.        Leaving only error bits enabled by imask.        The imask error bits are shifted by 16 bits offset from        their corresponding location in the ievent - hence the>> 16 */
name|event
operator|&=
operator|(
operator|(
name|imask
operator|&
name|MEMAC_ALL_ERRS_IMASK
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|fman_memac_ack_event
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|MEMAC_IEVNT_MGI
condition|)
name|p_Memac
operator|->
name|f_Exception
argument_list|(
name|p_Memac
operator|->
name|h_App
argument_list|,
name|e_FM_MAC_EX_MAGIC_PACKET_INDICATION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|void
name|FreeInitResources
parameter_list|(
name|t_Memac
modifier|*
name|p_Memac
parameter_list|)
block|{
name|e_FmMacType
name|portType
decl_stmt|;
name|portType
operator|=
operator|(
operator|(
name|ENET_SPEED_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
operator|<
name|e_ENET_SPEED_10000
operator|)
condition|?
name|e_FM_MAC_1G
else|:
name|e_FM_MAC_10G
operator|)
expr_stmt|;
if|if
condition|(
name|portType
operator|==
name|e_FM_MAC_10G
condition|)
name|FmUnregisterIntr
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
name|e_FM_MOD_10G_MAC
argument_list|,
name|p_Memac
operator|->
name|macId
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|)
expr_stmt|;
else|else
name|FmUnregisterIntr
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
name|e_FM_MOD_1G_MAC
argument_list|,
name|p_Memac
operator|->
name|macId
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|)
expr_stmt|;
comment|/* release the driver's group hash table */
name|FreeHashTable
argument_list|(
name|p_Memac
operator|->
name|p_MulticastAddrHash
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MulticastAddrHash
operator|=
name|NULL
expr_stmt|;
comment|/* release the driver's individual hash table */
name|FreeHashTable
argument_list|(
name|p_Memac
operator|->
name|p_UnicastAddrHash
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_UnicastAddrHash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*                     mEMAC API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacEnable
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|e_CommMode
name|mode
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_enable
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|mode
operator|&
name|e_COMM_MODE_RX
operator|)
argument_list|,
operator|(
name|mode
operator|&
name|e_COMM_MODE_TX
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacDisable
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|e_CommMode
name|mode
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_disable
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|mode
operator|&
name|e_COMM_MODE_RX
operator|)
argument_list|,
operator|(
name|mode
operator|&
name|e_COMM_MODE_TX
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacSetPromiscuous
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|newVal
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_set_promiscuous
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* .............................................................................. */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacAdjustLink
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|e_EnetSpeed
name|speed
parameter_list|,
name|bool
name|fullDuplex
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|speed
operator|>=
name|e_ENET_SPEED_1000
operator|)
operator|&&
operator|(
operator|!
name|fullDuplex
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Ethernet MAC 1G or 10G does not support half-duplex"
operator|)
argument_list|)
expr_stmt|;
name|fman_memac_adjust_link
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
expr|enum
name|enet_interface
operator|)
name|ENET_INTERFACE_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
argument_list|,
operator|(
expr|enum
name|enet_speed
operator|)
name|speed
argument_list|,
name|fullDuplex
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*                      Memac Configs modification functions                 */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigLoopback
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|newVal
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|loopback_enable
operator|=
name|newVal
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigWan
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|newVal
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|wan_mode_enable
operator|=
name|newVal
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigMaxFrameLength
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|uint16_t
name|newVal
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|max_frame_length
operator|=
name|newVal
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigPad
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|newVal
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|pad_enable
operator|=
name|newVal
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigLengthCheck
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|newVal
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|no_length_check_enable
operator|=
operator|!
name|newVal
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigException
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|e_FmMacExceptions
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint32_t
name|bitMask
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|GET_EXCEPTION_FLAG
argument_list|(
name|bitMask
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|p_Memac
operator|->
name|exceptions
operator||=
name|bitMask
expr_stmt|;
else|else
name|p_Memac
operator|->
name|exceptions
operator|&=
operator|~
name|bitMask
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Undefined exception"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacConfigResetOnInit
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|->
name|reset_on_init
operator|=
name|enable
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*                      Memac Run Time API functions                         */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacSetTxPauseFrames
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|uint8_t
name|priority
parameter_list|,
name|uint16_t
name|pauseTime
parameter_list|,
name|uint16_t
name|threshTime
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority
operator|!=
literal|0xFF
condition|)
block|{
name|bool
name|PortConfigured
decl_stmt|,
name|PreFetchEnabled
decl_stmt|;
if|if
condition|(
name|FmGetTnumAgingPeriod
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|)
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"For PFC operation, TNUM aging must be enabled"
operator|)
argument_list|)
expr_stmt|;
name|FmGetPortPreFetchConfiguration
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|macId
argument_list|,
operator|&
name|PortConfigured
argument_list|,
operator|&
name|PreFetchEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ENET_SPEED_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|enetMode
argument_list|)
operator|==
name|e_ENET_SPEED_1000
operator|)
operator|&&
operator|!
name|PortConfigured
condition|)
name|DBG
argument_list|(
name|INFO
argument_list|,
operator|(
literal|"For PFC correct operation, prefetch must be configured on the FM Tx PORT"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ENET_SPEED_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|enetMode
argument_list|)
operator|==
name|e_ENET_SPEED_1000
operator|)
operator|&&
name|PortConfigured
operator|&&
operator|!
name|PreFetchEnabled
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"For PFC correct operation, prefetch must be configured on the FM Tx PORT"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fman_memac_set_tx_pause_frames
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|priority
argument_list|,
name|pauseTime
argument_list|,
name|threshTime
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacSetTxAutoPauseFrames
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|uint16_t
name|pauseTime
parameter_list|)
block|{
return|return
name|MemacSetTxPauseFrames
argument_list|(
name|h_Memac
argument_list|,
name|FM_MAC_NO_PFC
argument_list|,
name|pauseTime
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacSetRxIgnorePauseFrames
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|en
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_set_rx_ignore_pause_frames
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|en
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacSetWakeOnLan
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|bool
name|en
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_set_wol
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|en
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* .............................................................................. */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacEnable1588TimeStamp
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Memac
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"mEMAC has 1588 always enabled!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* Counters handling */
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacGetStatistics
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|t_FmMacStatistics
modifier|*
name|p_Statistics
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Statistics
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts64
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R64
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts65to127
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R127
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts128to255
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R255
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts256to511
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R511
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts512to1023
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R1023
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts1024to1518
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R1518
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatPkts1519to1522
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_R1519X
argument_list|)
expr_stmt|;
comment|/* */
name|p_Statistics
operator|->
name|eStatFragments
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RFRG
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatJabbers
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RJBR
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatsDropEvents
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RDRP
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatCRCAlignErrors
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RALN
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatUndersizePkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TUND
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|eStatOversizePkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_ROVR
argument_list|)
expr_stmt|;
comment|/* Pause */
name|p_Statistics
operator|->
name|reStatPause
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RXPF
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|teStatPause
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TXPF
argument_list|)
expr_stmt|;
comment|/* MIB II */
name|p_Statistics
operator|->
name|ifInOctets
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_ROCT
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifInUcastPkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RUCA
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifInMcastPkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RMCA
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifInBcastPkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RBCA
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifInPkts
operator|=
name|p_Statistics
operator|->
name|ifInUcastPkts
operator|+
name|p_Statistics
operator|->
name|ifInMcastPkts
operator|+
name|p_Statistics
operator|->
name|ifInBcastPkts
expr_stmt|;
name|p_Statistics
operator|->
name|ifInDiscards
operator|=
literal|0
expr_stmt|;
name|p_Statistics
operator|->
name|ifInErrors
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_RERR
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutOctets
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TOCT
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutUcastPkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TUCA
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutMcastPkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TMCA
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutBcastPkts
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TBCA
argument_list|)
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutPkts
operator|=
name|p_Statistics
operator|->
name|ifOutUcastPkts
operator|+
name|p_Statistics
operator|->
name|ifOutMcastPkts
operator|+
name|p_Statistics
operator|->
name|ifOutBcastPkts
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutDiscards
operator|=
literal|0
expr_stmt|;
name|p_Statistics
operator|->
name|ifOutErrors
operator|=
name|fman_memac_get_counter
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|E_MEMAC_COUNTER_TERR
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacModifyMacAddress
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|t_EnetAddr
modifier|*
name|p_EnetAddr
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_add_addr_in_paddr
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|*
name|p_EnetAddr
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacResetCounters
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fman_memac_reset_stat
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacAddExactMatchMacAddress
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|t_EnetAddr
modifier|*
name|p_EthAddr
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint64_t
name|ethAddr
decl_stmt|;
name|uint8_t
name|paddrNum
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|ethAddr
operator|=
name|ENET_ADDR_TO_UINT64
argument_list|(
operator|*
name|p_EthAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ethAddr
operator|&
name|GROUP_ADDRESS
condition|)
comment|/* Multicast address has no effect in PADDR */
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Multicast address"
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure no PADDR contains this address */
for|for
control|(
name|paddrNum
operator|=
literal|0
init|;
name|paddrNum
operator|<
name|MEMAC_NUM_OF_PADDRS
condition|;
name|paddrNum
operator|++
control|)
if|if
condition|(
name|p_Memac
operator|->
name|indAddrRegUsed
index|[
name|paddrNum
index|]
condition|)
if|if
condition|(
name|p_Memac
operator|->
name|paddr
index|[
name|paddrNum
index|]
operator|==
name|ethAddr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* Find first unused PADDR */
for|for
control|(
name|paddrNum
operator|=
literal|0
init|;
name|paddrNum
operator|<
name|MEMAC_NUM_OF_PADDRS
condition|;
name|paddrNum
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|p_Memac
operator|->
name|indAddrRegUsed
index|[
name|paddrNum
index|]
operator|)
condition|)
block|{
comment|/* mark this PADDR as used */
name|p_Memac
operator|->
name|indAddrRegUsed
index|[
name|paddrNum
index|]
operator|=
name|TRUE
expr_stmt|;
comment|/* store address */
name|p_Memac
operator|->
name|paddr
index|[
name|paddrNum
index|]
operator|=
name|ethAddr
expr_stmt|;
comment|/* put in hardware */
name|fman_memac_add_addr_in_paddr
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|*
name|p_EthAddr
operator|)
argument_list|,
name|paddrNum
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|numOfIndAddrInRegs
operator|++
expr_stmt|;
return|return
name|E_OK
return|;
block|}
comment|/* No free PADDR */
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacDelExactMatchMacAddress
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|t_EnetAddr
modifier|*
name|p_EthAddr
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint64_t
name|ethAddr
decl_stmt|;
name|uint8_t
name|paddrNum
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|ethAddr
operator|=
name|ENET_ADDR_TO_UINT64
argument_list|(
operator|*
name|p_EthAddr
argument_list|)
expr_stmt|;
comment|/* Find used PADDR containing this address */
for|for
control|(
name|paddrNum
operator|=
literal|0
init|;
name|paddrNum
operator|<
name|MEMAC_NUM_OF_PADDRS
condition|;
name|paddrNum
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_Memac
operator|->
name|indAddrRegUsed
index|[
name|paddrNum
index|]
operator|)
operator|&&
operator|(
name|p_Memac
operator|->
name|paddr
index|[
name|paddrNum
index|]
operator|==
name|ethAddr
operator|)
condition|)
block|{
comment|/* mark this PADDR as not used */
name|p_Memac
operator|->
name|indAddrRegUsed
index|[
name|paddrNum
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* clear in hardware */
name|fman_memac_clear_addr_in_paddr
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|paddrNum
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|numOfIndAddrInRegs
operator|--
expr_stmt|;
return|return
name|E_OK
return|;
block|}
block|}
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_FOUND
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacGetId
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|uint32_t
modifier|*
name|macId
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
operator|*
name|macId
operator|=
name|p_Memac
operator|->
name|macId
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacAddHashMacAddress
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|t_EnetAddr
modifier|*
name|p_EthAddr
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|t_EthHashEntry
modifier|*
name|p_HashEntry
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|uint64_t
name|ethAddr
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|ethAddr
operator|=
name|ENET_ADDR_TO_UINT64
argument_list|(
operator|*
name|p_EthAddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ethAddr
operator|&
name|GROUP_ADDRESS
operator|)
condition|)
comment|/* Unicast addresses not supported in hash */
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Unicast Address"
operator|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|GetMacAddrHashCode
argument_list|(
name|ethAddr
argument_list|)
operator|&
name|HASH_CTRL_ADDR_MASK
expr_stmt|;
comment|/* Create element to be added to the driver hash table */
name|p_HashEntry
operator|=
operator|(
name|t_EthHashEntry
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_EthHashEntry
argument_list|)
argument_list|)
expr_stmt|;
name|p_HashEntry
operator|->
name|addr
operator|=
name|ethAddr
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_HashEntry
operator|->
name|node
argument_list|)
expr_stmt|;
name|LIST_AddToTail
argument_list|(
operator|&
operator|(
name|p_HashEntry
operator|->
name|node
operator|)
argument_list|,
operator|&
operator|(
name|p_Memac
operator|->
name|p_MulticastAddrHash
operator|->
name|p_Lsts
index|[
name|hash
index|]
operator|)
argument_list|)
expr_stmt|;
name|fman_memac_set_hash_table
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|hash
operator||
name|HASH_CTRL_MCAST_EN
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacDelHashMacAddress
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|t_EnetAddr
modifier|*
name|p_EthAddr
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|t_EthHashEntry
modifier|*
name|p_HashEntry
init|=
name|NULL
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|uint64_t
name|ethAddr
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|ethAddr
operator|=
name|ENET_ADDR_TO_UINT64
argument_list|(
operator|*
name|p_EthAddr
argument_list|)
expr_stmt|;
name|hash
operator|=
name|GetMacAddrHashCode
argument_list|(
name|ethAddr
argument_list|)
operator|&
name|HASH_CTRL_ADDR_MASK
expr_stmt|;
name|LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&(p_Memac->p_MulticastAddrHash->p_Lsts[hash])
argument_list|)
block|{
name|p_HashEntry
operator|=
name|ETH_HASH_ENTRY_OBJ
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_HashEntry
operator|->
name|addr
operator|==
name|ethAddr
condition|)
block|{
name|LIST_DelAndInit
argument_list|(
operator|&
name|p_HashEntry
operator|->
name|node
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_HashEntry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|LIST_IsEmpty
argument_list|(
operator|&
name|p_Memac
operator|->
name|p_MulticastAddrHash
operator|->
name|p_Lsts
index|[
name|hash
index|]
argument_list|)
condition|)
name|fman_memac_set_hash_table
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|hash
operator|&
operator|~
name|HASH_CTRL_MCAST_EN
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacSetException
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|,
name|e_FmMacExceptions
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint32_t
name|bitMask
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|GET_EXCEPTION_FLAG
argument_list|(
name|bitMask
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|p_Memac
operator|->
name|exceptions
operator||=
name|bitMask
expr_stmt|;
else|else
name|p_Memac
operator|->
name|exceptions
operator|&=
operator|~
name|bitMask
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Undefined exception"
operator|)
argument_list|)
expr_stmt|;
name|fman_memac_set_exception
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|bitMask
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|uint16_t
name|MemacGetMaxFrameLength
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fman_memac_get_max_frame_len
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|MemacInitInternalPhy
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|phyAddr
decl_stmt|;
if|if
condition|(
name|ENET_INTERFACE_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
operator|==
name|e_ENET_IF_SGMII
condition|)
block|{
comment|/* Configure internal SGMII PHY */
if|if
condition|(
name|p_Memac
operator|->
name|enetMode
operator|&
name|ENET_IF_SGMII_BASEX
condition|)
name|SetupSgmiiInternalPhyBaseX
argument_list|(
name|p_Memac
argument_list|,
name|PHY_MDIO_ADDR
argument_list|)
expr_stmt|;
else|else
name|SetupSgmiiInternalPhy
argument_list|(
name|p_Memac
argument_list|,
name|PHY_MDIO_ADDR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ENET_INTERFACE_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
operator|==
name|e_ENET_IF_QSGMII
condition|)
block|{
comment|/* Configure 4 internal SGMII PHYs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* QSGMII PHY address occupies 3 upper bits of 5-bit                phyAddress; the lower 2 bits are used to extend                register address space and access each one of 4                ports inside QSGMII. */
name|phyAddr
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|PHY_MDIO_ADDR
operator|<<
literal|2
operator|)
operator||
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Memac
operator|->
name|enetMode
operator|&
name|ENET_IF_SGMII_BASEX
condition|)
name|SetupSgmiiInternalPhyBaseX
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|)
expr_stmt|;
else|else
name|SetupSgmiiInternalPhy
argument_list|(
name|p_Memac
argument_list|,
name|phyAddr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*                      mEMAC Init& Free API                                   */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_decl_stmt
name|void
modifier|*
name|g_MemacRegs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|t_Error
name|MemacInit
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|struct
name|memac_cfg
modifier|*
name|p_MemacDriverParam
decl_stmt|;
name|enum
name|enet_interface
name|enet_interface
decl_stmt|;
name|enum
name|enet_speed
name|enet_speed
decl_stmt|;
name|t_EnetAddr
name|ethAddr
decl_stmt|;
name|e_FmMacType
name|portType
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|bool
name|slow_10g_if
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|p_Memac
operator|->
name|macId
operator|==
literal|3
condition|)
comment|/* This is a quick WA */
name|g_MemacRegs
operator|=
name|p_Memac
operator|->
name|p_MemMap
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|FM_GetRevision
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
operator|&
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|fmRevInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|6
operator|&&
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|fmRevInfo
operator|.
name|minorRev
operator|==
literal|4
condition|)
name|slow_10g_if
operator|=
name|TRUE
expr_stmt|;
name|CHECK_INIT_PARAMETERS
argument_list|(
name|p_Memac
argument_list|,
name|CheckInitParameters
argument_list|)
expr_stmt|;
name|p_MemacDriverParam
operator|=
name|p_Memac
operator|->
name|p_MemacDriverParam
expr_stmt|;
name|portType
operator|=
operator|(
operator|(
name|ENET_SPEED_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
operator|<
name|e_ENET_SPEED_10000
operator|)
condition|?
name|e_FM_MAC_1G
else|:
name|e_FM_MAC_10G
operator|)
expr_stmt|;
comment|/* First, reset the MAC if desired. */
if|if
condition|(
name|p_MemacDriverParam
operator|->
name|reset_on_init
condition|)
name|fman_memac_reset
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|)
expr_stmt|;
comment|/* MAC Address */
name|MAKE_ENET_ADDR_FROM_UINT64
argument_list|(
name|p_Memac
operator|->
name|addr
argument_list|,
name|ethAddr
argument_list|)
expr_stmt|;
name|fman_memac_add_addr_in_paddr
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ethAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enet_interface
operator|=
operator|(
expr|enum
name|enet_interface
operator|)
name|ENET_INTERFACE_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
expr_stmt|;
name|enet_speed
operator|=
operator|(
expr|enum
name|enet_speed
operator|)
name|ENET_SPEED_FROM_MODE
argument_list|(
name|p_Memac
operator|->
name|enetMode
argument_list|)
expr_stmt|;
name|fman_memac_init
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
argument_list|,
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|,
name|enet_interface
argument_list|,
name|enet_speed
argument_list|,
name|slow_10g_if
argument_list|,
name|p_Memac
operator|->
name|exceptions
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
block|{
name|uint32_t
name|tmpReg
init|=
literal|0
decl_stmt|;
name|FM_GetRevision
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
operator|&
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|fmRevInfo
argument_list|)
expr_stmt|;
comment|/* check the FMAN version - the bug exists only in rev1 */
if|if
condition|(
operator|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|fmRevInfo
operator|.
name|majorRev
operator|==
literal|6
operator|)
operator|&&
operator|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|fmRevInfo
operator|.
name|minorRev
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* MAC strips CRC from received frames - this workaround should         	   decrease the likelihood of bug appearance             */
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
operator|->
name|command_config
argument_list|)
expr_stmt|;
name|tmpReg
operator|&=
operator|~
name|CMD_CFG_CRC_FWD
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Memac
operator|->
name|p_MemMap
operator|->
name|command_config
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* DBG(WARNING, ("mEMAC strips CRC from received frames as part of A006320 errata workaround"));*/
block|}
block|}
endif|#
directive|endif
comment|/* FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320 */
name|MemacInitInternalPhy
argument_list|(
name|h_Memac
argument_list|)
expr_stmt|;
comment|/* Max Frame Length */
name|err
operator|=
name|FmSetMacMaxFrame
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
name|portType
argument_list|,
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|macId
argument_list|,
name|p_MemacDriverParam
operator|->
name|max_frame_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"settings Mac max frame length is FAILED"
operator|)
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MulticastAddrHash
operator|=
name|AllocHashTable
argument_list|(
name|HASH_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memac
operator|->
name|p_MulticastAddrHash
condition|)
block|{
name|FreeInitResources
argument_list|(
name|p_Memac
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"allocation hash table is FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Memac
operator|->
name|p_UnicastAddrHash
operator|=
name|AllocHashTable
argument_list|(
name|HASH_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memac
operator|->
name|p_UnicastAddrHash
condition|)
block|{
name|FreeInitResources
argument_list|(
name|p_Memac
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"allocation hash table is FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FmRegisterIntr
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
operator|(
name|portType
operator|==
name|e_FM_MAC_10G
operator|)
condition|?
name|e_FM_MOD_10G_MAC
else|:
name|e_FM_MOD_1G_MAC
argument_list|,
name|p_Memac
operator|->
name|macId
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|,
name|MemacErrException
argument_list|,
name|p_Memac
argument_list|)
expr_stmt|;
name|FmRegisterIntr
argument_list|(
name|p_Memac
operator|->
name|fmMacControllerDriver
operator|.
name|h_Fm
argument_list|,
operator|(
name|portType
operator|==
name|e_FM_MAC_10G
operator|)
condition|?
name|e_FM_MOD_10G_MAC
else|:
name|e_FM_MOD_1G_MAC
argument_list|,
name|p_Memac
operator|->
name|macId
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|,
name|MemacException
argument_list|,
name|p_Memac
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_MemacDriverParam
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|=
name|NULL
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|t_Error
name|MemacFree
parameter_list|(
name|t_Handle
name|h_Memac
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
init|=
operator|(
name|t_Memac
operator|*
operator|)
name|h_Memac
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Memac
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Memac
operator|->
name|p_MemacDriverParam
condition|)
block|{
comment|/* Called after config */
name|XX_Free
argument_list|(
name|p_Memac
operator|->
name|p_MemacDriverParam
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* Called after init */
name|FreeInitResources
argument_list|(
name|p_Memac
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Memac
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
specifier|static
name|void
name|InitFmMacControllerDriver
parameter_list|(
name|t_FmMacControllerDriver
modifier|*
name|p_FmMacControllerDriver
parameter_list|)
block|{
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Init
operator|=
name|MemacInit
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Free
operator|=
name|MemacFree
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetStatistics
operator|=
name|NULL
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigLoopback
operator|=
name|MemacConfigLoopback
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigMaxFrameLength
operator|=
name|MemacConfigMaxFrameLength
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigWan
operator|=
name|MemacConfigWan
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigPadAndCrc
operator|=
name|MemacConfigPad
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigHalfDuplex
operator|=
name|NULL
expr_stmt|;
comment|/* half-duplex is detected automatically */
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigLengthCheck
operator|=
name|MemacConfigLengthCheck
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigException
operator|=
name|MemacConfigException
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ConfigResetOnInit
operator|=
name|MemacConfigResetOnInit
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetException
operator|=
name|MemacSetException
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Enable1588TimeStamp
operator|=
name|MemacEnable1588TimeStamp
expr_stmt|;
comment|/* always enabled */
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Disable1588TimeStamp
operator|=
name|NULL
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetPromiscuous
operator|=
name|MemacSetPromiscuous
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_AdjustLink
operator|=
name|MemacAdjustLink
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_RestartAutoneg
operator|=
name|NULL
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Enable
operator|=
name|MemacEnable
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Disable
operator|=
name|MemacDisable
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_Resume
operator|=
name|MemacInitInternalPhy
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetTxAutoPauseFrames
operator|=
name|MemacSetTxAutoPauseFrames
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetTxPauseFrames
operator|=
name|MemacSetTxPauseFrames
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetRxIgnorePauseFrames
operator|=
name|MemacSetRxIgnorePauseFrames
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_SetWakeOnLan
operator|=
name|MemacSetWakeOnLan
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ResetCounters
operator|=
name|MemacResetCounters
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_GetStatistics
operator|=
name|MemacGetStatistics
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_ModifyMacAddr
operator|=
name|MemacModifyMacAddress
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_AddHashMacAddr
operator|=
name|MemacAddHashMacAddress
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_RemoveHashMacAddr
operator|=
name|MemacDelHashMacAddress
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_AddExactMatchMacAddr
operator|=
name|MemacAddExactMatchMacAddress
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_RemovelExactMatchMacAddr
operator|=
name|MemacDelExactMatchMacAddress
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_GetId
operator|=
name|MemacGetId
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_GetVersion
operator|=
name|NULL
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_GetMaxFrameLength
operator|=
name|MemacGetMaxFrameLength
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_MII_WritePhyReg
operator|=
name|MEMAC_MII_WritePhyReg
expr_stmt|;
name|p_FmMacControllerDriver
operator|->
name|f_FM_MAC_MII_ReadPhyReg
operator|=
name|MEMAC_MII_ReadPhyReg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*                      mEMAC Config Main Entry                             */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* ......................................................................... */
end_comment

begin_function
name|t_Handle
name|MEMAC_Config
parameter_list|(
name|t_FmMacParams
modifier|*
name|p_FmMacParam
parameter_list|)
block|{
name|t_Memac
modifier|*
name|p_Memac
decl_stmt|;
name|struct
name|memac_cfg
modifier|*
name|p_MemacDriverParam
decl_stmt|;
name|uintptr_t
name|baseAddr
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmMacParam
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|baseAddr
operator|=
name|p_FmMacParam
operator|->
name|baseAddr
expr_stmt|;
comment|/* Allocate memory for the mEMAC data structure */
name|p_Memac
operator|=
operator|(
name|t_Memac
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_Memac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Memac
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"mEMAC driver structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Memac
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_Memac
argument_list|)
argument_list|)
expr_stmt|;
name|InitFmMacControllerDriver
argument_list|(
operator|&
name|p_Memac
operator|->
name|fmMacControllerDriver
argument_list|)
expr_stmt|;
comment|/* Allocate memory for the mEMAC driver parameters data structure */
name|p_MemacDriverParam
operator|=
operator|(
expr|struct
name|memac_cfg
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|memac_cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_MemacDriverParam
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"mEMAC driver parameters"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Memac
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_MemacDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memac_cfg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Plant parameter structure pointer */
name|p_Memac
operator|->
name|p_MemacDriverParam
operator|=
name|p_MemacDriverParam
expr_stmt|;
name|fman_memac_defconfig
argument_list|(
name|p_MemacDriverParam
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|addr
operator|=
name|ENET_ADDR_TO_UINT64
argument_list|(
name|p_FmMacParam
operator|->
name|addr
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MemMap
operator|=
operator|(
expr|struct
name|memac_regs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|baseAddr
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|p_MiiMemMap
operator|=
operator|(
expr|struct
name|memac_mii_access_mem_map
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|baseAddr
operator|+
name|MEMAC_TO_MII_OFFSET
argument_list|)
expr_stmt|;
name|p_Memac
operator|->
name|enetMode
operator|=
name|p_FmMacParam
operator|->
name|enetMode
expr_stmt|;
name|p_Memac
operator|->
name|macId
operator|=
name|p_FmMacParam
operator|->
name|macId
expr_stmt|;
name|p_Memac
operator|->
name|exceptions
operator|=
name|MEMAC_default_exceptions
expr_stmt|;
name|p_Memac
operator|->
name|f_Exception
operator|=
name|p_FmMacParam
operator|->
name|f_Exception
expr_stmt|;
name|p_Memac
operator|->
name|f_Event
operator|=
name|p_FmMacParam
operator|->
name|f_Event
expr_stmt|;
name|p_Memac
operator|->
name|h_App
operator|=
name|p_FmMacParam
operator|->
name|h_App
expr_stmt|;
return|return
name|p_Memac
return|;
block|}
end_function

end_unit

