begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_pcd.c   @Description   FM PCD ... */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"sprint_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"net_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_muram_ext.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CheckFmPcdParameters
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Fm
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"h_Fm has to be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Something WRONG"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Something WRONG"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|f_Exception
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"f_FmPcdExceptions has to be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p_FmPcd
operator|->
name|f_FmPcdIndexedException
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|||
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"f_FmPcdIndexedException has to be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|->
name|prsMaxParseCycleLimit
operator|>
name|PRS_MAX_CYCLE_LIMIT
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"prsMaxParseCycleLimit has to be less than 8191"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|bool
name|blockingFlag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|IpcMsgCompletionCB
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
modifier|*
name|p_Msg
parameter_list|,
name|uint8_t
modifier|*
name|p_Reply
parameter_list|,
name|uint32_t
name|replyLength
parameter_list|,
name|t_Error
name|status
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Msg
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Reply
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|replyLength
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|blockingFlag
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IpcMsgHandlerCB
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
modifier|*
name|p_Msg
parameter_list|,
name|uint32_t
name|msgLength
parameter_list|,
name|uint8_t
modifier|*
name|p_Reply
parameter_list|,
name|uint32_t
modifier|*
name|p_ReplyLength
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcMsg
modifier|*
name|p_IpcMsg
init|=
operator|(
name|t_FmPcdIpcMsg
operator|*
operator|)
name|p_Msg
decl_stmt|;
name|t_FmPcdIpcReply
modifier|*
name|p_IpcReply
init|=
operator|(
name|t_FmPcdIpcReply
operator|*
operator|)
name|p_Reply
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|msgLength
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DISABLE_SANITY_CHECKS
name|UNUSED
argument_list|(
name|msgLength
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DISABLE_SANITY_CHECKS */
name|ASSERT_COND
argument_list|(
name|p_Msg
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_IpcReply
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|FM_PCD_MAX_REPLY_SIZE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p_IpcMsg
operator|->
name|msgId
condition|)
block|{
case|case
operator|(
name|FM_PCD_MASTER_IS_ALIVE
operator|)
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|p_IpcReply
operator|->
name|replyBody
operator|)
operator|=
literal|1
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_MASTER_IS_ENABLED
operator|)
case|:
comment|/* count partitions registrations */
if|if
condition|(
name|p_FmPcd
operator|->
name|enabled
condition|)
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|++
expr_stmt|;
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|p_IpcReply
operator|->
name|replyBody
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPcd
operator|->
name|enabled
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_GUEST_DISABLE
operator|)
case|:
if|if
condition|(
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
condition|)
block|{
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|--
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
block|}
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to disable an unregistered partition"
operator|)
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_INVALID_STATE
expr_stmt|;
block|}
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_GET_COUNTER
operator|)
case|:
block|{
name|e_FmPcdCounters
name|inCounter
decl_stmt|;
name|uint32_t
name|outCounter
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|inCounter
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|outCounter
operator|=
name|FM_PCD_GetCounter
argument_list|(
name|h_FmPcd
argument_list|,
name|inCounter
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|outCounter
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_KG_SCHEMES
operator|)
case|:
block|{
name|t_FmPcdIpcKgSchemesParams
name|ipcSchemesParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSchemesParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgSchemesParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgAllocSchemes
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcSchemesParams
operator|.
name|numOfSchemes
argument_list|,
name|ipcSchemesParams
operator|.
name|guestId
argument_list|,
name|p_IpcReply
operator|->
name|replyBody
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|ipcSchemesParams
operator|.
name|numOfSchemes
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_KG_SCHEMES
operator|)
case|:
block|{
name|t_FmPcdIpcKgSchemesParams
name|ipcSchemesParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSchemesParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgSchemesParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgFreeSchemes
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcSchemesParams
operator|.
name|numOfSchemes
argument_list|,
name|ipcSchemesParams
operator|.
name|guestId
argument_list|,
name|ipcSchemesParams
operator|.
name|schemesIds
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_KG_CLSPLAN
operator|)
case|:
block|{
name|t_FmPcdIpcKgClsPlanParams
name|ipcKgClsPlanParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcKgClsPlanParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgClsPlanParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|KgAllocClsPlanEntries
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|numOfClsPlanEntries
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|guestId
argument_list|,
name|p_IpcReply
operator|->
name|replyBody
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_KG_CLSPLAN
operator|)
case|:
block|{
name|t_FmPcdIpcKgClsPlanParams
name|ipcKgClsPlanParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcKgClsPlanParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgClsPlanParams
argument_list|)
argument_list|)
expr_stmt|;
name|KgFreeClsPlanEntries
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|numOfClsPlanEntries
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|guestId
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|clsPlanBase
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_PROFILES
operator|)
case|:
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|uint16_t
name|base
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|PlcrAllocProfilesForPartition
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcAllocParams
operator|.
name|base
argument_list|,
name|ipcAllocParams
operator|.
name|num
argument_list|,
name|ipcAllocParams
operator|.
name|guestId
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_PROFILES
operator|)
case|:
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|PlcrFreeProfilesForPartition
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcAllocParams
operator|.
name|base
argument_list|,
name|ipcAllocParams
operator|.
name|num
argument_list|,
name|ipcAllocParams
operator|.
name|guestId
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_SET_PORT_PROFILES
operator|)
case|:
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|PlcrSetPortProfiles
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcAllocParams
operator|.
name|guestId
argument_list|,
name|ipcAllocParams
operator|.
name|num
argument_list|,
name|ipcAllocParams
operator|.
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_CLEAR_PORT_PROFILES
operator|)
case|:
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|PlcrClearPortProfiles
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcAllocParams
operator|.
name|guestId
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_GET_SW_PRS_OFFSET
operator|)
case|:
block|{
name|t_FmPcdIpcSwPrsLable
name|ipcSwPrsLable
decl_stmt|;
name|uint32_t
name|swPrsOffset
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSwPrsLable
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcSwPrsLable
argument_list|)
argument_list|)
expr_stmt|;
name|swPrsOffset
operator|=
name|FmPcdGetSwPrsOffset
argument_list|(
name|h_FmPcd
argument_list|,
operator|(
name|e_NetHeaderType
operator|)
name|ipcSwPrsLable
operator|.
name|enumHdr
argument_list|,
name|ipcSwPrsLable
operator|.
name|indexPerHdr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|swPrsOffset
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_PRS_INC_PORT_STATS
operator|)
case|:
block|{
name|t_FmPcdIpcPrsIncludePort
name|ipcPrsIncludePort
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcPrsIncludePort
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcPrsIncludePort
argument_list|)
argument_list|)
expr_stmt|;
name|PrsIncludePortInStatistics
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcPrsIncludePort
operator|.
name|hardwarePortId
argument_list|,
name|ipcPrsIncludePort
operator|.
name|include
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
operator|*
name|p_ReplyLength
operator|=
literal|0
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"command not found!!!"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|NetEnvLock
parameter_list|(
name|t_Handle
name|h_NetEnv
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_NetEnv
argument_list|)
expr_stmt|;
return|return
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdNetEnv
operator|*
operator|)
name|h_NetEnv
operator|)
operator|->
name|h_Spinlock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|NetEnvUnlock
parameter_list|(
name|t_Handle
name|h_NetEnv
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_NetEnv
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdNetEnv
operator|*
operator|)
name|h_NetEnv
operator|)
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|EnqueueLockToFreeLst
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdLock
modifier|*
name|p_Lock
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|NCSW_LIST_AddToTail
argument_list|(
operator|&
name|p_Lock
operator|->
name|node
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|freeLocksLst
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_FmPcdLock
modifier|*
name|DequeueLockFromFreeLst
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|freeLocksLst
argument_list|)
condition|)
block|{
name|p_Lock
operator|=
name|FM_PCD_LOCK_OBJ
argument_list|(
name|p_FmPcd
operator|->
name|freeLocksLst
operator|.
name|p_Next
argument_list|)
expr_stmt|;
name|NCSW_LIST_DelAndInit
argument_list|(
operator|&
name|p_Lock
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Spinlock
condition|)
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|p_Lock
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|EnqueueLockToAcquiredLst
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdLock
modifier|*
name|p_Lock
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|NCSW_LIST_AddToTail
argument_list|(
operator|&
name|p_Lock
operator|->
name|node
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|acquiredLocksLst
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FillFreeLocksLst
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|p_Lock
operator|=
operator|(
name|t_FmPcdLock
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdLock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Lock
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM-PCD lock obj!"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_Lock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdLock
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_Lock
operator|->
name|node
argument_list|)
expr_stmt|;
name|p_Lock
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_Lock
operator|->
name|h_Spinlock
condition|)
block|{
name|XX_Free
argument_list|(
name|p_Lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"FM-PCD spinlock obj!"
operator|)
argument_list|)
expr_stmt|;
block|}
name|EnqueueLockToFreeLst
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Lock
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReleaseFreeLocksLst
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
decl_stmt|;
name|p_Lock
operator|=
name|DequeueLockFromFreeLst
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_Lock
condition|)
block|{
name|XX_FreeSpinlock
argument_list|(
name|p_Lock
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Lock
argument_list|)
expr_stmt|;
name|p_Lock
operator|=
name|DequeueLockFromFreeLst
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|FmPcdSetClsPlanGrpId
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|uint8_t
name|clsPlanGrpId
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
operator|=
name|clsPlanGrpId
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|PcdGetClsPlanGrpParams
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleClsPlanGrpParams
modifier|*
name|p_GrpParams
parameter_list|)
block|{
name|uint8_t
name|netEnvId
init|=
name|p_GrpParams
operator|->
name|netEnvId
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|j
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
operator|!=
name|ILLEGAL_CLS_PLAN
condition|)
block|{
name|p_GrpParams
operator|->
name|grpExists
operator|=
name|TRUE
expr_stmt|;
name|p_GrpParams
operator|->
name|clsPlanGrpId
operator|=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
expr_stmt|;
return|return
name|E_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* if an option exists, add it to the opts list */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
block|{
comment|/* check if this option already exists, add if it doesn't */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_GrpParams
operator|->
name|numOfOptions
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p_GrpParams
operator|->
name|options
index|[
name|j
index|]
operator|==
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
break|break;
block|}
name|p_GrpParams
operator|->
name|optVectors
index|[
name|j
index|]
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|p_GrpParams
operator|->
name|numOfOptions
condition|)
block|{
name|p_GrpParams
operator|->
name|options
index|[
name|p_GrpParams
operator|->
name|numOfOptions
index|]
operator|=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
expr_stmt|;
name|p_GrpParams
operator|->
name|numOfOptions
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|p_GrpParams
operator|->
name|numOfOptions
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
operator|!=
name|ILLEGAL_CLS_PLAN
condition|)
block|{
name|p_GrpParams
operator|->
name|grpExists
operator|=
name|TRUE
expr_stmt|;
name|p_GrpParams
operator|->
name|clsPlanGrpId
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|PcdGetVectorForOpt
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|protocolOpt_t
name|opt
parameter_list|,
name|uint32_t
modifier|*
name|p_Vector
parameter_list|)
block|{
name|uint8_t
name|j
decl_stmt|,
name|k
decl_stmt|;
operator|*
name|p_Vector
operator|=
literal|0
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|j
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|j
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|j
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|j
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|==
name|opt
condition|)
operator|*
name|p_Vector
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|p_Vector
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Requested option was not defined for this Network Environment Characteristics module"
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|PcdGetUnitsVector
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_NetEnvParams
modifier|*
name|p_Params
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Params
operator|->
name|netEnvId
operator|<
name|FM_MAX_NUM_OF_PORTS
argument_list|)
expr_stmt|;
name|p_Params
operator|->
name|vector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Params
operator|->
name|numOfDistinctionUnits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|p_Params
operator|->
name|netEnvId
index|]
operator|.
name|units
index|[
name|p_Params
operator|->
name|unitIds
index|[
name|i
index|]
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_NONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Requested unit was not defined for this Network Environment Characteristics module"
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|p_Params
operator|->
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|p_Params
operator|->
name|unitIds
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|p_Params
operator|->
name|vector
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|p_Params
operator|->
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|p_Params
operator|->
name|unitIds
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|bool
name|PcdNetEnvIsUnitWithoutOpts
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|uint32_t
name|unitVector
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
comment|/* check whether a given unit may be used by non-clsPlan users. */
comment|/* first, recognize the unit by its vector */
while|while
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|==
name|unitVector
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
comment|/* check that no option exists */
if|if
condition|(
operator|(
name|protocolOpt_t
operator|)
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* assert that a unit was found to mach the vector */
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdNetEnvIsHdrExist
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|hdr
condition|)
return|return
name|TRUE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_ALIAS_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|==
name|hdr
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPcdNetEnvGetUnitId
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|,
name|bool
name|interchangeable
parameter_list|,
name|protocolOpt_t
name|opt
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|interchangeable
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|hdr
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|==
name|opt
operator|)
condition|)
return|return
name|i
return|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|==
name|hdr
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|opt
operator|==
name|opt
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|1
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_NONE
operator|)
condition|)
return|return
name|i
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_ALIAS_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|==
name|hdr
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|opt
operator|==
name|opt
operator|)
condition|)
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|aliasHdr
return|;
block|}
return|return
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdUnregisterReassmPort
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_ReasmCommonPramTbl
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcReassmTimeoutParams
name|ccReassmTimeoutParams
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint8_t
name|result
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_ReasmCommonPramTbl
argument_list|)
expr_stmt|;
name|ccReassmTimeoutParams
operator|.
name|iprcpt
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|h_ReasmCommonPramTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|ccReassmTimeoutParams
operator|.
name|activate
operator|=
name|FALSE
expr_stmt|;
comment|/*Disable Timeout Task*/
if|if
condition|(
operator|(
name|err
operator|=
name|FmHcPcdCcTimeoutReassm
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
operator|&
name|ccReassmTimeoutParams
argument_list|,
operator|&
name|result
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
return|return
name|E_OK
return|;
case|case
operator|(
literal|1
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|""
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
literal|2
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|""
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
literal|3
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"Disable Timeout Task with invalid IPRCPT"
operator|)
argument_list|)
expr_stmt|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|e_NetHeaderType
name|FmPcdGetAliasHdr
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|netEnvId
operator|<
name|FM_MAX_NUM_OF_PORTS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_ALIAS_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|==
name|hdr
condition|)
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|aliasHdr
return|;
block|}
return|return
name|HEADER_TYPE_NONE
return|;
block|}
end_function

begin_function
name|void
name|FmPcdPortRegister
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint16_t
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|h_FmPort
operator|=
name|h_FmPort
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdGetLcv
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|netEnvId
parameter_list|,
name|uint8_t
name|hdrNum
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lcvs
index|[
name|hdrNum
index|]
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdGetMacsecLcv
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|netEnvId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|macsecVector
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPcdGetNetEnvId
parameter_list|(
name|t_Handle
name|h_NetEnv
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPcdNetEnv
operator|*
operator|)
name|h_NetEnv
operator|)
operator|->
name|netEnvId
return|;
block|}
end_function

begin_function
name|void
name|FmPcdIncNetEnvOwners
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|NetEnvLock
argument_list|(
operator|&
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
operator|++
expr_stmt|;
name|NetEnvUnlock
argument_list|(
operator|&
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FmPcdDecNetEnvOwners
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|NetEnvLock
argument_list|(
operator|&
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
operator|--
expr_stmt|;
name|NetEnvUnlock
argument_list|(
operator|&
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdLock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
return|return
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Spinlock
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|FmPcdUnlock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_FmPcdLock
modifier|*
name|FmPcdAcquireLock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|p_Lock
operator|=
name|DequeueLockFromFreeLst
argument_list|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Lock
condition|)
block|{
name|FillFreeLocksLst
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|p_Lock
operator|=
name|DequeueLockFromFreeLst
argument_list|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Lock
condition|)
name|EnqueueLockToAcquiredLst
argument_list|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
argument_list|,
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|p_Lock
return|;
block|}
end_function

begin_function
name|void
name|FmPcdReleaseLock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdLock
modifier|*
name|p_Lock
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|NCSW_LIST_DelAndInit
argument_list|(
operator|&
name|p_Lock
operator|->
name|node
argument_list|)
expr_stmt|;
name|FmPcdUnlock
argument_list|(
name|h_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|EnqueueLockToFreeLst
argument_list|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
argument_list|,
name|p_Lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|FmPcdLockTryLockAll
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|,
modifier|*
name|p_SavedPos
init|=
name|NULL
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&((t_FmPcd*)h_FmPcd)->acquiredLocksLst
argument_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
init|=
name|FM_PCD_LOCK_OBJ
argument_list|(
name|p_Pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLock
argument_list|(
name|p_Lock
argument_list|)
condition|)
block|{
name|p_SavedPos
operator|=
name|p_Pos
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p_SavedPos
condition|)
block|{
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&((t_FmPcd*)h_FmPcd)->acquiredLocksLst
argument_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
init|=
name|FM_PCD_LOCK_OBJ
argument_list|(
name|p_Pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_Pos
operator|==
name|p_SavedPos
condition|)
break|break;
name|FmPcdLockUnlock
argument_list|(
name|p_Lock
argument_list|)
expr_stmt|;
block|}
block|}
name|FmPcdUnlock
argument_list|(
name|h_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|CORE_MemoryBarrier
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_SavedPos
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|FmPcdLockUnlockAll
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&((t_FmPcd*)h_FmPcd)->acquiredLocksLst
argument_list|)
block|{
name|t_FmPcdLock
modifier|*
name|p_Lock
init|=
name|FM_PCD_LOCK_OBJ
argument_list|(
name|p_Pos
argument_list|)
decl_stmt|;
name|p_Lock
operator|->
name|flag
operator|=
name|FALSE
expr_stmt|;
block|}
name|FmPcdUnlock
argument_list|(
name|h_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|CORE_MemoryBarrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdHcSync
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Hc
argument_list|)
expr_stmt|;
return|return
name|FmHcPcdSync
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Hc
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Handle
name|FmPcdGetHcHandle
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Hc
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdIsAdvancedOffloadSupported
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|advancedOffloadSupport
return|;
block|}
end_function

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PCD_Config
parameter_list|(
name|t_FmPcdParams
modifier|*
name|p_FmPcdParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
name|NULL
decl_stmt|;
name|t_FmPhysAddr
name|physicalMuramBase
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcdParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcd
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|=
operator|(
name|t_FmPcdDriverParam
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdDriverParam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD Driver Param"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdDriverParam
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_Fm
operator|=
name|p_FmPcdParams
operator|->
name|h_Fm
expr_stmt|;
name|p_FmPcd
operator|->
name|guestId
operator|=
name|FmGetGuestId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_FmMuram
operator|=
name|FmGetMuramHandle
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_FmMuram
condition|)
block|{
name|FmGetPhysicalMuramBase
argument_list|(
name|p_FmPcdParams
operator|->
name|h_Fm
argument_list|,
operator|&
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|=
call|(
name|uint64_t
call|)
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
operator|&
name|physicalMuramBase
argument_list|)
operator|->
name|low
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
operator|&
name|physicalMuramBase
argument_list|)
operator|->
name|high
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PORTS
condition|;
name|i
operator|++
control|)
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
if|if
condition|(
name|p_FmPcdParams
operator|->
name|useHostCommand
condition|)
block|{
name|t_FmHcParams
name|hcParams
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hcParams
argument_list|)
argument_list|)
expr_stmt|;
name|hcParams
operator|.
name|h_Fm
operator|=
name|p_FmPcd
operator|->
name|h_Fm
expr_stmt|;
name|hcParams
operator|.
name|h_FmPcd
operator|=
operator|(
name|t_Handle
operator|)
name|p_FmPcd
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|hcParams
operator|.
name|params
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_FmPcdParams
operator|->
name|hc
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdHcParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_Hc
operator|=
name|FmHcConfigAndInit
argument_list|(
operator|&
name|hcParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD HC"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"No Host Command defined for a guest partition."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdParams
operator|->
name|kgSupport
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|=
operator|(
name|t_FmPcdKg
operator|*
operator|)
name|KgConfig
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD Keygen"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|p_FmPcdParams
operator|->
name|plcrSupport
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|=
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|PlcrConfig
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD Policer"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|p_FmPcdParams
operator|->
name|prsSupport
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|=
operator|(
name|t_FmPcdPrs
operator|*
operator|)
name|PrsConfig
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD Parser"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|p_FmPcd
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Spinlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD spinlock"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|INIT_LIST
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|freeLocksLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|acquiredLocksLst
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|f_Exception
operator|=
name|p_FmPcdParams
operator|->
name|f_Exception
expr_stmt|;
name|p_FmPcd
operator|->
name|f_FmPcdIndexedException
operator|=
name|p_FmPcdParams
operator|->
name|f_ExceptionId
expr_stmt|;
name|p_FmPcd
operator|->
name|h_App
operator|=
name|p_FmPcdParams
operator|->
name|h_App
expr_stmt|;
name|p_FmPcd
operator|->
name|p_CcShadow
operator|=
name|NULL
expr_stmt|;
name|p_FmPcd
operator|->
name|ccShadowSize
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|ccShadowAlign
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM PCD shadow spinlock"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_FmPcd
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Init
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|FM_GetRevision
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|fmRevInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
block|{
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdIpcHandlerModuleName
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdIpcHandlerModuleName
argument_list|,
literal|"FM_PCD_%d_%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|,
name|NCSW_MASTER_ID
argument_list|)
operator|!=
literal|10
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|"FM_PCD_%d_%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|)
operator|!=
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|<
literal|10
condition|?
literal|10
else|:
literal|11
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_IpcSession
operator|=
name|XX_IpcInitSession
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdIpcHandlerModuleName
argument_list|,
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|uint8_t
name|isMasterAlive
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_MASTER_IS_ALIVE
expr_stmt|;
name|msg
operator|.
name|msgBody
index|[
literal|0
index|]
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|blockingFlag
operator|=
name|TRUE
expr_stmt|;
do|do
block|{
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isMasterAlive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p_FmPcd
operator|->
name|guestId
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|IpcMsgCompletionCB
argument_list|,
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
while|while
condition|(
name|blockingFlag
condition|)
empty_stmt|;
if|if
condition|(
name|replyLength
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isMasterAlive
argument_list|)
operator|)
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|isMasterAlive
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|reply
operator|.
name|replyBody
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isMasterAlive
condition|)
do|;
block|}
block|}
name|CHECK_INIT_PARAMETERS
argument_list|(
name|p_FmPcd
argument_list|,
name|CheckFmPcdParameters
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
name|err
operator|=
name|KgInit
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|err
operator|=
name|PlcrInit
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
name|err
operator|=
name|PrsInit
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
comment|/* register to inter-core messaging mechanism */
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|"FM_PCD_%d_%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|,
name|NCSW_MASTER_ID
argument_list|)
operator|!=
literal|10
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcRegisterMsgHandler
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
name|IpcMsgHandlerCB
argument_list|,
name|p_FmPcd
argument_list|,
name|FM_PCD_MAX_REPLY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* IPv6 Frame-Id used for fragmentation */
name|p_FmPcd
operator|->
name|ipv6FrameIdAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|ipv6FrameIdAddr
condition|)
block|{
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for IPv6 Frame-Id"
operator|)
argument_list|)
expr_stmt|;
block|}
name|IOMemSet32
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPcd
operator|->
name|ipv6FrameIdAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* CAPWAP Frame-Id used for fragmentation */
name|p_FmPcd
operator|->
name|capwapFrameIdAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|capwapFrameIdAddr
condition|)
block|{
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CAPWAP Frame-Id"
operator|)
argument_list|)
expr_stmt|;
block|}
name|IOMemSet32
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPcd
operator|->
name|capwapFrameIdAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|=
name|NULL
expr_stmt|;
name|FmRegisterPcd
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Free
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|ipv6FrameIdAddr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_FmPcd
operator|->
name|ipv6FrameIdAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|capwapFrameIdAddr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_FmPcd
operator|->
name|capwapFrameIdAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|enabled
condition|)
name|FM_PCD_Disable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|KgFree
argument_list|(
name|p_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|PlcrFree
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
name|PrsFree
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|FmHcFree
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_Hc
operator|=
name|NULL
expr_stmt|;
block|}
name|XX_IpcUnregisterMsgHandler
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|)
expr_stmt|;
name|FmUnregisterPcd
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|ReleaseFreeLocksLst
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ConfigException
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdExceptions
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|bitMask
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ConfigException - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|GET_FM_PCD_EXCEPTION_FLAG
argument_list|(
name|bitMask
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|p_FmPcd
operator|->
name|exceptions
operator||=
name|bitMask
expr_stmt|;
else|else
name|p_FmPcd
operator|->
name|exceptions
operator|&=
operator|~
name|bitMask
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Undefined exception"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ConfigHcFramesDataMemory
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|memId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|FmHcSetFramesDataMemory
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|memId
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Enable
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|enabled
condition|)
return|return
name|E_OK
return|;
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|uint8_t
name|enabled
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_MASTER_IS_ENABLED
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|enabled
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|enabled
operator|=
operator|(
name|bool
operator|)
operator|!
operator|!
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|reply
operator|.
name|replyBody
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|enabled
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"FM-PCD master should be enabled first!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
elseif|else
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"running in guest-mode without IPC!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|KgEnable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|PlcrEnable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|PrsEnable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|enabled
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Disable
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|enabled
condition|)
return|return
name|E_OK
return|;
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_GUEST_DISABLE
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|.
name|error
operator|==
name|E_OK
condition|)
name|p_FmPcd
operator|->
name|enabled
operator|=
name|FALSE
expr_stmt|;
return|return
call|(
name|t_Error
call|)
argument_list|(
name|reply
operator|.
name|error
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"running in guest-mode without IPC!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to disable a master partition PCD while"
literal|"guest partitions are still enabled!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|KgDisable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|PlcrDisable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|PrsDisable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|enabled
operator|=
name|FALSE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_NetEnvCharacteristicsSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdNetEnvParams
modifier|*
name|p_NetEnvParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|,
name|specialUnits
init|=
literal|0
decl_stmt|;
name|uint8_t
name|bitId
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|uint8_t
name|netEnvCurrId
decl_stmt|;
name|uint8_t
name|ipsecAhUnit
init|=
literal|0
decl_stmt|,
name|ipsecEspUnit
init|=
literal|0
decl_stmt|;
name|bool
name|ipsecAhExists
init|=
name|FALSE
decl_stmt|,
name|ipsecEspExists
init|=
name|FALSE
decl_stmt|,
name|shim1Selected
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|hdrNum
decl_stmt|;
name|t_FmPcdNetEnvParams
modifier|*
name|p_ModifiedNetEnvParams
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_NetEnvParams
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
comment|/* find a new netEnv */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PORTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FM_MAX_NUM_OF_PORTS
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"No more than %d netEnv's allowed."
operator|,
name|FM_MAX_NUM_OF_PORTS
operator|)
argument_list|)
expr_stmt|;
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|used
operator|=
name|TRUE
expr_stmt|;
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
comment|/* As anyone doesn't have handle of this netEnv yet, no need        to protect it with spinlocks */
name|p_ModifiedNetEnvParams
operator|=
operator|(
name|t_FmPcdNetEnvParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdNetEnvParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifiedNetEnvParams
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FmPcdNetEnvParams"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|,
name|p_NetEnvParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdNetEnvParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_NetEnvParams
operator|=
name|p_ModifiedNetEnvParams
expr_stmt|;
name|netEnvCurrId
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
comment|/* clear from previous use */
name|memset
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdIntDistinctionUnit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MAX_NUM_OF_ALIAS_HDRS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdNetEnvAliases
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
argument_list|,
name|p_NetEnvParams
operator|->
name|units
argument_list|,
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdIntDistinctionUnit
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|netEnvId
operator|=
name|netEnvCurrId
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|h_FmPcd
operator|=
name|p_FmPcd
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
comment|/* check that header with opt is not interchanged with the same header */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* if an option exists, check that other headers are not the same header             without option */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|j
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|j
index|]
operator|.
name|hdr
operator|==
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|)
operator|&&
operator|!
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|j
index|]
operator|.
name|opt
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"Illegal unit - header with opt may not be interchangeable with the same header without opt"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* Specific headers checking  */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* Some headers pairs may not be defined on different units as the parser             doesn't distinguish */
comment|/* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
comment|/* check that header with opt is not interchanged with the same header */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPSEC_AH
condition|)
block|{
if|if
condition|(
name|ipsecEspExists
operator|&&
operator|(
name|ipsecEspUnit
operator|!=
name|i
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|ipsecAhUnit
operator|=
name|i
expr_stmt|;
name|ipsecAhExists
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPSEC_ESP
condition|)
block|{
if|if
condition|(
name|ipsecAhExists
operator|&&
operator|(
name|ipsecAhUnit
operator|!=
name|i
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|ipsecEspUnit
operator|=
name|i
expr_stmt|;
name|ipsecEspExists
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* ENCAP_ESP  */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_UDP_ENCAP_ESP
condition|)
block|{
comment|/* IPSec UDP encapsulation is currently set to use SHIM1 */
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP_ENCAP_ESP
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
operator|++
index|]
operator|.
name|aliasHdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
operator|||
operator|(
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|&&
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|)
comment|/* UDP_LITE  */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_UDP_LITE
condition|)
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP_LITE
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
operator|++
index|]
operator|.
name|aliasHdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) || ((DPAA_VERSION == 10)&& defined(FM_CAPWAP_SUPPORT)) */
comment|/* IP FRAG  */
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv4
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|==
name|IPV4_FRAG_1
operator|)
condition|)
block|{
comment|/* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if                  * IPv4 exists. If so we don't need to set an extra unit                  * We consider as "having IPv4" any IPv4 without interchangable headers                  * but including any options.  */
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|opt
operator|=
name|IPV4_FRAG_1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
operator|++
index|]
operator|.
name|aliasHdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
comment|/* check if IPv4 header exists by itself */
if|if
condition|(
name|FmPcdNetEnvGetUnitId
argument_list|(
name|p_FmPcd
argument_list|,
name|netEnvCurrId
argument_list|,
name|HEADER_TYPE_IPv4
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
operator|==
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
condition|)
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
operator|++
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|==
name|IPV6_FRAG_1
operator|)
condition|)
block|{
comment|/* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if                  * IPv4 exists. If so we don't need to set an extra unit                  * We consider as "having IPv6" any IPv6 without interchangable headers                  * but including any options.  */
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv6
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|opt
operator|=
name|IPV6_FRAG_1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
operator|++
index|]
operator|.
name|aliasHdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
comment|/* check if IPv6 header exists by itself */
if|if
condition|(
name|FmPcdNetEnvGetUnitId
argument_list|(
name|p_FmPcd
argument_list|,
name|netEnvCurrId
argument_list|,
name|HEADER_TYPE_IPv6
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
operator|==
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
condition|)
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv6
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
operator|++
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
comment|/* CAPWAP FRAG  */
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_CAPWAP
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|==
name|CAPWAP_FRAG_1
operator|)
condition|)
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_CAPWAP
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|opt
operator|=
name|CAPWAP_FRAG_1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
operator|++
index|]
operator|.
name|aliasHdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
block|}
comment|/* if private header (shim), check that no other headers specified */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_PRIVATE_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|1
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"SHIM header may not be interchanged with other headers"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_PRIVATE_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
switch|switch
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM1
operator|)
case|:
if|if
condition|(
name|shim1Selected
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"SHIM header cannot be selected with UDP_IPSEC_ESP"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|shim1Selected
operator|=
name|TRUE
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|=
literal|0x00000001
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM2
operator|)
case|:
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|=
literal|0x00000002
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Requested SHIM not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|0x80000000
operator|>>
name|bitId
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPECIAL_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|macsecVector
operator|=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* define a set of hardware parser LCV's according to the defined netenv */
comment|/* set an array of LCV's for each header in the netEnv */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* private headers have no LCV in the hard parser */
if|if
condition|(
operator|!
name|IS_PRIVATE_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
name|hdrNum
operator|=
name|GetPrsHdrNum
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
operator|)
operator|||
operator|(
name|hdrNum
operator|==
name|NO_HDR_NUM
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lcvs
index|[
name|hdrNum
index|]
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
name|XX_Free
argument_list|(
name|p_ModifiedNetEnvParams
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|h_Spinlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd NetEnv spinlock"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_NetEnvCharacteristicsDelete
parameter_list|(
name|t_Handle
name|h_NetEnv
parameter_list|)
block|{
name|t_FmPcdNetEnv
modifier|*
name|p_NetEnv
init|=
operator|(
name|t_FmPcdNetEnv
operator|*
operator|)
name|h_NetEnv
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
name|p_NetEnv
operator|->
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint8_t
name|netEnvId
init|=
name|p_NetEnv
operator|->
name|netEnvId
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* check that no port is bound to this netEnv */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"
operator|)
argument_list|)
expr_stmt|;
block|}
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|used
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIntDistinctionUnit
argument_list|)
operator|*
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lcvs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|FM_PCD_PRS_NUM_OF_HDRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|h_Spinlock
argument_list|)
expr_stmt|;
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|void
name|FM_PCD_HcTxConf
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_DpaaFD
modifier|*
name|p_Fd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|FmHcTxConf
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|p_Fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_SetAdvancedOffloadSupport
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmCtrlCodeRevisionInfo
name|revInfo
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|enabled
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_GetFmanCtrlCodeRevision
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
operator|&
name|revInfo
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"FM in guest-mode without IPC, can't validate firmware revision."
operator|)
argument_list|)
expr_stmt|;
name|revInfo
operator|.
name|packageRev
operator|=
name|IP_OFFLOAD_PACKAGE_NUMBER
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_OFFLOAD_PACKAGE
argument_list|(
name|revInfo
operator|.
name|packageRev
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Fman ctrl code package"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Hc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"HC must be initialized in this mode"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|advancedOffloadSupport
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PCD_GetCounter
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdCounters
name|counter
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|outCounter
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"KeyGen is not activated"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|&&
operator|!
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"running in guest-mode without neither IPC nor mapped register!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Policer is not activated"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|&&
operator|!
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"running in \"guest-mode\" without neither IPC nor mapped register!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check that counters are enabled */
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|&&
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_gcr
argument_list|)
operator|&
name|FM_PCD_PLCR_GCR_STEN
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|||
operator|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
name|p_FmPcd
operator|->
name|h_IpcSession
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Parser is not activated"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|&&
operator|!
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"running in guest-mode without neither IPC nor mapped register!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_GET_COUNTER
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|outCounter
argument_list|,
name|reply
operator|.
name|replyBody
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|outCounter
return|;
block|}
switch|switch
condition|(
name|counter
condition|)
block|{
comment|/* Parser statistics */
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_pds
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l2rrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l3rrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l4rrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_srrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l2rres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l3rres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l4rres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_srres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_spcs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_spscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_hxscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mrcs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mrscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mwcs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mwscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_fcscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_tpc
argument_list|)
return|;
comment|/* Policer statistics */
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ypcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rpcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rrpcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rypcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_tpcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_flmcnt
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_SetException
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdExceptions
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|bitMask
init|=
literal|0
decl_stmt|,
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_SetException - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|GET_FM_PCD_EXCEPTION_FLAG
argument_list|(
name|bitMask
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|p_FmPcd
operator|->
name|exceptions
operator||=
name|bitMask
expr_stmt|;
else|else
name|p_FmPcd
operator|->
name|exceptions
operator|&=
operator|~
name|bitMask
expr_stmt|;
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - keygen is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - policer is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - parser is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_EX_KG_DOUBLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_EX_KG_DOUBLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_eeer
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_EX_KG_KEYSIZE_OVERFLOW
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_EX_KG_KEYSIZE_OVERFLOW
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_eeer
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_perer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PRS_DOUBLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PRS_DOUBLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_perer
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_pever
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PRS_SINGLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PRS_SINGLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_pever
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_DOUBLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_DOUBLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* for ECC exceptions driver automatically enables ECC mechanism, if disabled.            Driver may disable them automatically, depending on driver's status */
if|if
condition|(
name|enable
operator|&&
operator|(
operator|(
name|exception
operator|==
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
operator|)
condition|)
name|FmEnableRamsEcc
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
operator|&&
operator|(
operator|(
name|exception
operator|==
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
operator|)
condition|)
name|FmDisableRamsEcc
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ForceIntr
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdExceptions
name|exception
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ForceIntr - guest mode!"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - keygen is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - policer is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt -parsrer is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid interrupt requested"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PRS_DOUBLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PRS_SINGLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_EX_KG_DOUBLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_feer
argument_list|,
name|FM_EX_KG_DOUBLE_ECC
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_EX_KG_KEYSIZE_OVERFLOW
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_feer
argument_list|,
name|FM_EX_KG_KEYSIZE_OVERFLOW
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_DOUBLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eifr
argument_list|,
name|FM_PCD_PLCR_DOUBLE_ECC
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_INIT_ENTRY_ERROR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eifr
argument_list|,
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ifr
argument_list|,
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ifr
argument_list|,
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ModifyCounter
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdCounters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ModifyCounter - guest mode!"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid counters - KeyGen is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid counters - Policer is not working"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_gcr
argument_list|)
operator|&
name|FM_PCD_PLCR_GCR_STEN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_pds
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l2rrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l3rrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l4rrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_srrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l2rres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l3rres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_l4rres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_srres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_spcs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_spscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_hxscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mrcs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mrscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mwcs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_mwscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fmpr_fcscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_tpc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
comment|/*Policer counters*/
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ypcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rpcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rrpcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rypcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_tpcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_flmcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_GetHcPort
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
return|return
name|FmHcGetPort
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|)
return|;
block|}
end_function

end_unit

