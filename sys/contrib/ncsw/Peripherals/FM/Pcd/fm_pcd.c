begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_pcd.c   @Description   FM PCD ... */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"xx_ext.h"
end_include

begin_include
include|#
directive|include
file|"sprint_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"net_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_function
specifier|static
name|t_Error
name|CheckFmPcdParameters
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Fm
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"h_Fm has to be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Something WRONG"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|&&
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Something WRONG"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|f_Exception
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"f_FmPcdExceptions has to be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p_FmPcd
operator|->
name|f_FmPcdIndexedException
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|||
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"f_FmPcdIndexedException has to be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|->
name|prsMaxParseCycleLimit
operator|>
name|PRS_MAX_CYCLE_LIMIT
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"prsMaxParseCycleLimit has to be less than 8191"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|bool
name|blockingFlag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|FmPcdIpcMsgCompletionCB
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
modifier|*
name|p_Msg
parameter_list|,
name|uint8_t
modifier|*
name|p_Reply
parameter_list|,
name|uint32_t
name|replyLength
parameter_list|,
name|t_Error
name|status
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Msg
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Reply
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|replyLength
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|blockingFlag
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPcdHandleIpcMsgCB
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
modifier|*
name|p_Msg
parameter_list|,
name|uint32_t
name|msgLength
parameter_list|,
name|uint8_t
modifier|*
name|p_Reply
parameter_list|,
name|uint32_t
modifier|*
name|p_ReplyLength
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcMsg
modifier|*
name|p_IpcMsg
init|=
operator|(
name|t_FmPcdIpcMsg
operator|*
operator|)
name|p_Msg
decl_stmt|;
name|t_FmPcdIpcReply
modifier|*
name|p_IpcReply
init|=
operator|(
name|t_FmPcdIpcReply
operator|*
operator|)
name|p_Reply
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|msgLength
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DISABLE_SANITY_CHECKS
name|UNUSED
argument_list|(
name|msgLength
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DISABLE_SANITY_CHECKS */
name|ASSERT_COND
argument_list|(
name|p_Msg
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_IpcReply
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|FM_PCD_MAX_REPLY_SIZE
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p_IpcMsg
operator|->
name|msgId
condition|)
block|{
case|case
operator|(
name|FM_PCD_MASTER_IS_ALIVE
operator|)
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|p_IpcReply
operator|->
name|replyBody
operator|)
operator|=
literal|1
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_MASTER_IS_ENABLED
operator|)
case|:
comment|/* count partitions registrations */
if|if
condition|(
name|p_FmPcd
operator|->
name|enabled
condition|)
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|++
expr_stmt|;
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|p_IpcReply
operator|->
name|replyBody
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPcd
operator|->
name|enabled
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_GUEST_DISABLE
operator|)
case|:
if|if
condition|(
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
condition|)
block|{
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|--
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
block|}
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to disable an unregistered partition"
operator|)
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_INVALID_STATE
expr_stmt|;
block|}
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_GET_COUNTER
operator|)
case|:
block|{
name|e_FmPcdCounters
name|inCounter
decl_stmt|;
name|uint32_t
name|outCounter
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|inCounter
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|outCounter
operator|=
name|FM_PCD_GetCounter
argument_list|(
name|h_FmPcd
argument_list|,
name|inCounter
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|outCounter
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|E_OK
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_KG_SCHEMES
operator|)
case|:
block|{
name|t_FmPcdIpcKgSchemesParams
name|ipcSchemesParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSchemesParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgSchemesParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgAllocSchemes
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcSchemesParams
operator|.
name|numOfSchemes
argument_list|,
name|ipcSchemesParams
operator|.
name|guestId
argument_list|,
name|p_IpcReply
operator|->
name|replyBody
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|ipcSchemesParams
operator|.
name|numOfSchemes
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_KG_SCHEMES
operator|)
case|:
block|{
name|t_FmPcdIpcKgSchemesParams
name|ipcSchemesParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSchemesParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgSchemesParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgFreeSchemes
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcSchemesParams
operator|.
name|numOfSchemes
argument_list|,
name|ipcSchemesParams
operator|.
name|guestId
argument_list|,
name|ipcSchemesParams
operator|.
name|schemesIds
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_KG_CLSPLAN
operator|)
case|:
block|{
name|t_FmPcdIpcKgClsPlanParams
name|ipcKgClsPlanParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcKgClsPlanParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgClsPlanParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|KgAllocClsPlanEntries
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|numOfClsPlanEntries
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|guestId
argument_list|,
name|p_IpcReply
operator|->
name|replyBody
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_KG_CLSPLAN
operator|)
case|:
block|{
name|t_FmPcdIpcKgClsPlanParams
name|ipcKgClsPlanParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcKgClsPlanParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgClsPlanParams
argument_list|)
argument_list|)
expr_stmt|;
name|KgFreeClsPlanEntries
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|numOfClsPlanEntries
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|guestId
argument_list|,
name|ipcKgClsPlanParams
operator|.
name|clsPlanBase
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_PROFILES
operator|)
case|:
block|{
name|t_FmPcdIpcPlcrAllocParams
name|ipcPlcrAllocParams
decl_stmt|;
name|uint16_t
name|profilesBase
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcPlcrAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcPlcrAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|PlcrAllocProfiles
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcPlcrAllocParams
operator|.
name|hardwarePortId
argument_list|,
name|ipcPlcrAllocParams
operator|.
name|num
argument_list|,
operator|&
name|profilesBase
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|profilesBase
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_PROFILES
operator|)
case|:
block|{
name|t_FmPcdIpcPlcrAllocParams
name|ipcPlcrAllocParams
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcPlcrAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcPlcrAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|PlcrFreeProfiles
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcPlcrAllocParams
operator|.
name|hardwarePortId
argument_list|,
name|ipcPlcrAllocParams
operator|.
name|num
argument_list|,
name|ipcPlcrAllocParams
operator|.
name|plcrProfilesBase
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_ALLOC_SHARED_PROFILES
operator|)
case|:
block|{
name|uint16_t
name|numOfProfiles
decl_stmt|;
name|uint16_t
name|profilesIds
index|[
name|FM_PCD_PLCR_NUM_ENTRIES
index|]
decl_stmt|;
name|uint32_t
name|profilesMask
index|[
name|FM_PCD_PLCR_NUM_ENTRIES
operator|/
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|profilesMask
argument_list|,
literal|0
argument_list|,
name|FM_PCD_PLCR_NUM_ENTRIES
operator|/
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|numOfProfiles
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|PlcrAllocSharedProfiles
argument_list|(
name|h_FmPcd
argument_list|,
name|numOfProfiles
argument_list|,
name|profilesIds
argument_list|)
expr_stmt|;
name|p_IpcReply
operator|->
name|error
operator|=
name|err
expr_stmt|;
comment|/* translate the allocated profile id's to a 32bit * 8regs mask */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfProfiles
condition|;
name|i
operator|++
control|)
name|profilesMask
index|[
name|profilesIds
index|[
name|i
index|]
operator|/
literal|32
index|]
operator||=
operator|(
literal|0x80000000
operator|>>
operator|(
name|profilesIds
index|[
name|i
index|]
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|profilesMask
argument_list|,
sizeof|sizeof
argument_list|(
name|profilesMask
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|profilesMask
argument_list|)
expr_stmt|;
comment|/* num-of-shared-profiles */
break|break;
block|}
case|case
operator|(
name|FM_PCD_FREE_SHARED_PROFILES
operator|)
case|:
block|{
name|t_FmPcdIpcSharedPlcrAllocParams
name|ipcSharedPlcrAllocParams
decl_stmt|;
name|uint16_t
name|profilesIds
index|[
name|FM_PCD_PLCR_NUM_ENTRIES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|uint32_t
name|walking1Mask
init|=
literal|0x80000000
decl_stmt|;
name|memset
argument_list|(
name|profilesIds
argument_list|,
literal|0
argument_list|,
name|FM_PCD_PLCR_NUM_ENTRIES
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSharedPlcrAllocParams
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcSharedPlcrAllocParams
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_PLCR_NUM_ENTRIES
operator|/
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ipcSharedPlcrAllocParams
operator|.
name|sharedProfilesMask
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ipcSharedPlcrAllocParams
operator|.
name|sharedProfilesMask
index|[
name|i
index|]
operator|&
name|walking1Mask
condition|)
name|profilesIds
index|[
name|index
operator|++
index|]
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|i
operator|*
literal|32
operator|+
name|j
argument_list|)
expr_stmt|;
name|walking1Mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|walking1Mask
operator|=
literal|0x80000000
expr_stmt|;
block|}
block|}
name|PlcrFreeSharedProfiles
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcSharedPlcrAllocParams
operator|.
name|num
argument_list|,
name|profilesIds
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_GET_SW_PRS_OFFSET
operator|)
case|:
block|{
name|t_FmPcdIpcSwPrsLable
name|ipcSwPrsLable
decl_stmt|;
name|uint32_t
name|swPrsOffset
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcSwPrsLable
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcSwPrsLable
argument_list|)
argument_list|)
expr_stmt|;
name|swPrsOffset
operator|=
name|FmPcdGetSwPrsOffset
argument_list|(
name|h_FmPcd
argument_list|,
operator|(
name|e_NetHeaderType
operator|)
name|ipcSwPrsLable
operator|.
name|enumHdr
argument_list|,
name|ipcSwPrsLable
operator|.
name|indexPerHdr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_IpcReply
operator|->
name|replyBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|swPrsOffset
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_ReplyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_PRS_INC_PORT_STATS
operator|)
case|:
block|{
name|t_FmPcdIpcPrsIncludePort
name|ipcPrsIncludePort
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ipcPrsIncludePort
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcPrsIncludePort
argument_list|)
argument_list|)
expr_stmt|;
name|PrsIncludePortInStatistics
argument_list|(
name|h_FmPcd
argument_list|,
name|ipcPrsIncludePort
operator|.
name|hardwarePortId
argument_list|,
name|ipcPrsIncludePort
operator|.
name|include
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ERRORS
argument_list|)
operator|&&
operator|(
name|DEBUG_ERRORS
operator|>
literal|0
operator|)
operator|)
case|case
operator|(
name|FM_PCD_DUMP_REGS
operator|)
case|:
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PCD_DumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_KG_DUMP_REGS
operator|)
case|:
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PCD_KgDumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_PLCR_DUMP_REGS
operator|)
case|:
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PCD_PlcrDumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|FM_PCD_PLCR_PROFILE_DUMP_REGS
operator|)
case|:
block|{
name|t_Handle
name|h_Profile
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|h_Profile
argument_list|,
name|p_IpcMsg
operator|->
name|msgBody
argument_list|,
sizeof|sizeof
argument_list|(
name|t_Handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PCD_PlcrProfileDumpRegs
argument_list|(
name|h_FmPcd
argument_list|,
name|h_Profile
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|FM_PCD_PRS_DUMP_REGS
operator|)
case|:
if|if
condition|(
operator|(
name|err
operator|=
name|FM_PCD_PrsDumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(DEBUG_ERRORS)&& (DEBUG_ERRORS> 0)) */
default|default:
operator|*
name|p_ReplyLength
operator|=
literal|0
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"command not found!!!"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|void
name|FmPcdSetClsPlanGrpId
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|uint8_t
name|clsPlanGrpId
parameter_list|)
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
operator|=
name|clsPlanGrpId
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|PcdGetClsPlanGrpParams
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleClsPlanGrpParams
modifier|*
name|p_GrpParams
parameter_list|)
block|{
name|uint8_t
name|netEnvId
init|=
name|p_GrpParams
operator|->
name|netEnvId
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
operator|!=
name|ILLEGAL_CLS_PLAN
condition|)
block|{
name|p_GrpParams
operator|->
name|grpExists
operator|=
name|TRUE
expr_stmt|;
name|p_GrpParams
operator|->
name|clsPlanGrpId
operator|=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
expr_stmt|;
return|return
name|E_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* if an option exists, add it to the opts list */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
block|{
comment|/* check if this option already exists, add if it doesn't */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_GrpParams
operator|->
name|numOfOptions
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p_GrpParams
operator|->
name|options
index|[
name|j
index|]
operator|==
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
break|break;
block|}
name|p_GrpParams
operator|->
name|optVectors
index|[
name|j
index|]
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|p_GrpParams
operator|->
name|numOfOptions
condition|)
block|{
name|p_GrpParams
operator|->
name|options
index|[
name|p_GrpParams
operator|->
name|numOfOptions
index|]
operator|=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
expr_stmt|;
name|p_GrpParams
operator|->
name|numOfOptions
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|p_GrpParams
operator|->
name|numOfOptions
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
operator|!=
name|ILLEGAL_CLS_PLAN
condition|)
block|{
name|p_GrpParams
operator|->
name|grpExists
operator|=
name|TRUE
expr_stmt|;
name|p_GrpParams
operator|->
name|clsPlanGrpId
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|PcdGetVectorForOpt
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|protocolOpt_t
name|opt
parameter_list|,
name|uint32_t
modifier|*
name|p_Vector
parameter_list|)
block|{
name|uint8_t
name|j
decl_stmt|,
name|k
decl_stmt|;
operator|*
name|p_Vector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|j
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|j
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|j
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|j
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|==
name|opt
condition|)
operator|*
name|p_Vector
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|p_Vector
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Requested option was not defined for this Network Environment Characteristics module"
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|PcdGetUnitsVector
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_NetEnvParams
modifier|*
name|p_Params
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|p_Params
operator|->
name|vector
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Params
operator|->
name|numOfDistinctionUnits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|p_Params
operator|->
name|netEnvId
index|]
operator|.
name|units
index|[
name|p_Params
operator|->
name|unitIds
index|[
name|i
index|]
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_NONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Requested unit was not defined for this Network Environment Characteristics module"
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|p_Params
operator|->
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|p_Params
operator|->
name|unitIds
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|p_Params
operator|->
name|vector
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|p_Params
operator|->
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|p_Params
operator|->
name|unitIds
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|bool
name|PcdNetEnvIsUnitWithoutOpts
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|uint32_t
name|unitVector
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
comment|/* check whether a given unit may be used by non-clsPlan users. */
comment|/* first, recognize the unit by its vector */
while|while
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|==
name|unitVector
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
comment|/* check that no option exists */
if|if
condition|(
operator|(
name|protocolOpt_t
operator|)
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* assert that a unit was found to mach the vector */
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdNetEnvIsHdrExist
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|hdr
condition|)
return|return
name|TRUE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_PRIVATE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|==
name|hdr
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|e_NetHeaderType
name|FmPcdGetAliasHdr
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_PRIVATE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|hdr
operator|==
name|hdr
condition|)
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|aliasHdrs
index|[
name|i
index|]
operator|.
name|aliasHdr
return|;
block|}
return|return
name|HEADER_TYPE_NONE
return|;
block|}
end_function

begin_function
name|void
name|FmPcdPortRegister
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint16_t
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|h_FmPort
operator|=
name|h_FmPort
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdGetLcv
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|netEnvId
parameter_list|,
name|uint8_t
name|hdrNum
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lcvs
index|[
name|hdrNum
index|]
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdGetMacsecLcv
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|netEnvId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
return|return
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|macsecVector
return|;
block|}
end_function

begin_function
name|void
name|FmPcdIncNetEnvOwners
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|)
block|{
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FmPcdDecNetEnvOwners
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdLock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
return|return
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Spinlock
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|FmPcdUnlock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Handle
name|FmPcdGetHcHandle
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Hc
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************************************************/
end_comment

begin_comment
comment|/*              API                                                                                       */
end_comment

begin_comment
comment|/**********************************************************************************************************/
end_comment

begin_function
name|t_Handle
name|FM_PCD_Config
parameter_list|(
name|t_FmPcdParams
modifier|*
name|p_FmPcdParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
name|NULL
decl_stmt|;
name|t_FmPhysAddr
name|physicalMuramBase
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcdParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcd
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|=
operator|(
name|t_FmPcdDriverParam
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdDriverParam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd Driver Param"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdDriverParam
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_Fm
operator|=
name|p_FmPcdParams
operator|->
name|h_Fm
expr_stmt|;
name|p_FmPcd
operator|->
name|guestId
operator|=
name|FmGetGuestId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_FmMuram
operator|=
name|FmGetMuramHandle
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|FmGetPhysicalMuramBase
argument_list|(
name|p_FmPcdParams
operator|->
name|h_Fm
argument_list|,
operator|&
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|=
call|(
name|uint64_t
call|)
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
operator|&
name|physicalMuramBase
argument_list|)
operator|->
name|low
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
operator|&
name|physicalMuramBase
argument_list|)
operator|->
name|high
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PORTS
condition|;
name|i
operator|++
control|)
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
if|if
condition|(
name|p_FmPcdParams
operator|->
name|useHostCommand
condition|)
block|{
name|t_FmHcParams
name|hcParams
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hcParams
argument_list|)
argument_list|)
expr_stmt|;
name|hcParams
operator|.
name|h_Fm
operator|=
name|p_FmPcd
operator|->
name|h_Fm
expr_stmt|;
name|hcParams
operator|.
name|h_FmPcd
operator|=
operator|(
name|t_Handle
operator|)
name|p_FmPcd
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|hcParams
operator|.
name|params
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_FmPcdParams
operator|->
name|hc
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdHcParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_Hc
operator|=
name|FmHcConfigAndInit
argument_list|(
operator|&
name|hcParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd HC"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"No Host Command defined for a guest partition."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdParams
operator|->
name|kgSupport
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|=
operator|(
name|t_FmPcdKg
operator|*
operator|)
name|KgConfig
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd Keygen"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|p_FmPcdParams
operator|->
name|plcrSupport
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|=
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|PlcrConfig
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd Policer"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|p_FmPcdParams
operator|->
name|prsSupport
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|=
operator|(
name|t_FmPcdPrs
operator|*
operator|)
name|PrsConfig
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd Parser"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|p_FmPcd
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Spinlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Pcd spinlock"
operator|)
argument_list|)
expr_stmt|;
name|FM_PCD_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|f_Exception
operator|=
name|p_FmPcdParams
operator|->
name|f_Exception
expr_stmt|;
name|p_FmPcd
operator|->
name|f_FmPcdIndexedException
operator|=
name|p_FmPcdParams
operator|->
name|f_ExceptionId
expr_stmt|;
name|p_FmPcd
operator|->
name|h_App
operator|=
name|p_FmPcdParams
operator|->
name|h_App
expr_stmt|;
return|return
name|p_FmPcd
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Init
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
block|{
name|uint8_t
name|isMasterAlive
init|=
literal|0
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdIpcHandlerModuleName
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdIpcHandlerModuleName
argument_list|,
literal|"FM_PCD_%d_%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|,
name|NCSW_MASTER_ID
argument_list|)
operator|!=
literal|10
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|"FM_PCD_%d_%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|)
operator|!=
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|<
literal|10
condition|?
literal|10
else|:
literal|11
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_IpcSession
operator|=
name|XX_IpcInitSession
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdIpcHandlerModuleName
argument_list|,
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_IpcSession
operator|==
name|NULL
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"FM PCD Guest %d IPC session"
operator|,
name|p_FmPcd
operator|->
name|guestId
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_MASTER_IS_ALIVE
expr_stmt|;
name|msg
operator|.
name|msgBody
index|[
literal|0
index|]
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|blockingFlag
operator|=
name|TRUE
expr_stmt|;
do|do
block|{
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isMasterAlive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p_FmPcd
operator|->
name|guestId
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|FmPcdIpcMsgCompletionCB
argument_list|,
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
while|while
condition|(
name|blockingFlag
condition|)
empty_stmt|;
if|if
condition|(
name|replyLength
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isMasterAlive
argument_list|)
operator|)
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|isMasterAlive
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|reply
operator|.
name|replyBody
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isMasterAlive
condition|)
do|;
block|}
name|CHECK_INIT_PARAMETERS
argument_list|(
name|p_FmPcd
argument_list|,
name|CheckFmPcdParameters
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
name|err
operator|=
name|KgInit
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|err
operator|=
name|PlcrInit
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
name|err
operator|=
name|PrsInit
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
comment|/* register to inter-core messaging mechanism */
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|MODULE_NAME_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sprint
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
literal|"FM_PCD_%d_%d"
argument_list|,
name|FmGetId
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|,
name|NCSW_MASTER_ID
argument_list|)
operator|!=
literal|10
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Sprint failed"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcRegisterMsgHandler
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|,
name|FmPcdHandleIpcMsgCB
argument_list|,
name|p_FmPcd
argument_list|,
name|FM_PCD_MAX_REPLY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|=
name|NULL
expr_stmt|;
name|FmRegisterPcd
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Free
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|enabled
condition|)
name|FM_PCD_Disable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Spinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|KgFree
argument_list|(
name|p_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|PlcrFree
argument_list|(
name|p_FmPcd
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
name|PrsFree
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|FmHcFree
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|h_Hc
operator|=
name|NULL
expr_stmt|;
block|}
name|XX_IpcUnregisterMsgHandler
argument_list|(
name|p_FmPcd
operator|->
name|fmPcdModuleName
argument_list|)
expr_stmt|;
name|FmUnregisterPcd
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Enable
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|KgEnable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|PlcrEnable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|PrsEnable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|enabled
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
name|enabled
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_MASTER_IS_ENABLED
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|enabled
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|enabled
operator|=
operator|(
name|bool
operator|)
operator|!
operator|!
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|reply
operator|.
name|replyBody
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|enabled
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"FM-PCD master should be enabled first!"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_Disable
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|numOfEnabledGuestPartitionsPcds
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to disable a master partition PCD while guest partitions are still enabled."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|KgDisable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|PlcrDisable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|PrsDisable
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|enabled
operator|=
name|FALSE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_GUEST_DISABLE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
return|return
call|(
name|t_Error
call|)
argument_list|(
name|reply
operator|.
name|error
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_SetNetEnvCharacteristics
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdNetEnvParams
modifier|*
name|p_NetEnvParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|,
name|specialUnits
init|=
literal|0
decl_stmt|;
name|uint8_t
name|bitId
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|uint8_t
name|netEnvCurrId
decl_stmt|;
name|uint8_t
name|ipsecAhUnit
init|=
literal|0
decl_stmt|,
name|ipsecEspUnit
init|=
literal|0
decl_stmt|;
name|bool
name|ipsecAhExists
init|=
name|FALSE
decl_stmt|,
name|ipsecEspExists
init|=
name|FALSE
decl_stmt|,
name|shim1Selected
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|hdrNum
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
comment|/* find a new netEnv */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PORTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FM_MAX_NUM_OF_PORTS
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"No more than %d netEnv's allowed."
operator|,
name|FM_MAX_NUM_OF_PORTS
operator|)
argument_list|)
expr_stmt|;
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|used
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|NULL
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
condition|)
block|{
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|netEnvCurrId
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
comment|/* clear from previous use */
name|memset
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdIntDistinctionUnit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MAX_NUM_OF_PRIVATE_HDRS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdNetEnvAliases
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
argument_list|,
name|p_NetEnvParams
operator|->
name|units
argument_list|,
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdIntDistinctionUnit
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
comment|/* check that header with opt is not interchanged with the same header */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* if an option exists, check that other headers are not the same header             without option */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|j
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|j
index|]
operator|.
name|hdr
operator|==
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|)
operator|&&
operator|!
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|j
index|]
operator|.
name|opt
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"Illegal unit - header with opt may not be interchangeable with the same header without opt"
operator|)
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
comment|/* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
comment|/* check that header with opt is not interchanged with the same header */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
comment|/* Some headers pairs may not be defined on different units as the parser             doesn't distinguish */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPSEC_AH
condition|)
block|{
if|if
condition|(
name|ipsecEspExists
operator|&&
operator|(
name|ipsecEspUnit
operator|!=
name|i
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"
operator|)
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|ipsecAhUnit
operator|=
name|i
expr_stmt|;
name|ipsecAhExists
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPSEC_ESP
condition|)
block|{
if|if
condition|(
name|ipsecAhExists
operator|&&
operator|(
name|ipsecAhUnit
operator|!=
name|i
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"
operator|)
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|ipsecEspUnit
operator|=
name|i
expr_stmt|;
name|ipsecEspExists
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|==
name|HEADER_TYPE_UDP_ENCAP_ESP
condition|)
block|{
comment|/* TODO - general coding. choose the free shim header */
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP_ENCAP_ESP
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|aliasHdrs
index|[
name|specialUnits
operator|++
index|]
operator|.
name|aliasHdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM1
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* if private header (shim), check that no other headers specified */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_PRIVATE_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|1
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"SHIM header may not be interchanged with other headers"
operator|)
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_NetEnvParams
operator|->
name|numOfDistinctionUnits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_PRIVATE_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
switch|switch
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM1
operator|)
case|:
if|if
condition|(
name|shim1Selected
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"SHIM header cannot be selected with UDP_IPSEC_ESP"
operator|)
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|shim1Selected
operator|=
name|TRUE
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|=
literal|0x00000001
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM2
operator|)
case|:
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|=
literal|0x00000002
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Requested SHIM not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|0x80000000
operator|>>
name|bitId
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPECIAL_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|macsecVector
operator|=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* define a set of hardware parser LCV's according to the defined netenv */
comment|/* set an array of LCV's for each header in the netEnv */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* private headers have no LCV in the hard parser */
if|if
condition|(
operator|!
name|IS_PRIVATE_HEADER
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
literal|0
index|]
operator|.
name|hdr
argument_list|)
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|k
operator|<
name|FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
operator|!=
name|HEADER_TYPE_NONE
operator|)
condition|;
name|k
operator|++
control|)
block|{
name|GET_PRS_HDR_NUM
argument_list|(
name|hdrNum
argument_list|,
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|units
index|[
name|i
index|]
operator|.
name|hdrs
index|[
name|k
index|]
operator|.
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdrNum
operator|==
name|ILLEGAL_HDR_NUM
operator|)
operator|||
operator|(
name|hdrNum
operator|==
name|NO_HDR_NUM
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lcvs
index|[
name|hdrNum
index|]
operator||=
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|unitsVectors
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvCurrId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|UINT_TO_PTR
argument_list|(
operator|(
name|uint64_t
operator|)
name|netEnvCurrId
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_DeleteNetEnvCharacteristics
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_NetEnv
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|netEnvId
init|=
call|(
name|uint8_t
call|)
argument_list|(
name|PTR_TO_UINT
argument_list|(
name|h_NetEnv
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
comment|/* check that no port is bound to this netEnv */
if|if
condition|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|owners
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|used
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|units
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIntDistinctionUnit
argument_list|)
operator|*
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|unitsVectors
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lcvs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|FM_PCD_PRS_NUM_OF_HDRS
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|netEnvs
index|[
name|netEnvId
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|void
name|FM_PCD_HcTxConf
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_DpaaFD
modifier|*
name|p_Fd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|FmHcTxConf
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|p_Fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PCD_GetCounter
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdCounters
name|counter
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|,
name|outCounter
init|=
literal|0
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
block|{
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_GET_COUNTER
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|outCounter
argument_list|,
name|reply
operator|.
name|replyBody
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|outCounter
return|;
block|}
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this counters"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this counters"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check that counters are enabled */
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_gcr
argument_list|)
operator|&
name|FM_PCD_PLCR_GCR_STEN
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this counters"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|pds
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l2rrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l3rrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l4rrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|srrs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l2rres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l3rres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l4rres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|srres
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|spcs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|spscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|hxscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mrcs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mrscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mwcs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mwscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fcscs
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgtpc
argument_list|)
return|;
comment|/*Policer statictics*/
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ypcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rpcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rrpcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rypcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_tpcnt
argument_list|)
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
return|return
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_flmcnt
argument_list|)
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ERRORS
argument_list|)
operator|&&
operator|(
name|DEBUG_ERRORS
operator|>
literal|0
operator|)
operator|)
end_if

begin_function
name|t_Error
name|FM_PCD_DumpRegs
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|DECLARE_DUMP
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
block|{
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_DUMP_REGS
expr_stmt|;
return|return
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
return|return
name|FM_PCD_KgDumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
return|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
return|return
name|FM_PCD_PlcrDumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
return|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
return|return
name|FM_PCD_PrsDumpRegs
argument_list|(
name|h_FmPcd
argument_list|)
return|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HcDumpRegs
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|DECLARE_DUMP
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
return|return
name|FmHcDumpRegs
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(DEBUG_ERRORS)&& ... */
end_comment

begin_function
name|t_Error
name|FM_PCD_ConfigException
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdExceptions
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|bitMask
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ConfigException - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|GET_FM_PCD_EXCEPTION_FLAG
argument_list|(
name|bitMask
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|p_FmPcd
operator|->
name|exceptions
operator||=
name|bitMask
expr_stmt|;
else|else
name|p_FmPcd
operator|->
name|exceptions
operator|&=
operator|~
name|bitMask
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Undefined exception"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_SetException
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdExceptions
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|bitMask
init|=
literal|0
decl_stmt|,
name|tmpReg
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_SetException - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|GET_FM_PCD_EXCEPTION_FLAG
argument_list|(
name|bitMask
argument_list|,
name|exception
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
if|if
condition|(
name|enable
condition|)
name|p_FmPcd
operator|->
name|exceptions
operator||=
name|bitMask
expr_stmt|;
else|else
name|p_FmPcd
operator|->
name|exceptions
operator|&=
operator|~
name|bitMask
expr_stmt|;
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - keygen is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - policer is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - parser is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported exception"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgeeer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_KG_DOUBLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_KG_DOUBLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgeeer
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgeeer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_KG_KEYSIZE_OVERFLOW
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_KG_KEYSIZE_OVERFLOW
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgeeer
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|perer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PRS_DOUBLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PRS_DOUBLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|perer
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|pever
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PRS_SINGLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PRS_SINGLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|pever
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_DOUBLE_ECC
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_DOUBLE_ECC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
operator|)
case|:
name|tmpReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg
operator||=
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
expr_stmt|;
else|else
name|tmpReg
operator|&=
operator|~
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported exception"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* for ECC exceptions driver automatically enables ECC mechanism, if disabled.            Driver may disable them automatically, depending on driver's status */
if|if
condition|(
name|enable
operator|&&
operator|(
operator|(
name|exception
operator|==
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
operator|)
condition|)
name|FmEnableRamsEcc
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
operator|&&
operator|(
operator|(
name|exception
operator|==
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
operator||
operator|(
name|exception
operator|==
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
operator|)
condition|)
name|FmDisableRamsEcc
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Undefined exception"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ForceIntr
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdExceptions
name|exception
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ForceIntr - guest mode!"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - keygen is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt - policer is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this interrupt -parsrer is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid interrupt requested"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|exception
condition|)
block|{
case|case
name|e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PRS_DOUBLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|perfr
argument_list|,
name|FM_PCD_PRS_DOUBLE_ECC
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PRS_SINGLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|pevfr
argument_list|,
name|FM_PCD_PRS_SINGLE_ECC
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_KG_DOUBLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgfeer
argument_list|,
name|FM_PCD_KG_DOUBLE_ECC
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_KG_KEYSIZE_OVERFLOW
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgfeer
argument_list|,
name|FM_PCD_KG_KEYSIZE_OVERFLOW
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_DOUBLE_ECC
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eifr
argument_list|,
name|FM_PCD_PLCR_DOUBLE_ECC
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_INIT_ENTRY_ERROR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eifr
argument_list|,
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ifr
argument_list|,
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
case|:
if|if
condition|(
operator|!
operator|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception is masked"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ifr
argument_list|,
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"The selected exception may not be forced"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ModifyCounter
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdCounters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ModifyCounter - guest mode!"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this counters - keygen is not working"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't ask for this counters - Policer is not working"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_gcr
argument_list|)
operator|&
name|FM_PCD_PLCR_GCR_STEN
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested counter was not enabled"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|pds
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l2rrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l3rrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l4rrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|srrs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l2rres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l3rres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|l4rres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|srres
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|spcs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|spscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|hxscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mrcs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mrscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mwcs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|mwscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPrs
operator|->
name|p_FmPcdPrsRegs
operator|->
name|fcscs
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_COUNTERS_TOTAL
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|kgtpc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
comment|/*Policer counters*/
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_YELLOW
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ypcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rpcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rrpcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_rypcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_TOTAL
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_tpcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH
operator|)
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_flmcnt
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported type of counter"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

end_unit

