begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_plcr.c   @Description   FM PCD POLICER... */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<linux/math64.h>
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"net_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fm_plcr.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|PlcrProfileLock
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Profile
argument_list|)
expr_stmt|;
return|return
name|FmPcdLockSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
operator|)
operator|->
name|p_Lock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PlcrProfileUnlock
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Profile
argument_list|)
expr_stmt|;
name|FmPcdUnlockSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
operator|)
operator|->
name|p_Lock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|PlcrProfileFlagTryLock
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Profile
argument_list|)
expr_stmt|;
return|return
name|FmPcdLockTryLock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
operator|)
operator|->
name|p_Lock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PlcrProfileFlagUnlock
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Profile
argument_list|)
expr_stmt|;
name|FmPcdLockUnlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
operator|)
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|PlcrHwLock
parameter_list|(
name|t_Handle
name|h_FmPcdPlcr
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcdPlcr
argument_list|)
expr_stmt|;
return|return
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|h_FmPcdPlcr
operator|)
operator|->
name|h_HwSpinlock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PlcrHwUnlock
parameter_list|(
name|t_Handle
name|h_FmPcdPlcr
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcdPlcr
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|h_FmPcdPlcr
operator|)
operator|->
name|h_HwSpinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|PlcrSwLock
parameter_list|(
name|t_Handle
name|h_FmPcdPlcr
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcdPlcr
argument_list|)
expr_stmt|;
return|return
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|h_FmPcdPlcr
operator|)
operator|->
name|h_SwSpinlock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PlcrSwUnlock
parameter_list|(
name|t_Handle
name|h_FmPcdPlcr
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcdPlcr
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|h_FmPcdPlcr
operator|)
operator|->
name|h_SwSpinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|IsProfileShared
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|sharedProfilesIds
index|[
name|i
index|]
operator|==
name|absoluteProfileId
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetProfileNia
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|e_FmPcdEngine
name|nextEngine
parameter_list|,
name|u_FmPcdPlcrNextEngineParams
modifier|*
name|p_NextEngineParams
parameter_list|,
name|uint32_t
modifier|*
name|nextAction
parameter_list|)
block|{
name|uint32_t
name|nia
decl_stmt|;
name|uint16_t
name|absoluteProfileId
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|,
name|physicalSchemeId
decl_stmt|;
name|nia
operator|=
name|FM_PCD_PLCR_NIA_VALID
expr_stmt|;
switch|switch
condition|(
name|nextEngine
condition|)
block|{
case|case
name|e_FM_PCD_DONE
case|:
switch|switch
condition|(
name|p_NextEngineParams
operator|->
name|action
condition|)
block|{
case|case
name|e_FM_PCD_DROP_FRAME
case|:
name|nia
operator||=
name|GET_NIA_BMI_AC_DISCARD_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_ENQ_FRAME
case|:
name|nia
operator||=
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|e_FM_PCD_KG
case|:
name|physicalSchemeId
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_NextEngineParams
operator|->
name|h_DirectScheme
argument_list|)
expr_stmt|;
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|>=
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_NextEngineParams
operator|->
name|h_DirectScheme
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid direct scheme."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KgIsSchemeAlwaysDirect
argument_list|(
name|p_FmPcd
argument_list|,
name|relativeSchemeId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Policer Profile may point only to a scheme that is always direct."
operator|)
argument_list|)
expr_stmt|;
name|nia
operator||=
name|NIA_ENG_KG
operator||
name|NIA_KG_DIRECT
operator||
name|physicalSchemeId
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR
case|:
name|absoluteProfileId
operator|=
operator|(
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|p_NextEngineParams
operator|->
name|h_Profile
operator|)
operator|->
name|absoluteProfileId
expr_stmt|;
if|if
condition|(
operator|!
name|IsProfileShared
argument_list|(
name|p_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next profile must be a shared profile"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid profile "
operator|)
argument_list|)
expr_stmt|;
name|nia
operator||=
name|NIA_ENG_PLCR
operator||
name|NIA_PLCR_ABSOLUTE
operator||
name|absoluteProfileId
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
operator|*
name|nextAction
operator|=
name|nia
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|CalcFPP
parameter_list|(
name|uint32_t
name|fpp
parameter_list|)
block|{
if|if
condition|(
name|fpp
operator|>
literal|15
condition|)
return|return
literal|15
operator|-
operator|(
literal|0x1f
operator|-
name|fpp
operator|)
return|;
else|else
return|return
literal|16
operator|+
name|fpp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|GetInfoRateReg
parameter_list|(
name|e_FmPcdPlcrRateMode
name|rateMode
parameter_list|,
name|uint32_t
name|rate
parameter_list|,
name|uint64_t
name|tsuInTenthNano
parameter_list|,
name|uint32_t
name|fppShift
parameter_list|,
name|uint64_t
modifier|*
name|p_Integer
parameter_list|,
name|uint64_t
modifier|*
name|p_Fraction
parameter_list|)
block|{
name|uint64_t
name|tmp
decl_stmt|,
name|div
decl_stmt|;
if|if
condition|(
name|rateMode
operator|==
name|e_FM_PCD_PLCR_BYTE_MODE
condition|)
block|{
comment|/* now we calculate the initial integer for the bigger rate */
comment|/* from Kbps to Bytes/TSU */
name|tmp
operator|=
operator|(
name|uint64_t
operator|)
name|rate
expr_stmt|;
name|tmp
operator|*=
literal|1000
expr_stmt|;
comment|/* kb --> b */
name|tmp
operator|*=
name|tsuInTenthNano
expr_stmt|;
comment|/* bps --> bpTsu(in 10nano) */
name|div
operator|=
literal|1000000000
expr_stmt|;
comment|/* nano */
name|div
operator|*=
literal|10
expr_stmt|;
comment|/* 10 nano */
name|div
operator|*=
literal|8
expr_stmt|;
comment|/* bit to byte */
block|}
else|else
block|{
comment|/* now we calculate the initial integer for the bigger rate */
comment|/* from Kbps to Bytes/TSU */
name|tmp
operator|=
operator|(
name|uint64_t
operator|)
name|rate
expr_stmt|;
name|tmp
operator|*=
name|tsuInTenthNano
expr_stmt|;
comment|/* bps --> bpTsu(in 10nano) */
name|div
operator|=
literal|1000000000
expr_stmt|;
comment|/* nano */
name|div
operator|*=
literal|10
expr_stmt|;
comment|/* 10 nano */
block|}
operator|*
name|p_Integer
operator|=
operator|(
name|tmp
operator|<<
name|fppShift
operator|)
operator|/
name|div
expr_stmt|;
comment|/* for calculating the fraction, we will recalculate cir and deduct the integer.      * For precision, we will multiply by 2^16. we do not divid back, since we write      * this value as fraction - see spec.      */
operator|*
name|p_Fraction
operator|=
operator|(
operator|(
operator|(
name|tmp
operator|<<
name|fppShift
operator|)
operator|<<
literal|16
operator|)
operator|-
operator|(
operator|(
operator|*
name|p_Integer
operator|<<
literal|16
operator|)
operator|*
name|div
operator|)
operator|)
operator|/
name|div
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .......... */
end_comment

begin_function
specifier|static
name|void
name|CalcRates
parameter_list|(
name|uint32_t
name|bitFor1Micro
parameter_list|,
name|t_FmPcdPlcrNonPassthroughAlgParams
modifier|*
name|p_NonPassthroughAlgParam
parameter_list|,
name|uint32_t
modifier|*
name|cir
parameter_list|,
name|uint32_t
modifier|*
name|cbs
parameter_list|,
name|uint32_t
modifier|*
name|pir_eir
parameter_list|,
name|uint32_t
modifier|*
name|pbs_ebs
parameter_list|,
name|uint32_t
modifier|*
name|fpp
parameter_list|)
block|{
name|uint64_t
name|integer
decl_stmt|,
name|fraction
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|,
name|tsuInTenthNanos
decl_stmt|;
name|uint8_t
name|fppShift
init|=
literal|0
decl_stmt|;
comment|/* we want the tsu to count 10 nano for better precision normally tsu is 3.9 nano, now we will get 39 */
name|tsuInTenthNanos
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|1000
operator|*
literal|10
operator|/
operator|(
literal|1
operator|<<
name|bitFor1Micro
operator|)
argument_list|)
expr_stmt|;
comment|/* we choose the faster rate to calibrate fpp */
comment|/* The meaning of this step:      * when fppShift is 0 it means all TS bits are treated as integer and TSU is the TS LSB count.      * In this configuration we calculate the integer and fraction that represent the higher infoRate      * When this is done, we can tell where we have "spare" unused bits and optimize the division of TS      * into "integer" and "fraction" where the logic is - as many bits as possible for integer at      * high rate, as many bits as possible for fraction at low rate.      */
if|if
condition|(
name|p_NonPassthroughAlgParam
operator|->
name|committedInfoRate
operator|>
name|p_NonPassthroughAlgParam
operator|->
name|peakOrExcessInfoRate
condition|)
name|GetInfoRateReg
argument_list|(
name|p_NonPassthroughAlgParam
operator|->
name|rateMode
argument_list|,
name|p_NonPassthroughAlgParam
operator|->
name|committedInfoRate
argument_list|,
name|tsuInTenthNanos
argument_list|,
literal|0
argument_list|,
operator|&
name|integer
argument_list|,
operator|&
name|fraction
argument_list|)
expr_stmt|;
else|else
name|GetInfoRateReg
argument_list|(
name|p_NonPassthroughAlgParam
operator|->
name|rateMode
argument_list|,
name|p_NonPassthroughAlgParam
operator|->
name|peakOrExcessInfoRate
argument_list|,
name|tsuInTenthNanos
argument_list|,
literal|0
argument_list|,
operator|&
name|integer
argument_list|,
operator|&
name|fraction
argument_list|)
expr_stmt|;
comment|/* we shift integer, as in cir/pir it is represented by the MSB 16 bits, and      * the LSB bits are for the fraction */
name|temp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|integer
operator|<<
literal|16
operator|)
operator|&
literal|0x00000000FFFFFFFF
argument_list|)
expr_stmt|;
comment|/* temp is effected by the rate. For low rates it may be as low as 0, and then we'll      * take max FP = 31.      * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is      * limited by the 10G physical port.      */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
comment|/* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16          * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.          * The logic is to have as many bits for integer in the higher rates, but if we have "0"s          * in the integer part of the cir/pir register, than these bits are wasted. So we want          * to use these bits for the fraction. in this way we will have for fraction - the number          * of "0" bits and the rest - for integer.          * In other words: For each bit we shift it in PIR_EIR, we move the FP in the TS          * one bit to the left - preserving the relationship and achieving more bits          * for integer in the TS.          */
comment|/* count zeroes left of the higher used bit (in order to shift the value such that          * unused bits may be used for fraction).          */
while|while
condition|(
operator|(
name|temp
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|temp
operator|<<
literal|1
expr_stmt|;
name|fppShift
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fppShift
operator|>
literal|15
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"timeStampPeriod to Information rate ratio is too small"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|uint32_t
operator|)
name|fraction
expr_stmt|;
comment|/* fraction will alyas be smaller than 2^16 */
if|if
condition|(
operator|!
name|temp
condition|)
comment|/* integer and fraction are 0, we set FP to its max val */
name|fppShift
operator|=
literal|31
expr_stmt|;
else|else
block|{
comment|/* integer was 0 but fraction is not. FP is 16 for the fraction,              * + all left zeroes of the fraction. */
name|fppShift
operator|=
literal|16
expr_stmt|;
comment|/* count zeroes left of the higher used bit (in order to shift the value such that              * unused bits may be used for fraction).              */
while|while
condition|(
operator|(
name|temp
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|temp
operator|<<
literal|1
expr_stmt|;
name|fppShift
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/*      * This means that the FM TS register will now be used so that 'fppShift' bits are for      * fraction and the rest for integer */
comment|/* now we re-calculate cir and pir_eir with the calculated FP */
name|GetInfoRateReg
argument_list|(
name|p_NonPassthroughAlgParam
operator|->
name|rateMode
argument_list|,
name|p_NonPassthroughAlgParam
operator|->
name|committedInfoRate
argument_list|,
name|tsuInTenthNanos
argument_list|,
name|fppShift
argument_list|,
operator|&
name|integer
argument_list|,
operator|&
name|fraction
argument_list|)
expr_stmt|;
operator|*
name|cir
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|integer
operator|<<
literal|16
operator||
operator|(
name|fraction
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
name|GetInfoRateReg
argument_list|(
name|p_NonPassthroughAlgParam
operator|->
name|rateMode
argument_list|,
name|p_NonPassthroughAlgParam
operator|->
name|peakOrExcessInfoRate
argument_list|,
name|tsuInTenthNanos
argument_list|,
name|fppShift
argument_list|,
operator|&
name|integer
argument_list|,
operator|&
name|fraction
argument_list|)
expr_stmt|;
operator|*
name|pir_eir
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|integer
operator|<<
literal|16
operator||
operator|(
name|fraction
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
operator|*
name|cbs
operator|=
name|p_NonPassthroughAlgParam
operator|->
name|committedBurstSize
expr_stmt|;
operator|*
name|pbs_ebs
operator|=
name|p_NonPassthroughAlgParam
operator|->
name|peakOrExcessBurstSize
expr_stmt|;
comment|/* convert FP as it should be written to reg.      * 0-15 --> 16-31      * 16-31 --> 0-15      */
operator|*
name|fpp
operator|=
name|CalcFPP
argument_list|(
name|fppShift
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|WritePar
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint32_t
name|par
parameter_list|)
block|{
name|t_FmPcdPlcrRegs
modifier|*
name|p_FmPcdPlcrRegs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_par
argument_list|,
name|par
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_par
argument_list|)
operator|&
name|FM_PCD_PLCR_PAR_GO
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildProfileRegs
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdPlcrProfileParams
modifier|*
name|p_ProfileParams
parameter_list|,
name|t_FmPcdPlcrProfileRegs
modifier|*
name|p_PlcrRegs
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|pemode
decl_stmt|,
name|gnia
decl_stmt|,
name|ynia
decl_stmt|,
name|rnia
decl_stmt|,
name|bitFor1Micro
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|bitFor1Micro
operator|=
name|FmGetTimeStampScale
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitFor1Micro
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"Timestamp scale"
operator|)
argument_list|)
expr_stmt|;
comment|/* Set G, Y, R Nia */
name|err
operator|=
name|SetProfileNia
argument_list|(
name|p_FmPcd
argument_list|,
name|p_ProfileParams
operator|->
name|nextEngineOnGreen
argument_list|,
operator|&
operator|(
name|p_ProfileParams
operator|->
name|paramsOnGreen
operator|)
argument_list|,
operator|&
name|gnia
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|SetProfileNia
argument_list|(
name|p_FmPcd
argument_list|,
name|p_ProfileParams
operator|->
name|nextEngineOnYellow
argument_list|,
operator|&
operator|(
name|p_ProfileParams
operator|->
name|paramsOnYellow
operator|)
argument_list|,
operator|&
name|ynia
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|SetProfileNia
argument_list|(
name|p_FmPcd
argument_list|,
name|p_ProfileParams
operator|->
name|nextEngineOnRed
argument_list|,
operator|&
operator|(
name|p_ProfileParams
operator|->
name|paramsOnRed
operator|)
argument_list|,
operator|&
name|rnia
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* Mode fmpl_pemode */
name|pemode
operator|=
name|FM_PCD_PLCR_PEMODE_PI
expr_stmt|;
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|algSelection
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_PASS_THROUGH
case|:
name|p_PlcrRegs
operator|->
name|fmpl_pecir
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pecbs
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pepepir_eir
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pepbs_ebs
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pelts
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pects
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pepts_ets
operator|=
literal|0
expr_stmt|;
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_ALG_MASK
expr_stmt|;
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|colorMode
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_COLOR_BLIND
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_CBLND
expr_stmt|;
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|color
operator|.
name|dfltColor
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_GREEN
case|:
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_DEFC_MASK
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_YELLOW
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_DEFC_Y
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_RED
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_DEFC_R
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_OVERRIDE
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|e_FM_PCD_PLCR_COLOR_AWARE
case|:
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_CBLND
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|e_FM_PCD_PLCR_RFC_2698
case|:
comment|/* Select algorithm MODE[ALG] = "01" */
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_ALG_RFC2698
expr_stmt|;
if|if
condition|(
name|p_ProfileParams
operator|->
name|nonPassthroughAlgParams
operator|.
name|committedInfoRate
operator|>
name|p_ProfileParams
operator|->
name|nonPassthroughAlgParams
operator|.
name|peakOrExcessInfoRate
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"in RFC2698 Peak rate must be equal or larger than committedInfoRate."
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|cont_rfc
goto|;
case|case
name|e_FM_PCD_PLCR_RFC_4115
case|:
comment|/* Select algorithm MODE[ALG] = "10" */
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_ALG_RFC4115
expr_stmt|;
name|cont_rfc
label|:
comment|/* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|colorMode
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_COLOR_BLIND
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_CBLND
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_COLOR_AWARE
case|:
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_CBLND
expr_stmt|;
comment|/*In color aware more select override color interpretation (MODE[OVCLR]) */
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|color
operator|.
name|override
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_GREEN
case|:
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_OVCLR_MASK
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_YELLOW
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_OVCLR_Y
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_RED
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_OVCLR_R
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_OVERRIDE
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_OVCLR_G_NC
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|nonPassthroughAlgParams
operator|.
name|rateMode
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_BYTE_MODE
case|:
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_PKT
expr_stmt|;
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|nonPassthroughAlgParams
operator|.
name|byteModeParams
operator|.
name|frameLengthSelection
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_L2_FRM_LEN
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_FLS_L2
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_L3_FRM_LEN
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_FLS_L3
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_L4_FRM_LEN
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_FLS_L4
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_FULL_FRM_LEN
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_FLS_FULL
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p_ProfileParams
operator|->
name|nonPassthroughAlgParams
operator|.
name|byteModeParams
operator|.
name|rollBackFrameSelection
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN
case|:
name|pemode
operator|&=
operator|~
name|FM_PCD_PLCR_PEMODE_RBFLS
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_RBFLS
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|e_FM_PCD_PLCR_PACKET_MODE
case|:
name|pemode
operator||=
name|FM_PCD_PLCR_PEMODE_PKT
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET                mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE                mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
comment|/* Configure Traffic Parameters*/
block|{
name|uint32_t
name|cir
init|=
literal|0
decl_stmt|,
name|cbs
init|=
literal|0
decl_stmt|,
name|pir_eir
init|=
literal|0
decl_stmt|,
name|pbs_ebs
init|=
literal|0
decl_stmt|,
name|fpp
init|=
literal|0
decl_stmt|;
name|CalcRates
argument_list|(
name|bitFor1Micro
argument_list|,
operator|&
name|p_ProfileParams
operator|->
name|nonPassthroughAlgParams
argument_list|,
operator|&
name|cir
argument_list|,
operator|&
name|cbs
argument_list|,
operator|&
name|pir_eir
argument_list|,
operator|&
name|pbs_ebs
argument_list|,
operator|&
name|fpp
argument_list|)
expr_stmt|;
comment|/*  Set Committed Information Rate (CIR) */
name|p_PlcrRegs
operator|->
name|fmpl_pecir
operator|=
name|cir
expr_stmt|;
comment|/*  Set Committed Burst Size (CBS). */
name|p_PlcrRegs
operator|->
name|fmpl_pecbs
operator|=
name|cbs
expr_stmt|;
comment|/*  Set Peak Information Rate (PIR_EIR used as PIR) */
name|p_PlcrRegs
operator|->
name|fmpl_pepepir_eir
operator|=
name|pir_eir
expr_stmt|;
comment|/*   Set Peak Burst Size (PBS_EBS used as PBS) */
name|p_PlcrRegs
operator|->
name|fmpl_pepbs_ebs
operator|=
name|pbs_ebs
expr_stmt|;
comment|/* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
comment|/* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
name|p_PlcrRegs
operator|->
name|fmpl_pepts_ets
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Committed Rate Token Bucket Size (CTS) */
name|p_PlcrRegs
operator|->
name|fmpl_pects
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/* Set the FPP based on calculation */
name|pemode
operator||=
operator|(
name|fpp
operator|<<
name|FM_PCD_PLCR_PEMODE_FPP_SHIFT
operator|)
expr_stmt|;
block|}
break|break;
comment|/* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_PlcrRegs
operator|->
name|fmpl_pemode
operator|=
name|pemode
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pegnia
operator|=
name|gnia
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_peynia
operator|=
name|ynia
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_pernia
operator|=
name|rnia
expr_stmt|;
comment|/* Zero Counters */
name|p_PlcrRegs
operator|->
name|fmpl_pegpc
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_peypc
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_perpc
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_perypc
operator|=
literal|0
expr_stmt|;
name|p_PlcrRegs
operator|->
name|fmpl_perrpc
operator|=
literal|0
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AllocSharedProfiles
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|,
name|uint16_t
modifier|*
name|profilesIds
parameter_list|)
block|{
name|uint32_t
name|profilesFound
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numOfProfiles
condition|)
return|return
name|E_OK
return|;
if|if
condition|(
name|numOfProfiles
operator|>
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numProfiles is too big."
operator|)
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|PlcrSwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
comment|/* Find numOfProfiles free profiles (may be spread) */
name|profilesFound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_PLCR_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|allocated
condition|)
block|{
name|profilesFound
operator|++
expr_stmt|;
name|profilesIds
index|[
name|k
index|]
operator|=
name|i
expr_stmt|;
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|profilesFound
operator|==
name|numOfProfiles
condition|)
break|break;
block|}
if|if
condition|(
name|profilesFound
operator|!=
name|numOfProfiles
condition|)
block|{
name|PlcrSwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profilesIds
index|[
name|i
index|]
index|]
operator|.
name|profilesMng
operator|.
name|allocated
operator|=
name|TRUE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profilesIds
index|[
name|i
index|]
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
literal|0
expr_stmt|;
block|}
name|PlcrSwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeSharedProfiles
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|,
name|uint16_t
modifier|*
name|profilesIds
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|numOfProfiles
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfProfiles
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profilesIds
index|[
name|i
index|]
index|]
operator|.
name|profilesMng
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profilesIds
index|[
name|i
index|]
index|]
operator|.
name|profilesMng
operator|.
name|allocated
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profilesIds
index|[
name|i
index|]
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateRequiredActionFlag
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|,
name|bool
name|set
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
comment|/* this routine is protected by calling routine */
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|requiredActionFlag
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|requiredAction
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|requiredActionFlag
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************/
end_comment

begin_comment
comment|/*............Policer Exception..............*/
end_comment

begin_comment
comment|/*********************************************/
end_comment

begin_function
specifier|static
name|void
name|EventsCB
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|event
decl_stmt|,
name|mask
decl_stmt|,
name|force
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_evr
argument_list|)
expr_stmt|;
name|mask
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ier
argument_list|)
expr_stmt|;
name|event
operator|&=
name|mask
expr_stmt|;
comment|/* clear the forced events */
name|force
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ifr
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|&
name|event
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_ifr
argument_list|,
name|force
operator|&
operator|~
name|event
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_evr
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
condition|)
name|p_FmPcd
operator|->
name|f_Exception
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
condition|)
name|p_FmPcd
operator|->
name|f_Exception
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ..... */
end_comment

begin_function
specifier|static
name|void
name|ErrorExceptionsCB
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|event
decl_stmt|,
name|force
decl_stmt|,
name|captureReg
decl_stmt|,
name|mask
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eevr
argument_list|)
expr_stmt|;
name|mask
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eier
argument_list|)
expr_stmt|;
name|event
operator|&=
name|mask
expr_stmt|;
comment|/* clear the forced events */
name|force
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eifr
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|&
name|event
condition|)
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eifr
argument_list|,
name|force
operator|&
operator|~
name|event
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_eevr
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|FM_PCD_PLCR_DOUBLE_ECC
condition|)
name|p_FmPcd
operator|->
name|f_Exception
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
condition|)
block|{
name|captureReg
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_upcr
argument_list|)
expr_stmt|;
comment|/*ASSERT_COND(captureReg& PLCR_ERR_UNINIT_CAP);         p_UnInitCapt->profileNum = (uint8_t)(captureReg& PLCR_ERR_UNINIT_NUM_MASK);         p_UnInitCapt->portId = (uint8_t)((captureReg& PLCR_ERR_UNINIT_PID_MASK)>>PLCR_ERR_UNINIT_PID_SHIFT) ;         p_UnInitCapt->absolute = (bool)(captureReg& PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
name|p_FmPcd
operator|->
name|f_FmPcdIndexedException
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|captureReg
operator|&
name|PLCR_ERR_UNINIT_NUM_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_upcr
argument_list|,
name|PLCR_ERR_UNINIT_CAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Handle
name|PlcrConfig
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdParams
modifier|*
name|p_FmPcdParams
parameter_list|)
block|{
name|t_FmPcdPlcr
modifier|*
name|p_FmPcdPlcr
decl_stmt|;
name|uint16_t
name|i
init|=
literal|0
decl_stmt|;
name|UNUSED
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_FmPcdParams
argument_list|)
expr_stmt|;
name|p_FmPcdPlcr
operator|=
operator|(
name|t_FmPcdPlcr
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdPlcr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdPlcr
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Policer structure allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcdPlcr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdPlcr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|=
operator|(
name|t_FmPcdPlcrRegs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|FmGetPcdPlcrBaseAddr
argument_list|(
name|p_FmPcdParams
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|->
name|plcrAutoRefresh
operator|=
name|DEFAULT_plcrAutoRefresh
expr_stmt|;
name|p_FmPcd
operator|->
name|exceptions
operator||=
operator|(
name|DEFAULT_fmPcdPlcrExceptions
operator||
name|DEFAULT_fmPcdPlcrErrorExceptions
operator|)
expr_stmt|;
block|}
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
operator|=
name|DEFAULT_numOfSharedPlcrProfiles
expr_stmt|;
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
operator|=
name|p_FmPcdParams
operator|->
name|partPlcrProfilesBase
expr_stmt|;
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
operator|=
name|p_FmPcdParams
operator|->
name|partNumOfPlcrProfiles
expr_stmt|;
comment|/* for backward compatabilty. if no policer profile, will set automatically to the max */
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|(
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
operator|==
literal|0
operator|)
condition|)
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
operator|=
name|FM_PCD_PLCR_NUM_ENTRIES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_PLCR_NUM_ENTRIES
condition|;
name|i
operator|++
control|)
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
operator|(
name|uint8_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
return|return
name|p_FmPcdPlcr
return|;
block|}
end_function

begin_function
name|t_Error
name|PlcrInit
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdDriverParam
modifier|*
name|p_Param
init|=
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
decl_stmt|;
name|t_FmPcdPlcr
modifier|*
name|p_FmPcdPlcr
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
decl_stmt|;
name|t_FmPcdPlcrRegs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|uint16_t
name|base
decl_stmt|;
if|if
condition|(
operator|(
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
operator|+
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
operator|)
operator|>
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"partPlcrProfilesBase+partNumOfPlcrProfiles out of range!!!"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcdPlcr
operator|->
name|h_HwSpinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdPlcr
operator|->
name|h_HwSpinlock
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Policer HW spinlock"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcdPlcr
operator|->
name|h_SwSpinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdPlcr
operator|->
name|h_SwSpinlock
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Policer SW spinlock"
operator|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|PlcrAllocProfilesForPartition
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
argument_list|,
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
condition|)
block|{
name|err
operator|=
name|AllocSharedProfiles
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
argument_list|,
name|p_FmPcdPlcr
operator|->
name|sharedProfilesIds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
return|return
name|E_OK
return|;
comment|/**********************FMPL_GCR******************/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_PLCR_GCR_STEN
expr_stmt|;
if|if
condition|(
name|p_Param
operator|->
name|plcrAutoRefresh
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_GCR_DAR
expr_stmt|;
name|tmpReg32
operator||=
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_gcr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/**********************FMPL_GCR******************/
comment|/**********************FMPL_EEVR******************/
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_eevr
argument_list|,
operator|(
name|FM_PCD_PLCR_DOUBLE_ECC
operator||
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
operator|)
argument_list|)
expr_stmt|;
comment|/**********************FMPL_EEVR******************/
comment|/**********************FMPL_EIER******************/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_DOUBLE_ECC
condition|)
block|{
name|FmEnableRamsEcc
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_PLCR_DOUBLE_ECC
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_INIT_ENTRY_ERROR
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_INIT_ENTRY_ERROR
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_eier
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/**********************FMPL_EIER******************/
comment|/**********************FMPL_EVR******************/
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_evr
argument_list|,
operator|(
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
operator||
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
operator|)
argument_list|)
expr_stmt|;
comment|/**********************FMPL_EVR******************/
comment|/**********************FMPL_IER******************/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_ier
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/**********************FMPL_IER******************/
comment|/* register even if no interrupts enabled, to allow future enablement */
name|FmRegisterIntr
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_PLCR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|,
name|ErrorExceptionsCB
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|FmRegisterIntr
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_PLCR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|,
name|EventsCB
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
comment|/* driver initializes one DFLT profile at the last entry*/
comment|/**********************FMPL_DPMR******************/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_dpmr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
literal|0
index|]
operator|.
name|profilesMng
operator|.
name|allocated
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|PlcrFree
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|FmUnregisterIntr
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_PLCR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|)
expr_stmt|;
name|FmUnregisterIntr
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_PLCR
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
condition|)
name|FreeSharedProfiles
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|sharedProfilesIds
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
condition|)
name|PlcrFreeProfilesForPartition
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|h_SwSpinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|h_SwSpinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|h_HwSpinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|h_HwSpinlock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|void
name|PlcrEnable
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdPlcrRegs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_gcr
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_gcr
argument_list|)
operator||
name|FM_PCD_PLCR_GCR_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PlcrDisable
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdPlcrRegs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_gcr
argument_list|,
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_gcr
argument_list|)
operator|&
operator|~
name|FM_PCD_PLCR_GCR_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint16_t
name|PlcrAllocProfilesForPartition
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint16_t
name|base
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|,
name|uint8_t
name|guestId
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|uint16_t
name|profilesFound
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numOfProfiles
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|numOfProfiles
operator|>
name|FM_PCD_PLCR_NUM_ENTRIES
operator|)
operator|||
operator|(
name|base
operator|+
name|numOfProfiles
operator|>
name|FM_PCD_PLCR_NUM_ENTRIES
operator|)
condition|)
return|return
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
return|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|ipcAllocParams
operator|.
name|guestId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|ipcAllocParams
operator|.
name|num
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
expr_stmt|;
name|ipcAllocParams
operator|.
name|base
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_ALLOC_PROFILES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|ipcAllocParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|E_OK
operator|)
operator|||
operator|(
name|replyLength
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
return|;
block|}
else|else
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
argument_list|,
name|reply
operator|.
name|replyBody
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
operator|==
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
block|{
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"FM Guest mode, without IPC - can't validate Policer-profiles range!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
return|;
block|}
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
operator|(
name|base
operator|+
name|numOfProfiles
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|==
operator|(
name|uint8_t
operator|)
name|ILLEGAL_BASE
condition|)
name|profilesFound
operator|++
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|profilesFound
operator|==
name|numOfProfiles
condition|)
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
operator|(
name|base
operator|+
name|numOfProfiles
operator|)
condition|;
name|i
operator|++
control|)
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
name|guestId
expr_stmt|;
else|else
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|ILLEGAL_BASE
return|;
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function

begin_function
name|void
name|PlcrFreeProfilesForPartition
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint16_t
name|base
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|,
name|uint8_t
name|guestId
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|ipcAllocParams
operator|.
name|guestId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|ipcAllocParams
operator|.
name|num
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partNumOfPlcrProfiles
expr_stmt|;
name|ipcAllocParams
operator|.
name|base
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|partPlcrProfilesBase
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_FREE_PROFILES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|ipcAllocParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
condition|)
block|{
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"FM Guest mode, without IPC - can't validate Policer-profiles range!"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
operator|(
name|base
operator|+
name|numOfProfiles
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|==
name|guestId
condition|)
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
operator|(
name|uint8_t
operator|)
name|ILLEGAL_BASE
expr_stmt|;
else|else
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"Request for freeing storage profile window which wasn't allocated to this partition"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|PlcrSetPortProfiles
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|,
name|uint16_t
name|base
parameter_list|)
block|{
name|t_FmPcdPlcrRegs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
name|uint32_t
name|log2Num
decl_stmt|,
name|tmpReg32
decl_stmt|;
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|!
name|p_Regs
operator|&&
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|ipcAllocParams
operator|.
name|guestId
operator|=
name|hardwarePortId
expr_stmt|;
name|ipcAllocParams
operator|.
name|num
operator|=
name|numOfProfiles
expr_stmt|;
name|ipcAllocParams
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_SET_PORT_PROFILES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|ipcAllocParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p_Regs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Either IPC or 'baseAddress' is required!"
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|IN_RANGE
argument_list|(
literal|1
argument_list|,
name|hardwarePortId
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_pmr
index|[
name|hardwarePortId
operator|-
literal|1
index|]
argument_list|)
operator|&
name|FM_PCD_PLCR_PMR_V
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"The requesting port has already an allocated profiles window."
operator|)
argument_list|)
expr_stmt|;
comment|/**********************FMPL_PMRx******************/
name|LOG2
argument_list|(
operator|(
name|uint64_t
operator|)
name|numOfProfiles
argument_list|,
name|log2Num
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|base
expr_stmt|;
name|tmpReg32
operator||=
name|log2Num
operator|<<
literal|16
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PMR_V
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_pmr
index|[
name|hardwarePortId
operator|-
literal|1
index|]
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|PlcrClearPortProfiles
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|t_FmPcdPlcrRegs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|!
name|p_Regs
operator|&&
name|p_FmPcd
operator|->
name|h_IpcSession
condition|)
block|{
name|t_FmIpcResourceAllocParams
name|ipcAllocParams
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ipcAllocParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|ipcAllocParams
operator|.
name|guestId
operator|=
name|hardwarePortId
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_CLEAR_PORT_PROFILES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|ipcAllocParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|t_FmIpcResourceAllocParams
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p_Regs
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Either IPC or 'baseAddress' is required!"
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|IN_RANGE
argument_list|(
literal|1
argument_list|,
name|hardwarePortId
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmpl_pmr
index|[
name|hardwarePortId
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdPlcrAllocProfiles
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint16_t
name|numOfProfiles
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|profilesFound
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|first
decl_stmt|,
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numOfProfiles
condition|)
return|return
name|E_OK
return|;
name|ASSERT_COND
argument_list|(
name|hardwarePortId
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfProfiles
operator|>
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numProfiles is too big."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|numOfProfiles
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numProfiles must be a power of 2."
operator|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|profilesFound
operator|=
literal|0
expr_stmt|;
name|intFlags
operator|=
name|PlcrSwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_PLCR_NUM_ENTRIES
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|allocated
condition|)
block|{
name|profilesFound
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|profilesFound
operator|==
name|numOfProfiles
condition|)
break|break;
block|}
else|else
block|{
name|profilesFound
operator|=
literal|0
expr_stmt|;
comment|/* advance i to the next aligned address */
name|i
operator|=
name|first
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|first
operator|+
name|numOfProfiles
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|profilesFound
operator|==
name|numOfProfiles
condition|)
block|{
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|first
operator|+
name|numOfProfiles
condition|;
name|i
operator|++
control|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|allocated
operator|=
name|TRUE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
name|hardwarePortId
expr_stmt|;
block|}
block|}
else|else
block|{
name|PlcrSwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"No profiles."
operator|)
argument_list|)
expr_stmt|;
block|}
name|PlcrSwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|err
operator|=
name|PlcrSetPortProfiles
argument_list|(
name|p_FmPcd
argument_list|,
name|hardwarePortId
argument_list|,
name|numOfProfiles
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|numOfProfiles
operator|=
name|numOfProfiles
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|profilesBase
operator|=
name|first
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdPlcrFreeProfiles
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|IN_RANGE
argument_list|(
literal|1
argument_list|,
name|hardwarePortId
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
name|err
operator|=
name|PlcrClearPortProfiles
argument_list|(
name|p_FmPcd
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|PlcrSwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|profilesBase
init|;
name|i
operator|<
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|profilesBase
operator|+
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|numOfProfiles
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|==
name|hardwarePortId
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|allocated
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|i
index|]
operator|.
name|profilesMng
operator|.
name|ownerId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
block|}
name|PlcrSwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|numOfProfiles
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|profilesBase
operator|=
literal|0
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdPlcrCcGetSetParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|profileIndx
parameter_list|,
name|uint32_t
name|requiredAction
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdPlcr
modifier|*
name|p_FmPcdPlcr
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
decl_stmt|;
name|t_FmPcdPlcrRegs
modifier|*
name|p_FmPcdPlcrRegs
init|=
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* Calling function locked all PCD modules, so no need to lock here */
if|if
condition|(
name|profileIndx
operator|>=
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Policer profile out of range"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Policer profile is not valid"
operator|)
argument_list|)
expr_stmt|;
comment|/*intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);*/
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdPlcrCcGetSetParams
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|profileIndx
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
name|UpdateRequiredActionFlag
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FmPcdPlcrUpdateRequiredAction
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
comment|/*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
return|return
name|err
return|;
block|}
comment|/* lock the HW because once we read the registers we don't want them to be changed      * by another access. (We can copy to a tmp location and release the lock!) */
name|intFlags
operator|=
name|PlcrHwLock
argument_list|(
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|FmPcdPlcrBuildReadPlcrActionReg
argument_list|(
name|profileIndx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|requiredActionFlag
operator|||
operator|!
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|requiredAction
operator|&
name|requiredAction
operator|)
condition|)
block|{
if|if
condition|(
name|requiredAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|nextEngineOnGreen
operator|!=
name|e_FM_PCD_DONE
operator|)
operator|||
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|nextEngineOnYellow
operator|!=
name|e_FM_PCD_DONE
operator|)
operator|||
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|nextEngineOnRed
operator|!=
name|e_FM_PCD_DONE
operator|)
condition|)
block|{
name|PlcrHwUnlock
argument_list|(
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
comment|/*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_OK
argument_list|,
operator|(
literal|"In this case the next engine can be e_FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|paramsOnGreen
operator|.
name|action
operator|==
name|e_FM_PCD_ENQ_FRAME
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pegnia
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpReg32
operator|&
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
operator|)
condition|)
block|{
name|PlcrHwUnlock
argument_list|(
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
comment|/*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next engine of this policer profile has to be assigned to FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator||=
name|NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pegnia
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|FmPcdPlcrBuildWritePlcrActionReg
argument_list|(
name|profileIndx
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PAR_PWSEL_PEGNIA
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|paramsOnYellow
operator|.
name|action
operator|==
name|e_FM_PCD_ENQ_FRAME
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_peynia
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpReg32
operator|&
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
operator|)
condition|)
block|{
name|PlcrHwUnlock
argument_list|(
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
comment|/*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next engine of this policer profile has to be assigned to FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator||=
name|NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_peynia
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|FmPcdPlcrBuildWritePlcrActionReg
argument_list|(
name|profileIndx
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PAR_PWSEL_PEYNIA
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|PlcrHwUnlock
argument_list|(
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|profileIndx
index|]
operator|.
name|paramsOnRed
operator|.
name|action
operator|==
name|e_FM_PCD_ENQ_FRAME
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pernia
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpReg32
operator|&
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
operator|)
condition|)
block|{
name|PlcrHwUnlock
argument_list|(
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
comment|/*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next engine of this policer profile has to be assigned to FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator||=
name|NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pernia
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|FmPcdPlcrBuildWritePlcrActionReg
argument_list|(
name|profileIndx
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PAR_PWSEL_PERNIA
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PlcrHwUnlock
argument_list|(
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|UpdateRequiredActionFlag
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FmPcdPlcrUpdateRequiredAction
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
comment|/*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrGetRequiredActionFlag
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|requiredActionFlag
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrGetRequiredAction
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|requiredAction
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdPlcrIsProfileValid
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdPlcr
modifier|*
name|p_FmPcdPlcr
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|absoluteProfileId
operator|<
name|FM_PCD_PLCR_NUM_ENTRIES
argument_list|)
expr_stmt|;
return|return
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
return|;
block|}
end_function

begin_function
name|void
name|FmPcdPlcrValidateProfileSw
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|PlcrProfileLock
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
operator|=
name|TRUE
expr_stmt|;
name|PlcrProfileUnlock
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FmPcdPlcrInvalidateProfileSw
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|PlcrProfileLock
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
name|PlcrProfileUnlock
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint16_t
name|FmPcdPlcrProfileGetAbsoluteId
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
operator|)
operator|->
name|absoluteProfileId
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdPlcrGetAbsoluteIdByProfileParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|e_FmPcdProfileTypeSelection
name|profileType
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|uint16_t
name|relativeProfile
parameter_list|,
name|uint16_t
modifier|*
name|p_AbsoluteId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdPlcr
modifier|*
name|p_FmPcdPlcr
init|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
switch|switch
condition|(
name|profileType
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_PORT_PRIVATE
case|:
comment|/* get port PCD id from port handle */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PORTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|i
index|]
operator|.
name|h_FmPort
operator|==
name|h_FmPort
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FM_MAX_NUM_OF_PORTS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid port handle."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|i
index|]
operator|.
name|numOfProfiles
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Port has no allocated profiles"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeProfile
operator|>=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|i
index|]
operator|.
name|numOfProfiles
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Profile id is out of range"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_AbsoluteId
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|i
index|]
operator|.
name|profilesBase
operator|+
name|relativeProfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_SHARED
case|:
if|if
condition|(
name|relativeProfile
operator|>=
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Profile id is out of range"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_AbsoluteId
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_FmPcdPlcr
operator|->
name|sharedProfilesIds
index|[
name|relativeProfile
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Invalid policer profile type"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint16_t
name|FmPcdPlcrGetPortProfilesBase
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint16_t
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|profilesBase
return|;
block|}
end_function

begin_function
name|uint16_t
name|FmPcdPlcrGetPortNumOfProfiles
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint16_t
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|numOfProfiles
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrBuildWritePlcrActionReg
parameter_list|(
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_PCD_PLCR_PAR_GO
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|absoluteProfileId
operator|<<
name|FM_PCD_PLCR_PAR_PNUM_SHIFT
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrBuildWritePlcrActionRegs
parameter_list|(
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_PCD_PLCR_PAR_GO
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|absoluteProfileId
operator|<<
name|FM_PCD_PLCR_PAR_PNUM_SHIFT
operator|)
operator||
name|FM_PCD_PLCR_PAR_PWSEL_MASK
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdPlcrHwProfileIsValid
parameter_list|(
name|uint32_t
name|profileModeReg
parameter_list|)
block|{
if|if
condition|(
name|profileModeReg
operator|&
name|FM_PCD_PLCR_PEMODE_PI
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrBuildReadPlcrActionReg
parameter_list|(
name|uint16_t
name|absoluteProfileId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_PCD_PLCR_PAR_GO
operator||
name|FM_PCD_PLCR_PAR_R
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|absoluteProfileId
operator|<<
name|FM_PCD_PLCR_PAR_PNUM_SHIFT
operator|)
operator||
name|FM_PCD_PLCR_PAR_PWSEL_MASK
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrBuildCounterProfileReg
parameter_list|(
name|e_FmPcdPlcrProfileCounters
name|counter
parameter_list|)
block|{
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER
operator|)
case|:
return|return
name|FM_PCD_PLCR_PAR_PWSEL_PEGPC
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER
operator|)
case|:
return|return
name|FM_PCD_PLCR_PAR_PWSEL_PEYPC
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER
operator|)
case|:
return|return
name|FM_PCD_PLCR_PAR_PWSEL_PERPC
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER
operator|)
case|:
return|return
name|FM_PCD_PLCR_PAR_PWSEL_PERYPC
return|;
case|case
operator|(
name|e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER
operator|)
case|:
return|return
name|FM_PCD_PLCR_PAR_PWSEL_PERRPC
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|uint32_t
name|FmPcdPlcrBuildNiaProfileReg
parameter_list|(
name|bool
name|green
parameter_list|,
name|bool
name|yellow
parameter_list|,
name|bool
name|red
parameter_list|)
block|{
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|green
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PAR_PWSEL_PEGNIA
expr_stmt|;
if|if
condition|(
name|yellow
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PAR_PWSEL_PEYNIA
expr_stmt|;
if|if
condition|(
name|red
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_PAR_PWSEL_PERNIA
expr_stmt|;
return|return
name|tmpReg32
return|;
block|}
end_function

begin_function
name|void
name|FmPcdPlcrUpdateRequiredAction
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|absoluteProfileId
parameter_list|,
name|uint32_t
name|requiredAction
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
comment|/* this routine is protected by calling routine */
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
operator|.
name|requiredAction
operator||=
name|requiredAction
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/**************************************************/
end_comment

begin_comment
comment|/*............Policer API.........................*/
end_comment

begin_comment
comment|/**************************************************/
end_comment

begin_function
name|t_Error
name|FM_PCD_ConfigPlcrAutoRefreshMode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
operator|->
name|plcrAutoRefresh
operator|=
name|enable
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ConfigPlcrNumOfSharedProfiles
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|numOfSharedPlcrProfiles
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|numOfSharedProfiles
operator|=
name|numOfSharedPlcrProfiles
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_SetPlcrStatistics
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_SetPlcrStatistics - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_gcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tmpReg32
operator||=
name|FM_PCD_PLCR_GCR_STEN
expr_stmt|;
else|else
name|tmpReg32
operator|&=
operator|~
name|FM_PCD_PLCR_GCR_STEN
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|fmpl_gcr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_PlcrProfileSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdPlcrProfileParams
modifier|*
name|p_ProfileParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdPlcrRegs
modifier|*
name|p_FmPcdPlcrRegs
decl_stmt|;
name|t_FmPcdPlcrProfileRegs
name|plcrProfileReg
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint16_t
name|absoluteProfileId
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_FmPcdPlcrProfile
modifier|*
name|p_Profile
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ProfileParams
operator|->
name|modify
condition|)
block|{
name|p_Profile
operator|=
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|p_ProfileParams
operator|->
name|id
operator|.
name|h_Profile
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Profile
operator|->
name|h_FmPcd
expr_stmt|;
name|absoluteProfileId
operator|=
name|p_Profile
operator|->
name|absoluteProfileId
expr_stmt|;
if|if
condition|(
name|absoluteProfileId
operator|>=
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"profileId too Big "
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Try lock profile using flag */
if|if
condition|(
operator|!
name|PlcrProfileFlagTryLock
argument_list|(
name|p_Profile
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Profile Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
comment|/* Signal to caller BUSY condition */
name|p_ProfileParams
operator|->
name|id
operator|.
name|h_Profile
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* SMP: needs to be protected only if another core now changes the windows */
name|err
operator|=
name|FmPcdPlcrGetAbsoluteIdByProfileParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_ProfileParams
operator|->
name|id
operator|.
name|newParams
operator|.
name|profileType
argument_list|,
name|p_ProfileParams
operator|->
name|id
operator|.
name|newParams
operator|.
name|h_FmPort
argument_list|,
name|p_ProfileParams
operator|->
name|id
operator|.
name|newParams
operator|.
name|relativeProfileId
argument_list|,
operator|&
name|absoluteProfileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|absoluteProfileId
operator|>=
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"profileId too Big "
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"Policer Profile is already used"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* initialize profile struct */
name|p_Profile
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|profiles
index|[
name|absoluteProfileId
index|]
expr_stmt|;
name|p_Profile
operator|->
name|h_FmPcd
operator|=
name|p_FmPcd
expr_stmt|;
name|p_Profile
operator|->
name|absoluteProfileId
operator|=
name|absoluteProfileId
expr_stmt|;
name|p_Profile
operator|->
name|p_Lock
operator|=
name|FmPcdAcquireLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Profile
operator|->
name|p_Lock
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"FM Policer Profile lock obj!"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_Profile
operator|->
name|nextEngineOnGreen
operator|=
name|p_ProfileParams
operator|->
name|nextEngineOnGreen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_Profile
operator|->
name|paramsOnGreen
argument_list|,
operator|&
operator|(
name|p_ProfileParams
operator|->
name|paramsOnGreen
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_FmPcdPlcrNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_Profile
operator|->
name|nextEngineOnYellow
operator|=
name|p_ProfileParams
operator|->
name|nextEngineOnYellow
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_Profile
operator|->
name|paramsOnYellow
argument_list|,
operator|&
operator|(
name|p_ProfileParams
operator|->
name|paramsOnYellow
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_FmPcdPlcrNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_Profile
operator|->
name|nextEngineOnRed
operator|=
name|p_ProfileParams
operator|->
name|nextEngineOnRed
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_Profile
operator|->
name|paramsOnRed
argument_list|,
operator|&
operator|(
name|p_ProfileParams
operator|->
name|paramsOnRed
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_FmPcdPlcrNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|plcrProfileReg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdPlcrProfileRegs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build the policer profile registers */
name|err
operator|=
name|BuildProfileRegs
argument_list|(
name|h_FmPcd
argument_list|,
name|p_ProfileParams
argument_list|,
operator|&
name|plcrProfileReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ProfileParams
operator|->
name|modify
condition|)
comment|/* unlock */
name|PlcrProfileFlagUnlock
argument_list|(
name|p_Profile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ProfileParams
operator|->
name|modify
operator|&&
name|p_Profile
operator|->
name|p_Lock
condition|)
comment|/* release allocated Profile lock */
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Profile
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdPlcrSetProfile
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_Profile
argument_list|,
operator|&
name|plcrProfileReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ProfileParams
operator|->
name|modify
condition|)
name|PlcrProfileFlagUnlock
argument_list|(
name|p_Profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* release the allocated scheme lock */
if|if
condition|(
operator|!
name|p_ProfileParams
operator|->
name|modify
operator|&&
name|p_Profile
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Profile
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|p_ProfileParams
operator|->
name|modify
condition|)
name|FmPcdPlcrValidateProfileSw
argument_list|(
name|p_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
expr_stmt|;
return|return
operator|(
name|t_Handle
operator|)
name|p_Profile
return|;
block|}
name|p_FmPcdPlcrRegs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcdPlcrRegs
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|PlcrHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pemode
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pemode
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pegnia
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pegnia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_peynia
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_peynia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pernia
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pernia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pecir
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pecir
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pecbs
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pecbs
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pepepir_eir
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pepepir_eir
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pepbs_ebs
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pepbs_ebs
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pelts
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pelts
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pects
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pects
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pepts_ets
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pepts_ets
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pegpc
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_pegpc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_peypc
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_peypc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perpc
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_perpc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perypc
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_perypc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perrpc
argument_list|,
name|plcrProfileReg
operator|.
name|fmpl_perrpc
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|FmPcdPlcrBuildWritePlcrActionRegs
argument_list|(
name|absoluteProfileId
argument_list|)
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|PlcrHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ProfileParams
operator|->
name|modify
condition|)
name|FmPcdPlcrValidateProfileSw
argument_list|(
name|p_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
expr_stmt|;
else|else
name|PlcrProfileFlagUnlock
argument_list|(
name|p_Profile
argument_list|)
expr_stmt|;
return|return
operator|(
name|t_Handle
operator|)
name|p_Profile
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_PlcrProfileDelete
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|)
block|{
name|t_FmPcdPlcrProfile
modifier|*
name|p_Profile
init|=
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint16_t
name|profileIndx
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Profile
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Profile
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|profileIndx
operator|=
name|p_Profile
operator|->
name|absoluteProfileId
expr_stmt|;
name|UpdateRequiredActionFlag
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|FmPcdPlcrInvalidateProfileSw
argument_list|(
name|p_FmPcd
argument_list|,
name|profileIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdPlcrDeleteProfile
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Profile
operator|->
name|p_Lock
condition|)
comment|/* release allocated Profile lock */
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Profile
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|intFlags
operator|=
name|PlcrHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pemode
argument_list|,
operator|~
name|FM_PCD_PLCR_PEMODE_PI
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|FmPcdPlcrBuildWritePlcrActionRegs
argument_list|(
name|profileIndx
argument_list|)
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|PlcrHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Profile
operator|->
name|p_Lock
condition|)
comment|/* release allocated Profile lock */
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Profile
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
comment|/* we do not memset profile as all its fields are being re-initialized at "set",      * plus its allocation information is still valid. */
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*............Policer Profile Counter..............*/
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
name|uint32_t
name|FM_PCD_PlcrProfileGetCounter
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|,
name|e_FmPcdPlcrProfileCounters
name|counter
parameter_list|)
block|{
name|t_FmPcdPlcrProfile
modifier|*
name|p_Profile
init|=
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint16_t
name|profileIndx
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|,
name|counterVal
init|=
literal|0
decl_stmt|;
name|t_FmPcdPlcrRegs
modifier|*
name|p_FmPcdPlcrRegs
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Profile
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Profile
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
return|return
name|FmHcPcdPlcrGetProfileCounter
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Profile
argument_list|,
name|counter
argument_list|)
return|;
name|p_FmPcdPlcrRegs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcdPlcrRegs
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|profileIndx
operator|=
name|p_Profile
operator|->
name|absoluteProfileId
expr_stmt|;
if|if
condition|(
name|profileIndx
operator|>=
name|FM_PCD_PLCR_NUM_ENTRIES
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"profileId too Big "
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|intFlags
operator|=
name|PlcrHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|FmPcdPlcrBuildReadPlcrActionReg
argument_list|(
name|profileIndx
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER
case|:
name|counterVal
operator|=
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pegpc
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER
case|:
name|counterVal
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_peypc
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER
case|:
name|counterVal
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perpc
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER
case|:
name|counterVal
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perypc
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER
case|:
name|counterVal
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perrpc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
block|}
name|PlcrHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|counterVal
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_PlcrProfileSetCounter
parameter_list|(
name|t_Handle
name|h_Profile
parameter_list|,
name|e_FmPcdPlcrProfileCounters
name|counter
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPcdPlcrProfile
modifier|*
name|p_Profile
init|=
operator|(
name|t_FmPcdPlcrProfile
operator|*
operator|)
name|h_Profile
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint16_t
name|profileIndx
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_FmPcdPlcrRegs
modifier|*
name|p_FmPcdPlcrRegs
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Profile
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Profile
operator|->
name|h_FmPcd
expr_stmt|;
name|profileIndx
operator|=
name|p_Profile
operator|->
name|absoluteProfileId
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
return|return
name|FmHcPcdPlcrSetProfileCounter
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Profile
argument_list|,
name|counter
argument_list|,
name|value
argument_list|)
return|;
name|p_FmPcdPlcrRegs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|p_FmPcdPlcrRegs
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdPlcrRegs
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|PlcrHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
name|e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_pegpc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_peypc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perpc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perypc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER
case|:
name|WRITE_UINT32
argument_list|(
name|p_FmPcdPlcrRegs
operator|->
name|profileRegs
operator|.
name|fmpl_perrpc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PlcrHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/*  Activate the atomic write action by writing FMPL_PAR with: GO=1, RW=1, PSI=0, PNUM =      *  Profile Number, PWSEL=0xFFFF (select all words).      */
name|tmpReg32
operator|=
name|FmPcdPlcrBuildWritePlcrActionReg
argument_list|(
name|profileIndx
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FmPcdPlcrBuildCounterProfileReg
argument_list|(
name|counter
argument_list|)
expr_stmt|;
name|WritePar
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|PlcrHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

end_unit

