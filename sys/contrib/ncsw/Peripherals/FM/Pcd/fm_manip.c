begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_manip.c   @Description   FM PCD manip ... */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_FMAN_P1023
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_muram_ext.h"
end_include

begin_include
include|#
directive|include
file|"memcpy_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_manip.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CORE_8BIT_ACCESS_ERRATA
end_ifdef

begin_undef
undef|#
directive|undef
name|WRITE_UINT16
end_undef

begin_undef
undef|#
directive|undef
name|GET_UINT16
end_undef

begin_undef
undef|#
directive|undef
name|WRITE_UINT8
end_undef

begin_undef
undef|#
directive|undef
name|GET_UINT8
end_undef

begin_define
define|#
directive|define
name|WRITE_UINT16
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
define|\
value|do{                             \             if((int)&(addr) % 4)    \                 WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr& ~0x3L),                                           \                         ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr& ~0x3L))& 0xffff0000) | (uint32_t)val));  \             else                    \                 WRITE_UINT32(*(uint32_t*)&addr,                                                                         \                         ((GET_UINT32(*(uint32_t*)&addr)& 0x0000ffff) | (uint32_t)val<<16));                            \       }while(0);
end_define

begin_define
define|#
directive|define
name|GET_UINT16
parameter_list|(
name|addr
parameter_list|)
value|(((uint32_t)&addr%4) ?           \        ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr& ~0x3L))):  \        ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr)>> 16)))
end_define

begin_define
define|#
directive|define
name|WRITE_UINT8
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
value|WRITE_UINT8_ERRATA(&addr,val)
end_define

begin_define
define|#
directive|define
name|GET_UINT8
parameter_list|(
name|addr
parameter_list|)
value|GET_UINT8_ERRATA(&addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CORE_8BIT_ACCESS_ERRATA */
end_comment

begin_function
specifier|static
name|void
name|WRITE_UINT8_ERRATA
parameter_list|(
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|uint32_t
name|newAddr
decl_stmt|,
name|newVal
decl_stmt|;
name|newAddr
operator|=
operator|(
name|uint32_t
operator|)
name|addr
operator|&
operator|~
literal|0x3L
expr_stmt|;
switch|switch
condition|(
operator|(
name|uint32_t
operator|)
name|addr
operator|%
literal|4
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0x00ffffff
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|val
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0xff00ffff
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|val
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|2
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0xffff00ff
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|val
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0xffffff00
operator|)
operator||
name|val
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GET_UINT8_ERRATA
parameter_list|(
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|newAddr
decl_stmt|,
name|newVal
init|=
literal|0
decl_stmt|;
name|newAddr
operator|=
operator|(
name|uint32_t
operator|)
name|addr
operator|&
operator|~
literal|0x3L
expr_stmt|;
switch|switch
condition|(
operator|(
name|uint32_t
operator|)
name|addr
operator|%
literal|4
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
break|break;
case|case
operator|(
literal|1
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
operator|(
literal|2
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|)
case|:
name|newVal
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|newAddr
argument_list|)
expr_stmt|;
name|newVal
operator|=
operator|(
name|newVal
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|uint8_t
operator|)
name|newVal
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|GetPrOffsetByNonHeader
parameter_list|(
name|uint8_t
modifier|*
name|parseArrayOffset
parameter_list|)
block|{
comment|/*For now - the only field in the Parse Array from the NON_BY_TYPE can be e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE*/
comment|/*Maybe extended in the future*/
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_NEXT_HEADER_OFFSET
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateManipIc
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|uint8_t
name|icOffset
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Handle
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|INTERNAL_CONTEXT_OFFSET
condition|)
block|{
name|tmpReg32
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|icOffset
operator|<<
literal|16
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
operator|=
name|tmpReg32
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|p_Manip
operator|->
name|icOffset
operator|=
name|icOffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|icOffset
operator|!=
name|icOffset
condition|)
name|RETURN_ERROR
argument_list|(
argument|MAJOR
argument_list|,
argument|E_INVALID_VALUE
argument_list|,
argument|(
literal|"this manipulation was updated previousely by different value"
argument|);
argument_list|)
empty_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|INTERNAL_CONTEXT_OFFSET
condition|)
block|{
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator||=
name|GET_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|icOffset
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|p_Manip
operator|->
name|icOffset
operator|=
name|icOffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|icOffset
operator|!=
name|icOffset
condition|)
name|RETURN_ERROR
argument_list|(
argument|MAJOR
argument_list|,
argument|E_INVALID_VALUE
argument_list|,
argument|(
literal|"this manipulation was updated previousely by different value"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|type
operator|&
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|muramAllocate
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_PSO
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|psoSize
operator|=
literal|16
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Parser result offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
name|ASSERT_COND
argument_list|(
operator|!
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
operator|%
literal|16
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_PSO
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|psoSize
operator|=
literal|16
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Parser result offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
condition|)
block|{
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|)
operator||
name|tmpReg32
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_PR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uint8_t
operator|)
name|tmpReg32
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
condition|)
name|RETURN_ERROR
argument_list|(
argument|MAJOR
argument_list|,
argument|E_INVALID_STATE
argument_list|,
argument|(
literal|"this manipulation was updated previousely by different value"
argument|);
argument_list|)
empty_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
end_ifdef

begin_function
specifier|static
name|t_Error
name|UpdateModifyCapwapFragmenation
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_FmPcdCcSavedManipParams
modifier|*
name|p_SavedManipParams
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|p_SavedManipParams
operator|=
name|FmPcdCcTreeGetSavedManipParams
argument_list|(
name|h_FmTree
argument_list|,
name|e_FM_MANIP_CAPWAP_INDX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SavedManipParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"for this manipulation tree has to be configured previosely with this type"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|=
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|poolId
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
operator|=
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|<<
literal|8
operator|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
operator|<<
literal|16
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|BUFFER_POOL_ID_FOR_MANIP
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
operator|(
name|OFFSET_OF_DATA
operator||
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
name|p_SavedManipParams
operator|=
name|FmPcdCcTreeGetSavedManipParams
argument_list|(
name|h_FmTree
argument_list|,
name|e_FM_MANIP_CAPWAP_INDX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SavedManipParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"for this manipulation tree has to be configured previosely with this type"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|!=
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|poolId
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
operator|!=
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"this manipulation was updated previousely by different value"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitCapwapFragmentation
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcSavedManipParams
modifier|*
name|p_SavedManipParams
decl_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
operator||
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIndex
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Data offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Buffer pool doe header manipulation wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
name|p_SavedManipParams
operator|=
operator|(
name|t_FmPcdCcSavedManipParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcSavedManipParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|poolId
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIdForManip
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
name|ASSERT_COND
argument_list|(
operator|!
operator|(
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
operator|%
literal|16
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FmPcdCcTreeSetSavedManipParams
argument_list|(
name|h_FmTree
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_SavedManipParams
argument_list|,
name|e_FM_MANIP_CAPWAP_INDX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIndex
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
operator||
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Data offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Buffer pool doe header manipulation wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIdForManip
operator|<<
literal|8
operator|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|<<
literal|16
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|BUFFER_POOL_ID_FOR_MANIP
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
operator|(
name|OFFSET_OF_DATA
operator||
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIdForManip
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIdForManip
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"this manipulation was updated previousely by different value"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitCapwapReasm
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_CapwapReasmPram
modifier|*
name|p_ReassmTbl
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|uint16_t
name|size
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcCapwapReassmTimeoutParams
name|ccCapwapReassmTimeoutParams
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"handler of PCD previously was initiated by different value"
operator|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_ReassmTbl
operator|=
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIndex
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Num of tasks wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data  wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"buffser pool id  wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hwPortId wasn't updated"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
name|ASSERT_COND
argument_list|(
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|%
literal|16
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIndex
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"NumOfTasks wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Buffer pool for header manipulation wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data  wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hwPortId wasn't updated"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
condition|)
block|{
name|size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|maxNumFramesInProcess
operator|+
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|255
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|numOfTasks
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
expr_stmt|;
comment|/*p_ReassmFrmDescrIndxPoolTbl*/
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|+
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|WRITE_UINT8
argument_list|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|,
name|i
argument_list|)
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|reasmFrmDescIndexPoolTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/*p_ReassmFrmDescrPoolTbl*/
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|reasmFrmDescPoolTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/*p_TimeOutTbl*/
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_TimeOutTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_TimeOutTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_TimeOutTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_TimeOutTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|timeOutTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|NUM_OF_TASKS
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|NUM_OF_TASKS
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
condition|)
block|{
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIdForManip
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|bufferPoolIdAndRisc1SetIndexes
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
operator|<<
literal|16
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|bufferPoolIdAndRisc1SetIndexes
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|BUFFER_POOL_ID_FOR_MANIP
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|BUFFER_POOL_ID_FOR_MANIP
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
condition|)
block|{
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_DATA
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
block|{
name|p_Manip
operator|->
name|fragParams
operator|.
name|prOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_PR_COPY
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|intStatsTblPtr
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|fragParams
operator|.
name|prOffset
operator|<<
literal|24
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|intStatsTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_PR
expr_stmt|;
block|}
else|else
block|{
name|p_Manip
operator|->
name|fragParams
operator|.
name|prOffset
operator|=
literal|0xff
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_PR
expr_stmt|;
block|}
name|p_Manip
operator|->
name|fragParams
operator|.
name|hwPortId
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|hardwarePortId
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|HW_PORT_ID
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|HW_PORT_ID
expr_stmt|;
comment|/*timeout hc */
name|ccCapwapReassmTimeoutParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|ccCapwapReassmTimeoutParams
operator|.
name|portIdAndCapwapReassmTbl
operator|=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|fragParams
operator|.
name|hwPortId
operator|<<
literal|24
expr_stmt|;
name|ccCapwapReassmTimeoutParams
operator|.
name|portIdAndCapwapReassmTbl
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_ReassmTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|ccCapwapReassmTimeoutParams
operator|.
name|timeoutRequestTime
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
name|p_Manip
operator|->
name|fragParams
operator|.
name|bitFor1Micro
operator|)
operator|*
name|p_Manip
operator|->
name|fragParams
operator|.
name|timeoutRoutineRequestTime
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|FmHcPcdCcCapwapTimeoutReassm
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
operator|&
name|ccCapwapReassmTimeoutParams
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|hardwarePortId
operator|!=
name|p_Manip
operator|->
name|fragParams
operator|.
name|hwPortId
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Reassembly manipulation previously was assigned to another port"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
operator|!=
name|p_Manip
operator|->
name|fragParams
operator|.
name|numOfTasks
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfTasks for this manipulation previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIdForManip
operator|!=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolId
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"poolId for this manipulation previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|prOffset
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Parse result offset previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|prOffset
operator|!=
literal|0xff
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Parse result offset previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|!=
name|p_Manip
operator|->
name|fragParams
operator|.
name|dataOffset
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Data offset previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FM_CAPWAP_SUPPORT */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|t_Error
name|UpdateInitIPSec
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_IPSEC
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/*     if(p_Manip->cnia)     {         p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;          WRITE_UINT32(p_Ad->ccAdBase, GET_UINT32(p_Ad->ccAdBase) | FM_PCD_MANIP_IPSEC_CNIA);     } */
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
end_ifdef

begin_function
specifier|static
name|t_Error
name|UpdateInitIpFragmentation
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_IP_FRAGMENTATION
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
operator||
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateIpReassCommonParamTable
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_IpReasmCommonTbl
modifier|*
name|p_IpReasmCommonPramTbl
parameter_list|)
block|{
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|uint64_t
name|tmpReg64
decl_stmt|,
name|size
decl_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_IpReassCommonParamsTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE
argument_list|,
name|FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_IpReassCommonParamsTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|p_IpReasmCommonPramTbl
operator|=
operator|(
name|t_IpReasmCommonTbl
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_IpReassCommonParamsTbl
operator|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_IpReasmCommonPramTbl
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|timeOutMode
operator|==
name|e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES
expr_stmt|;
name|tmpReg32
operator||=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|timeoutModeAndFqid
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|size
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|maxNumFramesInProcess
operator|+
literal|129
expr_stmt|;
comment|/*p_ReassmFrmDescrIndxPoolTbl */
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|2
argument_list|)
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|WRITE_UINT8
argument_list|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
argument_list|,
name|i
argument_list|)
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|reassFrmDescIndexPoolTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/*p_ReassmFrmDescrPoolTbl*/
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrPoolTbl
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|32
argument_list|)
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataMemId
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrPoolTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrPoolTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg64
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrPoolTbl
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_LIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|liodnAndReassFrmDescPoolPtrHi
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpReg64
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|reassFrmDescPoolPtrLow
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpReg64
argument_list|)
expr_stmt|;
comment|/*p_TimeOutTbl*/
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_TimeOutTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_TimeOutTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_TimeOutTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_TimeOutTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|timeOutTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Expiration Delay */
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|timeoutThresholdForReassmProcess
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|expirationDelay
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Counts the number of TimeOut occurrences - Must be initialized to zero.*/
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|totalTimeOutCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Counts the number of failed attempts to allocate a Reassembly Frame Descriptor - Must be initialized to zero.*/
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|totalRfdPoolBusyCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Counts the number of times an internal buffer busy occured.*/
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|totalInternalBufferBusy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Counts the number of times external buffer busy occured. */
name|WRITE_UINT32
argument_list|(
name|p_IpReasmCommonPramTbl
operator|->
name|totalExternalBufferBusy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateIpReassParamTable
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_IpReassParamsTblPtr
parameter_list|,
name|bool
name|ipv4
parameter_list|)
block|{
name|t_IpReasmPram
modifier|*
name|p_Table
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|,
name|autoLearnHashTblSize
decl_stmt|;
name|uint32_t
name|numOfWays
decl_stmt|,
name|setSize
decl_stmt|,
name|setSizeCode
decl_stmt|,
name|tmpSetSize
decl_stmt|;
name|uint32_t
name|waySize
decl_stmt|,
name|numOfSets
decl_stmt|,
name|tmpNumOfSets
decl_stmt|,
name|numOfEntries
decl_stmt|;
name|uint64_t
name|tmpReg64
decl_stmt|;
name|t_Handle
name|h_AutoLearnHashTbl
decl_stmt|,
name|h_AutoLearnSetLockTblPtr
decl_stmt|;
comment|/*Pointer to fragment ID*/
name|h_IpReassParamsTblPtr
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_MANIP_IP_REASM_TABLE_SIZE
argument_list|,
name|FM_PCD_MANIP_IP_REASM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_IpReassParamsTblPtr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|h_IpReassParamsTblPtr
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MANIP_IP_REASM_TABLE_SIZE
argument_list|)
expr_stmt|;
name|p_Table
operator|=
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|h_IpReassParamsTblPtr
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_IpReassCommonParamsTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|h_IpReassParamsTblPtr
operator|)
operator|->
name|ipReassCommonPrmTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* waysNumAndSetSize calculation */
name|numOfWays
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|numOfFramesPerHashEntry
expr_stmt|;
comment|/*It is recommended that the total number of entries in this table     (number of sets * number of ways) will be twice the number of frames that      are expected to be reassembled simultaneously.*/
name|numOfEntries
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|maxNumFramesInProcess
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* sets number calculation - number of entries = number of sets * number of ways */
name|numOfSets
operator|=
name|numOfEntries
operator|/
name|numOfWays
expr_stmt|;
comment|/*TODO - Handle way size*/
switch|switch
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
comment|/* WaySize is rounded-up to next multiple of 8 */
name|waySize
operator|=
name|ROUND_UP
argument_list|(
operator|(
operator|(
literal|16
operator|+
literal|16
operator|+
literal|4
operator|+
literal|2
operator|)
comment|/* * numOfWays*/
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported header for reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set size is rounded-up to next power of 2 */
name|LOG2
argument_list|(
name|numOfWays
operator|*
name|waySize
argument_list|,
name|tmpSetSize
argument_list|)
expr_stmt|;
name|setSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|tmpSetSize
operator|+
operator|(
name|POWER_OF_2
argument_list|(
name|numOfWays
operator|*
name|waySize
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|LOG2
argument_list|(
name|setSize
argument_list|,
name|setSizeCode
argument_list|)
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|waysNumAndSetSize
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|numOfWays
operator|<<
literal|8
operator|)
operator||
name|setSizeCode
argument_list|)
argument_list|)
expr_stmt|;
name|LOG2
argument_list|(
name|numOfSets
argument_list|,
name|tmpNumOfSets
argument_list|)
expr_stmt|;
name|numOfSets
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|tmpNumOfSets
operator|+
operator|(
name|POWER_OF_2
argument_list|(
name|numOfSets
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|autoLearnHashKeyMask
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|numOfSets
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/*autoLearnHashTbl allocation     Table size = set size * number of sets     This tables base address should be aligned to SetSize.*/
name|autoLearnHashTblSize
operator|=
name|numOfSets
operator|*
name|setSize
expr_stmt|;
if|if
condition|(
name|ipv4
condition|)
name|h_AutoLearnHashTbl
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4AutoLearnHashTbl
expr_stmt|;
else|else
name|h_AutoLearnHashTbl
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6AutoLearnHashTbl
expr_stmt|;
name|h_AutoLearnHashTbl
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
name|autoLearnHashTblSize
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataMemId
argument_list|,
name|setSizeCode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_AutoLearnHashTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|h_AutoLearnHashTbl
argument_list|,
literal|0
argument_list|,
name|autoLearnHashTblSize
argument_list|)
expr_stmt|;
name|tmpReg64
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_LIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
name|XX_VirtToPhys
argument_list|(
name|h_AutoLearnHashTbl
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|liodnAlAndAutoLearnHashTblPtrHi
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpReg64
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|autoLearnHashTblPtrLow
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpReg64
argument_list|)
expr_stmt|;
comment|/* AutoLearnSetLockTbl allocation - The size of this table is (number of sets in the IP     Reassembly Automatic Learning Hash table)*4 bytes. This table resides in external memory     and its base address should be 4-byte aligned */
if|if
condition|(
name|ipv4
condition|)
name|h_AutoLearnSetLockTblPtr
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4AutoLearnSetLockTblPtr
expr_stmt|;
else|else
name|h_AutoLearnSetLockTblPtr
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6AutoLearnSetLockTblPtr
expr_stmt|;
name|h_AutoLearnSetLockTblPtr
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|numOfSets
operator|*
literal|4
argument_list|)
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataMemId
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_AutoLearnSetLockTblPtr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|h_AutoLearnSetLockTblPtr
argument_list|,
literal|0
argument_list|,
operator|(
name|numOfSets
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|tmpReg64
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_LIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
name|XX_VirtToPhys
argument_list|(
name|h_AutoLearnSetLockTblPtr
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|liodnSlAndAutoLearnSetLockTblPtrHi
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpReg64
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|autoLearnSetLockTblPtrLow
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpReg64
argument_list|)
expr_stmt|;
comment|/* Setting the First/Middle fragment minimum size in Bytes */
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|minFragSize
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|minFragSize
argument_list|)
expr_stmt|;
comment|/* Zeroes all counters */
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalSuccessfullyReasmFramesCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalValidFragmentCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalProcessedFragCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalMalformdFragCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalSetBusyCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalDiscardedFragsCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_IpReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|totalMoreThan16FramesCounter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitIpReasm
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
decl_stmt|;
name|t_IpReasmCommonTbl
modifier|*
name|p_ReassmCommonTbl
init|=
name|NULL
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|type
operator|==
name|HMAN_OC_IP_REASSEMBLY
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"handler of PCD previously was initiated by different value"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIndex
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_RFENE
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_CLOSING_FRAG_CHECK
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Num of tasks wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data  wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hwPortId wasn't updated"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|poolIndex
operator|=
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_FRAG
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_RFENE
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_CLOSING_FRAG_CHECK
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"NumOfTasks wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data  wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hwPortId wasn't updated"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
condition|)
block|{
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataOffset
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_DATA
expr_stmt|;
block|}
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|HW_PORT_ID
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|HW_PORT_ID
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|validate
condition|)
block|{
comment|/* TODO - Handle validate..*/
comment|/*if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));             if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));              if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));              if(!(fmPortGetSetCcParams.getCcParams.type& OFFSET_OF_PR))             {                 if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));             }             else             {                 if(p_Manip->fragParams.prOffset != 0xff)                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));             }             if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));*/
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
end_comment

begin_function
specifier|static
name|void
name|ReleaseManipHandler
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|muramAllocate
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
else|else
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|h_Ad
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|p_Template
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|p_Template
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|p_Template
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_AutoLearnHashTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_TimeOutTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_TimeOutTbl
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|h_Frag
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
if|if
condition|(
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_FragId
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_FragId
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_Frag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|reassm
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4AutoLearnHashTbl
condition|)
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4AutoLearnHashTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6AutoLearnHashTbl
condition|)
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6AutoLearnHashTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4AutoLearnSetLockTblPtr
condition|)
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4AutoLearnSetLockTblPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6AutoLearnSetLockTblPtr
condition|)
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6AutoLearnSetLockTblPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4ReassParamsTblPtr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4ReassParamsTblPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6ReassParamsTblPtr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6ReassParamsTblPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_IpReassCommonParamsTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_IpReassCommonParamsTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrIndxPoolTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrPoolTbl
condition|)
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_ReassmFrmDescrPoolTbl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
if|if
condition|(
name|p_Manip
operator|->
name|p_StatsTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|p_StatsTbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CheckManipParamsAndSetType
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|rmv
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|rmvParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION
operator|)
case|:
switch|switch
condition|(
name|p_ManipParams
operator|->
name|rmvParams
operator|.
name|rmvSpecificLocationParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_LOC_BY_HDR
operator|)
case|:
switch|switch
condition|(
name|p_ManipParams
operator|->
name|rmvParams
operator|.
name|rmvSpecificLocationParams
operator|.
name|manipByHdr
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP_DTLS
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|insrt
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
block|{
if|if
condition|(
operator|!
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|frag
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_CAPWAP_REASSEMBLY
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"unsupported header for Reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for this type of manipulation frag can not be TRUE"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"non valid net header of remove location"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"non valid type of remove location"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_INT_FRAME_HDR
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|insrt
operator|||
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For the type of remove e_FM_PCD_MANIP_RMV_INT_FRAME_HDR the only valid option rmv = TRUE, insrt = FALSE, fragOrReasm = FALSE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
operator|||
operator|(
operator|(
name|p_ManipParams
operator|->
name|insrt
operator|)
operator|&&
name|p_ManipParams
operator|->
name|insrtParams
operator|.
name|type
operator|!=
name|e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION the only allowed insertion type is e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of remove manipulation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|insrt
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|insrtParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|frag
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
break|break;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid header for fragmentation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"can not reach this point"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of insert can not be fragOrReasm = TRUE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for only isert manipulation unsupported type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|frag
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|FALSE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_IP_FRAGMENTATION
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported header for fragmentation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_IP_REASSEMBLY
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_IP_REASSEMBLY
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv6
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported header for reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"User didn't ask for any manipulation"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|insrt
operator|=
name|p_ManipParams
operator|->
name|insrt
expr_stmt|;
name|p_Manip
operator|->
name|rmv
operator|=
name|p_ManipParams
operator|->
name|rmv
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateIndxStats
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"handler of PCD previously was initiated by different value"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_StatsTbl
condition|)
block|{
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNDN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_CC
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|p_StatsTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|owner
operator|*
name|FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_StatsTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|p_StatsTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|owner
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|p_StatsTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|cnia
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_INDEXED_STATS_CNIA
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_INDEXED_STATS_DPD
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNDN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_CC
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPcdManipInitUpdate
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|int
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_FmTree
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
if|if
condition|(
name|level
operator|!=
literal|1
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For CAPWAP reassembly the manipulation has to be in the first level of the tree"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix
argument_list|(
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
if|if
condition|(
name|level
operator|!=
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For CAPWAP fragmentation the manipulation has to be in the first level of the tree"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateInitCapwapFragmentation
argument_list|(
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|level
operator|!=
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For CAPWAP reassembly the manipulation has to be in the first level of the tree"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateInitCapwapReasm
argument_list|(
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
operator|)
case|case
operator|(
name|HMAN_OC_IPSEC
operator|)
case|:
name|err
operator|=
name|UpdateInitIPSec
argument_list|(
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"UpdateInitIPSec failed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
break|break;
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
name|err
operator|=
name|UpdateInitIpFragmentation
argument_list|(
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
name|err
operator|=
name|UpdateInitIpReasm
argument_list|(
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
endif|#
directive|endif
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))*/
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
if|if
condition|(
name|level
operator|!=
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For index statistics the manipulation has to be in the first level of the tree"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateIndxStats
argument_list|(
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|E_OK
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPcdManipModifyUpdate
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|int
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"modify node with this type of manipulation  is not suppported"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|BUFFER_POOL_ID_FOR_MANIP
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"modify node with this type of manipulation requires manipulation be updated previousely in SetPcd function"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For CAPWAP reassembly the manipulation has to be in the first level of the tree"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|level
operator|!=
literal|2
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For CAPWAP fragmentation the manipulation has to be in the first level of the tree"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateModifyCapwapFragmenation
argument_list|(
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
default|default:
return|return
name|E_OK
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|GetPrOffsetByHeaderOrField
parameter_list|(
name|t_FmPcdManipLocationParams
modifier|*
name|p_ManipParams
parameter_list|,
name|uint8_t
modifier|*
name|parseArrayOffset
parameter_list|)
block|{
name|e_NetHeaderType
name|hdr
init|=
name|p_ManipParams
operator|->
name|manipByHdr
operator|.
name|hdr
decl_stmt|;
name|e_FmPcdHdrIndex
name|hdrIndex
init|=
name|p_ManipParams
operator|->
name|manipByHdr
operator|.
name|hdrIndex
decl_stmt|;
name|bool
name|byField
init|=
name|p_ManipParams
operator|->
name|manipByHdr
operator|.
name|byField
decl_stmt|;
name|t_FmPcdFields
name|field
decl_stmt|;
if|if
condition|(
name|byField
condition|)
name|field
operator|=
name|p_ManipParams
operator|->
name|manipByHdr
operator|.
name|fullField
expr_stmt|;
if|if
condition|(
name|byField
condition|)
block|{
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_ETYPE_LAST_OFFSET
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of the type Ethernet with this field not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_VLAN1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_VLAN2_OFFSET
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of the type VLAN with this field not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of this header by field not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_ETH_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM1
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_USER_DEFINED_SHIM1_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM2
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_USER_DEFINED_SHIM2_OFFSET
expr_stmt|;
break|break;
comment|/* TODO - to take care about SHIM3             case(HEADER_TYPE_USER_DEFINED_SHIM3):                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;                 break;             */
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_USER_LLC_SNAP_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_PPPOE_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MPLS1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MPLS_LAST_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_IP1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_IP_LAST_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MINENC_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_GRE_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_L4_OFFSET
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of this header is not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|RmvHdrTillSpecLocNOrInsrtIntFrmHdr
parameter_list|(
name|t_FmPcdManipRmvParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|uint8_t
name|prsArrayOffset
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|rmv
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|rmvSpecificLocationParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_LOC_BY_HDR
operator|)
case|:
name|err
operator|=
name|GetPrOffsetByHeaderOrField
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|rmvSpecificLocationParams
argument_list|,
operator|&
name|prsArrayOffset
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_LOC_NON_HDR
operator|)
case|:
name|err
operator|=
name|GetPrOffsetByNonHeader
argument_list|(
operator|&
name|prsArrayOffset
argument_list|)
expr_stmt|;
break|break;
default|default :
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid type of location header manipulation of type Remove"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|prsArrayOffset
operator|<<
literal|24
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_RMV_HDR
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|insrt
condition|)
name|tmpReg32
operator||=
name|HMAN_INSRT_INT_FRM_HDR
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|MvIntFrameHeaderFromFrameToBufferPrefix
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|bool
name|caamUsed
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator||=
name|OFFSET_OF_PR
operator||
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|ccAdBase
operator|=
name|tmpReg32
expr_stmt|;
comment|/*TODO - update offsetInBufferPrefixForIntFrameHdr when port connected to tree     tmpReg32 = 0;     tmpReg32 |= offsetInBufferPrefixForIntFrameHdr;     *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;*/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
literal|0x16
operator|<<
literal|16
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|pcAndOffsets
operator|=
name|tmpReg32
expr_stmt|;
if|if
condition|(
name|caamUsed
condition|)
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|gmask
operator|=
literal|0xf0000000
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
end_ifdef

begin_function
specifier|static
name|t_Error
name|CapwapRmvDtlsHdr
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
name|p_Manip
operator|->
name|updateParams
operator||=
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapReassembly
parameter_list|(
name|t_CapwapReassemblyParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|poolIndex
parameter_list|)
block|{
name|t_Handle
name|p_Table
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint8_t
name|log2Num
decl_stmt|;
name|uint8_t
name|numOfSets
decl_stmt|;
name|uint32_t
name|j
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Hc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"hc port has to be initialized in this mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|p_ManipParams
operator|->
name|timeoutRoutineRequestTime
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"timeoutRoutineRequestTime has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumFramesInProcess has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ManipParams
operator|->
name|timeoutRoutineRequestTime
operator|&&
name|p_ManipParams
operator|->
name|timeoutThresholdForReassmProcess
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|numOfFramesPerHashEntry
operator|==
name|e_FM_PCD_MANIP_FOUR_WAYS_HASH
condition|)
block|{
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|<
literal|4
operator|)
operator|||
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|>
literal|512
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|<
literal|8
operator|)
operator|||
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|>
literal|2048
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Manip
operator|->
name|updateParams
operator||=
operator|(
name|NUM_OF_TASKS
operator||
name|BUFFER_POOL_ID_FOR_MANIP
operator||
name|OFFSET_OF_PR
operator||
name|OFFSET_OF_DATA
operator||
name|HW_PORT_ID
operator|)
expr_stmt|;
name|p_Manip
operator|->
name|h_Frag
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE
argument_list|)
expr_stmt|;
name|p_Table
operator|=
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_AutoLearnHashTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE
argument_list|)
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|autoLearnHashTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|timeOutMode
operator|==
name|e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|haltOnDuplicationFrag
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|numOfFramesPerHashEntry
operator|==
name|e_FM_PCD_MANIP_EIGHT_WAYS_HASH
condition|)
block|{
name|i
operator|=
literal|8
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|4
expr_stmt|;
name|numOfSets
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
operator|)
operator|/
name|i
argument_list|)
expr_stmt|;
name|LOG2
argument_list|(
name|numOfSets
argument_list|,
name|log2Num
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|log2Num
operator|-
literal|1
argument_list|)
operator|<<
literal|24
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|j
operator|/
name|i
operator|)
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|,
name|j
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE
argument_list|)
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
block|}
block|}
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|bufferPoolIdAndRisc1SetIndexes
argument_list|,
literal|0x00008000
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|risc23SetIndexes
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|risc4SetIndexesAndExtendedStatsTblPtr
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|maxNumFramesInProcess
operator|=
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
operator|=
name|poolIndex
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|p_ManipParams
operator|->
name|fqidForTimeOutFrames
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|timeoutRoutineRequestTime
operator|=
name|p_ManipParams
operator|->
name|timeoutRoutineRequestTime
expr_stmt|;
comment|/*TODO  - to take care about this function FmGetTimeStampScale - it return t_Error      now we have problems with all calls to this fucntion*/
name|p_Manip
operator|->
name|fragParams
operator|.
name|bitFor1Micro
operator|=
name|FmGetTimeStampScale
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
name|p_Manip
operator|->
name|fragParams
operator|.
name|bitFor1Micro
operator|)
operator|*
name|p_ManipParams
operator|->
name|timeoutThresholdForReassmProcess
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|expirationDelay
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapFragmentation
parameter_list|(
name|t_CapwapFragmentationParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|poolIndex
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator||=
name|OFFSET_OF_DATA
operator||
name|BUFFER_POOL_ID_FOR_MANIP
expr_stmt|;
name|p_Manip
operator|->
name|frag
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|h_Frag
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|headerOptionsCompr
condition|)
name|tmpReg32
operator|=
name|FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|sizeForFragmentation
operator|=
name|p_ManipParams
operator|->
name|sizeForFragmentation
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|poolIndx
operator|=
name|poolIndex
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FM_CAPWAP_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
end_ifdef

begin_function
specifier|static
name|t_Error
name|IpFragmentation
parameter_list|(
name|t_IpFragmentationParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|poolIndex
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_Frag
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_Frag
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_IP_FRAGMENTATION
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_ManipParams
operator|->
name|dontFragAction
operator|<<
literal|30
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|frag
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|sizeForFragmentation
operator|=
name|p_ManipParams
operator|->
name|sizeForFragmentation
expr_stmt|;
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|poolIndx
operator|=
name|poolIndex
expr_stmt|;
comment|/*Pointer to fragment ID*/
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_FragId
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_FragId
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_FragId
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|ipFragParams
operator|.
name|h_FragId
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|p_ManipParams
operator|->
name|scratchBpid
operator|<<
literal|24
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FillReassmManipParams
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|ipv4
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_Handle
name|h_IpReassParamsTblPtr
decl_stmt|;
comment|/* First Ad register */
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
if|if
condition|(
name|ipv4
condition|)
name|h_IpReassParamsTblPtr
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4ReassParamsTblPtr
expr_stmt|;
else|else
name|h_IpReassParamsTblPtr
operator|=
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6ReassParamsTblPtr
expr_stmt|;
name|err
operator|=
name|CreateIpReassParamTable
argument_list|(
name|p_Manip
argument_list|,
name|h_IpReassParamsTblPtr
argument_list|,
name|ipv4
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|E_OK
condition|)
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|h_IpReassParamsTblPtr
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
name|err
return|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Second Ad register */
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|bpid
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|=
name|OFFSET_OF_DATA
expr_stmt|;
comment|/* Third Ad register */
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_IP_REASSEMBLY
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_LIODN_SHIFT
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|&
name|FM_PCD_MANIP_IP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|reassm
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetIpv4ReassmManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|muramAllocate
condition|)
block|{
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4Ad
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataMemId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv4Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FillReassmManipParams
argument_list|(
name|p_Manip
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetIpv6ReassmManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|muramAllocate
condition|)
block|{
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataMemId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FillReassmManipParams
argument_list|(
name|p_Manip
argument_list|,
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|h_Ipv6Ad
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IpReassembly
parameter_list|(
name|t_FmPcdManipFragOrReasmParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|maxSetNumber
init|=
literal|10000
decl_stmt|;
name|t_IpReasmCommonTbl
modifier|*
name|p_IpReasmCommonPramTbl
init|=
name|NULL
decl_stmt|;
name|t_IpReassemblyParams
name|reassmManipParams
init|=
name|p_ManipParams
operator|->
name|ipReasmParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Hc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"hc port has to be initialized in this mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumFramesInProcess has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
operator|<
literal|1000
operator|)
operator|&&
operator|(
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
operator|>
literal|8000000
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"timeoutThresholdForReassmProcess should be 1msec - 8sec"
operator|)
argument_list|)
expr_stmt|;
comment|/*It is recommended that the total number of entries in this table (number of sets * number of ways)      will be twice the number of frames that are expected to be reassembled simultaneously.*/
if|if
condition|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
operator|>
operator|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
operator|*
name|maxSetNumber
operator|/
literal|2
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|maxNumFramesInProcess
operator|=
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|timeOutMode
operator|=
name|reassmManipParams
operator|.
name|timeOutMode
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|reassmManipParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|numOfFramesPerHashEntry
operator|=
name|reassmManipParams
operator|.
name|numOfFramesPerHashEntry
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|timeoutThresholdForReassmProcess
operator|=
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|liodnOffset
operator|=
name|reassmManipParams
operator|.
name|liodnOffset
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|minFragSize
operator|=
name|reassmManipParams
operator|.
name|minFragSize
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|dataMemId
operator|=
name|reassmManipParams
operator|.
name|dataMemId
expr_stmt|;
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|bpid
operator|=
name|p_ManipParams
operator|->
name|extBufPoolIndx
expr_stmt|;
name|CreateIpReassCommonParamTable
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|,
name|p_IpReasmCommonPramTbl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv4_AND_IPv6
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv4
operator|)
condition|)
return|return
name|SetIpv4ReassmManip
argument_list|(
name|p_Manip
argument_list|)
return|;
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv4_AND_IPv6
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|ipReassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
condition|)
return|return
name|SetIpv6ReassmManip
argument_list|(
name|p_Manip
argument_list|)
return|;
name|err
operator|=
name|FM_PCD_RegisterReassmPort
argument_list|(
name|p_FmPcd
argument_list|,
name|p_IpReasmCommonPramTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_IpReasmCommonPramTbl
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"port registration"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
end_comment

begin_function
specifier|static
name|t_Error
name|IndxStats
parameter_list|(
name|t_FmPcdStatsParams
modifier|*
name|p_StatsParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_INDEXED_STATS
expr_stmt|;
if|if
condition|(
name|p_StatsParams
operator|->
name|type
operator|==
name|e_FM_PCD_STATS_PER_FLOWID
condition|)
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
literal|0x16
operator|<<
literal|16
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|InsrtHdrByTempl
parameter_list|(
name|t_FmPcdManipInsrtParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdManipInsrtByTemplateParams
modifier|*
name|p_InsrtByTemplate
init|=
operator|&
name|p_ManipParams
operator|->
name|insrtByTemplateParams
decl_stmt|;
name|uint8_t
name|tmpReg8
init|=
literal|0xff
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|bool
name|ipModify
init|=
name|FALSE
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|tmpRegNia
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tmpReg16
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|extraAddedBytes
init|=
literal|0
decl_stmt|,
name|blockSize
init|=
literal|0
decl_stmt|,
name|extraAddedBytesAlignedToBlockSize
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|p_Template
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|insrt
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|p_InsrtByTemplate
operator|->
name|size
operator|&&
name|p_InsrtByTemplate
operator|->
name|modifyOuterIp
operator|)
operator|||
operator|(
operator|!
name|p_InsrtByTemplate
operator|->
name|size
operator|&&
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlan
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|size
operator|&&
name|p_InsrtByTemplate
operator|->
name|modifyOuterIp
operator|&&
operator|(
name|p_InsrtByTemplate
operator|->
name|size
operator|<=
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : size of template< ipOuterOffset"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|size
operator|>
literal|128
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Size of header template for insertion can not be more than 128"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|size
condition|)
block|{
name|p_Manip
operator|->
name|p_Template
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_InsrtByTemplate
operator|->
name|size
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_Template
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|p_Template
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_InsrtByTemplate
operator|->
name|size
operator|<<
literal|24
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|matchTblPtr
operator|=
name|tmpReg32
expr_stmt|;
block|}
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|p_Template
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|p_InsrtByTemplate
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Template
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"XX_Malloc allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_Template
argument_list|,
name|p_InsrtByTemplate
operator|->
name|hdrTemplate
argument_list|,
name|p_InsrtByTemplate
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIp
condition|)
block|{
name|ipModify
operator|=
name|TRUE
expr_stmt|;
name|tmpReg8
operator|=
operator|(
name|uint8_t
operator|)
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmpReg8
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
name|tmpReg8
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmpReg8
operator|&
literal|0xf0
operator|)
operator|==
literal|0x60
condition|)
name|tmpReg8
operator|=
literal|6
expr_stmt|;
else|else
name|tmpReg8
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|tmpReg8
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP
operator|+
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|)
operator|>
name|p_InsrtByTemplate
operator|->
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|dscpEcn
operator|&
literal|0xff00
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_DSCECN_FIELD_OFFSET_FROM_IP
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|dscpEcn
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLength
condition|)
block|{
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedAlignedToBlockSize
operator|+
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedNotAlignedToBlockSize
operator|)
operator|>
literal|255
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"extra Byte added can not be more than 256 bytes"
operator|)
argument_list|)
expr_stmt|;
name|extraAddedBytes
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedAlignedToBlockSize
operator|+
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedNotAlignedToBlockSize
argument_list|)
expr_stmt|;
name|blockSize
operator|=
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|blockSize
expr_stmt|;
name|extraAddedBytesAlignedToBlockSize
operator|=
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedAlignedToBlockSize
expr_stmt|;
comment|/*IP header template - IP totalLength -                      (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,                      in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)                      second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
block|}
if|if
condition|(
name|blockSize
condition|)
block|{
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|blockSize
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"inputFrmPaddingUpToBlockSize has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
name|blockSize
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|size
operator|-
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|extraAddedBytes
operator|)
operator|>
literal|255
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
name|blockSize
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|size
operator|-
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|extraAddedBytes
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_ID_FIELD_OFFSET_FROM_IP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_ID_FIELD_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
name|extraAddedBytesAlignedToBlockSize
expr_stmt|;
comment|/*IP header template - relevant only for ipv4 CheckSum = 0*/
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/*UDP checksum has to be 0*/
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpPresent
condition|)
block|{
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP
operator|+
name|UDP_UDPCHECKSUM_FIELD_SIZE
operator|)
operator|>
name|p_InsrtByTemplate
operator|->
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size)< size of header template"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP
operator|+
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipIdentGenId
operator|>
literal|7
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"
operator|)
argument_list|)
expr_stmt|;
name|tmpRegNia
operator||=
operator|(
name|uint32_t
operator|)
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipIdentGenId
operator|<<
literal|24
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"IP version supported only IPV4"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator|=
name|tmpReg16
operator|=
name|tmpReg8
operator|=
literal|0
expr_stmt|;
comment|/*TODO - check it*/
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlan
condition|)
block|{
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlanParams
operator|.
name|vpri
operator|&
operator|~
literal|0x07
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmpReg16
argument_list|,
operator|&
name|p_Template
index|[
name|VLAN_TAG_FIELD_OFFSET_FROM_ETH
index|]
argument_list|,
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpReg16
operator|!=
literal|0x9100
operator|)
operator|&&
operator|(
name|tmpReg16
operator|!=
literal|0x9200
operator|)
operator|&&
operator|(
name|tmpReg16
operator|!=
literal|0x8100
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmpReg8
argument_list|,
operator|&
name|p_Template
index|[
literal|14
index|]
argument_list|,
literal|1
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmpReg8
operator|&=
literal|0x1f
expr_stmt|;
name|tmpReg8
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlanParams
operator|.
name|vpri
operator|<<
literal|5
argument_list|)
expr_stmt|;
name|p_Template
index|[
literal|14
index|]
operator|=
name|tmpReg8
expr_stmt|;
block|}
name|Mem2IOCpy32
argument_list|(
name|p_Manip
operator|->
name|p_Template
argument_list|,
name|p_Template
argument_list|,
name|p_InsrtByTemplate
operator|->
name|size
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Template
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
name|tmpRegNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|sizeForFragmentation
operator|<<
literal|16
expr_stmt|;
block|}
else|else
name|tmpReg32
operator|=
literal|0xffff0000
expr_stmt|;
if|if
condition|(
name|ipModify
condition|)
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|<<
literal|8
expr_stmt|;
else|else
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
literal|0x0000ff00
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|pcAndOffsets
operator|=
name|tmpReg32
expr_stmt|;
name|tmpRegNia
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|ccAdBase
operator|=
name|tmpRegNia
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
end_if

begin_function
specifier|static
name|t_Error
name|IPSecManip
parameter_list|(
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|tmpRegNia
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|frag
operator|==
name|TRUE
condition|)
block|{
name|tmpRegNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|sizeForFragmentation
operator|<<
literal|16
expr_stmt|;
block|}
else|else
name|tmpReg32
operator|=
literal|0xffff0000
expr_stmt|;
name|tmpRegNia
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_OC_IPSEC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpRegNia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Total frame counter - MUST be initialized to zero.*/
comment|/*     TODO - Fill the following:          - Over write OuterTos          - SaveInnerTos          - support in CNIA */
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
end_comment

begin_function
specifier|static
name|t_Error
name|CheckStatsParamsAndSetType
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdStatsParams
modifier|*
name|p_StatsParams
parameter_list|)
block|{
switch|switch
condition|(
name|p_StatsParams
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_STATS_PER_FLOWID
operator|)
case|:
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_CAPWAP_INDEXED_STATS
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported statistics type"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Handle
name|ManipOrStatsSetNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
modifier|*
name|p_Params
parameter_list|,
name|bool
name|stats
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|p_Manip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdManip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Manip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdManip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stats
condition|)
block|{
name|err
operator|=
name|CheckManipParamsAndSetType
argument_list|(
name|p_Manip
argument_list|,
operator|(
name|t_FmPcdManipParams
operator|*
operator|)
name|p_Params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|CheckStatsParamsAndSetType
argument_list|(
name|p_Manip
argument_list|,
operator|(
name|t_FmPcdStatsParams
operator|*
operator|)
name|p_Params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"INVALID HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
if|if
condition|(
name|p_Manip
operator|->
name|type
operator|!=
name|HMAN_OC_IP_REASSEMBLY
condition|)
block|{
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
if|if
condition|(
name|p_Manip
operator|->
name|muramAllocate
condition|)
block|{
name|p_Manip
operator|->
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|IOMemSet32
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_Manip
operator|->
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_Malloc
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
block|}
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
name|p_Manip
operator|->
name|h_FmPcd
operator|=
name|h_FmPcd
expr_stmt|;
return|return
name|p_Manip
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipUpdate
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|int
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|,
name|bool
name|modify
parameter_list|)
block|{
name|t_Error
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|modify
condition|)
block|{
name|err
operator|=
name|FmPcdManipInitUpdate
argument_list|(
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|FmPcdManipModifyUpdate
argument_list|(
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdManipGetRequiredAction
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Manip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
return|return
name|UPDATE_NIA_ENQ_WITHOUT_DMA
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|FmPcdManipUpdateOwner
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
if|if
condition|(
name|add
condition|)
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|owner
operator|++
expr_stmt|;
else|else
block|{
name|ASSERT_COND
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|owner
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|owner
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipCheckParamsForCcNextEgine
parameter_list|(
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|,
name|uint32_t
modifier|*
name|requiredAction
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Manip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
operator|)
expr_stmt|;
operator|*
name|requiredAction
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
name|p_Manip
operator|->
name|cnia
operator|=
name|TRUE
expr_stmt|;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
operator|*
name|requiredAction
operator|=
name|UPDATE_NIA_ENQ_WITHOUT_DMA
expr_stmt|;
case|case
operator|(
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
operator|)
case|:
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
operator|)
operator|&&
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_CC
operator|)
operator|&&
operator|(
name|FmPcdCcGetParseCode
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
operator|!=
name|CC_PC_GENERIC_IC_HASH_INDEXED
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateManipIc
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|FmPcdCcGetOffset
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
operator|*
name|requiredAction
operator|=
name|UPDATE_NIA_ENQ_WITHOUT_DMA
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
operator|)
case|case
operator|(
name|HMAN_OC_IPSEC
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_DONE
operator|)
operator|&&
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
name|p_Manip
operator|->
name|cnia
operator|=
name|FALSE
expr_stmt|;
else|else
name|p_Manip
operator|->
name|cnia
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
break|break;
endif|#
directive|endif
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of header manipulation for this state"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipCheckParamsWithCcNodeParams
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdCcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|ownerTmp
operator|!=
name|FmPcdCcGetNumOfKeys
argument_list|(
name|h_FmPcdCcNode
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|ownerTmp
operator|!=
name|FmPcdCcGetNumOfKeys
argument_list|(
name|h_FmPcdCcNode
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateManipIc
argument_list|(
name|h_Manip
argument_list|,
name|FmPcdCcGetOffset
argument_list|(
name|h_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|FmPcdManipUpdateAdResultForCc
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|p_Ad
parameter_list|,
name|t_Handle
modifier|*
name|p_AdNew
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|h_Manip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
operator|)
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
endif|#
directive|endif
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
operator|*
name|p_AdNew
operator|=
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|fqid
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|fqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|plcrProfile
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|plcrProfile
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|nia
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|nia
argument_list|)
expr_stmt|;
operator|*
name|p_AdNew
operator|=
name|NULL
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
operator|)
case|case
operator|(
name|HMAN_OC_IPSEC
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|cnia
condition|)
operator|*
name|p_AdNew
operator|=
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
else|else
block|{
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|fqid
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|fqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|plcrProfile
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|plcrProfile
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|nia
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|nia
argument_list|)
expr_stmt|;
operator|*
name|p_AdNew
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|FmPcdManipUpdateAdContLookupForCc
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|p_Ad
parameter_list|,
name|t_Handle
modifier|*
name|p_AdNew
parameter_list|,
name|uint32_t
name|adTableOffset
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|h_Manip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|ccAdBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|matchTblPtr
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|matchTblPtr
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|gmask
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|gmask
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|)
operator||
name|adTableOffset
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_AdNew
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_ManipSetNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_ManipParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_Manip
operator|=
name|ManipOrStatsSetNode
argument_list|(
name|h_FmPcd
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_ManipParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
operator|)
case|:
comment|/* HmanType1 */
name|err
operator|=
name|RmvHdrTillSpecLocNOrInsrtIntFrmHdr
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|rmvParams
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
comment|/* IpReassembly */
name|err
operator|=
name|IpReassembly
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|fragOrReasmParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
comment|/* IpFragmentation */
name|err
operator|=
name|IpFragmentation
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|ipFragParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|,
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|extBufPoolIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_FRAG_REASSEMBLY
argument_list|)
operator|||
name|defined
argument_list|(
name|UNDER_CONSTRUCTION_IPSEC
argument_list|)
operator|)
case|case
operator|(
name|HMAN_OC_IPSEC
operator|)
case|:
name|err
operator|=
name|IPSecManip
argument_list|(
name|p_ManipParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
comment|/* CapwapFragmentation */
name|err
operator|=
name|CapwapFragmentation
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|capwapFragParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|,
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|extBufPoolIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|insrt
condition|)
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
expr_stmt|;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
comment|/* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
name|err
operator|=
name|InsrtHdrByTempl
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|insrtParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
comment|/*CAPWAP Reassembly*/
name|err
operator|=
name|CapwapReassembly
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|capwapReasmParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|,
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|extBufPoolIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|rmv
condition|)
name|p_Manip
operator|->
name|type
operator|=
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
expr_stmt|;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
comment|/*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
name|err
operator|=
name|CapwapRmvDtlsHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
comment|/*Application Specific type 1*/
name|err
operator|=
name|MvIntFrameHeaderFromFrameToBufferPrefix
argument_list|(
name|p_Manip
argument_list|,
call|(
name|bool
call|)
argument_list|(
name|p_ManipParams
operator|->
name|treatFdStatusFieldsAsErrors
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_Manip
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ManipDeleteNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_ManipNode
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_ManipNode
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|owner
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"This manipulation node not be removed because this node is occupied, first - unbind this node "
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|h_ManipNode
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_StatisticsSetNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdStatsParams
modifier|*
name|p_StatsParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_StatsParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_Manip
operator|=
name|ManipOrStatsSetNode
argument_list|(
name|h_FmPcd
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_StatsParams
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p_Manip
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
comment|/* Indexed statistics */
name|err
operator|=
name|IndxStats
argument_list|(
name|p_StatsParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED Statistics type"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_Manip
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FM_CAPWAP_SUPPORT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_FMAN_P1023 */
end_comment

end_unit

