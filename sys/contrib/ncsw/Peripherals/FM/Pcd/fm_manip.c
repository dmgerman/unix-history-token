begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_manip.c   @Description   FM PCD manip ...  */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_port_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_muram_ext.h"
end_include

begin_include
include|#
directive|include
file|"memcpy_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_manip.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|t_Handle
name|GetManipInfo
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|e_ManipInfo
name|manipInfo
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_CurManip
init|=
name|p_Manip
decl_stmt|;
if|if
condition|(
operator|!
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_Manip
expr_stmt|;
else|else
block|{
comment|/* go to first unified */
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_FIRST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_PrevManip
expr_stmt|;
block|}
switch|switch
condition|(
name|manipInfo
condition|)
block|{
case|case
operator|(
name|e_MANIP_HMCT
operator|)
case|:
return|return
name|p_CurManip
operator|->
name|p_Hmct
return|;
case|case
operator|(
name|e_MANIP_HMTD
operator|)
case|:
return|return
name|p_CurManip
operator|->
name|h_Ad
return|;
case|case
operator|(
name|e_MANIP_HANDLER_TABLE_OWNER
operator|)
case|:
return|return
operator|(
name|t_Handle
operator|)
name|p_CurManip
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|GetHmctSize
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|uint16_t
name|size
init|=
literal|0
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_CurManip
init|=
name|p_Manip
decl_stmt|;
if|if
condition|(
operator|!
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
condition|)
return|return
name|p_Manip
operator|->
name|tableSize
return|;
comment|/* accumulate sizes, starting with the first node */
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_FIRST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_PrevManip
expr_stmt|;
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_LAST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
block|{
name|size
operator|+=
name|p_CurManip
operator|->
name|tableSize
expr_stmt|;
name|p_CurManip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_CurManip
operator|->
name|h_NextManip
expr_stmt|;
block|}
name|size
operator|+=
name|p_CurManip
operator|->
name|tableSize
expr_stmt|;
comment|/* add last size */
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|GetDataSize
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|uint16_t
name|size
init|=
literal|0
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_CurManip
init|=
name|p_Manip
decl_stmt|;
if|if
condition|(
operator|!
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
condition|)
return|return
name|p_Manip
operator|->
name|dataSize
return|;
comment|/* accumulate sizes, starting with the first node */
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_FIRST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_PrevManip
expr_stmt|;
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_LAST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
block|{
name|size
operator|+=
name|p_CurManip
operator|->
name|dataSize
expr_stmt|;
name|p_CurManip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_CurManip
operator|->
name|h_NextManip
expr_stmt|;
block|}
name|size
operator|+=
name|p_CurManip
operator|->
name|dataSize
expr_stmt|;
comment|/* add last size */
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CalculateTableSize
parameter_list|(
name|t_FmPcdManipParams
modifier|*
name|p_FmPcdManipParams
parameter_list|,
name|uint16_t
modifier|*
name|p_TableSize
parameter_list|,
name|uint8_t
modifier|*
name|p_DataSize
parameter_list|)
block|{
name|uint8_t
name|localDataSize
decl_stmt|,
name|remain
decl_stmt|,
name|tableSize
init|=
literal|0
decl_stmt|,
name|dataSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmv
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_GENERIC
operator|)
case|:
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR
operator|)
case|:
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2
operator|)
case|:
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START
operator|)
case|:
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown byHdr.type"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown rmvParams.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_GENERIC
operator|)
case|:
name|remain
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|size
operator|%
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
condition|)
name|localDataSize
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|size
operator|+
literal|4
operator|-
name|remain
argument_list|)
expr_stmt|;
else|else
name|localDataSize
operator|=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|size
expr_stmt|;
name|tableSize
operator|+=
call|(
name|uint8_t
call|)
argument_list|(
name|HMCD_BASIC_SIZE
operator|+
name|localDataSize
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR
operator|)
case|:
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2
operator|)
case|:
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
operator|+
name|HMCD_PTR_SIZE
expr_stmt|;
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2Params
operator|.
name|specificL2
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_INSRT_MPLS
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_INSRT_PPPOE
operator|)
case|:
name|dataSize
operator|+=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2Params
operator|.
name|size
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_IP
operator|)
case|:
name|tableSize
operator|+=
operator|(
name|HMCD_BASIC_SIZE
operator|+
name|HMCD_PTR_SIZE
operator|+
name|HMCD_PARAM_SIZE
operator|+
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|insrt
operator|.
name|size
operator|)
expr_stmt|;
name|dataSize
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_UDP
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE
operator|)
case|:
name|tableSize
operator|+=
operator|(
name|HMCD_BASIC_SIZE
operator|+
name|HMCD_L4_HDR_SIZE
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP
operator|)
case|:
name|tableSize
operator|+=
operator|(
name|HMCD_BASIC_SIZE
operator|+
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown byHdr.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown insrtParams.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdate
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN
operator|)
case|:
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|updateType
operator|==
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN
condition|)
block|{
name|tableSize
operator|+=
name|HMCD_PTR_SIZE
expr_stmt|;
name|dataSize
operator|+=
name|DSCP_TO_VLAN_TABLE_SIZE
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4
operator|)
case|:
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_ID
condition|)
block|{
name|tableSize
operator|+=
name|HMCD_PARAM_SIZE
expr_stmt|;
name|dataSize
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_SRC
condition|)
name|tableSize
operator|+=
name|HMCD_IPV4_ADDR_SIZE
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_DST
condition|)
name|tableSize
operator|+=
name|HMCD_IPV4_ADDR_SIZE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6
operator|)
case|:
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_SRC
condition|)
name|tableSize
operator|+=
name|HMCD_IPV6_ADDR_SIZE
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_DST
condition|)
name|tableSize
operator|+=
name|HMCD_IPV6_ADDR_SIZE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP
operator|)
case|:
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|validUpdates
operator|==
name|HDR_MANIP_TCP_UDP_CHECKSUM
condition|)
comment|/* we implement this case with the update-checksum descriptor */
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
expr_stmt|;
else|else
comment|/* we implement this case with the TCP/UDP-update descriptor */
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
operator|+
name|HMCD_PARAM_SIZE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown fieldUpdateParams.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|custom
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE
operator|)
case|:
block|{
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
operator|+
name|HMCD_PARAM_SIZE
operator|+
name|HMCD_PARAM_SIZE
expr_stmt|;
name|dataSize
operator|+=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|hdrSize
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|replaceType
operator|==
name|e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4
operator|)
operator|&&
operator|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|updateIpv4Id
operator|)
condition|)
name|dataSize
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_CUSTOM_GEN_FIELD_REPLACE
operator|)
case|:
name|tableSize
operator|+=
name|HMCD_BASIC_SIZE
operator|+
name|HMCD_PARAM_SIZE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown customParams.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|p_TableSize
operator|=
name|tableSize
expr_stmt|;
operator|*
name|p_DataSize
operator|=
name|dataSize
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|GetPrOffsetByHeaderOrField
parameter_list|(
name|t_FmManipHdrInfo
modifier|*
name|p_HdrInfo
parameter_list|,
name|uint8_t
modifier|*
name|parseArrayOffset
parameter_list|)
block|{
name|e_NetHeaderType
name|hdr
init|=
name|p_HdrInfo
operator|->
name|hdr
decl_stmt|;
name|e_FmPcdHdrIndex
name|hdrIndex
init|=
name|p_HdrInfo
operator|->
name|hdrIndex
decl_stmt|;
name|bool
name|byField
init|=
name|p_HdrInfo
operator|->
name|byField
decl_stmt|;
name|t_FmPcdFields
name|field
decl_stmt|;
if|if
condition|(
name|byField
condition|)
name|field
operator|=
name|p_HdrInfo
operator|->
name|fullField
expr_stmt|;
if|if
condition|(
name|byField
condition|)
block|{
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_ETYPE_LAST_OFFSET
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of the type Ethernet with this field not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_VLAN1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_VLAN2_OFFSET
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of the type VLAN with this field not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of this header by field not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_ETH_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM1
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_USER_DEFINED_SHIM1_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM2
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_USER_DEFINED_SHIM2_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_USER_LLC_SNAP_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_PPPOE_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MPLS1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MPLS_LAST_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_IP1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_IP_LAST_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MINENC_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_GRE_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_L4_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_CAPWAP_DTLS
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_NEXT_HEADER_OFFSET
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header manipulation of this header is not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildHmct
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_FmPcdManipParams
parameter_list|,
name|uint8_t
modifier|*
name|p_DestHmct
parameter_list|,
name|uint8_t
modifier|*
name|p_DestData
parameter_list|,
name|bool
name|new
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p_TmpHmct
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|p_DestHmct
decl_stmt|,
modifier|*
name|p_LocalData
decl_stmt|;
name|uint32_t
name|tmpReg
init|=
literal|0
decl_stmt|,
modifier|*
name|p_Last
init|=
name|NULL
decl_stmt|,
name|tmp_ipv6_addr
decl_stmt|;
name|uint8_t
name|remain
decl_stmt|,
name|i
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|,
name|origSize
decl_stmt|,
modifier|*
name|p_UsrData
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_TmpData
init|=
name|p_DestData
decl_stmt|;
name|t_Handle
name|h_FmPcd
init|=
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmv
condition|)
block|{
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|type
operator|==
name|e_FM_PCD_MANIP_RMV_GENERIC
condition|)
block|{
comment|/* initialize HMCD */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_GENERIC_RMV
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
comment|/* tmp, should be conditional */
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|generic
operator|.
name|offset
operator|<<
name|HMCD_RMV_OFFSET_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|generic
operator|.
name|size
operator|<<
name|HMCD_RMV_SIZE_SHIFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|type
operator|==
name|e_FM_PCD_MANIP_RMV_BY_HDR
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2
operator|)
case|:
block|{
name|uint8_t
name|hmcdOpt
decl_stmt|;
comment|/* initialize HMCD */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_L2_RMV
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_RMV_ETHERNET
operator|)
case|:
name|hmcdOpt
operator|=
name|HMCD_RMV_L2_ETHERNET
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS
operator|)
case|:
name|hmcdOpt
operator|=
name|HMCD_RMV_L2_STACKED_QTAGS
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS
operator|)
case|:
name|hmcdOpt
operator|=
name|HMCD_RMV_L2_ETHERNET_AND_MPLS
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_RMV_MPLS
operator|)
case|:
name|hmcdOpt
operator|=
name|HMCD_RMV_L2_MPLS
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_RMV_PPPOE
operator|)
case|:
name|hmcdOpt
operator|=
name|HMCD_RMV_L2_PPPOE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator||=
name|hmcdOpt
operator|<<
name|HMCD_L2_MODE_SHIFT
expr_stmt|;
break|break;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP
operator|)
case|:
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_CAPWAP_RMV
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START
operator|)
case|:
block|{
name|uint8_t
name|prsArrayOffset
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_RMV_TILL
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
name|err
operator|=
name|GetPrOffsetByHeaderOrField
argument_list|(
operator|&
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|hdrInfo
argument_list|,
operator|&
name|prsArrayOffset
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
comment|/* was previously checked */
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|prsArrayOffset
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"manip header remove by hdr type!"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
comment|/* advance to next command */
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
condition|)
block|{
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|type
operator|==
name|e_FM_PCD_MANIP_INSRT_GENERIC
condition|)
block|{
comment|/* initialize HMCD */
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|replace
condition|)
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_GENERIC_REPLACE
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
else|else
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_GENERIC_INSRT
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|offset
operator|<<
name|HMCD_INSRT_OFFSET_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|size
operator|<<
name|HMCD_INSRT_SIZE_SHIFT
expr_stmt|;
name|size
operator|=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|size
expr_stmt|;
name|p_UsrData
operator|=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|generic
operator|.
name|p_Data
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
comment|/* initialize data to be inserted */
comment|/* if size is not a multiple of 4, padd with 0's */
name|origSize
operator|=
name|size
expr_stmt|;
name|remain
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|size
operator|%
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
condition|)
block|{
name|size
operator|+=
call|(
name|uint8_t
call|)
argument_list|(
literal|4
operator|-
name|remain
argument_list|)
expr_stmt|;
name|p_LocalData
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_LocalData
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_LocalData
argument_list|,
name|p_UsrData
argument_list|,
name|origSize
argument_list|)
expr_stmt|;
block|}
else|else
name|p_LocalData
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|p_UsrData
expr_stmt|;
comment|/* initialize data and advance pointer to next command */
name|MemCpy8
argument_list|(
name|p_TmpHmct
argument_list|,
name|p_LocalData
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
condition|)
name|XX_Free
argument_list|(
name|p_LocalData
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|type
operator|==
name|e_FM_PCD_MANIP_INSRT_BY_HDR
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2
operator|)
case|:
block|{
name|uint8_t
name|hmcdOpt
decl_stmt|;
comment|/* initialize HMCD */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_L2_INSRT
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2Params
operator|.
name|specificL2
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_INSRT_MPLS
operator|)
case|:
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2Params
operator|.
name|update
condition|)
name|hmcdOpt
operator|=
name|HMCD_INSRT_N_UPDATE_L2_MPLS
expr_stmt|;
else|else
name|hmcdOpt
operator|=
name|HMCD_INSRT_L2_MPLS
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_INSRT_PPPOE
operator|)
case|:
name|hmcdOpt
operator|=
name|HMCD_INSRT_L2_PPPOE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator||=
name|hmcdOpt
operator|<<
name|HMCD_L2_MODE_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
comment|/* set size and pointer of user's data */
name|size
operator|=
operator|(
name|uint8_t
operator|)
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2Params
operator|.
name|size
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_TmpData
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_TmpData
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|specificL2Params
operator|.
name|p_Data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
operator|(
name|size
operator|<<
name|HMCD_INSRT_L2_SIZE_SHIFT
operator|)
operator||
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_TmpData
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
name|p_TmpData
operator|+=
name|size
expr_stmt|;
block|}
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_IP
operator|)
case|:
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_IP_INSRT
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|calcL4Checksum
condition|)
name|tmpReg
operator||=
name|HMCD_IP_L4_CS_CALC
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|mappingMode
operator|==
name|e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS
condition|)
name|tmpReg
operator||=
name|HMCD_IP_OR_QOS
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|lastPidOffset
operator|&
name|HMCD_IP_LAST_PID_MASK
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|insrt
operator|.
name|size
operator|<<
name|HMCD_IP_SIZE_SHIFT
operator|)
operator|&
name|HMCD_IP_SIZE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|dontFragOverwrite
condition|)
name|tmpReg
operator||=
name|HMCD_IP_DF_MODE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
comment|/* set IP id */
name|ASSERT_COND
argument_list|(
name|p_TmpData
argument_list|)
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|p_TmpData
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|id
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_TmpData
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|p_TmpData
operator|+=
literal|2
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
name|WRITE_UINT8
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|lastDstOffset
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PARAM_SIZE
operator|/
literal|4
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_TmpHmct
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|insrt
operator|.
name|p_Data
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|insrt
operator|.
name|size
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|insrt
operator|.
name|size
operator|/
literal|4
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE
operator|)
case|:
name|tmpReg
operator|=
name|HMCD_INSRT_UDP_LITE
expr_stmt|;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_UDP
operator|)
case|:
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_UDP_INSRT
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_TmpHmct
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|p_Data
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
operator|/
literal|4
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP
operator|)
case|:
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_CAPWAP_INSRT
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|HMCD_CAPWAP_INSRT
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_TmpHmct
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|p_Data
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
operator|/
literal|4
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"manip header insert by header type!"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdate
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN
operator|)
case|:
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_VLAN_PRI_UPDATE
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
comment|/* set mode& table pointer */
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|updateType
operator|==
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN
condition|)
block|{
comment|/* set Mode */
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI
argument_list|)
operator|<<
name|HMCD_VLAN_PRI_REP_MODE_SHIFT
expr_stmt|;
comment|/* set VPRI default */
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|u
operator|.
name|dscpToVpri
operator|.
name|vpriDefVal
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
comment|/* write the table pointer into the Manip descriptor */
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_TmpData
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HMCD_DSCP_VALUES
condition|;
name|i
operator|++
control|)
block|{
comment|/* first we build from each 8 values a 32bit register */
name|tmpReg
operator||=
operator|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|u
operator|.
name|dscpToVpri
operator|.
name|dscpToVpriTable
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|32
operator|-
literal|4
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
comment|/* Than we write this register to the next table word                          * (i=7-->word 0, i=15-->word 1,... i=63-->word 7) */
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|7
condition|)
block|{
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|p_TmpData
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
literal|8
operator|-
literal|1
operator|)
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_TmpData
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
name|p_TmpData
operator|+=
name|DSCP_TO_VLAN_TABLE_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|updateType
operator|==
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI
condition|)
block|{
comment|/* set Mode */
comment|/* line commented out as it has no-side-effect ('0' value). */
comment|/*tmpReg |= HMCD_VLAN_PRI_UPDATE<< HMCD_VLAN_PRI_REP_MODE_SHIFT*/
empty_stmt|;
comment|/* set VPRI parameter */
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|u
operator|.
name|vpri
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4
operator|)
case|:
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_IPV4_UPDATE
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_TTL
condition|)
name|tmpReg
operator||=
name|HMCD_IPV4_UPDATE_TTL
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_TOS
condition|)
block|{
name|tmpReg
operator||=
name|HMCD_IPV4_UPDATE_TOS
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|tos
operator|<<
name|HMCD_IPV4_UPDATE_TOS_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_ID
condition|)
name|tmpReg
operator||=
name|HMCD_IPV4_UPDATE_ID
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_SRC
condition|)
name|tmpReg
operator||=
name|HMCD_IPV4_UPDATE_SRC
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_DST
condition|)
name|tmpReg
operator||=
name|HMCD_IPV4_UPDATE_DST
expr_stmt|;
comment|/* write the first 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_ID
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_TmpData
argument_list|)
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|p_TmpData
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|id
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_TmpData
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|p_TmpData
operator|+=
literal|2
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_SRC
condition|)
block|{
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|src
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_IPV4_ADDR_SIZE
operator|/
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV4_DST
condition|)
block|{
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv4
operator|.
name|dst
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_IPV4_ADDR_SIZE
operator|/
literal|4
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6
operator|)
case|:
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_IPV6_UPDATE
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_HL
condition|)
name|tmpReg
operator||=
name|HMCD_IPV6_UPDATE_HL
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_TC
condition|)
block|{
name|tmpReg
operator||=
name|HMCD_IPV6_UPDATE_TC
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|trafficClass
operator|<<
name|HMCD_IPV6_UPDATE_TC_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_SRC
condition|)
name|tmpReg
operator||=
name|HMCD_IPV6_UPDATE_SRC
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_DST
condition|)
name|tmpReg
operator||=
name|HMCD_IPV6_UPDATE_DST
expr_stmt|;
comment|/* write the first 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_SRC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NET_HEADER_FIELD_IPv6_ADDR_SIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmp_ipv6_addr
argument_list|,
operator|&
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|src
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmp_ipv6_addr
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_IPV6_DST
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NET_HEADER_FIELD_IPv6_ADDR_SIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|tmp_ipv6_addr
argument_list|,
operator|&
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|ipv6
operator|.
name|dst
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmp_ipv6_addr
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
block|}
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP
operator|)
case|:
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|validUpdates
operator|==
name|HDR_MANIP_TCP_UDP_CHECKSUM
condition|)
block|{
comment|/* we implement this case with the update-checksum descriptor */
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_TCP_UDP_CHECKSUM
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
comment|/* write the first 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* we implement this case with the TCP/UDP update descriptor */
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_TCP_UDP_UPDATE
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_TCP_UDP_DST
condition|)
name|tmpReg
operator||=
name|HMCD_TCP_UDP_UPDATE_DST
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_TCP_UDP_SRC
condition|)
name|tmpReg
operator||=
name|HMCD_TCP_UDP_UPDATE_SRC
expr_stmt|;
comment|/* write the first 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
name|tmpReg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_TCP_UDP_SRC
condition|)
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|src
operator|)
operator|<<
name|HMCD_TCP_UDP_UPDATE_SRC_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|validUpdates
operator|&
name|HDR_MANIP_TCP_UDP_DST
condition|)
name|tmpReg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|tcpUdp
operator|.
name|dst
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown fieldUpdateParams.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|custom
condition|)
block|{
switch|switch
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE
operator|)
case|:
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_REPLACE_IP
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|decTtlHl
condition|)
name|tmpReg
operator||=
name|HMCD_IP_REPLACE_TTL_HL
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|replaceType
operator|==
name|e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6
condition|)
comment|/* line commented out as it has no-side-effect ('0' value). */
comment|/*tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV4*/
empty_stmt|;
elseif|else
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|replaceType
operator|==
name|e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4
condition|)
block|{
name|tmpReg
operator||=
name|HMCD_IP_REPLACE_REPLACE_IPV6
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|updateIpv4Id
condition|)
name|tmpReg
operator||=
name|HMCD_IP_REPLACE_ID
expr_stmt|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."
operator|)
argument_list|)
expr_stmt|;
comment|/* write the first 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
name|size
operator|=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|hdrSize
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_TmpData
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_TmpData
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|hdr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|<<
name|HMCD_IP_REPLACE_L3HDRSIZE_SHIFT
argument_list|)
expr_stmt|;
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_TmpData
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
name|p_TmpData
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|replaceType
operator|==
name|e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4
operator|)
operator|&&
operator|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|updateIpv4Id
operator|)
condition|)
block|{
name|WRITE_UINT16
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|p_TmpData
argument_list|,
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|ipHdrReplace
operator|.
name|id
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_TmpData
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|p_TmpData
operator|+=
literal|2
expr_stmt|;
block|}
name|p_TmpHmct
operator|+=
name|HMCD_PTR_SIZE
operator|/
literal|4
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_HDR_CUSTOM_GEN_FIELD_REPLACE
operator|)
case|:
comment|/* set opcode */
name|tmpReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|HMCD_OPCODE_GEN_FIELD_REPLACE
argument_list|)
operator|<<
name|HMCD_OC_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|size
operator|<<
name|HMCD_GEN_FIELD_SIZE_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|srcOffset
operator|<<
name|HMCD_GEN_FIELD_SRC_OFF_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|dstOffset
operator|<<
name|HMCD_GEN_FIELD_DST_OFF_SHIFT
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|mask
condition|)
name|tmpReg
operator||=
name|HMCD_GEN_FIELD_MASK_EN
expr_stmt|;
comment|/* write the first 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
comment|/* save a pointer to the "last" indication word */
name|p_Last
operator|=
name|p_TmpHmct
expr_stmt|;
name|p_TmpHmct
operator|+=
name|HMCD_BASIC_SIZE
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|mask
condition|)
block|{
name|tmpReg
operator|=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|mask
operator|<<
name|HMCD_GEN_FIELD_MASK_SHIFT
expr_stmt|;
name|tmpReg
operator||=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|maskOffset
operator|<<
name|HMCD_GEN_FIELD_MASK_OFF_SHIFT
expr_stmt|;
comment|/* write the next 4 bytes of the descriptor */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_TmpHmct
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
block|}
name|p_TmpHmct
operator|+=
name|HMCD_PARAM_SIZE
operator|/
literal|4
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"Unknown customParams.type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this node has a nextManip, and no parsing is required, the old table must be copied to the new table      the old table and should be freed */
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|&&
operator|(
name|p_Manip
operator|->
name|nextManipType
operator|==
name|e_FM_PCD_MANIP_HDR
operator|)
operator|&&
operator|(
name|MANIP_DONT_REPARSE
argument_list|(
name|p_Manip
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|new
condition|)
block|{
comment|/* If this is the first time this manip is created we need to free unused memory. If it              * is a dynamic changes case, the memory used is either the CC shadow or the existing              * table - no allocation, no free */
name|MANIP_UPDATE_UNIFIED_POSITION
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|unifiedPosition
operator|=
name|e_MANIP_UNIFIED_FIRST
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT_COND
argument_list|(
name|p_Last
argument_list|)
expr_stmt|;
comment|/* set the "last" indication on the last command of the current table */
name|WRITE_UINT32
argument_list|(
operator|*
name|p_Last
argument_list|,
name|GET_UINT32
argument_list|(
operator|*
name|p_Last
argument_list|)
operator||
name|HMCD_LAST
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateManipActionNew
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_FmPcdManipParams
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_CurManip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|nextSize
init|=
literal|0
decl_stmt|,
name|totalSize
decl_stmt|;
name|uint16_t
name|tmpReg
decl_stmt|;
name|uint8_t
modifier|*
name|p_OldHmct
decl_stmt|,
modifier|*
name|p_TmpHmctPtr
decl_stmt|,
modifier|*
name|p_TmpDataPtr
decl_stmt|;
comment|/* set Manip structure */
name|p_Manip
operator|->
name|dontParseAfterManip
operator|=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|dontParseAfterManip
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
condition|)
block|{
comment|/* Next Header manipulation exists */
name|p_Manip
operator|->
name|nextManipType
operator|=
name|MANIP_GET_TYPE
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|nextManipType
operator|==
name|e_FM_PCD_MANIP_HDR
operator|)
operator|&&
name|p_Manip
operator|->
name|dontParseAfterManip
condition|)
name|nextSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|GetHmctSize
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
operator|+
name|GetDataSize
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* either parsing is required or next manip is Frag; no table merging. */
name|p_Manip
operator|->
name|cascaded
operator|=
name|TRUE
expr_stmt|;
comment|/* pass up the "cascaded" attribute. The whole chain is cascaded          * if something is cascaded along the way. */
if|if
condition|(
name|MANIP_IS_CASCADED
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
condition|)
name|p_Manip
operator|->
name|cascaded
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Allocate new table */
comment|/* calculate table size according to manip parameters */
name|err
operator|=
name|CalculateTableSize
argument_list|(
name|p_FmPcdManipParams
argument_list|,
operator|&
name|p_Manip
operator|->
name|tableSize
argument_list|,
operator|&
name|p_Manip
operator|->
name|dataSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|totalSize
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_Manip
operator|->
name|tableSize
operator|+
name|p_Manip
operator|->
name|dataSize
operator|+
name|nextSize
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|p_Hmct
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|h_FmMuram
argument_list|,
name|totalSize
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_Hmct
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc failed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|dataSize
condition|)
name|p_Manip
operator|->
name|p_Data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|p_Hmct
argument_list|,
operator|(
name|p_Manip
operator|->
name|tableSize
operator|+
name|nextSize
operator|)
argument_list|)
expr_stmt|;
comment|/* update shadow size to allow runtime replacement of Header manipulation */
comment|/* The allocated shadow is divided as follows:      0 . . .       16 . . .      --------------------------------      |   Shadow   |   Shadow HMTD   |      |   HMTD     |   Match Table   |      | (16 bytes) | (maximal size)  |      --------------------------------      */
name|err
operator|=
name|FmPcdUpdateCcShadow
argument_list|(
name|p_Manip
operator|->
name|h_FmPcd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|totalSize
operator|+
literal|16
argument_list|)
argument_list|,
operator|(
name|uint16_t
operator|)
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_Manip
operator|->
name|h_FmPcd
argument_list|,
name|p_Manip
operator|->
name|p_Hmct
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for HdrManip node shadow"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|&&
operator|(
name|p_Manip
operator|->
name|nextManipType
operator|==
name|e_FM_PCD_MANIP_HDR
operator|)
operator|&&
operator|(
name|MANIP_DONT_REPARSE
argument_list|(
name|p_Manip
argument_list|)
operator|)
condition|)
block|{
name|p_OldHmct
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|,
name|e_MANIP_HMCT
argument_list|)
expr_stmt|;
name|p_CurManip
operator|=
name|p_FmPcdManipParams
operator|->
name|h_NextManip
expr_stmt|;
comment|/* Run till the last Manip (which is the first to configure) */
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_LAST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_NextManip
expr_stmt|;
while|while
condition|(
name|p_CurManip
condition|)
block|{
comment|/* If this is a unified table, point to the part of the table              * which is the relative offset in HMCT.              */
name|p_TmpHmctPtr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|p_Hmct
argument_list|,
operator|(
name|p_Manip
operator|->
name|tableSize
operator|+
operator|(
name|PTR_TO_UINT
argument_list|(
name|p_CurManip
operator|->
name|p_Hmct
argument_list|)
operator|-
name|PTR_TO_UINT
argument_list|(
name|p_OldHmct
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CurManip
operator|->
name|p_Data
condition|)
name|p_TmpDataPtr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|p_Hmct
argument_list|,
operator|(
name|p_Manip
operator|->
name|tableSize
operator|+
operator|(
name|PTR_TO_UINT
argument_list|(
name|p_CurManip
operator|->
name|p_Data
argument_list|)
operator|-
name|PTR_TO_UINT
argument_list|(
name|p_OldHmct
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|p_TmpDataPtr
operator|=
name|NULL
expr_stmt|;
name|BuildHmct
argument_list|(
name|p_CurManip
argument_list|,
operator|&
name|p_CurManip
operator|->
name|manipParams
argument_list|,
name|p_TmpHmctPtr
argument_list|,
name|p_TmpDataPtr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* update old manip table pointer */
name|MANIP_SET_HMCT_PTR
argument_list|(
name|p_CurManip
argument_list|,
name|p_TmpHmctPtr
argument_list|)
expr_stmt|;
name|MANIP_SET_DATA_PTR
argument_list|(
name|p_CurManip
argument_list|,
name|p_TmpDataPtr
argument_list|)
expr_stmt|;
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_PrevManip
expr_stmt|;
block|}
comment|/* We copied the HMCT to create a new large HMCT so we can free the old one */
name|FM_MURAM_FreeMem
argument_list|(
name|MANIP_GET_MURAM
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
argument_list|,
name|p_OldHmct
argument_list|)
expr_stmt|;
block|}
comment|/* Fill table */
name|err
operator|=
name|BuildHmct
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcdManipParams
argument_list|,
name|p_Manip
operator|->
name|p_Hmct
argument_list|,
name|p_Manip
operator|->
name|p_Data
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_Manip
operator|->
name|h_FmPcd
argument_list|,
name|p_Manip
operator|->
name|p_Hmct
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* Build HMTD (table descriptor) */
name|tmpReg
operator|=
name|HMTD_CFG_TYPE
expr_stmt|;
comment|/* NADEN = 0 */
comment|/* add parseAfterManip */
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|dontParseAfterManip
condition|)
name|tmpReg
operator||=
name|HMTD_CFG_PRS_AFTER_HM
expr_stmt|;
comment|/* create cascade */
comment|/*if (p_FmPcdManipParams->h_NextManip&& (!MANIP_DONT_REPARSE(p_Manip) || (p_Manip->nextManipType != e_FM_PCD_MANIP_HDR)))*/
if|if
condition|(
name|p_Manip
operator|->
name|cascaded
condition|)
block|{
name|uint16_t
name|nextAd
decl_stmt|;
comment|/* indicate that there's another HM table descriptor */
name|tmpReg
operator||=
name|HMTD_CFG_NEXT_AD_EN
expr_stmt|;
comment|/* get address of next HMTD (table descriptor; h_Ad).          * If the next HMTD was removed due to table unifing, get the address          * of the "next next" as written in the h_Ad of the next h_Manip node.          */
if|if
condition|(
name|p_Manip
operator|->
name|unifiedPosition
operator|!=
name|e_MANIP_UNIFIED_FIRST
condition|)
name|nextAd
operator|=
call|(
name|uint16_t
call|)
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|MANIP_GET_HMTD_PTR
argument_list|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
argument_list|)
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
else|else
name|nextAd
operator|=
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_Ad
operator|)
operator|->
name|nextAdIdx
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|->
name|nextAdIdx
argument_list|,
name|nextAd
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT16
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|->
name|cfg
argument_list|,
name|tmpReg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|->
name|hmcdBasePtr
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|p_Hmct
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT8
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|->
name|opCode
argument_list|,
name|HMAN_OC
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|unifiedPosition
operator|==
name|e_MANIP_UNIFIED_FIRST
condition|)
block|{
comment|/* The HMTD of the next Manip is never going to be used */
if|if
condition|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|muramAllocate
condition|)
name|FM_MURAM_FreeMem
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_FmPcd
operator|)
operator|->
name|h_FmMuram
argument_list|,
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
else|else
name|XX_Free
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_FmPcdManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_Ad
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateManipActionShadow
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_FmPcdManipParams
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p_WholeHmct
decl_stmt|,
modifier|*
name|p_TmpHmctPtr
decl_stmt|,
name|newDataSize
decl_stmt|,
modifier|*
name|p_TmpDataPtr
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|newSize
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_CurManip
init|=
name|p_Manip
decl_stmt|;
name|err
operator|=
name|CalculateTableSize
argument_list|(
name|p_FmPcdManipParams
argument_list|,
operator|&
name|newSize
argument_list|,
operator|&
name|newDataSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* check coherency of new table parameters */
if|if
condition|(
name|newSize
operator|>
name|p_Manip
operator|->
name|tableSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"New Hdr Manip configuration requires larger size than current one (command table)."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newDataSize
operator|>
name|p_Manip
operator|->
name|dataSize
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"New Hdr Manip configuration requires larger size than current one (data)."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdManipParams
operator|->
name|h_NextManip
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"New Hdr Manip configuration can not contain h_NextManip."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
operator|&&
operator|(
name|newSize
operator|!=
name|p_Manip
operator|->
name|tableSize
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"New Hdr Manip configuration in a chained manipulation requires different size than current one."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|dontParseAfterManip
operator|!=
name|p_FmPcdManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|dontParseAfterManip
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"New Hdr Manip configuration differs in dontParseAfterManip value."
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|tableSize
operator|=
name|newSize
expr_stmt|;
name|p_Manip
operator|->
name|dataSize
operator|=
name|newDataSize
expr_stmt|;
comment|/* Build the new table in the shadow */
if|if
condition|(
operator|!
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
condition|)
block|{
name|p_TmpHmctPtr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|p_Data
condition|)
name|p_TmpDataPtr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_TmpHmctPtr
argument_list|,
operator|(
name|PTR_TO_UINT
argument_list|(
name|p_Manip
operator|->
name|p_Data
argument_list|)
operator|-
name|PTR_TO_UINT
argument_list|(
name|p_Manip
operator|->
name|p_Hmct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|BuildHmct
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcdManipParams
argument_list|,
name|p_TmpHmctPtr
argument_list|,
name|p_Manip
operator|->
name|p_Data
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_WholeHmct
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_Manip
argument_list|,
name|e_MANIP_HMCT
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_WholeHmct
argument_list|)
expr_stmt|;
comment|/* Run till the last Manip (which is the first to configure) */
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_LAST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_NextManip
expr_stmt|;
while|while
condition|(
name|p_CurManip
condition|)
block|{
comment|/* If this is a non-head node in a unified table, point to the part of the shadow              * which is the relative offset in HMCT.              * else, point to the beginning of the              * shadow table (we save 16 for the HMTD.              */
name|p_TmpHmctPtr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
operator|(
literal|16
operator|+
name|PTR_TO_UINT
argument_list|(
name|p_CurManip
operator|->
name|p_Hmct
argument_list|)
operator|-
name|PTR_TO_UINT
argument_list|(
name|p_WholeHmct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CurManip
operator|->
name|p_Data
condition|)
name|p_TmpDataPtr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
operator|(
literal|16
operator|+
name|PTR_TO_UINT
argument_list|(
name|p_CurManip
operator|->
name|p_Data
argument_list|)
operator|-
name|PTR_TO_UINT
argument_list|(
name|p_WholeHmct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|BuildHmct
argument_list|(
name|p_CurManip
argument_list|,
operator|&
name|p_CurManip
operator|->
name|manipParams
argument_list|,
name|p_TmpHmctPtr
argument_list|,
name|p_TmpDataPtr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_PrevManip
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateManipActionBackToOrig
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_FmPcdManipParams
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p_WholeHmct
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_TmpHmctPtr
decl_stmt|,
modifier|*
name|p_TmpDataPtr
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_CurManip
init|=
name|p_Manip
decl_stmt|;
comment|/* Build the new table in the shadow */
if|if
condition|(
operator|!
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
condition|)
name|BuildHmct
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcdManipParams
argument_list|,
name|p_Manip
operator|->
name|p_Hmct
argument_list|,
name|p_Manip
operator|->
name|p_Data
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|p_WholeHmct
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_Manip
argument_list|,
name|e_MANIP_HMCT
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_WholeHmct
argument_list|)
expr_stmt|;
comment|/* Run till the last Manip (which is the first to configure) */
while|while
condition|(
name|MANIP_IS_UNIFIED_NON_LAST
argument_list|(
name|p_CurManip
argument_list|)
condition|)
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_NextManip
expr_stmt|;
while|while
condition|(
name|p_CurManip
condition|)
block|{
comment|/* If this is a unified table, point to the part of the table              * which is the relative offset in HMCT.              */
name|p_TmpHmctPtr
operator|=
name|p_CurManip
operator|->
name|p_Hmct
expr_stmt|;
comment|/*- (uint32_t)p_WholeHmct*/
name|p_TmpDataPtr
operator|=
name|p_CurManip
operator|->
name|p_Data
expr_stmt|;
comment|/*- (uint32_t)p_WholeHmct*/
name|BuildHmct
argument_list|(
name|p_CurManip
argument_list|,
operator|&
name|p_CurManip
operator|->
name|manipParams
argument_list|,
name|p_TmpHmctPtr
argument_list|,
name|p_TmpDataPtr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p_CurManip
operator|=
name|p_CurManip
operator|->
name|h_PrevManip
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
end_if

begin_function
specifier|static
name|t_Error
name|UpdateManipIc
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|uint8_t
name|icOffset
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Handle
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|INTERNAL_CONTEXT_OFFSET
condition|)
block|{
name|tmpReg32
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|icOffset
operator|<<
literal|16
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
operator|=
name|tmpReg32
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|p_Manip
operator|->
name|icOffset
operator|=
name|icOffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|icOffset
operator|!=
name|icOffset
condition|)
name|RETURN_ERROR
argument_list|(
argument|MAJOR
argument_list|,
argument|E_INVALID_VALUE
argument_list|,
argument|(
literal|"this manipulation was updated previously by different value"
argument|);
argument_list|)
empty_stmt|;
block|}
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|INTERNAL_CONTEXT_OFFSET
condition|)
block|{
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator||=
name|GET_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|icOffset
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|p_Manip
operator|->
name|icOffset
operator|=
name|icOffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|icOffset
operator|!=
name|icOffset
condition|)
name|RETURN_ERROR
argument_list|(
argument|MAJOR
argument_list|,
argument|E_INVALID_VALUE
argument_list|,
argument|(
literal|"this manipulation was updated previousely by different value"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|&
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|muramAllocate
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_PSO
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|psoSize
operator|=
literal|16
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Parser result offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
name|ASSERT_COND
argument_list|(
operator|!
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
operator|%
literal|16
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_PSO
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|psoSize
operator|=
literal|16
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Parser result offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|p_Ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
condition|)
block|{
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|)
operator||
name|tmpReg32
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_PR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uint8_t
operator|)
name|tmpReg32
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
condition|)
name|RETURN_ERROR
argument_list|(
argument|MAJOR
argument_list|,
argument|E_INVALID_STATE
argument_list|,
argument|(
literal|"this manipulation was updated previousely by different value"
argument|);
argument_list|)
empty_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateModifyCapwapFragmenation
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_FmPcdCcSavedManipParams
modifier|*
name|p_SavedManipParams
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|p_SavedManipParams
operator|=
name|FmPcdCcTreeGetSavedManipParams
argument_list|(
name|h_FmTree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SavedManipParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"for this manipulation tree has to be configured previosely with this type"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
operator|=
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
operator|<<
literal|16
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
name|p_SavedManipParams
operator|=
name|FmPcdCcTreeGetSavedManipParams
argument_list|(
name|h_FmTree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SavedManipParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"for this manipulation tree has to be configured previosely with this type"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
operator|!=
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"this manipulation was updated previousely by different value"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitCapwapFragmentation
parameter_list|(
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcSavedManipParams
modifier|*
name|p_SavedManipParams
decl_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
operator||
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
comment|/* For CAPWAP Rassembly used FMAN_CTRL2 hardcoded - so for fragmentation its better to use FMAN_CTRL1 */
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|orFmanCtrl
operator|=
name|FPM_PORT_FM_CTL1
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Data offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
name|p_SavedManipParams
operator|=
operator|(
name|t_FmPcdCcSavedManipParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcSavedManipParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
name|ASSERT_COND
argument_list|(
operator|!
operator|(
name|p_SavedManipParams
operator|->
name|capwapParams
operator|.
name|dataOffset
operator|%
literal|16
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
name|FmPcdCcTreeSetSavedManipParams
argument_list|(
name|h_FmTree
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_SavedManipParams
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
operator||
name|UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Data offset wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|<<
literal|16
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"this manipulation was updated previousely by different value"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitCapwapReasm
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_CapwapReasmPram
modifier|*
name|p_ReassmTbl
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|uint16_t
name|size
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcCapwapReassmTimeoutParams
name|ccCapwapReassmTimeoutParams
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"handler of PCD previously was initiated by different value"
operator|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_ReassmTbl
operator|=
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Num of tasks wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data  wasn't configured previousely"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hwPortId wasn't updated"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
name|ASSERT_COND
argument_list|(
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|%
literal|16
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_PR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|HW_PORT_ID
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|shadowUpdateParams
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNEN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_POP_TO_N_STEP
operator||
name|NIA_ENG_FM_CTL
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|NUM_OF_TASKS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"NumOfTasks wasn't configured previously"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_DATA
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data  wasn't configured previously"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|HW_PORT_ID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hwPortId wasn't updated"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|NUM_OF_TASKS
condition|)
block|{
comment|/*recommendation of Microcode team - (maxNumFramesInProcess * 2) */
name|size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|maxNumFramesInProcess
operator|*
literal|2
operator|+
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|255
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|numOfTasks
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
expr_stmt|;
comment|/*p_ReassmFrmDescrIndxPoolTbl*/
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|+
literal|1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for CAPWAP Reassembly frame buffer index pool table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|WRITE_UINT8
argument_list|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|,
name|i
argument_list|)
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|reasmFrmDescIndexPoolTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/*p_ReassmFrmDescrPoolTbl*/
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for CAPWAP Reassembly frame buffer pool table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|reasmFrmDescPoolTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/*p_TimeOutTbl*/
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_TimeOutTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_TimeOutTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for CAPWAP Reassembly timeout table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_TimeOutTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_TimeOutTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|timeOutTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|NUM_OF_TASKS
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|NUM_OF_TASKS
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
name|OFFSET_OF_DATA
condition|)
block|{
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_DATA
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
block|{
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|prOffset
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_PR_COPY
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|intStatsTblPtr
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|prOffset
operator|<<
literal|24
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ReassmTbl
operator|->
name|intStatsTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_PR
expr_stmt|;
block|}
else|else
block|{
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|prOffset
operator|=
literal|0xff
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|OFFSET_OF_PR
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|OFFSET_OF_PR
expr_stmt|;
block|}
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|hwPortId
operator|=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|hardwarePortId
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
name|HW_PORT_ID
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
name|HW_PORT_ID
expr_stmt|;
comment|/*timeout hc */
name|ccCapwapReassmTimeoutParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|ccCapwapReassmTimeoutParams
operator|.
name|portIdAndCapwapReassmTbl
operator|=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|hwPortId
operator|<<
literal|24
expr_stmt|;
name|ccCapwapReassmTimeoutParams
operator|.
name|portIdAndCapwapReassmTbl
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_ReassmTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|ccCapwapReassmTimeoutParams
operator|.
name|timeoutRequestTime
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|bitFor1Micro
operator|)
operator|*
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|timeoutRoutineRequestTime
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|FmHcPcdCcCapwapTimeoutReassm
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
operator|&
name|ccCapwapReassmTimeoutParams
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|validate
condition|)
block|{
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|hardwarePortId
operator|!=
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|hwPortId
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Reassembly manipulation previously was assigned to another port"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
operator|!=
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|numOfTasks
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfTasks for this manipulation previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|prOffset
operator|!=
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|prOffset
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Parse result offset previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|prOffset
operator|!=
literal|0xff
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Parse result offset previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|dataOffset
operator|!=
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|dataOffset
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Data offset previously was defined by another value "
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
end_comment

begin_function
name|t_Error
name|FmPcdRegisterReassmPort
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_ReasmCommonPramTbl
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcReassmTimeoutParams
name|ccReassmTimeoutParams
init|=
block|{
literal|0
block|}
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|result
decl_stmt|;
name|uint32_t
name|bitFor1Micro
decl_stmt|,
name|tsbs
decl_stmt|,
name|log2num
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_ReasmCommonPramTbl
argument_list|)
expr_stmt|;
name|bitFor1Micro
operator|=
name|FmGetTimeStampScale
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitFor1Micro
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"Timestamp scale"
operator|)
argument_list|)
expr_stmt|;
name|bitFor1Micro
operator|=
literal|32
operator|-
name|bitFor1Micro
expr_stmt|;
name|LOG2
argument_list|(
name|FM_PCD_MANIP_REASM_TIMEOUT_THREAD_THRESH
argument_list|,
name|log2num
argument_list|)
expr_stmt|;
name|tsbs
operator|=
name|bitFor1Micro
operator|-
name|log2num
expr_stmt|;
name|ccReassmTimeoutParams
operator|.
name|iprcpt
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|h_ReasmCommonPramTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|ccReassmTimeoutParams
operator|.
name|tsbs
operator|=
operator|(
name|uint8_t
operator|)
name|tsbs
expr_stmt|;
name|ccReassmTimeoutParams
operator|.
name|activate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmHcPcdCcTimeoutReassm
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
operator|&
name|ccReassmTimeoutParams
argument_list|,
operator|&
name|result
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
return|return
name|E_OK
return|;
case|case
operator|(
literal|1
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"failed to allocate TNUM"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
literal|2
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"failed to allocate internal buffer from the HC-Port"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
literal|3
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"'Disable Timeout Task' with invalid IPRCPT"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
literal|4
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"too many timeout tasks"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
literal|5
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"invalid sub command"
operator|)
argument_list|)
expr_stmt|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateReassCommonTable
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|bitFor1Micro
decl_stmt|;
name|uint64_t
name|tmpReg64
decl_stmt|,
name|size
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|bitFor1Micro
operator|=
name|FmGetTimeStampScale
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitFor1Micro
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"Timestamp scale"
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocation of the Reassembly Common Parameters table. This table is located in the      MURAM. Its size is 64 bytes and its base address should be 8-byte aligned. */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|=
operator|(
name|t_ReassCommonTbl
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE
argument_list|,
name|FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Reassembly common parameters table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Setting the TimeOut Mode.*/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutMode
operator|==
name|e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_REASM_TIME_OUT_BETWEEN_FRAMES
expr_stmt|;
comment|/* Setting TimeOut FQID - Frames that time out are enqueued to this FQID.      In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
name|tmpReg32
operator||=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|timeoutModeAndFqid
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 129.*/
name|size
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|maxNumFramesInProcess
operator|+
literal|129
expr_stmt|;
comment|/*Allocation of IP Reassembly Frame Descriptor Indexes Pool - This pool resides in the MURAM */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|2
argument_list|)
argument_list|,
literal|256
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Reassembly frame descriptor indexes pool"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The entries in IP Reassembly Frame Descriptor Indexes Pool contains indexes starting with 1 up to      the maximum number of frames that are allowed to be reassembled simultaneously + 128.      The last entry in this pool must contain the index zero*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|WRITE_UINT16
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
argument_list|)
argument_list|,
operator|(
name|i
operator|<<
literal|1
operator|)
argument_list|)
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sets the IP Reassembly Frame Descriptor Indexes Pool offset from MURAM */
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|reassFrmDescIndexPoolTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Allocation of the Reassembly Frame Descriptors Pool - This pool resides in external memory.      The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrPoolTblAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|XX_MallocSmart
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|64
argument_list|)
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrPoolTblAddr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrPoolTblAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|64
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
name|tmpReg64
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrPoolTblAddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|&
name|FM_PCD_MANIP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_REASM_LIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|&
name|FM_PCD_MANIP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_REASM_ELIODN_SHIFT
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|liodnAndReassFrmDescPoolPtrHi
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpReg64
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|reassFrmDescPoolPtrLow
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpReg64
argument_list|)
expr_stmt|;
comment|/*Allocation of the TimeOut table - This table resides in the MURAM.      The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutTblAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutTblAddr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Reassembly timeout table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutTblAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|size
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sets the TimeOut table offset from MURAM */
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutTblAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|timeOutTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Sets the Expiration Delay */
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
call|(
name|uint32_t
call|)
argument_list|(
literal|1
operator|<<
name|bitFor1Micro
argument_list|)
operator|)
operator|*
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeoutThresholdForReassmProcess
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|expirationDelay
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdRegisterReassmPort
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"port registration"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CreateReassTable
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|,
name|autoLearnHashTblSize
decl_stmt|;
name|uint32_t
name|numOfWays
decl_stmt|,
name|setSize
decl_stmt|,
name|setSizeCode
decl_stmt|,
name|keySize
decl_stmt|;
name|uint32_t
name|waySize
decl_stmt|,
name|numOfSets
decl_stmt|,
name|numOfEntries
decl_stmt|;
name|uint64_t
name|tmpReg64
decl_stmt|;
name|uint16_t
name|minFragSize
decl_stmt|;
name|uint16_t
name|maxReassemSize
decl_stmt|;
name|uintptr_t
modifier|*
name|p_AutoLearnHashTblAddr
decl_stmt|,
modifier|*
name|p_AutoLearnSetLockTblAddr
decl_stmt|;
name|t_ReassTbl
modifier|*
modifier|*
name|p_ReassTbl
decl_stmt|;
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
name|HEADER_TYPE_IPv4
case|:
name|p_ReassTbl
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
expr_stmt|;
name|p_AutoLearnHashTblAddr
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv4AutoLearnHashTblAddr
expr_stmt|;
name|p_AutoLearnSetLockTblAddr
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv4AutoLearnSetLockTblAddr
expr_stmt|;
name|minFragSize
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|minFragSize
index|[
literal|0
index|]
expr_stmt|;
name|maxReassemSize
operator|=
literal|0
expr_stmt|;
name|numOfWays
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|numOfFramesPerHashEntry
index|[
literal|0
index|]
expr_stmt|;
name|keySize
operator|=
literal|4
operator|+
literal|4
operator|+
literal|1
operator|+
literal|2
expr_stmt|;
comment|/* 3-tuple + IP-Id */
break|break;
case|case
name|HEADER_TYPE_IPv6
case|:
name|p_ReassTbl
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
expr_stmt|;
name|p_AutoLearnHashTblAddr
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6AutoLearnHashTblAddr
expr_stmt|;
name|p_AutoLearnSetLockTblAddr
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6AutoLearnSetLockTblAddr
expr_stmt|;
name|minFragSize
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|minFragSize
index|[
literal|1
index|]
expr_stmt|;
name|maxReassemSize
operator|=
literal|0
expr_stmt|;
name|numOfWays
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|numOfFramesPerHashEntry
index|[
literal|1
index|]
expr_stmt|;
name|keySize
operator|=
literal|16
operator|+
literal|16
operator|+
literal|4
expr_stmt|;
comment|/* 2-tuple + IP-Id */
if|if
condition|(
name|numOfWays
operator|>
name|e_FM_PCD_MANIP_SIX_WAYS_HASH
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"num of ways"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEADER_TYPE_CAPWAP
case|:
name|p_ReassTbl
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
expr_stmt|;
name|p_AutoLearnHashTblAddr
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|autoLearnHashTblAddr
expr_stmt|;
name|p_AutoLearnSetLockTblAddr
operator|=
operator|&
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|autoLearnSetLockTblAddr
expr_stmt|;
name|minFragSize
operator|=
literal|0
expr_stmt|;
name|maxReassemSize
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|maxRessembledsSize
expr_stmt|;
name|numOfWays
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|numOfFramesPerHashEntry
expr_stmt|;
name|keySize
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"header type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|keySize
operator|+=
literal|2
expr_stmt|;
comment|/* 2 bytes reserved for RFDIndex */
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|keySize
operator|+=
literal|2
expr_stmt|;
comment|/* 2 bytes reserved */
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|waySize
operator|=
name|ROUND_UP
argument_list|(
name|keySize
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Allocates the Reassembly Parameters Table - This table is located in the MURAM.*/
operator|*
name|p_ReassTbl
operator|=
operator|(
name|t_ReassTbl
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_MANIP_REASM_TABLE_SIZE
argument_list|,
name|FM_PCD_MANIP_REASM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p_ReassTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Reassembly specific parameters table"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|p_ReassTbl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_ReassTbl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sets the Reassembly common Parameters table offset from MURAM in the Reassembly Table descriptor*/
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|reassCommonPrmTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Calculate set size (set size is rounded-up to next power of 2) */
name|NEXT_POWER_OF_2
argument_list|(
name|numOfWays
operator|*
name|waySize
argument_list|,
name|setSize
argument_list|)
expr_stmt|;
comment|/* Get set size code */
name|LOG2
argument_list|(
name|setSize
argument_list|,
name|setSizeCode
argument_list|)
expr_stmt|;
comment|/* Sets ways number and set size code */
name|WRITE_UINT16
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|waysNumAndSetSize
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|numOfWays
operator|<<
literal|8
operator|)
operator||
name|setSizeCode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It is recommended that the total number of entries in this table      (number of sets * number of ways) will be twice the number of frames that      are expected to be reassembled simultaneously.*/
name|numOfEntries
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|maxNumFramesInProcess
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* sets number calculation - number of entries = number of sets * number of ways */
name|numOfSets
operator|=
name|numOfEntries
operator|/
name|numOfWays
expr_stmt|;
comment|/* Sets AutoLearnHashKeyMask*/
name|NEXT_POWER_OF_2
argument_list|(
name|numOfSets
argument_list|,
name|numOfSets
argument_list|)
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|autoLearnHashKeyMask
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|numOfSets
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocation of Reassembly Automatic Learning Hash Table - This table resides in external memory.      The size of this table is determined by the number of sets and the set size.      Table size = set size * number of sets      This table base address should be aligned to SetSize.*/
name|autoLearnHashTblSize
operator|=
name|numOfSets
operator|*
name|setSize
expr_stmt|;
operator|*
name|p_AutoLearnHashTblAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|XX_MallocSmart
argument_list|(
name|autoLearnHashTblSize
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
argument_list|,
name|setSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p_AutoLearnHashTblAddr
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
operator|*
name|p_ReassTbl
argument_list|)
expr_stmt|;
operator|*
name|p_ReassTbl
operator|=
name|NULL
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
operator|*
name|p_AutoLearnHashTblAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|autoLearnHashTblSize
argument_list|)
expr_stmt|;
comment|/* Sets the Reassembly Automatic Learning Hash Table and liodn offset */
name|tmpReg64
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|&
name|FM_PCD_MANIP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_REASM_LIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|&
name|FM_PCD_MANIP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_REASM_ELIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
operator|*
name|p_AutoLearnHashTblAddr
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|liodnAlAndAutoLearnHashTblPtrHi
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpReg64
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|autoLearnHashTblPtrLow
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpReg64
argument_list|)
expr_stmt|;
comment|/* Allocation of the Set Lock table - This table resides in external memory      The size of this table is (number of sets in the Reassembly Automatic Learning Hash table)*4 bytes.      This table resides in external memory and its base address should be 4-byte aligned */
operator|*
name|p_AutoLearnSetLockTblAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|XX_MallocSmart
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|numOfSets
operator|*
literal|4
argument_list|)
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p_AutoLearnSetLockTblAddr
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
operator|*
name|p_ReassTbl
argument_list|)
expr_stmt|;
operator|*
name|p_ReassTbl
operator|=
name|NULL
expr_stmt|;
name|XX_FreeSmart
argument_list|(
name|UINT_TO_PTR
argument_list|(
operator|*
name|p_AutoLearnHashTblAddr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_AutoLearnHashTblAddr
operator|=
literal|0
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
operator|*
name|p_AutoLearnSetLockTblAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|numOfSets
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* sets Set Lock table pointer and liodn offset*/
name|tmpReg64
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|&
name|FM_PCD_MANIP_REASM_LIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_REASM_LIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|&
name|FM_PCD_MANIP_REASM_ELIODN_MASK
argument_list|)
operator|<<
operator|(
name|uint64_t
operator|)
name|FM_PCD_MANIP_REASM_ELIODN_SHIFT
operator|)
expr_stmt|;
name|tmpReg64
operator||=
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
operator|*
name|p_AutoLearnSetLockTblAddr
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|liodnSlAndAutoLearnSetLockTblPtrHi
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|tmpReg64
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|autoLearnSetLockTblPtrLow
argument_list|,
operator|(
name|uint32_t
operator|)
name|tmpReg64
argument_list|)
expr_stmt|;
comment|/* Sets user's requested minimum fragment size (in Bytes) for First/Middle fragment */
name|WRITE_UINT16
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|minFragSize
argument_list|,
name|minFragSize
argument_list|)
expr_stmt|;
name|WRITE_UINT16
argument_list|(
operator|(
operator|*
name|p_ReassTbl
operator|)
operator|->
name|maxReassemblySize
argument_list|,
name|maxReassemSize
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitReasm
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPortPcdParams
modifier|*
name|p_PcdParams
init|=
operator|(
name|t_FmPortPcdParams
operator|*
operator|)
name|h_PcdParams
decl_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|t_FmPcdCtrlParamsPage
modifier|*
name|p_ParamsPage
decl_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|frag
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_IP_REASSEMBLY
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_Manip
operator|->
name|updateParams
operator|||
name|h_PcdParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|updateParams
condition|)
return|return
name|E_OK
return|;
if|if
condition|(
name|p_Manip
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"handler of PCD previously was initiated by different value"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|p_Manip
operator|->
name|updateParams
operator|&
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator|)
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"in this stage parameters from Port has not be updated"
operator|)
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_REASSEMBLY
condition|)
block|{
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator||=
name|UPDATE_OFP_DPTE
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|ofpDpde
operator|=
literal|0xF
expr_stmt|;
block|}
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|p_Manip
operator|->
name|updateParams
operator||
name|FM_REV
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|&
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator||
name|FM_REV
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"offset of the data wasn't configured previously"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|updateParams
operator|&
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator|)
condition|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
modifier|*
name|p_Ptr
decl_stmt|,
name|i
decl_stmt|,
name|totalNumOfTnums
decl_stmt|;
name|totalNumOfTnums
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfTasks
operator|+
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|numOfExtraTasks
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|totalNumOfTnums
operator|*
name|BMI_FIFO_UNITS
argument_list|)
argument_list|,
name|BMI_FIFO_UNITS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolAddr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Reassembly internal buffers pool"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|totalNumOfTnums
operator|*
name|BMI_FIFO_UNITS
argument_list|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolManagementIndexAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
literal|5
operator|+
name|totalNumOfTnums
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolManagementIndexAddr
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Reassembly internal buffers management"
operator|)
argument_list|)
expr_stmt|;
name|p_Ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolManagementIndexAddr
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|p_Ptr
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p_Ptr
operator|+=
literal|4
init|;
name|i
operator|<
name|totalNumOfTnums
condition|;
name|i
operator|++
operator|,
name|p_Ptr
operator|++
control|)
name|WRITE_UINT8
argument_list|(
operator|*
name|p_Ptr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|WRITE_UINT8
argument_list|(
operator|*
name|p_Ptr
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
operator|(
literal|4
operator|<<
name|FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_SHIFT
operator|)
operator||
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolManagementIndexAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|internalBufferManagement
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator|&=
operator|~
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator|)
expr_stmt|;
name|p_Manip
operator|->
name|shadowUpdateParams
operator||=
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_REASSEMBLY
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Scheme
condition|)
block|{
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
index|]
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Scheme
expr_stmt|;
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
condition|)
block|{
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
index|]
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
expr_stmt|;
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
condition|)
block|{
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|h_Schemes
index|[
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
index|]
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
expr_stmt|;
name|p_PcdParams
operator|->
name|p_KgParams
operator|->
name|numOfSchemes
operator|++
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|revInfo
operator|.
name|majorRev
operator|>=
literal|6
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortSetGprFunc
argument_list|(
name|h_FmPort
argument_list|,
name|e_FM_PORT_GPR_MURAM_PAGE
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p_ParamsPage
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|NIA_ENG_KG
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
condition|)
block|{
name|tmpReg32
operator||=
name|NIA_KG_DIRECT
expr_stmt|;
name|tmpReg32
operator||=
name|NIA_KG_CC_EN
expr_stmt|;
name|tmpReg32
operator||=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|iprIpv4Nia
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
condition|)
block|{
name|tmpReg32
operator|&=
operator|~
name|NIA_AC_MASK
expr_stmt|;
name|tmpReg32
operator||=
name|NIA_KG_DIRECT
expr_stmt|;
name|tmpReg32
operator||=
name|NIA_KG_CC_EN
expr_stmt|;
name|tmpReg32
operator||=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_ParamsPage
operator|->
name|iprIpv6Nia
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|revInfo
operator|.
name|majorRev
operator|<
literal|6
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|discardMask
argument_list|,
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|discardMask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
end_if

begin_function
specifier|static
name|t_Error
name|FmPcdFragHcScratchPoolFill
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|scratchBpid
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcFragScratchPoolCmdParams
name|fmPcdCcFragScratchPoolCmdParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPcdCcFragScratchPoolCmdParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcFragScratchPoolCmdParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmPcdCcFragScratchPoolCmdParams
operator|.
name|numOfBuffers
operator|=
name|NUM_OF_SCRATCH_POOL_BUFFERS
expr_stmt|;
name|fmPcdCcFragScratchPoolCmdParams
operator|.
name|bufferPoolId
operator|=
name|scratchBpid
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmHcPcdCcIpFragScratchPollCmd
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fmPcdCcFragScratchPoolCmdParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmPcdCcFragScratchPoolCmdParams
operator|.
name|numOfBuffers
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Fill scratch pool failed,"
literal|"Failed to release %d buffers to the BM (missing FBPRs)"
operator|,
name|fmPcdCcFragScratchPoolCmdParams
operator|.
name|numOfBuffers
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPcdFragHcScratchPoolEmpty
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|scratchBpid
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcFragScratchPoolCmdParams
name|fmPcdCcFragScratchPoolCmdParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPcdCcFragScratchPoolCmdParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcFragScratchPoolCmdParams
argument_list|)
argument_list|)
expr_stmt|;
name|fmPcdCcFragScratchPoolCmdParams
operator|.
name|bufferPoolId
operator|=
name|scratchBpid
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmHcPcdCcIpFragScratchPollCmd
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|FALSE
argument_list|,
operator|&
name|fmPcdCcFragScratchPoolCmdParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION == 10) */
end_comment

begin_function
specifier|static
name|void
name|ReleaseManipHandler
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|muramAllocate
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
else|else
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|h_Ad
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|p_Template
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|p_Template
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|p_Template
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrPoolTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_ReassmFrmDescrIndxPoolTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_TimeOutTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_TimeOutTbl
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|h_Frag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
if|if
condition|(
name|p_Manip
operator|->
name|frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
condition|)
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
name|FmPcdFragHcScratchPoolEmpty
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_FmPcd
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|scratchBpid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_Manip
operator|->
name|reassm
condition|)
block|{
name|FmPcdUnregisterReassmPort
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutTblAddr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrPoolTblAddr
condition|)
name|XX_FreeSmart
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrPoolTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|reassFrmDescrIndxPoolTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolManagementIndexAddr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolManagementIndexAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolAddr
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|internalBufferPoolAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_CAPWAP
condition|)
block|{              }
else|else
block|{
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv4AutoLearnHashTblAddr
condition|)
name|XX_FreeSmart
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv4AutoLearnHashTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6AutoLearnHashTblAddr
condition|)
name|XX_FreeSmart
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6AutoLearnHashTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv4AutoLearnSetLockTblAddr
condition|)
name|XX_FreeSmart
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv4AutoLearnSetLockTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6AutoLearnSetLockTblAddr
condition|)
name|XX_FreeSmart
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6AutoLearnSetLockTblAddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
condition|)
name|XX_FreeSmart
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
condition|)
name|XX_FreeSmart
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_Manip
operator|->
name|p_StatsTbl
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|p_StatsTbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
end_if

begin_function
specifier|static
name|t_Error
name|CheckManipParamsAndSetType
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmv
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR
operator|)
case|:
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|fromStartByHdr
operator|.
name|include
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|fromStartByHdr
operator|.
name|hdrInfo
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP_DTLS
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
block|{
if|if
condition|(
operator|!
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|frag
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_REASSEMBLY
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"unsupported header for Reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for this type of manipulation frag can not be TRUE"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"non valid net header of remove location"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|fromStartByHdr
operator|.
name|hdrInfo
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP_DTLS
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
operator|||
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
operator|=
name|TRUE
expr_stmt|;
comment|//internal frame header
break|break;
default|default :
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of remove manipulation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default :
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of remove manipulation"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of remove manipulation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_TEMPLATE
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|frag
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid header for fragmentation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"can not reach this point"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for only isert manipulation unsupported type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasm
condition|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|frag
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported header for fragmentation"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"
operator|)
argument_list|)
expr_stmt|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported header for reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"User didn't ask for any manipulation"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|insrt
operator|=
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
expr_stmt|;
name|p_Manip
operator|->
name|rmv
operator|=
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmv
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
end_comment

begin_function
specifier|static
name|t_Error
name|CheckManipParamsAndSetType
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|type
condition|)
block|{
case|case
name|e_FM_PCD_MANIP_HDR
case|:
comment|/* Check that next-manip is not already used */
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
block|{
if|if
condition|(
operator|!
name|MANIP_IS_FIRST
argument_list|(
name|p_ManipParams
operator|->
name|h_NextManip
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"h_NextManip is already a part of another chain"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MANIP_GET_TYPE
argument_list|(
name|p_ManipParams
operator|->
name|h_NextManip
argument_list|)
operator|!=
name|e_FM_PCD_MANIP_HDR
operator|)
operator|&&
operator|(
name|MANIP_GET_TYPE
argument_list|(
name|p_ManipParams
operator|->
name|h_NextManip
argument_list|)
operator|!=
name|e_FM_PCD_MANIP_FRAG
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation or Fragmentation."
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmv
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR
operator|)
case|:
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2
operator|)
case|:
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP
operator|)
case|:
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START
operator|)
case|:
block|{
name|t_Error
name|err
decl_stmt|;
name|uint8_t
name|prsArrayOffset
decl_stmt|;
name|err
operator|=
name|GetPrOffsetByHeaderOrField
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|hdrInfo
argument_list|,
operator|&
name|prsArrayOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of remove manipulation"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_RMV_GENERIC
operator|)
case|:
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of remove manipulation"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|rmv
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrt
condition|)
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR
operator|)
case|:
block|{
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2
operator|)
case|:
comment|/* nothing to check */
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_IP
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|ipParams
operator|.
name|insrt
operator|.
name|size
operator|%
literal|4
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IP inserted header must be of size which is a multiple of four bytes"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
operator|%
literal|4
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"CAPWAP inserted header must be of size which is a multiple of four bytes"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_UDP
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE
operator|)
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
operator|.
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|insrt
operator|.
name|size
operator|!=
literal|8
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Inserted header must be of size 8"
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"unsupported insert by header type"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
case|case
operator|(
name|e_FM_PCD_MANIP_INSRT_GENERIC
operator|)
case|:
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"for only insert manipulation unsupported type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|insrt
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdate
condition|)
block|{
comment|/* Check parameters */
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|type
operator|==
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN
condition|)
block|{
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|updateType
operator|==
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI
operator|)
operator|&&
operator|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|u
operator|.
name|vpri
operator|>
literal|7
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"vpri should get values of 0-7 "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|updateType
operator|==
name|e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|u
operator|.
name|dscpToVpri
operator|.
name|vpriDefVal
operator|>
literal|7
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"vpriDefVal should get values of 0-7 "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_MANIP_DSCP_TO_VLAN_TRANS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|fieldUpdateParams
operator|.
name|u
operator|.
name|vlan
operator|.
name|u
operator|.
name|dscpToVpri
operator|.
name|dscpToVpriTable
index|[
name|i
index|]
operator|&
literal|0xf0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"dscpToVpriTabl value out of range (0-15)"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|fieldUpdate
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|custom
condition|)
block|{
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|type
operator|==
name|e_FM_PCD_MANIP_HDR_CUSTOM_GEN_FIELD_REPLACE
condition|)
block|{
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|size
operator|==
literal|0
operator|)
operator|||
operator|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|size
operator|>
literal|8
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"size should get values of 1-8 "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|srcOffset
operator|>
literal|7
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"srcOffset should be<= 7"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|srcOffset
operator|+
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|size
operator|)
operator|>
literal|8
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"(srcOffset + size) should be<= 8"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|dstOffset
operator|+
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|customParams
operator|.
name|u
operator|.
name|genFieldReplace
operator|.
name|size
operator|)
operator|>
literal|256
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"(dstOffset + size) should be<= 256"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|custom
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|e_FM_PCD_MANIP_REASSEM
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"next manip with reassembly"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|reassem
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_IP_REASSEMBLY
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv6
expr_stmt|;
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_IP_REASSEMBLY
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|=
name|HEADER_TYPE_CAPWAP
expr_stmt|;
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_REASSEMBLY
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"header for reassembly"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|e_FM_PCD_MANIP_FRAG
case|:
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"next manip with fragmentation"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|frag
operator|.
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_IP_FRAGMENTATION
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HEADER_TYPE_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"header for fragmentation"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|e_FM_PCD_MANIP_SPECIAL_OFFLOAD
case|:
switch|switch
condition|(
name|p_ManipParams
operator|->
name|u
operator|.
name|specialOffload
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_IPSEC_MANIP
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_MANIP
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"special offload type"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"manip type"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
end_if

begin_function
specifier|static
name|t_Error
name|UpdateIndxStats
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"handler of PCD previously was initiated by different value"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fmPortGetSetCcParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPortGetSetCcParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_StatsTbl
condition|)
block|{
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNDN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_CC
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|p_StatsTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|owner
operator|*
name|FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_StatsTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Manipulation indexed statistics table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|p_StatsTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|owner
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|p_StatsTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|cnia
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_INDEXED_STATS_CNIA
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_INDEXED_STATS_DPD
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
name|UPDATE_NIA_PNDN
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|nia
operator|=
name|NIA_FM_CTL_AC_CC
expr_stmt|;
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|RmvHdrTillSpecLocNOrInsrtIntFrmHdr
parameter_list|(
name|t_FmPcdManipHdrRmvParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|uint8_t
name|prsArrayOffset
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|rmv
condition|)
block|{
name|err
operator|=
name|GetPrOffsetByHeaderOrField
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|byHdr
operator|.
name|u
operator|.
name|fromStartByHdr
operator|.
name|hdrInfo
argument_list|,
operator|&
name|prsArrayOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|prsArrayOffset
operator|<<
literal|24
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_RMV_HDR
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|insrt
condition|)
name|tmpReg32
operator||=
name|HMAN_INSRT_INT_FRM_HDR
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|MvIntFrameHeaderFromFrameToBufferPrefix
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|bool
name|caamUsed
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator||=
name|OFFSET_OF_PR
operator||
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|ccAdBase
operator|=
name|tmpReg32
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
literal|0x16
operator|<<
literal|16
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|pcAndOffsets
operator|=
name|tmpReg32
expr_stmt|;
if|if
condition|(
name|caamUsed
condition|)
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|gmask
operator|=
literal|0xf0000000
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapRmvDtlsHdr
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
name|p_Manip
operator|->
name|updateParams
operator||=
name|INTERNAL_CONTEXT_OFFSET
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapReassembly
parameter_list|(
name|t_CapwapReassemblyParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|poolId
parameter_list|)
block|{
name|t_Handle
name|p_Table
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint8_t
name|log2Num
decl_stmt|;
name|uint8_t
name|numOfSets
decl_stmt|;
name|uint32_t
name|j
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bitFor1Micro
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|h_Hc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"hc port has to be initialized in this mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|p_ManipParams
operator|->
name|timeoutRoutineRequestTime
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"timeoutRoutineRequestTime has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumFramesInProcess has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ManipParams
operator|->
name|timeoutRoutineRequestTime
operator|&&
name|p_ManipParams
operator|->
name|timeoutThresholdForReassmProcess
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|numOfFramesPerHashEntry
operator|==
name|e_FM_PCD_MANIP_FOUR_WAYS_HASH
condition|)
block|{
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|<
literal|4
operator|)
operator|||
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|>
literal|512
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|<
literal|8
operator|)
operator|||
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|>
literal|2048
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"
operator|)
argument_list|)
expr_stmt|;
block|}
name|bitFor1Micro
operator|=
name|FmGetTimeStampScale
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitFor1Micro
operator|==
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"Timestamp scale"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator||=
operator|(
name|NUM_OF_TASKS
operator||
name|OFFSET_OF_PR
operator||
name|OFFSET_OF_DATA
operator||
name|HW_PORT_ID
operator|)
expr_stmt|;
name|p_Manip
operator|->
name|h_Frag
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc CAPWAP reassembly parameters table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE
argument_list|)
expr_stmt|;
name|p_Table
operator|=
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE
argument_list|)
argument_list|,
name|FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for CAPWAP automatic learning hash table"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|autoLearnHashTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|timeOutMode
operator|==
name|e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|haltOnDuplicationFrag
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|numOfFramesPerHashEntry
operator|==
name|e_FM_PCD_MANIP_EIGHT_WAYS_HASH
condition|)
block|{
name|i
operator|=
literal|8
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|4
expr_stmt|;
name|numOfSets
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
operator|)
operator|/
name|i
argument_list|)
expr_stmt|;
name|LOG2
argument_list|(
name|numOfSets
argument_list|,
name|log2Num
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|log2Num
operator|-
literal|1
argument_list|)
operator|<<
literal|24
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
operator|*
literal|2
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|j
operator|/
name|i
operator|)
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
name|WRITE_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|p_AutoLearnHashTbl
argument_list|,
name|j
operator|*
name|FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE
argument_list|)
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0x00008000
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|poolId
operator|<<
literal|16
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|bufferPoolIdAndRisc1SetIndexes
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|risc23SetIndexes
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|risc4SetIndexesAndExtendedStatsTblPtr
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|maxNumFramesInProcess
operator|=
name|p_ManipParams
operator|->
name|maxNumFramesInProcess
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|sgBpid
operator|=
name|poolId
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|p_ManipParams
operator|->
name|fqidForTimeOutFrames
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|timeoutRoutineRequestTime
operator|=
name|p_ManipParams
operator|->
name|timeoutRoutineRequestTime
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|bitFor1Micro
operator|=
name|bitFor1Micro
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|bitFor1Micro
operator|)
operator|*
name|p_ManipParams
operator|->
name|timeoutThresholdForReassmProcess
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_CapwapReasmPram
operator|*
operator|)
name|p_Table
operator|)
operator|->
name|expirationDelay
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapFragmentation
parameter_list|(
name|t_CapwapFragmentationParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|poolId
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|updateParams
operator||=
name|OFFSET_OF_DATA
expr_stmt|;
name|p_Manip
operator|->
name|frag
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|h_Frag
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for CAPWAP fragmentation table descriptor"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Frag
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|headerOptionsCompr
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN
expr_stmt|;
name|tmpReg32
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|poolId
operator|<<
literal|8
operator|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|sizeForFragmentation
operator|=
name|p_ManipParams
operator|->
name|sizeForFragmentation
expr_stmt|;
name|p_Manip
operator|->
name|capwapFragParams
operator|.
name|sgBpid
operator|=
name|poolId
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IndxStats
parameter_list|(
name|t_FmPcdStatsParams
modifier|*
name|p_StatsParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_INDEXED_STATS
expr_stmt|;
if|if
condition|(
name|p_StatsParams
operator|->
name|type
operator|==
name|e_FM_PCD_STATS_PER_FLOWID
condition|)
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
literal|0x16
operator|<<
literal|16
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|InsrtHdrByTempl
parameter_list|(
name|t_FmPcdManipHdrInsrtParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdManipHdrInsrtByTemplateParams
modifier|*
name|p_InsrtByTemplate
init|=
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|byTemplate
decl_stmt|;
name|uint8_t
name|tmpReg8
init|=
literal|0xff
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|bool
name|ipModify
init|=
name|FALSE
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|tmpRegNia
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tmpReg16
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|extraAddedBytes
init|=
literal|0
decl_stmt|,
name|blockSize
init|=
literal|0
decl_stmt|,
name|extraAddedBytesAlignedToBlockSize
init|=
literal|0
decl_stmt|,
name|log2Num
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|p_Template
init|=
name|NULL
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|insrt
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|p_InsrtByTemplate
operator|->
name|size
operator|&&
name|p_InsrtByTemplate
operator|->
name|modifyOuterIp
operator|)
operator|||
operator|(
operator|!
name|p_InsrtByTemplate
operator|->
name|size
operator|&&
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlan
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|size
operator|&&
name|p_InsrtByTemplate
operator|->
name|modifyOuterIp
operator|&&
operator|(
name|p_InsrtByTemplate
operator|->
name|size
operator|<=
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : size of template< ipOuterOffset"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|size
operator|>
literal|128
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Size of header template for insertion can not be more than 128"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|size
condition|)
block|{
name|p_Manip
operator|->
name|p_Template
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_InsrtByTemplate
operator|->
name|size
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|p_Template
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation in MURAM FAILED"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|p_Template
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_InsrtByTemplate
operator|->
name|size
operator|<<
literal|24
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|matchTblPtr
operator|=
name|tmpReg32
expr_stmt|;
block|}
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|p_Template
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|p_InsrtByTemplate
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Template
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"XX_Malloc allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_Template
argument_list|,
name|p_InsrtByTemplate
operator|->
name|hdrTemplate
argument_list|,
name|p_InsrtByTemplate
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIp
condition|)
block|{
name|ipModify
operator|=
name|TRUE
expr_stmt|;
name|tmpReg8
operator|=
operator|(
name|uint8_t
operator|)
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmpReg8
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
name|tmpReg8
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmpReg8
operator|&
literal|0xf0
operator|)
operator|==
literal|0x60
condition|)
name|tmpReg8
operator|=
literal|6
expr_stmt|;
else|else
name|tmpReg8
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|tmpReg8
operator|!=
literal|0xff
condition|)
block|{
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|dscpEcn
operator|&
literal|0xff00
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLength
condition|)
block|{
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedAlignedToBlockSize
operator|+
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedNotAlignedToBlockSize
operator|)
operator|>
literal|255
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"extra Byte added can not be more than 256 bytes"
operator|)
argument_list|)
expr_stmt|;
name|extraAddedBytes
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedAlignedToBlockSize
operator|+
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedNotAlignedToBlockSize
argument_list|)
expr_stmt|;
name|blockSize
operator|=
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|blockSize
expr_stmt|;
name|extraAddedBytesAlignedToBlockSize
operator|=
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|recalculateLengthParams
operator|.
name|extraBytesAddedAlignedToBlockSize
expr_stmt|;
comment|/*IP header template - IP totalLength -                      (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,                      in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)                      second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
block|}
if|if
condition|(
name|blockSize
condition|)
block|{
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|blockSize
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"inputFrmPaddingUpToBlockSize has to be power of 2"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmpReg8
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP
operator|+
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|)
operator|>
name|p_InsrtByTemplate
operator|->
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_DSCECN_FIELD_OFFSET_FROM_IP
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|dscpEcn
expr_stmt|;
if|if
condition|(
name|blockSize
condition|)
name|blockSize
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|size
operator|-
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|extraAddedBytes
operator|)
operator|>
literal|255
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
name|blockSize
expr_stmt|;
comment|// IPV6 - in AD instead of SEQ IND
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|size
operator|-
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|extraAddedBytes
argument_list|)
expr_stmt|;
comment|// for IPV6 decrement additional 40 bytes of IPV6 heade size
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_ID_FIELD_OFFSET_FROM_IP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_ID_FIELD_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
name|extraAddedBytesAlignedToBlockSize
expr_stmt|;
comment|/*IP header template - relevant only for ipv4 CheckSum = 0*/
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/*UDP checksum has to be 0*/
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpPresent
condition|)
block|{
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP
operator|+
name|UDP_CHECKSUM_FIELD_SIZE
operator|)
operator|>
name|p_InsrtByTemplate
operator|->
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size)< size of header template"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP
operator|+
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipIdentGenId
operator|>
literal|7
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"
operator|)
argument_list|)
expr_stmt|;
name|tmpRegNia
operator||=
operator|(
name|uint32_t
operator|)
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipIdentGenId
operator|<<
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpReg8
operator|==
literal|6
condition|)
block|{
comment|/*TODO - add check for maximum value of blockSize;*/
if|if
condition|(
name|blockSize
condition|)
name|LOG2
argument_list|(
name|blockSize
argument_list|,
name|log2Num
argument_list|)
expr_stmt|;
name|tmpRegNia
operator||=
operator|(
name|uint32_t
operator|)
name|log2Num
operator|<<
literal|24
expr_stmt|;
comment|// for IPV6 decrement additional 40 bytes of IPV6 heade size - because IPV6 header size is not included in payloadLength
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|size
operator|-
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|extraAddedBytes
operator|-
literal|40
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP
operator|+
literal|1
index|]
operator|=
name|extraAddedBytesAlignedToBlockSize
expr_stmt|;
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpPresent
condition|)
block|{
if|if
condition|(
operator|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP
operator|+
name|UDP_CHECKSUM_FIELD_SIZE
operator|)
operator|>
name|p_InsrtByTemplate
operator|->
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size)< size of header template"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|+
name|IPv6_NEXT_HEADER_OFFSET_FROM_IP
index|]
operator|!=
literal|0x88
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"OUr suppport is only IPv6/UDPLite"
operator|)
argument_list|)
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_LENGTH_FIELD_OFFSET_FROM_UDP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_LENGTH_FIELD_OFFSET_FROM_UDP
operator|+
literal|1
index|]
operator|=
literal|0x08
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP
index|]
operator|=
literal|0x00
expr_stmt|;
name|p_Template
index|[
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|udpOffset
operator|+
name|UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP
operator|+
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"IP version supported only IPV4"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator|=
name|tmpReg16
operator|=
name|tmpReg8
operator|=
literal|0
expr_stmt|;
comment|/*TODO - check it*/
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlan
condition|)
block|{
if|if
condition|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlanParams
operator|.
name|vpri
operator|&
operator|~
literal|0x07
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmpReg16
argument_list|,
operator|&
name|p_Template
index|[
name|VLAN_TAG_FIELD_OFFSET_FROM_ETH
index|]
argument_list|,
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpReg16
operator|!=
literal|0x9100
operator|)
operator|&&
operator|(
name|tmpReg16
operator|!=
literal|0x9200
operator|)
operator|&&
operator|(
name|tmpReg16
operator|!=
literal|0x8100
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmpReg8
argument_list|,
operator|&
name|p_Template
index|[
literal|14
index|]
argument_list|,
literal|1
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmpReg8
operator|&=
literal|0x1f
expr_stmt|;
name|tmpReg8
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|p_InsrtByTemplate
operator|->
name|modifyOuterVlanParams
operator|.
name|vpri
operator|<<
literal|5
argument_list|)
expr_stmt|;
name|p_Template
index|[
literal|14
index|]
operator|=
name|tmpReg8
expr_stmt|;
block|}
name|MemCpy8
argument_list|(
name|p_Manip
operator|->
name|p_Template
argument_list|,
name|p_Template
argument_list|,
name|p_InsrtByTemplate
operator|->
name|size
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Template
argument_list|)
expr_stmt|;
block|}
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
name|tmpRegNia
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|h_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|sizeForFragmentation
operator|<<
literal|16
expr_stmt|;
block|}
else|else
name|tmpReg32
operator|=
literal|0xffff0000
expr_stmt|;
if|if
condition|(
name|ipModify
condition|)
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|p_InsrtByTemplate
operator|->
name|modifyOuterIpParams
operator|.
name|ipOuterOffset
operator|<<
literal|8
expr_stmt|;
else|else
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
literal|0x0000ff00
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|pcAndOffsets
operator|=
name|tmpReg32
expr_stmt|;
name|tmpRegNia
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|p_Ad
operator|->
name|ccAdBase
operator|=
name|tmpRegNia
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CheckStatsParamsAndSetType
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdStatsParams
modifier|*
name|p_StatsParams
parameter_list|)
block|{
switch|switch
condition|(
name|p_StatsParams
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_STATS_PER_FLOWID
operator|)
case|:
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_INDEXED_STATS
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Unsupported statistics type"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
end_comment

begin_function
specifier|static
name|t_Error
name|FillReassmManipParams
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
comment|/* Creates the Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly      function or to the IPv6 reassembly function. If both IPv4 reassembly and IPv6 reassembly are required, then      two separate IP Reassembly Parameter tables are required.*/
if|if
condition|(
operator|(
name|err
operator|=
name|CreateReassTable
argument_list|(
name|p_Manip
argument_list|,
name|hdr
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the Reassembly Parameters Table offset from MURAM*/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
comment|/* Gets the required Action descriptor table pointer */
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
name|HEADER_TYPE_IPv4
case|:
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEADER_TYPE_IPv6
case|:
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEADER_TYPE_CAPWAP
case|:
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Ad
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"header type"
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID for V2) and Scatter/Gather table offset*/
comment|/* mark the Scatter/Gather table offset to be set later on when the port will be known */
name|p_Manip
operator|->
name|updateParams
operator|=
operator|(
name|NUM_OF_TASKS
operator||
name|NUM_OF_EXTRA_TASKS
operator||
name|DISCARD_MASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
operator|||
operator|(
name|hdr
operator|==
name|HEADER_TYPE_IPv4
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
name|tmpReg32
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|sgBpid
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|nonConsistentSpFqid
operator|!=
literal|0
condition|)
block|{
name|tmpReg32
operator|=
name|FM_PCD_AD_NCSPFQIDM_MASK
operator||
call|(
name|uint32_t
call|)
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|nonConsistentSpFqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_IP_REASSEMBLY
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
elseif|else
if|if
condition|(
name|hdr
operator|==
name|HEADER_TYPE_CAPWAP
condition|)
block|{
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_REASSEMBLY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|reassm
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetIpv4ReassmManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
comment|/* Allocation if IPv4 Action descriptor */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Allocation of IPv4 table descriptor"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
return|return
name|FillReassmManipParams
argument_list|(
name|p_Manip
argument_list|,
name|HEADER_TYPE_IPv4
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetIpv6ReassmManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
comment|/* Allocation if IPv6 Action descriptor */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Allocation of IPv6 table descriptor"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
return|return
name|FillReassmManipParams
argument_list|(
name|p_Manip
argument_list|,
name|HEADER_TYPE_IPv6
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IpReassembly
parameter_list|(
name|t_FmPcdManipReassemParams
modifier|*
name|p_ManipReassmParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|uint32_t
name|maxSetNumber
init|=
literal|10000
decl_stmt|;
name|t_FmPcdManipReassemIpParams
name|reassmManipParams
init|=
name|p_ManipReassmParams
operator|->
name|u
operator|.
name|ipReassem
decl_stmt|;
name|t_Error
name|res
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* Check validation of user's parameter.*/
if|if
condition|(
operator|(
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
operator|<
literal|1000
operator|)
operator|||
operator|(
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
operator|>
literal|8000000
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"timeoutThresholdForReassmProcess should be 1msec - 8sec"
operator|)
argument_list|)
expr_stmt|;
comment|/* It is recommended that the total number of entries in this table (number of sets * number of ways)      will be twice the number of frames that are expected to be reassembled simultaneously.*/
if|if
condition|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
operator|>
operator|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
operator|*
name|maxSetNumber
operator|/
literal|2
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_ManipReassmParams
operator|->
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
operator|&&
operator|(
name|reassmManipParams
operator|.
name|minFragSize
index|[
literal|1
index|]
operator|<
literal|256
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"minFragSize[1] must be>= 256"
operator|)
argument_list|)
expr_stmt|;
comment|/* Saves user's reassembly manipulation parameters */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|relativeSchemeId
index|[
literal|0
index|]
operator|=
name|reassmManipParams
operator|.
name|relativeSchemeId
index|[
literal|0
index|]
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|relativeSchemeId
index|[
literal|1
index|]
operator|=
name|reassmManipParams
operator|.
name|relativeSchemeId
index|[
literal|1
index|]
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|numOfFramesPerHashEntry
index|[
literal|0
index|]
operator|=
name|reassmManipParams
operator|.
name|numOfFramesPerHashEntry
index|[
literal|0
index|]
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|numOfFramesPerHashEntry
index|[
literal|1
index|]
operator|=
name|reassmManipParams
operator|.
name|numOfFramesPerHashEntry
index|[
literal|1
index|]
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|minFragSize
index|[
literal|0
index|]
operator|=
name|reassmManipParams
operator|.
name|minFragSize
index|[
literal|0
index|]
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|minFragSize
index|[
literal|1
index|]
operator|=
name|reassmManipParams
operator|.
name|minFragSize
index|[
literal|1
index|]
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|maxNumFramesInProcess
operator|=
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutMode
operator|=
name|reassmManipParams
operator|.
name|timeOutMode
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|reassmManipParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeoutThresholdForReassmProcess
operator|=
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
operator|=
name|reassmManipParams
operator|.
name|dataMemId
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|=
name|reassmManipParams
operator|.
name|dataLiodnOffset
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
name|p_Manip
operator|->
name|reassmParams
operator|.
name|sgBpid
operator|=
name|reassmManipParams
operator|.
name|sgBpid
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|reassmManipParams
operator|.
name|nonConsistentSpFqid
operator|!=
literal|0
condition|)
block|{
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|nonConsistentSpFqid
operator|=
name|reassmManipParams
operator|.
name|nonConsistentSpFqid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* Creates and initializes the IP Reassembly common parameter table */
name|CreateReassCommonTable
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
comment|/* Creation of IPv4 reassembly manipulation */
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv4
operator|)
condition|)
block|{
name|res
operator|=
name|SetIpv4ReassmManip
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|E_OK
condition|)
return|return
name|res
return|;
block|}
comment|/* Creation of IPv6 reassembly manipulation */
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv6
condition|)
block|{
name|res
operator|=
name|SetIpv6ReassmManip
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|E_OK
condition|)
return|return
name|res
return|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setIpReassmSchemeParams
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdKgSchemeParams
modifier|*
name|p_Scheme
parameter_list|,
name|t_Handle
name|h_CcTree
parameter_list|,
name|bool
name|ipv4
parameter_list|,
name|uint8_t
name|groupId
parameter_list|)
block|{
name|uint32_t
name|j
decl_stmt|;
name|uint8_t
name|res
decl_stmt|;
comment|/* Configures scheme's network environment parameters */
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|numOfDistinctionUnits
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ipv4
condition|)
name|res
operator|=
name|FmPcdNetEnvGetUnitId
argument_list|(
name|p_FmPcd
argument_list|,
name|FmPcdGetNetEnvId
argument_list|(
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
argument_list|)
argument_list|,
name|HEADER_TYPE_IPv4
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|FmPcdNetEnvGetUnitId
argument_list|(
name|p_FmPcd
argument_list|,
name|FmPcdGetNetEnvId
argument_list|(
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
argument_list|)
argument_list|,
name|HEADER_TYPE_IPv6
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|res
operator|!=
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|unitIds
index|[
literal|0
index|]
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|FmPcdNetEnvGetUnitId
argument_list|(
name|p_FmPcd
argument_list|,
name|FmPcdGetNetEnvId
argument_list|(
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
argument_list|)
argument_list|,
name|HEADER_TYPE_USER_DEFINED_SHIM2
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|res
operator|!=
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|unitIds
index|[
literal|1
index|]
operator|=
name|res
expr_stmt|;
comment|/* Configures scheme's next engine parameters*/
name|p_Scheme
operator|->
name|nextEngine
operator|=
name|e_FM_PCD_CC
expr_stmt|;
name|p_Scheme
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|h_CcTree
operator|=
name|h_CcTree
expr_stmt|;
name|p_Scheme
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|grpId
operator|=
name|groupId
expr_stmt|;
name|p_Scheme
operator|->
name|useHash
operator|=
name|TRUE
expr_stmt|;
comment|/* Configures scheme's key*/
if|if
condition|(
name|ipv4
operator|==
name|TRUE
condition|)
block|{
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|numOfUsedExtracts
operator|=
literal|4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FULL_FIELD
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv4
operator|=
name|NET_HEADER_FIELD_IPv4_DST_IP
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FULL_FIELD
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv4
operator|=
name|NET_HEADER_FIELD_IPv4_SRC_IP
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FULL_FIELD
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv4
operator|=
name|NET_HEADER_FIELD_IPv4_PROTO
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|3
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|3
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FROM_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|3
index|]
operator|.
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|FALSE
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|3
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|3
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
operator|=
literal|4
expr_stmt|;
block|}
else|else
comment|/* IPv6 */
block|{
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|numOfUsedExtracts
operator|=
literal|3
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FULL_FIELD
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv6
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv6
operator|=
name|NET_HEADER_FIELD_IPv6_DST_IP
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FULL_FIELD
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_IPv6
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv6
operator|=
name|NET_HEADER_FIELD_IPv6_SRC_IP
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_BY_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_USER_DEFINED_SHIM2
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FROM_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|size
operator|=
literal|4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
operator|=
literal|4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|2
index|]
operator|.
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|TRUE
expr_stmt|;
block|}
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|privateDflt0
operator|=
literal|0x01020304
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|privateDflt1
operator|=
literal|0x11121314
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|numOfUsedDflts
operator|=
name|FM_PCD_KG_NUM_OF_DEFAULT_GROUPS
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FM_PCD_KG_NUM_OF_DEFAULT_GROUPS
condition|;
name|j
operator|++
control|)
block|{
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|dflts
index|[
name|j
index|]
operator|.
name|type
operator|=
operator|(
name|e_FmPcdKgKnownFieldsDfltTypes
operator|)
name|j
expr_stmt|;
comment|/* all types */
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|dflts
index|[
name|j
index|]
operator|.
name|dfltSelect
operator|=
name|e_FM_PCD_KG_DFLT_GBL_0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IpReassemblyStats
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipReassemIpStats
modifier|*
name|p_Stats
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Stats
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|timeout
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalTimeOutCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|rfdPoolBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalRfdPoolBusyCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|internalBufferBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalInternalBufferBusy
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|externalBufferBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalExternalBufferBusy
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|sgFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalSgFragmentCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|dmaSemaphoreDepletion
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalDmaSemaphoreDepletionCounter
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|p_Stats
operator|->
name|nonConsistentSp
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalNCSPCounter
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
condition|)
block|{
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|successfullyReassembled
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalSuccessfullyReasmFramesCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|validFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalValidFragmentCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|processedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalProcessedFragCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|malformedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalMalformdFragCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|autoLearnBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalSetBusyCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|discardedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalDiscardedFragsCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|0
index|]
operator|.
name|moreThan16Fragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv4ReassTbl
operator|->
name|totalMoreThan16FramesCounter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
condition|)
block|{
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|successfullyReassembled
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalSuccessfullyReasmFramesCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|validFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalValidFragmentCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|processedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalProcessedFragCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|malformedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalMalformdFragCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|autoLearnBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalSetBusyCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|discardedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalDiscardedFragsCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|specificHdrStatistics
index|[
literal|1
index|]
operator|.
name|moreThan16Fragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|p_Ipv6ReassTbl
operator|->
name|totalMoreThan16FramesCounter
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IpFragmentationStats
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipFragIpStats
modifier|*
name|p_Stats
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Stats
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|p_Stats
operator|->
name|totalFrames
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|fragmentedFrames
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|ccAdBase
argument_list|)
operator|&
literal|0x00ffffff
expr_stmt|;
name|p_Stats
operator|->
name|generatedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|matchTblPtr
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IpFragmentation
parameter_list|(
name|t_FmPcdManipFragIpParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|uint32_t
name|pcAndOffsetsReg
init|=
literal|0
decl_stmt|,
name|ccAdBaseReg
init|=
literal|0
decl_stmt|,
name|gmaskReg
init|=
literal|0
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
operator|->
name|sizeForFragmentation
operator|!=
literal|0xFFFF
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Manip
operator|->
name|h_FmPcd
expr_stmt|;
comment|/* Allocation of fragmentation Action Descriptor */
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Fragmentation table descriptor"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Prepare the third Ad register (pcAndOffsets)- OperationCode */
name|pcAndOffsetsReg
operator|=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_IP_FRAGMENTATION
expr_stmt|;
comment|/* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
name|ccAdBaseReg
operator|=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|ccAdBaseReg
operator||=
operator|(
name|p_ManipParams
operator|->
name|dontFragAction
operator|<<
name|FM_PCD_MANIP_IP_FRAG_DF_SHIFT
operator|)
expr_stmt|;
comment|/* Set Scatter/Gather BPid */
if|if
condition|(
name|p_ManipParams
operator|->
name|sgBpidEn
condition|)
block|{
name|ccAdBaseReg
operator||=
name|FM_PCD_MANIP_IP_FRAG_SG_BDID_EN
expr_stmt|;
name|pcAndOffsetsReg
operator||=
operator|(
operator|(
name|p_ManipParams
operator|->
name|sgBpid
operator|<<
name|FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT
operator|)
operator|&
name|FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK
operator|)
expr_stmt|;
block|}
comment|/* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
name|gmaskReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPcd
operator|->
name|ipv6FrameIdAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
name|gmaskReg
operator||=
name|p_ManipParams
operator|->
name|scratchBpid
operator|<<
name|FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID
expr_stmt|;
else|#
directive|else
name|gmaskReg
operator||=
operator|(
literal|0xFF
operator|)
operator|<<
name|FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
comment|/* Set all Ad registers */
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|pcAndOffsets
argument_list|,
name|pcAndOffsetsReg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|ccAdBase
argument_list|,
name|ccAdBaseReg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|gmask
argument_list|,
name|gmaskReg
argument_list|)
expr_stmt|;
comment|/* Saves user's fragmentation manipulation parameters */
name|p_Manip
operator|->
name|frag
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|sizeForFragmentation
operator|=
name|p_ManipParams
operator|->
name|sizeForFragmentation
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
name|p_Manip
operator|->
name|fragParams
operator|.
name|scratchBpid
operator|=
name|p_ManipParams
operator|->
name|scratchBpid
expr_stmt|;
comment|/* scratch buffer pool initialization */
if|if
condition|(
operator|(
name|err
operator|=
name|FmPcdFragHcScratchPoolFill
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_FmPcd
argument_list|,
name|p_ManipParams
operator|->
name|scratchBpid
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|=
name|NULL
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION == 10) */
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IPManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|tmpRegNia
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Manip
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator|=
name|FM_PCD_MANIP_IP_NO_FRAGMENTATION
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|frag
operator|==
name|TRUE
condition|)
block|{
name|tmpRegNia
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|sizeForFragmentation
operator|<<
name|FM_PCD_MANIP_IP_MTU_SHIFT
expr_stmt|;
block|}
name|tmpRegNia
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_OC_IP_MANIP
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|tmpRegNia
operator||=
name|FM_PCD_MANIP_IP_CNIA
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpRegNia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Total frame counter - MUST be initialized to zero.*/
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitIpFrag
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_IP_FRAGMENTATION
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_PcdParams
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|validate
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|MANIP_EXTRA_SPACE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|internalBufferOffset
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"manipExtraSpace must be larger than '0'"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IPSecManip
parameter_list|(
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPcdManipSpecialOffloadIPSecParams
modifier|*
name|p_IPSecParams
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|uint32_t
name|power
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_IPSecParams
operator|=
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|specialOffload
operator|.
name|u
operator|.
name|ipsec
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_IPSecParams
operator|->
name|variableIpHdrLen
operator|||
name|p_IPSecParams
operator|->
name|decryption
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_IPSecParams
operator|->
name|variableIpVersion
operator|||
operator|!
name|p_IPSecParams
operator|->
name|decryption
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_IPSecParams
operator|->
name|variableIpVersion
operator|||
name|p_IPSecParams
operator|->
name|outerIPHdrLen
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_IPSecParams
operator|->
name|arwSize
operator|||
name|p_IPSecParams
operator|->
name|arwAddr
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_IPSecParams
operator|->
name|arwSize
operator|||
name|p_IPSecParams
operator|->
name|decryption
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_IPSecParams
operator|->
name|arwSize
operator|%
literal|16
operator|)
operator|==
literal|0
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_IPSecParams
operator|->
name|decryption
operator|)
condition|?
name|FM_PCD_MANIP_IPSEC_DEC
else|:
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_IPSecParams
operator|->
name|ecnCopy
operator|)
condition|?
name|FM_PCD_MANIP_IPSEC_ECN_EN
else|:
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_IPSecParams
operator|->
name|dscpCopy
operator|)
condition|?
name|FM_PCD_MANIP_IPSEC_DSCP_EN
else|:
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_IPSecParams
operator|->
name|variableIpHdrLen
operator|)
condition|?
name|FM_PCD_MANIP_IPSEC_VIPL_EN
else|:
literal|0
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_IPSecParams
operator|->
name|variableIpVersion
operator|)
condition|?
name|FM_PCD_MANIP_IPSEC_VIPV_EN
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|p_IPSecParams
operator|->
name|arwSize
condition|)
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_IPSecParams
operator|->
name|arwAddr
argument_list|)
argument_list|)
operator|-
name|FM_MM_MURAM
operator|)
operator|&
operator|(
name|FM_MURAM_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_IPSecParams
operator|->
name|arwSize
condition|)
block|{
name|NEXT_POWER_OF_2
argument_list|(
operator|(
name|p_IPSecParams
operator|->
name|arwSize
operator|+
literal|32
operator|)
argument_list|,
name|power
argument_list|)
expr_stmt|;
name|LOG2
argument_list|(
name|power
argument_list|,
name|power
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
operator|(
name|p_IPSecParams
operator|->
name|arwSize
operator||
operator|(
name|power
operator|-
literal|5
operator|)
operator|)
operator|<<
name|FM_PCD_MANIP_IPSEC_ARW_SIZE_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_ManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_Ad
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|HMAN_OC_IPSEC_MANIP
expr_stmt|;
name|tmpReg32
operator||=
name|p_IPSecParams
operator|->
name|outerIPHdrLen
operator|<<
name|FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
name|tmpReg32
operator||=
name|FM_PCD_MANIP_IPSEC_NADEN
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetCapwapReassmManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
decl_stmt|;
comment|/* Allocation if CAPWAP Action descriptor */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_MallocSmart
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Ad
condition|)
block|{
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Allocation of CAPWAP table descriptor"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Fill reassembly manipulation parameter in the Reassembly Action Descriptor */
return|return
name|FillReassmManipParams
argument_list|(
name|p_Manip
argument_list|,
name|HEADER_TYPE_CAPWAP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setCapwapReassmSchemeParams
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdKgSchemeParams
modifier|*
name|p_Scheme
parameter_list|,
name|t_Handle
name|h_CcTree
parameter_list|,
name|uint8_t
name|groupId
parameter_list|)
block|{
name|uint8_t
name|res
decl_stmt|;
comment|/* Configures scheme's network environment parameters */
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|numOfDistinctionUnits
operator|=
literal|1
expr_stmt|;
name|res
operator|=
name|FmPcdNetEnvGetUnitId
argument_list|(
name|p_FmPcd
argument_list|,
name|FmPcdGetNetEnvId
argument_list|(
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
argument_list|)
argument_list|,
name|HEADER_TYPE_USER_DEFINED_SHIM2
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|res
operator|!=
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|netEnvParams
operator|.
name|unitIds
index|[
literal|0
index|]
operator|=
name|res
expr_stmt|;
comment|/* Configures scheme's next engine parameters*/
name|p_Scheme
operator|->
name|nextEngine
operator|=
name|e_FM_PCD_CC
expr_stmt|;
name|p_Scheme
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|h_CcTree
operator|=
name|h_CcTree
expr_stmt|;
name|p_Scheme
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|grpId
operator|=
name|groupId
expr_stmt|;
name|p_Scheme
operator|->
name|useHash
operator|=
name|TRUE
expr_stmt|;
comment|/* Configures scheme's key*/
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|numOfUsedExtracts
operator|=
literal|2
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_NON_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractNonHdr
operator|.
name|src
operator|=
name|e_FM_PCD_EXTRACT_FROM_PARSE_RESULT
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractNonHdr
operator|.
name|action
operator|=
name|e_FM_PCD_ACTION_NONE
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractNonHdr
operator|.
name|offset
operator|=
literal|20
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|0
index|]
operator|.
name|extractNonHdr
operator|.
name|size
operator|=
literal|4
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_NON_HDR
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractNonHdr
operator|.
name|src
operator|=
name|e_FM_PCD_EXTRACT_FROM_DFLT_VALUE
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractNonHdr
operator|.
name|action
operator|=
name|e_FM_PCD_ACTION_NONE
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractNonHdr
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|extractArray
index|[
literal|1
index|]
operator|.
name|extractNonHdr
operator|.
name|size
operator|=
literal|1
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|privateDflt0
operator|=
literal|0x0
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|privateDflt1
operator|=
literal|0x0
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|numOfUsedDflts
operator|=
literal|1
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|dflts
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_KG_GENERIC_NOT_FROM_DATA
expr_stmt|;
name|p_Scheme
operator|->
name|keyExtractAndHashParams
operator|.
name|dflts
index|[
literal|0
index|]
operator|.
name|dfltSelect
operator|=
name|e_FM_PCD_KG_DFLT_PRIVATE_0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
specifier|static
name|t_Error
name|CapwapReassemblyStats
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipReassemCapwapStats
modifier|*
name|p_Stats
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Stats
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|timeout
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalTimeOutCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|rfdPoolBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalRfdPoolBusyCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|internalBufferBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalInternalBufferBusy
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|externalBufferBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalExternalBufferBusy
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|sgFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalSgFragmentCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|dmaSemaphoreDepletion
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalDmaSemaphoreDepletionCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|exceedMaxReassemblyFrameLen
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|p_ReassCommonTbl
operator|->
name|totalNCSPCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|successfullyReassembled
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalSuccessfullyReasmFramesCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|validFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalValidFragmentCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|processedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalProcessedFragCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|malformedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalMalformdFragCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|autoLearnBusy
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalSetBusyCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|discardedFragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalDiscardedFragsCounter
argument_list|)
expr_stmt|;
name|p_Stats
operator|->
name|moreThan16Fragments
operator|=
name|GET_UINT32
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|p_ReassTbl
operator|->
name|totalMoreThan16FramesCounter
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapFragmentationStats
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_FmPcdManipFragCapwapStats
modifier|*
name|p_Stats
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Stats
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|p_Stats
operator|->
name|totalFrames
operator|=
name|GET_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapReassembly
parameter_list|(
name|t_FmPcdManipReassemParams
modifier|*
name|p_ManipReassmParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|uint32_t
name|maxSetNumber
init|=
literal|10000
decl_stmt|;
name|t_FmPcdManipReassemCapwapParams
name|reassmManipParams
init|=
name|p_ManipReassmParams
operator|->
name|u
operator|.
name|capwapReassem
decl_stmt|;
name|t_Error
name|res
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* Check validation of user's parameter.*/
if|if
condition|(
operator|(
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
operator|<
literal|1000
operator|)
operator|||
operator|(
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
operator|>
literal|8000000
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"timeoutThresholdForReassmProcess should be 1msec - 8sec"
operator|)
argument_list|)
expr_stmt|;
comment|/* It is recommended that the total number of entries in this table (number of sets * number of ways)      will be twice the number of frames that are expected to be reassembled simultaneously.*/
if|if
condition|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
operator|>
operator|(
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
operator|*
name|maxSetNumber
operator|/
literal|2
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"
operator|)
argument_list|)
expr_stmt|;
comment|/* Saves user's reassembly manipulation parameters */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|relativeSchemeId
operator|=
name|reassmManipParams
operator|.
name|relativeSchemeId
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|numOfFramesPerHashEntry
operator|=
name|reassmManipParams
operator|.
name|numOfFramesPerHashEntry
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|maxRessembledsSize
operator|=
name|reassmManipParams
operator|.
name|maxReassembledFrameLength
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|maxNumFramesInProcess
operator|=
name|reassmManipParams
operator|.
name|maxNumFramesInProcess
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeOutMode
operator|=
name|reassmManipParams
operator|.
name|timeOutMode
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|fqidForTimeOutFrames
operator|=
name|reassmManipParams
operator|.
name|fqidForTimeOutFrames
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|timeoutThresholdForReassmProcess
operator|=
name|reassmManipParams
operator|.
name|timeoutThresholdForReassmProcess
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataMemId
operator|=
name|reassmManipParams
operator|.
name|dataMemId
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|dataLiodnOffset
operator|=
name|reassmManipParams
operator|.
name|dataLiodnOffset
expr_stmt|;
comment|/* Creates and initializes the Reassembly common parameter table */
name|CreateReassCommonTable
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|res
operator|=
name|SetCapwapReassmManip
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|E_OK
condition|)
return|return
name|res
return|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapFragmentation
parameter_list|(
name|t_FmPcdManipFragCapwapParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|uint32_t
name|pcAndOffsetsReg
init|=
literal|0
decl_stmt|,
name|ccAdBaseReg
init|=
literal|0
decl_stmt|,
name|gmaskReg
init|=
literal|0
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|tmpRegNia
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
operator|->
name|sizeForFragmentation
operator|!=
literal|0xFFFF
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Manip
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* Allocation of fragmentation Action Descriptor */
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Fragmentation table descriptor"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Prepare the third Ad register (pcAndOffsets)- OperationCode */
name|pcAndOffsetsReg
operator|=
operator|(
name|uint32_t
operator|)
name|HMAN_OC_CAPWAP_FRAGMENTATION
expr_stmt|;
comment|/* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
name|ccAdBaseReg
operator|=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|ccAdBaseReg
operator||=
operator|(
name|p_ManipParams
operator|->
name|compressModeEn
operator|)
condition|?
name|FM_PCD_MANIP_CAPWAP_FRAG_COMPRESS_EN
else|:
literal|0
expr_stmt|;
comment|/* Set Scatter/Gather BPid */
if|if
condition|(
name|p_ManipParams
operator|->
name|sgBpidEn
condition|)
block|{
name|ccAdBaseReg
operator||=
name|FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_EN
expr_stmt|;
name|pcAndOffsetsReg
operator||=
operator|(
operator|(
name|p_ManipParams
operator|->
name|sgBpid
operator|<<
name|FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_SHIFT
operator|)
operator|&
name|FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_MASK
operator|)
expr_stmt|;
block|}
comment|/* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
name|gmaskReg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPcd
operator|->
name|capwapFrameIdAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|gmaskReg
operator||=
operator|(
literal|0xFF
operator|)
operator|<<
name|FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID
expr_stmt|;
comment|/* Set all Ad registers */
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|pcAndOffsets
argument_list|,
name|pcAndOffsetsReg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|ccAdBase
argument_list|,
name|ccAdBaseReg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
operator|->
name|gmask
argument_list|,
name|gmaskReg
argument_list|)
expr_stmt|;
comment|/* Saves user's fragmentation manipulation parameters */
name|p_Manip
operator|->
name|frag
operator|=
name|TRUE
expr_stmt|;
name|p_Manip
operator|->
name|sizeForFragmentation
operator|=
name|p_ManipParams
operator|->
name|sizeForFragmentation
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpRegNia
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Manip
operator|->
name|fragParams
operator|.
name|p_Frag
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
operator|(
name|uint32_t
operator|)
name|p_Manip
operator|->
name|sizeForFragmentation
operator|<<
name|FM_PCD_MANIP_CAPWAP_FRAG_CHECK_MTU_SHIFT
expr_stmt|;
name|tmpRegNia
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
name|HMAN_OC_CAPWAP_FRAG_CHECK
expr_stmt|;
name|tmpRegNia
operator||=
name|FM_PCD_MANIP_CAPWAP_FRAG_CHECK_CNIA
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpRegNia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|gmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Total frame counter - MUST be initialized to zero.*/
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateInitCapwapFrag
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_FmPortGetSetCcParams
name|fmPortGetSetCcParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPort
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_Ad
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_PcdParams
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|validate
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|setCcParams
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|type
operator|=
name|MANIP_EXTRA_SPACE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|FmPortGetSetCcParams
argument_list|(
name|h_FmPort
argument_list|,
operator|&
name|fmPortGetSetCcParams
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmPortGetSetCcParams
operator|.
name|getCcParams
operator|.
name|internalBufferOffset
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"manipExtraSpace must be larger than '0'"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CapwapManip
parameter_list|(
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|,
name|t_FmPcdManip
modifier|*
name|p_Manip
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_Ad
decl_stmt|;
name|t_FmPcdManipSpecialOffloadCapwapParams
modifier|*
name|p_Params
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpReg32
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_Params
operator|=
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|specialOffload
operator|.
name|u
operator|.
name|capwap
expr_stmt|;
name|p_Ad
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_Params
operator|->
name|dtls
operator|)
condition|?
name|FM_PCD_MANIP_CAPWAP_DTLS
else|:
literal|0
expr_stmt|;
comment|/* TODO - add 'qosSrc' */
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|HMAN_OC_CAPWAP_MANIP
expr_stmt|;
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
block|{
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|matchTblPtr
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|p_ManipParams
operator|->
name|h_NextManip
operator|)
operator|->
name|h_Ad
argument_list|)
operator|-
operator|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|physicalMuramBase
operator|)
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_MANIP_CAPWAP_NADEN
expr_stmt|;
block|}
name|WRITE_UINT32
argument_list|(
name|p_Ad
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_function
specifier|static
name|t_Handle
name|ManipOrStatsSetNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
modifier|*
name|p_Params
parameter_list|,
name|bool
name|stats
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|p_Manip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdManip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Manip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdManip
argument_list|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|type
operator|=
operator|(
operator|(
name|t_FmPcdManipParams
operator|*
operator|)
name|p_Params
operator|)
operator|->
name|type
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_Manip
operator|->
name|manipParams
argument_list|,
name|p_Params
argument_list|,
sizeof|sizeof
argument_list|(
name|p_Manip
operator|->
name|manipParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stats
condition|)
name|err
operator|=
name|CheckManipParamsAndSetType
argument_list|(
name|p_Manip
argument_list|,
operator|(
name|t_FmPcdManipParams
operator|*
operator|)
name|p_Params
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
else|else
name|err
operator|=
name|CheckStatsParamsAndSetType
argument_list|(
name|p_Manip
argument_list|,
operator|(
name|t_FmPcdStatsParams
operator|*
operator|)
name|p_Params
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Statistics node!"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Invalid header manipulation type"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|!=
name|HMAN_OC_IP_REASSEMBLY
operator|)
operator|&&
operator|(
name|p_Manip
operator|->
name|opcode
operator|!=
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
condition|)
block|{
comment|/* In Case of reassembly manipulation the reassembly action descriptor will          be defines later on */
if|if
condition|(
name|p_Manip
operator|->
name|muramAllocate
condition|)
block|{
name|p_Manip
operator|->
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|p_FmPcd
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM alloc for Manipulation action descriptor"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MemSet8
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_Manip
operator|->
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_Malloc
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Allocation of Manipulation action descriptor"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p_Manip
operator|->
name|h_FmPcd
operator|=
name|h_FmPcd
expr_stmt|;
return|return
name|p_Manip
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip
parameter_list|(
name|t_FmPcdManip
modifier|*
name|p_CrntMdfManip
parameter_list|,
name|t_List
modifier|*
name|h_NodesLst
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInformation
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_NodePtrOnCurrentMdfManip
init|=
name|NULL
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|t_Handle
name|p_AdTablePtOnCrntCurrentMdfNode
comment|/*, p_AdTableNewModified*/
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_CrntMdfManip->nodesLst
argument_list|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|p_NodePtrOnCurrentMdfManip
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_CcNodeInformation
operator|->
name|h_CcNode
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_NodePtrOnCurrentMdfManip
argument_list|)
expr_stmt|;
comment|/* Search in the previous node which exact index points on this current modified node for getting AD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_NodePtrOnCurrentMdfManip
operator|->
name|numOfKeys
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_NodePtrOnCurrentMdfManip
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
if|if
condition|(
name|p_NodePtrOnCurrentMdfManip
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
operator|==
operator|(
name|t_Handle
operator|)
name|p_CrntMdfManip
condition|)
block|{
if|if
condition|(
name|p_NodePtrOnCurrentMdfManip
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|p_StatsObj
condition|)
name|p_AdTablePtOnCrntCurrentMdfNode
operator|=
name|p_NodePtrOnCurrentMdfManip
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
else|else
name|p_AdTablePtOnCrntCurrentMdfNode
operator|=
name|PTR_MOVE
argument_list|(
name|p_NodePtrOnCurrentMdfManip
operator|->
name|h_AdTable
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|p_AdTablePtOnCrntCurrentMdfNode
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|h_NodesLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ASSERT_COND
argument_list|(
name|i
operator|!=
name|p_NodePtrOnCurrentMdfManip
operator|->
name|numOfKeys
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|BuildHmtd
parameter_list|(
name|uint8_t
modifier|*
name|p_Dest
parameter_list|,
name|uint8_t
modifier|*
name|p_Src
parameter_list|,
name|uint8_t
modifier|*
name|p_Hmcd
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_Error
name|err
decl_stmt|;
comment|/* Copy the HMTD */
name|MemCpy8
argument_list|(
name|p_Dest
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_Src
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Replace the HMCT table pointer  */
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Dest
operator|)
operator|->
name|hmcdBasePtr
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Hmcd
argument_list|)
operator|-
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_FmPcd
operator|)
operator|->
name|physicalMuramBase
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call Host Command to replace HMTD by a new HMTD */
name|err
operator|=
name|FmHcPcdCcDoDynamicChange
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Src
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Dest
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Failed in dynamic manip change, continued to the rest of the owners."
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPcdManipInitUpdate
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|int
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|level
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_FmTree
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|err
operator|=
name|UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix
argument_list|(
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Frag
condition|)
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
name|err
operator|=
name|UpdateInitCapwapFragmentation
argument_list|(
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
name|err
operator|=
name|UpdateInitCapwapReasm
argument_list|(
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
name|err
operator|=
name|UpdateIndxStats
argument_list|(
name|h_FmPcd
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
name|err
operator|=
name|UpdateInitReasm
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
name|err
operator|=
name|UpdateInitIpFrag
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
name|err
operator|=
name|UpdateInitCapwapFrag
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
name|err
operator|=
name|UpdateInitReasm
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
return|return
name|E_OK
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FmPcdManipModifyUpdate
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|int
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|UNUSED
argument_list|(
name|level
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"modify node with this type of manipulation  is not suppported"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|NUM_OF_TASKS
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_DATA
operator|)
operator|&&
operator|!
operator|(
name|p_Manip
operator|->
name|shadowUpdateParams
operator|&
name|OFFSET_OF_PR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
name|err
operator|=
name|UpdateModifyCapwapFragmenation
argument_list|(
name|p_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
default|default:
return|return
name|E_OK
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FmPcdManipUpdate
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|int
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|,
name|bool
name|modify
parameter_list|)
block|{
name|t_Error
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|modify
condition|)
name|err
operator|=
name|FmPcdManipInitUpdate
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|FmPcdManipModifyUpdate
argument_list|(
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|FmPcdManipUpdateOwner
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|owner
operator|++
expr_stmt|;
else|else
block|{
name|ASSERT_COND
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|owner
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|owner
operator|--
expr_stmt|;
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_List
modifier|*
name|FmPcdManipGetNodeLstPointedOnThisManip
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Manip
argument_list|)
expr_stmt|;
return|return
operator|&
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|nodesLst
return|;
block|}
end_function

begin_function
name|t_List
modifier|*
name|FmPcdManipGetSpinlock
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Manip
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
operator|)
operator|->
name|h_Spinlock
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipCheckParamsForCcNextEngine
parameter_list|(
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|,
name|uint32_t
modifier|*
name|requiredAction
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10))*/
name|bool
name|pointFromCc
init|=
name|TRUE
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Manip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
operator|)
expr_stmt|;
operator|*
name|requiredAction
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p_Manip
condition|)
block|{
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
name|p_Manip
operator|->
name|cnia
operator|=
name|TRUE
expr_stmt|;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
operator|*
name|requiredAction
operator|=
name|UPDATE_NIA_ENQ_WITHOUT_DMA
expr_stmt|;
case|case
operator|(
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
operator|)
case|:
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
operator|)
operator|&&
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_CC
operator|)
operator|&&
operator|(
name|FmPcdCcGetParseCode
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
operator|!=
name|CC_PC_GENERIC_IC_HASH_INDEXED
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateManipIc
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|FmPcdCcGetOffset
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
operator|*
name|requiredAction
operator|=
name|UPDATE_NIA_ENQ_WITHOUT_DMA
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IPSEC_MANIP
operator|)
case|:
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_MANIP
operator|)
case|:
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|p_Manip
operator|->
name|ownerTmp
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|MANIP_IS_CASCADED
argument_list|(
name|p_Manip
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Can't have a cascaded manipulation when and Next Engine is CC"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MANIP_IS_FIRST
argument_list|(
name|p_Manip
argument_list|)
operator|&&
name|pointFromCc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"invalid type of header manipulation for this state"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_Manip
operator|=
name|p_Manip
operator|->
name|h_NextManip
expr_stmt|;
name|pointFromCc
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipCheckParamsWithCcNodeParams
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdCcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|ownerTmp
operator|!=
name|FmPcdCcGetNumOfKeys
argument_list|(
name|h_FmPcdCcNode
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
if|if
condition|(
name|p_Manip
operator|->
name|h_Frag
condition|)
block|{
if|if
condition|(
name|p_Manip
operator|->
name|ownerTmp
operator|!=
name|FmPcdCcGetNumOfKeys
argument_list|(
name|h_FmPcdCcNode
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateManipIc
argument_list|(
name|h_Manip
argument_list|,
name|FmPcdCcGetOffset
argument_list|(
name|h_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
default|default:
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|FmPcdManipUpdateAdResultForCc
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_CcNextEngineParams
parameter_list|,
name|t_Handle
name|p_Ad
parameter_list|,
name|t_Handle
modifier|*
name|p_AdNewPtr
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
comment|/* This routine creates a Manip AD and can return in "p_AdNewPtr"      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNextEngineParams
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Ad
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_AdNewPtr
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|h_Manip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* According to "type", either build& initialize a new AD (p_AdNew) or initialize      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|fqid
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|fqid
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|plcrProfile
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|plcrProfile
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|nia
argument_list|,
operator|(
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|nia
argument_list|)
expr_stmt|;
operator|*
name|p_AdNewPtr
operator|=
name|NULL
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
case|case
operator|(
name|HMAN_OC_IPSEC_MANIP
operator|)
case|:
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_MANIP
operator|)
case|:
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
operator|(
name|p_CcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_DONE
operator|)
operator|&&
operator|(
operator|!
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Ad
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_Manip
operator|->
name|h_Ad
argument_list|,
sizeof|sizeof
argument_list|(
name|t_AdOfTypeContLookup
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|,
name|GET_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|)
operator|&
operator|~
name|FM_PCD_MANIP_IP_CNIA
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
operator|*
name|p_AdNewPtr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
if|if
condition|(
name|FmPcdManipIpReassmIsIpv6Hdr
argument_list|(
name|p_Manip
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6Assigned
condition|)
block|{
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Ad
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6Assigned
operator|=
name|TRUE
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|h_Manip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|ipv6Assigned
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Ad
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Ad
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|*
name|p_AdNewPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|t_AdOfTypeContLookup
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_AdNewPtr
operator|=
name|NULL
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Ad
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Ad
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|*
name|p_AdNewPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|t_AdOfTypeContLookup
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_AdNewPtr
operator|=
name|NULL
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
case|case
operator|(
name|HMAN_OC
operator|)
case|:
comment|/* Allocate and initialize HMTD */
operator|*
name|p_AdNewPtr
operator|=
name|p_Manip
operator|->
name|h_Ad
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|FmPcdManipUpdateAdContLookupForCc
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|p_Ad
parameter_list|,
name|t_Handle
modifier|*
name|p_AdNewPtr
parameter_list|,
name|uint32_t
name|adTableOffset
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
comment|/* This routine creates a Manip AD and can return in "p_AdNewPtr"      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|h_Manip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|ccAdBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|matchTblPtr
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|matchTblPtr
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|pcAndOffsets
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|pcAndOffsets
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|gmask
argument_list|,
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_Ad
operator|)
operator|)
operator|->
name|gmask
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|,
operator|(
name|GET_UINT32
argument_list|(
operator|(
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|ccAdBase
argument_list|)
operator||
name|adTableOffset
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_AdNewPtr
operator|=
name|NULL
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
case|case
operator|(
name|HMAN_OC
operator|)
case|:
comment|/* Initialize HMTD within the match table*/
name|MemSet8
argument_list|(
name|p_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* copy the existing HMTD */
comment|/* ask Alla - memcpy??? */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Ad
argument_list|,
name|p_Manip
operator|->
name|h_Ad
argument_list|,
sizeof|sizeof
argument_list|(
name|t_Hmtd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update NADEN to be "1"*/
name|WRITE_UINT16
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|cfg
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|GET_UINT16
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|cfg
argument_list|)
operator||
name|HMTD_CFG_NEXT_AD_EN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update next action descriptor */
name|WRITE_UINT16
argument_list|(
operator|(
operator|(
name|t_Hmtd
operator|*
operator|)
name|p_Ad
operator|)
operator|->
name|nextAdIdx
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|adTableOffset
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark that Manip's HMTD is not used */
operator|*
name|p_AdNewPtr
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipBuildIpReassmScheme
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_Handle
name|h_NetEnv
parameter_list|,
name|t_Handle
name|h_CcTree
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|bool
name|isIpv4
parameter_list|,
name|uint8_t
name|groupId
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_FmPcdKgSchemeParams
modifier|*
name|p_SchemeParams
init|=
name|NULL
decl_stmt|;
name|t_Handle
name|h_Scheme
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_NetEnv
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
comment|/* scheme was already build, no need to check for IPv6 */
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
condition|)
return|return
name|E_OK
return|;
if|if
condition|(
name|isIpv4
condition|)
block|{
name|h_Scheme
operator|=
name|FmPcdKgGetSchemeHandle
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|relativeSchemeId
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_Scheme
condition|)
block|{
comment|/* scheme was found */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
operator|=
name|h_Scheme
expr_stmt|;
return|return
name|E_OK
return|;
block|}
block|}
else|else
block|{
name|h_Scheme
operator|=
name|FmPcdKgGetSchemeHandle
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|relativeSchemeId
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_Scheme
condition|)
block|{
comment|/* scheme was found */
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
operator|=
name|h_Scheme
expr_stmt|;
return|return
name|E_OK
return|;
block|}
block|}
name|p_SchemeParams
operator|=
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdKgSchemeParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SchemeParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation failed for scheme"
operator|)
argument_list|)
expr_stmt|;
comment|/* Configures the IPv4 or IPv6 scheme*/
name|memset
argument_list|(
name|p_SchemeParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKgSchemeParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
operator|=
name|h_NetEnv
expr_stmt|;
name|p_SchemeParams
operator|->
name|id
operator|.
name|relativeSchemeId
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|isIpv4
operator|==
name|TRUE
operator|)
condition|?
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|relativeSchemeId
index|[
literal|0
index|]
else|:
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|relativeSchemeId
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p_SchemeParams
operator|->
name|schemeCounter
operator|.
name|update
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|p_SchemeParams
operator|->
name|alwaysDirect
operator|=
name|TRUE
expr_stmt|;
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|p_SchemeParams
operator|->
name|keyExtractAndHashParams
operator|.
name|hashDistributionNumOfFqids
operator|=
literal|1
expr_stmt|;
name|p_SchemeParams
operator|->
name|baseFqid
operator|=
literal|0xFFFFFF
expr_stmt|;
comment|/*TODO- baseFqid*/
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|setIpReassmSchemeParams
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeParams
argument_list|,
name|h_CcTree
argument_list|,
name|isIpv4
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
comment|/* Sets the new scheme */
if|if
condition|(
name|isIpv4
condition|)
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
operator|=
name|FM_PCD_KgSchemeSet
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeParams
argument_list|)
expr_stmt|;
else|else
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
operator|=
name|FM_PCD_KgSchemeSet
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_SchemeParams
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipDeleteIpReassmSchemes
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
operator|)
operator|&&
operator|!
name|FmPcdKgIsSchemeHasOwners
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
argument_list|)
condition|)
name|FM_PCD_KgSchemeDelete
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv4Scheme
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
operator|)
operator|&&
operator|!
name|FmPcdKgIsSchemeHasOwners
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
argument_list|)
condition|)
name|FM_PCD_KgSchemeDelete
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|ip
operator|.
name|h_Ipv6Scheme
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdManipIpReassmIsIpv6Hdr
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipBuildCapwapReassmScheme
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_Handle
name|h_NetEnv
parameter_list|,
name|t_Handle
name|h_CcTree
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|uint8_t
name|groupId
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|t_FmPcdKgSchemeParams
modifier|*
name|p_SchemeParams
init|=
name|NULL
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_NetEnv
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
comment|/* scheme was already build, no need to check for IPv6 */
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Scheme
condition|)
return|return
name|E_OK
return|;
name|p_SchemeParams
operator|=
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdKgSchemeParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SchemeParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Memory allocation failed for scheme"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_SchemeParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKgSchemeParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
operator|=
name|h_NetEnv
expr_stmt|;
name|p_SchemeParams
operator|->
name|id
operator|.
name|relativeSchemeId
operator|=
operator|(
name|uint8_t
operator|)
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|relativeSchemeId
expr_stmt|;
name|p_SchemeParams
operator|->
name|schemeCounter
operator|.
name|update
operator|=
name|TRUE
expr_stmt|;
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
operator|=
name|TRUE
expr_stmt|;
name|setCapwapReassmSchemeParams
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeParams
argument_list|,
name|h_CcTree
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Scheme
operator|=
name|FM_PCD_KgSchemeSet
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_SchemeParams
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdManipDeleteCapwapReassmSchemes
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Scheme
condition|)
name|FM_PCD_KgSchemeDelete
argument_list|(
name|p_Manip
operator|->
name|reassmParams
operator|.
name|capwap
operator|.
name|h_Scheme
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
end_if

begin_function
name|t_Handle
name|FmPcdManipApplSpecificBuild
parameter_list|(
name|void
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|p_Manip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdManip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Manip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdManip
argument_list|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
expr_stmt|;
name|p_Manip
operator|->
name|muramAllocate
operator|=
name|FALSE
expr_stmt|;
name|p_Manip
operator|->
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|XX_Malloc
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Ad
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Allocation of Manipulation action descriptor"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
comment|/*Application specific = type of flowId index, move internal frame header from data to IC,      SEC errors check*/
if|if
condition|(
name|MvIntFrameHeaderFromFrameToBufferPrefix
argument_list|(
name|p_Manip
argument_list|,
name|TRUE
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_Free
argument_list|(
name|p_Manip
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_Manip
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdManipIsCapwapApplSpecific
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Manip
argument_list|)
expr_stmt|;
return|return
call|(
name|bool
call|)
argument_list|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
end_comment

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PCD_ManipNodeSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_ManipParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_Manip
operator|=
name|ManipOrStatsSetNode
argument_list|(
name|h_FmPcd
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_ManipParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_IP_REASSEMBLY
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_IP_FRAGMENTATION
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_IPSEC_MANIP
operator|)
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_MANIP
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
operator|)
operator|&&
operator|(
operator|!
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|p_FmPcd
argument_list|)
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Advanced-offload must be enabled"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_Manip
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
operator|->
name|h_Spinlock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|INIT_LIST
argument_list|(
operator|&
name|p_Manip
operator|->
name|nodesLst
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
comment|/* IpReassembly */
name|err
operator|=
name|IpReassembly
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|reassem
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
comment|/* IpFragmentation */
name|err
operator|=
name|IpFragmentation
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|frag
operator|.
name|u
operator|.
name|ipFrag
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|err
operator|=
name|IPManip
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_IPSEC_MANIP
operator|)
case|:
name|err
operator|=
name|IPSecManip
argument_list|(
name|p_ManipParams
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
comment|/* CapwapReassembly */
name|err
operator|=
name|CapwapReassembly
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|reassem
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
comment|/* CapwapFragmentation */
name|err
operator|=
name|CapwapFragmentation
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|frag
operator|.
name|u
operator|.
name|capwapFrag
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_MANIP
operator|)
case|:
name|err
operator|=
name|CapwapManip
argument_list|(
name|p_ManipParams
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
case|case
operator|(
name|HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR
operator|)
case|:
comment|/* HmanType1 */
name|err
operator|=
name|RmvHdrTillSpecLocNOrInsrtIntFrmHdr
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|rmvParams
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
name|err
operator|=
name|CapwapFragmentation
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|u
operator|.
name|capwapFragParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|,
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|sgBpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|insrt
condition|)
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
expr_stmt|;
case|case
operator|(
name|HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER
operator|)
case|:
comment|/* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
name|err
operator|=
name|InsrtHdrByTempl
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|u
operator|.
name|hdr
operator|.
name|insrtParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
name|err
operator|=
name|CapwapReassembly
argument_list|(
operator|&
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|u
operator|.
name|capwapReasmParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|,
name|p_ManipParams
operator|->
name|fragOrReasmParams
operator|.
name|sgBpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|rmv
condition|)
name|p_Manip
operator|->
name|opcode
operator|=
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
expr_stmt|;
case|case
operator|(
name|HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST
operator|)
case|:
comment|/*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
name|err
operator|=
name|CapwapRmvDtlsHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX
operator|)
case|:
comment|/*Application Specific type 1*/
name|err
operator|=
name|MvIntFrameHeaderFromFrameToBufferPrefix
argument_list|(
name|p_Manip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
case|case
operator|(
name|HMAN_OC
operator|)
case|:
comment|/* New Manip */
name|err
operator|=
name|CreateManipActionNew
argument_list|(
name|p_Manip
argument_list|,
name|p_ManipParams
argument_list|)
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED HEADER MANIPULATION TYPE"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_ManipParams
operator|->
name|h_NextManip
condition|)
block|{
comment|/* in the check routine we've verified that h_NextManip has no owners          * and that only supported types are allowed. */
name|p_Manip
operator|->
name|h_NextManip
operator|=
name|p_ManipParams
operator|->
name|h_NextManip
expr_stmt|;
comment|/* save a "prev" pointer in h_NextManip */
name|MANIP_SET_PREV
argument_list|(
name|p_Manip
operator|->
name|h_NextManip
argument_list|,
name|p_Manip
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|p_Manip
operator|->
name|h_NextManip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|p_Manip
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ManipNodeReplace
parameter_list|(
name|t_Handle
name|h_Manip
parameter_list|,
name|t_FmPcdManipParams
modifier|*
name|p_ManipParams
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_Manip
decl_stmt|,
modifier|*
name|p_FirstManip
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_FmPcd
operator|)
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint8_t
modifier|*
name|p_WholeHmct
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_ShadowHmct
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_Hmtd
init|=
name|NULL
decl_stmt|;
name|t_List
name|lstOfNodeshichPointsOnCrntMdfManip
decl_stmt|,
modifier|*
name|p_Pos
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ManipParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|lstOfNodeshichPointsOnCrntMdfManip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_ManipParams
operator|->
name|type
operator|!=
name|e_FM_PCD_MANIP_HDR
operator|)
operator|||
operator|(
name|p_Manip
operator|->
name|type
operator|!=
name|e_FM_PCD_MANIP_HDR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|opcode
operator|==
name|HMAN_OC
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Manip
operator|->
name|manipParams
operator|.
name|h_NextManip
operator|==
name|p_Manip
operator|->
name|h_NextManip
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_Manip
operator|->
name|manipParams
argument_list|,
name|p_ManipParams
argument_list|,
sizeof|sizeof
argument_list|(
name|p_Manip
operator|->
name|manipParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|manipParams
operator|.
name|h_NextManip
operator|=
name|p_Manip
operator|->
name|h_NextManip
expr_stmt|;
comment|/* The replacement of the HdrManip depends on the node type.*/
comment|/*      * (1) If this is an independent node, all its owners should be updated.      *      * (2) If it is the head of a cascaded chain (it does not have a "prev" but      * it has a "next" and it has a "cascaded" indication), the next      * node remains unchanged, and the behavior is as in (1).      *      * (3) If it is not the head, but a part of a cascaded chain, in can be      * also replaced as a regular node with just one owner.      *      * (4) If it is a part of a chain implemented as a unified table, the      * whole table is replaced and the owners of the head node must be updated.      *      */
comment|/* lock shadow */
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_CcShadow
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"CC Shadow not allocated"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
comment|/* this routine creates a new manip action in the CC Shadow. */
name|err
operator|=
name|CreateManipActionShadow
argument_list|(
name|p_Manip
argument_list|,
name|p_ManipParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* If the owners list is empty (these are NOT the "owners" counter, but pointers from CC)      * replace only HMTD and no lcok is required. Otherwise      * lock the whole PCD      * In case 4 MANIP_IS_UNIFIED_NON_FIRST(p_Manip) - Use the head node instead. */
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|p_ShadowHmct
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|PTR_MOVE
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p_FirstManip
operator|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_Manip
argument_list|,
name|e_MANIP_HANDLER_TABLE_OWNER
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FirstManip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_FirstManip
operator|->
name|nodesLst
argument_list|)
condition|)
name|UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip
argument_list|(
name|p_FirstManip
argument_list|,
operator|&
name|lstOfNodeshichPointsOnCrntMdfManip
argument_list|)
expr_stmt|;
name|p_Hmtd
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_Manip
argument_list|,
name|e_MANIP_HMTD
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Hmtd
argument_list|)
expr_stmt|;
name|BuildHmtd
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_Hmtd
argument_list|,
name|p_ShadowHmct
argument_list|,
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|)
argument_list|)
expr_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&lstOfNodeshichPointsOnCrntMdfManip
argument_list|)
block|{
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|BuildHmtd
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_CcNodeInfo
operator|->
name|h_CcNode
argument_list|,
name|p_ShadowHmct
argument_list|,
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_WholeHmct
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_Manip
argument_list|,
name|e_MANIP_HMCT
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_WholeHmct
argument_list|)
expr_stmt|;
comment|/* re-build the HMCT n the original location */
name|err
operator|=
name|CreateManipActionBackToOrig
argument_list|(
name|p_Manip
argument_list|,
name|p_ManipParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_Hmtd
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|GetManipInfo
argument_list|(
name|p_Manip
argument_list|,
name|e_MANIP_HMTD
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Hmtd
argument_list|)
expr_stmt|;
name|BuildHmtd
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_Hmtd
argument_list|,
name|p_WholeHmct
argument_list|,
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
argument_list|)
expr_stmt|;
comment|/* If NCSW_LIST> 0, create a list of p_Ad's that point to the HMCT. Join also t_HMTD to this list.      * For each p_Hmct (from list+fixed):      * call Host Command to replace HMTD by a new one */
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&lstOfNodeshichPointsOnCrntMdfManip
argument_list|)
block|{
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|BuildHmtd
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_CcNodeInfo
operator|->
name|h_CcNode
argument_list|,
name|p_WholeHmct
argument_list|,
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|ReleaseLst
argument_list|(
operator|&
name|lstOfNodeshichPointsOnCrntMdfManip
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
comment|/* unlock shadow */
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ManipNodeDelete
parameter_list|(
name|t_Handle
name|h_ManipNode
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_ManipNode
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|owner
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"This manipulation node not be removed because this node is occupied, first - unbind this node "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_NextManip
condition|)
block|{
name|MANIP_SET_PREV
argument_list|(
name|p_Manip
operator|->
name|h_NextManip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|p_Manip
operator|->
name|h_NextManip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_Manip
operator|->
name|p_Hmct
operator|&&
operator|(
name|MANIP_IS_UNIFIED_FIRST
argument_list|(
name|p_Manip
argument_list|)
operator|||
operator|!
name|MANIP_IS_UNIFIED
argument_list|(
name|p_Manip
argument_list|)
operator|)
condition|)
name|FM_MURAM_FreeMem
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_Manip
operator|->
name|h_FmPcd
operator|)
operator|->
name|h_FmMuram
argument_list|,
name|p_Manip
operator|->
name|p_Hmct
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Manip
operator|->
name|h_Spinlock
condition|)
block|{
name|XX_FreeSpinlock
argument_list|(
name|p_Manip
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|p_Manip
operator|->
name|h_Spinlock
operator|=
name|NULL
expr_stmt|;
block|}
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_Manip
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|h_ManipNode
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_ManipGetStatistics
parameter_list|(
name|t_Handle
name|h_ManipNode
parameter_list|,
name|t_FmPcdManipStats
modifier|*
name|p_FmPcdManipStats
parameter_list|)
block|{
name|t_FmPcdManip
modifier|*
name|p_Manip
init|=
operator|(
name|t_FmPcdManip
operator|*
operator|)
name|h_ManipNode
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Manip
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdManipStats
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
case|case
operator|(
name|HMAN_OC_IP_REASSEMBLY
operator|)
case|:
return|return
name|IpReassemblyStats
argument_list|(
name|p_Manip
argument_list|,
operator|&
name|p_FmPcdManipStats
operator|->
name|u
operator|.
name|reassem
operator|.
name|u
operator|.
name|ipReassem
argument_list|)
return|;
case|case
operator|(
name|HMAN_OC_IP_FRAGMENTATION
operator|)
case|:
return|return
name|IpFragmentationStats
argument_list|(
name|p_Manip
argument_list|,
operator|&
name|p_FmPcdManipStats
operator|->
name|u
operator|.
name|frag
operator|.
name|u
operator|.
name|ipFrag
argument_list|)
return|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|HMAN_OC_CAPWAP_REASSEMBLY
operator|)
case|:
return|return
name|CapwapReassemblyStats
argument_list|(
name|p_Manip
argument_list|,
operator|&
name|p_FmPcdManipStats
operator|->
name|u
operator|.
name|reassem
operator|.
name|u
operator|.
name|capwapReassem
argument_list|)
return|;
case|case
operator|(
name|HMAN_OC_CAPWAP_FRAGMENTATION
operator|)
case|:
return|return
name|CapwapFragmentationStats
argument_list|(
name|p_Manip
argument_list|,
operator|&
name|p_FmPcdManipStats
operator|->
name|u
operator|.
name|frag
operator|.
name|u
operator|.
name|capwapFrag
argument_list|)
return|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"no statistics to this type of manip"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|&&
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|)
end_if

begin_function
name|t_Handle
name|FM_PCD_StatisticsSetNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdStatsParams
modifier|*
name|p_StatsParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdManip
modifier|*
name|p_Manip
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_StatsParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_Manip
operator|=
name|ManipOrStatsSetNode
argument_list|(
name|h_FmPcd
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_StatsParams
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Manip
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|p_Manip
operator|->
name|opcode
condition|)
block|{
case|case
operator|(
name|HMAN_OC_CAPWAP_INDEXED_STATS
operator|)
case|:
comment|/* Indexed statistics */
name|err
operator|=
name|IndxStats
argument_list|(
name|p_StatsParams
argument_list|,
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"UNSUPPORTED Statistics type"
operator|)
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|ReleaseManipHandler
argument_list|(
name|p_Manip
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Manip
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_Manip
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(FM_CAPWAP_SUPPORT)&& (DPAA_VERSION == 10)) */
end_comment

end_unit

