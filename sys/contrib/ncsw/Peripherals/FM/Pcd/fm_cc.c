begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_cc.c   @Description   FM Coarse Classifier implementation  */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_muram_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_cc.h"
end_include

begin_include
include|#
directive|include
file|"crc64.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|t_Error
name|CcRootTryLock
parameter_list|(
name|t_Handle
name|h_FmPcdCcTree
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcTree
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcdCcTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmPcdLockTryLock
argument_list|(
name|p_FmPcdCcTree
operator|->
name|p_Lock
argument_list|)
condition|)
return|return
name|E_OK
return|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|CcRootReleaseLock
parameter_list|(
name|t_Handle
name|h_FmPcdCcTree
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcTree
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcdCcTree
argument_list|)
expr_stmt|;
name|FmPcdLockUnlock
argument_list|(
name|p_FmPcdCcTree
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateNodeOwner
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|p_CcNode
operator|->
name|owners
operator|++
expr_stmt|;
else|else
block|{
name|ASSERT_COND
argument_list|(
name|p_CcNode
operator|->
name|owners
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|owners
operator|--
expr_stmt|;
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|t_FmPcdStatsObj
modifier|*
name|DequeueStatsObj
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|)
block|{
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
init|=
name|NULL
decl_stmt|;
name|t_List
modifier|*
name|p_Next
decl_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
name|p_List
argument_list|)
condition|)
block|{
name|p_Next
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|p_List
argument_list|)
expr_stmt|;
name|p_StatsObj
operator|=
name|NCSW_LIST_OBJECT
argument_list|(
name|p_Next
argument_list|,
name|t_FmPcdStatsObj
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|NCSW_LIST_DelAndInit
argument_list|(
name|p_Next
argument_list|)
expr_stmt|;
block|}
return|return
name|p_StatsObj
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|void
name|EnqueueStatsObj
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|,
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
parameter_list|)
block|{
name|NCSW_LIST_AddToTail
argument_list|(
operator|&
name|p_StatsObj
operator|->
name|node
argument_list|,
name|p_List
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeStatObjects
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|,
name|t_Handle
name|h_FmMuram
parameter_list|)
block|{
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|;
while|while
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
name|p_List
argument_list|)
condition|)
block|{
name|p_StatsObj
operator|=
name|DequeueStatsObj
argument_list|(
name|p_List
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_StatsObj
operator|->
name|h_StatsAd
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_StatsObj
operator|->
name|h_StatsCounters
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_FmPcdStatsObj
modifier|*
name|GetStatsObj
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|)
block|{
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|;
name|t_Handle
name|h_FmMuram
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
comment|/* If 'maxNumOfKeys' was passed, all statistics object were preallocated      upon node initialization */
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
name|p_StatsObj
operator|=
name|DequeueStatsObj
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h_FmMuram
operator|=
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|)
operator|)
operator|->
name|h_FmMuram
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmMuram
argument_list|)
expr_stmt|;
name|p_StatsObj
operator|=
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdStatsObj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_StatsObj
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"statistics object"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_StatsObj
operator|->
name|h_StatsAd
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_StatsObj
operator|->
name|h_StatsAd
condition|)
block|{
name|XX_Free
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for statistics ADs"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MemSet8
argument_list|(
name|p_StatsObj
operator|->
name|h_StatsAd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_StatsObj
operator|->
name|h_StatsCounters
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_CcNode
operator|->
name|countersArraySize
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_StatsObj
operator|->
name|h_StatsCounters
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_StatsObj
operator|->
name|h_StatsAd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for statistics counters"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MemSet8
argument_list|(
name|p_StatsObj
operator|->
name|h_StatsCounters
argument_list|,
literal|0
argument_list|,
name|p_CcNode
operator|->
name|countersArraySize
argument_list|)
expr_stmt|;
block|}
return|return
name|p_StatsObj
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PutStatsObj
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
parameter_list|)
block|{
name|t_Handle
name|h_FmMuram
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
comment|/* If 'maxNumOfKeys' was passed, all statistics object were preallocated      upon node initialization and now will be enqueued back to the list */
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
comment|/* Nullify counters */
name|MemSet8
argument_list|(
name|p_StatsObj
operator|->
name|h_StatsCounters
argument_list|,
literal|0
argument_list|,
name|p_CcNode
operator|->
name|countersArraySize
argument_list|)
expr_stmt|;
name|EnqueueStatsObj
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|,
name|p_StatsObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h_FmMuram
operator|=
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|)
operator|)
operator|->
name|h_FmMuram
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmMuram
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_StatsObj
operator|->
name|h_StatsAd
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_StatsObj
operator|->
name|h_StatsCounters
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|SetStatsCounters
parameter_list|(
name|t_AdOfTypeStats
modifier|*
name|p_StatsAd
parameter_list|,
name|uint32_t
name|statsCountersAddr
parameter_list|)
block|{
name|uint32_t
name|tmp
init|=
operator|(
name|statsCountersAddr
operator|&
name|FM_PCD_AD_STATS_COUNTERS_ADDR_MASK
operator|)
decl_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_StatsAd
operator|->
name|statsTableAddr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateStatsAd
parameter_list|(
name|t_FmPcdCcStatsParams
modifier|*
name|p_FmPcdCcStatsParams
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|uint64_t
name|physicalMuramBase
parameter_list|)
block|{
name|t_AdOfTypeStats
modifier|*
name|p_StatsAd
decl_stmt|;
name|uint32_t
name|statsCountersAddr
decl_stmt|,
name|nextActionAddr
decl_stmt|,
name|tmp
decl_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|uint32_t
name|frameLengthRangesAddr
decl_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|p_StatsAd
operator|=
operator|(
name|t_AdOfTypeStats
operator|*
operator|)
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
expr_stmt|;
name|tmp
operator|=
name|FM_PCD_AD_STATS_TYPE
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsFLRs
condition|)
block|{
name|frameLengthRangesAddr
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsFLRs
argument_list|)
operator|-
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
name|frameLengthRangesAddr
operator|&
name|FM_PCD_AD_STATS_FLR_ADDR_MASK
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|WRITE_UINT32
argument_list|(
name|p_StatsAd
operator|->
name|profileTableAddr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|nextActionAddr
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|h_Ad
argument_list|)
operator|-
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|nextActionAddr
operator|<<
name|FM_PCD_AD_STATS_NEXT_ACTION_SHIFT
operator|)
operator|&
name|FM_PCD_AD_STATS_NEXT_ACTION_MASK
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
name|FM_PCD_AD_STATS_NAD_EN
operator||
name|FM_PCD_AD_STATS_OP_CODE
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsFLRs
condition|)
name|tmp
operator||=
name|FM_PCD_AD_STATS_FLR_EN
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|WRITE_UINT32
argument_list|(
name|p_StatsAd
operator|->
name|nextActionIndx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|statsCountersAddr
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsCounters
argument_list|)
operator|-
name|physicalMuramBase
operator|)
argument_list|)
expr_stmt|;
name|SetStatsCounters
argument_list|(
name|p_StatsAd
argument_list|,
name|statsCountersAddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FillAdOfTypeContLookup
parameter_list|(
name|t_Handle
name|h_Ad
parameter_list|,
name|t_FmPcdCcStatsParams
modifier|*
name|p_FmPcdCcStatsParams
parameter_list|,
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|p_CcNode
parameter_list|,
name|t_Handle
name|h_Manip
parameter_list|,
name|t_Handle
name|h_FrmReplic
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_Node
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_CcNode
decl_stmt|;
name|t_AdOfTypeContLookup
modifier|*
name|p_AdContLookup
init|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_Handle
name|h_TmpAd
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_Handle
name|p_AdNewPtr
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|h_Manip
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|h_FrmReplic
argument_list|)
expr_stmt|;
comment|/* there are 3 cases handled in this routine of building a "Continue lookup" type AD.      * Case 1: No Manip. The action descriptor is built within the match table.      *         p_AdResult = p_AdNewPtr;      * Case 2: Manip exists. A new AD is created - p_AdNewPtr. It is initialized      *         either in the FmPcdManipUpdateAdResultForCc routine or it was already      *         initialized and returned here.      *         p_AdResult (within the match table) will be initialized after      *         this routine returns and point to the existing AD.      * Case 3: Manip exists. The action descriptor is built within the match table.      *         FmPcdManipUpdateAdContLookupForCc returns a NULL p_AdNewPtr.      */
comment|/* As default, the "new" ptr is the current one. i.e. the content of the result      * AD will be written into the match table itself (case (1))*/
name|p_AdNewPtr
operator|=
name|p_AdContLookup
expr_stmt|;
comment|/* Initialize an action descriptor, if current statistics mode requires an Ad */
if|if
condition|(
name|p_FmPcdCcStatsParams
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsCounters
argument_list|)
expr_stmt|;
comment|/* Swapping addresses between statistics Ad and the current lookup AD */
name|h_TmpAd
operator|=
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
expr_stmt|;
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
operator|=
name|h_Ad
expr_stmt|;
name|h_Ad
operator|=
name|h_TmpAd
expr_stmt|;
name|p_AdNewPtr
operator|=
name|h_Ad
expr_stmt|;
name|p_AdContLookup
operator|=
name|h_Ad
expr_stmt|;
comment|/* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
name|UpdateStatsAd
argument_list|(
name|p_FmPcdCcStatsParams
argument_list|,
name|h_Ad
argument_list|,
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DPAA_VERSION
operator|>=
literal|11
if|if
condition|(
name|h_Manip
operator|&&
name|h_FrmReplic
condition|)
name|FmPcdManipUpdateAdContLookupForCc
argument_list|(
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
operator|&
name|p_AdNewPtr
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|FrmReplicGroupGetSourceTableDescriptor
argument_list|(
name|h_FrmReplic
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h_FrmReplic
condition|)
name|FrmReplicGroupUpdateAd
argument_list|(
name|h_FrmReplic
argument_list|,
name|h_Ad
argument_list|,
operator|&
name|p_AdNewPtr
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|h_Manip
condition|)
name|FmPcdManipUpdateAdContLookupForCc
argument_list|(
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
operator|&
name|p_AdNewPtr
argument_list|,
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
comment|/*no check for opcode of manip - this step can be reached only with capwap_applic_specific*/
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_Node
operator|->
name|h_AdTable
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
else|#
directive|else
comment|/* not FM_CAPWAP_SUPPORT */
argument_list|(
name|uint32_t
argument_list|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_Node
operator|->
name|h_Ad
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
endif|#
directive|endif
comment|/* not FM_CAPWAP_SUPPORT */
argument_list|)
expr_stmt|;
comment|/* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
if|if
condition|(
name|p_AdNewPtr
condition|)
block|{
comment|/* cases (1)& (2) */
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|FM_PCD_AD_CONT_LOOKUP_TYPE
expr_stmt|;
name|tmpReg32
operator||=
name|p_Node
operator|->
name|sizeOfExtraction
condition|?
operator|(
operator|(
name|p_Node
operator|->
name|sizeOfExtraction
operator|-
literal|1
operator|)
operator|<<
literal|24
operator|)
else|:
literal|0
expr_stmt|;
name|tmpReg32
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Node
operator|->
name|h_AdTable
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_AdContLookup
operator|->
name|ccAdBase
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|p_Node
operator|->
name|numOfKeys
operator|<<
literal|24
expr_stmt|;
name|tmpReg32
operator||=
operator|(
name|p_Node
operator|->
name|lclMask
condition|?
name|FM_PCD_AD_CONT_LOOKUP_LCL_MASK
else|:
literal|0
operator|)
expr_stmt|;
name|tmpReg32
operator||=
name|p_Node
operator|->
name|h_KeysMatchTable
condition|?
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_Node
operator|->
name|h_KeysMatchTable
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
else|:
literal|0
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_AdContLookup
operator|->
name|matchTblPtr
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
literal|0
expr_stmt|;
name|tmpReg32
operator||=
name|p_Node
operator|->
name|prsArrayOffset
operator|<<
literal|24
expr_stmt|;
name|tmpReg32
operator||=
name|p_Node
operator|->
name|offset
operator|<<
literal|16
expr_stmt|;
name|tmpReg32
operator||=
name|p_Node
operator|->
name|parseCode
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_AdContLookup
operator|->
name|pcAndOffsets
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|p_AdContLookup
operator|->
name|gmask
argument_list|,
name|p_Node
operator|->
name|p_GlblMask
argument_list|,
name|CC_GLBL_MASK_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AllocAndFillAdForContLookupManip
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_Ad
condition|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|p_CcNode
operator|->
name|h_Ad
operator|=
name|p_CcNode
operator|->
name|h_TmpAd
expr_stmt|;
else|else
name|p_CcNode
operator|->
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|)
operator|)
operator|->
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_Ad
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC action descriptor"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|p_CcNode
operator|->
name|h_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|FillAdOfTypeContLookup
argument_list|(
name|p_CcNode
operator|->
name|h_Ad
argument_list|,
name|NULL
argument_list|,
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetRequiredAction1
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|requiredAction
parameter_list|,
name|t_FmPcdCcKeyAndNextEngineParams
modifier|*
name|p_CcKeyAndNextEngineParamsTmp
parameter_list|,
name|t_Handle
name|h_AdTmp
parameter_list|,
name|uint16_t
name|numOfEntries
parameter_list|,
name|t_Handle
name|h_Tree
parameter_list|)
block|{
name|t_AdOfTypeResult
modifier|*
name|p_AdTmp
init|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|h_AdTmp
decl_stmt|;
name|uint32_t
name|tmpReg32
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tmp
init|=
literal|0
decl_stmt|;
name|uint16_t
name|profileId
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|,
name|physicalSchemeId
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|h_AdTmp
operator|=
name|PTR_MOVE
argument_list|(
name|h_AdTmp
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
else|else
name|h_AdTmp
operator|=
name|PTR_MOVE
argument_list|(
name|h_AdTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_CC
operator|)
case|:
if|if
condition|(
name|requiredAction
condition|)
block|{
name|p_CcNode
operator|=
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|shadowAction
operator|==
name|requiredAction
condition|)
break|break;
if|if
condition|(
operator|(
name|requiredAction
operator|&
name|UPDATE_CC_WITH_TREE
operator|)
operator|&&
operator|!
operator|(
name|p_CcNode
operator|->
name|shadowAction
operator|&
name|UPDATE_CC_WITH_TREE
operator|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|h_Tree
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreesLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator||=
name|UPDATE_CC_WITH_TREE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|requiredAction
operator|&
name|UPDATE_CC_SHADOW_CLEAR
operator|)
operator|&&
operator|!
operator|(
name|p_CcNode
operator|->
name|shadowAction
operator|&
name|UPDATE_CC_SHADOW_CLEAR
operator|)
condition|)
block|{
name|p_CcNode
operator|->
name|shadowAction
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|requiredAction
operator|&
name|UPDATE_CC_WITH_DELETE_TREE
operator|)
operator|&&
operator|!
operator|(
name|p_CcNode
operator|->
name|shadowAction
operator|&
name|UPDATE_CC_WITH_DELETE_TREE
operator|)
condition|)
block|{
name|DequeueNodeInfoFromRelevantLst
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreesLst
argument_list|,
name|h_Tree
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator||=
name|UPDATE_CC_WITH_DELETE_TREE
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|!=
name|e_FM_PCD_INVALID
condition|)
name|tmp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
name|err
operator|=
name|SetRequiredAction1
argument_list|(
name|h_FmPcd
argument_list|,
name|requiredAction
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|h_AdTable
argument_list|,
name|tmp
argument_list|,
name|h_Tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
return|return
name|err
return|;
if|if
condition|(
name|requiredAction
operator|!=
name|UPDATE_CC_SHADOW_CLEAR
condition|)
name|p_CcNode
operator|->
name|shadowAction
operator||=
name|requiredAction
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_KG
operator|)
case|:
if|if
condition|(
operator|(
name|requiredAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
operator|)
operator|&&
operator|!
operator|(
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
operator|)
condition|)
block|{
name|physicalSchemeId
operator|=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|kgParams
operator|.
name|h_DirectScheme
argument_list|)
expr_stmt|;
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|h_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|==
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|kgParams
operator|.
name|h_DirectScheme
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid direct scheme."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KgIsSchemeAlwaysDirect
argument_list|(
name|h_FmPcd
argument_list|,
name|relativeSchemeId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"For this action scheme has to be direct."
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdKgCcGetSetParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|kgParams
operator|.
name|h_DirectScheme
argument_list|,
name|requiredAction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator||=
name|requiredAction
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR
operator|)
case|:
if|if
condition|(
operator|(
name|requiredAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
operator|)
operator|&&
operator|!
operator|(
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|plcrParams
operator|.
name|overrideParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"In this initialization only overrideFqid can be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|plcrParams
operator|.
name|sharedProfile
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"In this initialization only overrideFqid can be initialized"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdPlcrGetAbsoluteIdByProfileParams
argument_list|(
name|h_FmPcd
argument_list|,
name|e_FM_PCD_PLCR_SHARED
argument_list|,
name|NULL
argument_list|,
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|plcrParams
operator|.
name|newRelativeProfileId
argument_list|,
operator|&
name|profileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdPlcrCcGetSetParams
argument_list|(
name|h_FmPcd
argument_list|,
name|profileId
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator||=
name|requiredAction
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_DONE
operator|)
case|:
if|if
condition|(
operator|(
name|requiredAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
operator|)
operator|&&
operator|!
operator|(
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
operator|)
condition|)
block|{
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_AdTmp
operator|->
name|nia
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpReg32
operator|&
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|h_FmPcd
argument_list|)
operator|)
operator|!=
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|h_FmPcd
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next engine was previously assigned not as PCD_DONE"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator||=
name|NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_AdTmp
operator|->
name|nia
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
name|p_CcKeyAndNextEngineParamsTmp
index|[
name|i
index|]
operator|.
name|shadowAction
operator||=
name|requiredAction
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|SetRequiredAction
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint32_t
name|requiredAction
parameter_list|,
name|t_FmPcdCcKeyAndNextEngineParams
modifier|*
name|p_CcKeyAndNextEngineParamsTmp
parameter_list|,
name|t_Handle
name|h_AdTmp
parameter_list|,
name|uint16_t
name|numOfEntries
parameter_list|,
name|t_Handle
name|h_Tree
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|SetRequiredAction1
argument_list|(
name|h_FmPcd
argument_list|,
name|requiredAction
argument_list|,
name|p_CcKeyAndNextEngineParamsTmp
argument_list|,
name|h_AdTmp
argument_list|,
name|numOfEntries
argument_list|,
name|h_Tree
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
return|return
name|err
return|;
return|return
name|SetRequiredAction1
argument_list|(
name|h_FmPcd
argument_list|,
name|UPDATE_CC_SHADOW_CLEAR
argument_list|,
name|p_CcKeyAndNextEngineParamsTmp
argument_list|,
name|h_AdTmp
argument_list|,
name|numOfEntries
argument_list|,
name|h_Tree
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|ReleaseModifiedDataStructure
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_List
modifier|*
name|h_FmPcdOldPointersLst
parameter_list|,
name|t_List
modifier|*
name|h_FmPcdNewPointersLst
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalParams
parameter_list|,
name|bool
name|useShadowStructs
parameter_list|)
block|{
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|,
modifier|*
name|p_CcNodeInformation
decl_stmt|;
name|t_Handle
name|h_Muram
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_FmPcdCcNextNode
decl_stmt|,
modifier|*
name|p_FmPcdCcWorkingOnNode
decl_stmt|;
name|t_List
modifier|*
name|p_UpdateLst
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdOldPointersLst
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdNewPointersLst
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* We don't update subtree of the new node with new tree because it was done in the previous stage */
if|if
condition|(
name|p_AdditionalParams
operator|->
name|h_NodeForAdd
condition|)
block|{
name|p_FmPcdCcNextNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_AdditionalParams
operator|->
name|h_NodeForAdd
expr_stmt|;
if|if
condition|(
operator|!
name|p_AdditionalParams
operator|->
name|tree
condition|)
name|p_UpdateLst
operator|=
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccPrevNodesLst
expr_stmt|;
else|else
name|p_UpdateLst
operator|=
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccTreeIdLst
expr_stmt|;
name|p_CcNodeInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
name|p_UpdateLst
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNodeInformation
condition|)
name|p_CcNodeInformation
operator|->
name|index
operator|++
expr_stmt|;
else|else
block|{
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
operator|(
name|t_Handle
operator|)
name|p_AdditionalParams
operator|->
name|h_CurrentNode
expr_stmt|;
name|ccNodeInfo
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|p_UpdateLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_AdditionalParams
operator|->
name|h_ManipForAdd
condition|)
block|{
name|p_CcNodeInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
name|FmPcdManipGetNodeLstPointedOnThisManip
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForAdd
argument_list|)
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|FmPcdManipGetSpinlock
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForAdd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNodeInformation
condition|)
name|p_CcNodeInformation
operator|->
name|index
operator|++
expr_stmt|;
else|else
block|{
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
operator|(
name|t_Handle
operator|)
name|p_AdditionalParams
operator|->
name|h_CurrentNode
expr_stmt|;
name|ccNodeInfo
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|FmPcdManipGetNodeLstPointedOnThisManip
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForAdd
argument_list|)
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|FmPcdManipGetSpinlock
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForAdd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p_AdditionalParams
operator|->
name|h_NodeForRmv
condition|)
block|{
name|p_FmPcdCcNextNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_AdditionalParams
operator|->
name|h_NodeForRmv
expr_stmt|;
if|if
condition|(
operator|!
name|p_AdditionalParams
operator|->
name|tree
condition|)
block|{
name|p_UpdateLst
operator|=
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccPrevNodesLst
expr_stmt|;
name|p_FmPcdCcWorkingOnNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
expr_stmt|;
for|for
control|(
name|p_Pos
operator|=
name|NCSW_LIST_FIRST
argument_list|(
operator|&
name|p_FmPcdCcWorkingOnNode
operator|->
name|ccTreesLst
argument_list|)
init|;
name|p_Pos
operator|!=
operator|(
operator|&
name|p_FmPcdCcWorkingOnNode
operator|->
name|ccTreesLst
operator|)
condition|;
name|p_Pos
operator|=
name|NCSW_LIST_NEXT
argument_list|(
name|p_Pos
argument_list|)
control|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|h_FmPcd
argument_list|,
name|UPDATE_CC_WITH_DELETE_TREE
argument_list|,
operator|&
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|p_AdditionalParams
operator|->
name|savedKeyIndex
index|]
argument_list|,
name|PTR_MOVE
argument_list|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_AdTable
argument_list|,
name|p_AdditionalParams
operator|->
name|savedKeyIndex
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p_UpdateLst
operator|=
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccTreeIdLst
expr_stmt|;
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|h_FmPcd
argument_list|,
name|UPDATE_CC_WITH_DELETE_TREE
argument_list|,
operator|&
operator|(
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|p_AdditionalParams
operator|->
name|savedKeyIndex
index|]
argument_list|,
name|UINT_TO_PTR
argument_list|(
operator|(
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|ccTreeBaseAddr
operator|+
name|p_AdditionalParams
operator|->
name|savedKeyIndex
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* We remove from the subtree of the removed node tree because it wasn't done in the previous stage          Update ccPrevNodesLst or ccTreeIdLst of the removed node          Update of the node owner */
name|p_CcNodeInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
name|p_UpdateLst
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
operator|->
name|index
argument_list|)
expr_stmt|;
name|p_CcNodeInformation
operator|->
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|p_CcNodeInformation
operator|->
name|index
operator|==
literal|0
condition|)
name|DequeueNodeInfoFromRelevantLst
argument_list|(
name|p_UpdateLst
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|UpdateNodeOwner
argument_list|(
name|p_FmPcdCcNextNode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
condition|)
block|{
name|p_CcNodeInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
name|FmPcdManipGetNodeLstPointedOnThisManip
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
argument_list|)
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|FmPcdManipGetSpinlock
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
operator|->
name|index
argument_list|)
expr_stmt|;
name|p_CcNodeInformation
operator|->
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|p_CcNodeInformation
operator|->
name|index
operator|==
literal|0
condition|)
name|DequeueNodeInfoFromRelevantLst
argument_list|(
name|FmPcdManipGetNodeLstPointedOnThisManip
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
argument_list|)
argument_list|,
name|p_AdditionalParams
operator|->
name|h_CurrentNode
argument_list|,
name|FmPcdManipGetSpinlock
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
condition|)
name|FmPcdManipUpdateOwner
argument_list|(
name|p_AdditionalParams
operator|->
name|h_ManipForRmv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_AdditionalParams
operator|->
name|p_StatsObjForRmv
condition|)
name|PutStatsObj
argument_list|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
argument_list|,
name|p_AdditionalParams
operator|->
name|p_StatsObjForRmv
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_AdditionalParams
operator|->
name|h_FrmReplicForRmv
condition|)
name|FrmReplicGroupUpdateOwner
argument_list|(
name|p_AdditionalParams
operator|->
name|h_FrmReplicForRmv
argument_list|,
name|FALSE
comment|/* remove */
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
operator|!
name|useShadowStructs
condition|)
block|{
name|h_Muram
operator|=
name|FmPcdGetMuramHandle
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Muram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_AdditionalParams
operator|->
name|tree
operator|&&
operator|!
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|p_CcShadow
operator|)
operator|||
operator|(
operator|!
name|p_AdditionalParams
operator|->
name|tree
operator|&&
operator|!
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|maxNumOfKeys
operator|)
condition|)
block|{
comment|/* We release new AD which was allocated and updated for copy from to actual AD */
for|for
control|(
name|p_Pos
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|h_FmPcdNewPointersLst
argument_list|)
init|;
name|p_Pos
operator|!=
operator|(
name|h_FmPcdNewPointersLst
operator|)
condition|;
name|p_Pos
operator|=
name|NCSW_LIST_NEXT
argument_list|(
name|p_Pos
argument_list|)
control|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|h_Muram
argument_list|,
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free Old data structure if it has to be freed - new data structure was allocated*/
if|if
condition|(
name|p_AdditionalParams
operator|->
name|p_AdTableOld
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|h_Muram
argument_list|,
name|p_AdditionalParams
operator|->
name|p_AdTableOld
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableOld
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|h_Muram
argument_list|,
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableOld
argument_list|)
expr_stmt|;
block|}
comment|/* Update current modified node with changed fields if it's required*/
if|if
condition|(
operator|!
name|p_AdditionalParams
operator|->
name|tree
condition|)
block|{
if|if
condition|(
name|p_AdditionalParams
operator|->
name|p_AdTableNew
condition|)
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_AdTable
operator|=
name|p_AdditionalParams
operator|->
name|p_AdTableNew
expr_stmt|;
if|if
condition|(
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableNew
condition|)
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_KeysMatchTable
operator|=
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableNew
expr_stmt|;
comment|/* Locking node's spinlock before updating 'keys and next engine' structure,          as it maybe used to retrieve keys statistics */
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|numOfKeys
operator|=
name|p_AdditionalParams
operator|->
name|numOfKeys
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|keyAndNextEngineParams
argument_list|,
operator|&
name|p_AdditionalParams
operator|->
name|keyAndNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
operator|*
operator|(
name|CC_MAX_NUM_OF_KEYS
operator|)
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
name|numEntries
init|=
operator|(
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|numOfEntries
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|numEntries
operator|<
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|keyAndNextEngineParams
argument_list|,
operator|&
name|p_AdditionalParams
operator|->
name|keyAndNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
operator|*
name|numEntries
argument_list|)
expr_stmt|;
block|}
name|ReleaseLst
argument_list|(
name|h_FmPcdOldPointersLst
argument_list|)
expr_stmt|;
name|ReleaseLst
argument_list|(
name|h_FmPcdNewPointersLst
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_AdditionalParams
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Handle
name|BuildNewAd
parameter_list|(
name|t_Handle
name|h_Ad
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_FmPcdModifyCcKeyAdditionalParams
parameter_list|,
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_FmPcdCcNodeTmp
decl_stmt|;
name|t_Handle
name|h_OrigAd
init|=
name|NULL
decl_stmt|;
name|p_FmPcdCcNodeTmp
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdCcNodeTmp
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"p_FmPcdCcNodeTmp"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcdCcNodeTmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|numOfKeys
operator|=
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|numOfKeys
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|h_KeysMatchTable
operator|=
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|p_KeysMatchTableNew
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|h_AdTable
operator|=
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|p_AdTableNew
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|lclMask
operator|=
name|p_CcNode
operator|->
name|lclMask
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|parseCode
operator|=
name|p_CcNode
operator|->
name|parseCode
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|offset
operator|=
name|p_CcNode
operator|->
name|offset
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|prsArrayOffset
operator|=
name|p_CcNode
operator|->
name|prsArrayOffset
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|ctrlFlow
operator|=
name|p_CcNode
operator|->
name|ctrlFlow
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|ccKeySizeAccExtraction
operator|=
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|sizeOfExtraction
operator|=
name|p_CcNode
operator|->
name|sizeOfExtraction
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|glblMaskSize
operator|=
name|p_CcNode
operator|->
name|glblMaskSize
expr_stmt|;
name|p_FmPcdCcNodeTmp
operator|->
name|p_GlblMask
operator|=
name|p_CcNode
operator|->
name|p_GlblMask
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
condition|)
block|{
name|h_OrigAd
operator|=
name|p_CcNode
operator|->
name|h_Ad
expr_stmt|;
if|if
condition|(
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcdCcNodeTmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|FillAdOfTypeContLookup
argument_list|(
name|h_Ad
argument_list|,
name|NULL
argument_list|,
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPcdCcNodeTmp
argument_list|,
name|h_OrigAd
condition|?
name|NULL
else|:
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
block|{
name|FillAdOfTypeContLookup
argument_list|(
name|h_Ad
argument_list|,
name|NULL
argument_list|,
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPcdCcNodeTmp
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|XX_Free
argument_list|(
name|p_FmPcdCcNodeTmp
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|DynamicChangeHc
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_List
modifier|*
name|h_OldPointersLst
parameter_list|,
name|t_List
modifier|*
name|h_NewPointersLst
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalParams
parameter_list|,
name|bool
name|useShadowStructs
parameter_list|)
block|{
name|t_List
modifier|*
name|p_PosOld
decl_stmt|,
modifier|*
name|p_PosNew
decl_stmt|;
name|uint32_t
name|oldAdAddrOffset
decl_stmt|,
name|newAdAddrOffset
decl_stmt|;
name|uint16_t
name|i
init|=
literal|0
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|numOfModifiedPtr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|numOfModifiedPtr
operator|=
operator|(
name|uint8_t
operator|)
name|NCSW_LIST_NumOfObjs
argument_list|(
name|h_OldPointersLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfModifiedPtr
condition|)
block|{
name|p_PosNew
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_PosOld
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|h_OldPointersLst
argument_list|)
expr_stmt|;
comment|/* Retrieve address of new AD */
name|newAdAddrOffset
operator|=
name|FmPcdCcGetNodeAddrOffsetFromNodeInfo
argument_list|(
name|h_FmPcd
argument_list|,
name|p_PosNew
argument_list|)
expr_stmt|;
if|if
condition|(
name|newAdAddrOffset
operator|==
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
condition|)
block|{
name|ReleaseModifiedDataStructure
argument_list|(
name|h_FmPcd
argument_list|,
name|h_OldPointersLst
argument_list|,
name|h_NewPointersLst
argument_list|,
name|p_AdditionalParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"New AD address"
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfModifiedPtr
condition|;
name|i
operator|++
control|)
block|{
comment|/* Retrieve address of current AD */
name|oldAdAddrOffset
operator|=
name|FmPcdCcGetNodeAddrOffsetFromNodeInfo
argument_list|(
name|h_FmPcd
argument_list|,
name|p_PosOld
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldAdAddrOffset
operator|==
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
condition|)
block|{
name|ReleaseModifiedDataStructure
argument_list|(
name|h_FmPcd
argument_list|,
name|h_OldPointersLst
argument_list|,
name|h_NewPointersLst
argument_list|,
name|p_AdditionalParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Old AD address"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Invoke host command to copy from new AD to old AD */
name|err
operator|=
name|FmHcPcdCcDoDynamicChange
argument_list|(
operator|(
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
operator|)
operator|->
name|h_Hc
argument_list|,
name|oldAdAddrOffset
argument_list|,
name|newAdAddrOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseModifiedDataStructure
argument_list|(
name|h_FmPcd
argument_list|,
name|h_OldPointersLst
argument_list|,
name|h_NewPointersLst
argument_list|,
name|p_AdditionalParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"For part of nodes changes are done - situation is danger"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_PosOld
operator|=
name|NCSW_LIST_NEXT
argument_list|(
name|p_PosOld
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|DoDynamicChange
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_List
modifier|*
name|h_OldPointersLst
parameter_list|,
name|t_List
modifier|*
name|h_NewPointersLst
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalParams
parameter_list|,
name|bool
name|useShadowStructs
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalParams
operator|->
name|h_CurrentNode
operator|)
decl_stmt|;
name|t_List
modifier|*
name|p_PosNew
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
decl_stmt|;
name|t_FmPcdCcNextEngineParams
name|nextEngineParams
decl_stmt|;
name|t_Handle
name|h_Ad
decl_stmt|;
name|uint32_t
name|keySize
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|numOfModifiedPtr
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|nextEngineParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|numOfModifiedPtr
operator|=
operator|(
name|uint8_t
operator|)
name|NCSW_LIST_NumOfObjs
argument_list|(
name|h_OldPointersLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfModifiedPtr
condition|)
block|{
name|p_PosNew
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|h_NewPointersLst
argument_list|)
expr_stmt|;
comment|/* Invoke host-command to copy from the new Ad to existing Ads */
name|err
operator|=
name|DynamicChangeHc
argument_list|(
name|h_FmPcd
argument_list|,
name|h_OldPointersLst
argument_list|,
name|h_NewPointersLst
argument_list|,
name|p_AdditionalParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|useShadowStructs
condition|)
block|{
comment|/* When the host-command above has ended, the old structures are 'free'and we can update 			 them by copying from the new shadow structures. */
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
name|keySize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|2
operator|*
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
expr_stmt|;
else|else
name|keySize
operator|=
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableOld
argument_list|,
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|*
name|keySize
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdditionalParams
operator|->
name|p_AdTableOld
argument_list|,
name|p_AdditionalParams
operator|->
name|p_AdTableNew
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Retrieve the address of the allocated Ad */
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_PosNew
argument_list|)
expr_stmt|;
name|h_Ad
operator|=
name|p_CcNodeInfo
operator|->
name|h_CcNode
expr_stmt|;
comment|/* Build a new Ad that holds the old (now updated) structures */
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableNew
operator|=
name|p_AdditionalParams
operator|->
name|p_KeysMatchTableOld
expr_stmt|;
name|p_AdditionalParams
operator|->
name|p_AdTableNew
operator|=
name|p_AdditionalParams
operator|->
name|p_AdTableOld
expr_stmt|;
name|nextEngineParams
operator|.
name|nextEngine
operator|=
name|e_FM_PCD_CC
expr_stmt|;
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
operator|=
operator|(
name|t_Handle
operator|)
name|p_CcNode
expr_stmt|;
name|BuildNewAd
argument_list|(
name|h_Ad
argument_list|,
name|p_AdditionalParams
argument_list|,
name|p_CcNode
argument_list|,
operator|&
name|nextEngineParams
argument_list|)
expr_stmt|;
comment|/* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
name|err
operator|=
name|DynamicChangeHc
argument_list|(
name|h_FmPcd
argument_list|,
name|h_OldPointersLst
argument_list|,
name|h_NewPointersLst
argument_list|,
name|p_AdditionalParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|ReleaseModifiedDataStructure
argument_list|(
name|h_FmPcd
argument_list|,
name|h_OldPointersLst
argument_list|,
name|h_NewPointersLst
argument_list|,
name|p_AdditionalParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
end_ifdef

begin_function
specifier|static
name|bool
name|IsCapwapApplSpecific
parameter_list|(
name|t_Handle
name|h_Node
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_Node
decl_stmt|;
name|bool
name|isManipForCapwapApplSpecificBuild
init|=
name|FALSE
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Node
argument_list|)
expr_stmt|;
comment|/* assumption that this function called only for INDEXED_FLOW_ID - so no miss*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
operator|&&
name|FmPcdManipIsCapwapApplSpecific
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|)
condition|)
block|{
name|isManipForCapwapApplSpecificBuild
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|isManipForCapwapApplSpecificBuild
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FM_CAPWAP_SUPPORT */
end_comment

begin_function
specifier|static
name|t_Error
name|CcUpdateParam
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_FmPcdCcKeyAndNextEngineParams
modifier|*
name|p_CcKeyAndNextEngineParams
parameter_list|,
name|uint16_t
name|numOfEntries
parameter_list|,
name|t_Handle
name|h_Ad
parameter_list|,
name|bool
name|validate
parameter_list|,
name|uint16_t
name|level
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|,
name|bool
name|modify
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint16_t
name|tmp
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_CcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmTree
decl_stmt|;
name|level
operator|++
expr_stmt|;
if|if
condition|(
name|p_CcTree
operator|->
name|h_IpReassemblyManip
condition|)
block|{
name|err
operator|=
name|FmPcdManipUpdate
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_CcTree
operator|->
name|h_IpReassemblyManip
argument_list|,
name|NULL
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|,
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_CcTree
operator|->
name|h_CapwapReassemblyManip
condition|)
block|{
name|err
operator|=
name|FmPcdManipUpdate
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_CcTree
operator|->
name|h_CapwapReassemblyManip
argument_list|,
name|NULL
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|,
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numOfEntries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|h_Ad
operator|=
name|PTR_MOVE
argument_list|(
name|h_Ad
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
else|else
name|h_Ad
operator|=
name|PTR_MOVE
argument_list|(
name|h_Ad
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcKeyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
name|p_CcNode
operator|=
name|p_CcKeyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcKeyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipUpdate
argument_list|(
name|h_FmPcd
argument_list|,
name|NULL
argument_list|,
name|h_FmPort
argument_list|,
name|p_CcKeyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|,
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|!=
name|e_FM_PCD_INVALID
condition|)
name|tmp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
name|err
operator|=
name|CcUpdateParam
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
argument_list|,
name|tmp
argument_list|,
name|p_CcNode
operator|->
name|h_AdTable
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|,
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_CcKeyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipUpdate
argument_list|(
name|h_FmPcd
argument_list|,
name|NULL
argument_list|,
name|h_FmPort
argument_list|,
name|p_CcKeyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|,
name|h_Ad
argument_list|,
name|validate
argument_list|,
name|level
argument_list|,
name|h_FmTree
argument_list|,
name|modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|ccPrivateInfo_t
name|IcDefineCode
parameter_list|(
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|)
block|{
switch|switch
condition|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|action
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_ACTION_EXACT_MATCH
operator|)
case|:
switch|switch
condition|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_KEY
operator|)
case|:
return|return
name|CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_HASH
operator|)
case|:
return|return
name|CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH
return|;
default|default:
return|return
name|CC_PRIVATE_INFO_NONE
return|;
block|}
case|case
operator|(
name|e_FM_PCD_ACTION_INDEXED_LOOKUP
operator|)
case|:
switch|switch
condition|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_HASH
operator|)
case|:
return|return
name|CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_FLOW_ID
operator|)
case|:
return|return
name|CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP
return|;
default|default:
return|return
name|CC_PRIVATE_INFO_NONE
return|;
block|}
default|default:
break|break;
block|}
return|return
name|CC_PRIVATE_INFO_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|t_CcNodeInformation
modifier|*
name|DequeueAdditionalInfoFromRelevantLst
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
name|p_List
argument_list|)
condition|)
block|{
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_List
operator|->
name|p_Next
argument_list|)
expr_stmt|;
name|NCSW_LIST_DelAndInit
argument_list|(
operator|&
name|p_CcNodeInfo
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|p_CcNodeInfo
return|;
block|}
end_function

begin_function
name|void
name|ReleaseLst
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
name|p_List
argument_list|)
condition|)
block|{
name|p_CcNodeInfo
operator|=
name|DequeueAdditionalInfoFromRelevantLst
argument_list|(
name|p_List
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_CcNodeInfo
condition|)
block|{
name|XX_Free
argument_list|(
name|p_CcNodeInfo
argument_list|)
expr_stmt|;
name|p_CcNodeInfo
operator|=
name|DequeueAdditionalInfoFromRelevantLst
argument_list|(
name|p_List
argument_list|)
expr_stmt|;
block|}
block|}
name|NCSW_LIST_Del
argument_list|(
name|p_List
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|DeleteNode
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
condition|)
return|return;
if|if
condition|(
name|p_CcNode
operator|->
name|p_GlblMask
condition|)
block|{
name|XX_Free
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|p_GlblMask
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|h_KeysMatchTable
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|h_KeysMatchTable
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_KeysMatchTable
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|h_AdTable
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|h_AdTable
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_AdTable
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|h_Ad
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|h_Ad
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_Ad
operator|=
name|NULL
expr_stmt|;
name|p_CcNode
operator|->
name|h_TmpAd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|h_StatsFLRs
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|h_StatsFLRs
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_StatsFLRs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|h_Spinlock
condition|)
block|{
name|XX_FreeSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_Spinlock
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Restore the original counters pointer instead of the mutual pointer (mutual to all hash buckets) */
if|if
condition|(
name|p_CcNode
operator|->
name|isHashBucket
operator|&&
operator|(
name|p_CcNode
operator|->
name|statisticsMode
operator|!=
name|e_FM_PCD_CC_STATS_MODE_NONE
operator|)
condition|)
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsCounters
operator|=
name|p_CcNode
operator|->
name|h_PrivMissStatsCounters
expr_stmt|;
comment|/* Releasing all currently used statistics objects, including 'miss' entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|p_StatsObj
condition|)
name|PutStatsObj
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|p_StatsObj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|)
condition|)
block|{
name|t_Handle
name|h_FmMuram
init|=
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmMuram
argument_list|)
expr_stmt|;
name|FreeStatObjects
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|,
name|h_FmMuram
argument_list|)
expr_stmt|;
block|}
name|NCSW_LIST_Del
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|)
expr_stmt|;
name|ReleaseLst
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccPrevNodesLst
argument_list|)
expr_stmt|;
name|ReleaseLst
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreeIdLst
argument_list|)
expr_stmt|;
name|ReleaseLst
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreesLst
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|DeleteTree
parameter_list|(
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdTree
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
if|if
condition|(
name|p_FmPcdTree
condition|)
block|{
if|if
condition|(
name|p_FmPcdTree
operator|->
name|ccTreeBaseAddr
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdTree
operator|->
name|ccTreeBaseAddr
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcdTree
operator|->
name|ccTreeBaseAddr
operator|=
literal|0
expr_stmt|;
block|}
name|ReleaseLst
argument_list|(
operator|&
name|p_FmPcdTree
operator|->
name|fmPortsLst
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_FmPcdTree
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|GetCcExtractKeySize
parameter_list|(
name|uint8_t
name|parseCodeRealSize
parameter_list|,
name|uint8_t
modifier|*
name|parseCodeCcSize
parameter_list|)
block|{
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<
literal|2
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|parseCodeRealSize
operator|==
literal|2
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|2
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|4
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|4
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|8
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|8
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|16
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|16
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|24
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|24
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|32
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|32
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|40
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|40
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|48
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|48
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parseCodeRealSize
operator|>
literal|48
operator|)
operator|&&
operator|(
name|parseCodeRealSize
operator|<=
literal|56
operator|)
condition|)
operator|*
name|parseCodeCcSize
operator|=
literal|56
expr_stmt|;
else|else
operator|*
name|parseCodeCcSize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|GetSizeHeaderField
parameter_list|(
name|e_NetHeaderType
name|hdr
parameter_list|,
name|t_FmPcdFields
name|field
parameter_list|,
name|uint8_t
modifier|*
name|parseCodeRealSize
parameter_list|)
block|{
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_DA
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|6
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_ETH_SA
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|6
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported1"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|pppoe
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_PPPoE_PID
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported1"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported2"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|mpls
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_MPLS_LABEL_STACK
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported3"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv4
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_DST_IP
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_SRC_IP
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|4
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_TOS
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_PROTO
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_DST_IP
operator||
name|NET_HEADER_FIELD_IPv4_SRC_IP
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|8
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_TTL
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported4"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv6
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_VER
operator||
name|NET_HEADER_FIELD_IPv6_FL
operator||
name|NET_HEADER_FIELD_IPv6_TC
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|4
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_NEXT_HDR
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_HOP_LIMIT
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_DST_IP
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_SRC_IP
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported5"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ip
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IP_DSCP
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_IP_PROTO
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported5"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|gre
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_GRE_TYPE
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported6"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|minencap
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_TYPE
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_DST_IP
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_SRC_IP
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|4
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_SRC_IP
operator||
name|NET_HEADER_FIELD_MINENCAP_DST_IP
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported7"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|tcp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_SRC
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_DST
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_SRC
operator||
name|NET_HEADER_FIELD_TCP_PORT_DST
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported8"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|udp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_SRC
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_DST
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_SRC
operator||
name|NET_HEADER_FIELD_UDP_PORT_DST
operator|)
case|:
operator|*
name|parseCodeRealSize
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported9"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported10"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|parseCodeRealSize
operator|=
name|CC_SIZE_ILLEGAL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|t_Error
name|ValidateNextEngineParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|,
name|e_FmPcdCcStatsMode
name|statsMode
parameter_list|)
block|{
name|uint16_t
name|absoluteProfileId
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|;
if|if
condition|(
operator|(
name|statsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_NONE
operator|)
operator|&&
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Statistics are requested for a key, but statistics mode was set"
literal|"to 'NONE' upon initialization"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_INVALID
operator|)
case|:
name|err
operator|=
name|E_NOT_SUPPORTED
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_DONE
operator|)
case|:
if|if
condition|(
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|action
operator|==
name|e_FM_PCD_ENQ_FRAME
operator|)
operator|&&
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
block|{
if|if
condition|(
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|newFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"When overrideFqid is set, newFqid must not be zero"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|newFqid
operator|&
operator|~
literal|0x00FFFFFF
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fqidForCtrlFlow must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_KG
operator|)
case|:
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|h_FmPcd
argument_list|,
name|FmPcdKgGetSchemeId
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|kgParams
operator|.
name|h_DirectScheme
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|==
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|kgParams
operator|.
name|h_DirectScheme
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"not valid schemeIndex in KG next engine param"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KgIsSchemeAlwaysDirect
argument_list|(
name|h_FmPcd
argument_list|,
name|relativeSchemeId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"CC Node may point only to a scheme that is always direct."
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR
operator|)
case|:
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|overrideParams
condition|)
block|{
comment|/* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|sharedProfile
condition|)
block|{
name|err
operator|=
name|FmPcdPlcrGetAbsoluteIdByProfileParams
argument_list|(
name|h_FmPcd
argument_list|,
name|e_FM_PCD_PLCR_SHARED
argument_list|,
name|NULL
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|newRelativeProfileId
argument_list|,
operator|&
name|absoluteProfileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Shared profile offset is out of range"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|h_FmPcd
argument_list|,
name|absoluteProfileId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Invalid profile"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_HASH
operator|)
case|:
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
operator|=
name|e_FM_PCD_CC
expr_stmt|;
case|case
operator|(
name|e_FM_PCD_CC
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NULL_POINTER
argument_list|,
operator|(
literal|"handler to next Node is NULL"
operator|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_FR
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
condition|)
name|err
operator|=
name|E_NOT_SUPPORTED
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next engine is not correct"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetGenParseCode
parameter_list|(
name|e_FmPcdExtractFrom
name|src
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|bool
name|glblMask
parameter_list|,
name|uint8_t
modifier|*
name|parseArrayOffset
parameter_list|,
name|bool
name|fromIc
parameter_list|,
name|ccPrivateInfo_t
name|icCode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fromIc
condition|)
block|{
switch|switch
condition|(
name|src
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_FRAME_START
operator|)
case|:
if|if
condition|(
name|glblMask
condition|)
return|return
name|CC_PC_GENERIC_WITH_MASK
return|;
else|else
return|return
name|CC_PC_GENERIC_WITHOUT_MASK
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_NEXT_HEADER_OFFSET
expr_stmt|;
if|if
condition|(
name|offset
condition|)
return|return
name|CC_PR_OFFSET
return|;
else|else
return|return
name|CC_PR_WITHOUT_OFFSET
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Illegal 'extract from' src"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|icCode
condition|)
block|{
case|case
operator|(
name|CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
literal|0x50
expr_stmt|;
return|return
name|CC_PC_GENERIC_IC_GMASK
return|;
case|case
operator|(
name|CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
literal|0x48
expr_stmt|;
return|return
name|CC_PC_GENERIC_IC_GMASK
return|;
case|case
operator|(
name|CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
literal|0x48
expr_stmt|;
return|return
name|CC_PC_GENERIC_IC_HASH_INDEXED
return|;
case|case
operator|(
name|CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
literal|0x16
expr_stmt|;
return|return
name|CC_PC_GENERIC_IC_HASH_INDEXED
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Illegal 'extract from' src"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|CC_PC_ILLEGAL
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetFullFieldParseCode
parameter_list|(
name|e_NetHeaderType
name|hdr
parameter_list|,
name|e_FmPcdHdrIndex
name|index
parameter_list|,
name|t_FmPcdFields
name|field
parameter_list|)
block|{
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_DA
operator|)
case|:
return|return
name|CC_PC_FF_MACDST
return|;
case|case
operator|(
name|NET_HEADER_FIELD_ETH_SA
operator|)
case|:
return|return
name|CC_PC_FF_MACSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
return|return
name|CC_PC_FF_ETYPE
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_TCI1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|CC_PC_FF_TCI2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|mpls
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_MPLS_LABEL_STACK
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_MPLS1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|CC_PC_FF_MPLS_LAST
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal MPLS index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv4
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_DST_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV4DST1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV4DST2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_TOS
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV4IPTOS_TC1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV4IPTOS_TC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_PROTO
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV4PTYPE1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV4PTYPE2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_SRC_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV4SRC1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV4SRC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_SRC_IP
operator||
name|NET_HEADER_FIELD_IPv4_DST_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV4SRC1_IPV4DST1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV4SRC2_IPV4DST2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_TTL
operator|)
case|:
return|return
name|CC_PC_FF_IPV4TTL
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv6
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_VER
operator||
name|NET_HEADER_FIELD_IPv6_FL
operator||
name|NET_HEADER_FIELD_IPv6_TC
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_NEXT_HDR
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV6PTYPE1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV6PTYPE2
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|CC_PC_FF_IPPID
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_DST_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV6DST1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV6DST2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_SRC_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPV6SRC1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|CC_PC_FF_IPV6SRC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_HOP_LIMIT
operator|)
case|:
return|return
name|CC_PC_FF_IPV6HOP_LIMIT
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ip
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IP_DSCP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|CC_PC_FF_IPDSCP
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IP index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IP_PROTO
operator|)
case|:
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|CC_PC_FF_IPPID
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IP index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|gre
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_GRE_TYPE
operator|)
case|:
return|return
name|CC_PC_FF_GREPTYPE
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|minencap
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_TYPE
operator|)
case|:
return|return
name|CC_PC_FF_MINENCAP_PTYPE
return|;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_DST_IP
operator|)
case|:
return|return
name|CC_PC_FF_MINENCAP_IPDST
return|;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_SRC_IP
operator|)
case|:
return|return
name|CC_PC_FF_MINENCAP_IPSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_SRC_IP
operator||
name|NET_HEADER_FIELD_MINENCAP_DST_IP
operator|)
case|:
return|return
name|CC_PC_FF_MINENCAP_IPSRC_IPDST
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|tcp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_SRC
operator|)
case|:
return|return
name|CC_PC_FF_L4PSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_DST
operator|)
case|:
return|return
name|CC_PC_FF_L4PDST
return|;
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_DST
operator||
name|NET_HEADER_FIELD_TCP_PORT_SRC
operator|)
case|:
return|return
name|CC_PC_FF_L4PSRC_L4PDST
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|pppoe
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_PPPoE_PID
operator|)
case|:
return|return
name|CC_PC_FF_PPPPID
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|udp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_SRC
operator|)
case|:
return|return
name|CC_PC_FF_L4PSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_DST
operator|)
case|:
return|return
name|CC_PC_FF_L4PDST
return|;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_DST
operator||
name|NET_HEADER_FIELD_UDP_PORT_SRC
operator|)
case|:
return|return
name|CC_PC_FF_L4PSRC_L4PDST
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetPrParseCode
parameter_list|(
name|e_NetHeaderType
name|hdr
parameter_list|,
name|e_FmPcdHdrIndex
name|hdrIndex
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|bool
name|glblMask
parameter_list|,
name|uint8_t
modifier|*
name|parseArrayOffset
parameter_list|)
block|{
name|bool
name|offsetRelevant
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|offsetRelevant
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_ETH_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM1
operator|)
case|:
if|if
condition|(
name|offset
operator|||
name|glblMask
condition|)
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_USER_DEFINED_SHIM1_OFFSET
expr_stmt|;
else|else
return|return
name|CC_PC_PR_SHIM1
return|;
break|break;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM2
operator|)
case|:
if|if
condition|(
name|offset
operator|||
name|glblMask
condition|)
operator|*
name|parseArrayOffset
operator|=
operator|(
name|uint8_t
operator|)
name|CC_PC_PR_USER_DEFINED_SHIM2_OFFSET
expr_stmt|;
else|else
return|return
name|CC_PC_PR_SHIM2
return|;
break|break;
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_USER_LLC_SNAP_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_PPPOE_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MPLS1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MPLS_LAST_OFFSET
expr_stmt|;
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal MPLS header index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_IP1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_IP_LAST_OFFSET
expr_stmt|;
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IP header index"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_MINENC_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_GRE_OFFSET
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_L4_OFFSET
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IP header for this type of operation"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
if|if
condition|(
name|offsetRelevant
condition|)
return|return
name|CC_PR_OFFSET
return|;
else|else
return|return
name|CC_PR_WITHOUT_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetFieldParseCode
parameter_list|(
name|e_NetHeaderType
name|hdr
parameter_list|,
name|t_FmPcdFields
name|field
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|parseArrayOffset
parameter_list|,
name|e_FmPcdHdrIndex
name|hdrIndex
parameter_list|)
block|{
name|bool
name|offsetRelevant
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|offsetRelevant
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_ETYPE_LAST_OFFSET
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_VLAN1_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
operator|*
name|parseArrayOffset
operator|=
name|CC_PC_PR_VLAN2_OFFSET
expr_stmt|;
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
break|break;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal header "
operator|)
argument_list|)
expr_stmt|;
return|return
name|CC_PC_ILLEGAL
return|;
block|}
if|if
condition|(
name|offsetRelevant
condition|)
return|return
name|CC_PR_OFFSET
return|;
else|else
return|return
name|CC_PR_WITHOUT_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FillAdOfTypeResult
parameter_list|(
name|t_Handle
name|h_Ad
parameter_list|,
name|t_FmPcdCcStatsParams
modifier|*
name|p_FmPcdCcStatsParams
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_CcNextEngineParams
parameter_list|)
block|{
name|t_AdOfTypeResult
modifier|*
name|p_AdResult
init|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|h_Ad
decl_stmt|;
name|t_Handle
name|h_TmpAd
decl_stmt|;
name|uint32_t
name|tmp
init|=
literal|0
decl_stmt|,
name|tmpNia
init|=
literal|0
decl_stmt|;
name|uint16_t
name|profileId
decl_stmt|;
name|t_Handle
name|p_AdNewPtr
init|=
name|NULL
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
comment|/* There are 3 cases handled in this routine of building a "result" type AD.      * Case 1: No Manip. The action descriptor is built within the match table.      * Case 2: Manip exists. A new AD is created - p_AdNewPtr. It is initialized      *         either in the FmPcdManipUpdateAdResultForCc routine or it was already      *         initialized and returned here.      *         p_AdResult (within the match table) will be initialized after      *         this routine returns and point to the existing AD.      * Case 3: Manip exists. The action descriptor is built within the match table.      *         FmPcdManipUpdateAdResultForCc returns a NULL p_AdNewPtr.      *      * If statistics were enabled and the statistics mode of this node requires      * a statistics Ad, it will be placed after the result Ad and before the      * manip Ad, if manip Ad exists here.      */
comment|/* As default, the "new" ptr is the current one. i.e. the content of the result      * AD will be written into the match table itself (case (1))*/
name|p_AdNewPtr
operator|=
name|p_AdResult
expr_stmt|;
comment|/* Initialize an action descriptor, if current statistics mode requires an Ad */
if|if
condition|(
name|p_FmPcdCcStatsParams
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsCounters
argument_list|)
expr_stmt|;
comment|/* Swapping addresses between statistics Ad and the current lookup AD addresses */
name|h_TmpAd
operator|=
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
expr_stmt|;
name|p_FmPcdCcStatsParams
operator|->
name|h_StatsAd
operator|=
name|h_Ad
expr_stmt|;
name|h_Ad
operator|=
name|h_TmpAd
expr_stmt|;
name|p_AdNewPtr
operator|=
name|h_Ad
expr_stmt|;
name|p_AdResult
operator|=
name|h_Ad
expr_stmt|;
comment|/* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
name|UpdateStatsAd
argument_list|(
name|p_FmPcdCcStatsParams
argument_list|,
name|h_Ad
argument_list|,
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
block|}
comment|/* Create manip and return p_AdNewPtr to either a new descriptor or NULL */
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|h_Manip
condition|)
name|FmPcdManipUpdateAdResultForCc
argument_list|(
name|p_CcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|p_CcNextEngineParams
argument_list|,
name|h_Ad
argument_list|,
operator|&
name|p_AdNewPtr
argument_list|)
expr_stmt|;
comment|/* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
if|if
condition|(
name|p_AdNewPtr
condition|)
block|{
comment|/* case (1) and (2) */
switch|switch
condition|(
name|p_CcNextEngineParams
operator|->
name|nextEngine
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_DONE
operator|)
case|:
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|action
operator|==
name|e_FM_PCD_ENQ_FRAME
condition|)
block|{
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|overrideFqid
condition|)
block|{
name|tmp
operator|=
name|FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE
expr_stmt|;
name|tmp
operator||=
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|newFqid
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|tmp
operator||=
operator|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|newRelativeStorageProfileId
operator|&
name|FM_PCD_AD_RESULT_VSP_MASK
operator|)
operator|<<
name|FM_PCD_AD_RESULT_VSP_SHIFT
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
else|else
block|{
name|tmp
operator|=
name|FM_PCD_AD_RESULT_DATA_FLOW_TYPE
expr_stmt|;
name|tmp
operator||=
name|FM_PCD_AD_RESULT_PLCR_DIS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|enqueueParams
operator|.
name|action
operator|==
name|e_FM_PCD_DROP_FRAME
condition|)
name|tmpNia
operator||=
name|GET_NIA_BMI_AC_DISCARD_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
else|else
name|tmpNia
operator||=
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG
operator|)
case|:
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|kgParams
operator|.
name|overrideFqid
condition|)
block|{
name|tmp
operator|=
name|FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE
expr_stmt|;
name|tmp
operator||=
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|kgParams
operator|.
name|newFqid
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|tmp
operator||=
operator|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|kgParams
operator|.
name|newRelativeStorageProfileId
operator|&
name|FM_PCD_AD_RESULT_VSP_MASK
operator|)
operator|<<
name|FM_PCD_AD_RESULT_VSP_SHIFT
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
else|else
block|{
name|tmp
operator|=
name|FM_PCD_AD_RESULT_DATA_FLOW_TYPE
expr_stmt|;
name|tmp
operator||=
name|FM_PCD_AD_RESULT_PLCR_DIS
expr_stmt|;
block|}
name|tmpNia
operator|=
name|NIA_KG_DIRECT
expr_stmt|;
name|tmpNia
operator||=
name|NIA_ENG_KG
expr_stmt|;
name|tmpNia
operator||=
name|NIA_KG_CC_EN
expr_stmt|;
name|tmpNia
operator||=
name|FmPcdKgGetSchemeId
argument_list|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|kgParams
operator|.
name|h_DirectScheme
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR
operator|)
case|:
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|overrideParams
condition|)
block|{
name|tmp
operator|=
name|FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE
expr_stmt|;
comment|/* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|sharedProfile
condition|)
block|{
name|tmpNia
operator||=
name|NIA_PLCR_ABSOLUTE
expr_stmt|;
name|err
operator|=
name|FmPcdPlcrGetAbsoluteIdByProfileParams
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_FmPcd
argument_list|,
name|e_FM_PCD_PLCR_SHARED
argument_list|,
name|NULL
argument_list|,
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|newRelativeProfileId
argument_list|,
operator|&
name|profileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
return|return;
block|}
else|else
name|profileId
operator|=
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|newRelativeProfileId
expr_stmt|;
name|tmp
operator||=
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|newFqid
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|tmp
operator||=
operator|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|newRelativeStorageProfileId
operator|&
name|FM_PCD_AD_RESULT_VSP_MASK
operator|)
operator|<<
name|FM_PCD_AD_RESULT_VSP_SHIFT
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|WRITE_UINT32
argument_list|(
name|p_AdResult
operator|->
name|plcrProfile
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|profileId
operator|<<
name|FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|FM_PCD_AD_RESULT_DATA_FLOW_TYPE
expr_stmt|;
name|tmpNia
operator||=
name|NIA_ENG_PLCR
operator||
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|plcrParams
operator|.
name|newRelativeProfileId
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|WRITE_UINT32
argument_list|(
name|p_AdResult
operator|->
name|fqid
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|h_Manip
condition|)
block|{
name|tmp
operator|=
name|GET_UINT32
argument_list|(
name|p_AdResult
operator|->
name|plcrProfile
argument_list|)
expr_stmt|;
name|tmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_AdNewPtr
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_AdResult
operator|->
name|plcrProfile
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmpNia
operator||=
name|FM_PCD_AD_RESULT_EXTENDED_MODE
expr_stmt|;
name|tmpNia
operator||=
name|FM_PCD_AD_RESULT_NADEN
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|tmpNia
operator||=
name|FM_PCD_AD_RESULT_NO_OM_VSPE
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|WRITE_UINT32
argument_list|(
name|p_AdResult
operator|->
name|nia
argument_list|,
name|tmpNia
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CcUpdateParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|,
name|bool
name|validate
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_CcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmTree
decl_stmt|;
return|return
name|CcUpdateParam
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|p_CcTree
operator|->
name|keyAndNextEngineParams
argument_list|,
name|p_CcTree
operator|->
name|numOfEntries
argument_list|,
name|UINT_TO_PTR
argument_list|(
name|p_CcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
argument_list|,
name|validate
argument_list|,
literal|0
argument_list|,
name|h_FmTree
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReleaseNewNodeCommonPart
parameter_list|(
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalInfo
parameter_list|)
block|{
if|if
condition|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalInfo
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|(
name|p_AdditionalInfo
operator|->
name|h_CurrentNode
operator|)
operator|)
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdateGblMask
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|)
block|{
name|uint8_t
name|prvGlblMaskSize
init|=
name|p_CcNode
operator|->
name|glblMaskSize
decl_stmt|;
if|if
condition|(
name|p_Mask
operator|&&
operator|!
name|p_CcNode
operator|->
name|glblMaskUpdated
operator|&&
operator|(
name|keySize
operator|<=
literal|4
operator|)
operator|&&
operator|!
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|parseCode
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_TCI1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_TCI2
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_MPLS1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_MPLS_LAST
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPV4IPTOS_TC1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPV4IPTOS_TC2
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPDSCP
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2
operator|)
condition|)
block|{
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
literal|0
expr_stmt|;
name|p_CcNode
operator|->
name|lclMask
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
name|p_Mask
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
operator|*
name|keySize
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskUpdated
operator|=
name|TRUE
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_Mask
operator|&&
operator|(
name|keySize
operator|<=
literal|4
operator|)
operator|&&
operator|!
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
name|p_Mask
argument_list|,
name|keySize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p_CcNode
operator|->
name|lclMask
operator|=
name|TRUE
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|p_Mask
operator|&&
name|p_CcNode
operator|->
name|glblMaskUpdated
operator|&&
operator|(
name|keySize
operator|<=
literal|4
operator|)
condition|)
block|{
name|uint32_t
name|tmpMask
init|=
literal|0xffffffff
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
operator|&
name|tmpMask
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p_CcNode
operator|->
name|lclMask
operator|=
name|TRUE
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_Mask
condition|)
block|{
name|p_CcNode
operator|->
name|lclMask
operator|=
name|TRUE
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* In static mode (maxNumOfKeys> 0), local mask is supported      only is mask support was enabled at initialization */
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|&&
operator|(
operator|!
name|p_CcNode
operator|->
name|maskSupport
operator|)
operator|&&
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
name|p_CcNode
operator|->
name|lclMask
operator|=
name|FALSE
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
name|prvGlblMaskSize
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_NOT_SUPPORTED
argument_list|)
return|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|t_Handle
name|GetNewAd
parameter_list|(
name|t_Handle
name|h_FmPcdCcNodeOrTree
parameter_list|,
name|bool
name|isTree
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_Handle
name|h_Ad
decl_stmt|;
if|if
condition|(
name|isTree
condition|)
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
operator|(
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|h_FmPcd
operator|)
expr_stmt|;
else|else
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|h_FmPcd
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|isTree
operator|&&
name|p_FmPcd
operator|->
name|p_CcShadow
operator|)
operator|||
operator|(
operator|!
name|isTree
operator|&&
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|maxNumOfKeys
operator|)
condition|)
block|{
comment|/* The allocated shadow is divided as follows:          0 . . .       16 . . .          ---------------------------------------------------          |   Shadow   |   Shadow Keys   |   Shadow Next    |          |     Ad     |   Match Table   |   Engine Table   |          | (16 bytes) | (maximal size)  |  (maximal size)  |          ---------------------------------------------------          */
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_CcShadow
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"CC Shadow not allocated"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|h_Ad
operator|=
name|p_FmPcd
operator|->
name|p_CcShadow
expr_stmt|;
block|}
else|else
block|{
name|h_Ad
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_Ad
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node action descriptor"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|h_Ad
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildNewNodeCommonPart
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|int
modifier|*
name|size
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalInfo
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
decl_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
operator|*
name|size
operator|=
literal|2
operator|*
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
expr_stmt|;
else|else
operator|*
name|size
operator|=
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|==
literal|0
condition|)
block|{
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node action descriptors table"
operator|)
argument_list|)
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
operator|(
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
argument_list|,
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|)
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
operator|=
name|NULL
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node key match table"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
literal|0
argument_list|,
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
operator|(
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The allocated shadow is divided as follows:          0 . . .       16 . . .          ---------------------------------------------------          |   Shadow   |   Shadow Keys   |   Shadow Next    |          |     Ad     |   Match Table   |   Engine Table   |          | (16 bytes) | (maximal size)  |  (maximal size)  |          ---------------------------------------------------          */
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_CcShadow
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"CC Shadow not allocated"
operator|)
argument_list|)
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
operator|=
name|PTR_MOVE
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|p_CcNode
operator|->
name|keysMatchTableMaxSize
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
operator|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_AdditionalInfo
operator|->
name|p_AdTableOld
operator|=
name|p_CcNode
operator|->
name|h_AdTable
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableOld
operator|=
name|p_CcNode
operator|->
name|h_KeysMatchTable
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildNewNodeAddOrMdfyKeyAndNextEngine
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalInfo
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_Handle
name|p_AdTableNewTmp
decl_stmt|,
name|p_KeysMatchTableNewTmp
decl_stmt|;
name|t_Handle
name|p_KeysMatchTableOldTmp
decl_stmt|,
name|p_AdTableOldTmp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|requiredAction
init|=
literal|0
decl_stmt|;
name|bool
name|prvLclMask
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInformation
decl_stmt|;
name|t_FmPcdCcStatsParams
name|statsParams
init|=
block|{
literal|0
block|}
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|;
comment|/* Check that new NIA is legal */
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|prvLclMask
operator|=
name|p_CcNode
operator|->
name|lclMask
expr_stmt|;
comment|/* Check that new key is not require update of localMask */
name|err
operator|=
name|UpdateGblMask
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|,
name|p_KeyParams
operator|->
name|p_Mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
comment|/* Update internal data structure with new next engine for the given index */
name|memcpy
argument_list|(
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|key
argument_list|,
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_KeyParams
operator|->
name|p_Mask
condition|)
name|memcpy
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|mask
argument_list|,
name|p_KeyParams
operator|->
name|p_Mask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|mask
argument_list|,
literal|0xFF
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
comment|/* Update numOfKeys */
if|if
condition|(
name|add
condition|)
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|=
operator|(
name|uint8_t
operator|)
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
comment|/* Allocate new tables in MURAM: keys match table and action descriptors table */
name|err
operator|=
name|BuildNewNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
operator|&
name|size
argument_list|,
name|p_AdditionalInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* Check that manip is legal and what requiredAction is necessary for this manip */
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
operator||=
name|UPDATE_CC_WITH_TREE
expr_stmt|;
comment|/* Update new Ad and new Key Table according to new requirement */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_AdditionalInfo
operator|->
name|numOfKeys
condition|;
name|j
operator|++
control|)
block|{
name|p_AdTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|j
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|keyIndex
condition|)
block|{
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|statisticsEn
condition|)
block|{
comment|/* Allocate a statistics object that holds statistics AD and counters.                  - For added key - New statistics AD and counters pointer need to be allocated                  new statistics object. If statistics were enabled, we need to replace the                  existing descriptor with a new descriptor with nullified counters.                  */
name|p_StatsObj
operator|=
name|GetStatsObj
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
comment|/* Store allocated statistics object */
name|ASSERT_COND
argument_list|(
name|keyIndex
operator|<
name|CC_MAX_NUM_OF_KEYS
argument_list|)
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|=
name|p_StatsObj
expr_stmt|;
name|statsParams
operator|.
name|h_StatsAd
operator|=
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|statsParams
operator|.
name|h_StatsCounters
operator|=
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|statsParams
operator|.
name|h_StatsFLRs
operator|=
name|p_CcNode
operator|->
name|h_StatsFLRs
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* Building action descriptor for the received new key */
name|NextStepAd
argument_list|(
name|p_AdTableNewTmp
argument_list|,
operator|&
name|statsParams
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Building action descriptor for the received new key */
name|NextStepAd
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the received new key into keys match table */
name|p_KeysMatchTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|j
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
comment|/* Update mask for the received new key */
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
if|if
condition|(
name|p_KeyParams
operator|->
name|p_Mask
condition|)
block|{
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_KeyParams
operator|->
name|p_Mask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|>
literal|4
condition|)
block|{
name|MemSet8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
literal|0xff
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If key modification requested, the old entry is omitted and replaced by the new parameters */
if|if
condition|(
operator|!
name|add
condition|)
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy existing action descriptors to the newly allocated Ad table */
name|p_AdTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableOld
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|p_AdTableOldTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Copy existing keys and their masks to the newly allocated keys match table */
name|p_KeysMatchTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|j
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_KeysMatchTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableOld
argument_list|,
name|i
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
if|if
condition|(
name|prvLclMask
condition|)
block|{
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableOldTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_KeysMatchTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|h_KeysMatchTable
argument_list|,
name|i
operator|*
operator|(
name|int
operator|)
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|>
literal|4
condition|)
block|{
name|MemSet8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
literal|0xff
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|MemCpy8
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_KeysMatchTableOldTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* Miss action descriptor */
name|p_AdTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|j
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_AdTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableOld
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|p_AdTableOldTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreesLst
argument_list|)
condition|)
block|{
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_CcNode->ccTreesLst
argument_list|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
comment|/* Update the manipulation which has to be updated from parameters of the port */
comment|/* It's has to be updated with restrictions defined in the function */
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
name|p_CcNode
operator|->
name|shadowAction
operator||
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
argument_list|,
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
argument_list|,
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|keyIndex
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|CcUpdateParam
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
argument_list|,
literal|1
argument_list|,
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|keyIndex
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|p_CcNodeInformation
operator|->
name|index
argument_list|,
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
name|memset
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
literal|0xff
argument_list|,
name|CC_GLBL_MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|p_AdditionalInfo
operator|->
name|h_NodeForAdd
operator|=
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|h_Manip
condition|)
name|p_AdditionalInfo
operator|->
name|h_ManipForAdd
operator|=
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|h_Manip
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|p_AdditionalInfo
operator|->
name|h_FrmReplicForAdd
operator|=
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
operator|!
name|add
condition|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|p_AdditionalInfo
operator|->
name|h_NodeForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|p_AdditionalInfo
operator|->
name|h_ManipForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
expr_stmt|;
comment|/* If statistics were previously enabled, store the old statistics object to be released */
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
condition|)
block|{
name|p_AdditionalInfo
operator|->
name|p_StatsObjForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|p_AdditionalInfo
operator|->
name|h_FrmReplicForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildNewNodeRemoveKey
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalInfo
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|t_Handle
name|p_AdTableNewTmp
decl_stmt|,
name|p_KeysMatchTableNewTmp
decl_stmt|;
name|t_Handle
name|p_KeysMatchTableOldTmp
decl_stmt|,
name|p_AdTableOldTmp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
comment|/*save new numOfKeys*/
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*function which allocates in the memory new KeyTbl, AdTbl*/
name|err
operator|=
name|BuildNewNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
operator|&
name|size
argument_list|,
name|p_AdditionalInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/*update new Ad and new Key Table according to new requirement*/
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|keyIndex
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|p_CcNode
operator|->
name|numOfKeys
condition|)
break|break;
name|p_AdTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_AdTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableOld
argument_list|,
name|j
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|p_AdTableOldTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_KeysMatchTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableOld
argument_list|,
name|j
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_KeysMatchTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|i
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_KeysMatchTableOldTmp
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p_AdTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_AdTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableOld
argument_list|,
name|j
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|p_AdTableOldTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|p_AdditionalInfo
operator|->
name|h_NodeForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|p_AdditionalInfo
operator|->
name|h_ManipForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
expr_stmt|;
comment|/* If statistics were previously enabled, store the old statistics object to be released */
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
condition|)
block|{
name|p_AdditionalInfo
operator|->
name|p_StatsObjForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|p_AdditionalInfo
operator|->
name|h_FrmReplicForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildNewNodeModifyKey
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalInfo
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_Handle
name|p_AdTableNewTmp
decl_stmt|,
name|p_KeysMatchTableNewTmp
decl_stmt|;
name|t_Handle
name|p_KeysMatchTableOldTmp
decl_stmt|,
name|p_AdTableOldTmp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|bool
name|prvLclMask
decl_stmt|;
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|,
name|tmpStatsObj
decl_stmt|;
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|=
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
name|prvLclMask
operator|=
name|p_CcNode
operator|->
name|lclMask
expr_stmt|;
comment|/* Check that new key is not require update of localMask */
name|err
operator|=
name|UpdateGblMask
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|,
name|p_Mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
comment|/* Update internal data structure with new next engine for the given index */
name|memcpy
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|key
argument_list|,
name|p_Key
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Mask
condition|)
name|memcpy
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|mask
argument_list|,
name|p_Mask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|mask
argument_list|,
literal|0xFF
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
comment|/*function which build in the memory new KeyTbl, AdTbl*/
name|err
operator|=
name|BuildNewNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
operator|&
name|size
argument_list|,
name|p_AdditionalInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/*fill the New AdTable and New KeyTable*/
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|j
operator|<
name|p_AdditionalInfo
operator|->
name|numOfKeys
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|p_AdTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|j
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_AdTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableOld
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|p_AdTableOldTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|keyIndex
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|keyIndex
operator|<
name|CC_MAX_NUM_OF_KEYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
condition|)
block|{
comment|/* As statistics were enabled, we need to update the existing                  statistics descriptor with a new nullified counters. */
name|p_StatsObj
operator|=
name|GetStatsObj
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|SetStatsCounters
argument_list|(
name|p_AdTableNewTmp
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_StatsObj
operator|->
name|h_StatsCounters
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmpStatsObj
operator|.
name|h_StatsAd
operator|=
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|tmpStatsObj
operator|.
name|h_StatsCounters
operator|=
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
comment|/* As we need to replace only the counters, we build a new statistics                  object that holds the old AD and the new counters - this will be the                  currently used statistics object.                  The newly allocated AD is not required and may be released back to                  the available objects with the previous counters pointer. */
name|p_StatsObj
operator|->
name|h_StatsAd
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsAd
operator|=
name|tmpStatsObj
operator|.
name|h_StatsAd
expr_stmt|;
comment|/* Store allocated statistics object */
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|=
name|p_StatsObj
expr_stmt|;
comment|/* As statistics were previously enabled, store the old statistics object to be released */
name|p_AdditionalInfo
operator|->
name|p_StatsObjForRmv
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
expr_stmt|;
block|}
name|p_KeysMatchTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|j
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_Key
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
if|if
condition|(
name|p_Mask
condition|)
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_Mask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|>
literal|4
condition|)
name|MemSet8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
literal|0xff
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
else|else
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p_KeysMatchTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_KeysMatchTableNew
argument_list|,
name|j
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_KeysMatchTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|h_KeysMatchTable
argument_list|,
name|i
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
if|if
condition|(
name|prvLclMask
condition|)
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableOldTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
else|else
block|{
name|p_KeysMatchTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|h_KeysMatchTable
argument_list|,
name|i
operator|*
operator|(
name|int
operator|)
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|>
literal|4
condition|)
name|MemSet8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
literal|0xff
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
else|else
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
name|p_CcNode
operator|->
name|userSizeOfExtraction
argument_list|)
expr_stmt|;
block|}
block|}
name|MemCpy8
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p_KeysMatchTableNewTmp
argument_list|,
name|p_KeysMatchTableOldTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
expr_stmt|;
block|}
block|}
name|p_AdTableNewTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdditionalInfo
operator|->
name|p_AdTableNew
argument_list|,
name|j
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|p_AdTableOldTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|h_AdTable
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|p_AdTableNewTmp
argument_list|,
name|p_AdTableOldTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildNewNodeModifyNextEngine
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNodeOrTree
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_CcNextEngineParams
parameter_list|,
name|t_List
modifier|*
name|h_OldLst
parameter_list|,
name|t_List
modifier|*
name|h_NewLst
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_AdditionalInfo
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|requiredAction
init|=
literal|0
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInformation
decl_stmt|,
name|ccNodeInfo
decl_stmt|;
name|t_Handle
name|p_Ad
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_FmPcdCcNode1
init|=
name|NULL
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
name|NULL
decl_stmt|;
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|;
name|t_FmPcdCcStatsParams
name|statsParams
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNextEngineParams
argument_list|)
expr_stmt|;
comment|/* check that new NIA is legal */
if|if
condition|(
operator|!
name|p_AdditionalInfo
operator|->
name|tree
condition|)
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNextEngineParams
argument_list|,
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
else|else
comment|/* Statistics are not supported for CC root */
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNextEngineParams
argument_list|,
name|e_FM_PCD_CC_STATS_MODE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* Update internal data structure for next engine per index (index - key) */
name|memcpy
argument_list|(
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
argument_list|,
name|p_CcNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that manip is legal and what requiredAction is necessary for this manip */
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
name|p_CcNextEngineParams
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_AdditionalInfo
operator|->
name|tree
condition|)
block|{
name|p_FmPcdCcNode1
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|numOfKeys
operator|=
name|p_FmPcdCcNode1
operator|->
name|numOfKeys
expr_stmt|;
name|p_Ad
operator|=
name|p_FmPcdCcNode1
operator|->
name|h_AdTable
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|p_AdditionalInfo
operator|->
name|h_NodeForRmv
operator|=
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|p_AdditionalInfo
operator|->
name|h_ManipForRmv
operator|=
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|p_AdditionalInfo
operator|->
name|h_FrmReplicForRmv
operator|=
name|p_FmPcdCcNode1
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
else|else
block|{
name|p_FmPcdCcTree
operator|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
expr_stmt|;
name|p_Ad
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|p_AdditionalInfo
operator|->
name|h_NodeForRmv
operator|=
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|p_AdditionalInfo
operator|->
name|h_ManipForRmv
operator|=
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|p_AdditionalInfo
operator|->
name|h_FrmReplicForRmv
operator|=
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
if|if
condition|(
operator|(
name|p_CcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcNextEngineParams
operator|->
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|p_Ad
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|PTR_MOVE
argument_list|(
name|p_Ad
argument_list|,
name|keyIndex
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* If statistics were enabled, this Ad is the statistics Ad. Need to follow its      nextAction to retrieve the actual Nia-Ad. If statistics should remain enabled,      only the actual Nia-Ad should be modified. */
if|if
condition|(
operator|(
operator|!
name|p_AdditionalInfo
operator|->
name|tree
operator|)
operator|&&
operator|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|)
operator|&&
operator|(
name|p_CcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|h_OldLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|p_Ad
operator|=
name|GetNewAd
argument_list|(
name|h_FmPcdCcNodeOrTree
argument_list|,
name|p_AdditionalInfo
operator|->
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Ad
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node action descriptor"
operator|)
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_Ad
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* If statistics were not enabled before, but requested now -  Allocate a statistics      object that holds statistics AD and counters. */
if|if
condition|(
operator|(
operator|!
name|p_AdditionalInfo
operator|->
name|tree
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|)
operator|&&
operator|(
name|p_CcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
block|{
name|p_StatsObj
operator|=
name|GetStatsObj
argument_list|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
comment|/* Store allocated statistics object */
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|=
name|p_StatsObj
expr_stmt|;
name|statsParams
operator|.
name|h_StatsAd
operator|=
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|statsParams
operator|.
name|h_StatsCounters
operator|=
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|statsParams
operator|.
name|h_StatsFLRs
operator|=
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|h_StatsFLRs
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|NextStepAd
argument_list|(
name|p_Ad
argument_list|,
operator|&
name|statsParams
argument_list|,
name|p_CcNextEngineParams
argument_list|,
name|h_FmPcd
argument_list|)
expr_stmt|;
block|}
else|else
name|NextStepAd
argument_list|(
name|p_Ad
argument_list|,
name|NULL
argument_list|,
name|p_CcNextEngineParams
argument_list|,
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|p_Ad
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|h_NewLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
operator||=
name|UPDATE_CC_WITH_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|p_AdditionalInfo
operator|->
name|tree
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcNode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_FmPcdCcNode1
operator|->
name|ccTreesLst
argument_list|)
condition|)
block|{
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_FmPcdCcNode1->ccTreesLst
argument_list|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
comment|/* Update the manipulation which has to be updated from parameters of the port                  it's has to be updated with restrictions defined in the function */
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|p_FmPcdCcNode1
operator|->
name|h_FmPcd
argument_list|,
name|p_FmPcdCcNode1
operator|->
name|shadowAction
operator||
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
argument_list|,
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
argument_list|,
name|p_Ad
argument_list|,
literal|1
argument_list|,
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|CcUpdateParam
argument_list|(
name|p_FmPcdCcNode1
operator|->
name|h_FmPcd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
argument_list|,
literal|1
argument_list|,
name|p_Ad
argument_list|,
name|TRUE
argument_list|,
name|p_CcNodeInformation
operator|->
name|index
argument_list|,
name|p_CcNodeInformation
operator|->
name|h_CcNode
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|h_FmPcd
argument_list|,
name|p_FmPcdCcTree
operator|->
name|requiredAction
operator||
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|requiredAction
argument_list|,
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
argument_list|,
name|p_Ad
argument_list|,
literal|1
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|CcUpdateParam
argument_list|(
name|h_FmPcd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
argument_list|,
literal|1
argument_list|,
name|p_Ad
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_FmPcdCcTree
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|p_AdditionalInfo
operator|->
name|h_NodeForAdd
operator|=
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
name|p_CcNextEngineParams
operator|->
name|h_Manip
condition|)
name|p_AdditionalInfo
operator|->
name|h_ManipForAdd
operator|=
name|p_CcNextEngineParams
operator|->
name|h_Manip
expr_stmt|;
comment|/* If statistics were previously enabled, but now are disabled,      store the old statistics object to be released */
if|if
condition|(
operator|(
operator|!
name|p_AdditionalInfo
operator|->
name|tree
operator|)
operator|&&
operator|(
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|)
operator|&&
operator|(
operator|!
name|p_CcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
block|{
name|p_AdditionalInfo
operator|->
name|p_StatsObjForRmv
operator|=
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
operator|)
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
expr_stmt|;
name|p_AdditionalInfo
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_CcNextEngineParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|p_AdditionalInfo
operator|->
name|h_FrmReplicForAdd
operator|=
name|p_CcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CrntMdfNode
parameter_list|,
name|t_List
modifier|*
name|h_OldLst
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
modifier|*
name|p_NextEngineParams
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInformation
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_NodePtrOnCurrentMdfNode
init|=
name|NULL
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|t_Handle
name|p_AdTablePtOnCrntCurrentMdfNode
comment|/*, p_AdTableNewModified*/
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_CrntMdfNode->ccPrevNodesLst
argument_list|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|p_NodePtrOnCurrentMdfNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_CcNodeInformation
operator|->
name|h_CcNode
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_NodePtrOnCurrentMdfNode
argument_list|)
expr_stmt|;
comment|/* Search in the previous node which exact index points on this current modified node for getting AD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_NodePtrOnCurrentMdfNode
operator|->
name|numOfKeys
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_NodePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
if|if
condition|(
name|p_NodePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
operator|==
operator|(
name|t_Handle
operator|)
name|p_CrntMdfNode
condition|)
block|{
if|if
condition|(
name|p_NodePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|p_AdTablePtOnCrntCurrentMdfNode
operator|=
name|p_CrntMdfNode
operator|->
name|h_Ad
expr_stmt|;
elseif|else
if|if
condition|(
name|p_NodePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|p_StatsObj
condition|)
name|p_AdTablePtOnCrntCurrentMdfNode
operator|=
name|p_NodePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
else|else
name|p_AdTablePtOnCrntCurrentMdfNode
operator|=
name|PTR_MOVE
argument_list|(
name|p_NodePtrOnCurrentMdfNode
operator|->
name|h_AdTable
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|p_AdTablePtOnCrntCurrentMdfNode
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|h_OldLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p_NextEngineParams
operator|)
condition|)
operator|*
name|p_NextEngineParams
operator|=
operator|&
name|p_NodePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
expr_stmt|;
block|}
block|}
block|}
name|ASSERT_COND
argument_list|(
name|i
operator|!=
name|p_NodePtrOnCurrentMdfNode
operator|->
name|numOfKeys
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CrntMdfNode
parameter_list|,
name|t_List
modifier|*
name|h_OldLst
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
modifier|*
name|p_NextEngineParams
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInformation
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_TreePtrOnCurrentMdfNode
init|=
name|NULL
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|t_Handle
name|p_AdTableTmp
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_CrntMdfNode->ccTreeIdLst
argument_list|)
block|{
name|p_CcNodeInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|p_TreePtrOnCurrentMdfNode
operator|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|p_CcNodeInformation
operator|->
name|h_CcNode
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_TreePtrOnCurrentMdfNode
argument_list|)
expr_stmt|;
comment|/*search in the trees which exact index points on this current modified node for getting AD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_TreePtrOnCurrentMdfNode
operator|->
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_TreePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
if|if
condition|(
name|p_TreePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
operator|==
operator|(
name|t_Handle
operator|)
name|p_CrntMdfNode
condition|)
block|{
name|p_AdTableTmp
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_TreePtrOnCurrentMdfNode
operator|->
name|ccTreeBaseAddr
operator|+
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|p_AdTableTmp
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|h_OldLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p_NextEngineParams
operator|)
condition|)
operator|*
name|p_NextEngineParams
operator|=
operator|&
name|p_TreePtrOnCurrentMdfNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
expr_stmt|;
block|}
block|}
block|}
name|ASSERT_COND
argument_list|(
name|i
operator|==
name|p_TreePtrOnCurrentMdfNode
operator|->
name|numOfEntries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|ModifyNodeCommonPart
parameter_list|(
name|t_Handle
name|h_FmPcdCcNodeOrTree
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|e_ModifyState
name|modifyState
parameter_list|,
name|bool
name|ttlCheck
parameter_list|,
name|bool
name|hashCheck
parameter_list|,
name|bool
name|tree
parameter_list|)
block|{
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_FmPcdModifyCcKeyAdditionalParams
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|bool
name|wasUpdate
init|=
name|FALSE
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
name|NULL
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
decl_stmt|;
name|uint16_t
name|numOfKeys
decl_stmt|;
name|t_FmPcdCcKeyAndNextEngineParams
modifier|*
name|p_KeyAndNextEngineParams
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcdCcNodeOrTree
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
block|{
name|p_CcNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
expr_stmt|;
name|numOfKeys
operator|=
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
comment|/* node has to be pointed by another node or tree */
name|p_KeyAndNextEngineParams
operator|=
operator|(
name|t_FmPcdCcKeyAndNextEngineParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
operator|*
operator|(
name|numOfKeys
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_KeyAndNextEngineParams
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Next engine and required action structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|p_KeyAndNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
argument_list|,
operator|(
name|numOfKeys
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttlCheck
condition|)
block|{
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_FF_IPV4TTL
operator|)
operator|||
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_FF_IPV6HOP_LIMIT
operator|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_KeyAndNextEngineParams
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for this operation"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|hashCheck
condition|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_GENERIC_IC_HASH_INDEXED
condition|)
block|{
name|XX_Free
argument_list|(
name|p_KeyAndNextEngineParams
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"nodeId of CC_PC_GENERIC_IC_HASH_INDEXED can not be used for this operation"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
else|else
block|{
name|p_FmPcdCcTree
operator|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcNodeOrTree
expr_stmt|;
name|numOfKeys
operator|=
name|p_FmPcdCcTree
operator|->
name|numOfEntries
expr_stmt|;
name|p_KeyAndNextEngineParams
operator|=
operator|(
name|t_FmPcdCcKeyAndNextEngineParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
operator|*
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_KeyAndNextEngineParams
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Next engine and required action structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|p_KeyAndNextEngineParams
argument_list|,
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
argument_list|,
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPcdModifyCcKeyAdditionalParams
operator|=
operator|(
name|t_FmPcdModifyCcKeyAdditionalParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdModifyCcKeyAdditionalParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdModifyCcKeyAdditionalParams
condition|)
block|{
name|XX_Free
argument_list|(
name|p_KeyAndNextEngineParams
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Allocation of internal data structure FAILED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcdModifyCcKeyAdditionalParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdModifyCcKeyAdditionalParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|h_CurrentNode
operator|=
name|h_FmPcdCcNodeOrTree
expr_stmt|;
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|savedKeyIndex
operator|=
name|keyIndex
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|numOfKeys
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|==
name|keyIndex
operator|)
operator|&&
operator|!
name|wasUpdate
condition|)
block|{
if|if
condition|(
name|modifyState
operator|==
name|e_MODIFY_STATE_ADD
condition|)
name|j
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|modifyState
operator|==
name|e_MODIFY_STATE_REMOVE
condition|)
name|i
operator|++
expr_stmt|;
name|wasUpdate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|keyAndNextEngineParams
index|[
name|j
index|]
argument_list|,
name|p_KeyAndNextEngineParams
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|keyIndex
operator|==
name|numOfKeys
condition|)
block|{
if|if
condition|(
name|modifyState
operator|==
name|e_MODIFY_STATE_ADD
condition|)
name|j
operator|++
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|p_FmPcdModifyCcKeyAdditionalParams
operator|->
name|keyAndNextEngineParams
index|[
name|j
index|]
argument_list|,
name|p_KeyAndNextEngineParams
operator|+
name|numOfKeys
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_KeyAndNextEngineParams
argument_list|)
expr_stmt|;
return|return
name|p_FmPcdModifyCcKeyAdditionalParams
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|UpdatePtrWhichPointOnCrntMdfNode
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_FmPcdModifyCcKeyAdditionalParams
parameter_list|,
name|t_List
modifier|*
name|h_OldLst
parameter_list|,
name|t_List
modifier|*
name|h_NewLst
parameter_list|)
block|{
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_NextEngineParams
init|=
name|NULL
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
init|=
block|{
literal|0
block|}
decl_stmt|;
name|t_Handle
name|h_NewAd
decl_stmt|;
name|t_Handle
name|h_OrigAd
init|=
name|NULL
decl_stmt|;
comment|/* Building a list of all action descriptors that point to the previous node */
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccPrevNodesLst
argument_list|)
condition|)
name|UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode
argument_list|(
name|p_CcNode
argument_list|,
name|h_OldLst
argument_list|,
operator|&
name|p_NextEngineParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NCSW_LIST_IsEmpty
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreeIdLst
argument_list|)
condition|)
name|UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode
argument_list|(
name|p_CcNode
argument_list|,
name|h_OldLst
argument_list|,
operator|&
name|p_NextEngineParams
argument_list|)
expr_stmt|;
comment|/* This node must be found as next engine of one of its previous nodes or trees*/
if|if
condition|(
name|p_NextEngineParams
condition|)
block|{
comment|/* Building a new action descriptor that points to the modified node */
name|h_NewAd
operator|=
name|GetNewAd
argument_list|(
name|p_CcNode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_NewAd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|MemSet8
argument_list|(
name|h_NewAd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|h_OrigAd
operator|=
name|p_CcNode
operator|->
name|h_Ad
expr_stmt|;
name|BuildNewAd
argument_list|(
name|h_NewAd
argument_list|,
name|p_FmPcdModifyCcKeyAdditionalParams
argument_list|,
name|p_CcNode
argument_list|,
name|p_NextEngineParams
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|h_NewAd
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|h_NewLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_NextEngineParams
operator|->
name|h_Manip
operator|&&
operator|!
name|h_OrigAd
condition|)
name|FmPcdManipUpdateOwner
argument_list|(
name|p_NextEngineParams
operator|->
name|h_Manip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateCcRootOwner
parameter_list|(
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
comment|/* this routine must be protected by the calling routine! */
if|if
condition|(
name|add
condition|)
name|p_FmPcdCcTree
operator|->
name|owners
operator|++
expr_stmt|;
else|else
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
operator|->
name|owners
argument_list|)
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|owners
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CheckAndSetManipParamsWithCcNodeParams
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsWithCcNodeParams
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|ValidateAndCalcStatsParams
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|,
name|uint32_t
modifier|*
name|p_NumOfRanges
parameter_list|,
name|uint32_t
modifier|*
name|p_CountersArraySize
parameter_list|)
block|{
name|e_FmPcdCcStatsMode
name|statisticsMode
init|=
name|p_CcNode
operator|->
name|statisticsMode
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|UNUSED
argument_list|(
name|p_CcNodeParam
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|statisticsMode
condition|)
block|{
case|case
name|e_FM_PCD_CC_STATS_MODE_NONE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keyParams
index|[
name|i
index|]
operator|.
name|ccNextEngineParams
operator|.
name|statisticsEn
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Statistics cannot be enabled for key %d when statistics mode was set to 'NONE'"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
case|case
name|e_FM_PCD_CC_STATS_MODE_FRAME
case|:
case|case
name|e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME
case|:
operator|*
name|p_NumOfRanges
operator|=
literal|1
expr_stmt|;
operator|*
name|p_CountersArraySize
operator|=
literal|2
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
expr_stmt|;
return|return
name|E_OK
return|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
name|e_FM_PCD_CC_STATS_MODE_RMON
case|:
block|{
name|uint16_t
modifier|*
name|p_FrameLengthRanges
init|=
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|frameLengthRanges
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|p_FrameLengthRanges
index|[
literal|0
index|]
operator|<=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Statistics mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FrameLengthRanges
index|[
literal|0
index|]
operator|==
literal|0xFFFF
condition|)
block|{
operator|*
name|p_NumOfRanges
operator|=
literal|1
expr_stmt|;
operator|*
name|p_CountersArraySize
operator|=
literal|2
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|FM_PCD_CC_STATS_MAX_NUM_OF_FLR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FrameLengthRanges
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|p_FrameLengthRanges
index|[
name|i
index|]
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Frame length range must be larger at least by 1 from preceding range"
operator|)
argument_list|)
expr_stmt|;
comment|/* Stop when last range is reached */
if|if
condition|(
name|p_FrameLengthRanges
index|[
name|i
index|]
operator|==
literal|0xFFFF
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|>=
name|FM_PCD_CC_STATS_MAX_NUM_OF_FLR
operator|)
operator|||
operator|(
name|p_FrameLengthRanges
index|[
name|i
index|]
operator|!=
literal|0xFFFF
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Last Frame length range must be 0xFFFF"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_NumOfRanges
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Allocate an extra counter for byte count, as counters              array always begins with byte count */
operator|*
name|p_CountersArraySize
operator|=
operator|(
operator|*
name|p_NumOfRanges
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
expr_stmt|;
block|}
return|return
name|E_OK
return|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Statistics mode"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CheckParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|,
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|bool
modifier|*
name|isKeyTblAlloc
parameter_list|)
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint32_t
name|requiredAction
init|=
literal|0
decl_stmt|;
comment|/* Validate statistics parameters */
name|err
operator|=
name|ValidateAndCalcStatsParams
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNodeParam
argument_list|,
operator|&
operator|(
name|p_CcNode
operator|->
name|numOfStatsFLRs
operator|)
argument_list|,
operator|&
operator|(
name|p_CcNode
operator|->
name|countersArraySize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Invalid statistics parameters"
operator|)
argument_list|)
expr_stmt|;
comment|/* Validate next engine parameters on Miss */
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"For this node MissNextEngineParams are not valid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|tmp
operator|++
control|)
block|{
name|p_KeyParams
operator|=
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keyParams
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_KeyParams
operator|->
name|p_Key
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"p_Key is not initialized"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|UpdateGblMask
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
argument_list|,
name|p_KeyParams
operator|->
name|p_Mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store 'key' parameters - key, mask (if passed by the user) */
name|memcpy
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|key
argument_list|,
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|p_Mask
condition|)
name|memcpy
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|mask
argument_list|,
name|p_KeyParams
operator|->
name|p_Mask
argument_list|,
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|mask
operator|)
argument_list|,
literal|0xFF
argument_list|,
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
argument_list|)
expr_stmt|;
comment|/* Store next engine parameters */
name|memcpy
argument_list|(
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Number of keys exceed the provided maximal number of keys"
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|isKeyTblAlloc
operator|=
name|TRUE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|Ipv4TtlOrIpv6HopLimitCheckParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|,
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|bool
modifier|*
name|isKeyTblAlloc
parameter_list|)
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint8_t
name|key
init|=
literal|0x01
decl_stmt|;
name|uint32_t
name|requiredAction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|numOfKeys
operator|!=
literal|1
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
operator|)
operator|&&
operator|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
operator|!=
literal|1
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"
operator|)
argument_list|)
expr_stmt|;
comment|/* Validate statistics parameters */
name|err
operator|=
name|ValidateAndCalcStatsParams
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNodeParam
argument_list|,
operator|&
operator|(
name|p_CcNode
operator|->
name|numOfStatsFLRs
operator|)
argument_list|,
operator|&
operator|(
name|p_CcNode
operator|->
name|countersArraySize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Invalid statistics parameters"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"For this node MissNextEngineParams are not valid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|p_CcNode
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|tmp
operator|++
control|)
block|{
name|p_KeyParams
operator|=
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keyParams
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|p_Mask
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
operator|&
name|key
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store 'key' parameters - key (fixed to 0x01), key size of 1 byte and full mask */
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|key
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|mask
index|[
literal|0
index|]
operator|=
literal|0xFF
expr_stmt|;
comment|/* Store NextEngine parameters */
name|memcpy
argument_list|(
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
block|}
operator|*
name|isKeyTblAlloc
operator|=
name|FALSE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|IcHashIndexedCheckParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|,
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|bool
modifier|*
name|isKeyTblAlloc
parameter_list|)
block|{
name|int
name|tmp
init|=
literal|0
decl_stmt|,
name|countOnes
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint16_t
name|glblMask
init|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|icIndxMask
decl_stmt|;
name|uint16_t
name|countMask
init|=
call|(
name|uint16_t
call|)
argument_list|(
name|glblMask
operator|>>
literal|4
argument_list|)
decl_stmt|;
name|uint32_t
name|requiredAction
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|glblMask
operator|&
literal|0x000f
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"icIndxMask has to be with last nibble 0"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|countMask
condition|)
block|{
name|countOnes
operator|++
expr_stmt|;
name|countMask
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|countMask
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For Node of the type INDEXED numOfKeys has to be powerOfTwo"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|numOfKeys
operator|!=
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
name|countOnes
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
operator|&&
operator|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
operator|!=
name|p_CcNode
operator|->
name|numOfKeys
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"
operator|)
argument_list|)
expr_stmt|;
comment|/* Validate statistics parameters */
name|err
operator|=
name|ValidateAndCalcStatsParams
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNodeParam
argument_list|,
operator|&
operator|(
name|p_CcNode
operator|->
name|numOfStatsFLRs
operator|)
argument_list|,
operator|&
operator|(
name|p_CcNode
operator|->
name|countersArraySize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Invalid statistics parameters"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_NOT_SUPPORTED
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|tmp
operator|++
control|)
block|{
name|p_KeyParams
operator|=
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keyParams
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|p_Mask
operator|||
name|p_KeyParams
operator|->
name|p_Key
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|glblMask
operator|&
operator|(
name|tmp
operator|*
literal|16
operator|)
operator|)
operator|==
operator|(
name|tmp
operator|*
literal|16
operator|)
condition|)
block|{
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_CcNode
operator|->
name|statisticsMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_NOT_SUPPORTED
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|isKeyTblAlloc
operator|=
name|FALSE
expr_stmt|;
name|glblMask
operator|=
name|htobe16
argument_list|(
name|glblMask
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|glblMask
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|ModifyNextEngineParamNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"keyIndex> previously cleared last index + 1"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_CHANGE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|&&
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|BuildNewNodeModifyNextEngine
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|FindKeyIndex
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|,
name|uint16_t
modifier|*
name|p_KeyIndex
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint8_t
name|tmpMask
index|[
name|FM_PCD_MAX_SIZE_OF_KEY
index|]
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Key
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_KeyIndex
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|keySize
operator|<
name|FM_PCD_MAX_SIZE_OF_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|keySize
operator|!=
name|p_CcNode
operator|->
name|userSizeOfExtraction
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Key size doesn't match the extraction size of the node"
operator|)
argument_list|)
expr_stmt|;
comment|/* If user didn't pass a mask for this key, we'll look for full extraction mask */
if|if
condition|(
operator|!
name|p_Mask
condition|)
name|memset
argument_list|(
name|tmpMask
argument_list|,
literal|0xFF
argument_list|,
name|keySize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|i
operator|++
control|)
block|{
comment|/* Comparing received key */
if|if
condition|(
name|memcmp
argument_list|(
name|p_Key
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|keySize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_Mask
condition|)
block|{
comment|/* If a user passed a mask for this key, it must match to the existing key's mask for a correct match */
if|if
condition|(
name|memcmp
argument_list|(
name|p_Mask
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|keySize
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p_KeyIndex
operator|=
name|i
expr_stmt|;
return|return
name|E_OK
return|;
block|}
block|}
else|else
block|{
comment|/* If user didn't pass a mask for this key, check if the existing key mask is full extraction */
if|if
condition|(
name|memcmp
argument_list|(
name|tmpMask
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|mask
argument_list|,
name|keySize
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p_KeyIndex
operator|=
name|i
expr_stmt|;
return|return
name|E_OK
return|;
block|}
block|}
block|}
block|}
return|return
name|ERROR_CODE
argument_list|(
name|E_NOT_FOUND
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CalcAndUpdateCcShadow
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|bool
name|isKeyTblAlloc
parameter_list|,
name|uint32_t
modifier|*
name|p_MatchTableSize
parameter_list|,
name|uint32_t
modifier|*
name|p_AdTableSize
parameter_list|)
block|{
name|uint32_t
name|shadowSize
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* Calculate keys table maximal size - each entry consists of a key and a mask,      (if local mask support is requested) */
operator|*
name|p_MatchTableSize
operator|=
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|p_CcNode
operator|->
name|maxNumOfKeys
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maskSupport
condition|)
operator|*
name|p_MatchTableSize
operator|*=
literal|2
expr_stmt|;
comment|/* Calculate next action descriptors table, including one more entry for miss */
operator|*
name|p_AdTableSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|+
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Calculate maximal shadow size of this node.      All shadow structures will be used for runtime modifications host command. If      keys table was allocated for this node, the keys table and next engines table may      be modified in run time (entries added or removed), so shadow tables are requires.      Otherwise, the only supported runtime modification is a specific next engine update      and this requires shadow memory of a single AD */
comment|/* Shadow size should be enough to hold the following 3 structures:      * 1 - an action descriptor */
name|shadowSize
operator|=
name|FM_PCD_CC_AD_ENTRY_SIZE
expr_stmt|;
comment|/* 2 - keys match table, if was allocated for the current node */
if|if
condition|(
name|isKeyTblAlloc
condition|)
name|shadowSize
operator|+=
operator|*
name|p_MatchTableSize
expr_stmt|;
comment|/* 3 - next action descriptors table */
name|shadowSize
operator|+=
operator|*
name|p_AdTableSize
expr_stmt|;
comment|/* Update shadow to the calculated size */
name|err
operator|=
name|FmPcdUpdateCcShadow
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
operator|(
name|uint32_t
operator|)
name|shadowSize
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node shadow"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AllocStatsObjs
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|)
block|{
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|;
name|t_Handle
name|h_FmMuram
decl_stmt|,
name|h_StatsAd
decl_stmt|,
name|h_StatsCounters
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|h_FmMuram
operator|=
name|FmPcdGetMuramHandle
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_FmMuram
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"FM MURAM"
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate statistics ADs and statistics counter. An extra pair (AD + counters)      will be allocated to support runtime modifications */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Allocate list object structure */
name|p_StatsObj
operator|=
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdStatsObj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_StatsObj
condition|)
block|{
name|FreeStatObjects
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|,
name|h_FmMuram
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Statistics object"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_StatsObj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdStatsObj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate statistics AD from MURAM */
name|h_StatsAd
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_StatsAd
condition|)
block|{
name|FreeStatObjects
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|,
name|h_FmMuram
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for statistics ADs"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
name|h_StatsAd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Allocate statistics counters from MURAM */
name|h_StatsCounters
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|p_CcNode
operator|->
name|countersArraySize
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_StatsCounters
condition|)
block|{
name|FreeStatObjects
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|,
name|h_FmMuram
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|h_FmMuram
argument_list|,
name|h_StatsAd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for statistics counters"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
name|h_StatsCounters
argument_list|,
literal|0
argument_list|,
name|p_CcNode
operator|->
name|countersArraySize
argument_list|)
expr_stmt|;
name|p_StatsObj
operator|->
name|h_StatsAd
operator|=
name|h_StatsAd
expr_stmt|;
name|p_StatsObj
operator|->
name|h_StatsCounters
operator|=
name|h_StatsCounters
expr_stmt|;
name|EnqueueStatsObj
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|,
name|p_StatsObj
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|MatchTableGetKeyStatistics
parameter_list|(
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcKeyStatistics
modifier|*
name|p_KeyStatistics
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p_StatsCounters
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|statisticsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_NONE
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Statistics were not enabled for this match table"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Statistics were not enabled for this key"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_KeyStatistics
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyStatistics
argument_list|)
argument_list|)
expr_stmt|;
name|p_StatsCounters
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsCounters
argument_list|)
expr_stmt|;
name|p_KeyStatistics
operator|->
name|byteCount
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_StatsCounters
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_CcNode
operator|->
name|numOfStatsFLRs
condition|;
name|i
operator|++
control|)
block|{
name|p_StatsCounters
operator|=
name|PTR_MOVE
argument_list|(
name|p_StatsCounters
argument_list|,
name|FM_PCD_CC_STATS_COUNTER_SIZE
argument_list|)
expr_stmt|;
name|p_KeyStatistics
operator|->
name|frameCount
operator|+=
name|GET_UINT32
argument_list|(
operator|*
name|p_StatsCounters
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|p_KeyStatistics
operator|->
name|frameLengthRangeCount
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|GET_UINT32
argument_list|(
operator|*
name|p_StatsCounters
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|MatchTableSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
parameter_list|,
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_FmPcdCcNextNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|,
name|keySize
decl_stmt|;
name|bool
name|glblMask
init|=
name|FALSE
decl_stmt|;
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
decl_stmt|;
name|t_Handle
name|h_FmMuram
decl_stmt|,
name|p_KeysMatchTblTmp
decl_stmt|,
name|p_AdTableTmp
decl_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|t_Handle
name|h_StatsFLRs
decl_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|bool
name|fullField
init|=
name|FALSE
decl_stmt|;
name|ccPrivateInfo_t
name|icCode
init|=
name|CC_PRIVATE_INFO_NONE
decl_stmt|;
name|bool
name|isKeyTblAlloc
decl_stmt|,
name|fromIc
init|=
name|FALSE
decl_stmt|;
name|uint32_t
name|matchTableSize
decl_stmt|,
name|adTableSize
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|,
modifier|*
name|p_CcInformation
decl_stmt|;
name|t_FmPcdStatsObj
modifier|*
name|p_StatsObj
decl_stmt|;
name|t_FmPcdCcStatsParams
name|statsParams
init|=
block|{
literal|0
block|}
decl_stmt|;
name|t_Handle
name|h_Manip
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeParam
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|p_GlblMask
operator|=
operator|(
name|t_Handle
operator|)
name|XX_Malloc
argument_list|(
name|CC_GLBL_MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
literal|0
argument_list|,
name|CC_GLBL_MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_FmPcd
operator|=
name|h_FmPcd
expr_stmt|;
name|p_CcNode
operator|->
name|numOfKeys
operator|=
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|numOfKeys
expr_stmt|;
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|=
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
expr_stmt|;
name|p_CcNode
operator|->
name|maskSupport
operator|=
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|maskSupport
expr_stmt|;
name|p_CcNode
operator|->
name|statisticsMode
operator|=
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|statisticsMode
expr_stmt|;
comment|/* For backward compatibility - even if statistics mode is nullified,      we'll fix it to frame mode so we can support per-key request for      statistics using 'statisticsEn' in next engine parameters */
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|&&
operator|(
name|p_CcNode
operator|->
name|statisticsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_NONE
operator|)
condition|)
name|p_CcNode
operator|->
name|statisticsMode
operator|=
name|e_FM_PCD_CC_STATS_MODE_FRAME
expr_stmt|;
name|h_FmMuram
operator|=
name|FmPcdGetMuramHandle
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_FmMuram
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"FM MURAM"
operator|)
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccPrevNodesLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreeIdLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_CcNode
operator|->
name|ccTreesLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_CcNode
operator|->
name|availableStatsLst
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|h_Spinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_Spinlock
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"CC node spinlock"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|type
operator|==
name|e_FM_PCD_EXTRACT_BY_HDR
operator|)
operator|&&
operator|(
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv4
operator|)
operator|||
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdr
operator|==
name|HEADER_TYPE_IPv6
operator|)
operator|)
operator|&&
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|type
operator|==
name|e_FM_PCD_EXTRACT_FULL_FIELD
operator|)
operator|&&
operator|(
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv6
operator|==
name|NET_HEADER_FIELD_IPv6_HOP_LIMIT
operator|)
operator|||
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|ipv4
operator|==
name|NET_HEADER_FIELD_IPv4_TTL
operator|)
operator|)
condition|)
block|{
name|err
operator|=
name|Ipv4TtlOrIpv6HopLimitCheckParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNodeParam
argument_list|,
name|p_CcNode
argument_list|,
operator|&
name|isKeyTblAlloc
argument_list|)
expr_stmt|;
name|glblMask
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|type
operator|==
name|e_FM_PCD_EXTRACT_NON_HDR
operator|)
operator|&&
operator|(
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
operator|==
name|e_FM_PCD_EXTRACT_FROM_KEY
operator|)
operator|||
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
operator|==
name|e_FM_PCD_EXTRACT_FROM_HASH
operator|)
operator|||
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
operator|==
name|e_FM_PCD_EXTRACT_FROM_FLOW_ID
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
operator|==
name|e_FM_PCD_EXTRACT_FROM_FLOW_ID
operator|)
operator|&&
operator|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"
operator|)
argument_list|)
expr_stmt|;
block|}
name|icCode
operator|=
name|IcDefineCode
argument_list|(
name|p_CcNodeParam
argument_list|)
expr_stmt|;
name|fromIc
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|icCode
operator|==
name|CC_PRIVATE_INFO_NONE
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"user asked extraction from IC and field in internal context or action wasn't initialized in the right way"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|icCode
operator|==
name|CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP
operator|)
operator|||
operator|(
name|icCode
operator|==
name|CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP
operator|)
condition|)
block|{
name|err
operator|=
name|IcHashIndexedCheckParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNodeParam
argument_list|,
name|p_CcNode
argument_list|,
operator|&
name|isKeyTblAlloc
argument_list|)
expr_stmt|;
name|glblMask
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|CheckParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNodeParam
argument_list|,
name|p_CcNode
argument_list|,
operator|&
name|isKeyTblAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|glblMaskSize
condition|)
name|glblMask
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|CheckParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNodeParam
argument_list|,
name|p_CcNode
argument_list|,
operator|&
name|isKeyTblAlloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|glblMaskSize
condition|)
name|glblMask
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_BY_HDR
operator|)
case|:
switch|switch
condition|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FULL_FIELD
operator|)
case|:
name|p_CcNode
operator|->
name|parseCode
operator|=
name|GetFullFieldParseCode
argument_list|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdrIndex
argument_list|,
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
argument_list|)
expr_stmt|;
name|GetSizeHeaderField
argument_list|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
argument_list|,
operator|&
name|p_CcNode
operator|->
name|sizeOfExtraction
argument_list|)
expr_stmt|;
name|fullField
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_TCI1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_TCI2
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_MPLS1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_MPLS_LAST
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPV4IPTOS_TC1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPV4IPTOS_TC2
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPDSCP
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|!=
name|CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2
operator|)
operator|&&
name|glblMask
condition|)
block|{
name|glblMask
operator|=
name|FALSE
expr_stmt|;
name|p_CcNode
operator|->
name|glblMaskSize
operator|=
literal|4
expr_stmt|;
name|p_CcNode
operator|->
name|lclMask
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_HDR
operator|)
case|:
name|p_CcNode
operator|->
name|sizeOfExtraction
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|size
expr_stmt|;
name|p_CcNode
operator|->
name|offset
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
expr_stmt|;
name|p_CcNode
operator|->
name|userOffset
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
expr_stmt|;
name|p_CcNode
operator|->
name|parseCode
operator|=
name|GetPrParseCode
argument_list|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdrIndex
argument_list|,
name|p_CcNode
operator|->
name|offset
argument_list|,
name|glblMask
argument_list|,
operator|&
name|p_CcNode
operator|->
name|prsArrayOffset
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_FIELD
operator|)
case|:
name|p_CcNode
operator|->
name|offset
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|offset
expr_stmt|;
name|p_CcNode
operator|->
name|userOffset
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|offset
expr_stmt|;
name|p_CcNode
operator|->
name|sizeOfExtraction
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|size
expr_stmt|;
name|p_CcNode
operator|->
name|parseCode
operator|=
name|GetFieldParseCode
argument_list|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|field
argument_list|,
name|p_CcNode
operator|->
name|offset
argument_list|,
operator|&
name|p_CcNode
operator|->
name|prsArrayOffset
argument_list|,
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractByHdr
operator|.
name|hdrIndex
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_NON_HDR
operator|)
case|:
comment|/* get the field code for the generic extract */
name|p_CcNode
operator|->
name|sizeOfExtraction
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|size
expr_stmt|;
name|p_CcNode
operator|->
name|offset
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|offset
expr_stmt|;
name|p_CcNode
operator|->
name|userOffset
operator|=
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|offset
expr_stmt|;
name|p_CcNode
operator|->
name|parseCode
operator|=
name|GetGenParseCode
argument_list|(
name|p_CcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
argument_list|,
name|p_CcNode
operator|->
name|offset
argument_list|,
name|glblMask
argument_list|,
operator|&
name|p_CcNode
operator|->
name|prsArrayOffset
argument_list|,
name|fromIc
argument_list|,
name|icCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_GENERIC_IC_HASH_INDEXED
condition|)
block|{
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|offset
operator|+
name|p_CcNode
operator|->
name|sizeOfExtraction
operator|)
operator|>
literal|8
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_GENERIC_IC_GMASK
operator|)
operator|||
operator|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_GENERIC_IC_HASH_INDEXED
operator|)
condition|)
block|{
name|p_CcNode
operator|->
name|offset
operator|+=
name|p_CcNode
operator|->
name|prsArrayOffset
expr_stmt|;
name|p_CcNode
operator|->
name|prsArrayOffset
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_ILLEGAL
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"illegal extraction type"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|sizeOfExtraction
operator|>
name|FM_PCD_MAX_SIZE_OF_KEY
operator|)
operator|||
operator|!
name|p_CcNode
operator|->
name|sizeOfExtraction
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"sizeOfExatrction can not be greater than 56 and not 0"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
operator|!=
name|p_CcNode
operator|->
name|sizeOfExtraction
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"keySize has to be equal to sizeOfExtraction"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_CcNode
operator|->
name|userSizeOfExtraction
operator|=
name|p_CcNode
operator|->
name|sizeOfExtraction
expr_stmt|;
if|if
condition|(
operator|!
name|glblMask
condition|)
name|memset
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
literal|0xff
argument_list|,
name|CC_GLBL_MASK_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|CheckAndSetManipParamsWithCcNodeParams
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"keySize has to be equal to sizeOfExtraction"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Calculating matching table entry size by rounding up the user-defined size of extraction to valid entry size */
name|GetCcExtractKeySize
argument_list|(
name|p_CcNode
operator|->
name|sizeOfExtraction
argument_list|,
operator|&
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
expr_stmt|;
comment|/* If local mask is used, it is stored next to each key in the keys match table */
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
name|keySize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|2
operator|*
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
expr_stmt|;
else|else
name|keySize
operator|=
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
expr_stmt|;
comment|/* Update CC shadow with maximal size required by this node */
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
name|err
operator|=
name|CalcAndUpdateCcShadow
argument_list|(
name|p_CcNode
argument_list|,
name|isKeyTblAlloc
argument_list|,
operator|&
name|matchTableSize
argument_list|,
operator|&
name|adTableSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_CcNode
operator|->
name|keysMatchTableMaxSize
operator|=
name|matchTableSize
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|statisticsMode
operator|!=
name|e_FM_PCD_CC_STATS_MODE_NONE
condition|)
block|{
name|err
operator|=
name|AllocStatsObjs
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If manipulation will be initialized before this node, it will use the table          descriptor in the AD table of previous node and this node will need an extra          AD as his table descriptor. */
name|p_CcNode
operator|->
name|h_TmpAd
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_TmpAd
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC action descriptor"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|matchTableSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|keySize
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
operator|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|adTableSize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|FM_PCD_CC_AD_ENTRY_SIZE
operator|*
operator|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
switch|switch
condition|(
name|p_CcNode
operator|->
name|statisticsMode
condition|)
block|{
case|case
name|e_FM_PCD_CC_STATS_MODE_RMON
case|:
comment|/* If RMON statistics or RMON conditional statistics modes are requested,              allocate frame length ranges array */
name|p_CcNode
operator|->
name|h_StatsFLRs
operator|=
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|p_CcNode
operator|->
name|numOfStatsFLRs
argument_list|)
operator|*
name|FM_PCD_CC_STATS_FLR_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_StatsFLRs
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC frame length ranges array"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize using value received from the user */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|p_CcNode
operator|->
name|numOfStatsFLRs
condition|;
name|tmp
operator|++
control|)
block|{
name|uint16_t
name|flr
init|=
name|cpu_to_be16
argument_list|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|frameLengthRanges
index|[
name|tmp
index|]
argument_list|)
decl_stmt|;
name|h_StatsFLRs
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|h_StatsFLRs
argument_list|,
name|tmp
operator|*
name|FM_PCD_CC_STATS_FLR_SIZE
argument_list|)
expr_stmt|;
name|MemCpy8
argument_list|(
name|h_StatsFLRs
argument_list|,
operator|&
name|flr
argument_list|,
name|FM_PCD_CC_STATS_FLR_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
comment|/* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL      identification, IPv6 hop count identification, etc. */
if|if
condition|(
name|isKeyTblAlloc
condition|)
block|{
name|p_CcNode
operator|->
name|h_KeysMatchTable
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|matchTableSize
argument_list|,
name|FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_KeysMatchTable
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node key match table"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_CcNode
operator|->
name|h_KeysMatchTable
argument_list|,
literal|0
argument_list|,
name|matchTableSize
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate action descriptors table */
name|p_CcNode
operator|->
name|h_AdTable
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_FmMuram
argument_list|,
name|adTableSize
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|h_AdTable
condition|)
block|{
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC node action descriptors table"
operator|)
argument_list|)
expr_stmt|;
block|}
name|MemSet8
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_CcNode
operator|->
name|h_AdTable
argument_list|,
literal|0
argument_list|,
name|adTableSize
argument_list|)
expr_stmt|;
name|p_KeysMatchTblTmp
operator|=
name|p_CcNode
operator|->
name|h_KeysMatchTable
expr_stmt|;
name|p_AdTableTmp
operator|=
name|p_CcNode
operator|->
name|h_AdTable
expr_stmt|;
comment|/* For each key, create the key and the next step AD */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|tmp
operator|++
control|)
block|{
name|p_KeyParams
operator|=
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|keyParams
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|p_KeysMatchTblTmp
condition|)
block|{
comment|/* Copy the key */
name|MemCpy8
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p_KeysMatchTblTmp
argument_list|,
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
name|p_CcNode
operator|->
name|sizeOfExtraction
argument_list|)
expr_stmt|;
comment|/* Copy the key mask or initialize it to 0xFF..F */
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
operator|&&
name|p_KeyParams
operator|->
name|p_Mask
condition|)
block|{
name|MemCpy8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTblTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
comment|/* User's size of extraction rounded up to a valid matching table entry size */
name|p_KeyParams
operator|->
name|p_Mask
argument_list|,
name|p_CcNode
operator|->
name|sizeOfExtraction
argument_list|)
expr_stmt|;
comment|/* Exact size of extraction as received from the user */
block|}
elseif|else
if|if
condition|(
name|p_CcNode
operator|->
name|lclMask
condition|)
block|{
name|MemSet8
argument_list|(
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTblTmp
argument_list|,
name|p_CcNode
operator|->
name|ccKeySizeAccExtraction
argument_list|)
argument_list|,
comment|/* User's size of extraction rounded up to a valid matching table entry size */
literal|0xff
argument_list|,
name|p_CcNode
operator|->
name|sizeOfExtraction
argument_list|)
expr_stmt|;
comment|/* Exact size of extraction as received from the user */
block|}
name|p_KeysMatchTblTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_KeysMatchTblTmp
argument_list|,
name|keySize
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the next action descriptor in the match table */
if|if
condition|(
name|p_KeyParams
operator|->
name|ccNextEngineParams
operator|.
name|statisticsEn
condition|)
block|{
name|p_StatsObj
operator|=
name|GetStatsObj
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
name|statsParams
operator|.
name|h_StatsAd
operator|=
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|statsParams
operator|.
name|h_StatsCounters
operator|=
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|statsParams
operator|.
name|h_StatsFLRs
operator|=
name|p_CcNode
operator|->
name|h_StatsFLRs
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|NextStepAd
argument_list|(
name|p_AdTableTmp
argument_list|,
operator|&
name|statsParams
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|p_StatsObj
operator|=
name|p_StatsObj
expr_stmt|;
block|}
else|else
block|{
name|NextStepAd
argument_list|(
name|p_AdTableTmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_KeyParams
operator|->
name|ccNextEngineParams
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|p_StatsObj
operator|=
name|NULL
expr_stmt|;
block|}
name|p_AdTableTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdTableTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Update next engine for the 'miss' entry */
if|if
condition|(
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
operator|.
name|statisticsEn
condition|)
block|{
name|p_StatsObj
operator|=
name|GetStatsObj
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsObj
argument_list|)
expr_stmt|;
comment|/* All 'bucket' nodes of a hash table should share the same statistics counters,          allocated by the hash table. So, if this node is a bucket of a hash table,          we'll replace the locally allocated counters with the shared counters. */
if|if
condition|(
name|p_CcNode
operator|->
name|isHashBucket
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_CcNode
operator|->
name|h_MissStatsCounters
argument_list|)
expr_stmt|;
comment|/* Store original counters pointer and replace it with mutual preallocated pointer */
name|p_CcNode
operator|->
name|h_PrivMissStatsCounters
operator|=
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
name|p_StatsObj
operator|->
name|h_StatsCounters
operator|=
name|p_CcNode
operator|->
name|h_MissStatsCounters
expr_stmt|;
block|}
name|statsParams
operator|.
name|h_StatsAd
operator|=
name|p_StatsObj
operator|->
name|h_StatsAd
expr_stmt|;
name|statsParams
operator|.
name|h_StatsCounters
operator|=
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
name|statsParams
operator|.
name|h_StatsFLRs
operator|=
name|p_CcNode
operator|->
name|h_StatsFLRs
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|NextStepAd
argument_list|(
name|p_AdTableTmp
argument_list|,
operator|&
name|statsParams
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|p_StatsObj
operator|=
name|p_StatsObj
expr_stmt|;
block|}
else|else
block|{
name|NextStepAd
argument_list|(
name|p_AdTableTmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_CcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|p_StatsObj
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* This parameter will be used to initialize the "key length" field in the action descriptor      that points to this node and it should be 0 for full field extraction */
if|if
condition|(
name|fullField
operator|==
name|TRUE
condition|)
name|p_CcNode
operator|->
name|sizeOfExtraction
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|MIN
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
argument_list|,
name|CC_MAX_NUM_OF_KEYS
argument_list|)
condition|;
name|tmp
operator|++
control|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
name|p_FmPcdCcNextNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|p_CcInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccPrevNodesLst
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_CcNode
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcInformation
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
operator|(
name|t_Handle
operator|)
name|p_CcNode
expr_stmt|;
name|ccNodeInfo
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccPrevNodesLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
block|}
else|else
name|p_CcInformation
operator|->
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|h_Manip
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
expr_stmt|;
name|p_CcInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
name|FmPcdManipGetNodeLstPointedOnThisManip
argument_list|(
name|h_Manip
argument_list|)
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_CcNode
argument_list|,
name|FmPcdManipGetSpinlock
argument_list|(
name|h_Manip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcInformation
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
operator|(
name|t_Handle
operator|)
name|p_CcNode
expr_stmt|;
name|ccNodeInfo
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|FmPcdManipGetNodeLstPointedOnThisManip
argument_list|(
name|h_Manip
argument_list|)
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|FmPcdManipGetSpinlock
argument_list|(
name|h_Manip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p_CcInformation
operator|->
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
name|p_AdTableTmp
operator|=
name|p_CcNode
operator|->
name|h_AdTable
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|h_FmPcd
argument_list|)
condition|)
block|{
name|FM_PCD_MatchTableDelete
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_CcNode
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
comment|/* Required action for each next engine */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|MIN
argument_list|(
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
argument_list|,
name|CC_MAX_NUM_OF_KEYS
argument_list|)
condition|;
name|tmp
operator|++
control|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|requiredAction
condition|)
block|{
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
operator|.
name|requiredAction
argument_list|,
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|tmp
index|]
argument_list|,
name|p_AdTableTmp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|FmPcdLockUnlockAll
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|FM_PCD_MatchTableDelete
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_CcNode
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|p_AdTableTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_AdTableTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|FmPcdLockUnlockAll
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/************************** End of static functions **************************/
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_CcNodeInformation
modifier|*
name|FindNodeInfoInReleventLst
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|,
name|t_Handle
name|h_Info
parameter_list|,
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcInformation
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|)
expr_stmt|;
for|for
control|(
name|p_Pos
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|p_List
argument_list|)
init|;
name|p_Pos
operator|!=
operator|(
name|p_List
operator|)
condition|;
name|p_Pos
operator|=
name|NCSW_LIST_NEXT
argument_list|(
name|p_Pos
argument_list|)
control|)
block|{
name|p_CcInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcInformation
operator|->
name|h_CcNode
operator|==
name|h_Info
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|p_CcInformation
return|;
block|}
block|}
name|XX_UnlockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|EnqueueNodeInfoToRelevantLst
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|,
name|t_CcNodeInformation
modifier|*
name|p_CcInfo
parameter_list|,
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcInformation
decl_stmt|;
name|uint32_t
name|intFlags
init|=
literal|0
decl_stmt|;
name|p_CcInformation
operator|=
operator|(
name|t_CcNodeInformation
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcInformation
condition|)
block|{
name|memset
argument_list|(
name|p_CcInformation
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_CcInformation
argument_list|,
name|p_CcInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_CcInformation
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_Spinlock
condition|)
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|)
expr_stmt|;
name|NCSW_LIST_AddToTail
argument_list|(
operator|&
name|p_CcInformation
operator|->
name|node
argument_list|,
name|p_List
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_Spinlock
condition|)
name|XX_UnlockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
else|else
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"CC Node Information"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DequeueNodeInfoFromRelevantLst
parameter_list|(
name|t_List
modifier|*
name|p_List
parameter_list|,
name|t_Handle
name|h_Info
parameter_list|,
name|t_Handle
name|h_Spinlock
parameter_list|)
block|{
name|t_CcNodeInformation
modifier|*
name|p_CcInformation
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|intFlags
init|=
literal|0
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
if|if
condition|(
name|h_Spinlock
condition|)
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|NCSW_LIST_IsEmpty
argument_list|(
name|p_List
argument_list|)
condition|)
block|{
name|XX_RestoreAllIntr
argument_list|(
name|intFlags
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|p_Pos
operator|=
name|NCSW_LIST_FIRST
argument_list|(
name|p_List
argument_list|)
init|;
name|p_Pos
operator|!=
operator|(
name|p_List
operator|)
condition|;
name|p_Pos
operator|=
name|NCSW_LIST_NEXT
argument_list|(
name|p_Pos
argument_list|)
control|)
block|{
name|p_CcInformation
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcInformation
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcInformation
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcInformation
operator|->
name|h_CcNode
operator|==
name|h_Info
condition|)
break|break;
block|}
if|if
condition|(
name|p_CcInformation
condition|)
block|{
name|NCSW_LIST_DelAndInit
argument_list|(
operator|&
name|p_CcInformation
operator|->
name|node
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_CcInformation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h_Spinlock
condition|)
name|XX_UnlockIntrSpinlock
argument_list|(
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|NextStepAd
parameter_list|(
name|t_Handle
name|h_Ad
parameter_list|,
name|t_FmPcdCcStatsParams
modifier|*
name|p_FmPcdCcStatsParams
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|,
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
switch|switch
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|nextEngine
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_PLCR
operator|)
case|:
case|case
operator|(
name|e_FM_PCD_DONE
operator|)
case|:
comment|/* if NIA is not CC, create a "result" type AD */
name|FillAdOfTypeResult
argument_list|(
name|h_Ad
argument_list|,
name|p_FmPcdCcStatsParams
argument_list|,
name|p_FmPcd
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
case|case
operator|(
name|e_FM_PCD_FR
operator|)
case|:
if|if
condition|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
condition|)
block|{
name|FillAdOfTypeContLookup
argument_list|(
name|h_Ad
argument_list|,
name|p_FmPcdCcStatsParams
argument_list|,
name|p_FmPcd
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
argument_list|)
expr_stmt|;
name|FrmReplicGroupUpdateOwner
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
argument_list|,
name|TRUE
comment|/* add */
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
case|case
operator|(
name|e_FM_PCD_CC
operator|)
case|:
comment|/* if NIA is not CC, create a TD to continue the CC lookup */
name|FillAdOfTypeContLookup
argument_list|(
name|h_Ad
argument_list|,
name|p_FmPcdCcStatsParams
argument_list|,
name|p_FmPcd
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|,
name|p_FmPcdCcNextEngineParams
operator|->
name|h_Manip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UpdateNodeOwner
argument_list|(
name|p_FmPcdCcNextEngineParams
operator|->
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcTreeAddIPR
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|,
name|t_Handle
name|h_NetEnv
parameter_list|,
name|t_Handle
name|h_IpReassemblyManip
parameter_list|,
name|bool
name|createSchemes
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmTree
decl_stmt|;
name|t_FmPcdCcNextEngineParams
name|nextEngineParams
decl_stmt|;
name|t_NetEnvParams
name|netEnvParams
decl_stmt|;
name|t_Handle
name|h_Ad
decl_stmt|;
name|bool
name|isIpv6Present
decl_stmt|;
name|uint8_t
name|ipv4GroupId
decl_stmt|,
name|ipv6GroupId
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
comment|/* this routine must be protected by the calling routine! */
name|memset
argument_list|(
operator|&
name|nextEngineParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|netEnvParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_NetEnvParams
argument_list|)
argument_list|)
expr_stmt|;
name|h_Ad
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
expr_stmt|;
name|isIpv6Present
operator|=
name|FmPcdManipIpReassmIsIpv6Hdr
argument_list|(
name|h_IpReassemblyManip
argument_list|)
expr_stmt|;
if|if
condition|(
name|isIpv6Present
operator|&&
operator|(
name|p_FmPcdCcTree
operator|->
name|numOfEntries
operator|>
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|2
operator|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"need two free entries for IPR"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|numOfEntries
operator|>
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|1
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"need two free entries for IPR"
operator|)
argument_list|)
expr_stmt|;
name|nextEngineParams
operator|.
name|nextEngine
operator|=
name|e_FM_PCD_DONE
expr_stmt|;
name|nextEngineParams
operator|.
name|h_Manip
operator|=
name|h_IpReassemblyManip
expr_stmt|;
comment|/* Lock tree */
name|err
operator|=
name|CcRootTryLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|h_IpReassemblyManip
operator|==
name|h_IpReassemblyManip
condition|)
block|{
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
if|if
condition|(
operator|(
name|p_FmPcdCcTree
operator|->
name|h_IpReassemblyManip
operator|)
operator|&&
operator|(
name|p_FmPcdCcTree
operator|->
name|h_IpReassemblyManip
operator|!=
name|h_IpReassemblyManip
operator|)
condition|)
block|{
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"This tree was previously updated with different IPR"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize IPR for the first time for this tree */
if|if
condition|(
name|isIpv6Present
condition|)
block|{
name|ipv6GroupId
operator|=
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|++
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|ipv6GroupId
index|]
operator|.
name|baseGroupEntry
operator|=
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|createSchemes
condition|)
block|{
name|err
operator|=
name|FmPcdManipBuildIpReassmScheme
argument_list|(
name|h_FmPcd
argument_list|,
name|h_NetEnv
argument_list|,
name|p_FmPcdCcTree
argument_list|,
name|h_IpReassemblyManip
argument_list|,
name|FALSE
argument_list|,
name|ipv6GroupId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|--
expr_stmt|;
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|NextStepAd
argument_list|(
name|PTR_MOVE
argument_list|(
name|h_Ad
argument_list|,
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|2
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|nextEngineParams
argument_list|,
name|h_FmPcd
argument_list|)
expr_stmt|;
block|}
name|ipv4GroupId
operator|=
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|++
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|ipv4GroupId
index|]
operator|.
name|totalBitsMask
operator|=
literal|0
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|ipv4GroupId
index|]
operator|.
name|baseGroupEntry
operator|=
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|createSchemes
condition|)
block|{
name|err
operator|=
name|FmPcdManipBuildIpReassmScheme
argument_list|(
name|h_FmPcd
argument_list|,
name|h_NetEnv
argument_list|,
name|p_FmPcdCcTree
argument_list|,
name|h_IpReassemblyManip
argument_list|,
name|TRUE
argument_list|,
name|ipv4GroupId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|--
expr_stmt|;
if|if
condition|(
name|isIpv6Present
condition|)
block|{
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|--
expr_stmt|;
name|FmPcdManipDeleteIpReassmSchemes
argument_list|(
name|h_IpReassemblyManip
argument_list|)
expr_stmt|;
block|}
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|NextStepAd
argument_list|(
name|PTR_MOVE
argument_list|(
name|h_Ad
argument_list|,
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|nextEngineParams
argument_list|,
name|h_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|h_IpReassemblyManip
operator|=
name|h_IpReassemblyManip
expr_stmt|;
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcTreeAddCPR
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmTree
parameter_list|,
name|t_Handle
name|h_NetEnv
parameter_list|,
name|t_Handle
name|h_ReassemblyManip
parameter_list|,
name|bool
name|createSchemes
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmTree
decl_stmt|;
name|t_FmPcdCcNextEngineParams
name|nextEngineParams
decl_stmt|;
name|t_NetEnvParams
name|netEnvParams
decl_stmt|;
name|t_Handle
name|h_Ad
decl_stmt|;
name|uint8_t
name|groupId
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
comment|/* this routine must be protected by the calling routine! */
name|memset
argument_list|(
operator|&
name|nextEngineParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|netEnvParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_NetEnvParams
argument_list|)
argument_list|)
expr_stmt|;
name|h_Ad
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|numOfEntries
operator|>
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|1
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"need one free entries for CPR"
operator|)
argument_list|)
expr_stmt|;
name|nextEngineParams
operator|.
name|nextEngine
operator|=
name|e_FM_PCD_DONE
expr_stmt|;
name|nextEngineParams
operator|.
name|h_Manip
operator|=
name|h_ReassemblyManip
expr_stmt|;
comment|/* Lock tree */
name|err
operator|=
name|CcRootTryLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|h_CapwapReassemblyManip
operator|==
name|h_ReassemblyManip
condition|)
block|{
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
if|if
condition|(
operator|(
name|p_FmPcdCcTree
operator|->
name|h_CapwapReassemblyManip
operator|)
operator|&&
operator|(
name|p_FmPcdCcTree
operator|->
name|h_CapwapReassemblyManip
operator|!=
name|h_ReassemblyManip
operator|)
condition|)
block|{
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"This tree was previously updated with different CPR"
operator|)
argument_list|)
expr_stmt|;
block|}
name|groupId
operator|=
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|++
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|groupId
index|]
operator|.
name|baseGroupEntry
operator|=
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|createSchemes
condition|)
block|{
name|err
operator|=
name|FmPcdManipBuildCapwapReassmScheme
argument_list|(
name|h_FmPcd
argument_list|,
name|h_NetEnv
argument_list|,
name|p_FmPcdCcTree
argument_list|,
name|h_ReassemblyManip
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|--
expr_stmt|;
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|NextStepAd
argument_list|(
name|PTR_MOVE
argument_list|(
name|h_Ad
argument_list|,
operator|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|-
literal|1
operator|)
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|nextEngineParams
argument_list|,
name|h_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|h_CapwapReassemblyManip
operator|=
name|h_ReassemblyManip
expr_stmt|;
name|CcRootReleaseLock
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FmPcdCcTreeGetSavedManipParams
parameter_list|(
name|t_Handle
name|h_FmTree
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmTree
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
return|return
name|p_FmPcdCcTree
operator|->
name|h_FmPcdCcSavedManipParams
return|;
block|}
end_function

begin_function
name|void
name|FmPcdCcTreeSetSavedManipParams
parameter_list|(
name|t_Handle
name|h_FmTree
parameter_list|,
name|t_Handle
name|h_SavedManipParams
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmTree
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|h_FmPcdCcSavedManipParams
operator|=
name|h_SavedManipParams
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|FmPcdCcGetParseCode
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
return|return
name|p_CcNode
operator|->
name|parseCode
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPcdCcGetOffset
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
return|return
name|p_CcNode
operator|->
name|offset
return|;
block|}
end_function

begin_function
name|uint16_t
name|FmPcdCcGetNumOfKeys
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
return|return
name|p_CcNode
operator|->
name|numOfKeys
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcModifyNextEngineParamTree
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcTree
parameter_list|,
name|uint8_t
name|grpId
parameter_list|,
name|uint8_t
name|index
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcTree
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdCcTree
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
name|grpId
operator|<=
literal|7
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|grpId
operator|>=
name|p_FmPcdCcTree
operator|->
name|numOfGrps
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"grpId you asked> numOfGroup of relevant tree"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|grpId
index|]
operator|.
name|numOfEntriesInGroup
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"index> numOfEntriesInGroup"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|keyIndex
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|grpId
index|]
operator|.
name|baseGroupEntry
operator|+
name|index
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_CHANGE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|->
name|tree
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_CcShadow
operator|&&
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|BuildNewNodeModifyNextEngine
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcdCcTree
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_CcShadow
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcRemoveKey
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|bool
name|useShadowStructs
init|=
name|FALSE
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|keyIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"impossible to remove key when numOfKeys<= keyIndex"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"handler to FmPcd is different from the handle provided at node initialization time"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_REMOVE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|useShadowStructs
operator|=
name|TRUE
expr_stmt|;
block|}
name|err
operator|=
name|BuildNewNodeRemoveKey
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|UpdatePtrWhichPointOnCrntMdfNode
argument_list|(
name|p_CcNode
argument_list|,
name|p_ModifyKeyParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseNewNodeCommonPart
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcModifyKey
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|uint16_t
name|tmpKeyIndex
decl_stmt|;
name|bool
name|useShadowStructs
init|=
name|FALSE
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|keyIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"keyIndex> previously cleared last index + 1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keySize
operator|!=
name|p_CcNode
operator|->
name|userSizeOfExtraction
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"size for ModifyKey has to be the same as defined in SetNode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"handler to FmPcd is different from the handle provided at node initialization time"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|h_FmPcdCcNode
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
operator|&
name|tmpKeyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_NOT_FOUND
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"The received key and mask pair was already found in the match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_CHANGE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|useShadowStructs
operator|=
name|TRUE
expr_stmt|;
block|}
name|err
operator|=
name|BuildNewNodeModifyKey
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|UpdatePtrWhichPointOnCrntMdfNode
argument_list|(
name|p_CcNode
argument_list|,
name|p_ModifyKeyParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseNewNodeCommonPart
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcModifyMissNextEngineParamNode
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|keyIndex
operator|=
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_CHANGE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
operator|&&
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|BuildNewNodeModifyNextEngine
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcAddKey
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_FmPcdCcKeyParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|bool
name|useShadowStructs
init|=
name|FALSE
decl_stmt|;
name|uint16_t
name|tmpKeyIndex
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|keyIndex
operator|>
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"keyIndex> previously cleared last index + 1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keySize
operator|!=
name|p_CcNode
operator|->
name|userSizeOfExtraction
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"keySize has to be defined as it was defined in initialization step"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"handler to FmPcd is different from the handle provided at node initialization time"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|numOfKeys
operator|==
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"number of keys exceeds the maximal number of keys provided at node initialization time"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_CcNode
operator|->
name|numOfKeys
operator|==
name|FM_PCD_MAX_NUM_OF_KEYS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"number of keys can not be larger than %d"
operator|,
name|FM_PCD_MAX_NUM_OF_KEYS
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|h_FmPcdCcNode
argument_list|,
name|keySize
argument_list|,
name|p_FmPcdCcKeyParams
operator|->
name|p_Key
argument_list|,
name|p_FmPcdCcKeyParams
operator|->
name|p_Mask
argument_list|,
operator|&
name|tmpKeyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_NOT_FOUND
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"The received key and mask pair was already found in the match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_ADD
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|useShadowStructs
operator|=
name|TRUE
expr_stmt|;
block|}
name|err
operator|=
name|BuildNewNodeAddOrMdfyKeyAndNextEngine
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcKeyParams
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseNewNodeCommonPart
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|UpdatePtrWhichPointOnCrntMdfNode
argument_list|(
name|p_CcNode
argument_list|,
name|p_ModifyKeyParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseNewNodeCommonPart
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcModifyKeyAndNextEngine
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_FmPcdCcKeyParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_List
name|h_OldPointersLst
decl_stmt|,
name|h_NewPointersLst
decl_stmt|;
name|t_FmPcdModifyCcKeyAdditionalParams
modifier|*
name|p_ModifyKeyParams
decl_stmt|;
name|uint16_t
name|tmpKeyIndex
decl_stmt|;
name|bool
name|useShadowStructs
init|=
name|FALSE
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|keyIndex
operator|>
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"keyIndex> previously cleared last index + 1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keySize
operator|!=
name|p_CcNode
operator|->
name|userSizeOfExtraction
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"keySize has to be defined as it was defined in initialization step"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|h_FmPcd
operator|!=
name|h_FmPcd
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"handler to FmPcd is different from the handle provided at node initialization time"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|h_FmPcdCcNode
argument_list|,
name|keySize
argument_list|,
name|p_FmPcdCcKeyParams
operator|->
name|p_Key
argument_list|,
name|p_FmPcdCcKeyParams
operator|->
name|p_Mask
argument_list|,
operator|&
name|tmpKeyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_NOT_FOUND
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"The received key and mask pair was already found in the match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_OldPointersLst
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
name|p_ModifyKeyParams
operator|=
name|ModifyNodeCommonPart
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|e_MODIFY_STATE_CHANGE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ModifyKeyParams
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
block|{
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|useShadowStructs
operator|=
name|TRUE
expr_stmt|;
block|}
name|err
operator|=
name|BuildNewNodeAddOrMdfyKeyAndNextEngine
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcKeyParams
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseNewNodeCommonPart
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|UpdatePtrWhichPointOnCrntMdfNode
argument_list|(
name|p_CcNode
argument_list|,
name|p_ModifyKeyParams
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ReleaseNewNodeCommonPart
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ModifyKeyParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|DoDynamicChange
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_OldPointersLst
argument_list|,
operator|&
name|h_NewPointersLst
argument_list|,
name|p_ModifyKeyParams
argument_list|,
name|useShadowStructs
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|maxNumOfKeys
condition|)
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdCcGetNodeAddrOffsetFromNodeInfo
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_Pointer
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
name|uint32_t
operator|)
name|ILLEGAL_BASE
argument_list|)
expr_stmt|;
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|h_Pointer
argument_list|)
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_CcNodeInfo
operator|->
name|h_CcNode
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcGetGrpParams
parameter_list|(
name|t_Handle
name|h_FmPcdCcTree
parameter_list|,
name|uint8_t
name|grpId
parameter_list|,
name|uint32_t
modifier|*
name|p_GrpBits
parameter_list|,
name|uint8_t
modifier|*
name|p_GrpBase
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcTree
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdCcTree
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|grpId
operator|>=
name|p_FmPcdCcTree
operator|->
name|numOfGrps
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"grpId you asked> numOfGroup of relevant tree"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_GrpBits
operator|=
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|grpId
index|]
operator|.
name|totalBitsMask
expr_stmt|;
operator|*
name|p_GrpBase
operator|=
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|grpId
index|]
operator|.
name|baseGroupEntry
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcBindTree
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_PcdParams
parameter_list|,
name|t_Handle
name|h_FmPcdCcTree
parameter_list|,
name|uint32_t
modifier|*
name|p_Offset
parameter_list|,
name|t_Handle
name|h_FmPort
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcTree
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdCcTree
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* this routine must be protected by the calling routine by locking all PCD modules! */
name|err
operator|=
name|CcUpdateParams
argument_list|(
name|h_FmPcd
argument_list|,
name|h_PcdParams
argument_list|,
name|h_FmPort
argument_list|,
name|h_FmPcdCcTree
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|E_OK
condition|)
name|UpdateCcRootOwner
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|p_Offset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcUnbindTree
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcTree
parameter_list|)
block|{
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_FmPcdCcTree
decl_stmt|;
comment|/* this routine must be protected by the calling routine by locking all PCD modules! */
name|UNUSED
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_FmPcdCcTree
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|UpdateCcRootOwner
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdCcNodeTreeTryLock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_FmPcdCcNode
parameter_list|,
name|t_List
modifier|*
name|p_List
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_FmPcdCcNode
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|,
modifier|*
name|p_Tmp
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
decl_stmt|,
name|nodeInfo
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_CcNode->ccTreesLst
argument_list|)
block|{
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CcNodeInfo
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
name|err
operator|=
name|CcRootTryLock
argument_list|(
name|p_CcNodeInfo
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Tmp
argument_list|,
argument|&p_CcNode->ccTreesLst
argument_list|)
block|{
if|if
condition|(
name|p_Tmp
operator|==
name|p_Pos
condition|)
break|break;
name|CcRootReleaseLock
argument_list|(
name|p_CcNodeInfo
operator|->
name|h_CcNode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|memset
argument_list|(
operator|&
name|nodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|nodeInfo
operator|.
name|h_CcNode
operator|=
name|p_CcNodeInfo
operator|->
name|h_CcNode
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|p_List
argument_list|,
operator|&
name|nodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|FmPcdUnlock
argument_list|(
name|h_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|CORE_MemoryBarrier
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|FmPcdCcNodeTreeReleaseLock
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_List
modifier|*
name|p_List
parameter_list|)
block|{
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|t_CcNodeInformation
modifier|*
name|p_CcNodeInfo
decl_stmt|;
name|t_Handle
name|h_FmPcdCcTree
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|h_FmPcd
argument_list|)
expr_stmt|;
name|NCSW_LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|p_List
argument_list|)
block|{
name|p_CcNodeInfo
operator|=
name|CC_NODE_F_OBJECT
argument_list|(
name|p_Pos
argument_list|)
expr_stmt|;
name|h_FmPcdCcTree
operator|=
name|p_CcNodeInfo
operator|->
name|h_CcNode
expr_stmt|;
name|CcRootReleaseLock
argument_list|(
name|h_FmPcdCcTree
argument_list|)
expr_stmt|;
block|}
name|ReleaseLst
argument_list|(
name|p_List
argument_list|)
expr_stmt|;
name|FmPcdUnlock
argument_list|(
name|h_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|CORE_MemoryBarrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdUpdateCcShadow
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint32_t
name|align
parameter_list|)
block|{
name|uint32_t
name|intFlags
decl_stmt|;
name|uint32_t
name|newSize
init|=
literal|0
decl_stmt|,
name|newAlign
init|=
literal|0
decl_stmt|;
name|bool
name|allocFail
init|=
name|FALSE
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"size must be larger then 0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWER_OF_2
argument_list|(
name|align
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"alignment must be power of 2"
operator|)
argument_list|)
expr_stmt|;
name|newSize
operator|=
name|p_FmPcd
operator|->
name|ccShadowSize
expr_stmt|;
name|newAlign
operator|=
name|p_FmPcd
operator|->
name|ccShadowAlign
expr_stmt|;
comment|/* Check if current shadow is large enough to hold the requested size */
if|if
condition|(
name|size
operator|>
name|p_FmPcd
operator|->
name|ccShadowSize
condition|)
name|newSize
operator|=
name|size
expr_stmt|;
comment|/* Check if current shadow matches the requested alignment */
if|if
condition|(
name|align
operator|>
name|p_FmPcd
operator|->
name|ccShadowAlign
condition|)
name|newAlign
operator|=
name|align
expr_stmt|;
comment|/* If a bigger shadow size or bigger shadow alignment are required,      a new shadow will be allocated */
if|if
condition|(
operator|(
name|newSize
operator|!=
name|p_FmPcd
operator|->
name|ccShadowSize
operator|)
operator|||
operator|(
name|newAlign
operator|!=
name|p_FmPcd
operator|->
name|ccShadowAlign
operator|)
condition|)
block|{
name|intFlags
operator|=
name|FmPcdLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_CcShadow
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|ccShadowSize
operator|=
literal|0
expr_stmt|;
name|p_FmPcd
operator|->
name|ccShadowAlign
operator|=
literal|0
expr_stmt|;
block|}
name|p_FmPcd
operator|->
name|p_CcShadow
operator|=
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
name|newSize
argument_list|,
name|newAlign
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_CcShadow
condition|)
block|{
name|allocFail
operator|=
name|TRUE
expr_stmt|;
comment|/* If new shadow size allocation failed,              re-allocate with previous parameters */
name|p_FmPcd
operator|->
name|p_CcShadow
operator|=
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|,
name|p_FmPcd
operator|->
name|ccShadowSize
argument_list|,
name|p_FmPcd
operator|->
name|ccShadowAlign
argument_list|)
expr_stmt|;
block|}
name|FmPcdUnlock
argument_list|(
name|p_FmPcd
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocFail
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC Shadow memory"
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|ccShadowSize
operator|=
name|newSize
expr_stmt|;
name|p_FmPcd
operator|->
name|ccShadowAlign
operator|=
name|newAlign
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
name|void
name|FmPcdCcGetAdTablesThatPointOnReplicGroup
parameter_list|(
name|t_Handle
name|h_Node
parameter_list|,
name|t_Handle
name|h_ReplicGroup
parameter_list|,
name|t_List
modifier|*
name|p_AdTables
parameter_list|,
name|uint32_t
modifier|*
name|p_NumOfAdTables
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CurrentNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_Node
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|p_AdTable
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Node
argument_list|)
expr_stmt|;
operator|*
name|p_NumOfAdTables
operator|=
literal|0
expr_stmt|;
comment|/* search in the current node which exact index points on this current replicator group for getting AD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CurrentNode
operator|->
name|numOfKeys
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_CurrentNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
operator|(
name|p_CurrentNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|==
operator|(
name|t_Handle
operator|)
name|h_ReplicGroup
operator|)
operator|)
condition|)
block|{
comment|/* save the current ad table in the list */
comment|/* this entry uses the input replicator group */
name|p_AdTable
operator|=
name|PTR_MOVE
argument_list|(
name|p_CurrentNode
operator|->
name|h_AdTable
argument_list|,
name|i
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
name|p_AdTable
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
name|p_AdTables
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p_NumOfAdTables
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|ASSERT_COND
argument_list|(
name|i
operator|!=
name|p_CurrentNode
operator|->
name|numOfKeys
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PCD_CcRootBuild
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcTreeParams
modifier|*
name|p_PcdGroupsParam
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_FmPcdCcTree
decl_stmt|;
name|uint8_t
name|numOfEntries
decl_stmt|;
name|t_Handle
name|p_CcTreeTmp
decl_stmt|;
name|t_FmPcdCcGrpParams
modifier|*
name|p_FmPcdCcGroupParams
decl_stmt|;
name|t_FmPcdCcKeyAndNextEngineParams
modifier|*
name|p_Params
decl_stmt|,
modifier|*
name|p_KeyAndNextEngineParams
decl_stmt|;
name|t_NetEnvParams
name|netEnvParams
decl_stmt|;
name|uint8_t
name|lastOne
init|=
literal|0
decl_stmt|;
name|uint32_t
name|requiredAction
init|=
literal|0
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_FmPcdCcNextNode
decl_stmt|;
name|t_CcNodeInformation
name|ccNodeInfo
decl_stmt|,
modifier|*
name|p_CcInformation
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_PcdGroupsParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_PcdGroupsParam
operator|->
name|numOfGrps
operator|>
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfGrps should not exceed %d"
operator|,
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcdCcTree
operator|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcTree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdCcTree
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"PCD tree structure"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcdCcTree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcTree
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|h_FmPcd
operator|=
name|h_FmPcd
expr_stmt|;
name|p_Params
operator|=
operator|(
name|t_FmPcdCcKeyAndNextEngineParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_Params
argument_list|,
literal|0
argument_list|,
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_FmPcdCcTree
operator|->
name|fmPortsLst
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
if|if
condition|(
operator|(
name|p_PcdGroupsParam
operator|->
name|numOfGrps
operator|==
literal|1
operator|)
operator|&&
operator|(
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
literal|0
index|]
operator|.
name|numOfDistinctionUnits
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
literal|0
index|]
operator|.
name|nextEnginePerEntriesInGrp
index|[
literal|0
index|]
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
literal|0
index|]
operator|.
name|nextEnginePerEntriesInGrp
index|[
literal|0
index|]
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
operator|&&
name|IsCapwapApplSpecific
argument_list|(
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
literal|0
index|]
operator|.
name|nextEnginePerEntriesInGrp
index|[
literal|0
index|]
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
condition|)
block|{
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
literal|0
index|]
operator|.
name|nextEnginePerEntriesInGrp
index|[
literal|0
index|]
operator|.
name|h_Manip
operator|=
name|FmPcdManipApplSpecificBuild
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
literal|0
index|]
operator|.
name|nextEnginePerEntriesInGrp
index|[
literal|0
index|]
operator|.
name|h_Manip
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
name|numOfEntries
operator|=
literal|0
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|netEnvId
operator|=
name|FmPcdGetNetEnvId
argument_list|(
name|p_PcdGroupsParam
operator|->
name|h_NetEnv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_PcdGroupsParam
operator|->
name|numOfGrps
condition|;
name|i
operator|++
control|)
block|{
name|p_FmPcdCcGroupParams
operator|=
operator|&
name|p_PcdGroupsParam
operator|->
name|ccGrpParams
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcGroupParams
operator|->
name|numOfDistinctionUnits
operator|>
name|FM_PCD_MAX_NUM_OF_CC_UNITS
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfDistinctionUnits (group %d) should not exceed %d"
operator|,
name|i
operator|,
name|FM_PCD_MAX_NUM_OF_CC_UNITS
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|baseGroupEntry
operator|=
name|numOfEntries
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|numOfEntriesInGroup
operator|=
call|(
name|uint8_t
call|)
argument_list|(
literal|0x01
operator|<<
name|p_FmPcdCcGroupParams
operator|->
name|numOfDistinctionUnits
argument_list|)
expr_stmt|;
name|numOfEntries
operator|+=
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|numOfEntriesInGroup
expr_stmt|;
if|if
condition|(
name|numOfEntries
operator|>
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfEntries can not be larger than %d"
operator|,
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|lastOne
condition|)
block|{
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|numOfEntriesInGroup
operator|>
name|lastOne
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"numOfEntries per group must be set in descending order"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|lastOne
operator|=
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|numOfEntriesInGroup
expr_stmt|;
name|netEnvParams
operator|.
name|netEnvId
operator|=
name|p_FmPcdCcTree
operator|->
name|netEnvId
expr_stmt|;
name|netEnvParams
operator|.
name|numOfDistinctionUnits
operator|=
name|p_FmPcdCcGroupParams
operator|->
name|numOfDistinctionUnits
expr_stmt|;
name|memcpy
argument_list|(
name|netEnvParams
operator|.
name|unitIds
argument_list|,
operator|&
name|p_FmPcdCcGroupParams
operator|->
name|unitIds
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
operator|*
name|p_FmPcdCcGroupParams
operator|->
name|numOfDistinctionUnits
argument_list|)
expr_stmt|;
name|err
operator|=
name|PcdGetUnitsVector
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|netEnvParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|totalBitsMask
operator|=
name|netEnvParams
operator|.
name|vector
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_FmPcdCcTree
operator|->
name|fmPcdGroupParam
index|[
name|i
index|]
operator|.
name|numOfEntriesInGroup
condition|;
name|j
operator|++
control|)
block|{
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_FmPcdCcGroupParams
operator|->
name|nextEnginePerEntriesInGrp
index|[
name|j
index|]
argument_list|,
name|e_FM_PCD_CC_STATS_MODE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_FmPcdCcGroupParams
operator|->
name|nextEnginePerEntriesInGrp
index|[
name|j
index|]
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|FmPcdManipCheckParamsForCcNextEngine
argument_list|(
operator|&
name|p_FmPcdCcGroupParams
operator|->
name|nextEnginePerEntriesInGrp
index|[
name|j
index|]
argument_list|,
operator|&
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|p_KeyAndNextEngineParams
operator|=
name|p_Params
operator|+
name|k
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_KeyAndNextEngineParams
operator|->
name|nextEngineParams
argument_list|,
operator|&
name|p_FmPcdCcGroupParams
operator|->
name|nextEnginePerEntriesInGrp
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_KeyAndNextEngineParams
operator|->
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_KeyAndNextEngineParams
operator|->
name|nextEngineParams
operator|.
name|h_Manip
condition|)
block|{
name|err
operator|=
name|AllocAndFillAdForContLookupManip
argument_list|(
name|p_KeyAndNextEngineParams
operator|->
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC Tree"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|requiredAction
operator||=
name|UPDATE_CC_WITH_TREE
expr_stmt|;
name|p_KeyAndNextEngineParams
operator|->
name|requiredAction
operator|=
name|requiredAction
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
name|p_FmPcdCcTree
operator|->
name|numOfEntries
operator|=
operator|(
name|uint8_t
operator|)
name|k
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|numOfGrps
operator|=
name|p_PcdGroupsParam
operator|->
name|numOfGrps
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
operator|=
name|PTR_TO_UINT
argument_list|(
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|h_FmPcd
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|,
name|FM_PCD_CC_TREE_ADDR_ALIGN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
condition|)
block|{
name|DeleteTree
argument_list|(
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for CC Tree"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MemSet8
argument_list|(
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
argument_list|,
literal|0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|FM_PCD_MAX_NUM_OF_CC_GROUPS
operator|*
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|p_CcTreeTmp
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
name|p_KeyAndNextEngineParams
operator|=
name|p_Params
operator|+
name|i
expr_stmt|;
name|NextStepAd
argument_list|(
name|p_CcTreeTmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_KeyAndNextEngineParams
operator|->
name|nextEngineParams
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_CcTreeTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcTreeTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
argument_list|,
name|p_KeyAndNextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcKeyAndNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
name|p_FmPcdCcNextNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|p_CcInformation
operator|=
name|FindNodeInfoInReleventLst
argument_list|(
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccTreeIdLst
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_FmPcdCcTree
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcInformation
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ccNodeInfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_CcNodeInformation
argument_list|)
argument_list|)
expr_stmt|;
name|ccNodeInfo
operator|.
name|h_CcNode
operator|=
operator|(
name|t_Handle
operator|)
name|p_FmPcdCcTree
expr_stmt|;
name|ccNodeInfo
operator|.
name|index
operator|=
literal|1
expr_stmt|;
name|EnqueueNodeInfoToRelevantLst
argument_list|(
operator|&
name|p_FmPcdCcNextNode
operator|->
name|ccTreeIdLst
argument_list|,
operator|&
name|ccNodeInfo
argument_list|,
name|p_FmPcdCcNextNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
block|}
else|else
name|p_CcInformation
operator|->
name|index
operator|++
expr_stmt|;
block|}
block|}
name|FmPcdIncNetEnvOwners
argument_list|(
name|h_FmPcd
argument_list|,
name|p_FmPcdCcTree
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
name|p_CcTreeTmp
operator|=
name|UINT_TO_PTR
argument_list|(
name|p_FmPcdCcTree
operator|->
name|ccTreeBaseAddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|requiredAction
condition|)
block|{
name|err
operator|=
name|SetRequiredAction
argument_list|(
name|h_FmPcd
argument_list|,
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|requiredAction
argument_list|,
operator|&
name|p_FmPcdCcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
argument_list|,
name|p_CcTreeTmp
argument_list|,
literal|1
argument_list|,
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_CcTreeTmp
operator|=
name|PTR_MOVE
argument_list|(
name|p_CcTreeTmp
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcdCcTree
operator|->
name|p_Lock
operator|=
name|FmPcdAcquireLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdCcTree
operator|->
name|p_Lock
condition|)
block|{
name|FM_PCD_CcRootDelete
argument_list|(
name|p_FmPcdCcTree
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM CC lock"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|XX_Free
argument_list|(
name|p_Params
argument_list|)
expr_stmt|;
return|return
name|p_FmPcdCcTree
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_CcRootDelete
parameter_list|(
name|t_Handle
name|h_CcTree
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_CcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_CcTree
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcTree
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcTree
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|FmPcdDecNetEnvOwners
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcTree
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcTree
operator|->
name|owners
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"
operator|)
argument_list|)
expr_stmt|;
comment|/* Delete ip-reassembly schemes if exist */
if|if
condition|(
name|p_CcTree
operator|->
name|h_IpReassemblyManip
condition|)
block|{
name|FmPcdManipDeleteIpReassmSchemes
argument_list|(
name|p_CcTree
operator|->
name|h_IpReassemblyManip
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|p_CcTree
operator|->
name|h_IpReassemblyManip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Delete capwap-reassembly schemes if exist */
if|if
condition|(
name|p_CcTree
operator|->
name|h_CapwapReassemblyManip
condition|)
block|{
name|FmPcdManipDeleteCapwapReassmSchemes
argument_list|(
name|p_CcTree
operator|->
name|h_CapwapReassemblyManip
argument_list|)
expr_stmt|;
name|FmPcdManipUpdateOwner
argument_list|(
name|p_CcTree
operator|->
name|h_CapwapReassemblyManip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcTree
operator|->
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|UpdateNodeOwner
argument_list|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|FmPcdManipUpdateOwner
argument_list|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FM_CAPWAP_SUPPORT
if|if
condition|(
operator|(
name|p_CcTree
operator|->
name|numOfGrps
operator|==
literal|1
operator|)
operator|&&
operator|(
name|p_CcTree
operator|->
name|fmPcdGroupParam
index|[
literal|0
index|]
operator|.
name|numOfEntriesInGroup
operator|==
literal|1
operator|)
operator|&&
operator|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
literal|0
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
literal|0
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
operator|&&
name|IsCapwapApplSpecific
argument_list|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
literal|0
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
condition|)
block|{
if|if
condition|(
name|FM_PCD_ManipNodeDelete
argument_list|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
literal|0
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|)
operator|!=
name|E_OK
condition|)
return|return
name|E_INVALID_STATE
return|;
block|}
endif|#
directive|endif
comment|/* FM_CAPWAP_SUPPORT */
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
name|FrmReplicGroupUpdateOwner
argument_list|(
name|p_CcTree
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
if|if
condition|(
name|p_CcTree
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_CcTree
operator|->
name|h_FmPcd
argument_list|,
name|p_CcTree
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
name|DeleteTree
argument_list|(
name|p_CcTree
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_CcRootModifyNextEngine
parameter_list|(
name|t_Handle
name|h_CcTree
parameter_list|,
name|uint8_t
name|grpId
parameter_list|,
name|uint8_t
name|index
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcTree
modifier|*
name|p_CcTree
init|=
operator|(
name|t_FmPcdCcTree
operator|*
operator|)
name|h_CcTree
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcTree
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcTree
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcModifyNextEngineParamTree
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcTree
argument_list|,
name|grpId
argument_list|,
name|index
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_MatchTableSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNodeParams
modifier|*
name|p_CcNodeParam
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_CcNodeParam
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p_CcNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_CcNode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|MatchTableSet
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|p_CcNodeParam
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
break|break;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|p_CcNode
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableDelete
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
operator|->
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|owners
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"This node cannot be removed because it is occupied; first unbind this node"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|UpdateNodeOwner
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
name|UpdateNodeOwner
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Handle also Miss entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_CcNode
operator|->
name|numOfKeys
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
condition|)
name|FmPcdManipUpdateOwner
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|h_Manip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_FR
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
operator|)
condition|)
block|{
name|FrmReplicGroupUpdateOwner
argument_list|(
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|frParams
operator|.
name|h_FrmReplic
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
block|}
name|DeleteNode
argument_list|(
name|p_CcNode
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableAddKey
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIndex
operator|==
name|FM_PCD_LAST_KEY_INDEX
condition|)
name|keyIndex
operator|=
name|p_CcNode
operator|->
name|numOfKeys
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcAddKey
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|keySize
argument_list|,
name|p_KeyParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableRemoveKey
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcRemoveKey
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableModifyKey
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcModifyKey
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableModifyNextEngine
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|ModifyNextEngineParamNode
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableModifyMissNextEngine
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcModifyMissNextEngineParamNode
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableModifyKeyAndNextEngine
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FmPcdCcModifyKeyAndNextEngine
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|keySize
argument_list|,
name|p_KeyParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableFindNRemoveKey
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|p_CcNode
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
operator|&
name|keyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"The received key and mask pair was not found in the match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|FmPcdCcRemoveKey
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableFindNModifyNextEngine
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|p_CcNode
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
operator|&
name|keyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"The received key and mask pair was not found in the match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ModifyNextEngineParamNode
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableFindNModifyKeyAndNextEngine
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdLockTryLockAll
argument_list|(
name|p_FmPcd
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"FmPcdLockTryLockAll failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|p_CcNode
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
operator|&
name|keyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"The received key and mask pair was not found in the match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|FmPcdCcModifyKeyAndNextEngine
argument_list|(
name|p_FmPcd
argument_list|,
name|h_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|keySize
argument_list|,
name|p_KeyParams
argument_list|)
expr_stmt|;
name|FmPcdLockUnlockAll
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableFindNModifyKey
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|,
name|uint8_t
modifier|*
name|p_NewKey
parameter_list|,
name|uint8_t
modifier|*
name|p_NewMask
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|t_List
name|h_List
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_NewKey
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|p_CcNode
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|h_List
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmPcdCcNodeTreeTryLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
operator|&
name|h_List
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Node's trees lock failed"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|p_CcNode
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
operator|&
name|keyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|FmPcdCcNodeTreeReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_List
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"The received key and mask pair was not found in the "
literal|"match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|FmPcdCcModifyKey
argument_list|(
name|p_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|keySize
argument_list|,
name|p_NewKey
argument_list|,
name|p_NewMask
argument_list|)
expr_stmt|;
name|FmPcdCcNodeTreeReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|h_List
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableGetNextEngine
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"keyIndex exceeds current number of keys"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIndex
operator|>
operator|(
name|FM_PCD_MAX_NUM_OF_KEYS
operator|-
literal|1
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"keyIndex can not be larger than %d"
operator|,
operator|(
name|FM_PCD_MAX_NUM_OF_KEYS
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
operator|&
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|nextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PCD_MatchTableGetKeyCounter
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint32_t
modifier|*
name|p_StatsCounters
decl_stmt|,
name|frameCount
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNode
operator|->
name|statisticsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_NONE
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Statistics were not enabled for this match table"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|p_CcNode
operator|->
name|statisticsMode
operator|!=
name|e_FM_PCD_CC_STATS_MODE_FRAME
operator|)
operator|&&
operator|(
name|p_CcNode
operator|->
name|statisticsMode
operator|!=
name|e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME
operator|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Frame count is not supported in the statistics mode of this match table"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"The provided keyIndex exceeds the number of keys in this match table"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Statistics were not enabled for this key"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p_StatsCounters
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
name|keyIndex
index|]
operator|.
name|p_StatsObj
operator|->
name|h_StatsCounters
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_StatsCounters
argument_list|)
expr_stmt|;
comment|/* The first counter is byte counter, so we need to advance to the next counter */
name|frameCount
operator|=
name|GET_UINT32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|PTR_MOVE
argument_list|(
name|p_StatsCounters
argument_list|,
name|FM_PCD_CC_STATS_COUNTER_SIZE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|frameCount
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableGetKeyStatistics
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint16_t
name|keyIndex
parameter_list|,
name|t_FmPcdCcKeyStatistics
modifier|*
name|p_KeyStatistics
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyStatistics
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"The provided keyIndex exceeds the number of keys in this match table"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|MatchTableGetKeyStatistics
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_KeyStatistics
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableGetMissStatistics
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|t_FmPcdCcKeyStatistics
modifier|*
name|p_MissStatistics
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_MissStatistics
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|err
operator|=
name|MatchTableGetKeyStatistics
argument_list|(
name|p_CcNode
argument_list|,
name|p_CcNode
operator|->
name|numOfKeys
argument_list|,
name|p_MissStatistics
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableFindNGetKeyStatistics
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
modifier|*
name|p_Mask
parameter_list|,
name|t_FmPcdCcKeyStatistics
modifier|*
name|p_KeyStatistics
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint16_t
name|keyIndex
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyStatistics
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|XX_LockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|)
expr_stmt|;
name|err
operator|=
name|FindKeyIndex
argument_list|(
name|p_CcNode
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_Mask
argument_list|,
operator|&
name|keyIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"The received key and mask pair was not found in the "
literal|"match table of the provided node"
operator|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT_COND
argument_list|(
name|keyIndex
operator|<
name|p_CcNode
operator|->
name|numOfKeys
argument_list|)
expr_stmt|;
name|err
operator|=
name|MatchTableGetKeyStatistics
argument_list|(
name|p_CcNode
argument_list|,
name|keyIndex
argument_list|,
name|p_KeyStatistics
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
name|p_CcNode
operator|->
name|h_Spinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_MatchTableGetIndexedHashBucket
parameter_list|(
name|t_Handle
name|h_CcNode
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|uint8_t
name|hashShift
parameter_list|,
name|t_Handle
modifier|*
name|p_CcNodeBucketHandle
parameter_list|,
name|uint8_t
modifier|*
name|p_BucketIndex
parameter_list|,
name|uint16_t
modifier|*
name|p_LastIndex
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_CcNode
decl_stmt|;
name|uint16_t
name|glblMask
decl_stmt|;
name|uint64_t
name|crc64
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_CcNode
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNode
operator|->
name|parseCode
operator|==
name|CC_PC_GENERIC_IC_HASH_INDEXED
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_CcNodeBucketHandle
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|glblMask
argument_list|,
name|PTR_MOVE
argument_list|(
name|p_CcNode
operator|->
name|p_GlblMask
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|glblMask
operator|=
name|be16toh
argument_list|(
name|glblMask
argument_list|)
expr_stmt|;
name|crc64
operator|=
name|crc64_init
argument_list|()
expr_stmt|;
name|crc64
operator|=
name|crc64_compute
argument_list|(
name|p_Key
argument_list|,
name|keySize
argument_list|,
name|crc64
argument_list|)
expr_stmt|;
name|crc64
operator|>>=
name|hashShift
expr_stmt|;
operator|*
name|p_BucketIndex
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
operator|(
name|crc64
operator|>>
operator|(
literal|8
operator|*
operator|(
literal|6
operator|-
name|p_CcNode
operator|->
name|userOffset
operator|)
operator|)
operator|)
operator|&
name|glblMask
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p_BucketIndex
operator|>=
name|p_CcNode
operator|->
name|numOfKeys
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"bucket index!"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_CcNodeBucketHandle
operator|=
name|p_CcNode
operator|->
name|keyAndNextEngineParams
index|[
operator|*
name|p_BucketIndex
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p_CcNodeBucketHandle
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_NOT_FOUND
argument_list|,
operator|(
literal|"bucket!"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|p_LastIndex
operator|=
operator|(
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
operator|*
name|p_CcNodeBucketHandle
operator|)
operator|->
name|numOfKeys
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Handle
name|FM_PCD_HashTableSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdHashTableParams
modifier|*
name|p_Param
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_CcNodeHashTbl
decl_stmt|;
name|t_FmPcdCcNodeParams
modifier|*
name|p_IndxHashCcNodeParam
decl_stmt|,
modifier|*
name|p_ExactMatchCcNodeParam
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_CcNode
decl_stmt|;
name|t_Handle
name|h_MissStatsCounters
init|=
name|NULL
decl_stmt|;
name|t_FmPcdCcKeyParams
modifier|*
name|p_HashKeyParams
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|numOfSets
decl_stmt|,
name|numOfWays
decl_stmt|,
name|countMask
decl_stmt|,
name|onesCount
init|=
literal|0
decl_stmt|;
name|bool
name|statsEnForMiss
init|=
name|FALSE
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_Param
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Param
operator|->
name|maxNumOfKeys
operator|==
literal|0
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Max number of keys must be higher then 0"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_Param
operator|->
name|hashResMask
operator|==
literal|0
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Hash result mask must differ from 0"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*Fix: QorIQ SDK / QSDK-2131*/
if|if
condition|(
name|p_Param
operator|->
name|ccNextEngineParamsForMiss
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_INVALID
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Next PCD Engine for on-miss entry is invalid. On-miss entry is always required. You can use e_FM_PCD_DONE."
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_Param
operator|->
name|statisticsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_RMON
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"RMON statistics mode is not supported for hash table"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
name|p_ExactMatchCcNodeParam
operator|=
operator|(
name|t_FmPcdCcNodeParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNodeParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ExactMatchCcNodeParam
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"p_ExactMatchCcNodeParam"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_ExactMatchCcNodeParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNodeParams
argument_list|)
argument_list|)
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|=
operator|(
name|t_FmPcdCcNodeParams
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNodeParams
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_IndxHashCcNodeParam
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ExactMatchCcNodeParam
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"p_IndxHashCcNodeParam"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_IndxHashCcNodeParam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNodeParams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate number of sets and number of ways of the hash table */
name|countMask
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|p_Param
operator|->
name|hashResMask
operator|>>
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|countMask
condition|)
block|{
name|onesCount
operator|++
expr_stmt|;
name|countMask
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|countMask
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
name|numOfSets
operator|=
call|(
name|uint16_t
call|)
argument_list|(
literal|1
operator|<<
name|onesCount
argument_list|)
expr_stmt|;
name|numOfWays
operator|=
operator|(
name|uint16_t
operator|)
name|DIV_CEIL
argument_list|(
name|p_Param
operator|->
name|maxNumOfKeys
argument_list|,
name|numOfSets
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Param
operator|->
name|maxNumOfKeys
operator|%
name|numOfSets
condition|)
name|DBG
argument_list|(
name|INFO
argument_list|,
operator|(
literal|"'maxNumOfKeys' is not a multiple of hash number of ways, so number of ways will be rounded up"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_Param
operator|->
name|statisticsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_FRAME
operator|)
operator|||
operator|(
name|p_Param
operator|->
name|statisticsMode
operator|==
name|e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME
operator|)
condition|)
block|{
comment|/* Allocating a statistics counters table that will be used by all          'miss' entries of the hash table */
name|h_MissStatsCounters
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|h_FmPcd
argument_list|)
argument_list|,
literal|2
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_MissStatsCounters
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"MURAM allocation for statistics table for hash miss"
operator|)
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_IndxHashCcNodeParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ExactMatchCcNodeParam
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|h_MissStatsCounters
argument_list|,
literal|0
argument_list|,
operator|(
literal|2
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
operator|)
argument_list|)
expr_stmt|;
comment|/* Always enable statistics for 'miss', so that a statistics AD will be          initialized from the start. We'll store the requested 'statistics enable'          value and it will be used when statistics are read by the user. */
name|statsEnForMiss
operator|=
name|p_Param
operator|->
name|ccNextEngineParamsForMiss
operator|.
name|statisticsEn
expr_stmt|;
name|p_Param
operator|->
name|ccNextEngineParamsForMiss
operator|.
name|statisticsEn
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Building exact-match node params, will be used to create the hash buckets */
name|p_ExactMatchCcNodeParam
operator|->
name|extractCcParams
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_NON_HDR
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
operator|=
name|e_FM_PCD_EXTRACT_FROM_KEY
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|action
operator|=
name|e_FM_PCD_ACTION_EXACT_MATCH
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|size
operator|=
name|p_Param
operator|->
name|matchKeySize
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
operator|=
name|numOfWays
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|keysParams
operator|.
name|maskSupport
operator|=
name|FALSE
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|keysParams
operator|.
name|statisticsMode
operator|=
name|p_Param
operator|->
name|statisticsMode
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|keysParams
operator|.
name|numOfKeys
operator|=
literal|0
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
operator|=
name|p_Param
operator|->
name|matchKeySize
expr_stmt|;
name|p_ExactMatchCcNodeParam
operator|->
name|keysParams
operator|.
name|ccNextEngineParamsForMiss
operator|=
name|p_Param
operator|->
name|ccNextEngineParamsForMiss
expr_stmt|;
name|p_HashKeyParams
operator|=
name|p_IndxHashCcNodeParam
operator|->
name|keysParams
operator|.
name|keyParams
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfSets
condition|;
name|i
operator|++
control|)
block|{
comment|/* Each exact-match node will be marked as a 'bucket' and provided with            a pointer to statistics counters, to be used for 'miss' entry            statistics */
name|p_CcNode
operator|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CcNode
condition|)
break|break;
name|memset
argument_list|(
name|p_CcNode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNode
argument_list|)
argument_list|)
expr_stmt|;
name|p_CcNode
operator|->
name|isHashBucket
operator|=
name|TRUE
expr_stmt|;
name|p_CcNode
operator|->
name|h_MissStatsCounters
operator|=
name|h_MissStatsCounters
expr_stmt|;
name|err
operator|=
name|MatchTableSet
argument_list|(
name|h_FmPcd
argument_list|,
name|p_CcNode
argument_list|,
name|p_ExactMatchCcNodeParam
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|p_HashKeyParams
index|[
name|i
index|]
operator|.
name|ccNextEngineParams
operator|.
name|nextEngine
operator|=
name|e_FM_PCD_CC
expr_stmt|;
name|p_HashKeyParams
index|[
name|i
index|]
operator|.
name|ccNextEngineParams
operator|.
name|statisticsEn
operator|=
name|FALSE
expr_stmt|;
name|p_HashKeyParams
index|[
name|i
index|]
operator|.
name|ccNextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
operator|=
name|p_CcNode
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|numOfSets
condition|)
block|{
for|for
control|(
name|i
operator|=
name|i
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|FM_PCD_MatchTableDelete
argument_list|(
name|p_HashKeyParams
index|[
name|i
index|]
operator|.
name|ccNextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
argument_list|)
expr_stmt|;
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|h_FmPcd
argument_list|)
argument_list|,
name|h_MissStatsCounters
argument_list|)
expr_stmt|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NULL_POINTER
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_IndxHashCcNodeParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ExactMatchCcNodeParam
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Creating indexed-hash CC node */
name|p_IndxHashCcNodeParam
operator|->
name|extractCcParams
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_NON_HDR
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|src
operator|=
name|e_FM_PCD_EXTRACT_FROM_HASH
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|action
operator|=
name|e_FM_PCD_ACTION_INDEXED_LOOKUP
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|icIndxMask
operator|=
name|p_Param
operator|->
name|hashResMask
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|offset
operator|=
name|p_Param
operator|->
name|hashShift
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|extractCcParams
operator|.
name|extractNonHdr
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|keysParams
operator|.
name|maxNumOfKeys
operator|=
name|numOfSets
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|keysParams
operator|.
name|maskSupport
operator|=
name|FALSE
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|keysParams
operator|.
name|statisticsMode
operator|=
name|e_FM_PCD_CC_STATS_MODE_NONE
expr_stmt|;
comment|/* Number of keys of this node is number of sets of the hash */
name|p_IndxHashCcNodeParam
operator|->
name|keysParams
operator|.
name|numOfKeys
operator|=
name|numOfSets
expr_stmt|;
name|p_IndxHashCcNodeParam
operator|->
name|keysParams
operator|.
name|keySize
operator|=
literal|2
expr_stmt|;
name|p_CcNodeHashTbl
operator|=
name|FM_PCD_MatchTableSet
argument_list|(
name|h_FmPcd
argument_list|,
name|p_IndxHashCcNodeParam
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CcNodeHashTbl
condition|)
block|{
name|p_CcNodeHashTbl
operator|->
name|kgHashShift
operator|=
name|p_Param
operator|->
name|kgHashShift
expr_stmt|;
comment|/* Storing the allocated counters for buckets 'miss' in the hash table          and if statistics for miss were enabled. */
name|p_CcNodeHashTbl
operator|->
name|h_MissStatsCounters
operator|=
name|h_MissStatsCounters
expr_stmt|;
name|p_CcNodeHashTbl
operator|->
name|statsEnForMiss
operator|=
name|statsEnForMiss
expr_stmt|;
block|}
name|XX_Free
argument_list|(
name|p_IndxHashCcNodeParam
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ExactMatchCcNodeParam
argument_list|)
expr_stmt|;
return|return
name|p_CcNodeHashTbl
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableDelete
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_FmPcd
decl_stmt|;
name|t_Handle
modifier|*
name|p_HashBuckets
decl_stmt|,
name|h_MissStatsCounters
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|numOfBuckets
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* Store all hash buckets before the hash is freed */
name|numOfBuckets
operator|=
name|p_HashTbl
operator|->
name|numOfKeys
expr_stmt|;
name|p_HashBuckets
operator|=
operator|(
name|t_Handle
operator|*
operator|)
name|XX_Malloc
argument_list|(
name|numOfBuckets
operator|*
sizeof|sizeof
argument_list|(
name|t_Handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_HashBuckets
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfBuckets
condition|;
name|i
operator|++
control|)
name|p_HashBuckets
index|[
name|i
index|]
operator|=
name|p_HashTbl
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|h_FmPcd
operator|=
name|p_HashTbl
operator|->
name|h_FmPcd
expr_stmt|;
name|h_MissStatsCounters
operator|=
name|p_HashTbl
operator|->
name|h_MissStatsCounters
expr_stmt|;
comment|/* Free the hash */
name|err
operator|=
name|FM_PCD_MatchTableDelete
argument_list|(
name|p_HashTbl
argument_list|)
expr_stmt|;
comment|/* Free each hash bucket */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfBuckets
condition|;
name|i
operator|++
control|)
name|err
operator||=
name|FM_PCD_MatchTableDelete
argument_list|(
name|p_HashBuckets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_HashBuckets
argument_list|)
expr_stmt|;
comment|/* Free statistics counters for 'miss', if these were allocated */
if|if
condition|(
name|h_MissStatsCounters
condition|)
name|FM_MURAM_FreeMem
argument_list|(
name|FmPcdGetMuramHandle
argument_list|(
name|h_FmPcd
argument_list|)
argument_list|,
name|h_MissStatsCounters
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableAddKey
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|t_FmPcdCcKeyParams
modifier|*
name|p_KeyParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_HashBucket
decl_stmt|;
name|uint8_t
name|bucketIndex
decl_stmt|;
name|uint16_t
name|lastIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_KeyParams
operator|->
name|p_Mask
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Keys masks not supported for hash table"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FM_PCD_MatchTableGetIndexedHashBucket
argument_list|(
name|p_HashTbl
argument_list|,
name|keySize
argument_list|,
name|p_KeyParams
operator|->
name|p_Key
argument_list|,
name|p_HashTbl
operator|->
name|kgHashShift
argument_list|,
operator|&
name|h_HashBucket
argument_list|,
operator|&
name|bucketIndex
argument_list|,
operator|&
name|lastIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|FM_PCD_MatchTableAddKey
argument_list|(
name|h_HashBucket
argument_list|,
name|FM_PCD_LAST_KEY_INDEX
argument_list|,
name|keySize
argument_list|,
name|p_KeyParams
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableRemoveKey
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_HashBucket
decl_stmt|;
name|uint8_t
name|bucketIndex
decl_stmt|;
name|uint16_t
name|lastIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|err
operator|=
name|FM_PCD_MatchTableGetIndexedHashBucket
argument_list|(
name|p_HashTbl
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_HashTbl
operator|->
name|kgHashShift
argument_list|,
operator|&
name|h_HashBucket
argument_list|,
operator|&
name|bucketIndex
argument_list|,
operator|&
name|lastIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|FM_PCD_MatchTableFindNRemoveKey
argument_list|(
name|h_HashBucket
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableModifyNextEngine
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_HashBucket
decl_stmt|;
name|uint8_t
name|bucketIndex
decl_stmt|;
name|uint16_t
name|lastIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|err
operator|=
name|FM_PCD_MatchTableGetIndexedHashBucket
argument_list|(
name|p_HashTbl
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_HashTbl
operator|->
name|kgHashShift
argument_list|,
operator|&
name|h_HashBucket
argument_list|,
operator|&
name|bucketIndex
argument_list|,
operator|&
name|lastIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|FM_PCD_MatchTableFindNModifyNextEngine
argument_list|(
name|h_HashBucket
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|NULL
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableModifyMissNextEngine
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_HashBucket
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|bool
name|nullifyMissStats
init|=
name|FALSE
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|p_HashTbl
operator|->
name|h_MissStatsCounters
operator|)
operator|&&
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Statistics are requested for a key, but statistics mode was set"
literal|"to 'NONE' upon initialization"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_HashTbl
operator|->
name|h_MissStatsCounters
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|p_HashTbl
operator|->
name|statsEnForMiss
operator|)
operator|&&
operator|(
name|p_FmPcdCcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
name|nullifyMissStats
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|p_HashTbl
operator|->
name|statsEnForMiss
operator|)
operator|&&
operator|(
operator|!
name|p_FmPcdCcNextEngineParams
operator|->
name|statisticsEn
operator|)
condition|)
block|{
name|p_HashTbl
operator|->
name|statsEnForMiss
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcdCcNextEngineParams
operator|->
name|statisticsEn
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_HashTbl
operator|->
name|numOfKeys
condition|;
name|i
operator|++
control|)
block|{
name|h_HashBucket
operator|=
name|p_HashTbl
operator|->
name|keyAndNextEngineParams
index|[
name|i
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|err
operator|=
name|FM_PCD_MatchTableModifyMissNextEngine
argument_list|(
name|h_HashBucket
argument_list|,
name|p_FmPcdCcNextEngineParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullifyMissStats
condition|)
block|{
name|memset
argument_list|(
name|p_HashTbl
operator|->
name|h_MissStatsCounters
argument_list|,
literal|0
argument_list|,
operator|(
literal|2
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_HashTbl
operator|->
name|h_MissStatsCounters
argument_list|,
literal|0
argument_list|,
operator|(
literal|2
operator|*
name|FM_PCD_CC_STATS_COUNTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|p_HashTbl
operator|->
name|statsEnForMiss
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableGetMissNextEngine
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_FmPcdCcNextEngineParams
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_FmPcdCcNode
modifier|*
name|p_HashBucket
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* Miss next engine of each bucket was initialized with the next engine of the hash table */
name|p_HashBucket
operator|=
name|p_HashTbl
operator|->
name|keyAndNextEngineParams
index|[
literal|0
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
name|memcpy
argument_list|(
name|p_FmPcdCcNextEngineParams
argument_list|,
operator|&
name|p_HashBucket
operator|->
name|keyAndNextEngineParams
index|[
name|p_HashBucket
operator|->
name|numOfKeys
index|]
operator|.
name|nextEngineParams
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdCcNextEngineParams
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableFindNGetKeyStatistics
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|uint8_t
name|keySize
parameter_list|,
name|uint8_t
modifier|*
name|p_Key
parameter_list|,
name|t_FmPcdCcKeyStatistics
modifier|*
name|p_KeyStatistics
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_HashBucket
decl_stmt|;
name|uint8_t
name|bucketIndex
decl_stmt|;
name|uint16_t
name|lastIndex
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_Key
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_KeyStatistics
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|err
operator|=
name|FM_PCD_MatchTableGetIndexedHashBucket
argument_list|(
name|p_HashTbl
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|p_HashTbl
operator|->
name|kgHashShift
argument_list|,
operator|&
name|h_HashBucket
argument_list|,
operator|&
name|bucketIndex
argument_list|,
operator|&
name|lastIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|FM_PCD_MatchTableFindNGetKeyStatistics
argument_list|(
name|h_HashBucket
argument_list|,
name|keySize
argument_list|,
name|p_Key
argument_list|,
name|NULL
argument_list|,
name|p_KeyStatistics
argument_list|)
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_HashTableGetMissStatistics
parameter_list|(
name|t_Handle
name|h_HashTbl
parameter_list|,
name|t_FmPcdCcKeyStatistics
modifier|*
name|p_MissStatistics
parameter_list|)
block|{
name|t_FmPcdCcNode
modifier|*
name|p_HashTbl
init|=
operator|(
name|t_FmPcdCcNode
operator|*
operator|)
name|h_HashTbl
decl_stmt|;
name|t_Handle
name|h_HashBucket
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_HashTbl
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_MissStatistics
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_HashTbl
operator|->
name|statsEnForMiss
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Statistics were not enabled for miss"
operator|)
argument_list|)
expr_stmt|;
name|h_HashBucket
operator|=
name|p_HashTbl
operator|->
name|keyAndNextEngineParams
index|[
literal|0
index|]
operator|.
name|nextEngineParams
operator|.
name|params
operator|.
name|ccParams
operator|.
name|h_CcNode
expr_stmt|;
return|return
name|FM_PCD_MatchTableGetMissStatistics
argument_list|(
name|h_HashBucket
argument_list|,
name|p_MissStatistics
argument_list|)
return|;
block|}
end_function

end_unit

