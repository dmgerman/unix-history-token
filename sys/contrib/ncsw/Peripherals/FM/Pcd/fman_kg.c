begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *	 notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *	 notice, this list of conditions and the following disclaimer in the  *	 documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *	 names of its contributors may be used to endorse or promote products  *	 derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"fsl_fman_kg.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|build_ar_bind_scheme
parameter_list|(
name|uint8_t
name|hwport_id
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|uint32_t
name|rw
decl_stmt|;
name|rw
operator|=
name|write
condition|?
operator|(
name|uint32_t
operator|)
name|FM_KG_KGAR_WRITE
else|:
operator|(
name|uint32_t
operator|)
name|FM_KG_KGAR_READ
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|rw
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_ENTRY
operator||
name|hwport_id
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_pe_all_scheme
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|)
block|{
name|uint32_t
name|ar
decl_stmt|;
name|fman_kg_write_sp
argument_list|(
name|regs
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar
operator|=
name|build_ar_bind_scheme
argument_list|(
name|hwport_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|ar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|build_ar_bind_cls_plan
parameter_list|(
name|uint8_t
name|hwport_id
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|uint32_t
name|rw
decl_stmt|;
name|rw
operator|=
name|write
condition|?
operator|(
name|uint32_t
operator|)
name|FM_KG_KGAR_WRITE
else|:
operator|(
name|uint32_t
operator|)
name|FM_KG_KGAR_READ
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|rw
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_ENTRY
operator||
name|hwport_id
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_pe_all_cls_plan
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|)
block|{
name|uint32_t
name|ar
decl_stmt|;
name|fman_kg_write_cpp
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar
operator|=
name|build_ar_bind_cls_plan
argument_list|(
name|hwport_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|ar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|get_gen_ht_code
parameter_list|(
name|enum
name|fman_kg_gen_extract_src
name|src
parameter_list|,
name|bool
name|no_validation
parameter_list|,
name|uint8_t
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
switch|switch
condition|(
name|src
condition|)
block|{
case|case
name|E_FMAN_KG_GEN_EXTRACT_ETH
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x73
else|:
literal|0x3
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_ETYPE
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x77
else|:
literal|0x7
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_SNAP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x74
else|:
literal|0x4
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_1
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x75
else|:
literal|0x5
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_VLAN_TCI_N
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x76
else|:
literal|0x6
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_PPPoE
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x78
else|:
literal|0x8
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_MPLS_1
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x79
else|:
literal|0x9
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_MPLS_2
case|:
name|code
operator|=
name|no_validation
condition|?
name|FM_KG_SCH_GEN_HT_INVALID
else|:
literal|0x19
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_MPLS_3
case|:
name|code
operator|=
name|no_validation
condition|?
name|FM_KG_SCH_GEN_HT_INVALID
else|:
literal|0x29
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_MPLS_N
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7a
else|:
literal|0xa
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IPv4_1
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7b
else|:
literal|0xb
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IPv6_1
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7b
else|:
literal|0x1b
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IPv4_2
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7c
else|:
literal|0xc
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IPv6_2
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7c
else|:
literal|0x1c
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_MINENCAP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7c
else|:
literal|0x2c
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IP_PID
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x72
else|:
literal|0x2
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_GRE
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7d
else|:
literal|0xd
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_TCP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7e
else|:
literal|0xe
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_UDP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7e
else|:
literal|0x1e
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_SCTP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7e
else|:
literal|0x3e
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_DCCP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7e
else|:
literal|0x4e
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IPSEC_AH
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7e
else|:
literal|0x2e
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_IPSEC_ESP
case|:
name|code
operator|=
name|no_validation
condition|?
literal|0x7e
else|:
literal|0x6e
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_SHIM_1
case|:
name|code
operator|=
literal|0x70
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_SHIM_2
case|:
name|code
operator|=
literal|0x71
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_FROM_DFLT
case|:
name|code
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_FROM_FRAME_START
case|:
name|code
operator|=
literal|0x40
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_FROM_PARSE_RESULT
case|:
name|code
operator|=
literal|0x20
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_FROM_END_OF_PARSE
case|:
name|code
operator|=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|E_FMAN_KG_GEN_EXTRACT_FROM_FQID
case|:
name|code
operator|=
literal|0x20
expr_stmt|;
operator|*
name|offset
operator|+=
literal|0x20
expr_stmt|;
break|break;
default|default:
name|code
operator|=
name|FM_KG_SCH_GEN_HT_INVALID
expr_stmt|;
block|}
return|return
operator|(
name|uint8_t
operator|)
name|code
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|build_ar_scheme
parameter_list|(
name|uint8_t
name|scheme
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|bool
name|update_counter
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|uint32_t
name|rw
decl_stmt|;
name|rw
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|write
condition|?
name|FM_KG_KGAR_WRITE
else|:
name|FM_KG_KGAR_READ
argument_list|)
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|rw
operator||
name|FM_KG_KGAR_SEL_SCHEME_ENTRY
operator||
name|hwport_id
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|scheme
operator|<<
name|FM_KG_KGAR_NUM_SHIFT
operator|)
operator||
operator|(
name|update_counter
condition|?
name|FM_KG_KGAR_SCM_WSEL_UPDATE_CNT
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|build_ar_cls_plan
parameter_list|(
name|uint8_t
name|grp
parameter_list|,
name|uint8_t
name|entries_mask
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|bool
name|write
parameter_list|)
block|{
name|uint32_t
name|rw
decl_stmt|;
name|rw
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|write
condition|?
name|FM_KG_KGAR_WRITE
else|:
name|FM_KG_KGAR_READ
argument_list|)
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|rw
operator||
name|FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY
operator||
name|hwport_id
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|grp
operator|<<
name|FM_KG_KGAR_NUM_SHIFT
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|entries_mask
operator|<<
name|FM_KG_KGAR_WSEL_SHIFT
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_write_ar_wait
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|fmkg_ar
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|fmkg_ar
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_ar
argument_list|)
expr_stmt|;
comment|/* Wait for GO to be idle and read error */
while|while
condition|(
operator|(
name|fmkg_ar
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_ar
argument_list|)
operator|)
operator|&
name|FM_KG_KGAR_GO
condition|)
empty_stmt|;
if|if
condition|(
name|fmkg_ar
operator|&
name|FM_PCD_KG_KGAR_ERR
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fman_kg_write_sp
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|sp
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|struct
name|fman_kg_pe_regs
modifier|*
name|kgpe_regs
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|kgpe_regs
operator|=
operator|(
expr|struct
name|fman_kg_pe_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|kgpe_regs
operator|->
name|fmkg_pe_sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|tmp
operator||=
name|sp
expr_stmt|;
else|else
comment|/* clear */
name|tmp
operator|&=
operator|~
name|sp
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|kgpe_regs
operator|->
name|fmkg_pe_sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_write_cpp
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|cpp
parameter_list|)
block|{
name|struct
name|fman_kg_pe_regs
modifier|*
name|kgpe_regs
decl_stmt|;
name|kgpe_regs
operator|=
operator|(
expr|struct
name|fman_kg_pe_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|cpp
argument_list|,
operator|&
name|kgpe_regs
operator|->
name|fmkg_pe_cpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_get_event
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
modifier|*
name|event
parameter_list|,
name|uint32_t
modifier|*
name|scheme_idx
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|,
name|force
decl_stmt|;
operator|*
name|event
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_eer
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
operator|*
name|scheme_idx
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_seer
argument_list|)
expr_stmt|;
operator|*
name|scheme_idx
operator|&=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_seeer
argument_list|)
expr_stmt|;
operator|*
name|event
operator|&=
name|mask
expr_stmt|;
comment|/* clear the forced events */
name|force
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_feer
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|&
operator|*
name|event
condition|)
name|iowrite32be
argument_list|(
name|force
operator|&
operator|~
operator|*
name|event
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_feer
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
operator|*
name|event
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_eer
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
operator|*
name|scheme_idx
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_seer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_init
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|exceptions
parameter_list|,
name|uint32_t
name|dflt_nia
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iowrite32be
argument_list|(
name|FM_EX_KG_DOUBLE_ECC
operator||
name|FM_EX_KG_KEYSIZE_OVERFLOW
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_eer
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exceptions
operator|&
name|FM_EX_KG_DOUBLE_ECC
condition|)
name|tmp
operator||=
name|FM_EX_KG_DOUBLE_ECC
expr_stmt|;
if|if
condition|(
name|exceptions
operator|&
name|FM_EX_KG_KEYSIZE_OVERFLOW
condition|)
name|tmp
operator||=
name|FM_EX_KG_KEYSIZE_OVERFLOW
expr_stmt|;
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
literal|0
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_fdor
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
literal|0
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gdv0r
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
literal|0
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gdv1r
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|dflt_nia
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gcr
argument_list|)
expr_stmt|;
comment|/* Clear binding between ports to schemes and classification plans 	 * so that all ports are not bound to any scheme/classification plan */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FMAN_MAX_NUM_OF_HW_PORTS
condition|;
name|i
operator|++
control|)
block|{
name|clear_pe_all_scheme
argument_list|(
name|regs
argument_list|,
operator|(
name|uint8_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|clear_pe_all_cls_plan
argument_list|(
name|regs
argument_list|,
operator|(
name|uint8_t
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fman_kg_enable_scheme_interrupts
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|)
block|{
comment|/* enable and enable all scheme interrupts */
name|iowrite32be
argument_list|(
literal|0xFFFFFFFF
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_seer
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
literal|0xFFFFFFFF
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_seeer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_enable
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_gcr
argument_list|)
operator||
name|FM_KG_KGGCR_EN
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_disable
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_gcr
argument_list|)
operator|&
operator|~
name|FM_KG_KGGCR_EN
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_set_data_after_prs
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|offset
parameter_list|)
block|{
name|iowrite32be
argument_list|(
name|offset
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_fdor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_set_dflt_val
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|def_id
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|def_id
operator|==
literal|0
condition|)
name|iowrite32be
argument_list|(
name|val
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gdv0r
argument_list|)
expr_stmt|;
else|else
name|iowrite32be
argument_list|(
name|val
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_gdv1r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_set_exception
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|exception
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|tmp
operator||=
name|exception
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|&=
operator|~
name|exception
expr_stmt|;
block|}
name|iowrite32be
argument_list|(
name|tmp
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fman_kg_get_exception
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
modifier|*
name|events
parameter_list|,
name|uint32_t
modifier|*
name|scheme_ids
parameter_list|,
name|bool
name|clear
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|;
operator|*
name|events
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_eer
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_eeer
argument_list|)
expr_stmt|;
operator|*
name|events
operator|&=
name|mask
expr_stmt|;
operator|*
name|scheme_ids
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|events
operator|&
name|FM_EX_KG_KEYSIZE_OVERFLOW
condition|)
block|{
operator|*
name|scheme_ids
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_seer
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_seeer
argument_list|)
expr_stmt|;
operator|*
name|scheme_ids
operator|&=
name|mask
expr_stmt|;
block|}
if|if
condition|(
name|clear
condition|)
block|{
name|iowrite32be
argument_list|(
operator|*
name|scheme_ids
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_seer
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
operator|*
name|events
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_eer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fman_kg_get_capture
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|struct
name|fman_kg_ex_ecc_attr
modifier|*
name|ecc_attr
parameter_list|,
name|bool
name|clear
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_serc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|KG_FMKG_SERC_CAP
condition|)
block|{
comment|/* Captured data is valid */
name|ecc_attr
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
name|ecc_attr
operator|->
name|double_ecc
operator|=
call|(
name|bool
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|KG_FMKG_SERC_CET
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
name|ecc_attr
operator|->
name|single_ecc_count
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|tmp
operator|&
name|KG_FMKG_SERC_CNT_MSK
operator|)
operator|>>
name|KG_FMKG_SERC_CNT_SHIFT
argument_list|)
expr_stmt|;
name|ecc_attr
operator|->
name|addr
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|tmp
operator|&
name|KG_FMKG_SERC_ADDR_MSK
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear
condition|)
name|iowrite32be
argument_list|(
name|KG_FMKG_SERC_CAP
argument_list|,
operator|&
name|regs
operator|->
name|fmkg_serc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No ECC error is captured */
name|ecc_attr
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|fman_kg_build_scheme
parameter_list|(
name|struct
name|fman_kg_scheme_params
modifier|*
name|params
parameter_list|,
name|struct
name|fman_kg_scheme_regs
modifier|*
name|scheme_regs
parameter_list|)
block|{
name|struct
name|fman_kg_extract_params
modifier|*
name|extract_params
decl_stmt|;
name|struct
name|fman_kg_gen_extract_params
modifier|*
name|gen_params
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|,
name|i
decl_stmt|,
name|select
decl_stmt|,
name|mask
decl_stmt|,
name|fqb
decl_stmt|;
name|uint8_t
name|offset
decl_stmt|,
name|shift
decl_stmt|,
name|ht
decl_stmt|;
comment|/* Zero out all registers so no need to care about unused ones */
name|memset
argument_list|(
name|scheme_regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fman_kg_scheme_regs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mode register */
name|tmp_reg
operator|=
name|fm_kg_build_nia
argument_list|(
name|params
operator|->
name|next_engine
argument_list|,
name|params
operator|->
name|next_engine_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_reg
operator|==
name|KG_NIA_INVALID
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|params
operator|->
name|next_engine
operator|==
name|E_FMAN_PCD_PLCR
condition|)
block|{
name|tmp_reg
operator||=
name|FMAN_KG_SCH_MODE_NIA_PLCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|->
name|next_engine
operator|==
name|E_FMAN_PCD_CC
condition|)
block|{
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|params
operator|->
name|cc_params
operator|.
name|base_offset
operator|<<
name|FMAN_KG_SCH_MODE_CCOBASE_SHIFT
expr_stmt|;
block|}
name|tmp_reg
operator||=
name|FMAN_KG_SCH_MODE_EN
expr_stmt|;
name|scheme_regs
operator|->
name|kgse_mode
operator|=
name|tmp_reg
expr_stmt|;
comment|/* Match vector */
name|scheme_regs
operator|->
name|kgse_mv
operator|=
name|params
operator|->
name|match_vector
expr_stmt|;
name|extract_params
operator|=
operator|&
name|params
operator|->
name|extract_params
expr_stmt|;
comment|/* Scheme default values registers */
name|scheme_regs
operator|->
name|kgse_dv0
operator|=
name|extract_params
operator|->
name|def_scheme_0
expr_stmt|;
name|scheme_regs
operator|->
name|kgse_dv1
operator|=
name|extract_params
operator|->
name|def_scheme_1
expr_stmt|;
comment|/* Extract Known Fields Command register */
name|scheme_regs
operator|->
name|kgse_ekfc
operator|=
name|extract_params
operator|->
name|known_fields
expr_stmt|;
comment|/* Entry Extract Known Default Value register */
name|tmp_reg
operator|=
literal|0
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|mac_addr
operator|<<
name|FMAN_KG_SCH_DEF_MAC_ADDR_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|vlan_tci
operator|<<
name|FMAN_KG_SCH_DEF_VLAN_TCI_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|etype
operator|<<
name|FMAN_KG_SCH_DEF_ETYPE_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ppp_sid
operator|<<
name|FMAN_KG_SCH_DEF_PPP_SID_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ppp_pid
operator|<<
name|FMAN_KG_SCH_DEF_PPP_PID_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|mpls
operator|<<
name|FMAN_KG_SCH_DEF_MPLS_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ip_addr
operator|<<
name|FMAN_KG_SCH_DEF_IP_ADDR_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ptype
operator|<<
name|FMAN_KG_SCH_DEF_PTYPE_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ip_tos_tc
operator|<<
name|FMAN_KG_SCH_DEF_IP_TOS_TC_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ipv6_fl
operator|<<
name|FMAN_KG_SCH_DEF_IPv6_FL_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|ipsec_spi
operator|<<
name|FMAN_KG_SCH_DEF_IPSEC_SPI_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|l4_port
operator|<<
name|FMAN_KG_SCH_DEF_L4_PORT_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|extract_params
operator|->
name|known_fields_def
operator|.
name|tcp_flg
operator|<<
name|FMAN_KG_SCH_DEF_TCP_FLG_SHIFT
expr_stmt|;
name|scheme_regs
operator|->
name|kgse_ekdv
operator|=
name|tmp_reg
expr_stmt|;
comment|/* Generic extract registers */
if|if
condition|(
name|extract_params
operator|->
name|gen_extract_num
operator|>
name|FM_KG_NUM_OF_GENERIC_REGS
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extract_params
operator|->
name|gen_extract_num
condition|;
name|i
operator|++
control|)
block|{
name|gen_params
operator|=
name|extract_params
operator|->
name|gen_extract
operator|+
name|i
expr_stmt|;
name|tmp_reg
operator|=
name|FMAN_KG_SCH_GEN_VALID
expr_stmt|;
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|gen_params
operator|->
name|def_val
operator|<<
name|FMAN_KG_SCH_GEN_DEF_SHIFT
expr_stmt|;
if|if
condition|(
name|gen_params
operator|->
name|type
operator|==
name|E_FMAN_KG_HASH_EXTRACT
condition|)
block|{
if|if
condition|(
operator|(
name|gen_params
operator|->
name|extract
operator|>
name|FMAN_KG_SCH_GEN_SIZE_MAX
operator|)
operator|||
operator|(
name|gen_params
operator|->
name|extract
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
block|{
name|tmp_reg
operator||=
name|FMAN_KG_SCH_GEN_OR
expr_stmt|;
block|}
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|gen_params
operator|->
name|extract
operator|<<
name|FMAN_KG_SCH_GEN_SIZE_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|gen_params
operator|->
name|mask
operator|<<
name|FMAN_KG_SCH_GEN_MASK_SHIFT
expr_stmt|;
name|offset
operator|=
name|gen_params
operator|->
name|offset
expr_stmt|;
name|ht
operator|=
name|get_gen_ht_code
argument_list|(
name|gen_params
operator|->
name|src
argument_list|,
name|gen_params
operator|->
name|no_validation
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|ht
operator|<<
name|FMAN_KG_SCH_GEN_HT_SHIFT
expr_stmt|;
name|tmp_reg
operator||=
name|offset
expr_stmt|;
name|scheme_regs
operator|->
name|kgse_gec
index|[
name|i
index|]
operator|=
name|tmp_reg
expr_stmt|;
block|}
comment|/* Masks registers */
if|if
condition|(
name|extract_params
operator|->
name|masks_num
operator|>
name|FM_KG_EXTRACT_MASKS_NUM
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|select
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|fqb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extract_params
operator|->
name|masks_num
condition|;
name|i
operator|++
control|)
block|{
comment|/* MCSx fields */
name|KG_GET_MASK_SEL_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|extract_params
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|is_known
condition|)
block|{
comment|/* Mask known field */
name|select
operator||=
name|extract_params
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|field_or_gen_idx
operator|<<
name|shift
expr_stmt|;
block|}
else|else
block|{
comment|/* Mask generic extract */
name|select
operator||=
operator|(
name|extract_params
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|field_or_gen_idx
operator|+
name|FM_KG_MASK_SEL_GEN_BASE
operator|)
operator|<<
name|shift
expr_stmt|;
block|}
comment|/* MOx fields - spread between se_bmch and se_fqb registers */
name|KG_GET_MASK_OFFSET_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
name|select
operator||=
operator|(
name|uint32_t
operator|)
name|extract_params
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|offset
operator|<<
name|shift
expr_stmt|;
block|}
else|else
block|{
name|fqb
operator||=
operator|(
name|uint32_t
operator|)
name|extract_params
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|offset
operator|<<
name|shift
expr_stmt|;
block|}
comment|/* BMx fields */
name|KG_GET_MASK_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mask
operator||=
operator|(
name|uint32_t
operator|)
name|extract_params
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|mask
operator|<<
name|shift
expr_stmt|;
block|}
comment|/* Finish with rest of BMx fileds - 	 * don't mask bits for unused masks by setting 	 * corresponding BMx field = 0xFF */
for|for
control|(
name|i
operator|=
name|extract_params
operator|->
name|masks_num
init|;
name|i
operator|<
name|FM_KG_EXTRACT_MASKS_NUM
condition|;
name|i
operator|++
control|)
block|{
name|KG_GET_MASK_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mask
operator||=
literal|0xFF
operator|<<
name|shift
expr_stmt|;
block|}
name|scheme_regs
operator|->
name|kgse_bmch
operator|=
name|select
expr_stmt|;
name|scheme_regs
operator|->
name|kgse_bmcl
operator|=
name|mask
expr_stmt|;
comment|/* Finish with FQB register initialization. 	 * Check fqid is 24-bit value. */
if|if
condition|(
name|params
operator|->
name|base_fqid
operator|&
operator|~
literal|0x00FFFFFF
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|fqb
operator||=
name|params
operator|->
name|base_fqid
expr_stmt|;
name|scheme_regs
operator|->
name|kgse_fqb
operator|=
name|fqb
expr_stmt|;
comment|/* Hash Configuration register */
name|tmp_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hash_params
operator|.
name|use_hash
condition|)
block|{
comment|/* Check hash mask is 24-bit value */
if|if
condition|(
name|params
operator|->
name|hash_params
operator|.
name|mask
operator|&
operator|~
literal|0x00FFFFFF
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Hash function produces 64-bit value, 24 bits of that 		 * are used to generate fq_id and policer profile. 		 * Thus, maximal shift is 40 bits to allow 24 bits out of 64. 		 */
if|if
condition|(
name|params
operator|->
name|hash_params
operator|.
name|shift_r
operator|>
name|FMAN_KG_SCH_HASH_HSHIFT_MAX
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|tmp_reg
operator||=
name|params
operator|->
name|hash_params
operator|.
name|mask
expr_stmt|;
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|params
operator|->
name|hash_params
operator|.
name|shift_r
operator|<<
name|FMAN_KG_SCH_HASH_HSHIFT_SHIFT
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|hash_params
operator|.
name|sym
condition|)
block|{
name|tmp_reg
operator||=
name|FMAN_KG_SCH_HASH_SYM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|params
operator|->
name|bypass_fqid_gen
condition|)
block|{
name|tmp_reg
operator||=
name|FMAN_KG_SCH_HASH_NO_FQID_GEN
expr_stmt|;
block|}
name|scheme_regs
operator|->
name|kgse_hc
operator|=
name|tmp_reg
expr_stmt|;
comment|/* Policer Profile register */
if|if
condition|(
name|params
operator|->
name|policer_params
operator|.
name|bypass_pp_gen
condition|)
block|{
name|tmp_reg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Lower 8 bits of 24-bits extracted from hash result 		 * are used for policer profile generation. 		 * That leaves maximum shift value = 23. */
if|if
condition|(
name|params
operator|->
name|policer_params
operator|.
name|shift
operator|>
name|FMAN_KG_SCH_PP_SHIFT_MAX
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
name|tmp_reg
operator|=
name|params
operator|->
name|policer_params
operator|.
name|base
expr_stmt|;
name|tmp_reg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|params
operator|->
name|policer_params
operator|.
name|shift
operator|<<
name|FMAN_KG_SCH_PP_SH_SHIFT
operator|)
operator|&
name|FMAN_KG_SCH_PP_SH_MASK
expr_stmt|;
name|tmp_reg
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|params
operator|->
name|policer_params
operator|.
name|shift
operator|<<
name|FMAN_KG_SCH_PP_SL_SHIFT
operator|)
operator|&
name|FMAN_KG_SCH_PP_SL_MASK
expr_stmt|;
name|tmp_reg
operator||=
operator|(
name|uint32_t
operator|)
name|params
operator|->
name|policer_params
operator|.
name|mask
operator|<<
name|FMAN_KG_SCH_PP_MASK_SHIFT
expr_stmt|;
block|}
name|scheme_regs
operator|->
name|kgse_ppc
operator|=
name|tmp_reg
expr_stmt|;
comment|/* Coarse Classification Bit Select register */
if|if
condition|(
name|params
operator|->
name|next_engine
operator|==
name|E_FMAN_PCD_CC
condition|)
block|{
name|scheme_regs
operator|->
name|kgse_ccbs
operator|=
name|params
operator|->
name|cc_params
operator|.
name|qlcv_bits_sel
expr_stmt|;
block|}
comment|/* Packets Counter register */
if|if
condition|(
name|params
operator|->
name|update_counter
condition|)
block|{
name|scheme_regs
operator|->
name|kgse_spc
operator|=
name|params
operator|->
name|counter_value
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_write_scheme
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|scheme_id
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|struct
name|fman_kg_scheme_regs
modifier|*
name|scheme_regs
parameter_list|,
name|bool
name|update_counter
parameter_list|)
block|{
name|struct
name|fman_kg_scheme_regs
modifier|*
name|kgse_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
comment|/* Write indirect scheme registers */
name|kgse_regs
operator|=
operator|(
expr|struct
name|fman_kg_scheme_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_mode
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_mode
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_ekfc
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_ekfc
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_ekdv
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_ekdv
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_bmch
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_bmch
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_bmcl
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_bmcl
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_fqb
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_fqb
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_hc
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_hc
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_ppc
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_ppc
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_spc
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_spc
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_dv0
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_dv0
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_dv1
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_dv1
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_ccbs
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_ccbs
argument_list|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_mv
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_mv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_KG_NUM_OF_GENERIC_REGS
condition|;
name|i
operator|++
control|)
name|iowrite32be
argument_list|(
name|scheme_regs
operator|->
name|kgse_gec
index|[
name|i
index|]
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_gec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Write AR (Action register) */
name|tmp_reg
operator|=
name|build_ar_scheme
argument_list|(
name|scheme_id
argument_list|,
name|hwport_id
argument_list|,
name|update_counter
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_delete_scheme
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|scheme_id
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|)
block|{
name|struct
name|fman_kg_scheme_regs
modifier|*
name|kgse_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|kgse_regs
operator|=
operator|(
expr|struct
name|fman_kg_scheme_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* Clear all registers including enable bit in mode register */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|fman_kg_scheme_regs
argument_list|)
operator|)
operator|/
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|iowrite32be
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|kgse_regs
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write AR (Action register) */
name|tmp_reg
operator|=
name|build_ar_scheme
argument_list|(
name|scheme_id
argument_list|,
name|hwport_id
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_get_scheme_counter
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|scheme_id
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|uint32_t
modifier|*
name|counter
parameter_list|)
block|{
name|struct
name|fman_kg_scheme_regs
modifier|*
name|kgse_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|kgse_regs
operator|=
operator|(
expr|struct
name|fman_kg_scheme_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|tmp_reg
operator|=
name|build_ar_scheme
argument_list|(
name|scheme_id
argument_list|,
name|hwport_id
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
operator|*
name|counter
operator|=
name|ioread32be
argument_list|(
operator|&
name|kgse_regs
operator|->
name|kgse_spc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_set_scheme_counter
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|scheme_id
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|uint32_t
name|counter
parameter_list|)
block|{
name|struct
name|fman_kg_scheme_regs
modifier|*
name|kgse_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|kgse_regs
operator|=
operator|(
expr|struct
name|fman_kg_scheme_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|tmp_reg
operator|=
name|build_ar_scheme
argument_list|(
name|scheme_id
argument_list|,
name|hwport_id
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
comment|/* Keygen indirect access memory contains all scheme_id registers 	 * by now. Change only counter value. */
name|iowrite32be
argument_list|(
name|counter
argument_list|,
operator|&
name|kgse_regs
operator|->
name|kgse_spc
argument_list|)
expr_stmt|;
comment|/* Write back scheme registers */
name|tmp_reg
operator|=
name|build_ar_scheme
argument_list|(
name|scheme_id
argument_list|,
name|hwport_id
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|uint32_t
name|fman_kg_get_schemes_total_counter
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|)
block|{
return|return
name|ioread32be
argument_list|(
operator|&
name|regs
operator|->
name|fmkg_tpc
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_build_cls_plan
parameter_list|(
name|struct
name|fman_kg_cls_plan_params
modifier|*
name|params
parameter_list|,
name|struct
name|fman_kg_cp_regs
modifier|*
name|cls_plan_regs
parameter_list|)
block|{
name|uint8_t
name|entries_set
decl_stmt|,
name|entry_bit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Zero out all group's register */
name|memset
argument_list|(
name|cls_plan_regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fman_kg_cp_regs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go over all classification entries in params->entries_mask and 	 * configure the corresponding cpe register */
name|entries_set
operator|=
name|params
operator|->
name|entries_mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|entries_set
condition|;
name|i
operator|++
control|)
block|{
name|entry_bit
operator|=
call|(
name|uint8_t
call|)
argument_list|(
literal|0x80
operator|>>
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry_bit
operator|&
name|entries_set
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|entries_set
operator|^=
name|entry_bit
expr_stmt|;
name|cls_plan_regs
operator|->
name|kgcpe
index|[
name|i
index|]
operator|=
name|params
operator|->
name|mask_vector
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_write_cls_plan
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|grp_id
parameter_list|,
name|uint8_t
name|entries_mask
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|struct
name|fman_kg_cp_regs
modifier|*
name|cls_plan_regs
parameter_list|)
block|{
name|struct
name|fman_kg_cp_regs
modifier|*
name|kgcpe_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
comment|/* Check group index is valid and the group isn't empty */
if|if
condition|(
name|grp_id
operator|>=
name|FM_KG_CLS_PLAN_GRPS_NUM
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Write indirect classification plan registers */
name|kgcpe_regs
operator|=
operator|(
expr|struct
name|fman_kg_cp_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_KG_NUM_CLS_PLAN_ENTR
condition|;
name|i
operator|++
control|)
block|{
name|iowrite32be
argument_list|(
name|cls_plan_regs
operator|->
name|kgcpe
index|[
name|i
index|]
argument_list|,
operator|&
name|kgcpe_regs
operator|->
name|kgcpe
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tmp_reg
operator|=
name|build_ar_cls_plan
argument_list|(
name|grp_id
argument_list|,
name|entries_mask
argument_list|,
name|hwport_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_write_bind_schemes
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|uint32_t
name|schemes
parameter_list|)
block|{
name|struct
name|fman_kg_pe_regs
modifier|*
name|kg_pe_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|kg_pe_regs
operator|=
operator|(
expr|struct
name|fman_kg_pe_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|schemes
argument_list|,
operator|&
name|kg_pe_regs
operator|->
name|fmkg_pe_sp
argument_list|)
expr_stmt|;
name|tmp_reg
operator|=
name|build_ar_bind_scheme
argument_list|(
name|hwport_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_build_bind_cls_plans
parameter_list|(
name|uint8_t
name|grp_base
parameter_list|,
name|uint8_t
name|grp_mask
parameter_list|,
name|uint32_t
modifier|*
name|bind_cls_plans
parameter_list|)
block|{
comment|/* Check grp_base and grp_mask are 5-bits values */
if|if
condition|(
operator|(
name|grp_base
operator|&
operator|~
literal|0x0000001F
operator|)
operator|||
operator|(
name|grp_mask
operator|&
operator|~
literal|0x0000001F
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
operator|*
name|bind_cls_plans
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|grp_mask
operator|<<
name|FMAN_KG_PE_CPP_MASK_SHIFT
operator|)
operator||
name|grp_base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fman_kg_write_bind_cls_plans
parameter_list|(
name|struct
name|fman_kg_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
name|hwport_id
parameter_list|,
name|uint32_t
name|bind_cls_plans
parameter_list|)
block|{
name|struct
name|fman_kg_pe_regs
modifier|*
name|kg_pe_regs
decl_stmt|;
name|uint32_t
name|tmp_reg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|kg_pe_regs
operator|=
operator|(
expr|struct
name|fman_kg_pe_regs
operator|*
operator|)
operator|&
operator|(
name|regs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|iowrite32be
argument_list|(
name|bind_cls_plans
argument_list|,
operator|&
name|kg_pe_regs
operator|->
name|fmkg_pe_cpp
argument_list|)
expr_stmt|;
name|tmp_reg
operator|=
name|build_ar_bind_cls_plan
argument_list|(
name|hwport_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

