begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_replic.c   @Description   FM frame replicator */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_muram_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_replic.h"
end_include

begin_include
include|#
directive|include
file|"fm_cc.h"
end_include

begin_include
include|#
directive|include
file|"list_ext.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|uint8_t
name|GetMemberPosition
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|uint32_t
name|memberIndex
parameter_list|,
name|bool
name|isAddOperation
parameter_list|)
block|{
name|uint8_t
name|memberPosition
decl_stmt|;
name|uint32_t
name|lastMemberIndex
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
comment|/* the last member index is different between add and remove operation -     in case of remove - this is exactly the last member index     in case of add - this is the last member index + 1 - e.g.     if we have 4 members, the index of the actual last member is 3(because the     index starts from 0) therefore in order to add a new member as the last     member we shall use memberIndex = 4 and not 3     */
if|if
condition|(
name|isAddOperation
condition|)
name|lastMemberIndex
operator|=
name|p_ReplicGroup
operator|->
name|numOfEntries
expr_stmt|;
else|else
name|lastMemberIndex
operator|=
name|p_ReplicGroup
operator|->
name|numOfEntries
operator|-
literal|1
expr_stmt|;
comment|/* last */
if|if
condition|(
name|memberIndex
operator|==
name|lastMemberIndex
condition|)
name|memberPosition
operator|=
name|FRM_REPLIC_LAST_MEMBER_INDEX
expr_stmt|;
else|else
block|{
comment|/* first */
if|if
condition|(
name|memberIndex
operator|==
literal|0
condition|)
name|memberPosition
operator|=
name|FRM_REPLIC_FIRST_MEMBER_INDEX
expr_stmt|;
else|else
block|{
comment|/* middle */
name|ASSERT_COND
argument_list|(
name|memberIndex
operator|<
name|lastMemberIndex
argument_list|)
expr_stmt|;
name|memberPosition
operator|=
name|FRM_REPLIC_MIDDLE_MEMBER_INDEX
expr_stmt|;
block|}
block|}
return|return
name|memberPosition
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|MemberCheckParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_MemberParams
parameter_list|)
block|{
name|t_Error
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|p_MemberParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_DONE
operator|)
operator|&&
operator|(
name|p_MemberParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_KG
operator|)
operator|&&
operator|(
name|p_MemberParams
operator|->
name|nextEngine
operator|!=
name|e_FM_PCD_PLCR
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Next engine of a member should be MatchTable(cc) or Done or Policer"
operator|)
argument_list|)
expr_stmt|;
comment|/* check the regular parameters of the next engine */
name|err
operator|=
name|ValidateNextEngineParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_MemberParams
argument_list|,
name|e_FM_PCD_CC_STATS_MODE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"member next engine parameters"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|CheckParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdFrmReplicGroupParams
modifier|*
name|p_ReplicGroupParam
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* check that max num of entries is at least 2 */
if|if
condition|(
operator|!
name|IN_RANGE
argument_list|(
literal|2
argument_list|,
name|p_ReplicGroupParam
operator|->
name|maxNumOfEntries
argument_list|,
name|FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"maxNumOfEntries in the frame replicator parameters should be 2-%d"
operator|,
name|FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES
operator|)
argument_list|)
expr_stmt|;
comment|/* check that number of entries is greater than zero */
if|if
condition|(
operator|!
name|p_ReplicGroupParam
operator|->
name|numOfEntries
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOFEntries in the frame replicator group should be greater than zero"
operator|)
argument_list|)
expr_stmt|;
comment|/* check that max num of entries is equal or greater than number of entries */
if|if
condition|(
name|p_ReplicGroupParam
operator|->
name|maxNumOfEntries
operator|<
name|p_ReplicGroupParam
operator|->
name|numOfEntries
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"maxNumOfEntries should be equal or greater than numOfEntries"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ReplicGroupParam
operator|->
name|numOfEntries
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|MemberCheckParams
argument_list|(
name|h_FmPcd
argument_list|,
operator|&
name|p_ReplicGroupParam
operator|->
name|nextEngineParams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"member check parameters"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_FmPcdFrmReplicMember
modifier|*
name|GetAvailableMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|)
block|{
name|t_FmPcdFrmReplicMember
modifier|*
name|p_ReplicMember
init|=
name|NULL
decl_stmt|;
name|t_List
modifier|*
name|p_Next
decl_stmt|;
if|if
condition|(
operator|!
name|LIST_IsEmpty
argument_list|(
operator|&
name|p_ReplicGroup
operator|->
name|availableMembersList
argument_list|)
condition|)
block|{
name|p_Next
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p_ReplicGroup
operator|->
name|availableMembersList
argument_list|)
expr_stmt|;
name|p_ReplicMember
operator|=
name|LIST_OBJECT
argument_list|(
name|p_Next
argument_list|,
name|t_FmPcdFrmReplicMember
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicMember
argument_list|)
expr_stmt|;
name|LIST_DelAndInit
argument_list|(
name|p_Next
argument_list|)
expr_stmt|;
block|}
return|return
name|p_ReplicMember
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PutAvailableMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_ReplicMember
parameter_list|)
block|{
name|LIST_AddToTail
argument_list|(
operator|&
name|p_ReplicMember
operator|->
name|node
argument_list|,
operator|&
name|p_ReplicGroup
operator|->
name|availableMembersList
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|AddMemberToList
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
parameter_list|,
name|t_List
modifier|*
name|p_ListHead
parameter_list|)
block|{
name|LIST_Add
argument_list|(
operator|&
name|p_CurrentMember
operator|->
name|node
argument_list|,
name|p_ListHead
argument_list|)
expr_stmt|;
name|p_ReplicGroup
operator|->
name|numOfEntries
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|RemoveMemberFromList
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
operator|->
name|numOfEntries
argument_list|)
expr_stmt|;
name|LIST_DelAndInit
argument_list|(
operator|&
name|p_CurrentMember
operator|->
name|node
argument_list|)
expr_stmt|;
name|p_ReplicGroup
operator|->
name|numOfEntries
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|LinkSourceToMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_AdOfTypeContLookup
modifier|*
name|p_SourceTd
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_ReplicMember
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_SourceTd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicMember
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
comment|/* Link the first member in the group to the source TD */
name|p_FmPcd
operator|=
name|p_ReplicGroup
operator|->
name|h_FmPcd
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_SourceTd
operator|->
name|matchTblPtr
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_ReplicMember
operator|->
name|p_MemberAd
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|LinkMemberToMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_NextMember
parameter_list|)
block|{
name|t_AdOfTypeResult
modifier|*
name|p_CurrReplicAd
init|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_CurrentMember
operator|->
name|p_MemberAd
decl_stmt|;
name|t_AdOfTypeResult
modifier|*
name|p_NextReplicAd
init|=
name|NULL
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint32_t
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Check if the next member exists or it's NULL (- means that this is the last member) */
if|if
condition|(
name|p_NextMember
condition|)
block|{
name|p_NextReplicAd
operator|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_NextMember
operator|->
name|p_MemberAd
expr_stmt|;
name|p_FmPcd
operator|=
name|p_ReplicGroup
operator|->
name|h_FmPcd
expr_stmt|;
name|offset
operator|=
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_NextReplicAd
argument_list|)
operator|-
operator|(
name|p_FmPcd
operator|->
name|physicalMuramBase
operator|)
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|offset
operator|>>
name|NEXT_FRM_REPLIC_ADDR_SHIFT
operator|)
operator|<<
name|NEXT_FRM_REPLIC_MEMBER_INDEX_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* link the current AD to point to the AD of the next member */
name|WRITE_UINT32
argument_list|(
name|p_CurrReplicAd
operator|->
name|res
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|ModifyDescriptor
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|void
modifier|*
name|p_OldDescriptor
parameter_list|,
name|void
modifier|*
name|p_NewDescriptor
parameter_list|)
block|{
name|t_Handle
name|h_Hc
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_OldDescriptor
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_NewDescriptor
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_ReplicGroup
operator|->
name|h_FmPcd
expr_stmt|;
name|h_Hc
operator|=
name|FmPcdGetHcHandle
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_Hc
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"Host command"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|FmHcPcdCcDoDynamicChange
argument_list|(
name|h_Hc
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_OldDescriptor
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|XX_VirtToPhys
argument_list|(
name|p_NewDescriptor
argument_list|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Dynamic change host command"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FillReplicAdOfTypeResult
parameter_list|(
name|void
modifier|*
name|p_ReplicAd
parameter_list|,
name|bool
name|last
parameter_list|)
block|{
name|t_AdOfTypeResult
modifier|*
name|p_CurrReplicAd
init|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_ReplicAd
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|GET_UINT32
argument_list|(
name|p_CurrReplicAd
operator|->
name|plcrProfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
comment|/* clear the NL bit in case it's the last member in the group*/
name|WRITE_UINT32
argument_list|(
name|p_CurrReplicAd
operator|->
name|plcrProfile
argument_list|,
operator|(
name|tmp
operator|&
operator|~
name|FRM_REPLIC_NL_BIT
operator|)
argument_list|)
expr_stmt|;
else|else
comment|/* set the NL bit in case it's not the last member in the group */
name|WRITE_UINT32
argument_list|(
name|p_CurrReplicAd
operator|->
name|plcrProfile
argument_list|,
operator|(
name|tmp
operator||
name|FRM_REPLIC_NL_BIT
operator|)
argument_list|)
expr_stmt|;
comment|/* set FR bit in the action descriptor */
name|tmp
operator|=
name|GET_UINT32
argument_list|(
name|p_CurrReplicAd
operator|->
name|nia
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_CurrReplicAd
operator|->
name|nia
argument_list|,
operator|(
name|tmp
operator||
name|FRM_REPLIC_FR_BIT
operator||
name|FM_PCD_AD_RESULT_EXTENDED_MODE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|BuildSourceTd
parameter_list|(
name|void
modifier|*
name|p_Ad
parameter_list|)
block|{
name|t_AdOfTypeContLookup
modifier|*
name|p_SourceTd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Ad
argument_list|)
expr_stmt|;
name|p_SourceTd
operator|=
operator|(
name|t_AdOfTypeContLookup
operator|*
operator|)
name|p_Ad
expr_stmt|;
name|IOMemSet32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_SourceTd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* initialize the source table descriptor */
name|WRITE_UINT32
argument_list|(
name|p_SourceTd
operator|->
name|ccAdBase
argument_list|,
name|FM_PCD_AD_CONT_LOOKUP_TYPE
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_SourceTd
operator|->
name|pcAndOffsets
argument_list|,
name|FRM_REPLIC_SOURCE_TD_OPCODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildShadowAndModifyDescriptor
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_NextMember
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
parameter_list|,
name|bool
name|sourceDescriptor
parameter_list|,
name|bool
name|last
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|t_FmPcdFrmReplicMember
name|shadowMember
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_ReplicGroup
operator|->
name|h_FmPcd
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRY_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|h_ShadowSpinlock
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
if|if
condition|(
name|sourceDescriptor
condition|)
block|{
name|BuildSourceTd
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|)
expr_stmt|;
name|LinkSourceToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
name|p_NextMember
argument_list|)
expr_stmt|;
comment|/* Modify the source table descriptor according to the prepared shadow descriptor */
name|err
operator|=
name|ModifyDescriptor
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_ReplicGroup
operator|->
name|p_SourceTd
argument_list|,
name|p_FmPcd
operator|->
name|p_CcShadow
comment|/* new prepared source td */
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Modify source Descriptor in BuildShadowAndModifyDescriptor"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IO2IOCpy32
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
name|p_CurrentMember
operator|->
name|p_MemberAd
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* update the last bit in the shadow ad */
name|FillReplicAdOfTypeResult
argument_list|(
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|shadowMember
operator|.
name|p_MemberAd
operator|=
name|p_FmPcd
operator|->
name|p_CcShadow
expr_stmt|;
comment|/* update the next FR member index */
name|LinkMemberToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
operator|&
name|shadowMember
argument_list|,
name|p_NextMember
argument_list|)
expr_stmt|;
comment|/* Modify the next member according to the prepared shadow descriptor */
name|err
operator|=
name|ModifyDescriptor
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
operator|->
name|p_MemberAd
argument_list|,
name|p_FmPcd
operator|->
name|p_CcShadow
argument_list|)
expr_stmt|;
name|RELEASE_LOCK
argument_list|(
name|p_FmPcd
operator|->
name|shadowLock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Modify Descriptor in BuildShadowAndModifyDescriptor"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_FmPcdFrmReplicMember
modifier|*
name|GetMemberByIndex
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|uint16_t
name|memberIndex
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|t_List
modifier|*
name|p_Pos
decl_stmt|;
name|t_FmPcdFrmReplicMember
modifier|*
name|p_Member
init|=
name|NULL
decl_stmt|;
name|LIST_FOR_EACH
argument_list|(
argument|p_Pos
argument_list|,
argument|&p_ReplicGroup->membersList
argument_list|)
block|{
if|if
condition|(
name|i
operator|==
name|memberIndex
condition|)
block|{
name|p_Member
operator|=
name|LIST_OBJECT
argument_list|(
name|p_Pos
argument_list|,
name|t_FmPcdFrmReplicMember
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|p_Member
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|p_Member
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|AllocMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|)
block|{
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
decl_stmt|;
name|t_Handle
name|h_Muram
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|h_Muram
operator|=
name|FmPcdGetMuramHandle
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Muram
argument_list|)
expr_stmt|;
comment|/* Initialize an internal structure of a member to add to the available members list */
name|p_CurrentMember
operator|=
operator|(
name|t_FmPcdFrmReplicMember
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdFrmReplicMember
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CurrentMember
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Frame replicator member"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_CurrentMember
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdFrmReplicMember
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the member AD */
name|p_CurrentMember
operator|->
name|p_MemberAd
operator|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_Muram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CurrentMember
operator|->
name|p_MemberAd
condition|)
block|{
name|XX_Free
argument_list|(
name|p_CurrentMember
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"member AD table"
operator|)
argument_list|)
expr_stmt|;
block|}
name|IOMemSet32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_CurrentMember
operator|->
name|p_MemberAd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Add the new member to the available members list */
name|LIST_AddToTail
argument_list|(
operator|&
name|p_CurrentMember
operator|->
name|node
argument_list|,
operator|&
operator|(
name|p_ReplicGroup
operator|->
name|availableMembersList
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_FmPcdFrmReplicMember
modifier|*
name|InitMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_MemberParams
parameter_list|,
name|bool
name|last
parameter_list|)
block|{
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
init|=
name|NULL
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
comment|/* Get an available member from the internal members list */
name|p_CurrentMember
operator|=
name|GetAvailableMember
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CurrentMember
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_FOUND
argument_list|,
operator|(
literal|"Available member"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_CurrentMember
operator|->
name|h_Manip
operator|=
name|NULL
expr_stmt|;
comment|/* clear the Ad of the new member */
name|IOMemSet32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_CurrentMember
operator|->
name|p_MemberAd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_CurrentMember
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Initialize the Ad of the member */
name|NextStepAd
argument_list|(
name|p_CurrentMember
operator|->
name|p_MemberAd
argument_list|,
name|NULL
argument_list|,
name|p_MemberParams
argument_list|,
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
comment|/* save Manip handle (for free needs) */
if|if
condition|(
name|p_MemberParams
operator|->
name|h_Manip
condition|)
name|p_CurrentMember
operator|->
name|h_Manip
operator|=
name|p_MemberParams
operator|->
name|h_Manip
expr_stmt|;
comment|/* Initialize the relevant frame replicator fields in the AD */
name|FillReplicAdOfTypeResult
argument_list|(
name|p_CurrentMember
operator|->
name|p_MemberAd
argument_list|,
name|last
argument_list|)
expr_stmt|;
return|return
name|p_CurrentMember
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|t_FmPcdFrmReplicMember
modifier|*
name|p_Member
parameter_list|)
block|{
comment|/* Note: Can't free the member AD just returns the member to the available        member list - therefore only memset the AD */
comment|/* zero the AD */
name|IOMemSet32
argument_list|(
name|p_Member
operator|->
name|p_MemberAd
argument_list|,
literal|0
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* return the member to the available members list */
name|PutAvailableMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_Member
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|RemoveMember
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|,
name|uint16_t
name|memberIndex
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
name|NULL
decl_stmt|;
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_PreviousMember
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_NextMember
init|=
name|NULL
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint8_t
name|memberPosition
decl_stmt|;
name|p_FmPcd
operator|=
name|p_ReplicGroup
operator|->
name|h_FmPcd
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
name|p_CurrentMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
name|memberIndex
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CurrentMember
argument_list|)
expr_stmt|;
comment|/* determine the member position in the group */
name|memberPosition
operator|=
name|GetMemberPosition
argument_list|(
name|p_ReplicGroup
argument_list|,
name|memberIndex
argument_list|,
name|FALSE
comment|/*remove operation*/
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|memberPosition
condition|)
block|{
case|case
name|FRM_REPLIC_FIRST_MEMBER_INDEX
case|:
name|p_NextMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|memberIndex
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_NextMember
argument_list|)
expr_stmt|;
comment|/* update the source td itself by using a host command */
name|err
operator|=
name|BuildShadowAndModifyDescriptor
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NextMember
argument_list|,
name|NULL
argument_list|,
name|TRUE
comment|/*sourceDescriptor*/
argument_list|,
name|FALSE
comment|/*last*/
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRM_REPLIC_MIDDLE_MEMBER_INDEX
case|:
name|p_PreviousMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|memberIndex
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_PreviousMember
argument_list|)
expr_stmt|;
name|p_NextMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|memberIndex
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_NextMember
argument_list|)
expr_stmt|;
name|err
operator|=
name|BuildShadowAndModifyDescriptor
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NextMember
argument_list|,
name|p_PreviousMember
argument_list|,
name|FALSE
comment|/*sourceDescriptor*/
argument_list|,
name|FALSE
comment|/*last*/
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRM_REPLIC_LAST_MEMBER_INDEX
case|:
name|p_PreviousMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|memberIndex
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_PreviousMember
argument_list|)
expr_stmt|;
name|err
operator|=
name|BuildShadowAndModifyDescriptor
argument_list|(
name|p_ReplicGroup
argument_list|,
name|NULL
argument_list|,
name|p_PreviousMember
argument_list|,
name|FALSE
comment|/*sourceDescriptor*/
argument_list|,
name|TRUE
comment|/*last*/
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"member position in remove member"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CurrentMember
operator|->
name|h_Manip
condition|)
block|{
name|FmPcdManipUpdateOwner
argument_list|(
name|p_CurrentMember
operator|->
name|h_Manip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p_CurrentMember
operator|->
name|h_Manip
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* remove the member from the driver internal members list */
name|RemoveMemberFromList
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
argument_list|)
expr_stmt|;
comment|/* return the member to the available members list */
name|FreeMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DeleteGroup
parameter_list|(
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|t_Handle
name|h_Muram
decl_stmt|;
name|t_FmPcdFrmReplicMember
modifier|*
name|p_Member
decl_stmt|,
modifier|*
name|p_CurrentMember
decl_stmt|;
if|if
condition|(
name|p_ReplicGroup
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|h_Muram
operator|=
name|FmPcdGetMuramHandle
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Muram
argument_list|)
expr_stmt|;
comment|/* free the source table descriptor */
if|if
condition|(
name|p_ReplicGroup
operator|->
name|p_SourceTd
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|h_Muram
argument_list|,
name|p_ReplicGroup
operator|->
name|p_SourceTd
argument_list|)
expr_stmt|;
name|p_ReplicGroup
operator|->
name|p_SourceTd
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Remove all members from the members linked list (hw and sw) and            return the members to the available members list */
if|if
condition|(
name|p_ReplicGroup
operator|->
name|numOfEntries
condition|)
block|{
name|j
operator|=
name|p_ReplicGroup
operator|->
name|numOfEntries
operator|-
literal|1
expr_stmt|;
comment|/* manually removal of the member because there are no owners of                this group */
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|p_CurrentMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
operator|(
name|uint16_t
operator|)
name|i
comment|/*memberIndex*/
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CurrentMember
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_CurrentMember
operator|->
name|h_Manip
condition|)
block|{
name|FmPcdManipUpdateOwner
argument_list|(
name|p_CurrentMember
operator|->
name|h_Manip
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p_CurrentMember
operator|->
name|h_Manip
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* remove the member from the internal driver members list */
name|RemoveMemberFromList
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
argument_list|)
expr_stmt|;
comment|/* return the member to the available members list */
name|FreeMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free members AD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ReplicGroup
operator|->
name|maxNumOfEntries
condition|;
name|i
operator|++
control|)
block|{
name|p_Member
operator|=
name|GetAvailableMember
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Member
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Member
operator|->
name|p_MemberAd
condition|)
block|{
name|FM_MURAM_FreeMem
argument_list|(
name|h_Muram
argument_list|,
name|p_Member
operator|->
name|p_MemberAd
argument_list|)
expr_stmt|;
name|p_Member
operator|->
name|p_MemberAd
operator|=
name|NULL
expr_stmt|;
block|}
name|XX_Free
argument_list|(
name|p_Member
argument_list|)
expr_stmt|;
block|}
comment|/* release the group lock */
if|if
condition|(
name|p_ReplicGroup
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|,
name|p_ReplicGroup
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
comment|/* free the replicator group */
name|XX_Free
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* NOTE: the inter-module routines are locked by cc in case of using them */
end_comment

begin_function
name|void
modifier|*
name|FrmReplicGroupGetSourceTableDescriptor
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_ReplicGroup
operator|->
name|p_SourceTd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|FrmReplicGroupUpdateAd
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|,
name|void
modifier|*
name|p_Ad
parameter_list|,
name|t_Handle
modifier|*
name|h_AdNew
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|t_AdOfTypeResult
modifier|*
name|p_AdResult
init|=
operator|(
name|t_AdOfTypeResult
operator|*
operator|)
name|p_Ad
decl_stmt|;
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
name|p_ReplicGroup
operator|->
name|h_FmPcd
expr_stmt|;
comment|/* build a bypass ad */
name|WRITE_UINT32
argument_list|(
name|p_AdResult
operator|->
name|fqid
argument_list|,
name|FM_PCD_AD_BYPASS_TYPE
operator||
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|XX_VirtToPhys
argument_list|(
name|p_ReplicGroup
operator|->
name|p_SourceTd
argument_list|)
operator|)
operator|-
name|p_FmPcd
operator|->
name|physicalMuramBase
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|h_AdNew
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FrmReplicGroupUpdateOwner
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
comment|/* update the group owner counter */
if|if
condition|(
name|add
condition|)
name|p_ReplicGroup
operator|->
name|owners
operator|++
expr_stmt|;
else|else
block|{
name|ASSERT_COND
argument_list|(
name|p_ReplicGroup
operator|->
name|owners
argument_list|)
expr_stmt|;
name|p_ReplicGroup
operator|->
name|owners
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|t_Error
name|FrmReplicGroupTryLock
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_ReplicGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmPcdLockTryLock
argument_list|(
name|p_ReplicGroup
operator|->
name|p_Lock
argument_list|)
condition|)
return|return
name|E_OK
return|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|FrmReplicGroupUnlock
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|h_ReplicGroup
argument_list|)
expr_stmt|;
name|FmPcdLockUnlock
argument_list|(
name|p_ReplicGroup
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       API Init unit functions        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PCD_FrmReplicSetGroup
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdFrmReplicGroupParams
modifier|*
name|p_ReplicGroupParam
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
decl_stmt|;
name|t_FmPcdFrmReplicMember
modifier|*
name|p_CurrentMember
decl_stmt|,
modifier|*
name|p_NextMember
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|bool
name|last
init|=
name|FALSE
decl_stmt|;
name|t_Handle
name|h_Muram
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_ReplicGroupParam
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdIsAdvancedOffloadSupported
argument_list|(
name|h_FmPcd
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Advanced-offload must be enabled"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|err
operator|=
name|CheckParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_ReplicGroupParam
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
name|NO_MSG
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_ReplicGroup
operator|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdFrmReplicGroup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ReplicGroup
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_ReplicGroup
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdFrmReplicGroup
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize lists for internal driver use */
name|INIT_LIST
argument_list|(
operator|&
name|p_ReplicGroup
operator|->
name|availableMembersList
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
operator|&
name|p_ReplicGroup
operator|->
name|membersList
argument_list|)
expr_stmt|;
name|p_ReplicGroup
operator|->
name|h_FmPcd
operator|=
name|h_FmPcd
expr_stmt|;
name|h_Muram
operator|=
name|FmPcdGetMuramHandle
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|h_Muram
argument_list|)
expr_stmt|;
comment|/* initialize the group lock */
name|p_ReplicGroup
operator|->
name|p_Lock
operator|=
name|FmPcdAcquireLock
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ReplicGroup
operator|->
name|p_Lock
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Replic group lock"
operator|)
argument_list|)
expr_stmt|;
name|DeleteGroup
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Allocate the frame replicator source table descriptor */
name|p_ReplicGroup
operator|->
name|p_SourceTd
operator|=
operator|(
name|t_Handle
operator|)
name|FM_MURAM_AllocMem
argument_list|(
name|h_Muram
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ReplicGroup
operator|->
name|p_SourceTd
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"frame replicator source table descriptor"
operator|)
argument_list|)
expr_stmt|;
name|DeleteGroup
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* update the shadow size - required for the host commands */
name|err
operator|=
name|FmPcdUpdateCcShadow
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|,
name|FM_PCD_CC_AD_ENTRY_SIZE
argument_list|,
name|FM_PCD_CC_AD_TABLE_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Update CC shadow"
operator|)
argument_list|)
expr_stmt|;
name|DeleteGroup
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_ReplicGroup
operator|->
name|maxNumOfEntries
operator|=
name|p_ReplicGroupParam
operator|->
name|maxNumOfEntries
expr_stmt|;
comment|/* Allocate the maximal number of members ADs and Statistics AD for the group        It prevents allocation of Muram in run-time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ReplicGroup
operator|->
name|maxNumOfEntries
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|AllocMember
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"allocate a new member"
operator|)
argument_list|)
expr_stmt|;
name|DeleteGroup
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Initialize the members linked lists:       (hw - the one that is used by the FMan controller and        sw - the one that is managed by the driver internally) */
for|for
control|(
name|i
operator|=
operator|(
name|p_ReplicGroupParam
operator|->
name|numOfEntries
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* check if this is the last member in the group */
if|if
condition|(
name|i
operator|==
operator|(
name|p_ReplicGroupParam
operator|->
name|numOfEntries
operator|-
literal|1
operator|)
condition|)
name|last
operator|=
name|TRUE
expr_stmt|;
else|else
name|last
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize a new member */
name|p_CurrentMember
operator|=
name|InitMember
argument_list|(
name|p_ReplicGroup
argument_list|,
operator|&
operator|(
name|p_ReplicGroupParam
operator|->
name|nextEngineParams
index|[
name|i
index|]
operator|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_CurrentMember
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"No available member"
operator|)
argument_list|)
expr_stmt|;
name|DeleteGroup
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Build the members group - link two consecutive members in the hw linked list */
name|LinkMemberToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
argument_list|,
name|p_NextMember
argument_list|)
expr_stmt|;
comment|/* update the driver internal members list to be compatible to the hw members linked list */
name|AddMemberToList
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_CurrentMember
argument_list|,
operator|&
name|p_ReplicGroup
operator|->
name|membersList
argument_list|)
expr_stmt|;
name|p_NextMember
operator|=
name|p_CurrentMember
expr_stmt|;
block|}
comment|/* initialize the source table descriptor */
name|BuildSourceTd
argument_list|(
name|p_ReplicGroup
operator|->
name|p_SourceTd
argument_list|)
expr_stmt|;
comment|/* link the source table descriptor to point to the first member in the group */
name|LinkSourceToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_ReplicGroup
operator|->
name|p_SourceTd
argument_list|,
name|p_NextMember
argument_list|)
expr_stmt|;
return|return
name|p_ReplicGroup
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_FrmReplicDeleteGroup
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ReplicGroup
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ReplicGroup
operator|->
name|owners
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"the group has owners and can't be deleted"
operator|)
argument_list|)
expr_stmt|;
name|DeleteGroup
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*       API Run-time Frame replicator Control unit functions                */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FM_PCD_FrmReplicAddMember
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|,
name|uint16_t
name|memberIndex
parameter_list|,
name|t_FmPcdCcNextEngineParams
modifier|*
name|p_MemberParams
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|t_FmPcdFrmReplicMember
modifier|*
name|p_NewMember
decl_stmt|,
modifier|*
name|p_CurrentMember
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_PreviousMember
init|=
name|NULL
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|uint8_t
name|memberPosition
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ReplicGroup
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_MemberParams
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* group lock */
name|err
operator|=
name|FrmReplicGroupTryLock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|==
name|E_BUSY
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
if|if
condition|(
name|memberIndex
operator|>
name|p_ReplicGroup
operator|->
name|numOfEntries
condition|)
block|{
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"memberIndex is greater than the members in the list"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memberIndex
operator|>=
name|p_ReplicGroup
operator|->
name|maxNumOfEntries
condition|)
block|{
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"memberIndex is greater than the allowed number of members in the group"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_ReplicGroup
operator|->
name|numOfEntries
operator|+
literal|1
operator|)
operator|>
name|FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES
condition|)
block|{
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfEntries with new entry can not be larger than %d\n"
operator|,
name|FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|MemberCheckParams
argument_list|(
name|p_ReplicGroup
operator|->
name|h_FmPcd
argument_list|,
name|p_MemberParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"member check parameters in add operation"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* determine the member position in the group */
name|memberPosition
operator|=
name|GetMemberPosition
argument_list|(
name|p_ReplicGroup
argument_list|,
name|memberIndex
argument_list|,
name|TRUE
comment|/* add operation */
argument_list|)
expr_stmt|;
comment|/* Initialize a new member */
name|p_NewMember
operator|=
name|InitMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_MemberParams
argument_list|,
operator|(
name|memberPosition
operator|==
name|FRM_REPLIC_LAST_MEMBER_INDEX
condition|?
name|TRUE
else|:
name|FALSE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_NewMember
condition|)
block|{
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
operator|(
literal|"No available member"
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|memberPosition
condition|)
block|{
case|case
name|FRM_REPLIC_FIRST_MEMBER_INDEX
case|:
name|p_CurrentMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
name|memberIndex
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CurrentMember
argument_list|)
expr_stmt|;
name|LinkMemberToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NewMember
argument_list|,
name|p_CurrentMember
argument_list|)
expr_stmt|;
comment|/* update the internal group source TD */
name|LinkSourceToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_ReplicGroup
operator|->
name|p_SourceTd
argument_list|,
name|p_NewMember
argument_list|)
expr_stmt|;
comment|/* add member to the internal sw member list */
name|AddMemberToList
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NewMember
argument_list|,
operator|&
name|p_ReplicGroup
operator|->
name|membersList
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRM_REPLIC_MIDDLE_MEMBER_INDEX
case|:
name|p_CurrentMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
name|memberIndex
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_CurrentMember
argument_list|)
expr_stmt|;
name|p_PreviousMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|memberIndex
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_PreviousMember
argument_list|)
expr_stmt|;
name|LinkMemberToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NewMember
argument_list|,
name|p_CurrentMember
argument_list|)
expr_stmt|;
name|LinkMemberToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_PreviousMember
argument_list|,
name|p_NewMember
argument_list|)
expr_stmt|;
name|AddMemberToList
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NewMember
argument_list|,
operator|&
name|p_PreviousMember
operator|->
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRM_REPLIC_LAST_MEMBER_INDEX
case|:
name|p_PreviousMember
operator|=
name|GetMemberByIndex
argument_list|(
name|p_ReplicGroup
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|memberIndex
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_PreviousMember
argument_list|)
expr_stmt|;
name|LinkMemberToMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_PreviousMember
argument_list|,
name|p_NewMember
argument_list|)
expr_stmt|;
name|FillReplicAdOfTypeResult
argument_list|(
name|p_PreviousMember
operator|->
name|p_MemberAd
argument_list|,
name|FALSE
comment|/*last*/
argument_list|)
expr_stmt|;
comment|/* add the new member to the internal sw member list */
name|AddMemberToList
argument_list|(
name|p_ReplicGroup
argument_list|,
name|p_NewMember
argument_list|,
operator|&
name|p_PreviousMember
operator|->
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"member position in add member"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_FrmReplicRemoveMember
parameter_list|(
name|t_Handle
name|h_ReplicGroup
parameter_list|,
name|uint16_t
name|memberIndex
parameter_list|)
block|{
name|t_FmPcdFrmReplicGroup
modifier|*
name|p_ReplicGroup
init|=
operator|(
name|t_FmPcdFrmReplicGroup
operator|*
operator|)
name|h_ReplicGroup
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_ReplicGroup
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* lock */
name|err
operator|=
name|FrmReplicGroupTryLock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
operator|==
name|E_BUSY
condition|)
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
if|if
condition|(
name|memberIndex
operator|>=
name|p_ReplicGroup
operator|->
name|numOfEntries
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
operator|(
literal|"member index to remove"
operator|)
argument_list|)
expr_stmt|;
comment|/* Design decision: group must contain at least one member        No possibility to remove the last member from the group */
if|if
condition|(
name|p_ReplicGroup
operator|->
name|numOfEntries
operator|==
literal|1
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_CONFLICT
argument_list|,
operator|(
literal|"Can't remove the last member. At least one member should be related to a group."
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|RemoveMember
argument_list|(
name|p_ReplicGroup
argument_list|,
name|memberIndex
argument_list|)
expr_stmt|;
comment|/* unlock */
name|FrmReplicGroupUnlock
argument_list|(
name|p_ReplicGroup
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_ERROR_TYPE
argument_list|(
name|err
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
return|return
name|E_OK
return|;
case|case
name|E_BUSY
case|:
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"E_BUSY error"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERROR_CODE
argument_list|(
name|E_BUSY
argument_list|)
return|;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************** End of API routines ************************/
end_comment

end_unit

