begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2008-2012 Freescale Semiconductor Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Freescale Semiconductor nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") as published by the Free Software  * Foundation, either version 2 of that License or (at your option) any  * later version.  *  * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/******************************************************************************  @File          fm_kg.c   @Description   FM PCD ... */
end_comment

begin_comment
comment|/***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"std_ext.h"
end_include

begin_include
include|#
directive|include
file|"error_ext.h"
end_include

begin_include
include|#
directive|include
file|"string_ext.h"
end_include

begin_include
include|#
directive|include
file|"debug_ext.h"
end_include

begin_include
include|#
directive|include
file|"net_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_port_ext.h"
end_include

begin_include
include|#
directive|include
file|"fm_common.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd.h"
end_include

begin_include
include|#
directive|include
file|"fm_hc.h"
end_include

begin_include
include|#
directive|include
file|"fm_pcd_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fm_kg.h"
end_include

begin_include
include|#
directive|include
file|"fsl_fman_kg.h"
end_include

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*       static functions               */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|KgHwLock
parameter_list|(
name|t_Handle
name|h_FmPcdKg
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcdKg
argument_list|)
expr_stmt|;
return|return
name|XX_LockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdKg
operator|*
operator|)
name|h_FmPcdKg
operator|)
operator|->
name|h_HwSpinlock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|KgHwUnlock
parameter_list|(
name|t_Handle
name|h_FmPcdKg
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_FmPcdKg
argument_list|)
expr_stmt|;
name|XX_UnlockIntrSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdKg
operator|*
operator|)
name|h_FmPcdKg
operator|)
operator|->
name|h_HwSpinlock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|KgSchemeLock
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Scheme
argument_list|)
expr_stmt|;
return|return
name|FmPcdLockSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|p_Lock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|KgSchemeUnlock
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|,
name|uint32_t
name|intFlags
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Scheme
argument_list|)
expr_stmt|;
name|FmPcdUnlockSpinlock
argument_list|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|p_Lock
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|KgSchemeFlagTryLock
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Scheme
argument_list|)
expr_stmt|;
return|return
name|FmPcdLockTryLock
argument_list|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|p_Lock
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|KgSchemeFlagUnlock
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
name|h_Scheme
argument_list|)
expr_stmt|;
name|FmPcdLockUnlock
argument_list|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|WriteKgarWait
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint32_t
name|fmkg_ar
parameter_list|)
block|{
name|struct
name|fman_kg_regs
modifier|*
name|regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
decl_stmt|;
if|if
condition|(
name|fman_kg_write_ar_wait
argument_list|(
name|regs
argument_list|,
name|fmkg_ar
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Keygen scheme access violation"
operator|)
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|e_FmPcdKgExtractDfltSelect
name|GetGenericSwDefault
parameter_list|(
name|t_FmPcdKgExtractDflt
name|swDefaults
index|[]
parameter_list|,
name|uint8_t
name|numOfSwDefaults
parameter_list|,
name|uint8_t
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
operator|(
name|KG_SCH_GEN_PARSE_RESULT_N_FQID
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_DEFAULT
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_NEXTHDR
operator|)
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfSwDefaults
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|swDefaults
index|[
name|i
index|]
operator|.
name|type
operator|==
name|e_FM_PCD_KG_GENERIC_NOT_FROM_DATA
condition|)
return|return
name|swDefaults
index|[
name|i
index|]
operator|.
name|dfltSelect
return|;
break|break;
case|case
operator|(
name|KG_SCH_GEN_SHIM1
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_SHIM2
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IP_PID_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_ETH_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_SNAP_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_VLAN1_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_VLAN2_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_ETH_TYPE_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_PPP_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MPLS1_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MPLS_LAST_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_L3_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IP2_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_GRE_NO_V
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_L4_NO_V
operator|)
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfSwDefaults
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|swDefaults
index|[
name|i
index|]
operator|.
name|type
operator|==
name|e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V
condition|)
return|return
name|swDefaults
index|[
name|i
index|]
operator|.
name|dfltSelect
return|;
break|break;
case|case
operator|(
name|KG_SCH_GEN_START_OF_FRM
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_ETH
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_SNAP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_VLAN1
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_VLAN2
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_ETH_TYPE
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_PPP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MPLS1
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MPLS2
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MPLS3
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MPLS_LAST
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IPV4
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IPV6
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IPV4_TUNNELED
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IPV6_TUNNELED
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_MIN_ENCAP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_GRE
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_TCP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_UDP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_SCTP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_DCCP
operator|)
case|:
case|case
operator|(
name|KG_SCH_GEN_IPSEC_ESP
operator|)
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfSwDefaults
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|swDefaults
index|[
name|i
index|]
operator|.
name|type
operator|==
name|e_FM_PCD_KG_GENERIC_FROM_DATA
condition|)
return|return
name|swDefaults
index|[
name|i
index|]
operator|.
name|dfltSelect
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|e_FM_PCD_KG_DFLT_ILLEGAL
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetGenCode
parameter_list|(
name|e_FmPcdExtractFrom
name|src
parameter_list|,
name|uint8_t
modifier|*
name|p_Offset
parameter_list|)
block|{
operator|*
name|p_Offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|src
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_FRAME_START
operator|)
case|:
return|return
name|KG_SCH_GEN_START_OF_FRM
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_DFLT_VALUE
operator|)
case|:
return|return
name|KG_SCH_GEN_DEFAULT
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_PARSE_RESULT
operator|)
case|:
return|return
name|KG_SCH_GEN_PARSE_RESULT_N_FQID
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_ENQ_FQID
operator|)
case|:
operator|*
name|p_Offset
operator|=
literal|32
expr_stmt|;
return|return
name|KG_SCH_GEN_PARSE_RESULT_N_FQID
return|;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE
operator|)
case|:
return|return
name|KG_SCH_GEN_NEXTHDR
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Illegal 'extract from' src"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetGenHdrCode
parameter_list|(
name|e_NetHeaderType
name|hdr
parameter_list|,
name|e_FmPcdHdrIndex
name|hdrIndex
parameter_list|,
name|bool
name|ignoreProtocolValidation
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreProtocolValidation
condition|)
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
return|return
name|KG_SCH_GEN_ETH
return|;
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
return|return
name|KG_SCH_GEN_SNAP
return|;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
return|return
name|KG_SCH_GEN_PPP
return|;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_MPLS1
return|;
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|KG_SCH_GEN_MPLS2
return|;
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_3
condition|)
return|return
name|KG_SCH_GEN_MPLS3
return|;
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|KG_SCH_GEN_MPLS_LAST
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal MPLS header index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_IPV4
return|;
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_GEN_IPV4_TUNNELED
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 header index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_IPV6
return|;
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_GEN_IPV6_TUNNELED
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 header index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
return|return
name|KG_SCH_GEN_GRE
return|;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
return|return
name|KG_SCH_GEN_TCP
return|;
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
return|return
name|KG_SCH_GEN_UDP
return|;
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
return|return
name|KG_SCH_GEN_IPSEC_AH
return|;
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
return|return
name|KG_SCH_GEN_IPSEC_ESP
return|;
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
return|return
name|KG_SCH_GEN_SCTP
return|;
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
return|return
name|KG_SCH_GEN_DCCP
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
return|return
name|KG_SCH_GEN_ETH_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
return|return
name|KG_SCH_GEN_SNAP_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
return|return
name|KG_SCH_GEN_PPP_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_MPLS1_NO_V
return|;
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|KG_SCH_GEN_MPLS_LAST_NO_V
return|;
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_3
operator|)
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Indexed MPLS Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
else|else
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal MPLS header index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_L3_NO_V
return|;
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_GEN_IP2_NO_V
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IP header index"
operator|)
argument_list|)
expr_stmt|;
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
return|return
name|KG_SCH_GEN_IP2_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_L3
operator|)
case|:
return|return
name|KG_SCH_GEN_L3_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
return|return
name|KG_SCH_GEN_GRE_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
return|return
name|KG_SCH_GEN_L4_NO_V
return|;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM1
operator|)
case|:
return|return
name|KG_SCH_GEN_SHIM1
return|;
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_SHIM2
operator|)
case|:
return|return
name|KG_SCH_GEN_SHIM2
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_GenericCodes
name|GetGenFieldCode
parameter_list|(
name|e_NetHeaderType
name|hdr
parameter_list|,
name|t_FmPcdFields
name|field
parameter_list|,
name|bool
name|ignoreProtocolValidation
parameter_list|,
name|e_FmPcdHdrIndex
name|hdrIndex
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ignoreProtocolValidation
condition|)
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
return|return
name|KG_SCH_GEN_ETH_TYPE
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_VLAN1
return|;
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|KG_SCH_GEN_VLAN2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal VLAN header index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_L3
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_L4
operator|)
case|:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
break|break;
block|}
else|else
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
return|return
name|KG_SCH_GEN_ETH_TYPE_NO_V
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_GEN_VLAN1_NO_V
return|;
if|if
condition|(
name|hdrIndex
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|KG_SCH_GEN_VLAN2_NO_V
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal VLAN header index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv4
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_PROTO
operator|)
case|:
return|return
name|KG_SCH_GEN_IP_PID_NO_V
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv6
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_NEXT_HDR
operator|)
case|:
return|return
name|KG_SCH_GEN_IP_PID_NO_V
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_L3
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
case|case
operator|(
name|HEADER_TYPE_USER_DEFINED_L4
operator|)
case|:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Header not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|t_KnownFieldsMasks
name|GetKnownProtMask
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|e_NetHeaderType
name|hdr
parameter_list|,
name|e_FmPcdHdrIndex
name|index
parameter_list|,
name|t_FmPcdFields
name|field
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
condition|)
block|{
case|case
operator|(
name|HEADER_TYPE_NONE
operator|)
case|:
name|ASSERT_COND
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|HEADER_TYPE_ETH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|eth
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_ETH_DA
operator|)
case|:
return|return
name|KG_SCH_KN_MACDST
return|;
case|case
operator|(
name|NET_HEADER_FIELD_ETH_SA
operator|)
case|:
return|return
name|KG_SCH_KN_MACSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_ETH_TYPE
operator|)
case|:
return|return
name|KG_SCH_KN_ETYPE
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_LLC_SNAP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|llcSnap
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_LLC_SNAP_TYPE
operator|)
case|:
return|return
name|KG_SCH_KN_ETYPE
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_VLAN
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|vlan
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_VLAN_TCI
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_TCI1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|KG_SCH_KN_TCI2
return|;
else|else
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_MPLS
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|mpls
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_MPLS_LABEL_STACK
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_MPLS1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|KG_SCH_KN_MPLS2
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
return|return
name|KG_SCH_KN_MPLS_LAST
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal MPLS index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IPv4
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv4
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_SRC_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPSRC1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPSRC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_DST_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPDST1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPDST2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_PROTO
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_PTYPE1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_PTYPE2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv4_TOS
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPTOS_TC1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPTOS_TC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv4 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IPv6
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipv6
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_SRC_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPSRC1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPSRC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_DST_IP
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPDST1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPDST2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_NEXT_HDR
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_PTYPE1
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
condition|)
return|return
name|KG_SCH_KN_PTYPE2
return|;
if|if
condition|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
condition|)
ifdef|#
directive|ifdef
name|FM_KG_NO_IPPID_SUPPORT
if|if
condition|(
name|p_FmPcd
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
condition|)
return|return
name|KG_SCH_KN_PTYPE2
return|;
endif|#
directive|endif
comment|/* FM_KG_NO_IPPID_SUPPORT */
return|return
name|KG_SCH_KN_IPPID
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_VER
operator||
name|NET_HEADER_FIELD_IPv6_FL
operator||
name|NET_HEADER_FIELD_IPv6_TC
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
operator|(
name|KG_SCH_KN_IPV6FL1
operator||
name|KG_SCH_KN_IPTOS_TC1
operator|)
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
operator|(
name|KG_SCH_KN_IPV6FL2
operator||
name|KG_SCH_KN_IPTOS_TC2
operator|)
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_VER
operator||
name|NET_HEADER_FIELD_IPv6_TC
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPTOS_TC1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPTOS_TC2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPv6_FL
operator|)
case|:
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_NONE
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_1
operator|)
condition|)
return|return
name|KG_SCH_KN_IPV6FL1
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_2
operator|)
operator|||
operator|(
name|index
operator|==
name|e_FM_PCD_HDR_INDEX_LAST
operator|)
condition|)
return|return
name|KG_SCH_KN_IPV6FL2
return|;
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal IPv6 index"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_GRE
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|gre
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_GRE_TYPE
operator|)
case|:
return|return
name|KG_SCH_KN_GREPTYPE
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_MINENCAP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|minencap
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_SRC_IP
operator|)
case|:
return|return
name|KG_SCH_KN_IPSRC2
return|;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_DST_IP
operator|)
case|:
return|return
name|KG_SCH_KN_IPDST2
return|;
case|case
operator|(
name|NET_HEADER_FIELD_MINENCAP_TYPE
operator|)
case|:
return|return
name|KG_SCH_KN_PTYPE2
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_TCP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|tcp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_SRC
operator|)
case|:
return|return
name|KG_SCH_KN_L4PSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_TCP_PORT_DST
operator|)
case|:
return|return
name|KG_SCH_KN_L4PDST
return|;
case|case
operator|(
name|NET_HEADER_FIELD_TCP_FLAGS
operator|)
case|:
return|return
name|KG_SCH_KN_TFLG
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_UDP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|udp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_SRC
operator|)
case|:
return|return
name|KG_SCH_KN_L4PSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_PORT_DST
operator|)
case|:
return|return
name|KG_SCH_KN_L4PDST
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IPSEC_AH
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipsecAh
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPSEC_AH_SPI
operator|)
case|:
return|return
name|KG_SCH_KN_IPSEC_SPI
return|;
case|case
operator|(
name|NET_HEADER_FIELD_IPSEC_AH_NH
operator|)
case|:
return|return
name|KG_SCH_KN_IPSEC_NH
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_IPSEC_ESP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|ipsecEsp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_IPSEC_ESP_SPI
operator|)
case|:
return|return
name|KG_SCH_KN_IPSEC_SPI
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_SCTP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|sctp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_SCTP_PORT_SRC
operator|)
case|:
return|return
name|KG_SCH_KN_L4PSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_SCTP_PORT_DST
operator|)
case|:
return|return
name|KG_SCH_KN_L4PDST
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_DCCP
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|dccp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_DCCP_PORT_SRC
operator|)
case|:
return|return
name|KG_SCH_KN_L4PSRC
return|;
case|case
operator|(
name|NET_HEADER_FIELD_DCCP_PORT_DST
operator|)
case|:
return|return
name|KG_SCH_KN_L4PDST
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
operator|(
name|HEADER_TYPE_PPPoE
operator|)
case|:
switch|switch
condition|(
name|field
operator|.
name|pppoe
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_PPPoE_PID
operator|)
case|:
return|return
name|KG_SCH_KN_PPPID
return|;
case|case
operator|(
name|NET_HEADER_FIELD_PPPoE_SID
operator|)
case|:
return|return
name|KG_SCH_KN_PPPSID
return|;
default|default:
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Extraction not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetKnownFieldId
parameter_list|(
name|uint32_t
name|bitMask
parameter_list|)
block|{
name|uint8_t
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bitMask
condition|)
if|if
condition|(
name|bitMask
operator|&
literal|0x80000000
condition|)
break|break;
else|else
block|{
name|cnt
operator|++
expr_stmt|;
name|bitMask
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|GetExtractedOrMask
parameter_list|(
name|uint8_t
name|bitOffset
parameter_list|,
name|bool
name|fqid
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|,
name|mask
decl_stmt|,
name|numOfOnesToClear
decl_stmt|,
name|walking1Mask
init|=
literal|1
decl_stmt|;
comment|/* bitOffset 1-7 --> mask 0x1-0x7F */
if|if
condition|(
name|bitOffset
operator|<
literal|8
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bitOffset
condition|;
name|i
operator|++
operator|,
name|walking1Mask
operator|<<=
literal|1
control|)
name|mask
operator||=
name|walking1Mask
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
literal|0xFF
expr_stmt|;
name|numOfOnesToClear
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fqid
operator|&&
name|bitOffset
operator|>
literal|24
condition|)
comment|/* bitOffset 25-31 --> mask 0xFE-0x80 */
name|numOfOnesToClear
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bitOffset
operator|-
literal|24
argument_list|)
expr_stmt|;
elseif|else
comment|/* bitOffset 9-15 --> mask 0xFE-0x80 */
if|if
condition|(
operator|!
name|fqid
operator|&&
name|bitOffset
operator|>
literal|8
condition|)
name|numOfOnesToClear
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bitOffset
operator|-
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfOnesToClear
condition|;
name|i
operator|++
operator|,
name|walking1Mask
operator|<<=
literal|1
control|)
name|mask
operator|&=
operator|~
name|walking1Mask
expr_stmt|;
comment|/* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|IncSchemeOwners
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_BindPort
parameter_list|)
block|{
name|t_FmPcdKg
modifier|*
name|p_FmPcdKg
decl_stmt|;
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p_FmPcdKg
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
expr_stmt|;
comment|/* for each scheme - update owners counters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_BindPort
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|p_BindPort
operator|->
name|schemesIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|relativeSchemeId
operator|<
name|FM_PCD_KG_NUM_OF_SCHEMES
argument_list|)
expr_stmt|;
name|p_Scheme
operator|=
operator|&
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
expr_stmt|;
comment|/* increment owners number */
name|intFlags
operator|=
name|KgSchemeLock
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|owners
operator|++
expr_stmt|;
name|KgSchemeUnlock
argument_list|(
name|p_Scheme
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|DecSchemeOwners
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_BindPort
parameter_list|)
block|{
name|t_FmPcdKg
modifier|*
name|p_FmPcdKg
decl_stmt|;
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p_FmPcdKg
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
expr_stmt|;
comment|/* for each scheme - update owners counters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_BindPort
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|p_BindPort
operator|->
name|schemesIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|relativeSchemeId
operator|<
name|FM_PCD_KG_NUM_OF_SCHEMES
argument_list|)
expr_stmt|;
name|p_Scheme
operator|=
operator|&
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
expr_stmt|;
comment|/* increment owners number */
name|ASSERT_COND
argument_list|(
name|p_Scheme
operator|->
name|owners
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgSchemeLock
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|owners
operator|--
expr_stmt|;
name|KgSchemeUnlock
argument_list|(
name|p_Scheme
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|UpdateRequiredActionFlag
parameter_list|(
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
parameter_list|,
name|bool
name|set
parameter_list|)
block|{
comment|/* this routine is locked by the calling routine */
name|ASSERT_COND
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|p_Scheme
operator|->
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|p_Scheme
operator|->
name|requiredActionFlag
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|p_Scheme
operator|->
name|requiredAction
operator|=
literal|0
expr_stmt|;
name|p_Scheme
operator|->
name|requiredActionFlag
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|KgWriteSp
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint32_t
name|spReg
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|struct
name|fman_kg_regs
modifier|*
name|p_KgRegs
decl_stmt|;
name|uint32_t
name|tmpKgarReg
init|=
literal|0
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
comment|/* The calling routine had locked the port, so for each port only one core can access      * (so we don't need a lock here) */
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
return|return
name|FmHcKgWriteSp
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|hardwarePortId
argument_list|,
name|spReg
argument_list|,
name|add
argument_list|)
return|;
name|p_KgRegs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
expr_stmt|;
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadPortSchemeBindActionReg
argument_list|(
name|hardwarePortId
argument_list|)
expr_stmt|;
comment|/* lock a common KG reg */
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|err
operator|=
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|fman_kg_write_sp
argument_list|(
name|p_KgRegs
argument_list|,
name|spReg
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWritePortSchemeBindActionReg
argument_list|(
name|hardwarePortId
argument_list|)
expr_stmt|;
name|err
operator|=
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|KgWriteCpp
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint32_t
name|cppReg
parameter_list|)
block|{
name|struct
name|fman_kg_regs
modifier|*
name|p_KgRegs
decl_stmt|;
name|uint32_t
name|tmpKgarReg
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|p_KgRegs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcKgWriteCpp
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|hardwarePortId
argument_list|,
name|cppReg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|fman_kg_write_cpp
argument_list|(
name|p_KgRegs
argument_list|,
name|cppReg
argument_list|)
expr_stmt|;
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWritePortClsPlanBindActionReg
argument_list|(
name|hardwarePortId
argument_list|)
expr_stmt|;
name|err
operator|=
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|BuildCppReg
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|clsPlanGrpId
parameter_list|)
block|{
name|uint32_t
name|tmpKgpeCpp
decl_stmt|;
name|tmpKgpeCpp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrpId
index|]
operator|.
name|baseEntry
operator|/
literal|8
argument_list|)
expr_stmt|;
name|tmpKgpeCpp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrpId
index|]
operator|.
name|sizeOfGrp
operator|/
literal|8
operator|)
operator|-
literal|1
operator|)
operator|<<
name|FM_KG_PE_CPP_MASK_SHIFT
argument_list|)
expr_stmt|;
return|return
name|tmpKgpeCpp
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BindPortToClsPlanGrp
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint8_t
name|clsPlanGrpId
parameter_list|)
block|{
name|uint32_t
name|tmpKgpeCpp
init|=
literal|0
decl_stmt|;
name|tmpKgpeCpp
operator|=
name|BuildCppReg
argument_list|(
name|p_FmPcd
argument_list|,
name|clsPlanGrpId
argument_list|)
expr_stmt|;
return|return
name|KgWriteCpp
argument_list|(
name|p_FmPcd
argument_list|,
name|hardwarePortId
argument_list|,
name|tmpKgpeCpp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|UnbindPortToClsPlanGrp
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
name|KgWriteCpp
argument_list|(
name|p_FmPcd
argument_list|,
name|hardwarePortId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ERRORS
argument_list|)
operator|&&
operator|(
name|DEBUG_ERRORS
operator|>
literal|0
operator|)
operator|)
end_if

begin_decl_stmt
specifier|static
name|uint32_t
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
name|ReadClsPlanBlockActionReg
argument_list|(
name|uint8_t
name|grpId
argument_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_READ
operator||
name|FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY
operator||
name|DUMMY_PORT_ID
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|grpId
operator|<<
name|FM_PCD_KG_KGAR_NUM_SHIFT
operator|)
operator||
name|FM_PCD_KG_KGAR_WSEL_MASK
argument_list|)
return|;
comment|/* if we ever want to write 1 by 1, use:        sel = (uint8_t)(0x01<< (7- (entryId % CLS_PLAN_NUM_PER_GRP)));      */
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(DEBUG_ERRORS)&& ... */
end_comment

begin_function
specifier|static
name|void
name|PcdKgErrorException
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|event
decl_stmt|,
name|schemeIndexes
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|struct
name|fman_kg_regs
modifier|*
name|p_KgRegs
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|p_KgRegs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
expr_stmt|;
name|fman_kg_get_event
argument_list|(
name|p_KgRegs
argument_list|,
operator|&
name|event
argument_list|,
operator|&
name|schemeIndexes
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|FM_EX_KG_DOUBLE_ECC
condition|)
name|p_FmPcd
operator|->
name|f_Exception
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|FM_EX_KG_KEYSIZE_OVERFLOW
condition|)
block|{
if|if
condition|(
name|schemeIndexes
condition|)
block|{
while|while
condition|(
name|schemeIndexes
condition|)
block|{
if|if
condition|(
name|schemeIndexes
operator|&
literal|0x1
condition|)
name|p_FmPcd
operator|->
name|f_FmPcdIndexedException
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
literal|31
operator|-
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|schemeIndexes
operator|>>=
literal|1
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* this should happen only when interrupt is forced. */
name|p_FmPcd
operator|->
name|f_Exception
argument_list|(
name|p_FmPcd
operator|->
name|h_App
argument_list|,
name|e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|t_Error
name|KgInitGuest
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcKgSchemesParams
name|kgAlloc
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|guestId
operator|!=
name|NCSW_MASTER_ID
argument_list|)
expr_stmt|;
comment|/* in GUEST_PARTITION, we use the IPC  */
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|kgAlloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdIpcKgSchemesParams
argument_list|)
argument_list|)
expr_stmt|;
name|kgAlloc
operator|.
name|numOfSchemes
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
expr_stmt|;
name|kgAlloc
operator|.
name|guestId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_ALLOC_KG_SCHEMES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|kgAlloc
argument_list|,
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesIds
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|reply
operator|.
name|replyBody
operator|)
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|t_Error
operator|)
name|reply
operator|.
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|KgInitMaster
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|struct
name|fman_kg_regs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|exceptions
operator|&
name|FM_EX_KG_DOUBLE_ECC
condition|)
name|FmEnableRamsEcc
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
expr_stmt|;
name|fman_kg_init
argument_list|(
name|p_Regs
argument_list|,
name|p_FmPcd
operator|->
name|exceptions
argument_list|,
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* register even if no interrupts enabled, to allow future enablement */
name|FmRegisterIntr
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_KG
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|,
name|PcdKgErrorException
argument_list|,
name|p_FmPcd
argument_list|)
expr_stmt|;
name|fman_kg_enable_scheme_interrupts
argument_list|(
name|p_Regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
condition|)
block|{
name|err
operator|=
name|FmPcdKgAllocSchemes
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesIds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ValidateSchemeSw
parameter_list|(
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
parameter_list|)
block|{
name|ASSERT_COND
argument_list|(
operator|!
name|p_Scheme
operator|->
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Scheme
operator|->
name|netEnvId
operator|!=
name|ILLEGAL_NETENV
condition|)
name|FmPcdIncNetEnvOwners
argument_list|(
name|p_Scheme
operator|->
name|h_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|InvalidateSchemeSw
parameter_list|(
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
parameter_list|)
block|{
if|if
condition|(
name|p_Scheme
operator|->
name|owners
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to delete a scheme that has ports bound to"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Scheme
operator|->
name|netEnvId
operator|!=
name|ILLEGAL_NETENV
condition|)
name|FmPcdDecNetEnvOwners
argument_list|(
name|p_Scheme
operator|->
name|h_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
specifier|static
name|t_Error
name|BuildSchemeRegs
parameter_list|(
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
parameter_list|,
name|t_FmPcdKgSchemeParams
modifier|*
name|p_SchemeParams
parameter_list|,
name|struct
name|fman_kg_scheme_regs
modifier|*
name|p_SchemeRegs
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_Scheme
operator|->
name|h_FmPcd
operator|)
decl_stmt|;
name|uint32_t
name|grpBits
init|=
literal|0
decl_stmt|;
name|uint8_t
name|grpBase
decl_stmt|;
name|bool
name|direct
init|=
name|TRUE
decl_stmt|,
name|absolute
init|=
name|FALSE
decl_stmt|;
name|uint16_t
name|profileId
init|=
literal|0
decl_stmt|,
name|numOfProfiles
init|=
literal|0
decl_stmt|,
name|relativeProfileId
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|t_NetEnvParams
name|netEnvParams
decl_stmt|;
name|uint32_t
name|tmpReg
decl_stmt|,
name|fqbTmp
init|=
literal|0
decl_stmt|,
name|ppcTmp
init|=
literal|0
decl_stmt|,
name|selectTmp
decl_stmt|,
name|maskTmp
decl_stmt|,
name|knownTmp
decl_stmt|,
name|genTmp
decl_stmt|;
name|t_FmPcdKgKeyExtractAndHashParams
modifier|*
name|p_KeyAndHash
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|j
decl_stmt|,
name|curr
decl_stmt|,
name|idx
decl_stmt|;
name|uint8_t
name|id
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|,
name|code
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|t_FmPcdExtractEntry
modifier|*
name|p_Extract
init|=
name|NULL
decl_stmt|;
name|t_FmPcdKgExtractedOrParams
modifier|*
name|p_ExtractOr
decl_stmt|;
name|bool
name|generic
init|=
name|FALSE
decl_stmt|;
name|t_KnownFieldsMasks
name|bitMask
decl_stmt|;
name|e_FmPcdKgExtractDfltSelect
name|swDefault
init|=
operator|(
name|e_FmPcdKgExtractDfltSelect
operator|)
literal|0
decl_stmt|;
name|t_FmPcdKgSchemesExtracts
modifier|*
name|p_LocalExtractsArray
decl_stmt|;
name|uint8_t
name|numOfSwDefaults
init|=
literal|0
decl_stmt|;
name|t_FmPcdKgExtractDflt
name|swDefaults
index|[
name|NUM_OF_SW_DEFAULTS
index|]
decl_stmt|;
name|uint8_t
name|currGenId
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|swDefaults
argument_list|,
literal|0
argument_list|,
name|NUM_OF_SW_DEFAULTS
operator|*
sizeof|sizeof
argument_list|(
name|t_FmPcdKgExtractDflt
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_SchemeRegs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fman_kg_scheme_regs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|numOfDistinctionUnits
operator|>
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfDistinctionUnits should not exceed %d"
operator|,
name|FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS
operator|)
argument_list|)
expr_stmt|;
comment|/* by netEnv parameters, get match vector */
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|alwaysDirect
condition|)
block|{
name|p_Scheme
operator|->
name|netEnvId
operator|=
name|FmPcdGetNetEnvId
argument_list|(
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|h_NetEnv
argument_list|)
expr_stmt|;
name|netEnvParams
operator|.
name|netEnvId
operator|=
name|p_Scheme
operator|->
name|netEnvId
expr_stmt|;
name|netEnvParams
operator|.
name|numOfDistinctionUnits
operator|=
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|numOfDistinctionUnits
expr_stmt|;
name|memcpy
argument_list|(
name|netEnvParams
operator|.
name|unitIds
argument_list|,
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|unitIds
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
operator|*
name|p_SchemeParams
operator|->
name|netEnvParams
operator|.
name|numOfDistinctionUnits
argument_list|)
expr_stmt|;
name|err
operator|=
name|PcdGetUnitsVector
argument_list|(
name|p_FmPcd
argument_list|,
operator|&
name|netEnvParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|matchVector
operator|=
name|netEnvParams
operator|.
name|vector
expr_stmt|;
block|}
else|else
block|{
name|p_Scheme
operator|->
name|matchVector
operator|=
name|SCHEME_ALWAYS_DIRECT
expr_stmt|;
name|p_Scheme
operator|->
name|netEnvId
operator|=
name|ILLEGAL_NETENV
expr_stmt|;
block|}
if|if
condition|(
name|p_SchemeParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_INVALID
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Next Engine of the scheme is not Valid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
condition|)
block|{
ifdef|#
directive|ifdef
name|FM_KG_NO_BYPASS_FQID_GEN
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"bypassFqidGeneration."
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FM_KG_NO_BYPASS_FQID_GEN */
if|if
condition|(
name|p_SchemeParams
operator|->
name|baseFqid
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"baseFqid set for a scheme that does not generate an FQID"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|baseFqid
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"baseFqid is 0."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_PLCR
condition|)
block|{
name|direct
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|direct
expr_stmt|;
name|p_Scheme
operator|->
name|directPlcr
operator|=
name|direct
expr_stmt|;
name|absolute
operator|=
call|(
name|bool
call|)
argument_list|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|sharedProfile
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|direct
operator|&&
name|absolute
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Indirect policing is not available when profile is shared."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct
condition|)
block|{
name|profileId
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|directRelativeProfileId
expr_stmt|;
name|numOfProfiles
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|profileId
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|fqidOffsetRelativeProfileIdBase
expr_stmt|;
name|shift
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|fqidOffsetShift
expr_stmt|;
name|numOfProfiles
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|numOfProfiles
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_SchemeParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
ifdef|#
directive|ifdef
name|FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
if|if
condition|(
operator|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrNext
operator|)
operator|&&
operator|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|bypassPlcrProfileGeneration
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|p_FmPcd
operator|->
name|fmRevInfo
operator|.
name|majorRev
operator|<
literal|6
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"bypassPlcrProfileGeneration."
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FM_KG_NO_BYPASS_PLCR_PROFILE_GEN */
name|err
operator|=
name|FmPcdCcGetGrpParams
argument_list|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|h_CcTree
argument_list|,
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|grpId
argument_list|,
operator|&
name|grpBits
argument_list|,
operator|&
name|grpBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|ccUnits
operator|=
name|grpBits
expr_stmt|;
if|if
condition|(
operator|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrNext
operator|)
operator|&&
operator|(
operator|!
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|bypassPlcrProfileGeneration
operator|)
condition|)
block|{
if|if
condition|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrProfile
operator|.
name|sharedProfile
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Shared profile may not be used after Coarse classification."
operator|)
argument_list|)
expr_stmt|;
name|absolute
operator|=
name|FALSE
expr_stmt|;
name|direct
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrProfile
operator|.
name|direct
expr_stmt|;
if|if
condition|(
name|direct
condition|)
block|{
name|profileId
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|directRelativeProfileId
expr_stmt|;
name|numOfProfiles
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|profileId
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|fqidOffsetRelativeProfileIdBase
expr_stmt|;
name|shift
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|fqidOffsetShift
expr_stmt|;
name|numOfProfiles
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|numOfProfiles
expr_stmt|;
block|}
block|}
block|}
comment|/* if policer is used directly after KG, or after CC */
if|if
condition|(
operator|(
name|p_SchemeParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_PLCR
operator|)
operator|||
operator|(
operator|(
name|p_SchemeParams
operator|->
name|nextEngine
operator|==
name|e_FM_PCD_CC
operator|)
operator|&&
operator|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrNext
operator|)
operator|&&
operator|(
operator|!
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|bypassPlcrProfileGeneration
operator|)
operator|)
condition|)
block|{
comment|/* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
if|if
condition|(
name|absolute
condition|)
block|{
comment|/* for absolute direct policy only, */
name|relativeProfileId
operator|=
name|profileId
expr_stmt|;
name|err
operator|=
name|FmPcdPlcrGetAbsoluteIdByProfileParams
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_FmPcd
argument_list|,
name|e_FM_PCD_PLCR_SHARED
argument_list|,
name|NULL
argument_list|,
name|relativeProfileId
argument_list|,
operator|&
name|profileId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
operator|(
literal|"Shared profile not valid offset"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPcd
argument_list|,
name|profileId
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Shared profile not valid."
operator|)
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|relativeProfileId
operator|=
name|profileId
expr_stmt|;
block|}
else|else
block|{
comment|/* save relative profile id's for later check */
name|p_Scheme
operator|->
name|nextRelativePlcrProfile
operator|=
name|TRUE
expr_stmt|;
name|p_Scheme
operator|->
name|relativeProfileId
operator|=
name|profileId
expr_stmt|;
name|p_Scheme
operator|->
name|numOfProfiles
operator|=
name|numOfProfiles
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if policer is NOT going to be used after KG at all than if bypassFqidGeneration         is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
if|if
condition|(
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
operator|&&
name|p_SchemeParams
operator|->
name|numOfUsedExtractedOrs
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
operator|&&
name|p_SchemeParams
operator|->
name|useHash
operator|&&
name|p_SchemeParams
operator|->
name|keyExtractAndHashParams
operator|.
name|hashDistributionNumOfFqids
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"hashDistributionNumOfFqids is set in a scheme that does not generate FQID or policer profile ID"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* configure all 21 scheme registers */
name|tmpReg
operator|=
name|KG_SCH_MODE_EN
expr_stmt|;
switch|switch
condition|(
name|p_SchemeParams
operator|->
name|nextEngine
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_PLCR
operator|)
case|:
comment|/* add to mode register - NIA */
name|tmpReg
operator||=
name|KG_SCH_MODE_NIA_PLCR
expr_stmt|;
name|tmpReg
operator||=
name|NIA_ENG_PLCR
expr_stmt|;
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|plcrProfile
operator|.
name|sharedProfile
condition|?
name|NIA_PLCR_ABSOLUTE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize policer profile command - */
comment|/*  configure kgse_ppc  */
if|if
condition|(
name|direct
condition|)
comment|/* use profileId as base, other fields are 0 */
name|p_SchemeRegs
operator|->
name|kgse_ppc
operator|=
operator|(
name|uint32_t
operator|)
name|profileId
expr_stmt|;
else|else
block|{
if|if
condition|(
name|shift
operator|>
name|MAX_PP_SHIFT
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fqidOffsetShift may not be larger than %d"
operator|,
name|MAX_PP_SHIFT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numOfProfiles
operator|||
operator|!
name|POWER_OF_2
argument_list|(
name|numOfProfiles
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfProfiles must not be 0 and must be a power of 2"
operator|)
argument_list|)
expr_stmt|;
name|ppcTmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|shift
operator|<<
name|KG_SCH_PP_SHIFT_HIGH_SHIFT
operator|)
operator|&
name|KG_SCH_PP_SHIFT_HIGH
expr_stmt|;
name|ppcTmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|shift
operator|<<
name|KG_SCH_PP_SHIFT_LOW_SHIFT
operator|)
operator|&
name|KG_SCH_PP_SHIFT_LOW
expr_stmt|;
name|ppcTmp
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|numOfProfiles
operator|-
literal|1
argument_list|)
operator|<<
name|KG_SCH_PP_MASK_SHIFT
operator|)
expr_stmt|;
name|ppcTmp
operator||=
operator|(
name|uint32_t
operator|)
name|profileId
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_ppc
operator|=
name|ppcTmp
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_CC
operator|)
case|:
comment|/* mode reg - define NIA */
name|tmpReg
operator||=
operator|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_CC
operator|)
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_ccbs
operator|=
name|grpBits
expr_stmt|;
name|tmpReg
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|grpBase
operator|<<
name|KG_SCH_MODE_CCOBASE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|plcrNext
condition|)
block|{
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|cc
operator|.
name|bypassPlcrProfileGeneration
condition|)
block|{
comment|/* find out if absolute or relative */
if|if
condition|(
name|absolute
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct
condition|)
block|{
comment|/* mask = 0, base = directProfileId */
name|p_SchemeRegs
operator|->
name|kgse_ppc
operator|=
operator|(
name|uint32_t
operator|)
name|profileId
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|shift
operator|>
name|MAX_PP_SHIFT
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fqidOffsetShift may not be larger than %d"
operator|,
name|MAX_PP_SHIFT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numOfProfiles
operator|||
operator|!
name|POWER_OF_2
argument_list|(
name|numOfProfiles
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfProfiles must not be 0 and must be a power of 2"
operator|)
argument_list|)
expr_stmt|;
name|ppcTmp
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|shift
operator|<<
name|KG_SCH_PP_SHIFT_HIGH_SHIFT
operator|)
operator|&
name|KG_SCH_PP_SHIFT_HIGH
expr_stmt|;
name|ppcTmp
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|shift
operator|<<
name|KG_SCH_PP_SHIFT_LOW_SHIFT
operator|)
operator|&
name|KG_SCH_PP_SHIFT_LOW
expr_stmt|;
name|ppcTmp
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|numOfProfiles
operator|-
literal|1
argument_list|)
operator|<<
name|KG_SCH_PP_MASK_SHIFT
operator|)
expr_stmt|;
name|ppcTmp
operator||=
operator|(
name|uint32_t
operator|)
name|profileId
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_ppc
operator|=
name|ppcTmp
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_DONE
operator|)
case|:
if|if
condition|(
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|doneAction
operator|==
name|e_FM_PCD_DROP_FRAME
condition|)
name|tmpReg
operator||=
name|GET_NIA_BMI_AC_DISCARD_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
else|else
name|tmpReg
operator||=
name|GET_NIA_BMI_AC_ENQ_FRAME
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Next engine not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_SchemeRegs
operator|->
name|kgse_mode
operator|=
name|tmpReg
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_mv
operator|=
name|p_Scheme
operator|->
name|matchVector
expr_stmt|;
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
if|if
condition|(
name|p_SchemeParams
operator|->
name|overrideStorageProfile
condition|)
block|{
name|p_SchemeRegs
operator|->
name|kgse_om
operator||=
name|KG_SCH_OM_VSPE
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|storageProfile
operator|.
name|direct
condition|)
block|{
name|profileId
operator|=
name|p_SchemeParams
operator|->
name|storageProfile
operator|.
name|profileSelect
operator|.
name|directRelativeProfileId
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|numOfProfiles
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|profileId
operator|=
name|p_SchemeParams
operator|->
name|storageProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|fqidOffsetRelativeProfileIdBase
expr_stmt|;
name|shift
operator|=
name|p_SchemeParams
operator|->
name|storageProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|fqidOffsetShift
expr_stmt|;
name|numOfProfiles
operator|=
name|p_SchemeParams
operator|->
name|storageProfile
operator|.
name|profileSelect
operator|.
name|indirectProfile
operator|.
name|numOfProfiles
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|>
name|MAX_SP_SHIFT
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"fqidOffsetShift may not be larger than %d"
operator|,
name|MAX_SP_SHIFT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|numOfProfiles
operator|||
operator|!
name|POWER_OF_2
argument_list|(
name|numOfProfiles
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfProfiles must not be 0 and must be a power of 2"
operator|)
argument_list|)
expr_stmt|;
name|tmpReg
operator|=
operator|(
name|uint32_t
operator|)
name|shift
operator|<<
name|KG_SCH_VSP_SHIFT
expr_stmt|;
name|tmpReg
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|numOfProfiles
operator|-
literal|1
argument_list|)
operator|<<
name|KG_SCH_VSP_MASK_SHIFT
operator|)
expr_stmt|;
name|tmpReg
operator||=
operator|(
name|uint32_t
operator|)
name|profileId
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_vsp
operator|=
name|tmpReg
expr_stmt|;
name|p_Scheme
operator|->
name|vspe
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|p_SchemeRegs
operator|->
name|kgse_vsp
operator|=
name|KG_SCH_VSP_NO_KSP_EN
expr_stmt|;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) */
if|if
condition|(
name|p_SchemeParams
operator|->
name|useHash
condition|)
block|{
name|p_KeyAndHash
operator|=
operator|&
name|p_SchemeParams
operator|->
name|keyExtractAndHashParams
expr_stmt|;
if|if
condition|(
name|p_KeyAndHash
operator|->
name|numOfUsedExtracts
operator|>=
name|FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfUsedExtracts out of range"
operator|)
argument_list|)
expr_stmt|;
comment|/*  configure kgse_dv0  */
name|p_SchemeRegs
operator|->
name|kgse_dv0
operator|=
name|p_KeyAndHash
operator|->
name|privateDflt0
expr_stmt|;
comment|/*  configure kgse_dv1  */
name|p_SchemeRegs
operator|->
name|kgse_dv1
operator|=
name|p_KeyAndHash
operator|->
name|privateDflt1
expr_stmt|;
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
condition|)
block|{
if|if
condition|(
operator|!
name|p_KeyAndHash
operator|->
name|hashDistributionNumOfFqids
operator|||
operator|!
name|POWER_OF_2
argument_list|(
name|p_KeyAndHash
operator|->
name|hashDistributionNumOfFqids
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"hashDistributionNumOfFqids must not be 0 and must be a power of 2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_KeyAndHash
operator|->
name|hashDistributionNumOfFqids
operator|-
literal|1
operator|)
operator|&
name|p_SchemeParams
operator|->
name|baseFqid
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  configure kgse_ekdv  */
name|tmpReg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_KeyAndHash
operator|->
name|numOfUsedDflts
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_MAC_ADDR
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_MAC_ADDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_TCI
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_TCI_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_ENET_TYPE
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_ENET_TYPE_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_PPP_SESSION_ID
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_PPP_SESSION_ID_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_PPP_PROTOCOL_ID
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_MPLS_LABEL
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_MPLS_LABEL_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_IP_ADDR
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_IP_ADDR_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_PROTOCOL_TYPE
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_PROTOCOL_TYPE_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_IP_TOS_TC
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_IP_TOS_TC_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_IPV6_FLOW_LABEL
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_L4_PORT_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_IPSEC_SPI
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_IPSEC_SPI_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_L4_PORT
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_L4_PORT_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_TCP_FLAG
operator|)
case|:
name|tmpReg
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
operator|<<
name|KG_SCH_DEF_TCP_FLAG_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_GENERIC_FROM_DATA
operator|)
case|:
name|swDefaults
index|[
name|numOfSwDefaults
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_KG_GENERIC_FROM_DATA
expr_stmt|;
name|swDefaults
index|[
name|numOfSwDefaults
index|]
operator|.
name|dfltSelect
operator|=
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
expr_stmt|;
name|numOfSwDefaults
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V
operator|)
case|:
name|swDefaults
index|[
name|numOfSwDefaults
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V
expr_stmt|;
name|swDefaults
index|[
name|numOfSwDefaults
index|]
operator|.
name|dfltSelect
operator|=
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
expr_stmt|;
name|numOfSwDefaults
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_KG_GENERIC_NOT_FROM_DATA
operator|)
case|:
name|swDefaults
index|[
name|numOfSwDefaults
index|]
operator|.
name|type
operator|=
name|e_FM_PCD_KG_GENERIC_NOT_FROM_DATA
expr_stmt|;
name|swDefaults
index|[
name|numOfSwDefaults
index|]
operator|.
name|dfltSelect
operator|=
name|p_KeyAndHash
operator|->
name|dflts
index|[
name|i
index|]
operator|.
name|dfltSelect
expr_stmt|;
name|numOfSwDefaults
operator|++
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
name|p_SchemeRegs
operator|->
name|kgse_ekdv
operator|=
name|tmpReg
expr_stmt|;
name|p_LocalExtractsArray
operator|=
operator|(
name|t_FmPcdKgSchemesExtracts
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdKgSchemesExtracts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_LocalExtractsArray
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"No memory"
operator|)
argument_list|)
expr_stmt|;
comment|/*  configure kgse_ekfc and  kgse_gec */
name|knownTmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_KeyAndHash
operator|->
name|numOfUsedExtracts
condition|;
name|i
operator|++
control|)
block|{
name|p_Extract
operator|=
operator|&
name|p_KeyAndHash
operator|->
name|extractArray
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|p_Extract
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO
operator|)
case|:
name|knownTmp
operator||=
name|KG_SCH_KN_PORT_ID
expr_stmt|;
comment|/* save in driver structure */
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|id
operator|=
name|GetKnownFieldId
argument_list|(
name|KG_SCH_KN_PORT_ID
argument_list|)
expr_stmt|;
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|known
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_BY_HDR
operator|)
case|:
switch|switch
condition|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
condition|)
block|{
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
operator|||
operator|(
operator|(
name|DPAA_VERSION
operator|==
literal|10
operator|)
operator|&&
name|defined
argument_list|(
name|FM_CAPWAP_SUPPORT
argument_list|)
operator|)
case|case
operator|(
name|HEADER_TYPE_UDP_LITE
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* (DPAA_VERSION>= 11) || ((DPAA_VERSION == 10)&& defined(FM_CAPWAP_SUPPORT)) */
case|case
operator|(
name|HEADER_TYPE_UDP_ENCAP_ESP
operator|)
case|:
switch|switch
condition|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_HDR
operator|)
case|:
comment|/* case where extraction from ESP only */
if|if
condition|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
operator|>=
name|UDP_HEADER_SIZE
condition|)
block|{
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|FmPcdGetAliasHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
operator|-=
name|UDP_HEADER_SIZE
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_FIELD
operator|)
case|:
switch|switch
condition|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|field
operator|.
name|udpEncapEsp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FROM_HDR
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|FmPcdGetAliasHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
expr_stmt|;
comment|/*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FROM_HDR
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|FmPcdGetAliasHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|offset
operator|+=
name|ESP_SEQ_NUM_OFFSET
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FULL_FIELD
operator|)
case|:
switch|switch
condition|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
operator|.
name|udpEncapEsp
condition|)
block|{
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN
operator|)
case|:
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|HEADER_TYPE_UDP
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FROM_HDR
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|FmPcdGetAliasHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|size
operator|=
name|ESP_SPI_SIZE
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
operator|=
name|ESP_SPI_OFFSET
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
operator|(
name|NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM
operator|)
case|:
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|type
operator|=
name|e_FM_PCD_EXTRACT_FROM_HDR
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
operator|=
name|FmPcdGetAliasHdr
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|netEnvId
argument_list|,
name|HEADER_TYPE_UDP_ENCAP_ESP
argument_list|)
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|size
operator|=
name|ESP_SEQ_NUM_SIZE
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
operator|=
name|ESP_SEQ_NUM_OFFSET
expr_stmt|;
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_HDR
operator|)
case|:
name|generic
operator|=
name|TRUE
expr_stmt|;
comment|/* get the header code for the generic extract */
name|code
operator|=
name|GetGenHdrCode
argument_list|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdrIndex
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
argument_list|)
expr_stmt|;
comment|/* set generic register fields */
name|offset
operator|=
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|offset
expr_stmt|;
name|size
operator|=
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromHdr
operator|.
name|size
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FROM_FIELD
operator|)
case|:
name|generic
operator|=
name|TRUE
expr_stmt|;
comment|/* get the field code for the generic extract */
name|code
operator|=
name|GetGenFieldCode
argument_list|(
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|field
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdrIndex
argument_list|)
expr_stmt|;
name|offset
operator|=
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|offset
expr_stmt|;
name|size
operator|=
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fromField
operator|.
name|size
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_FULL_FIELD
operator|)
case|:
if|if
condition|(
operator|!
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
condition|)
block|{
comment|/* if we have a known field for it - use it, otherwise use generic */
name|bitMask
operator|=
name|GetKnownProtMask
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|hdrIndex
argument_list|,
name|p_Extract
operator|->
name|extractByHdr
operator|.
name|extractByHdrType
operator|.
name|fullField
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitMask
condition|)
block|{
name|knownTmp
operator||=
name|bitMask
expr_stmt|;
comment|/* save in driver structure */
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|id
operator|=
name|GetKnownFieldId
argument_list|(
name|bitMask
argument_list|)
expr_stmt|;
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|known
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|generic
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|generic
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|generic
condition|)
block|{
comment|/* tmp - till we cover more headers under generic */
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Full header selection not supported"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_NON_HDR
operator|)
case|:
comment|/* use generic */
name|generic
operator|=
name|TRUE
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* get the field code for the generic extract */
name|code
operator|=
name|GetGenCode
argument_list|(
name|p_Extract
operator|->
name|extractNonHdr
operator|.
name|src
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|p_Extract
operator|->
name|extractNonHdr
operator|.
name|offset
expr_stmt|;
name|size
operator|=
name|p_Extract
operator|->
name|extractNonHdr
operator|.
name|size
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|generic
condition|)
block|{
comment|/* set generic register fields */
if|if
condition|(
name|currGenId
operator|>=
name|FM_KG_NUM_OF_GENERIC_REGS
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"Generic registers are fully used"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|code
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
name|genTmp
operator|=
name|KG_SCH_GEN_VALID
expr_stmt|;
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|code
operator|<<
name|KG_SCH_GEN_HT_SHIFT
argument_list|)
expr_stmt|;
name|genTmp
operator||=
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|>
name|MAX_KG_SCH_SIZE
operator|)
operator|||
operator|(
name|size
operator|<
literal|1
operator|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"Illegal extraction (size out of range)"
operator|)
argument_list|)
expr_stmt|;
block|}
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|<<
name|KG_SCH_GEN_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|swDefault
operator|=
name|GetGenericSwDefault
argument_list|(
name|swDefaults
argument_list|,
name|numOfSwDefaults
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|swDefault
operator|==
name|e_FM_PCD_KG_DFLT_ILLEGAL
condition|)
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"No sw default configured"
operator|)
argument_list|)
expr_stmt|;
else|else
name|genTmp
operator||=
name|swDefault
operator|<<
name|KG_SCH_GEN_DEF_SHIFT
expr_stmt|;
name|genTmp
operator||=
name|KG_SCH_GEN_MASK
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_gec
index|[
name|currGenId
index|]
operator|=
name|genTmp
expr_stmt|;
comment|/* save in driver structure */
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|id
operator|=
name|currGenId
operator|++
expr_stmt|;
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|known
operator|=
name|FALSE
expr_stmt|;
name|generic
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|=
name|knownTmp
expr_stmt|;
name|selectTmp
operator|=
literal|0
expr_stmt|;
name|maskTmp
operator|=
literal|0xFFFFFFFF
expr_stmt|;
comment|/*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
if|if
condition|(
name|p_KeyAndHash
operator|->
name|numOfUsedMasks
operator|>
name|FM_PCD_KG_NUM_OF_EXTRACT_MASKS
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Only %d masks supported"
operator|,
name|FM_PCD_KG_NUM_OF_EXTRACT_MASKS
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_KeyAndHash
operator|->
name|numOfUsedMasks
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
name|id
operator|=
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|p_KeyAndHash
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|extractArrayIndex
index|]
operator|.
name|id
expr_stmt|;
comment|/* Get the shift of the select field (depending on i) */
name|GET_MASK_SEL_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|p_KeyAndHash
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|extractArrayIndex
index|]
operator|.
name|known
condition|)
name|selectTmp
operator||=
name|id
operator|<<
name|shift
expr_stmt|;
else|else
name|selectTmp
operator||=
operator|(
name|id
operator|+
name|MASK_FOR_GENERIC_BASE_ID
operator|)
operator|<<
name|shift
expr_stmt|;
comment|/* Get the shift of the offset field (depending on i) - may                be in  kgse_bmch or in kgse_fqb (depending on i) */
name|GET_MASK_OFFSET_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|1
condition|)
name|selectTmp
operator||=
name|p_KeyAndHash
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|offset
operator|<<
name|shift
expr_stmt|;
else|else
name|fqbTmp
operator||=
name|p_KeyAndHash
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|offset
operator|<<
name|shift
expr_stmt|;
comment|/* Get the shift of the mask field (depending on i) */
name|GET_MASK_SHIFT
argument_list|(
name|shift
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* pass all bits */
name|maskTmp
operator||=
name|KG_SCH_BITMASK_MASK
operator|<<
name|shift
expr_stmt|;
comment|/* clear bits that need masking */
name|maskTmp
operator|&=
operator|~
operator|(
literal|0xFF
operator|<<
name|shift
operator|)
expr_stmt|;
comment|/* set mask bits */
name|maskTmp
operator||=
operator|(
name|p_KeyAndHash
operator|->
name|masks
index|[
name|i
index|]
operator|.
name|mask
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
name|p_SchemeRegs
operator|->
name|kgse_bmch
operator|=
name|selectTmp
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_bmcl
operator|=
name|maskTmp
expr_stmt|;
comment|/* kgse_fqb will be written t the end of the routine */
comment|/*  configure kgse_hc  */
if|if
condition|(
name|p_KeyAndHash
operator|->
name|hashShift
operator|>
name|MAX_HASH_SHIFT
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"hashShift must not be larger than %d"
operator|,
name|MAX_HASH_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_KeyAndHash
operator|->
name|hashDistributionFqidsShift
operator|>
name|MAX_DIST_FQID_SHIFT
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"hashDistributionFqidsShift must not be larger than %d"
operator|,
name|MAX_DIST_FQID_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator|=
literal|0
expr_stmt|;
name|tmpReg
operator||=
operator|(
operator|(
name|p_KeyAndHash
operator|->
name|hashDistributionNumOfFqids
operator|-
literal|1
operator|)
operator|<<
name|p_KeyAndHash
operator|->
name|hashDistributionFqidsShift
operator|)
expr_stmt|;
name|tmpReg
operator||=
name|p_KeyAndHash
operator|->
name|hashShift
operator|<<
name|KG_SCH_HASH_CONFIG_SHIFT_SHIFT
expr_stmt|;
if|if
condition|(
name|p_KeyAndHash
operator|->
name|symmetricHash
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_MACSRC
operator|)
operator|!=
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_MACDST
operator|)
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_IPSRC1
operator|)
operator|!=
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_IPDST1
operator|)
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_IPSRC2
operator|)
operator|!=
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_IPDST2
operator|)
operator|)
operator|||
operator|(
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_L4PSRC
operator|)
operator|!=
operator|!
operator|!
operator|(
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|&
name|KG_SCH_KN_L4PDST
operator|)
operator|)
condition|)
block|{
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"symmetricHash set but src/dest extractions missing"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tmpReg
operator||=
name|KG_SCH_HASH_CONFIG_SYM
expr_stmt|;
block|}
name|p_SchemeRegs
operator|->
name|kgse_hc
operator|=
name|tmpReg
expr_stmt|;
comment|/* build the return array describing the order of the extractions */
comment|/* the last currGenId places of the array            are for generic extracts that are always last.            We now sort for the calculation of the order of the known            extractions we sort the known extracts between orderedArray[0] and            orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId - 1].            for the calculation of the order of the generic extractions we use:            num_of_generic - currGenId            num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId            first_generic_index = num_of_known */
name|curr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_KeyAndHash
operator|->
name|numOfUsedExtracts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|known
condition|)
block|{
name|ASSERT_COND
argument_list|(
name|curr
operator|<
operator|(
name|p_KeyAndHash
operator|->
name|numOfUsedExtracts
operator|-
name|currGenId
operator|)
argument_list|)
expr_stmt|;
name|j
operator|=
name|curr
expr_stmt|;
comment|/* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original                 index in the user's extractions array */
comment|/* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]                 location */
while|while
condition|(
operator|(
name|j
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|id
operator|<
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|p_Scheme
operator|->
name|orderedArray
index|[
name|j
operator|-
literal|1
index|]
index|]
operator|.
name|id
operator|)
condition|)
block|{
name|p_Scheme
operator|->
name|orderedArray
index|[
name|j
index|]
operator|=
name|p_Scheme
operator|->
name|orderedArray
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|p_Scheme
operator|->
name|orderedArray
index|[
name|j
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* index is first_generic_index + generic index (id) */
name|idx
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_KeyAndHash
operator|->
name|numOfUsedExtracts
operator|-
name|currGenId
operator|+
name|p_LocalExtractsArray
operator|->
name|extractsArray
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|idx
operator|<
name|FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|orderedArray
index|[
name|idx
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
block|}
block|}
name|XX_Free
argument_list|(
name|p_LocalExtractsArray
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* clear all unused registers: */
name|p_SchemeRegs
operator|->
name|kgse_ekfc
operator|=
literal|0
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_ekdv
operator|=
literal|0
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_bmch
operator|=
literal|0
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_bmcl
operator|=
literal|0
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_hc
operator|=
literal|0
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_dv0
operator|=
literal|0
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_dv1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p_SchemeParams
operator|->
name|bypassFqidGeneration
condition|)
name|p_SchemeRegs
operator|->
name|kgse_hc
operator||=
name|KG_SCH_HASH_CONFIG_NO_FQID
expr_stmt|;
comment|/*  configure kgse_spc  */
if|if
condition|(
name|p_SchemeParams
operator|->
name|schemeCounter
operator|.
name|update
condition|)
name|p_SchemeRegs
operator|->
name|kgse_spc
operator|=
name|p_SchemeParams
operator|->
name|schemeCounter
operator|.
name|value
expr_stmt|;
comment|/* check that are enough generic registers */
if|if
condition|(
name|p_SchemeParams
operator|->
name|numOfUsedExtractedOrs
operator|+
name|currGenId
operator|>
name|FM_KG_NUM_OF_GENERIC_REGS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"Generic registers are fully used"
operator|)
argument_list|)
expr_stmt|;
comment|/* extracted OR mask on Qid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_SchemeParams
operator|->
name|numOfUsedExtractedOrs
condition|;
name|i
operator|++
control|)
block|{
name|p_Scheme
operator|->
name|extractedOrs
operator|=
name|TRUE
expr_stmt|;
comment|/*  configure kgse_gec[i]  */
name|p_ExtractOr
operator|=
operator|&
name|p_SchemeParams
operator|->
name|extractedOrs
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|p_ExtractOr
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO
operator|)
case|:
name|code
operator|=
name|KG_SCH_GEN_PARSE_RESULT_N_FQID
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_BY_HDR
operator|)
case|:
comment|/* get the header code for the generic extract */
name|code
operator|=
name|GetGenHdrCode
argument_list|(
name|p_ExtractOr
operator|->
name|extractByHdr
operator|.
name|hdr
argument_list|,
name|p_ExtractOr
operator|->
name|extractByHdr
operator|.
name|hdrIndex
argument_list|,
name|p_ExtractOr
operator|->
name|extractByHdr
operator|.
name|ignoreProtocolValidation
argument_list|)
expr_stmt|;
comment|/* set generic register fields */
name|offset
operator|=
name|p_ExtractOr
operator|->
name|extractionOffset
expr_stmt|;
break|break;
case|case
operator|(
name|e_FM_PCD_EXTRACT_NON_HDR
operator|)
case|:
comment|/* get the field code for the generic extract */
name|offset
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|GetGenCode
argument_list|(
name|p_ExtractOr
operator|->
name|src
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|p_ExtractOr
operator|->
name|extractionOffset
expr_stmt|;
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_SELECTION
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* set generic register fields */
if|if
condition|(
operator|!
name|code
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|genTmp
operator|=
name|KG_SCH_GEN_EXTRACT_TYPE
operator||
name|KG_SCH_GEN_VALID
expr_stmt|;
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|code
operator|<<
name|KG_SCH_GEN_HT_SHIFT
argument_list|)
expr_stmt|;
name|genTmp
operator||=
name|offset
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
operator|==
operator|!
operator|!
name|p_ExtractOr
operator|->
name|bitOffsetInPlcrProfile
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|" extracted byte must effect either FQID or Policer profile"
operator|)
argument_list|)
expr_stmt|;
comment|/************************************************************************************             bitOffsetInFqid and bitOffsetInPolicerProfile are translated to rotate parameter             in the following way:              Driver API and implementation:             ==============================             FQID: extracted OR byte may be shifted right 1-31 bits to effect parts of the FQID.             if shifted less than 8 bits, or more than 24 bits a mask is set on the bits that             are not overlapping FQID.                      ------------------------                     |      FQID (24)         |                      ------------------------             --------            |        |  extracted OR byte             --------              Policer Profile: extracted OR byte may be shifted right 1-15 bits to effect parts of the             PP id. Unless shifted exactly 8 bits to overlap the PP id, a mask is set on the bits that             are not overlapping PP id.                       --------                     | PP (8) |                      --------             --------            |        |  extracted OR byte             --------              HW implementation             =================             FQID and PP construct a 32 bit word in the way describe below. Extracted byte is located             as the highest byte of that word and may be rotated to effect any part os the FQID or             the PP.              ------------------------  --------             |      FQID (24)         || PP (8) |              ------------------------  --------              --------             |        |  extracted OR byte              --------          ************************************************************************************/
if|if
condition|(
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
condition|)
block|{
if|if
condition|(
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
operator|>
name|MAX_KG_SCH_FQID_BIT_OFFSET
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Illegal extraction (bitOffsetInFqid out of range)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
operator|<
literal|8
condition|)
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
operator|+
literal|24
operator|)
operator|<<
name|KG_SCH_GEN_SIZE_SHIFT
argument_list|)
expr_stmt|;
else|else
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
operator|-
literal|8
operator|)
operator|<<
name|KG_SCH_GEN_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|p_ExtractOr
operator|->
name|mask
operator|&=
name|GetExtractedOrMask
argument_list|(
name|p_ExtractOr
operator|->
name|bitOffsetInFqid
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* effect policer profile */
block|{
if|if
condition|(
name|p_ExtractOr
operator|->
name|bitOffsetInPlcrProfile
operator|>
name|MAX_KG_SCH_PP_BIT_OFFSET
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Illegal extraction (bitOffsetInPlcrProfile out of range)"
operator|)
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|bitOffsetInPlcrProfile
operator|=
name|p_ExtractOr
operator|->
name|bitOffsetInPlcrProfile
expr_stmt|;
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|p_ExtractOr
operator|->
name|bitOffsetInPlcrProfile
operator|+
literal|16
operator|)
operator|<<
name|KG_SCH_GEN_SIZE_SHIFT
argument_list|)
expr_stmt|;
name|p_ExtractOr
operator|->
name|mask
operator|&=
name|GetExtractedOrMask
argument_list|(
name|p_ExtractOr
operator|->
name|bitOffsetInPlcrProfile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|p_ExtractOr
operator|->
name|extractionOffset
operator|<<
name|KG_SCH_GEN_DEF_SHIFT
argument_list|)
expr_stmt|;
comment|/* clear bits that need masking */
name|genTmp
operator|&=
operator|~
name|KG_SCH_GEN_MASK
expr_stmt|;
comment|/* set mask bits */
name|genTmp
operator||=
call|(
name|uint32_t
call|)
argument_list|(
name|p_ExtractOr
operator|->
name|mask
operator|<<
name|KG_SCH_GEN_MASK_SHIFT
argument_list|)
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_gec
index|[
name|currGenId
operator|++
index|]
operator|=
name|genTmp
expr_stmt|;
block|}
comment|/* clear all unused GEC registers */
for|for
control|(
name|i
operator|=
name|currGenId
init|;
name|i
operator|<
name|FM_KG_NUM_OF_GENERIC_REGS
condition|;
name|i
operator|++
control|)
name|p_SchemeRegs
operator|->
name|kgse_gec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* add base Qid for this scheme */
comment|/* add configuration for kgse_fqb */
if|if
condition|(
name|p_SchemeParams
operator|->
name|baseFqid
operator|&
operator|~
literal|0x00FFFFFF
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"baseFqid must be between 1 and 2^24-1"
operator|)
argument_list|)
expr_stmt|;
name|fqbTmp
operator||=
name|p_SchemeParams
operator|->
name|baseFqid
expr_stmt|;
name|p_SchemeRegs
operator|->
name|kgse_fqb
operator|=
name|fqbTmp
expr_stmt|;
name|p_Scheme
operator|->
name|nextEngine
operator|=
name|p_SchemeParams
operator|->
name|nextEngine
expr_stmt|;
name|p_Scheme
operator|->
name|doneAction
operator|=
name|p_SchemeParams
operator|->
name|kgNextEngineParams
operator|.
name|doneAction
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*              Inter-module API routines                                    */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|t_Error
name|FmPcdKgBuildClsPlanGrp
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleClsPlanGrpParams
modifier|*
name|p_Grp
parameter_list|,
name|t_FmPcdKgInterModuleClsPlanSet
modifier|*
name|p_ClsPlanSet
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdKgClsPlanGrp
modifier|*
name|p_ClsPlanGrp
decl_stmt|;
name|t_FmPcdIpcKgClsPlanParams
name|kgAlloc
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|oredVectors
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* this routine is protected by the calling routine ! */
if|if
condition|(
name|p_Grp
operator|->
name|numOfOptions
operator|>=
name|FM_PCD_MAX_NUM_OF_OPTIONS
argument_list|(
name|FM_PCD_MAX_NUM_OF_CLS_PLANS
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"Too many classification plan basic options selected."
operator|)
argument_list|)
expr_stmt|;
comment|/* find a new clsPlan group */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_MAX_NUM_OF_PORTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FM_MAX_NUM_OF_PORTS
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"No classification plan groups available."
operator|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|i
index|]
operator|.
name|used
operator|=
name|TRUE
expr_stmt|;
name|p_Grp
operator|->
name|clsPlanGrpId
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|p_Grp
operator|->
name|numOfOptions
operator|==
literal|0
condition|)
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
name|p_ClsPlanGrp
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|i
index|]
expr_stmt|;
name|p_ClsPlanGrp
operator|->
name|netEnvId
operator|=
name|p_Grp
operator|->
name|netEnvId
expr_stmt|;
name|p_ClsPlanGrp
operator|->
name|owners
operator|=
literal|0
expr_stmt|;
name|FmPcdSetClsPlanGrpId
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Grp
operator|->
name|netEnvId
argument_list|,
name|p_Grp
operator|->
name|clsPlanGrpId
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Grp
operator|->
name|numOfOptions
operator|!=
literal|0
condition|)
name|FmPcdIncNetEnvOwners
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Grp
operator|->
name|netEnvId
argument_list|)
expr_stmt|;
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
operator|=
call|(
name|uint16_t
call|)
argument_list|(
literal|1
operator|<<
name|p_Grp
operator|->
name|numOfOptions
argument_list|)
expr_stmt|;
comment|/* a minimal group of 8 is required */
if|if
condition|(
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
operator|<
name|CLS_PLAN_NUM_PER_GRP
condition|)
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
operator|=
name|CLS_PLAN_NUM_PER_GRP
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
name|err
operator|=
name|KgAllocClsPlanEntries
argument_list|(
name|h_FmPcd
argument_list|,
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|,
operator|&
name|p_ClsPlanGrp
operator|->
name|baseEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
comment|/* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|kgAlloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|)
expr_stmt|;
name|kgAlloc
operator|.
name|guestId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|kgAlloc
operator|.
name|numOfClsPlanEntries
operator|=
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_ALLOC_KG_CLSPLAN
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|kgAlloc
argument_list|,
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p_ClsPlanGrp
operator|->
name|baseEntry
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p_ClsPlanGrp
operator|->
name|baseEntry
argument_list|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t_Error
operator|)
name|reply
operator|.
name|error
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
operator|(
name|t_Error
operator|)
name|reply
operator|.
name|error
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|p_ClsPlanGrp
operator|->
name|baseEntry
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|reply
operator|.
name|replyBody
operator|)
expr_stmt|;
block|}
comment|/* build classification plan entries parameters */
name|p_ClsPlanSet
operator|->
name|baseEntry
operator|=
name|p_ClsPlanGrp
operator|->
name|baseEntry
expr_stmt|;
name|p_ClsPlanSet
operator|->
name|numOfClsPlanEntries
operator|=
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
expr_stmt|;
name|oredVectors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Grp
operator|->
name|numOfOptions
condition|;
name|i
operator|++
control|)
block|{
name|oredVectors
operator||=
name|p_Grp
operator|->
name|optVectors
index|[
name|i
index|]
expr_stmt|;
comment|/* save an array of used options - the indexes represent the power of 2 index */
name|p_ClsPlanGrp
operator|->
name|optArray
index|[
name|i
index|]
operator|=
name|p_Grp
operator|->
name|options
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* set the classification plan relevant entries so that all bits      * relevant to the list of options is cleared      */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
condition|;
name|j
operator|++
control|)
name|p_ClsPlanSet
operator|->
name|vectors
index|[
name|j
index|]
operator|=
operator|~
name|oredVectors
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_Grp
operator|->
name|numOfOptions
condition|;
name|i
operator|++
control|)
block|{
comment|/* option i got the place 2^i in the clsPlan array. all entries that          * have bit i set, should have the vector bit cleared. So each option          * has one location that it is exclusive (1,2,4,8...) and represent the          * presence of that option only, and other locations that represent a          * combination of options.          * e.g:          * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2          * now represents a frame with ethernet-BC header - so the bit          * representing ethernet-BC should be set and all other option bits          * should be cleared.          * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit          * vector[1] set, but they also have other bits set:          * 3=1+2, options 0 and 1          * 6=2+4, options 1 and 2          * 7=1+2+4, options 0,1,and 2          * 10=2+8, options 1 and 3          * etc.          * */
comment|/* now for each option (i), we set their bits in all entries (j)          * that contain bit 2^i.          */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ClsPlanGrp
operator|->
name|sizeOfGrp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|p_ClsPlanSet
operator|->
name|vectors
index|[
name|j
index|]
operator||=
name|p_Grp
operator|->
name|optVectors
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|void
name|FmPcdKgDestroyClsPlanGrp
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|grpId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdIpcKgClsPlanParams
name|kgAlloc
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
comment|/* check that no port is bound to this clsPlan */
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|owners
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Trying to delete a clsPlan grp that has ports bound to"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|FmPcdSetClsPlanGrpId
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|netEnvId
argument_list|,
name|ILLEGAL_CLS_PLAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|grpId
operator|==
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
condition|)
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
else|else
name|FmPcdDecNetEnvOwners
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|netEnvId
argument_list|)
expr_stmt|;
comment|/* free blocks */
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
name|KgFreeClsPlanEntries
argument_list|(
name|h_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|sizeOfGrp
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|baseEntry
argument_list|)
expr_stmt|;
else|else
comment|/* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
block|{
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|kgAlloc
operator|.
name|guestId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|kgAlloc
operator|.
name|numOfClsPlanEntries
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|sizeOfGrp
expr_stmt|;
name|kgAlloc
operator|.
name|clsPlanBase
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
operator|.
name|baseEntry
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_FREE_KG_CLSPLAN
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|kgAlloc
argument_list|,
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|t_Error
operator|)
name|reply
operator|.
name|error
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Free KG clsPlan failed"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* clear clsPlan driver structure */
name|memset
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|grpId
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKgClsPlanGrp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgBuildBindPortToSchemes
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_BindPort
parameter_list|,
name|uint32_t
modifier|*
name|p_SpReg
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|j
decl_stmt|,
name|schemesPerPortVector
init|=
literal|0
decl_stmt|;
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|relativeSchemeId
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|,
name|walking1Mask
decl_stmt|;
name|uint8_t
name|swPortIndex
init|=
literal|0
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* for each scheme */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_BindPort
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|p_BindPort
operator|->
name|schemesIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|>=
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|p_Scheme
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_Scheme
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested scheme is invalid."
operator|)
argument_list|)
expr_stmt|;
comment|/* check netEnvId  of the port against the scheme netEnvId */
if|if
condition|(
operator|(
name|p_Scheme
operator|->
name|netEnvId
operator|!=
name|p_BindPort
operator|->
name|netEnvId
operator|)
operator|&&
operator|(
name|p_Scheme
operator|->
name|netEnvId
operator|!=
name|ILLEGAL_NETENV
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Port may not be bound to requested scheme - differ in netEnvId"
operator|)
argument_list|)
expr_stmt|;
comment|/* if next engine is private port policer profile, we need to check that it is valid */
name|HW_PORT_ID_TO_SW_PORT_INDX
argument_list|(
name|swPortIndex
argument_list|,
name|p_BindPort
operator|->
name|hardwarePortId
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Scheme
operator|->
name|nextRelativePlcrProfile
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_Scheme
operator|->
name|numOfProfiles
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|h_FmPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Scheme
operator|->
name|relativeProfileId
operator|+
name|j
operator|>=
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|numOfProfiles
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Relative profile not in range"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdPlcrIsProfileValid
argument_list|(
name|p_FmPcd
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdPlcr
operator|->
name|portsMapping
index|[
name|swPortIndex
index|]
operator|.
name|profilesBase
operator|+
name|p_Scheme
operator|->
name|relativeProfileId
operator|+
name|j
argument_list|)
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Relative profile not valid."
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|p_BindPort
operator|->
name|useClsPlan
condition|)
block|{
comment|/* This check may be redundant as port is a assigned to the whole NetEnv */
comment|/* if this port does not use clsPlan, it may not be bound to schemes with units that contain                 cls plan options. Schemes that are used only directly, should not be checked.                 it also may not be bound to schemes that go to CC with units that are options  - so we OR                 the match vector and the grpBits (= ccUnits) */
if|if
condition|(
operator|(
name|p_Scheme
operator|->
name|matchVector
operator|!=
name|SCHEME_ALWAYS_DIRECT
operator|)
operator|||
name|p_Scheme
operator|->
name|ccUnits
condition|)
block|{
name|uint8_t
name|netEnvId
decl_stmt|;
name|walking1Mask
operator|=
literal|0x80000000
expr_stmt|;
name|netEnvId
operator|=
operator|(
name|p_Scheme
operator|->
name|netEnvId
operator|==
name|ILLEGAL_NETENV
operator|)
condition|?
name|p_BindPort
operator|->
name|netEnvId
else|:
name|p_Scheme
operator|->
name|netEnvId
expr_stmt|;
name|tmp
operator|=
operator|(
name|p_Scheme
operator|->
name|matchVector
operator|==
name|SCHEME_ALWAYS_DIRECT
operator|)
condition|?
literal|0
else|:
name|p_Scheme
operator|->
name|matchVector
expr_stmt|;
name|tmp
operator||=
name|p_Scheme
operator|->
name|ccUnits
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|&
name|walking1Mask
condition|)
block|{
name|tmp
operator|&=
operator|~
name|walking1Mask
expr_stmt|;
if|if
condition|(
operator|!
name|PcdNetEnvIsUnitWithoutOpts
argument_list|(
name|p_FmPcd
argument_list|,
name|netEnvId
argument_list|,
name|walking1Mask
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"
operator|)
argument_list|)
expr_stmt|;
block|}
name|walking1Mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* build vector */
name|schemesPerPortVector
operator||=
literal|1
operator|<<
operator|(
literal|31
operator|-
name|p_BindPort
operator|->
name|schemesIds
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
operator|*
name|p_SpReg
operator|=
name|schemesPerPortVector
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgBindPortToSchemes
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_SchemeBind
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|spReg
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|err
operator|=
name|FmPcdKgBuildBindPortToSchemes
argument_list|(
name|h_FmPcd
argument_list|,
name|p_SchemeBind
argument_list|,
operator|&
name|spReg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|KgWriteSp
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeBind
operator|->
name|hardwarePortId
argument_list|,
name|spReg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|IncSchemeOwners
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeBind
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgUnbindPortToSchemes
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleBindPortToSchemes
modifier|*
name|p_SchemeBind
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint32_t
name|spReg
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|err
operator|=
name|FmPcdKgBuildBindPortToSchemes
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeBind
argument_list|,
operator|&
name|spReg
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|err
operator|=
name|KgWriteSp
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeBind
operator|->
name|hardwarePortId
argument_list|,
name|spReg
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|DecSchemeOwners
argument_list|(
name|p_FmPcd
argument_list|,
name|p_SchemeBind
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdKgIsSchemeValidSw
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
init|=
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
decl_stmt|;
return|return
name|p_Scheme
operator|->
name|valid
return|;
block|}
end_function

begin_function
name|bool
name|KgIsSchemeAlwaysDirect
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|matchVector
operator|==
name|SCHEME_ALWAYS_DIRECT
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgAllocSchemes
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|numOfSchemes
parameter_list|,
name|uint8_t
name|guestId
parameter_list|,
name|uint8_t
modifier|*
name|p_SchemesIds
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* This routine is issued only on master core of master partition -        either directly or through IPC, so no need for lock */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_KG_NUM_OF_SCHEMES
operator|&&
name|j
operator|<
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|i
index|]
operator|.
name|allocated
condition|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|i
index|]
operator|.
name|allocated
operator|=
name|TRUE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|i
index|]
operator|.
name|ownerId
operator|=
name|guestId
expr_stmt|;
name|p_SchemesIds
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|!=
name|numOfSchemes
condition|)
block|{
comment|/* roll back */
for|for
control|(
name|j
operator|--
init|;
name|j
condition|;
name|j
operator|--
control|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|p_SchemesIds
index|[
name|j
index|]
index|]
operator|.
name|allocated
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|p_SchemesIds
index|[
name|j
index|]
index|]
operator|.
name|ownerId
operator|=
literal|0
expr_stmt|;
name|p_SchemesIds
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"No schemes found"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgFreeSchemes
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|numOfSchemes
parameter_list|,
name|uint8_t
name|guestId
parameter_list|,
name|uint8_t
modifier|*
name|p_SchemesIds
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
comment|/* This routine is issued only on master core of master partition -        either directly or through IPC */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOfSchemes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|p_SchemesIds
index|[
name|i
index|]
index|]
operator|.
name|allocated
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Scheme was not previously allocated"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|p_SchemesIds
index|[
name|i
index|]
index|]
operator|.
name|ownerId
operator|!=
name|guestId
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Scheme is not owned by caller. "
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|p_SchemesIds
index|[
name|i
index|]
index|]
operator|.
name|allocated
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesMng
index|[
name|p_SchemesIds
index|[
name|i
index|]
index|]
operator|.
name|ownerId
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|KgAllocClsPlanEntries
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|numOfClsPlanEntries
parameter_list|,
name|uint8_t
name|guestId
parameter_list|,
name|uint8_t
modifier|*
name|p_First
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|numOfBlocks
decl_stmt|,
name|blocksFound
init|=
literal|0
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This routine is issued only on master core of master partition -        either directly or through IPC, so no need for lock */
if|if
condition|(
operator|!
name|numOfClsPlanEntries
condition|)
return|return
name|E_OK
return|;
if|if
condition|(
operator|(
name|numOfClsPlanEntries
operator|%
name|CLS_PLAN_NUM_PER_GRP
operator|)
operator|||
operator|(
operator|!
name|POWER_OF_2
argument_list|(
name|numOfClsPlanEntries
argument_list|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfClsPlanEntries must be a power of 2 and divisible by 8"
operator|)
argument_list|)
expr_stmt|;
name|numOfBlocks
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|numOfClsPlanEntries
operator|/
name|CLS_PLAN_NUM_PER_GRP
argument_list|)
expr_stmt|;
comment|/* try to find consequent blocks */
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_PCD_MAX_NUM_OF_CLS_PLANS
operator|/
name|CLS_PLAN_NUM_PER_GRP
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|i
index|]
operator|.
name|allocated
condition|)
block|{
name|blocksFound
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|blocksFound
operator|==
name|numOfBlocks
condition|)
break|break;
block|}
else|else
block|{
name|blocksFound
operator|=
literal|0
expr_stmt|;
comment|/* advance i to the next aligned address */
name|first
operator|=
name|i
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|first
operator|+
name|numOfBlocks
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blocksFound
operator|==
name|numOfBlocks
condition|)
block|{
operator|*
name|p_First
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|first
operator|*
name|CLS_PLAN_NUM_PER_GRP
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|first
init|;
name|j
operator|<
operator|(
name|first
operator|+
name|numOfBlocks
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|j
index|]
operator|.
name|allocated
operator|=
name|TRUE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|j
index|]
operator|.
name|ownerId
operator|=
name|guestId
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
else|else
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|E_FULL
argument_list|,
operator|(
literal|"No resources for clsPlan"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|KgFreeClsPlanEntries
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint16_t
name|numOfClsPlanEntries
parameter_list|,
name|uint8_t
name|guestId
parameter_list|,
name|uint8_t
name|base
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|numOfBlocks
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|baseBlock
decl_stmt|;
ifdef|#
directive|ifdef
name|DISABLE_ASSERTIONS
name|UNUSED
argument_list|(
name|guestId
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DISABLE_ASSERTIONS */
comment|/* This routine is issued only on master core of master partition -        either directly or through IPC, so no need for lock */
name|numOfBlocks
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|numOfClsPlanEntries
operator|/
name|CLS_PLAN_NUM_PER_GRP
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
operator|!
operator|(
name|base
operator|%
name|CLS_PLAN_NUM_PER_GRP
operator|)
argument_list|)
expr_stmt|;
name|baseBlock
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|base
operator|/
name|CLS_PLAN_NUM_PER_GRP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|baseBlock
init|;
name|i
operator|<
name|baseBlock
operator|+
name|numOfBlocks
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|i
index|]
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|guestId
operator|==
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|i
index|]
operator|.
name|ownerId
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|i
index|]
operator|.
name|allocated
operator|=
name|FALSE
expr_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanBlocksMng
index|[
name|i
index|]
operator|.
name|ownerId
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|KgEnable
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|struct
name|fman_kg_regs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|fman_kg_enable
argument_list|(
name|p_Regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|KgDisable
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|struct
name|fman_kg_regs
modifier|*
name|p_Regs
init|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|fman_kg_disable
argument_list|(
name|p_Regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|KgSetClsPlan
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdKgInterModuleClsPlanSet
modifier|*
name|p_Set
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|struct
name|fman_kg_cp_regs
modifier|*
name|p_FmPcdKgPortRegs
decl_stmt|;
name|uint32_t
name|tmpKgarReg
init|=
literal|0
decl_stmt|,
name|intFlags
decl_stmt|;
name|uint16_t
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This routine is protected by the calling routine ! */
name|ASSERT_COND
argument_list|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcdKgPortRegs
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|clsPlanRegs
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p_Set
operator|->
name|baseEntry
init|;
name|i
operator|<
name|p_Set
operator|->
name|baseEntry
operator|+
name|p_Set
operator|->
name|numOfClsPlanEntries
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteClsPlanBlockActionReg
argument_list|(
call|(
name|uint8_t
call|)
argument_list|(
name|i
operator|/
name|CLS_PLAN_NUM_PER_GRP
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT_COND
argument_list|(
name|IN_RANGE
argument_list|(
literal|0
argument_list|,
operator|(
name|j
operator|-
name|p_Set
operator|->
name|baseEntry
operator|)
argument_list|,
name|FM_PCD_MAX_NUM_OF_CLS_PLANS
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcdKgPortRegs
operator|->
name|kgcpe
index|[
name|j
operator|%
name|CLS_PLAN_NUM_PER_GRP
index|]
argument_list|,
name|p_Set
operator|->
name|vectors
index|[
name|j
operator|-
name|p_Set
operator|->
name|baseEntry
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
operator|!=
name|E_OK
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"WriteKgarWait FAILED"
operator|)
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|t_Handle
name|KgConfig
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|,
name|t_FmPcdParams
modifier|*
name|p_FmPcdParams
parameter_list|)
block|{
name|t_FmPcdKg
modifier|*
name|p_FmPcdKg
decl_stmt|;
name|UNUSED
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcdParams
operator|->
name|numOfSchemes
operator|>
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"numOfSchemes should not exceed %d"
operator|,
name|FM_PCD_KG_NUM_OF_SCHEMES
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_FmPcdKg
operator|=
operator|(
name|t_FmPcdKg
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdKg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcdKg
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM Keygen allocation FAILED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_FmPcdKg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
condition|)
block|{
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|=
operator|(
expr|struct
name|fman_kg_regs
operator|*
operator|)
name|UINT_TO_PTR
argument_list|(
name|FmGetPcdKgBaseAddr
argument_list|(
name|p_FmPcdParams
operator|->
name|h_Fm
argument_list|)
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|->
name|exceptions
operator||=
name|DEFAULT_fmPcdKgErrorExceptions
expr_stmt|;
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|=
operator|(
name|u_FmPcdKgIndirectAccessRegs
operator|*
operator|)
operator|&
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
operator|->
name|fmkg_indirect
index|[
literal|0
index|]
expr_stmt|;
block|}
name|p_FmPcdKg
operator|->
name|numOfSchemes
operator|=
name|p_FmPcdParams
operator|->
name|numOfSchemes
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
operator|)
operator|&&
operator|!
name|p_FmPcdKg
operator|->
name|numOfSchemes
condition|)
block|{
name|p_FmPcdKg
operator|->
name|numOfSchemes
operator|=
name|FM_PCD_KG_NUM_OF_SCHEMES
expr_stmt|;
name|DBG
argument_list|(
name|WARNING
argument_list|,
operator|(
literal|"numOfSchemes was defined 0 by user, re-defined by driver to FM_PCD_KG_NUM_OF_SCHEMES"
operator|)
argument_list|)
expr_stmt|;
block|}
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
return|return
name|p_FmPcdKg
return|;
block|}
end_function

begin_function
name|t_Error
name|KgInit
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
operator|=
name|XX_InitSpinlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"FM KG HW spinlock"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
name|err
operator|=
name|KgInitMaster
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|KgInitGuest
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|E_OK
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|t_Error
name|KgFree
parameter_list|(
name|t_FmPcd
modifier|*
name|p_FmPcd
parameter_list|)
block|{
name|t_FmPcdIpcKgSchemesParams
name|kgAlloc
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdIpcMsg
name|msg
decl_stmt|;
name|uint32_t
name|replyLength
decl_stmt|;
name|t_FmPcdIpcReply
name|reply
decl_stmt|;
name|FmUnregisterIntr
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|,
name|e_FM_MOD_KG
argument_list|,
literal|0
argument_list|,
name|e_FM_INTR_TYPE_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|guestId
operator|==
name|NCSW_MASTER_ID
condition|)
block|{
name|err
operator|=
name|FmPcdKgFreeSchemes
argument_list|(
name|p_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
argument_list|,
name|p_FmPcd
operator|->
name|guestId
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesIds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
comment|/* guest */
name|memset
argument_list|(
operator|&
name|reply
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|kgAlloc
operator|.
name|numOfSchemes
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
expr_stmt|;
name|kgAlloc
operator|.
name|guestId
operator|=
name|p_FmPcd
operator|->
name|guestId
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|kgAlloc
operator|.
name|numOfSchemes
operator|<
name|FM_PCD_KG_NUM_OF_SCHEMES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|kgAlloc
operator|.
name|schemesIds
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesIds
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
operator|*
name|kgAlloc
operator|.
name|numOfSchemes
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msgId
operator|=
name|FM_PCD_FREE_KG_SCHEMES
expr_stmt|;
name|memcpy
argument_list|(
name|msg
operator|.
name|msgBody
argument_list|,
operator|&
name|kgAlloc
argument_list|,
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|)
expr_stmt|;
name|replyLength
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|XX_IpcSendMessage
argument_list|(
name|p_FmPcd
operator|->
name|h_IpcSession
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
operator|.
name|msgId
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|kgAlloc
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reply
argument_list|,
operator|&
name|replyLength
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|replyLength
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"IPC reply length mismatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
condition|)
name|XX_FreeSpinlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|h_HwSpinlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|t_Error
operator|)
name|reply
operator|.
name|error
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgSetOrBindToClsPlanGrp
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint8_t
name|netEnvId
parameter_list|,
name|protocolOpt_t
modifier|*
name|p_OptArray
parameter_list|,
name|uint8_t
modifier|*
name|p_ClsPlanGrpId
parameter_list|,
name|bool
modifier|*
name|p_IsEmptyClsPlanGrp
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdKgInterModuleClsPlanGrpParams
name|grpParams
decl_stmt|,
modifier|*
name|p_GrpParams
decl_stmt|;
name|t_FmPcdKgClsPlanGrp
modifier|*
name|p_ClsPlanGrp
decl_stmt|;
name|t_FmPcdKgInterModuleClsPlanSet
modifier|*
name|p_ClsPlanSet
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* This function is issued only from FM_PORT_SetPcd which locked all PCD modules,        so no need for lock here */
name|memset
argument_list|(
operator|&
name|grpParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|grpParams
argument_list|)
argument_list|)
expr_stmt|;
name|grpParams
operator|.
name|clsPlanGrpId
operator|=
name|ILLEGAL_CLS_PLAN
expr_stmt|;
name|p_GrpParams
operator|=
operator|&
name|grpParams
expr_stmt|;
name|p_GrpParams
operator|->
name|netEnvId
operator|=
name|netEnvId
expr_stmt|;
comment|/* Get from the NetEnv the information of the clsPlan (can be already created,      * or needs to build) */
name|err
operator|=
name|PcdGetClsPlanGrpParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_GrpParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_GrpParams
operator|->
name|grpExists
condition|)
block|{
comment|/* this group was already updated (at least) in SW */
operator|*
name|p_ClsPlanGrpId
operator|=
name|p_GrpParams
operator|->
name|clsPlanGrpId
expr_stmt|;
block|}
else|else
block|{
name|p_ClsPlanSet
operator|=
operator|(
name|t_FmPcdKgInterModuleClsPlanSet
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdKgInterModuleClsPlanSet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ClsPlanSet
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Classification plan set"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_ClsPlanSet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKgInterModuleClsPlanSet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build (in SW) the clsPlan parameters, including the vectors to be written to HW */
name|err
operator|=
name|FmPcdKgBuildClsPlanGrp
argument_list|(
name|h_FmPcd
argument_list|,
name|p_GrpParams
argument_list|,
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
operator|*
name|p_ClsPlanGrpId
operator|=
name|p_GrpParams
operator|->
name|clsPlanGrpId
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
comment|/* write clsPlan entries to memory */
name|err
operator|=
name|FmHcPcdKgSetClsPlan
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XX_Free
argument_list|(
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* write clsPlan entries to memory */
name|KgSetClsPlan
argument_list|(
name|p_FmPcd
argument_list|,
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
block|}
comment|/* Set caller parameters     */
comment|/* mark if this is an empty classification group */
if|if
condition|(
operator|*
name|p_ClsPlanGrpId
operator|==
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|emptyClsPlanGrpId
condition|)
operator|*
name|p_IsEmptyClsPlanGrp
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|p_IsEmptyClsPlanGrp
operator|=
name|FALSE
expr_stmt|;
name|p_ClsPlanGrp
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
operator|*
name|p_ClsPlanGrpId
index|]
expr_stmt|;
comment|/* increment owners number */
name|p_ClsPlanGrp
operator|->
name|owners
operator|++
expr_stmt|;
comment|/* copy options array for port */
name|memcpy
argument_list|(
name|p_OptArray
argument_list|,
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
operator|*
name|p_ClsPlanGrpId
index|]
operator|.
name|optArray
argument_list|,
name|FM_PCD_MAX_NUM_OF_OPTIONS
argument_list|(
name|FM_PCD_MAX_NUM_OF_CLS_PLANS
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|protocolOpt_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bind port to the new or existing group */
name|err
operator|=
name|BindPortToClsPlanGrp
argument_list|(
name|p_FmPcd
argument_list|,
name|hardwarePortId
argument_list|,
name|p_GrpParams
operator|->
name|clsPlanGrpId
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgDeleteOrUnbindPortToClsPlanGrp
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|hardwarePortId
parameter_list|,
name|uint8_t
name|clsPlanGrpId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|t_FmPcdKgClsPlanGrp
modifier|*
name|p_ClsPlanGrp
init|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrpId
index|]
decl_stmt|;
name|t_FmPcdKgInterModuleClsPlanSet
modifier|*
name|p_ClsPlanSet
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
comment|/* This function is issued only from FM_PORT_DeletePcd which locked all PCD modules,        so no need for lock here */
name|UnbindPortToClsPlanGrp
argument_list|(
name|p_FmPcd
argument_list|,
name|hardwarePortId
argument_list|)
expr_stmt|;
comment|/* decrement owners number */
name|ASSERT_COND
argument_list|(
name|p_ClsPlanGrp
operator|->
name|owners
argument_list|)
expr_stmt|;
name|p_ClsPlanGrp
operator|->
name|owners
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|p_ClsPlanGrp
operator|->
name|owners
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdKgDeleteClsPlan
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|clsPlanGrpId
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
block|{
comment|/* clear clsPlan entries in memory */
name|p_ClsPlanSet
operator|=
operator|(
name|t_FmPcdKgInterModuleClsPlanSet
operator|*
operator|)
name|XX_Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|t_FmPcdKgInterModuleClsPlanSet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ClsPlanSet
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NO_MEMORY
argument_list|,
operator|(
literal|"Classification plan set"
operator|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|p_ClsPlanSet
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKgInterModuleClsPlanSet
argument_list|)
argument_list|)
expr_stmt|;
name|p_ClsPlanSet
operator|->
name|baseEntry
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrpId
index|]
operator|.
name|baseEntry
expr_stmt|;
name|p_ClsPlanSet
operator|->
name|numOfClsPlanEntries
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrpId
index|]
operator|.
name|sizeOfGrp
expr_stmt|;
name|KgSetClsPlan
argument_list|(
name|p_FmPcd
argument_list|,
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
name|XX_Free
argument_list|(
name|p_ClsPlanSet
argument_list|)
expr_stmt|;
name|FmPcdKgDestroyClsPlanGrp
argument_list|(
name|h_FmPcd
argument_list|,
name|clsPlanGrpId
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgGetRequiredAction
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|requiredAction
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgGetRequiredActionFlag
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|requiredActionFlag
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdKgIsDirectPlcr
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|directPlcr
return|;
block|}
end_function

begin_function
name|uint16_t
name|FmPcdKgGetRelativeProfileId
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|relativeProfileId
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdKgIsDistrOnPlcrProfile
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|extractedOrs
operator|&&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|bitOffsetInPlcrProfile
operator|)
operator|||
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|nextRelativePlcrProfile
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|e_FmPcdEngine
name|FmPcdKgGetNextEngine
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|relativeSchemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|nextEngine
return|;
block|}
end_function

begin_function
name|e_FmPcdDoneAction
name|FmPcdKgGetDoneAction
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|schemeId
index|]
operator|.
name|doneAction
return|;
block|}
end_function

begin_function
name|void
name|FmPcdKgUpdateRequiredAction
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|,
name|uint32_t
name|requiredAction
parameter_list|)
block|{
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
init|=
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
decl_stmt|;
comment|/* this routine is protected by calling routine */
name|ASSERT_COND
argument_list|(
name|p_Scheme
operator|->
name|valid
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|requiredAction
operator||=
name|requiredAction
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|FmPcdKgHwSchemeIsValid
parameter_list|(
name|uint32_t
name|schemeModeReg
parameter_list|)
block|{
return|return
operator|(
name|bool
operator|)
operator|!
operator|!
operator|(
name|schemeModeReg
operator|&
name|KG_SCH_MODE_EN
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgBuildWriteSchemeActionReg
parameter_list|(
name|uint8_t
name|schemeId
parameter_list|,
name|bool
name|updateCounter
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|schemeId
operator|<<
name|FM_PCD_KG_KGAR_NUM_SHIFT
operator|)
operator||
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_WRITE
operator||
name|FM_KG_KGAR_SEL_SCHEME_ENTRY
operator||
name|DUMMY_PORT_ID
operator||
operator|(
name|updateCounter
condition|?
name|FM_KG_KGAR_SCM_WSEL_UPDATE_CNT
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgBuildReadSchemeActionReg
parameter_list|(
name|uint8_t
name|schemeId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|schemeId
operator|<<
name|FM_PCD_KG_KGAR_NUM_SHIFT
operator|)
operator||
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_READ
operator||
name|FM_KG_KGAR_SEL_SCHEME_ENTRY
operator||
name|DUMMY_PORT_ID
operator||
name|FM_KG_KGAR_SCM_WSEL_UPDATE_CNT
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgBuildWriteClsPlanBlockActionReg
parameter_list|(
name|uint8_t
name|grpId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_WRITE
operator||
name|FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY
operator||
name|DUMMY_PORT_ID
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|grpId
operator|<<
name|FM_PCD_KG_KGAR_NUM_SHIFT
operator|)
operator||
name|FM_PCD_KG_KGAR_WSEL_MASK
argument_list|)
return|;
comment|/* if we ever want to write 1 by 1, use:        sel = (uint8_t)(0x01<< (7- (entryId % CLS_PLAN_NUM_PER_GRP)));      */
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgBuildWritePortSchemeBindActionReg
parameter_list|(
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_WRITE
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_ENTRY
operator||
name|hardwarePortId
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgBuildReadPortSchemeBindActionReg
parameter_list|(
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_READ
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_ENTRY
operator||
name|hardwarePortId
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|FmPcdKgBuildWritePortClsPlanBindActionReg
parameter_list|(
name|uint8_t
name|hardwarePortId
parameter_list|)
block|{
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|FM_KG_KGAR_GO
operator||
name|FM_KG_KGAR_WRITE
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_ENTRY
operator||
name|hardwarePortId
operator||
name|FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP
argument_list|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPcdKgGetClsPlanGrpBase
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|clsPlanGrp
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrp
index|]
operator|.
name|baseEntry
return|;
block|}
end_function

begin_function
name|uint16_t
name|FmPcdKgGetClsPlanGrpSize
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|clsPlanGrp
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
return|return
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|clsPlanGrps
index|[
name|clsPlanGrp
index|]
operator|.
name|sizeOfGrp
return|;
block|}
end_function

begin_function
name|uint8_t
name|FmPcdKgGetSchemeId
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|schemeId
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DPAA_VERSION
operator|>=
literal|11
operator|)
end_if

begin_function
name|bool
name|FmPcdKgGetVspe
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|vspe
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (DPAA_VERSION>= 11) */
end_comment

begin_function
name|uint8_t
name|FmPcdKgGetRelativeSchemeId
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|schemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesIds
index|[
name|i
index|]
operator|==
name|schemeId
condition|)
return|return
name|i
return|;
if|if
condition|(
name|i
operator|==
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"Scheme is out of partition range"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FM_PCD_KG_NUM_OF_SCHEMES
return|;
block|}
end_function

begin_function
name|t_Handle
name|FmPcdKgGetSchemeHandle
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|relativeSchemeId
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|ASSERT_COND
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
comment|/* check that schemeId is in range */
if|if
condition|(
name|relativeSchemeId
operator|>=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"relative-scheme-id %d!"
operator|,
name|relativeSchemeId
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
return|;
block|}
end_function

begin_function
name|bool
name|FmPcdKgIsSchemeHasOwners
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|owners
operator|==
literal|0
operator|)
condition|?
name|FALSE
else|:
name|TRUE
return|;
block|}
end_function

begin_function
name|t_Error
name|FmPcdKgCcGetSetParams
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_Handle
name|h_Scheme
parameter_list|,
name|uint32_t
name|requiredAction
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|uint8_t
name|relativeSchemeId
decl_stmt|,
name|physicalSchemeId
decl_stmt|;
name|uint32_t
name|tmpKgarReg
decl_stmt|,
name|tmpReg32
init|=
literal|0
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_Error
name|err
decl_stmt|;
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
init|=
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_INVALID_STATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Calling function locked all PCD modules, so no need to lock here */
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|h_Scheme
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"Scheme is Invalid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdKgCcGetSetParams
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Scheme
argument_list|,
name|requiredAction
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|UpdateRequiredActionFlag
argument_list|(
name|h_Scheme
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FmPcdKgUpdateRequiredAction
argument_list|(
name|h_Scheme
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|physicalSchemeId
operator|=
name|p_Scheme
operator|->
name|schemeId
expr_stmt|;
name|relativeSchemeId
operator|=
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|relativeSchemeId
operator|>=
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|requiredActionFlag
operator|||
operator|!
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|requiredAction
operator|&
name|requiredAction
operator|)
condition|)
block|{
if|if
condition|(
name|requiredAction
operator|&
name|UPDATE_NIA_ENQ_WITHOUT_DMA
condition|)
block|{
switch|switch
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|nextEngine
condition|)
block|{
case|case
operator|(
name|e_FM_PCD_DONE
operator|)
case|:
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|doneAction
operator|==
name|e_FM_PCD_ENQ_FRAME
condition|)
block|{
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|tmpReg32
operator|&
operator|(
name|NIA_ENG_BMI
operator||
name|NIA_BMI_AC_ENQ_FRAME
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|,
name|tmpReg32
operator||
name|NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|e_FM_PCD_PLCR
operator|)
case|:
if|if
condition|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|directPlcr
operator|||
operator|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|extractedOrs
operator|&&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|bitOffsetInPlcrProfile
operator|)
operator|||
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|nextRelativePlcrProfile
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"In this situation PP can not be with distribution and has to be shared"
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|FmPcdPlcrCcGetSetParams
argument_list|(
name|h_FmPcd
argument_list|,
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|relativeProfileId
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_VALUE
argument_list|,
operator|(
literal|"in this situation the next engine after scheme can be or PLCR or ENQ_FRAME"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|requiredAction
operator|&
name|UPDATE_KG_NIA_CC_WA
condition|)
block|{
if|if
condition|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
operator|.
name|nextEngine
operator|==
name|e_FM_PCD_CC
condition|)
block|{
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|)
expr_stmt|;
name|ASSERT_COND
argument_list|(
name|tmpReg32
operator|&
operator|(
name|NIA_ENG_FM_CTL
operator||
name|NIA_FM_CTL_AC_CC
operator|)
argument_list|)
expr_stmt|;
name|tmpReg32
operator|&=
operator|~
name|NIA_FM_CTL_AC_CC
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|,
name|tmpReg32
operator||
name|NIA_FM_CTL_AC_PRE_CC
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|requiredAction
operator|&
name|UPDATE_KG_OPT_MODE
condition|)
block|{
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_om
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requiredAction
operator|&
name|UPDATE_KG_NIA
condition|)
block|{
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|tmpReg32
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|)
expr_stmt|;
name|tmpReg32
operator|&=
operator|~
operator|(
name|NIA_ENG_MASK
operator||
name|NIA_AC_MASK
operator|)
expr_stmt|;
name|tmpReg32
operator||=
name|value
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|,
name|tmpReg32
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
block|}
block|}
name|UpdateRequiredActionFlag
argument_list|(
name|h_Scheme
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FmPcdKgUpdateRequiredAction
argument_list|(
name|h_Scheme
argument_list|,
name|requiredAction
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/*********************** End of inter-module routines ************************/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/*  API routines                        */
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
name|t_Handle
name|FM_PCD_KgSchemeSet
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|t_FmPcdKgSchemeParams
modifier|*
name|p_SchemeParams
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|struct
name|fman_kg_scheme_regs
name|schemeRegs
decl_stmt|;
name|struct
name|fman_kg_scheme_regs
modifier|*
name|p_MemRegs
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|uint32_t
name|tmpKgarReg
decl_stmt|;
name|uint32_t
name|intFlags
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|,
name|relativeSchemeId
init|=
literal|0
decl_stmt|;
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
decl_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|modify
condition|)
block|{
name|p_Scheme
operator|=
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|p_SchemeParams
operator|->
name|id
operator|.
name|h_Scheme
expr_stmt|;
name|p_FmPcd
operator|=
name|p_Scheme
operator|->
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_Scheme
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"Scheme is invalid"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|KgSchemeFlagTryLock
argument_list|(
name|p_Scheme
argument_list|)
condition|)
block|{
name|DBG
argument_list|(
name|TRACE
argument_list|,
operator|(
literal|"Scheme Try Lock - BUSY"
operator|)
argument_list|)
expr_stmt|;
comment|/* Signal to caller BUSY condition */
name|p_SchemeParams
operator|->
name|id
operator|.
name|h_Scheme
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|relativeSchemeId
operator|=
name|p_SchemeParams
operator|->
name|id
operator|.
name|relativeSchemeId
expr_stmt|;
comment|/* check that schemeId is in range */
if|if
condition|(
name|relativeSchemeId
operator|>=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|numOfSchemes
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
operator|(
literal|"relative-scheme-id %d!"
operator|,
name|relativeSchemeId
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_Scheme
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemes
index|[
name|relativeSchemeId
index|]
expr_stmt|;
if|if
condition|(
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|p_Scheme
argument_list|)
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"Scheme id (%d)!"
operator|,
name|relativeSchemeId
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Clear all fields, scheme may have beed previously used */
name|memset
argument_list|(
name|p_Scheme
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t_FmPcdKgScheme
argument_list|)
argument_list|)
expr_stmt|;
name|p_Scheme
operator|->
name|schemeId
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|schemesIds
index|[
name|relativeSchemeId
index|]
expr_stmt|;
name|p_Scheme
operator|->
name|h_FmPcd
operator|=
name|p_FmPcd
expr_stmt|;
name|p_Scheme
operator|->
name|p_Lock
operator|=
name|FmPcdAcquireLock
argument_list|(
name|p_FmPcd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_Scheme
operator|->
name|p_Lock
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_AVAILABLE
argument_list|,
operator|(
literal|"FM KG Scheme lock obj!"
operator|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|BuildSchemeRegs
argument_list|(
operator|(
name|t_Handle
operator|)
name|p_Scheme
argument_list|,
name|p_SchemeParams
argument_list|,
operator|&
name|schemeRegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|modify
condition|)
name|KgSchemeFlagUnlock
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|modify
operator|&&
name|p_Scheme
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdKgSetScheme
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
operator|(
name|t_Handle
operator|)
name|p_Scheme
argument_list|,
operator|&
name|schemeRegs
argument_list|,
name|p_SchemeParams
operator|->
name|schemeCounter
operator|.
name|update
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SchemeParams
operator|->
name|modify
condition|)
name|KgSchemeFlagUnlock
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|modify
operator|&&
name|p_Scheme
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|modify
condition|)
name|ValidateSchemeSw
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
return|return
operator|(
name|t_Handle
operator|)
name|p_Scheme
return|;
block|}
name|physicalSchemeId
operator|=
name|p_Scheme
operator|->
name|schemeId
expr_stmt|;
comment|/* configure all 21 scheme registers */
name|p_MemRegs
operator|=
operator|&
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_ppc
argument_list|,
name|schemeRegs
operator|.
name|kgse_ppc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_ccbs
argument_list|,
name|schemeRegs
operator|.
name|kgse_ccbs
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_mode
argument_list|,
name|schemeRegs
operator|.
name|kgse_mode
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_mv
argument_list|,
name|schemeRegs
operator|.
name|kgse_mv
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_dv0
argument_list|,
name|schemeRegs
operator|.
name|kgse_dv0
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_dv1
argument_list|,
name|schemeRegs
operator|.
name|kgse_dv1
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_ekdv
argument_list|,
name|schemeRegs
operator|.
name|kgse_ekdv
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_ekfc
argument_list|,
name|schemeRegs
operator|.
name|kgse_ekfc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_bmch
argument_list|,
name|schemeRegs
operator|.
name|kgse_bmch
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_bmcl
argument_list|,
name|schemeRegs
operator|.
name|kgse_bmcl
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_hc
argument_list|,
name|schemeRegs
operator|.
name|kgse_hc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_spc
argument_list|,
name|schemeRegs
operator|.
name|kgse_spc
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_fqb
argument_list|,
name|schemeRegs
operator|.
name|kgse_fqb
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_om
argument_list|,
name|schemeRegs
operator|.
name|kgse_om
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_vsp
argument_list|,
name|schemeRegs
operator|.
name|kgse_vsp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FM_KG_NUM_OF_GENERIC_REGS
condition|;
name|i
operator|++
control|)
name|WRITE_UINT32
argument_list|(
name|p_MemRegs
operator|->
name|kgse_gec
index|[
name|i
index|]
argument_list|,
name|schemeRegs
operator|.
name|kgse_gec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|p_SchemeParams
operator|->
name|schemeCounter
operator|.
name|update
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_SchemeParams
operator|->
name|modify
condition|)
name|ValidateSchemeSw
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
else|else
name|KgSchemeFlagUnlock
argument_list|(
name|p_Scheme
argument_list|)
expr_stmt|;
return|return
operator|(
name|t_Handle
operator|)
name|p_Scheme
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_KgSchemeDelete
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|uint32_t
name|tmpKgarReg
decl_stmt|,
name|intFlags
decl_stmt|;
name|t_Error
name|err
init|=
name|E_OK
decl_stmt|;
name|t_FmPcdKgScheme
modifier|*
name|p_Scheme
init|=
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|h_Scheme
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
name|p_Scheme
operator|->
name|h_FmPcd
operator|)
expr_stmt|;
name|UpdateRequiredActionFlag
argument_list|(
name|h_Scheme
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* check that no port is bound to this scheme */
name|err
operator|=
name|InvalidateSchemeSw
argument_list|(
name|h_Scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|RETURN_ERROR
argument_list|(
name|MINOR
argument_list|,
name|err
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
block|{
name|err
operator|=
name|FmHcPcdKgDeleteScheme
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Scheme
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|physicalSchemeId
operator|=
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|schemeId
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
comment|/* clear mode register, including enable bit */
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_Scheme
operator|->
name|p_Lock
condition|)
name|FmPcdReleaseLock
argument_list|(
name|p_FmPcd
argument_list|,
name|p_Scheme
operator|->
name|p_Lock
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|uint32_t
name|FM_PCD_KgSchemeGetCounter
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint32_t
name|tmpKgarReg
decl_stmt|,
name|spc
decl_stmt|,
name|intFlags
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_Scheme
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|h_FmPcd
operator|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
return|return
name|FmHcPcdKgGetSchemeCounter
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Scheme
argument_list|)
return|;
name|physicalSchemeId
operator|=
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|schemeId
expr_stmt|;
if|if
condition|(
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
operator|==
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|)
operator|&
name|KG_SCH_MODE_EN
operator|)
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"Scheme is Invalid"
operator|)
argument_list|)
expr_stmt|;
name|spc
operator|=
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_spc
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|spc
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_KgSchemeSetCounter
parameter_list|(
name|t_Handle
name|h_Scheme
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
decl_stmt|;
name|uint32_t
name|tmpKgarReg
decl_stmt|,
name|intFlags
decl_stmt|;
name|uint8_t
name|physicalSchemeId
decl_stmt|;
name|SANITY_CHECK_RETURN_VALUE
argument_list|(
name|h_Scheme
argument_list|,
name|E_INVALID_HANDLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_FmPcd
operator|=
operator|(
name|t_FmPcd
operator|*
operator|)
operator|(
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|h_FmPcd
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|FmPcdKgIsSchemeValidSw
argument_list|(
name|h_Scheme
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_INVALID_STATE
argument_list|,
operator|(
literal|"Requested scheme is invalid."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_FmPcd
operator|->
name|h_Hc
condition|)
return|return
name|FmHcPcdKgSetSchemeCounter
argument_list|(
name|p_FmPcd
operator|->
name|h_Hc
argument_list|,
name|h_Scheme
argument_list|,
name|value
argument_list|)
return|;
name|physicalSchemeId
operator|=
operator|(
operator|(
name|t_FmPcdKgScheme
operator|*
operator|)
name|h_Scheme
operator|)
operator|->
name|schemeId
expr_stmt|;
comment|/* check that schemeId is in range */
if|if
condition|(
name|FmPcdKgGetRelativeSchemeId
argument_list|(
name|p_FmPcd
argument_list|,
name|physicalSchemeId
argument_list|)
operator|==
name|FM_PCD_KG_NUM_OF_SCHEMES
condition|)
name|REPORT_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_IN_RANGE
argument_list|,
name|NO_MSG
argument_list|)
expr_stmt|;
comment|/* read specified scheme into scheme registers */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildReadSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|)
expr_stmt|;
name|intFlags
operator|=
name|KgHwLock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_mode
argument_list|)
operator|&
name|KG_SCH_MODE_EN
operator|)
condition|)
block|{
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_ALREADY_EXISTS
argument_list|,
operator|(
literal|"Scheme is Invalid"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* change counter value */
name|WRITE_UINT32
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_IndirectAccessRegs
operator|->
name|schemeRegs
operator|.
name|kgse_spc
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* call indirect command for scheme write */
name|tmpKgarReg
operator|=
name|FmPcdKgBuildWriteSchemeActionReg
argument_list|(
name|physicalSchemeId
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|WriteKgarWait
argument_list|(
name|p_FmPcd
argument_list|,
name|tmpKgarReg
argument_list|)
expr_stmt|;
name|KgHwUnlock
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|intFlags
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_KgSetAdditionalDataAfterParsing
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|payloadOffset
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|struct
name|fman_kg_regs
modifier|*
name|p_Regs
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Regs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
expr_stmt|;
if|if
condition|(
operator|!
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"
operator|)
argument_list|)
expr_stmt|;
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmkg_fdor
argument_list|,
name|payloadOffset
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_function
name|t_Error
name|FM_PCD_KgSetDfltValue
parameter_list|(
name|t_Handle
name|h_FmPcd
parameter_list|,
name|uint8_t
name|valueId
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|t_FmPcd
modifier|*
name|p_FmPcd
init|=
operator|(
name|t_FmPcd
operator|*
operator|)
name|h_FmPcd
decl_stmt|;
name|struct
name|fman_kg_regs
modifier|*
name|p_Regs
decl_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
argument_list|,
name|E_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|(
operator|(
name|valueId
operator|==
literal|0
operator|)
operator|||
operator|(
name|valueId
operator|==
literal|1
operator|)
operator|)
argument_list|,
name|E_INVALID_VALUE
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
operator|!
name|p_FmPcd
operator|->
name|p_FmPcdDriverParam
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|SANITY_CHECK_RETURN_ERROR
argument_list|(
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
argument_list|,
name|E_NULL_POINTER
argument_list|)
expr_stmt|;
name|p_Regs
operator|=
name|p_FmPcd
operator|->
name|p_FmPcdKg
operator|->
name|p_FmPcdKgRegs
expr_stmt|;
if|if
condition|(
operator|!
name|FmIsMaster
argument_list|(
name|p_FmPcd
operator|->
name|h_Fm
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|MAJOR
argument_list|,
name|E_NOT_SUPPORTED
argument_list|,
operator|(
literal|"FM_PCD_KgSetDfltValue - guest mode!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valueId
operator|==
literal|0
condition|)
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmkg_gdv0r
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|WRITE_UINT32
argument_list|(
name|p_Regs
operator|->
name|fmkg_gdv1r
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

end_unit

