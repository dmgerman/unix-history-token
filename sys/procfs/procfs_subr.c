begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Paul Kranenburg.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: procfs_subr.c,v 1.3 1993/12/26 10:40:22 davidg Exp $  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_page.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_kern.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_user.h"
end_include

begin_include
include|#
directive|include
file|"kinfo.h"
end_include

begin_include
include|#
directive|include
file|"kinfo_proc.h"
end_include

begin_include
include|#
directive|include
file|"machine/pmap.h"
end_include

begin_include
include|#
directive|include
file|"procfs.h"
end_include

begin_include
include|#
directive|include
file|"pfsnode.h"
end_include

begin_include
include|#
directive|include
file|"machine/vmparam.h"
end_include

begin_comment
comment|/*  * Get process address map (PIOCGMAP)  */
end_comment

begin_function
name|int
name|pfs_vmmap
parameter_list|(
name|procp
parameter_list|,
name|pfsp
parameter_list|,
name|pmapp
parameter_list|)
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|pfsp
decl_stmt|;
name|struct
name|procmap
modifier|*
name|pmapp
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|struct
name|procmap
name|prmap
decl_stmt|;
name|map
operator|=
operator|&
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|is_a_map
condition|)
block|{
name|vm_map_t
name|submap
init|=
name|entry
operator|->
name|object
operator|.
name|share_map
decl_stmt|;
name|vm_map_entry_t
name|subentry
decl_stmt|;
name|vm_map_lock
argument_list|(
name|submap
argument_list|)
expr_stmt|;
name|subentry
operator|=
name|submap
operator|->
name|header
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|subentry
operator|!=
operator|&
name|submap
operator|->
name|header
condition|)
block|{
name|prmap
operator|.
name|vaddr
operator|=
name|subentry
operator|->
name|start
expr_stmt|;
name|prmap
operator|.
name|size
operator|=
name|subentry
operator|->
name|end
operator|-
name|subentry
operator|->
name|start
expr_stmt|;
name|prmap
operator|.
name|offset
operator|=
name|subentry
operator|->
name|offset
expr_stmt|;
name|prmap
operator|.
name|prot
operator|=
name|subentry
operator|->
name|protection
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|prmap
argument_list|,
name|pmapp
argument_list|,
sizeof|sizeof
argument_list|(
name|prmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|pmapp
operator|++
expr_stmt|;
name|subentry
operator|=
name|subentry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|submap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|prmap
operator|.
name|vaddr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|prmap
operator|.
name|size
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|prmap
operator|.
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
name|prmap
operator|.
name|prot
operator|=
name|entry
operator|->
name|protection
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|prmap
argument_list|,
name|pmapp
argument_list|,
sizeof|sizeof
argument_list|(
name|prmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|pmapp
operator|++
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Count number of VM entries of process (PIOCNMAP)  */
end_comment

begin_function
name|int
name|pfs_vm_nentries
parameter_list|(
name|procp
parameter_list|,
name|pfsp
parameter_list|)
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|pfsp
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|map
operator|=
operator|&
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|vm_map_lock
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|is_a_map
condition|)
name|count
operator|+=
name|entry
operator|->
name|object
operator|.
name|share_map
operator|->
name|nentries
expr_stmt|;
else|else
name|count
operator|++
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|vm_map_unlock
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Map process mapped file to file descriptor (PIOCGMAPFD)  */
end_comment

begin_function
name|int
name|pfs_vmfd
parameter_list|(
name|procp
parameter_list|,
name|pfsp
parameter_list|,
name|vmfdp
parameter_list|,
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|pfsnode
modifier|*
name|pfsp
decl_stmt|;
name|struct
name|vmfd
modifier|*
name|vmfdp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|rv
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|,
name|maxprot
decl_stmt|;
name|vm_inherit_t
name|inherit
decl_stmt|;
name|boolean_t
name|shared
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|objoff
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|struct
name|fileops
name|vnops
decl_stmt|;
name|map
operator|=
operator|&
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|addr
operator|=
name|vmfdp
operator|->
name|vaddr
expr_stmt|;
name|rv
operator|=
name|vm_region
argument_list|(
name|map
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|maxprot
argument_list|,
operator|&
name|inherit
argument_list|,
operator|&
name|shared
argument_list|,
operator|&
name|object
argument_list|,
operator|&
name|objoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
name|EINVAL
return|;
while|while
condition|(
name|object
operator|!=
name|NULL
operator|&&
name|object
operator|->
name|pager
operator|==
name|NULL
condition|)
name|object
operator|=
name|object
operator|->
name|shadow
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
operator|||
name|object
operator|->
name|pager
operator|==
name|NULL
comment|/* Nobody seems to care || !object->pager_ready */
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|object
operator|->
name|pager
operator|->
name|pg_type
operator|!=
name|PG_VNODE
condition|)
return|return
name|ENOENT
return|;
comment|/* We have a vnode pager, allocate file descriptor */
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|object
operator|->
name|pager
operator|->
name|pg_handle
expr_stmt|;
if|if
condition|(
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VREAD
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|rv
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rv
operator|=
name|falloc
argument_list|(
name|p
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|vmfdp
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|out
goto|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_type
operator|=
name|DTYPE_VNODE
expr_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|vnops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|vp
expr_stmt|;
name|fp
operator|->
name|f_flag
operator|=
name|FREAD
expr_stmt|;
name|out
label|:
name|vm_object_unlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode op for reading/writing.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pfs_doio
parameter_list|(
name|vp
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|pfsnode
modifier|*
name|pfsp
init|=
name|VTOPFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|long
name|n
decl_stmt|,
name|on
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|,
name|kbuf
decl_stmt|;
name|int
name|pflag
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pfs_debug
condition|)
name|printf
argument_list|(
literal|"pfs_doio(%s): vp 0x%x, proc %x, offset %d\n"
argument_list|,
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
condition|?
literal|"R"
else|:
literal|"W"
argument_list|,
name|vp
argument_list|,
name|uio
operator|->
name|uio_procp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VPROC
condition|)
name|panic
argument_list|(
literal|"pfs_doio vtype"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|procp
operator|=
name|pfsp
operator|->
name|pfs_pid
condition|?
name|pfind
argument_list|(
name|pfsp
operator|->
name|pfs_pid
argument_list|)
else|:
operator|&
name|proc0
expr_stmt|;
if|if
condition|(
operator|!
name|procp
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
name|procp
operator|->
name|p_flag
operator|&
name|SSYS
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* allocate a bounce buffer */
comment|/* notice that this bounce buffer bogosity is due to 	   a problem with wiring/unwiring procs pages, so 	   rather than wire the destination procs data pages 	   I used a kernel bounce buffer 	*/
name|kbuf
operator|=
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbuf
condition|)
return|return
name|ENOMEM
return|;
comment|/* allocate a kva */
name|kva
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kva
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|kbuf
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|pflag
operator|=
name|procp
operator|->
name|p_flag
operator|&
name|SKEEP
expr_stmt|;
name|procp
operator|->
name|p_flag
operator||=
name|SKEEP
expr_stmt|;
do|do
block|{
comment|/* One page at a time */
name|int
name|rv
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|,
name|v
decl_stmt|,
name|pa
decl_stmt|;
name|vm_prot_t
name|oldprot
init|=
literal|0
decl_stmt|,
name|prot
decl_stmt|,
name|maxprot
decl_stmt|;
name|vm_inherit_t
name|inherit
decl_stmt|;
name|boolean_t
name|shared
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|objoff
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_offset_t
name|size
decl_stmt|;
name|int
name|s
decl_stmt|;
name|on
operator|=
name|uio
operator|->
name|uio_offset
operator|-
name|trunc_page
argument_list|(
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|NBPG
operator|-
name|on
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
comment|/* Map page into kernel space */
comment|/* printf("rw: offset: %d, n: %d, resid: %d\n",  			uio->uio_offset, n, uio->uio_resid); */
if|if
condition|(
name|procp
operator|->
name|p_vmspace
operator|!=
name|pfsp
operator|->
name|pfs_vs
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|map
operator|=
operator|&
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|offset
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
comment|/*  * This code *fakes* the existance of the UPAGES at the address USRSTACK  * in the process address space for versions of the kernel where the  * UPAGES do not exist in the process map.    */
if|#
directive|if
literal|0
ifndef|#
directive|ifndef
name|FULLSWAP
block|if( offset>= USRSTACK) { 			caddr_t paddr; 			if( offset>= USRSTACK + NBPG*UPAGES) { 				error = EINVAL; 				break; 			} 			paddr = (caddr_t) procp->p_addr; 			error = uiomove(paddr + (offset - USRSTACK), (int)n, uio); 			continue; 		}
endif|#
directive|endif
endif|#
directive|endif
comment|/* make sure that the offset exists in the procs map */
name|rv
operator|=
name|vm_region
argument_list|(
name|map
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|maxprot
argument_list|,
operator|&
name|inherit
argument_list|,
operator|&
name|shared
argument_list|,
operator|&
name|object
argument_list|,
operator|&
name|objoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* change protections if need be */
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
operator|&&
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|oldprot
operator|=
name|prot
expr_stmt|;
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|rv
operator|=
name|vm_protect
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|NBPG
argument_list|,
name|FALSE
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|!=
name|UIO_WRITE
condition|)
block|{
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
block|}
comment|/* check for stack area -- don't fault in unused pages */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|offset
operator|>=
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_maxsaddr
operator|&&
name|offset
operator|<
name|USRSTACK
condition|)
block|{
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|offset
operator|<
operator|(
operator|(
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_maxsaddr
operator|+
name|MAXSSIZ
operator|)
operator|-
name|ctob
argument_list|(
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_ssize
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|reprot
goto|;
block|}
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|offset
operator|>=
operator|(
operator|(
name|procp
operator|->
name|p_vmspace
operator|->
name|vm_maxsaddr
operator|+
name|MAXSSIZ
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|reprot
goto|;
block|}
block|}
comment|/* wire the page table page */
name|v
operator|=
name|trunc_page
argument_list|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|vtopte
argument_list|(
name|offset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|vm_map_pageable
argument_list|(
name|map
argument_list|,
name|v
argument_list|,
name|round_page
argument_list|(
name|v
operator|+
literal|1
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
condition|)
block|{
comment|/* Now just fault the page table and the page */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|VM_PROT_READ
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|procp
operator|->
name|p_flag
operator|=
operator|(
name|procp
operator|->
name|p_flag
operator|&
operator|~
name|SKEEP
operator|)
operator||
name|pflag
expr_stmt|;
name|vm_map_pageable
argument_list|(
name|map
argument_list|,
name|v
argument_list|,
name|round_page
argument_list|(
name|v
operator|+
literal|1
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|reprot
goto|;
block|}
comment|/* get the physical address of the page */
name|pa
operator|=
name|pmap_extract
argument_list|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pa
condition|)
block|{
name|printf
argument_list|(
literal|"pfs: cannot get pa -- read\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* enter the physical address into the kernel pmap */
name|pmap_enter
argument_list|(
name|vm_map_pmap
argument_list|(
name|kernel_map
argument_list|)
argument_list|,
name|kva
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* copy the data */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|kva
argument_list|,
operator|(
name|caddr_t
operator|)
name|kbuf
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
comment|/* remove the physical address from the kernel pmap */
name|pmap_remove
argument_list|(
name|vm_map_pmap
argument_list|(
name|kernel_map
argument_list|)
argument_list|,
name|kva
argument_list|,
name|round_page
argument_list|(
name|kva
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|uiomove
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|kbuf
operator|+
name|on
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
condition|)
block|{
comment|/* Now just fault the page table and the page */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|procp
operator|->
name|p_flag
operator|=
operator|(
name|procp
operator|->
name|p_flag
operator|&
operator|~
name|SKEEP
operator|)
operator||
name|pflag
expr_stmt|;
name|vm_map_pageable
argument_list|(
name|map
argument_list|,
name|v
argument_list|,
name|round_page
argument_list|(
name|v
operator|+
literal|1
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|reprot
goto|;
block|}
comment|/* get the physical address of the page */
name|pa
operator|=
name|pmap_extract
argument_list|(
name|vm_map_pmap
argument_list|(
name|map
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pa
condition|)
block|{
name|printf
argument_list|(
literal|"pfs: cannot get pa -- write\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* enter the physical address into the kernel pmap */
name|pmap_enter
argument_list|(
name|vm_map_pmap
argument_list|(
name|kernel_map
argument_list|)
argument_list|,
name|kva
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* copy the data */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|kbuf
argument_list|,
operator|(
name|caddr_t
operator|)
name|kva
operator|+
name|on
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* remove the physical address from the kernel pmap */
name|pmap_remove
argument_list|(
name|vm_map_pmap
argument_list|(
name|kernel_map
argument_list|)
argument_list|,
name|kva
argument_list|,
name|round_page
argument_list|(
name|kva
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* unwire the page table page */
name|vm_map_pageable
argument_list|(
name|map
argument_list|,
name|v
argument_list|,
name|round_page
argument_list|(
name|v
operator|+
literal|1
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|reprot
label|:
if|if
condition|(
name|oldprot
condition|)
block|{
name|rv
operator|=
name|vm_protect
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|NBPG
argument_list|,
name|FALSE
argument_list|,
name|oldprot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
do|;
name|procp
operator|->
name|p_flag
operator|=
operator|(
name|procp
operator|->
name|p_flag
operator|&
operator|~
name|SKEEP
operator|)
operator||
name|pflag
expr_stmt|;
comment|/* free the kva and bounce buffer */
name|kmem_free_wakeup
argument_list|(
name|kernel_map
argument_list|,
name|kva
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|kbuf
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

