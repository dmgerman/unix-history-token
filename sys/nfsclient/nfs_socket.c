begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1991, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_socket.c	8.5 (Berkeley) 3/30/95  * $Id: nfs_socket.c,v 1.41 1998/06/07 17:12:28 dfr Exp $  */
end_comment

begin_comment
comment|/*  * Socket operations for use by nfs  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/tprintf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsrtt.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nqnfs.h>
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  * Estimate rto for an nfs rpc sent via. an unreliable datagram.  * Use the mean and mean deviation of rtt for the appropriate type of rpc  * for the frequent rpcs and a default for the others.  * The justification for doing "other" this way is that these rpcs  * happen so infrequently that timer est. would probably be stale.  * Also, since many of these rpcs are  * non-idempotent, a conservative timeout is desired.  * getattr, lookup - A+2D  * read, write     - A+4D  * other           - nm_timeo  */
end_comment

begin_define
define|#
directive|define
name|NFS_RTO
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|((t) == 0 ? (n)->nm_timeo : \ 	 ((t)< 3 ? \ 	  (((((n)->nm_srtt[t-1] + 3)>> 2) + (n)->nm_sdrtt[t-1] + 1)>> 1) : \ 	  ((((n)->nm_srtt[t-1] + 7)>> 3) + (n)->nm_sdrtt[t-1] + 1)))
end_define

begin_define
define|#
directive|define
name|NFS_SRTT
parameter_list|(
name|r
parameter_list|)
value|(r)->r_nmp->nm_srtt[proct[(r)->r_procnum] - 1]
end_define

begin_define
define|#
directive|define
name|NFS_SDRTT
parameter_list|(
name|r
parameter_list|)
value|(r)->r_nmp->nm_sdrtt[proct[(r)->r_procnum] - 1]
end_define

begin_comment
comment|/*  * External data, mostly RPC constants in XDR form  */
end_comment

begin_decl_stmt
specifier|extern
name|u_int32_t
name|rpc_reply
decl_stmt|,
name|rpc_msgdenied
decl_stmt|,
name|rpc_mismatch
decl_stmt|,
name|rpc_vers
decl_stmt|,
name|rpc_auth_unix
decl_stmt|,
name|rpc_msgaccepted
decl_stmt|,
name|rpc_call
decl_stmt|,
name|rpc_autherr
decl_stmt|,
name|rpc_auth_kerb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int32_t
name|nfs_prog
decl_stmt|,
name|nqnfs_prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|nqnfsstarttime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|nfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsv3_procid
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_ticks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defines which timer to use for the procnum.  * 0 - default  * 1 - getattr  * 2 - lookup  * 3 - read  * 4 - write  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|proct
index|[
name|NFS_NPROCS
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * There is a congestion window for outstanding rpcs maintained per mount  * point. The cwnd size is adjusted in roughly the way that:  * Van Jacobson, Congestion avoidance and Control, In "Proceedings of  * SIGCOMM '88". ACM, August 1988.  * describes for TCP. The cwnd size is chopped in half on a retransmit timeout  * and incremented by 1/cwnd when each rpc reply is received and a full cwnd  * of rpcs is in progress.  * (The sent count and cwnd are scaled for integer arith.)  * Variants of "slow start" were tried and were found to be too much of a  * performance hit (ave. rtt 3 times larger),  * I suspect due to the large rtt that nfs rpcs have.  */
end_comment

begin_define
define|#
directive|define
name|NFS_CWNDSCALE
value|256
end_define

begin_define
define|#
directive|define
name|NFS_MAXCWND
value|(NFS_CWNDSCALE * 32)
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_backoff
index|[
literal|8
index|]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrtton
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsrtt
name|nfsrtt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_msg
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_rcvlock
name|__P
argument_list|(
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nfs_rcvunlock
name|__P
argument_list|(
operator|(
name|int
operator|*
name|flagp
operator|,
name|int
operator|*
name|statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nfs_realign
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|int
name|hsiz
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_receive
name|__P
argument_list|(
operator|(
expr|struct
name|nfsreq
operator|*
name|rep
operator|,
expr|struct
name|sockaddr
operator|*
operator|*
name|aname
operator|,
expr|struct
name|mbuf
operator|*
operator|*
name|mp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_reconnect
name|__P
argument_list|(
operator|(
expr|struct
name|nfsreq
operator|*
name|rep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|nfsrv_getstream
name|__P
argument_list|(
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|int
argument_list|(
argument|*nfsrv3_procs[NFS_NPROCS]
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
expr|struct
name|nfsrv_descript
operator|*
name|nd
operator|,
expr|struct
name|nfssvc_sock
operator|*
name|slp
operator|,
expr|struct
name|proc
operator|*
name|procp
operator|,
expr|struct
name|mbuf
operator|*
operator|*
name|mreqp
operator|)
argument_list|)
operator|=
block|{
name|nfsrv_null
block|,
name|nfsrv_getattr
block|,
name|nfsrv_setattr
block|,
name|nfsrv_lookup
block|,
name|nfsrv3_access
block|,
name|nfsrv_readlink
block|,
name|nfsrv_read
block|,
name|nfsrv_write
block|,
name|nfsrv_create
block|,
name|nfsrv_mkdir
block|,
name|nfsrv_symlink
block|,
name|nfsrv_mknod
block|,
name|nfsrv_remove
block|,
name|nfsrv_rmdir
block|,
name|nfsrv_rename
block|,
name|nfsrv_link
block|,
name|nfsrv_readdir
block|,
name|nfsrv_readdirplus
block|,
name|nfsrv_statfs
block|,
name|nfsrv_fsinfo
block|,
name|nfsrv_pathconf
block|,
name|nfsrv_commit
block|,
name|nqnfsrv_getlease
block|,
name|nqnfsrv_vacated
block|,
name|nfsrv_noop
block|,
name|nfsrv_noop
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_comment
comment|/*  * Initialize sockets and congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_function
name|int
name|nfs_connect
parameter_list|(
name|nmp
parameter_list|,
name|rep
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|rcvreserve
decl_stmt|,
name|sndreserve
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int16_t
name|tport
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
operator|&
name|proc0
decl_stmt|;
comment|/* only used for socreate and sobind */
name|nmp
operator|->
name|nm_so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
name|saddr
operator|=
name|nmp
operator|->
name|nm_nam
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|saddr
operator|->
name|sa_family
argument_list|,
operator|&
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_sotype
argument_list|,
name|nmp
operator|->
name|nm_soproto
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
comment|/* 	 * Some servers require that the client port be a reserved port number. 	 */
if|if
condition|(
name|saddr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_RESVPORT
operator|)
condition|)
block|{
name|struct
name|sockaddr_in
name|ssin
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ssin
argument_list|,
sizeof|sizeof
name|ssin
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|&
name|ssin
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|tport
operator|=
name|IPPORT_RESERVED
operator|-
literal|1
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|tport
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|sobind
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|EADDRINUSE
operator|&&
operator|--
name|tport
operator|>
name|IPPORT_RESERVED
operator|/
literal|2
condition|)
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|tport
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Protocols that do not require connections may be optionally left 	 * unconnected for servers that reply from a port other than NFS_PORT. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* XXX should not use mbuf */
name|error
operator|=
name|soconnect
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Wait for the connection to complete. Cribbed from the 		 * connect system call but with the wait timing out so 		 * that interruptible mounts don't hang here for a long time. 		 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
operator|&&
name|rep
operator|&&
operator|(
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_SOFT
operator||
name|NFSMNT_INT
operator|)
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
literal|2
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_SEQPACKET
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
literal|2
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"nfscon sotype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int32_t
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int32_t
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
literal|2
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
literal|2
expr_stmt|;
block|}
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
comment|/* Initialize other non-zero congestion variables */
name|nmp
operator|->
name|nm_srtt
index|[
literal|0
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|1
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|2
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|3
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|4
index|]
operator|=
operator|(
name|NFS_TIMEO
operator|<<
literal|3
operator|)
expr_stmt|;
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|0
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|1
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|2
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|3
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_MAXCWND
operator|/
literal|2
expr_stmt|;
comment|/* Initial send window */
name|nmp
operator|->
name|nm_sent
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_timeouts
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconnect routine:  * Called when a connection is broken on a reliable protocol.  * - clean up the old socket  * - nfs_connect() again  * - set R_MUSTRESEND for all outstanding requests on mount point  * If this fails the mount point is DEAD!  * nb: Must be called with the nfs_sndlock() set on the mount point.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_reconnect
parameter_list|(
name|rep
parameter_list|)
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|rep
operator|->
name|r_nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|nfs_connect
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop through outstanding request list and fix up all requests 	 * on old socket. 	 */
for|for
control|(
name|rp
operator|=
name|nfs_reqq
operator|.
name|tqh_first
init|;
name|rp
operator|!=
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|r_chain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_nmp
operator|==
name|nmp
condition|)
name|rp
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS disconnect. Clean up and unlink.  */
end_comment

begin_function
name|void
name|nfs_disconnect
parameter_list|(
name|nmp
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_so
condition|)
block|{
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nfs_safedisconnect
parameter_list|(
name|nmp
parameter_list|)
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
block|{
name|struct
name|nfsreq
name|dummyreq
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dummyreq
argument_list|,
sizeof|sizeof
argument_list|(
name|dummyreq
argument_list|)
argument_list|)
expr_stmt|;
name|dummyreq
operator|.
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|nfs_rcvlock
argument_list|(
operator|&
name|dummyreq
argument_list|)
expr_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nfs_rcvunlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the nfs send routine. For connection based socket types, it  * must be called with an nfs_sndlock() on the socket.  * "rep == NULL" indicates that it has been called from a server.  * For the client side:  * - return EINTR if the RPC is terminated, 0 otherwise  * - set R_MUSTRESEND if the send fails for any reason  * - do any cleanup required by recoverable socket errors (???)  * For the server side:  * - return EINTR or ERESTART if interrupted by a signal  * - return EPIPE if a connection is lost for connection based sockets (TCP...)  * - do any cleanup required by recoverable socket errors (???)  */
end_comment

begin_function
name|int
name|nfs_send
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|top
parameter_list|,
name|rep
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
block|{
name|struct
name|sockaddr
modifier|*
name|sendnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|soflags
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_MUSTRESEND
expr_stmt|;
name|soflags
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_soflags
expr_stmt|;
block|}
else|else
name|soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
if|if
condition|(
operator|(
name|soflags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
name|sendnam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|sendnam
operator|=
name|nam
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_SEQPACKET
condition|)
name|flags
operator|=
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
argument_list|(
name|so
argument_list|,
name|sendnam
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|curproc
comment|/*XXX*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|rep
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nfs send error %d for server %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
comment|/* 			 * Deal with errors for the client side. 			 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nfsd send error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 		 * Handle any recoverable (soft) socket errors here. (???) 		 */
if|if
condition|(
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
operator|&&
name|error
operator|!=
name|EPIPE
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a Sun RPC Request/Reply. For SOCK_DGRAM, the work is all  * done by soreceive(), but for SOCK_STREAM we must deal with the Record  * Mark and consolidate the data into a new mbuf list.  * nb: Sometimes TCP passes the data up to soreceive() in long lists of  *     small mbufs.  * For SOCK_STREAM we must be very careful to read an entire record once  * we have read any of it, even if the system call has been interrupted.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_receive
parameter_list|(
name|rep
parameter_list|,
name|aname
parameter_list|,
name|mp
parameter_list|)
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|aname
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aio
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|getnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sotype
decl_stmt|,
name|rcvflg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
comment|/* 	 * Set up arguments for soreceive() 	 */
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|aname
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
name|sotype
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_sotype
expr_stmt|;
comment|/* 	 * For reliable protocols, lock against other senders/receivers 	 * in case a reconnect is necessary. 	 * For SOCK_STREAM, first get the Record Mark to find out how much 	 * more there is to get. 	 * We must lock the socket against other receivers 	 * until we have an entire rpc request/reply. 	 */
if|if
condition|(
name|sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
name|error
operator|=
name|nfs_sndlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tryagain
label|:
comment|/* 		 * Check for fatal errors and resending request. 		 */
comment|/* 		 * Ugh: If a reconnect attempt just happened, nm_so 		 * would have changed. NULL indicates a failed 		 * attempt that has essentially shut down this 		 * mount point. 		 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
block|{
name|nfs_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
expr_stmt|;
if|if
condition|(
operator|!
name|so
condition|)
block|{
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nfs_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
goto|goto
name|tryagain
goto|;
block|}
while|while
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
block|{
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|so
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
operator|||
operator|(
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nfs_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
goto|goto
name|tryagain
goto|;
block|}
block|}
name|nfs_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|aio
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|len
expr_stmt|;
name|aio
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aio
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* 			     * Don't log a 0 byte receive; it means 			     * that the socket has been closed, and 			     * can happen during normal operation 			     * (forcible unmount or Solaris server). 			     */
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|!=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"short receive (%d/%d) from nfs server %s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|auio
operator|.
name|uio_resid
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|errout
goto|;
name|len
operator|=
name|ntohl
argument_list|(
name|len
argument_list|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
comment|/* 			 * This is SERIOUS! We are out of sync with the sender 			 * and forcing a disconnect/reconnect is all I can do. 			 */
if|if
condition|(
name|len
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s (%d) from nfs server %s\n"
argument_list|,
literal|"impossible packet length"
argument_list|,
name|len
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|auio
operator|.
name|uio_resid
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"short receive (%d/%d) from nfs server %s\n"
argument_list|,
name|len
operator|-
name|auio
operator|.
name|uio_resid
argument_list|,
name|len
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * NB: Since uio_resid is big, MSG_WAITALL is ignored 			 * and soreceive() will return when it has either a 			 * control msg or a data msg. 			 * We have no use for control msg., but must grab them 			 * and then throw them away so we know what is going 			 * on. 			 */
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|100000000
expr_stmt|;
comment|/* Anything Big */
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|&
name|control
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
operator|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
operator|&&
name|control
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|rcvflg
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Egad!!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
name|errout
label|:
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EPIPE
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receive error %d from nfs server %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_sndlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|tryagain
goto|;
else|else
name|nfs_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
name|getnam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|getnam
operator|=
name|aname
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
name|getnam
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 	 * Search for any mbufs that are not a multiple of 4 bytes long 	 * or with m_data not longword aligned. 	 * These could cause pointer alignment problems, so copy them to 	 * well aligned mbufs. 	 */
name|nfs_realign
argument_list|(
operator|*
name|mp
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement receipt of reply on a socket.  * We must search through the list of received datagrams matching them  * with outstanding requests using the xid, until ours is found.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|nfs_reply
parameter_list|(
name|myrep
parameter_list|)
name|struct
name|nfsreq
modifier|*
name|myrep
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|myrep
operator|->
name|r_nmp
decl_stmt|;
specifier|register
name|int32_t
name|t1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|u_int32_t
name|rxid
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Loop around until we get our own reply 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Lock against other receivers so that I don't get stuck in 		 * sbwait() after someone else has received my reply for me. 		 * Also necessary for connection based protocols to avoid 		 * race conditions during a reconnect. 		 * If nfs_rcvlock() returns EALREADY, that means that 		 * the reply has already been recieved by another 		 * process and we can return immediately.  In this 		 * case, the lock is not taken to avoid races with 		 * other processes. 		 */
name|error
operator|=
name|nfs_rcvlock
argument_list|(
name|myrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EALREADY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Get the next Rpc reply off the socket 		 */
name|error
operator|=
name|nfs_receive
argument_list|(
name|myrep
argument_list|,
operator|&
name|nam
argument_list|,
operator|&
name|mrep
argument_list|)
expr_stmt|;
name|nfs_rcvunlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Ignore routing errors on connectionless protocols?? 			 */
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|nmp
operator|->
name|nm_so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nam
condition|)
name|FREE
argument_list|(
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
comment|/* 		 * Get the xid and check that it is an rpc reply 		 */
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|rxid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
name|rpc_reply
condition|)
block|{
ifndef|#
directive|ifndef
name|NFS_NOSERVER
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
condition|)
block|{
if|if
condition|(
name|nqnfs_callback
argument_list|(
name|nmp
argument_list|,
name|mrep
argument_list|,
name|md
argument_list|,
name|dpos
argument_list|)
condition|)
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
block|}
else|else
block|{
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nfsmout
label|:
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * Loop through the request list to match up the reply 		 * Iff no match, just drop the datagram 		 */
for|for
control|(
name|rep
operator|=
name|nfs_reqq
operator|.
name|tqh_first
init|;
name|rep
operator|!=
literal|0
condition|;
name|rep
operator|=
name|rep
operator|->
name|r_chain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|rxid
operator|==
name|rep
operator|->
name|r_xid
condition|)
block|{
comment|/* Found it.. */
name|rep
operator|->
name|r_mrep
operator|=
name|mrep
expr_stmt|;
name|rep
operator|->
name|r_md
operator|=
name|md
expr_stmt|;
name|rep
operator|->
name|r_dpos
operator|=
name|dpos
expr_stmt|;
if|if
condition|(
name|nfsrtton
condition|)
block|{
name|struct
name|rttl
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
operator|&
name|nfsrtt
operator|.
name|rttl
index|[
name|nfsrtt
operator|.
name|pos
index|]
expr_stmt|;
name|rt
operator|->
name|proc
operator|=
name|rep
operator|->
name|r_procnum
expr_stmt|;
name|rt
operator|->
name|rto
operator|=
name|NFS_RTO
argument_list|(
name|nmp
argument_list|,
name|proct
index|[
name|rep
operator|->
name|r_procnum
index|]
argument_list|)
expr_stmt|;
name|rt
operator|->
name|sent
operator|=
name|nmp
operator|->
name|nm_sent
expr_stmt|;
name|rt
operator|->
name|cwnd
operator|=
name|nmp
operator|->
name|nm_cwnd
expr_stmt|;
name|rt
operator|->
name|srtt
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
name|proct
index|[
name|rep
operator|->
name|r_procnum
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|rt
operator|->
name|sdrtt
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
name|proct
index|[
name|rep
operator|->
name|r_procnum
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|rt
operator|->
name|fsid
operator|=
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|rt
operator|->
name|tstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
name|rt
operator|->
name|rtt
operator|=
name|rep
operator|->
name|r_rtt
expr_stmt|;
else|else
name|rt
operator|->
name|rtt
operator|=
literal|1000000
expr_stmt|;
name|nfsrtt
operator|.
name|pos
operator|=
operator|(
name|nfsrtt
operator|.
name|pos
operator|+
literal|1
operator|)
operator|%
name|NFSRTTLOGSIZ
expr_stmt|;
block|}
comment|/* 				 * Update congestion window. 				 * Do the additive increase of 				 * one rpc/rtt. 				 */
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|<=
name|nmp
operator|->
name|nm_sent
condition|)
block|{
name|nmp
operator|->
name|nm_cwnd
operator|+=
operator|(
name|NFS_CWNDSCALE
operator|*
name|NFS_CWNDSCALE
operator|+
operator|(
name|nmp
operator|->
name|nm_cwnd
operator|>>
literal|1
operator|)
operator|)
operator|/
name|nmp
operator|->
name|nm_cwnd
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|>
name|NFS_MAXCWND
condition|)
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_MAXCWND
expr_stmt|;
block|}
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
comment|/* 				 * Update rtt using a gain of 0.125 on the mean 				 * and a gain of 0.25 on the deviation. 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
comment|/* 					 * Since the timer resolution of 					 * NFS_HZ is so course, it can often 					 * result in r_rtt == 0. Since 					 * r_rtt == N means that the actual 					 * rtt is between N+dt and N+2-dt ticks, 					 * add 1. 					 */
name|t1
operator|=
name|rep
operator|->
name|r_rtt
operator|+
literal|1
expr_stmt|;
name|t1
operator|-=
operator|(
name|NFS_SRTT
argument_list|(
name|rep
argument_list|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|NFS_SRTT
argument_list|(
name|rep
argument_list|)
operator|+=
name|t1
expr_stmt|;
if|if
condition|(
name|t1
operator|<
literal|0
condition|)
name|t1
operator|=
operator|-
name|t1
expr_stmt|;
name|t1
operator|-=
operator|(
name|NFS_SDRTT
argument_list|(
name|rep
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|NFS_SDRTT
argument_list|(
name|rep
argument_list|)
operator|+=
name|t1
expr_stmt|;
block|}
name|nmp
operator|->
name|nm_timeouts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If not matched to a request, drop it. 		 * If it's mine, get out. 		 */
if|if
condition|(
name|rep
operator|==
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpcunexpected
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|==
name|myrep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsreply nil"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_send() for first transmit  *	- calls nfs_receive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_function
name|int
name|nfs_request
parameter_list|(
name|vp
parameter_list|,
name|mrest
parameter_list|,
name|procnum
parameter_list|,
name|procp
parameter_list|,
name|cred
parameter_list|,
name|mrp
parameter_list|,
name|mdp
parameter_list|,
name|dposp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrest
decl_stmt|;
name|int
name|procnum
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mrep
decl_stmt|;
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|,
modifier|*
name|mheadend
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|char
name|nickv
index|[
name|RPCX_NICKVERF
index|]
decl_stmt|;
name|time_t
name|reqtime
decl_stmt|,
name|waituntil
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|t1
decl_stmt|,
name|nqlflag
decl_stmt|,
name|cachable
decl_stmt|,
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|mrest_len
decl_stmt|,
name|auth_len
decl_stmt|,
name|auth_type
decl_stmt|;
name|int
name|trylater_delay
init|=
name|NQ_TRYLATERDEL
decl_stmt|,
name|trylater_cnt
init|=
literal|0
decl_stmt|,
name|failed_auth
init|=
literal|0
decl_stmt|;
name|int
name|verf_len
decl_stmt|,
name|verf_type
decl_stmt|;
name|u_int32_t
name|xid
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
name|char
modifier|*
name|auth_str
decl_stmt|,
modifier|*
name|verf_str
decl_stmt|;
name|NFSKERBKEY_T
name|key
decl_stmt|;
comment|/* save session key */
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|rep
argument_list|,
expr|struct
name|nfsreq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|rep
operator|->
name|r_vp
operator|=
name|vp
expr_stmt|;
name|rep
operator|->
name|r_procp
operator|=
name|procp
expr_stmt|;
name|rep
operator|->
name|r_procnum
operator|=
name|procnum
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|mrest
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|mrest_len
operator|=
name|i
expr_stmt|;
comment|/* 	 * Get the RPC header with authorization. 	 */
name|kerbauth
label|:
name|verf_str
operator|=
name|auth_str
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_KERB
condition|)
block|{
name|verf_str
operator|=
name|nickv
expr_stmt|;
name|verf_len
operator|=
sizeof|sizeof
argument_list|(
name|nickv
argument_list|)
expr_stmt|;
name|auth_type
operator|=
name|RPCAUTH_KERB4
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed_auth
operator|||
name|nfs_getnickauth
argument_list|(
name|nmp
argument_list|,
name|cred
argument_list|,
operator|&
name|auth_str
argument_list|,
operator|&
name|auth_len
argument_list|,
name|verf_str
argument_list|,
name|verf_len
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfs_getauth
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|cred
argument_list|,
operator|&
name|auth_str
argument_list|,
operator|&
name|auth_len
argument_list|,
name|verf_str
argument_list|,
operator|&
name|verf_len
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrest
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|auth_type
operator|=
name|RPCAUTH_UNIX
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_ngroups
operator|<
literal|1
condition|)
name|panic
argument_list|(
literal|"nfsreq nogrps"
argument_list|)
expr_stmt|;
name|auth_len
operator|=
operator|(
operator|(
operator|(
operator|(
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
operator|)
operator|>
name|nmp
operator|->
name|nm_numgrps
operator|)
condition|?
name|nmp
operator|->
name|nm_numgrps
else|:
operator|(
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|5
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
block|}
name|m
operator|=
name|nfsm_rpchead
argument_list|(
name|cred
argument_list|,
name|nmp
operator|->
name|nm_flag
argument_list|,
name|procnum
argument_list|,
name|auth_type
argument_list|,
name|auth_len
argument_list|,
name|auth_str
argument_list|,
name|verf_len
argument_list|,
name|verf_str
argument_list|,
name|mrest
argument_list|,
name|mrest_len
argument_list|,
operator|&
name|mheadend
argument_list|,
operator|&
name|xid
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_str
condition|)
name|free
argument_list|(
name|auth_str
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* 	 * For stream protocols, insert a Sun RPC Record Mark. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|NFSX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
block|}
name|rep
operator|->
name|r_mreq
operator|=
name|m
expr_stmt|;
name|rep
operator|->
name|r_xid
operator|=
name|xid
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
condition|)
name|rep
operator|->
name|r_retry
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
else|else
name|rep
operator|->
name|r_retry
operator|=
name|NFS_MAXREXMIT
operator|+
literal|1
expr_stmt|;
comment|/* past clip limit */
name|rep
operator|->
name|r_rtt
operator|=
name|rep
operator|->
name|r_rexmit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proct
index|[
name|procnum
index|]
operator|>
literal|0
condition|)
name|rep
operator|->
name|r_flags
operator|=
name|R_TIMING
expr_stmt|;
else|else
name|rep
operator|->
name|r_flags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Do the client side RPC. 	 */
name|nfsstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
comment|/* 	 * Chain request into list of outstanding requests. Be sure 	 * to put it LAST so timer finds oldest requests first. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfs_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
comment|/* Get send time for nqnfs */
name|reqtime
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * If backing off another request or avoiding congestion, don't 	 * send this one now but let timer do it. If not timing a request, 	 * do it now. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_so
operator|&&
operator|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
operator|||
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
operator|)
operator|||
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_cwnd
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|error
operator|=
name|nfs_sndlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|nmp
operator|->
name|nm_state
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|m
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|nfs_sndunlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|,
operator|&
name|nmp
operator|->
name|nm_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_sent
operator|+=
name|NFS_CWNDSCALE
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
block|}
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Wait for the reply from our send or the timer's. 	 */
if|if
condition|(
operator|!
name|error
operator|||
name|error
operator|==
name|EPIPE
condition|)
name|error
operator|=
name|nfs_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
comment|/* 	 * RPC done, unlink the request. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfs_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the outstanding request count. 	 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
comment|/* paranoia */
name|nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
comment|/* 	 * If there was a successful reply and a tprintf msg. 	 * tprintf a response. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
condition|)
name|nfs_msg
argument_list|(
name|rep
operator|->
name|r_procp
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
literal|"is alive again"
argument_list|)
expr_stmt|;
name|mrep
operator|=
name|rep
operator|->
name|r_mrep
expr_stmt|;
name|md
operator|=
name|rep
operator|->
name|r_md
expr_stmt|;
name|dpos
operator|=
name|rep
operator|->
name|r_dpos
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * break down the rpc header and check if ok 	 */
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|==
name|rpc_msgdenied
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|rpc_mismatch
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_KERB
operator|)
operator|&&
operator|*
name|tl
operator|++
operator|==
name|rpc_autherr
condition|)
block|{
if|if
condition|(
operator|!
name|failed_auth
condition|)
block|{
name|failed_auth
operator|++
expr_stmt|;
name|mheadend
operator|->
name|m_next
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
goto|goto
name|kerbauth
goto|;
block|}
else|else
name|error
operator|=
name|EAUTH
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Grab any Kerberos verifier, otherwise just throw it away. 	 */
name|verf_type
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_KERB
operator|)
operator|&&
name|verf_type
operator|==
name|RPCAUTH_KERB4
condition|)
block|{
name|error
operator|=
name|nfs_savenickauth
argument_list|(
name|nmp
argument_list|,
name|cred
argument_list|,
name|i
argument_list|,
name|key
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|,
name|mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 0 == ok */
if|if
condition|(
operator|*
name|tl
operator|==
literal|0
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
operator|&&
name|error
operator|==
name|NFSERR_TRYLATER
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|waituntil
operator|=
name|time_second
operator|+
name|trylater_delay
expr_stmt|;
while|while
condition|(
name|time_second
operator|<
name|waituntil
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nqnfstry"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trylater_delay
operator|*=
name|nfs_backoff
index|[
name|trylater_cnt
index|]
expr_stmt|;
if|if
condition|(
name|trylater_cnt
operator|<
literal|7
condition|)
name|trylater_cnt
operator|++
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* 			 * If the File Handle was stale, invalidate the 			 * lookup cache, just in case. 			 */
if|if
condition|(
name|error
operator|==
name|ESTALE
condition|)
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|error
operator||=
name|NFSERR_RETERR
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * For nqnfs, get any lease in reply 		 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nqlflag
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cachable
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|reqtime
operator|+=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqtime
operator|>
name|time_second
condition|)
block|{
name|fxdr_hyper
argument_list|(
name|tl
argument_list|,
operator|&
name|frev
argument_list|)
expr_stmt|;
name|nqnfs_clientlease
argument_list|(
name|nmp
argument_list|,
name|np
argument_list|,
name|nqlflag
argument_list|,
name|cachable
argument_list|,
name|reqtime
argument_list|,
name|frev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
name|nfsmout
label|:
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Generate the rpc reply header  * siz arg. is used to decide if adding a cluster is worthwhile  */
end_comment

begin_function
name|int
name|nfs_rephead
parameter_list|(
name|siz
parameter_list|,
name|nd
parameter_list|,
name|slp
parameter_list|,
name|err
parameter_list|,
name|cache
parameter_list|,
name|frev
parameter_list|,
name|mrq
parameter_list|,
name|mbp
parameter_list|,
name|bposp
parameter_list|)
name|int
name|siz
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|cache
decl_stmt|;
name|u_quad_t
modifier|*
name|frev
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mbp
decl_stmt|;
name|caddr_t
modifier|*
name|bposp
decl_stmt|;
block|{
specifier|register
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|MGETHDR
argument_list|(
name|mreq
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mb
operator|=
name|mreq
expr_stmt|;
comment|/* 	 * If this is a big reply, use a cluster else 	 * try and leave leading space for the lower level headers. 	 */
name|siz
operator|+=
name|RPC_REPLYSIZ
expr_stmt|;
if|if
condition|(
name|siz
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|mreq
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
name|mreq
operator|->
name|m_data
operator|+=
name|max_hdr
expr_stmt|;
name|tl
operator|=
name|mtod
argument_list|(
name|mreq
argument_list|,
name|u_int32_t
operator|*
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|m_len
operator|=
literal|6
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|bpos
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|tl
operator|)
operator|+
name|mreq
operator|->
name|m_len
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_retxid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|rpc_reply
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERPCMISMATCH
operator|||
operator|(
name|err
operator|&
name|NFSERR_AUTHERR
operator|)
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|rpc_msgdenied
expr_stmt|;
if|if
condition|(
name|err
operator|&
name|NFSERR_AUTHERR
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|rpc_autherr
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|err
operator|&
operator|~
name|NFSERR_AUTHERR
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|m_len
operator|-=
name|NFSX_UNSIGNED
expr_stmt|;
name|bpos
operator|-=
name|NFSX_UNSIGNED
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|++
operator|=
name|rpc_mismatch
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_VER2
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_VER2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|tl
operator|++
operator|=
name|rpc_msgaccepted
expr_stmt|;
comment|/* 		 * For Kerberos authentication, we must send the nickname 		 * verifier back, otherwise just RPCAUTH_NULL. 		 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_KERBFULL
condition|)
block|{
specifier|register
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|;
name|struct
name|timeval
name|ktvin
decl_stmt|,
name|ktvout
decl_stmt|;
for|for
control|(
name|nuidp
operator|=
name|NUIDHASH
argument_list|(
name|slp
argument_list|,
name|nd
operator|->
name|nd_cr
operator|.
name|cr_uid
argument_list|)
operator|->
name|lh_first
init|;
name|nuidp
operator|!=
literal|0
condition|;
name|nuidp
operator|=
name|nuidp
operator|->
name|nu_hash
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_uid
operator|==
name|nd
operator|->
name|nd_cr
operator|.
name|cr_uid
operator|&&
operator|(
operator|!
name|nd
operator|->
name|nd_nam2
operator|||
name|netaddr_match
argument_list|(
name|NU_NETFAM
argument_list|(
name|nuidp
argument_list|)
argument_list|,
operator|&
name|nuidp
operator|->
name|nu_haddr
argument_list|,
name|nd
operator|->
name|nd_nam2
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|nuidp
condition|)
block|{
name|ktvin
operator|.
name|tv_sec
operator|=
name|txdr_unsigned
argument_list|(
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_sec
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ktvin
operator|.
name|tv_usec
operator|=
name|txdr_unsigned
argument_list|(
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* 			 * Encrypt the timestamp in ecb mode using the 			 * session key. 			 */
ifdef|#
directive|ifdef
name|NFSKERB
name|XXX
endif|#
directive|endif
operator|*
name|tl
operator|++
operator|=
name|rpc_auth_kerb
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|ktvout
operator|.
name|tv_sec
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|ktvout
operator|.
name|tv_usec
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EPROGUNAVAIL
case|:
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGUNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPROGMISMATCH
case|:
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROGMISMATCH
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NQNFS
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EPROCUNAVAIL
case|:
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_PROCUNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBADRPC
case|:
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_GARBAGE
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|NFSERR_RETVOID
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nfsrv_errmap
argument_list|(
name|nd
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
block|}
comment|/* 	 * For nqnfs, piggyback lease as requested. 	 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NQNFS
operator|)
operator|&&
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_LEASE
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_LEASE
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|cache
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_duration
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|frev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mrq
operator|!=
name|NULL
condition|)
operator|*
name|mrq
operator|=
name|mreq
expr_stmt|;
operator|*
name|mbp
operator|=
name|mb
expr_stmt|;
operator|*
name|bposp
operator|=
name|bpos
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|NFSERR_RETVOID
condition|)
name|nfsstats
operator|.
name|srvrpc_errs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_comment
comment|/*  * Nfs timer routine  * Scan the nfsreq list and retranmit any requests that have timed out  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0 (implies nm_retry == 0).  */
end_comment

begin_function
name|void
name|nfs_timer
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* never used */
block|{
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|int
name|timeo
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
ifndef|#
directive|ifndef
name|NFS_NOSERVER
specifier|static
name|long
name|lasttime
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|u_quad_t
name|cur_usec
decl_stmt|;
endif|#
directive|endif
comment|/* NFS_NOSERVER */
name|struct
name|proc
modifier|*
name|p
init|=
operator|&
name|proc0
decl_stmt|;
comment|/* XXX for credentials, will break if sleep */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|rep
operator|=
name|nfs_reqq
operator|.
name|tqh_first
init|;
name|rep
operator|!=
literal|0
condition|;
name|rep
operator|=
name|rep
operator|->
name|r_chain
operator|.
name|tqe_next
control|)
block|{
name|nmp
operator|=
name|rep
operator|->
name|r_nmp
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|>=
literal|0
condition|)
block|{
name|rep
operator|->
name|r_rtt
operator|++
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
condition|)
name|timeo
operator|=
name|nmp
operator|->
name|nm_timeo
expr_stmt|;
else|else
name|timeo
operator|=
name|NFS_RTO
argument_list|(
name|nmp
argument_list|,
name|proct
index|[
name|rep
operator|->
name|r_procnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_timeouts
operator|>
literal|0
condition|)
name|timeo
operator|*=
name|nfs_backoff
index|[
name|nmp
operator|->
name|nm_timeouts
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|<=
name|timeo
condition|)
continue|continue;
if|if
condition|(
name|nmp
operator|->
name|nm_timeouts
operator|<
literal|8
condition|)
name|nmp
operator|->
name|nm_timeouts
operator|++
expr_stmt|;
block|}
comment|/* 		 * Check for server not responding 		 */
if|if
condition|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
operator|==
literal|0
operator|&&
name|rep
operator|->
name|r_rexmit
operator|>
name|nmp
operator|->
name|nm_deadthresh
condition|)
block|{
name|nfs_msg
argument_list|(
name|rep
operator|->
name|r_procp
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
literal|"not responding"
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TPRINTFMSG
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rexmit
operator|>=
name|rep
operator|->
name|r_retry
condition|)
block|{
comment|/* too many */
name|nfsstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * If there is enough space and the window allows.. 		 *	Resend it 		 * Set r_rtt to -1 in case we fail to send it now. 		 */
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>=
name|rep
operator|->
name|r_mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|&&
operator|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
operator|)
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
operator|)
operator|||
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_cwnd
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Iff first send, start timing 				 * else turn timing off, backoff timer 				 * and divide congestion window by 2. 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
name|nmp
operator|->
name|nm_cwnd
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|<
name|NFS_CWNDSCALE
condition|)
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_CWNDSCALE
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|+=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
name|rep
operator|->
name|r_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|NFS_NOSERVER
comment|/* 	 * Call the nqnfs server timer once a second to handle leases. 	 */
if|if
condition|(
name|lasttime
operator|!=
name|time_second
condition|)
block|{
name|lasttime
operator|=
name|time_second
expr_stmt|;
name|nqnfs_serverd
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Scan the write gathering queues for writes that need to be 	 * completed now. 	 */
name|cur_usec
operator|=
name|nfs_curusec
argument_list|()
expr_stmt|;
for|for
control|(
name|slp
operator|=
name|nfssvc_sockhead
operator|.
name|tqh_first
init|;
name|slp
operator|!=
literal|0
condition|;
name|slp
operator|=
name|slp
operator|->
name|ns_chain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
operator|&&
name|slp
operator|->
name|ns_tq
operator|.
name|lh_first
operator|->
name|nd_time
operator|<=
name|cur_usec
condition|)
name|nfsrv_wakenfsd
argument_list|(
name|slp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NFS_NOSERVER */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|nfs_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|nfs_ticks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test for a termination condition pending on the process.  * This is used for NFSMNT_INT mounts.  */
end_comment

begin_function
name|int
name|nfs_sigintr
parameter_list|(
name|nmp
parameter_list|,
name|rep
parameter_list|,
name|p
parameter_list|)
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|rep
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|p_siglist
operator|&&
operator|(
operator|(
operator|(
name|p
operator|->
name|p_siglist
operator|&
operator|~
name|p
operator|->
name|p_sigmask
operator|)
operator|&
operator|~
name|p
operator|->
name|p_sigignore
operator|)
operator|&
name|NFSINT_SIGMASK
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a socket against others.  * Necessary for STREAM sockets to ensure you get an entire rpc request/reply  * and also to avoid race conditions between the processes with nfs requests  * in progress when a reconnect is necessary.  */
end_comment

begin_function
name|int
name|nfs_sndlock
parameter_list|(
name|flagp
parameter_list|,
name|statep
parameter_list|,
name|rep
parameter_list|)
specifier|register
name|int
modifier|*
name|flagp
decl_stmt|;
specifier|register
name|int
modifier|*
name|statep
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|slpflag
init|=
literal|0
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|p
operator|=
name|rep
operator|->
name|r_procp
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_SNDLOCK
condition|)
block|{
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|,
name|rep
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|*
name|statep
operator||=
name|NFSSTA_WANTSND
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsndlck"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
operator|*
name|statep
operator||=
name|NFSSTA_SNDLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
name|void
name|nfs_sndunlock
parameter_list|(
name|flagp
parameter_list|,
name|statep
parameter_list|)
specifier|register
name|int
modifier|*
name|flagp
decl_stmt|;
specifier|register
name|int
modifier|*
name|statep
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|statep
operator|&
name|NFSSTA_SNDLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs sndunlock"
argument_list|)
expr_stmt|;
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_SNDLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_WANTSND
condition|)
block|{
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_WANTSND
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_rcvlock
parameter_list|(
name|rep
parameter_list|)
specifier|register
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|flagp
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
decl_stmt|;
specifier|register
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
name|int
name|slpflag
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
else|else
name|slpflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_RCVLOCK
condition|)
block|{
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_procp
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|*
name|statep
operator||=
name|NFSSTA_WANTRCV
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsrcvlk"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
comment|/* 		 * If our reply was recieved while we were sleeping, 		 * then just return without taking the lock to avoid a 		 * situation where a single iod could 'capture' the 		 * recieve lock. 		 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
operator|*
name|statep
operator||=
name|NFSSTA_RCVLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_rcvunlock
parameter_list|(
name|flagp
parameter_list|,
name|statep
parameter_list|)
specifier|register
name|int
modifier|*
name|flagp
decl_stmt|;
specifier|register
name|int
modifier|*
name|statep
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|statep
operator|&
name|NFSSTA_RCVLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs rcvunlock"
argument_list|)
expr_stmt|;
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_RCVLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_WANTRCV
condition|)
block|{
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_WANTRCV
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check for badly aligned mbuf data areas and  * realign data in an mbuf list by copying the data areas up, as required.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_realign
parameter_list|(
name|m
parameter_list|,
name|hsiz
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|hsiz
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
specifier|register
name|int
name|siz
decl_stmt|,
name|mlen
decl_stmt|,
name|olen
decl_stmt|;
specifier|register
name|caddr_t
name|tcp
decl_stmt|,
name|fcp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mnew
decl_stmt|;
while|while
condition|(
name|m
condition|)
block|{
comment|/* 	     * This never happens for UDP, rarely happens for TCP 	     * but frequently happens for iso transport. 	     */
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|intptr_t
argument_list|)
operator|&
literal|0x3
operator|)
condition|)
block|{
name|olen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|fcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|fcp
operator|&
literal|0x3
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|+
operator|(
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_size
operator|-
name|olen
operator|)
operator|&
operator|~
literal|0x3
operator|)
expr_stmt|;
else|else
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|tcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|mnew
operator|=
name|m
expr_stmt|;
name|m2
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* 		 * If possible, only put the first invariant part 		 * of the RPC header in the first mbuf. 		 */
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<=
name|hsiz
operator|&&
name|mlen
operator|>
name|hsiz
condition|)
name|mlen
operator|=
name|hsiz
expr_stmt|;
comment|/* 		 * Loop through the mbuf list consolidating data. 		 */
while|while
condition|(
name|m
condition|)
block|{
while|while
condition|(
name|olen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mlen
operator|==
literal|0
condition|)
block|{
name|m2
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
if|if
condition|(
name|m2
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m2
operator|->
name|m_data
operator|=
name|m2
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
else|else
name|m2
operator|->
name|m_data
operator|=
name|m2
operator|->
name|m_dat
expr_stmt|;
name|m2
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|tcp
operator|=
name|mtod
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|mnew
operator|=
name|m2
expr_stmt|;
name|m2
operator|=
name|m2
operator|->
name|m_next
expr_stmt|;
block|}
name|siz
operator|=
name|min
argument_list|(
name|mlen
argument_list|,
name|olen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp
operator|!=
name|fcp
condition|)
name|bcopy
argument_list|(
name|fcp
argument_list|,
name|tcp
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|mnew
operator|->
name|m_len
operator|+=
name|siz
expr_stmt|;
name|mlen
operator|-=
name|siz
expr_stmt|;
name|olen
operator|-=
name|siz
expr_stmt|;
name|tcp
operator|+=
name|siz
expr_stmt|;
name|fcp
operator|+=
name|siz
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|olen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|fcp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Finally, set m_len == 0 for any trailing mbufs that have 		 * been copied out of. 		 */
while|while
condition|(
name|m2
condition|)
block|{
name|m2
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m2
operator|=
name|m2
operator|->
name|m_next
expr_stmt|;
block|}
return|return;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Parse an RPC request  * - verify it  * - fill in the cred struct.  */
end_comment

begin_function
name|int
name|nfs_getreq
parameter_list|(
name|nd
parameter_list|,
name|nfsd
parameter_list|,
name|has_header
parameter_list|)
specifier|register
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
name|struct
name|nfsd
modifier|*
name|nfsd
decl_stmt|;
name|int
name|has_header
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int32_t
name|t1
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|,
name|cp
decl_stmt|;
name|u_int32_t
name|nfsvers
decl_stmt|,
name|auth_type
decl_stmt|;
name|uid_t
name|nickuid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|nqnfs
init|=
literal|0
decl_stmt|,
name|ticklen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
specifier|register
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|;
name|struct
name|timeval
name|tvin
decl_stmt|,
name|tvout
decl_stmt|;
if|#
directive|if
literal|0
comment|/* until encrypted keys are implemented */
block|NFSKERBKEYSCHED_T keys;
comment|/* stores key schedule */
endif|#
directive|endif
name|mrep
operator|=
name|nd
operator|->
name|nd_mrep
expr_stmt|;
name|md
operator|=
name|nd
operator|->
name|nd_md
expr_stmt|;
name|dpos
operator|=
name|nd
operator|->
name|nd_dpos
expr_stmt|;
if|if
condition|(
name|has_header
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|10
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_retxid
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|!=
name|rpc_call
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
block|}
else|else
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|8
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|!=
name|rpc_vers
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|ERPCMISMATCH
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|tl
operator|!=
name|nfs_prog
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|nqnfs_prog
condition|)
name|nqnfs
operator|++
expr_stmt|;
else|else
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EPROGUNAVAIL
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|tl
operator|++
expr_stmt|;
name|nfsvers
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nfsvers
operator|<
name|NFS_VER2
operator|||
name|nfsvers
operator|>
name|NFS_VER3
operator|)
operator|&&
operator|!
name|nqnfs
operator|)
operator|||
operator|(
name|nfsvers
operator|!=
name|NQNFS_VER3
operator|&&
name|nqnfs
operator|)
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EPROGMISMATCH
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nqnfs
condition|)
name|nd
operator|->
name|nd_flag
operator|=
operator|(
name|ND_NFSV3
operator||
name|ND_NQNFS
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nfsvers
operator|==
name|NFS_VER3
condition|)
name|nd
operator|->
name|nd_flag
operator|=
name|ND_NFSV3
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|>=
name|NFS_NPROCS
operator|||
operator|(
operator|!
name|nqnfs
operator|&&
name|nd
operator|->
name|nd_procnum
operator|>=
name|NQNFSPROC_GETLEASE
operator|)
operator|||
operator|(
operator|!
name|nd
operator|->
name|nd_flag
operator|&&
name|nd
operator|->
name|nd_procnum
operator|>
name|NFSV2PROC_STATFS
operator|)
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EPROCUNAVAIL
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|==
literal|0
condition|)
name|nd
operator|->
name|nd_procnum
operator|=
name|nfsv3_procid
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
name|auth_type
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|RPCAUTH_MAXSIZ
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nd
operator|->
name|nd_flag
operator|&=
operator|~
name|ND_KERBAUTH
expr_stmt|;
comment|/* 	 * Handle auth_unix or auth_kerb. 	 */
if|if
condition|(
name|auth_type
operator|==
name|rpc_auth_unix
condition|)
block|{
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nd
operator|->
name|nd_cr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ucred
argument_list|)
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ref
operator|=
literal|1
expr_stmt|;
name|nd
operator|->
name|nd_cr
operator|.
name|cr_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_cr
operator|.
name|cr_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|RPCAUTH_UNIXGIDS
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
operator|(
name|len
operator|+
literal|2
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|<
name|NGROUPS
condition|)
name|nd
operator|->
name|nd_cr
operator|.
name|cr_groups
index|[
name|i
index|]
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
else|else
name|tl
operator|++
expr_stmt|;
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ngroups
operator|=
operator|(
name|len
operator|>=
name|NGROUPS
operator|)
condition|?
name|NGROUPS
else|:
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ngroups
operator|>
literal|1
condition|)
name|nfsrvw_sort
argument_list|(
name|nd
operator|->
name|nd_cr
operator|.
name|cr_groups
argument_list|,
name|nd
operator|->
name|nd_cr
operator|.
name|cr_ngroups
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|RPCAUTH_MAXSIZ
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auth_type
operator|==
name|rpc_auth_kerb
condition|)
block|{
switch|switch
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
condition|)
block|{
case|case
name|RPCAKN_FULLNAME
case|:
name|ticklen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|nfsd
operator|->
name|nfsd_authstr
operator|)
operator|=
operator|*
name|tl
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|nfsm_rndup
argument_list|(
name|ticklen
argument_list|)
operator|+
name|NFSX_UNSIGNED
expr_stmt|;
name|nfsd
operator|->
name|nfsd_authlen
operator|=
name|uio
operator|.
name|uio_resid
operator|+
name|NFSX_UNSIGNED
expr_stmt|;
if|if
condition|(
name|uio
operator|.
name|uio_resid
operator|>
operator|(
name|len
operator|-
literal|2
operator|*
name|NFSX_UNSIGNED
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|nfsd
operator|->
name|nfsd_authstr
index|[
literal|4
index|]
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|RPCAUTH_MAXSIZ
operator|-
literal|4
expr_stmt|;
name|nfsm_mtouio
argument_list|(
operator|&
name|uio
argument_list|,
name|uio
operator|.
name|uio_resid
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|!=
name|rpc_auth_kerb
operator|||
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
literal|4
operator|*
name|NFSX_UNSIGNED
condition|)
block|{
name|printf
argument_list|(
literal|"Bad kerb verifier\n"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_BADVERF
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nfsm_dissect
argument_list|(
name|cp
argument_list|,
name|caddr_t
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
name|RPCAKN_FULLNAME
condition|)
block|{
name|printf
argument_list|(
literal|"Not fullname kerb verifier\n"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_BADVERF
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|nfsd
operator|->
name|nfsd_verfstr
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsd
operator|->
name|nfsd_verflen
operator|=
literal|3
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_KERBFULL
expr_stmt|;
name|nfsd
operator|->
name|nfsd_flag
operator||=
name|NFSD_NEEDAUTH
expr_stmt|;
break|break;
case|case
name|RPCAKN_NICKNAME
case|:
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
name|NFSX_UNSIGNED
condition|)
block|{
name|printf
argument_list|(
literal|"Kerb nickname short\n"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_BADCRED
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nickuid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|!=
name|rpc_auth_kerb
operator|||
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
literal|3
operator|*
name|NFSX_UNSIGNED
condition|)
block|{
name|printf
argument_list|(
literal|"Kerb nick verifier bad\n"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_BADVERF
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tvin
operator|.
name|tv_sec
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|tvin
operator|.
name|tv_usec
operator|=
operator|*
name|tl
expr_stmt|;
for|for
control|(
name|nuidp
operator|=
name|NUIDHASH
argument_list|(
name|nfsd
operator|->
name|nfsd_slp
argument_list|,
name|nickuid
argument_list|)
operator|->
name|lh_first
init|;
name|nuidp
operator|!=
literal|0
condition|;
name|nuidp
operator|=
name|nuidp
operator|->
name|nu_hash
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|nuidp
operator|->
name|nu_cr
operator|.
name|cr_uid
operator|==
name|nickuid
operator|&&
operator|(
operator|!
name|nd
operator|->
name|nd_nam2
operator|||
name|netaddr_match
argument_list|(
name|NU_NETFAM
argument_list|(
name|nuidp
argument_list|)
argument_list|,
operator|&
name|nuidp
operator|->
name|nu_haddr
argument_list|,
name|nd
operator|->
name|nd_nam2
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|nuidp
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_REJECTCRED
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * Now, decrypt the timestamp using the session key 			 * and validate it. 			 */
ifdef|#
directive|ifdef
name|NFSKERB
name|XXX
endif|#
directive|endif
name|tvout
operator|.
name|tv_sec
init|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|tvout
operator|.
name|tv_sec
argument_list|)
decl_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
name|tvout
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|nuidp
operator|->
name|nu_expire
operator|<
name|time_second
operator|||
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_sec
operator|>
name|tvout
operator|.
name|tv_sec
operator|||
operator|(
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_sec
operator|==
name|tvout
operator|.
name|tv_sec
operator|&&
name|nuidp
operator|->
name|nu_timestamp
operator|.
name|tv_usec
operator|>
name|tvout
operator|.
name|tv_usec
operator|)
condition|)
block|{
name|nuidp
operator|->
name|nu_expire
operator|=
literal|0
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_REJECTVERF
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nfsrv_setcred
argument_list|(
operator|&
name|nuidp
operator|->
name|nu_cr
argument_list|,
operator|&
name|nd
operator|->
name|nd_cr
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_KERBNICK
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_REJECTCRED
operator|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSPROC_NOOP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * For nqnfs, get piggybacked lease request. 	 */
if|if
condition|(
name|nqnfs
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NQNFSPROC_EVICTED
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_LEASE
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_duration
operator|=
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
name|nd
operator|->
name|nd_duration
operator|=
name|NQ_MINLEASE
expr_stmt|;
block|}
else|else
name|nd
operator|->
name|nd_duration
operator|=
name|NQ_MINLEASE
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|md
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|dpos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|p
parameter_list|,
name|server
parameter_list|,
name|msg
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|,
decl|*
name|msg
decl_stmt|;
end_function

begin_block
block|{
name|tpr_t
name|tpr
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|tpr
operator|=
name|tprintf_open
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|tpr
operator|=
name|NULL
expr_stmt|;
name|tprintf
argument_list|(
name|tpr
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|tprintf_close
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Socket upcall routine for the nfsd sockets.  * The caddr_t arg is a pointer to the "struct nfssvc_sock".  * Essentially do as much as possible non-blocking, else punt and it will  * be called with M_WAIT from an nfsd.  */
end_comment

begin_function
name|void
name|nfsrv_rcv
parameter_list|(
name|so
parameter_list|,
name|arg
parameter_list|,
name|waitflag
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
name|int
name|waitflag
decl_stmt|;
block|{
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
init|=
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|)
name|arg
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Define this to test for nfsds handling this under heavy load. 	 */
if|if
condition|(
name|waitflag
operator|==
name|M_DONTWAIT
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_NEEDQ
expr_stmt|;
goto|goto
name|dorecs
goto|;
block|}
endif|#
directive|endif
name|auio
operator|.
name|uio_procp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
block|{
comment|/* 		 * If there are already records on the queue, defer soreceive() 		 * to an nfsd so that there is feedback to the TCP layer that 		 * the nfs servers are heavily loaded. 		 */
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|)
operator|&&
name|waitflag
operator|==
name|M_DONTWAIT
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_NEEDQ
expr_stmt|;
goto|goto
name|dorecs
goto|;
block|}
comment|/* 		 * Do soreceive(). 		 */
name|auio
operator|.
name|uio_resid
operator|=
literal|1000000000
expr_stmt|;
name|flags
operator|=
name|MSG_DONTWAIT
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|&
name|nam
argument_list|,
operator|&
name|auio
argument_list|,
operator|&
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|mp
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_NEEDQ
expr_stmt|;
else|else
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_DISCONN
expr_stmt|;
goto|goto
name|dorecs
goto|;
block|}
name|m
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_rawend
condition|)
block|{
name|slp
operator|->
name|ns_rawend
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|slp
operator|->
name|ns_cc
operator|+=
literal|1000000000
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
else|else
block|{
name|slp
operator|->
name|ns_raw
operator|=
name|m
expr_stmt|;
name|slp
operator|->
name|ns_cc
operator|=
literal|1000000000
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
while|while
condition|(
name|m
operator|->
name|m_next
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|slp
operator|->
name|ns_rawend
operator|=
name|m
expr_stmt|;
comment|/* 		 * Now try and parse record(s) out of the raw stream data. 		 */
name|error
operator|=
name|nfsrv_getstream
argument_list|(
name|slp
argument_list|,
name|waitflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EPERM
condition|)
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_DISCONN
expr_stmt|;
else|else
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_NEEDQ
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|auio
operator|.
name|uio_resid
operator|=
literal|1000000000
expr_stmt|;
name|flags
operator|=
name|MSG_DONTWAIT
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|&
name|nam
argument_list|,
operator|&
name|auio
argument_list|,
operator|&
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|struct
name|nfsrv_rec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_rec
argument_list|)
argument_list|,
name|M_NFSRVDESC
argument_list|,
name|waitflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rec
condition|)
block|{
if|if
condition|(
name|nam
condition|)
name|FREE
argument_list|(
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nfs_realign
argument_list|(
name|mp
argument_list|,
literal|10
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|rec
operator|->
name|nr_address
operator|=
name|nam
expr_stmt|;
name|rec
operator|->
name|nr_packet
operator|=
name|mp
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|,
name|rec
argument_list|,
name|nr_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_DISCONN
expr_stmt|;
goto|goto
name|dorecs
goto|;
block|}
block|}
block|}
do|while
condition|(
name|mp
condition|)
do|;
block|}
comment|/* 	 * Now try and process the request records, non-blocking. 	 */
name|dorecs
label|:
if|if
condition|(
name|waitflag
operator|==
name|M_DONTWAIT
operator|&&
operator|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|)
operator|||
operator|(
name|slp
operator|->
name|ns_flag
operator|&
operator|(
name|SLP_NEEDQ
operator||
name|SLP_DISCONN
operator|)
operator|)
operator|)
condition|)
name|nfsrv_wakenfsd
argument_list|(
name|slp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try and extract an RPC request from the mbuf data list received on a  * stream socket. The "waitflag" argument indicates whether or not it  * can sleep.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getstream
parameter_list|(
name|slp
parameter_list|,
name|waitflag
parameter_list|)
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|int
name|waitflag
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|om
decl_stmt|,
modifier|*
name|m2
decl_stmt|,
modifier|*
name|recm
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|recmark
decl_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_GETSTREAM
condition|)
name|panic
argument_list|(
literal|"nfs getstream"
argument_list|)
expr_stmt|;
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_GETSTREAM
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|slp
operator|->
name|ns_reclen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slp
operator|->
name|ns_cc
operator|<
name|NFSX_UNSIGNED
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_GETSTREAM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|=
name|slp
operator|->
name|ns_raw
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
name|NFSX_UNSIGNED
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|recmark
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|NFSX_UNSIGNED
expr_stmt|;
block|}
else|else
block|{
name|cp1
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|recmark
expr_stmt|;
name|cp2
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp1
operator|<
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|recmark
operator|)
operator|+
name|NFSX_UNSIGNED
condition|)
block|{
while|while
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|cp2
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp1
operator|++
operator|=
operator|*
name|cp2
operator|++
expr_stmt|;
name|m
operator|->
name|m_data
operator|++
expr_stmt|;
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
block|}
block|}
name|slp
operator|->
name|ns_cc
operator|-=
name|NFSX_UNSIGNED
expr_stmt|;
name|recmark
operator|=
name|ntohl
argument_list|(
name|recmark
argument_list|)
expr_stmt|;
name|slp
operator|->
name|ns_reclen
operator|=
name|recmark
operator|&
operator|~
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|recmark
operator|&
literal|0x80000000
condition|)
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_LASTFRAG
expr_stmt|;
else|else
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_LASTFRAG
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_reclen
operator|<
name|NFS_MINPACKET
operator|||
name|slp
operator|->
name|ns_reclen
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_GETSTREAM
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
comment|/* 	     * Now get the record part. 	     */
if|if
condition|(
name|slp
operator|->
name|ns_cc
operator|==
name|slp
operator|->
name|ns_reclen
condition|)
block|{
name|recm
operator|=
name|slp
operator|->
name|ns_raw
expr_stmt|;
name|slp
operator|->
name|ns_raw
operator|=
name|slp
operator|->
name|ns_rawend
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|slp
operator|->
name|ns_cc
operator|=
name|slp
operator|->
name|ns_reclen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slp
operator|->
name|ns_cc
operator|>
name|slp
operator|->
name|ns_reclen
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|slp
operator|->
name|ns_raw
expr_stmt|;
name|om
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|slp
operator|->
name|ns_reclen
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|+
name|m
operator|->
name|m_len
operator|)
operator|>
name|slp
operator|->
name|ns_reclen
condition|)
block|{
name|m2
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|slp
operator|->
name|ns_reclen
operator|-
name|len
argument_list|,
name|waitflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
condition|)
block|{
if|if
condition|(
name|om
condition|)
block|{
name|om
operator|->
name|m_next
operator|=
name|m2
expr_stmt|;
name|recm
operator|=
name|slp
operator|->
name|ns_raw
expr_stmt|;
block|}
else|else
name|recm
operator|=
name|m2
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|slp
operator|->
name|ns_reclen
operator|-
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|slp
operator|->
name|ns_reclen
operator|-
name|len
expr_stmt|;
name|len
operator|=
name|slp
operator|->
name|ns_reclen
expr_stmt|;
block|}
else|else
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_GETSTREAM
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|+
name|m
operator|->
name|m_len
operator|)
operator|==
name|slp
operator|->
name|ns_reclen
condition|)
block|{
name|om
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|recm
operator|=
name|slp
operator|->
name|ns_raw
expr_stmt|;
name|om
operator|->
name|m_next
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|om
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|slp
operator|->
name|ns_raw
operator|=
name|m
expr_stmt|;
name|slp
operator|->
name|ns_cc
operator|-=
name|len
expr_stmt|;
name|slp
operator|->
name|ns_reclen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|slp
operator|->
name|ns_flag
operator|&=
operator|~
name|SLP_GETSTREAM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	     * Accumulate the fragments into a record. 	     */
name|mpp
operator|=
operator|&
name|slp
operator|->
name|ns_frag
expr_stmt|;
while|while
condition|(
operator|*
name|mpp
condition|)
name|mpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|mpp
operator|)
operator|->
name|m_next
operator|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|recm
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_LASTFRAG
condition|)
block|{
name|struct
name|nfsrv_rec
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_rec
argument_list|)
argument_list|,
name|M_NFSRVDESC
argument_list|,
name|waitflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rec
condition|)
block|{
name|m_freem
argument_list|(
name|slp
operator|->
name|ns_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfs_realign
argument_list|(
name|slp
operator|->
name|ns_frag
argument_list|,
literal|10
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|rec
operator|->
name|nr_address
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
name|rec
operator|->
name|nr_packet
operator|=
name|slp
operator|->
name|ns_frag
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|,
name|rec
argument_list|,
name|nr_link
argument_list|)
expr_stmt|;
block|}
name|slp
operator|->
name|ns_frag
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Parse an RPC header.  */
end_comment

begin_function
name|int
name|nfsrv_dorec
parameter_list|(
name|slp
parameter_list|,
name|nfsd
parameter_list|,
name|ndp
parameter_list|)
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|nfsd
modifier|*
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
modifier|*
name|ndp
decl_stmt|;
block|{
name|struct
name|nfsrv_rec
modifier|*
name|rec
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
specifier|register
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|ndp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
operator|||
operator|!
name|STAILQ_FIRST
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|)
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|rec
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|slp
operator|->
name|ns_rec
argument_list|,
name|nr_link
argument_list|)
expr_stmt|;
name|nam
operator|=
name|rec
operator|->
name|nr_address
expr_stmt|;
name|m
operator|=
name|rec
operator|->
name|nr_packet
expr_stmt|;
name|free
argument_list|(
name|rec
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nd
argument_list|,
expr|struct
name|nfsrv_descript
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_descript
argument_list|)
argument_list|,
name|M_NFSRVDESC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|nd
operator|->
name|nd_mrep
operator|=
name|m
expr_stmt|;
name|nd
operator|->
name|nd_nam2
operator|=
name|nam
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_getreq
argument_list|(
name|nd
argument_list|,
name|nfsd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|,
name|M_NFSRVDESC
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|ndp
operator|=
name|nd
expr_stmt|;
name|nfsd
operator|->
name|nfsd_nd
operator|=
name|nd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for a sleeping nfsd and wake it up.  * SIDE EFFECT: If none found, set NFSD_CHECKSLP flag, so that one of the  * running nfsds will go look for the work in the nfssvc_sock list.  */
end_comment

begin_function
name|void
name|nfsrv_wakenfsd
parameter_list|(
name|slp
parameter_list|)
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsd
modifier|*
name|nd
decl_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|nd
operator|=
name|nfsd_head
operator|.
name|tqh_first
init|;
name|nd
operator|!=
literal|0
condition|;
name|nd
operator|=
name|nd
operator|->
name|nfsd_chain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|nd
operator|->
name|nfsd_flag
operator|&
name|NFSD_WAITING
condition|)
block|{
name|nd
operator|->
name|nfsd_flag
operator|&=
operator|~
name|NFSD_WAITING
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nfsd_slp
condition|)
name|panic
argument_list|(
literal|"nfsd wakeup"
argument_list|)
expr_stmt|;
name|slp
operator|->
name|ns_sref
operator|++
expr_stmt|;
name|nd
operator|->
name|nfsd_slp
operator|=
name|slp
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|slp
operator|->
name|ns_flag
operator||=
name|SLP_DOREC
expr_stmt|;
name|nfsd_head_flag
operator||=
name|NFSD_CHECKSLP
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

end_unit

