begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1991, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_socket.c	8.5 (Berkeley) 3/30/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Socket operations for use by nfs  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsnode.h>
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  * Estimate rto for an nfs rpc sent via. an unreliable datagram.  * Use the mean and mean deviation of rtt for the appropriate type of rpc  * for the frequent rpcs and a default for the others.  * The justification for doing "other" this way is that these rpcs  * happen so infrequently that timer est. would probably be stale.  * Also, since many of these rpcs are  * non-idempotent, a conservative timeout is desired.  * getattr, lookup - A+2D  * read, write     - A+4D  * other           - nm_timeo  */
end_comment

begin_define
define|#
directive|define
name|NFS_RTO
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|((t) == 0 ? (n)->nm_timeo : \ 	 ((t)< 3 ? \ 	  (((((n)->nm_srtt[t-1] + 3)>> 2) + (n)->nm_sdrtt[t-1] + 1)>> 1) : \ 	  ((((n)->nm_srtt[t-1] + 7)>> 3) + (n)->nm_sdrtt[t-1] + 1)))
end_define

begin_define
define|#
directive|define
name|NFS_SRTT
parameter_list|(
name|r
parameter_list|)
value|(r)->r_nmp->nm_srtt[proct[(r)->r_procnum] - 1]
end_define

begin_define
define|#
directive|define
name|NFS_SDRTT
parameter_list|(
name|r
parameter_list|)
value|(r)->r_nmp->nm_sdrtt[proct[(r)->r_procnum] - 1]
end_define

begin_comment
comment|/*  * Defines which timer to use for the procnum.  * 0 - default  * 1 - getattr  * 2 - lookup  * 3 - read  * 4 - write  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|proct
index|[
name|NFS_NPROCS
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_realign_test
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_realign_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_bufpackets
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|realign_test
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_realign_test
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|realign_count
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_realign_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufpackets
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_bufpackets
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * There is a congestion window for outstanding rpcs maintained per mount  * point. The cwnd size is adjusted in roughly the way that:  * Van Jacobson, Congestion avoidance and Control, In "Proceedings of  * SIGCOMM '88". ACM, August 1988.  * describes for TCP. The cwnd size is chopped in half on a retransmit timeout  * and incremented by 1/cwnd when each rpc reply is received and a full cwnd  * of rpcs is in progress.  * (The sent count and cwnd are scaled for integer arith.)  * Variants of "slow start" were tried and were found to be too much of a  * performance hit (ave. rtt 3 times larger),  * I suspect due to the large rtt that nfs rpcs have.  */
end_comment

begin_define
define|#
directive|define
name|NFS_CWNDSCALE
value|256
end_define

begin_define
define|#
directive|define
name|NFS_MAXCWND
value|(NFS_CWNDSCALE * 32)
end_define

begin_define
define|#
directive|define
name|NFS_NBACKOFF
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_backoff
index|[
name|NFS_NBACKOFF
index|]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout_handle
name|nfs_timer_handle
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_rcvlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfs_rcvunlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfs_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|hsiz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_receive
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|aname
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_reply
parameter_list|(
name|struct
name|nfsreq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfs_softterm
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_reconnect
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize sockets and congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_function
name|int
name|nfs_connect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|rcvreserve
decl_stmt|,
name|sndreserve
decl_stmt|;
name|int
name|pktscale
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
operator|&
name|thread0
decl_stmt|;
comment|/* only used for socreate and sobind */
name|nmp
operator|->
name|nm_so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
name|saddr
operator|=
name|nmp
operator|->
name|nm_nam
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|saddr
operator|->
name|sa_family
argument_list|,
operator|&
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_sotype
argument_list|,
name|nmp
operator|->
name|nm_soproto
argument_list|,
name|nmp
operator|->
name|nm_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
comment|/* 	 * Some servers require that the client port be a reserved port number. 	 */
if|if
condition|(
name|saddr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_RESVPORT
operator|)
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|ip
decl_stmt|;
name|struct
name|sockaddr_in
name|ssin
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|ip
operator|=
name|IP_PORTRANGE_LOW
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|IP_PORTRANGE
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ip
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|bzero
argument_list|(
operator|&
name|ssin
argument_list|,
sizeof|sizeof
name|ssin
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|&
name|ssin
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|sobind
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|ip
operator|=
name|IP_PORTRANGE_DEFAULT
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|IP_PORTRANGE
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ip
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Protocols that do not require connections may be optionally left 	 * unconnected for servers that reply from a port other than NFS_PORT. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|soconnect
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Wait for the connection to complete. Cribbed from the 		 * connect system call but with the wait timing out so 		 * that interruptible mounts don't hang here for a long time. 		 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
operator|&&
name|rep
operator|&&
operator|(
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
operator|(
name|rep
operator|->
name|r_td
condition|?
name|rep
operator|->
name|r_td
operator|->
name|td_proc
else|:
name|NULL
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|5
operator|*
name|hz
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|5
operator|*
name|hz
expr_stmt|;
comment|/* 	 * Get buffer reservation size from sysctl, but impose reasonable 	 * limits. 	 */
name|pktscale
operator|=
name|nfs_bufpackets
expr_stmt|;
if|if
condition|(
name|pktscale
operator|<
literal|2
condition|)
name|pktscale
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pktscale
operator|>
literal|64
condition|)
name|pktscale
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_SEQPACKET
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"nfscon sotype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_KEEPALIVE
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|val
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|val
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|val
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|val
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
block|}
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
comment|/* Initialize other non-zero congestion variables */
name|nmp
operator|->
name|nm_srtt
index|[
literal|0
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|1
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|2
index|]
operator|=
name|nmp
operator|->
name|nm_srtt
index|[
literal|3
index|]
operator|=
operator|(
name|NFS_TIMEO
operator|<<
literal|3
operator|)
expr_stmt|;
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|0
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|1
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|2
index|]
operator|=
name|nmp
operator|->
name|nm_sdrtt
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_MAXCWND
operator|/
literal|2
expr_stmt|;
comment|/* Initial send window */
name|nmp
operator|->
name|nm_sent
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_timeouts
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconnect routine:  * Called when a connection is broken on a reliable protocol.  * - clean up the old socket  * - nfs_connect() again  * - set R_MUSTRESEND for all outstanding requests on mount point  * If this fails the mount point is DEAD!  * nb: Must be called with the nfs_sndlock() set on the mount point.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_reconnect
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|nfsreq
modifier|*
name|rp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|rep
operator|->
name|r_nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|nfs_connect
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop through outstanding request list and fix up all requests 	 * on old socket. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_nmp
operator|==
name|nmp
condition|)
name|rp
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS disconnect. Clean up and unlink.  */
end_comment

begin_function
name|void
name|nfs_disconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_so
condition|)
block|{
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nfs_safedisconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nfsreq
name|dummyreq
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dummyreq
argument_list|,
sizeof|sizeof
argument_list|(
name|dummyreq
argument_list|)
argument_list|)
expr_stmt|;
name|dummyreq
operator|.
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|nfs_rcvlock
argument_list|(
operator|&
name|dummyreq
argument_list|)
expr_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nfs_rcvunlock
argument_list|(
operator|&
name|dummyreq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the nfs send routine. For connection based socket types, it  * must be called with an nfs_sndlock() on the socket.  * - return EINTR if the RPC is terminated, 0 otherwise  * - set R_MUSTRESEND if the send fails for any reason  * - do any cleanup required by recoverable socket errors (?)  */
end_comment

begin_function
name|int
name|nfs_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sendnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|soflags
decl_stmt|,
name|flags
decl_stmt|;
name|KASSERT
argument_list|(
name|rep
argument_list|,
operator|(
literal|"nfs_send: called with rep == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_MUSTRESEND
expr_stmt|;
name|soflags
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_soflags
expr_stmt|;
if|if
condition|(
operator|(
name|soflags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
name|sendnam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|sendnam
operator|=
name|nam
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_SEQPACKET
condition|)
name|flags
operator|=
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
argument_list|(
name|so
argument_list|,
name|sendnam
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|curthread
comment|/*XXX*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOBUFS
operator|&&
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nfs send error %d for server %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
comment|/* 		 * Deal with errors for the client side. 		 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
comment|/* 		 * Handle any recoverable (soft) socket errors here. (?) 		 */
if|if
condition|(
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
operator|&&
name|error
operator|!=
name|EPIPE
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a Sun RPC Request/Reply. For SOCK_DGRAM, the work is all  * done by soreceive(), but for SOCK_STREAM we must deal with the Record  * Mark and consolidate the data into a new mbuf list.  * nb: Sometimes TCP passes the data up to soreceive() in long lists of  *     small mbufs.  * For SOCK_STREAM we must be very careful to read an entire record once  * we have read any of it, even if the system call has been interrupted.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_receive
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|aname
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aio
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|getnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sotype
decl_stmt|,
name|rcvflg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
comment|/* 	 * Set up arguments for soreceive() 	 */
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|aname
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
name|sotype
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_sotype
expr_stmt|;
comment|/* 	 * For reliable protocols, lock against other senders/receivers 	 * in case a reconnect is necessary. 	 * For SOCK_STREAM, first get the Record Mark to find out how much 	 * more there is to get. 	 * We must lock the socket against other receivers 	 * until we have an entire rpc request/reply. 	 */
if|if
condition|(
name|sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
name|error
operator|=
name|nfs_sndlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tryagain
label|:
comment|/* 		 * Check for fatal errors and resending request. 		 */
comment|/* 		 * Ugh: If a reconnect attempt just happened, nm_so 		 * would have changed. NULL indicates a failed 		 * attempt that has essentially shut down this 		 * mount point. 		 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
block|{
name|nfs_sndunlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
expr_stmt|;
if|if
condition|(
operator|!
name|so
condition|)
block|{
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nfs_sndunlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
goto|goto
name|tryagain
goto|;
block|}
while|while
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
block|{
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|so
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
operator|||
operator|(
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nfs_sndunlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
goto|goto
name|tryagain
goto|;
block|}
block|}
name|nfs_sndunlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|aio
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|len
expr_stmt|;
name|aio
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aio
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* 			     * Don't log a 0 byte receive; it means 			     * that the socket has been closed, and 			     * can happen during normal operation 			     * (forcible unmount or Solaris server). 			     */
if|if
condition|(
name|auio
operator|.
name|uio_resid
operator|!=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"short receive (%d/%d) from nfs server %s\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|auio
operator|.
name|uio_resid
argument_list|)
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|errout
goto|;
name|len
operator|=
name|ntohl
argument_list|(
name|len
argument_list|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
comment|/* 			 * This is SERIOUS! We are out of sync with the sender 			 * and forcing a disconnect/reconnect is all I can do. 			 */
if|if
condition|(
name|len
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s (%d) from nfs server %s\n"
argument_list|,
literal|"impossible packet length"
argument_list|,
name|len
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
name|MSG_WAITALL
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|auio
operator|.
name|uio_resid
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"short receive (%d/%d) from nfs server %s\n"
argument_list|,
name|len
operator|-
name|auio
operator|.
name|uio_resid
argument_list|,
name|len
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * NB: Since uio_resid is big, MSG_WAITALL is ignored 			 * and soreceive() will return when it has either a 			 * control msg or a data msg. 			 * We have no use for control msg., but must grab them 			 * and then throw them away so we know what is going 			 * on. 			 */
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|100000000
expr_stmt|;
comment|/* Anything Big */
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|&
name|control
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
operator|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
operator|&&
name|control
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|rcvflg
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Egad!!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
name|errout
label|:
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EPIPE
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receive error %d from nfs server %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_sndlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|tryagain
goto|;
else|else
name|nfs_sndunlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
name|getnam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|getnam
operator|=
name|aname
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
name|getnam
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 	 * Search for any mbufs that are not a multiple of 4 bytes long 	 * or with m_data not longword aligned. 	 * These could cause pointer alignment problems, so copy them to 	 * well aligned mbufs. 	 */
name|nfs_realign
argument_list|(
name|mp
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement receipt of reply on a socket.  * We must search through the list of received datagrams matching them  * with outstanding requests using the xid, until ours is found.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_reply
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|myrep
parameter_list|)
block|{
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|myrep
operator|->
name|r_nmp
decl_stmt|;
name|int32_t
name|t1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|u_int32_t
name|rxid
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Loop around until we get our own reply 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Lock against other receivers so that I don't get stuck in 		 * sbwait() after someone else has received my reply for me. 		 * Also necessary for connection based protocols to avoid 		 * race conditions during a reconnect. 		 * If nfs_rcvlock() returns EALREADY, that means that 		 * the reply has already been recieved by another 		 * process and we can return immediately.  In this 		 * case, the lock is not taken to avoid races with 		 * other processes. 		 */
name|error
operator|=
name|nfs_rcvlock
argument_list|(
name|myrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EALREADY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Get the next Rpc reply off the socket 		 */
name|error
operator|=
name|nfs_receive
argument_list|(
name|myrep
argument_list|,
operator|&
name|nam
argument_list|,
operator|&
name|mrep
argument_list|)
expr_stmt|;
name|nfs_rcvunlock
argument_list|(
name|myrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Ignore routing errors on connectionless protocols?? 			 */
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|nmp
operator|->
name|nm_so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nam
condition|)
name|FREE
argument_list|(
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
comment|/* 		 * Get the xid and check that it is an rpc reply 		 */
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|rxid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
name|rpc_reply
condition|)
block|{
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * Loop through the request list to match up the reply 		 * Iff no match, just drop the datagram 		 */
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|rxid
operator|==
name|rep
operator|->
name|r_xid
condition|)
block|{
comment|/* Found it.. */
name|rep
operator|->
name|r_mrep
operator|=
name|mrep
expr_stmt|;
name|rep
operator|->
name|r_md
operator|=
name|md
expr_stmt|;
name|rep
operator|->
name|r_dpos
operator|=
name|dpos
expr_stmt|;
comment|/* 				 * Update congestion window. 				 * Do the additive increase of 				 * one rpc/rtt. 				 */
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|<=
name|nmp
operator|->
name|nm_sent
condition|)
block|{
name|nmp
operator|->
name|nm_cwnd
operator|+=
operator|(
name|NFS_CWNDSCALE
operator|*
name|NFS_CWNDSCALE
operator|+
operator|(
name|nmp
operator|->
name|nm_cwnd
operator|>>
literal|1
operator|)
operator|)
operator|/
name|nmp
operator|->
name|nm_cwnd
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|>
name|NFS_MAXCWND
condition|)
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_MAXCWND
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
comment|/* 				 * Update rtt using a gain of 0.125 on the mean 				 * and a gain of 0.25 on the deviation. 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
comment|/* 					 * Since the timer resolution of 					 * NFS_HZ is so course, it can often 					 * result in r_rtt == 0. Since 					 * r_rtt == N means that the actual 					 * rtt is between N+dt and N+2-dt ticks, 					 * add 1. 					 */
name|t1
operator|=
name|rep
operator|->
name|r_rtt
operator|+
literal|1
expr_stmt|;
name|t1
operator|-=
operator|(
name|NFS_SRTT
argument_list|(
name|rep
argument_list|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|NFS_SRTT
argument_list|(
name|rep
argument_list|)
operator|+=
name|t1
expr_stmt|;
if|if
condition|(
name|t1
operator|<
literal|0
condition|)
name|t1
operator|=
operator|-
name|t1
expr_stmt|;
name|t1
operator|-=
operator|(
name|NFS_SDRTT
argument_list|(
name|rep
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|NFS_SDRTT
argument_list|(
name|rep
argument_list|)
operator|+=
name|t1
expr_stmt|;
block|}
name|nmp
operator|->
name|nm_timeouts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If not matched to a request, drop it. 		 * If it's mine, get out. 		 */
if|if
condition|(
name|rep
operator|==
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpcunexpected
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|==
name|myrep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsreply nil"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_send() for first transmit  *	- calls nfs_receive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_comment
comment|/* XXX overloaded before */
end_comment

begin_define
define|#
directive|define
name|NQ_TRYLATERDEL
value|15
end_define

begin_comment
comment|/* Initial try later delay (sec) */
end_comment

begin_function
name|int
name|nfs_request
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mrest
parameter_list|,
name|int
name|procnum
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
parameter_list|,
name|caddr_t
modifier|*
name|dposp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mheadend
decl_stmt|;
name|time_t
name|waituntil
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|mrest_len
decl_stmt|,
name|auth_len
decl_stmt|,
name|auth_type
decl_stmt|;
name|int
name|trylater_delay
init|=
name|NQ_TRYLATERDEL
decl_stmt|,
name|trylater_cnt
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|xid
decl_stmt|;
comment|/* Reject requests while attempting to unmount. */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNT
condition|)
block|{
name|m_freem
argument_list|(
name|mrest
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|rep
argument_list|,
expr|struct
name|nfsreq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|rep
operator|->
name|r_vp
operator|=
name|vp
expr_stmt|;
name|rep
operator|->
name|r_td
operator|=
name|td
expr_stmt|;
name|rep
operator|->
name|r_procnum
operator|=
name|procnum
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|mrest
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|mrest_len
operator|=
name|i
expr_stmt|;
comment|/* 	 * Get the RPC header with authorization. 	 */
name|auth_type
operator|=
name|RPCAUTH_UNIX
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_ngroups
operator|<
literal|1
condition|)
name|panic
argument_list|(
literal|"nfsreq nogrps"
argument_list|)
expr_stmt|;
name|auth_len
operator|=
operator|(
operator|(
operator|(
operator|(
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
operator|)
operator|>
name|nmp
operator|->
name|nm_numgrps
operator|)
condition|?
name|nmp
operator|->
name|nm_numgrps
else|:
operator|(
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|5
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|m
operator|=
name|nfsm_rpchead
argument_list|(
name|cred
argument_list|,
name|nmp
operator|->
name|nm_flag
argument_list|,
name|procnum
argument_list|,
name|auth_type
argument_list|,
name|auth_len
argument_list|,
name|mrest
argument_list|,
name|mrest_len
argument_list|,
operator|&
name|mheadend
argument_list|,
operator|&
name|xid
argument_list|)
expr_stmt|;
comment|/* 	 * For stream protocols, insert a Sun RPC Record Mark. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|NFSX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
block|}
name|rep
operator|->
name|r_mreq
operator|=
name|m
expr_stmt|;
name|rep
operator|->
name|r_xid
operator|=
name|xid
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
condition|)
name|rep
operator|->
name|r_retry
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
else|else
name|rep
operator|->
name|r_retry
operator|=
name|NFS_MAXREXMIT
operator|+
literal|1
expr_stmt|;
comment|/* past clip limit */
name|rep
operator|->
name|r_rtt
operator|=
name|rep
operator|->
name|r_rexmit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proct
index|[
name|procnum
index|]
operator|>
literal|0
condition|)
name|rep
operator|->
name|r_flags
operator|=
name|R_TIMING
expr_stmt|;
else|else
name|rep
operator|->
name|r_flags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Do the client side RPC. 	 */
name|nfsstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
comment|/* 	 * Chain request into list of outstanding requests. Be sure 	 * to put it LAST so timer finds oldest requests first. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfs_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
comment|/* 	 * If backing off another request or avoiding congestion, don't 	 * send this one now but let timer do it. If not timing a request, 	 * do it now. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_so
operator|&&
operator|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
operator|||
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
operator|)
operator|||
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_cwnd
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|error
operator|=
name|nfs_sndlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|m2
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|m2
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|nfs_sndunlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_sent
operator|+=
name|NFS_CWNDSCALE
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
block|}
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Wait for the reply from our send or the timer's. 	 */
if|if
condition|(
operator|!
name|error
operator|||
name|error
operator|==
name|EPIPE
condition|)
name|error
operator|=
name|nfs_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
comment|/* 	 * RPC done, unlink the request. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfs_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the outstanding request count. 	 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
comment|/* paranoia */
name|nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
comment|/* 	 * If there was a successful reply and a tprintf msg. 	 * tprintf a response. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
condition|)
name|nfs_msg
argument_list|(
name|rep
operator|->
name|r_td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
literal|"is alive again"
argument_list|)
expr_stmt|;
name|mrep
operator|=
name|rep
operator|->
name|r_mrep
expr_stmt|;
name|md
operator|=
name|rep
operator|->
name|r_md
expr_stmt|;
name|dpos
operator|=
name|rep
operator|->
name|r_dpos
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * break down the rpc header and check if ok 	 */
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|==
name|rpc_msgdenied
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|rpc_mismatch
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Just throw away any verifyer (ie: kerberos etc). 	 */
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
comment|/* verf type */
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* len */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 0 == ok */
if|if
condition|(
operator|*
name|tl
operator|==
literal|0
condition|)
block|{
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
operator|&&
name|error
operator|==
name|NFSERR_TRYLATER
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|waituntil
operator|=
name|time_second
operator|+
name|trylater_delay
expr_stmt|;
while|while
condition|(
name|time_second
operator|<
name|waituntil
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nqnfstry"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trylater_delay
operator|*=
name|nfs_backoff
index|[
name|trylater_cnt
index|]
expr_stmt|;
if|if
condition|(
name|trylater_cnt
operator|<
name|NFS_NBACKOFF
operator|-
literal|1
condition|)
name|trylater_cnt
operator|++
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* 			 * If the File Handle was stale, invalidate the 			 * lookup cache, just in case. 			 */
if|if
condition|(
name|error
operator|==
name|ESTALE
condition|)
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|error
operator||=
name|NFSERR_RETERR
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
name|nfsmout
label|:
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs timer routine  * Scan the nfsreq list and retranmit any requests that have timed out  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0 (implies nm_retry == 0).  */
end_comment

begin_function
name|void
name|nfs_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|timeo
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
operator|&
name|thread0
expr_stmt|;
comment|/* XXX for credentials, may break if sleep */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
name|nmp
operator|=
name|rep
operator|->
name|r_nmp
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
operator|(
name|rep
operator|->
name|r_td
condition|?
name|rep
operator|->
name|r_td
operator|->
name|td_proc
else|:
name|NULL
operator|)
argument_list|)
condition|)
block|{
name|nfs_softterm
argument_list|(
name|rep
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|>=
literal|0
condition|)
block|{
name|rep
operator|->
name|r_rtt
operator|++
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
condition|)
name|timeo
operator|=
name|nmp
operator|->
name|nm_timeo
expr_stmt|;
else|else
name|timeo
operator|=
name|NFS_RTO
argument_list|(
name|nmp
argument_list|,
name|proct
index|[
name|rep
operator|->
name|r_procnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_timeouts
operator|>
literal|0
condition|)
name|timeo
operator|*=
name|nfs_backoff
index|[
name|nmp
operator|->
name|nm_timeouts
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|<=
name|timeo
condition|)
continue|continue;
if|if
condition|(
name|nmp
operator|->
name|nm_timeouts
operator|<
name|NFS_NBACKOFF
condition|)
name|nmp
operator|->
name|nm_timeouts
operator|++
expr_stmt|;
block|}
comment|/* 		 * Check for server not responding 		 */
if|if
condition|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
operator|==
literal|0
operator|&&
name|rep
operator|->
name|r_rexmit
operator|>
name|nmp
operator|->
name|nm_deadthresh
condition|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"not responding %d> %d"
argument_list|,
name|rep
operator|->
name|r_rexmit
argument_list|,
name|nmp
operator|->
name|nm_deadthresh
argument_list|)
expr_stmt|;
name|nfs_msg
argument_list|(
name|rep
operator|->
name|r_td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|buf
comment|/* "not responding" */
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TPRINTFMSG
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rexmit
operator|>=
name|rep
operator|->
name|r_retry
condition|)
block|{
comment|/* too many */
name|nfsstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|nfs_softterm
argument_list|(
name|rep
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * If there is enough space and the window allows.. 		 *	Resend it 		 * Set r_rtt to -1 in case we fail to send it now. 		 */
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>=
name|rep
operator|->
name|r_mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|&&
operator|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
operator|)
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
operator|)
operator|||
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_cwnd
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Iff first send, start timing 				 * else turn timing off, backoff timer 				 * and divide congestion window by 2. 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
name|nmp
operator|->
name|nm_cwnd
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|<
name|NFS_CWNDSCALE
condition|)
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_CWNDSCALE
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|+=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
name|rep
operator|->
name|r_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nfs_timer_handle
operator|=
name|timeout
argument_list|(
name|nfs_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|nfs_ticks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark all of an nfs mount's outstanding requests with R_SOFTTERM and  * wait for all requests to complete. This is used by forced unmounts  * to terminate any outstanding RPCs.  */
end_comment

begin_function
name|int
name|nfs_nmcancelreqs
parameter_list|(
name|nmp
parameter_list|)
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
block|{
name|struct
name|nfsreq
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|req
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|nmp
operator|!=
name|req
operator|->
name|r_nmp
operator|||
name|req
operator|->
name|r_mrep
operator|!=
name|NULL
operator|||
operator|(
name|req
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
continue|continue;
name|nfs_softterm
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|req
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|nmp
operator|==
name|req
operator|->
name|r_nmp
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tsleep
argument_list|(
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscancel"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flag a request as being about to terminate (due to NFSMNT_INT/NFSMNT_SOFT).  * The nm_send count is decremented now to avoid deadlocks when the process in  * soreceive() hasn't yet managed to send its own request.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_softterm
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Test for a termination condition pending on the process.  * This is used for NFSMNT_INT mounts.  */
end_comment

begin_function
name|int
name|nfs_sigintr
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|sigset_t
name|tmpset
decl_stmt|;
if|if
condition|(
name|rep
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
comment|/* Terminate all requests while attempting to unmount. */
if|if
condition|(
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNT
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tmpset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|&&
name|NFSINT_SIGMASK
argument_list|(
name|tmpset
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a socket against others.  * Necessary for STREAM sockets to ensure you get an entire rpc request/reply  * and also to avoid race conditions between the processes with nfs requests  * in progress when a reconnect is necessary.  */
end_comment

begin_function
name|int
name|nfs_sndlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|slpflag
init|=
literal|0
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|td
operator|=
name|rep
operator|->
name|r_td
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
block|}
else|else
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_SNDLOCK
condition|)
block|{
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|,
name|rep
argument_list|,
name|td
condition|?
name|td
operator|->
name|td_proc
else|:
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|*
name|statep
operator||=
name|NFSSTA_WANTSND
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|statep
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsndlck"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
operator|*
name|statep
operator||=
name|NFSSTA_SNDLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
name|void
name|nfs_sndunlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|statep
operator|&
name|NFSSTA_SNDLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs sndunlock"
argument_list|)
expr_stmt|;
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_SNDLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_WANTSND
condition|)
block|{
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_WANTSND
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|statep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_rcvlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
name|int
name|slpflag
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
else|else
name|slpflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_RCVLOCK
condition|)
block|{
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|,
name|rep
argument_list|,
operator|(
name|rep
operator|->
name|r_td
condition|?
name|rep
operator|->
name|r_td
operator|->
name|td_proc
else|:
name|NULL
operator|)
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|*
name|statep
operator||=
name|NFSSTA_WANTRCV
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|statep
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsrcvlk"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
comment|/* 		 * If our reply was recieved while we were sleeping, 		 * then just return without taking the lock to avoid a 		 * situation where a single iod could 'capture' the 		 * recieve lock. 		 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
comment|/* Always fail if our request has been cancelled. */
if|if
condition|(
name|rep
operator|!=
name|NULL
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
operator|*
name|statep
operator||=
name|NFSSTA_RCVLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_rcvunlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|statep
operator|&
name|NFSSTA_RCVLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs rcvunlock"
argument_list|)
expr_stmt|;
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_RCVLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_WANTRCV
condition|)
block|{
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_WANTRCV
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|statep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	nfs_realign:  *  *	Check for badly aligned mbuf data and realign by copying the unaligned  *	portion of the data into a new mbuf chain and freeing the portions  *	of the old chain that were replaced.  *  *	We cannot simply realign the data within the existing mbuf chain  *	because the underlying buffers may contain other rpc commands and  *	we cannot afford to overwrite them.  *  *	We would prefer to avoid this situation entirely.  The situation does  *	not occur with NFS/UDP and is supposed to only occassionally occur  *	with TCP.  Use vfs.nfs.realign_count and realign_test to check this.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|hsiz
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
operator|++
name|nfs_realign_test
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|*
name|pm
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|intptr_t
argument_list|)
operator|&
literal|0x3
operator|)
condition|)
block|{
name|MGET
argument_list|(
name|n
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pm
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * If n is non-NULL, loop on m copying data, then replace the 	 * portion of the chain that had to be realigned. 	 */
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
operator|++
name|nfs_realign_count
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|m_copyback
argument_list|(
name|n
argument_list|,
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|server
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|tprintf
argument_list|(
name|td
condition|?
name|td
operator|->
name|td_proc
else|:
name|NULL
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

