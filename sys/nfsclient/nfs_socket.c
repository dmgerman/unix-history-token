begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1991, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_socket.c	8.5 (Berkeley) 3/30/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Socket operations for use by nfs  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsnode.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NFS_LEGACYRPC
end_ifdef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_realign_test
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_realign_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_bufpackets
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_reconnects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs3_jukebox_delay
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_skip_wcc_data_onerr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fake_wchan
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|realign_test
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_realign_test
argument_list|,
literal|0
argument_list|,
literal|"Number of realign tests done"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|realign_count
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_realign_count
argument_list|,
literal|0
argument_list|,
literal|"Number of mbuf realignments done"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufpackets
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_bufpackets
argument_list|,
literal|0
argument_list|,
literal|"Buffer reservation size 2< x< 64"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|reconnects
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nfs_reconnects
argument_list|,
literal|0
argument_list|,
literal|"Number of times the nfs client has had to reconnect"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs3_jukebox_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs3_jukebox_delay
argument_list|,
literal|0
argument_list|,
literal|"Number of seconds to delay a retry after receiving EJUKEBOX"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|skip_wcc_data_onerr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_skip_wcc_data_onerr
argument_list|,
literal|0
argument_list|,
literal|"Disable weak cache consistency checking when server returns an error"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * There is a congestion window for outstanding rpcs maintained per mount  * point. The cwnd size is adjusted in roughly the way that:  * Van Jacobson, Congestion avoidance and Control, In "Proceedings of  * SIGCOMM '88". ACM, August 1988.  * describes for TCP. The cwnd size is chopped in half on a retransmit timeout  * and incremented by 1/cwnd when each rpc reply is received and a full cwnd  * of rpcs is in progress.  * (The sent count and cwnd are scaled for integer arith.)  * Variants of "slow start" were tried and were found to be too much of a  * performance hit (ave. rtt 3 times larger),  * I suspect due to the large rtt that nfs rpcs have.  */
end_comment

begin_define
define|#
directive|define
name|NFS_CWNDSCALE
value|256
end_define

begin_define
define|#
directive|define
name|NFS_MAXCWND
value|(NFS_CWNDSCALE * 32)
end_define

begin_define
define|#
directive|define
name|NFS_NBACKOFF
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_backoff
index|[
name|NFS_NBACKOFF
index|]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
name|nfs_callout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|hsiz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_reply
parameter_list|(
name|struct
name|nfsreq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfs_softterm
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_reconnect
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_clnt_tcp_soupcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_clnt_udp_soupcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|nfs_reqq_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * RTT estimator  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|nfs_rto_timer_t
name|nfs_proct
index|[
name|NFS_NPROCS
index|]
init|=
block|{
name|NFS_DEFAULT_TIMER
block|,
comment|/* NULL */
name|NFS_GETATTR_TIMER
block|,
comment|/* GETATTR */
name|NFS_DEFAULT_TIMER
block|,
comment|/* SETATTR */
name|NFS_LOOKUP_TIMER
block|,
comment|/* LOOKUP */
name|NFS_GETATTR_TIMER
block|,
comment|/* ACCESS */
name|NFS_READ_TIMER
block|,
comment|/* READLINK */
name|NFS_READ_TIMER
block|,
comment|/* READ */
name|NFS_WRITE_TIMER
block|,
comment|/* WRITE */
name|NFS_DEFAULT_TIMER
block|,
comment|/* CREATE */
name|NFS_DEFAULT_TIMER
block|,
comment|/* MKDIR */
name|NFS_DEFAULT_TIMER
block|,
comment|/* SYMLINK */
name|NFS_DEFAULT_TIMER
block|,
comment|/* MKNOD */
name|NFS_DEFAULT_TIMER
block|,
comment|/* REMOVE */
name|NFS_DEFAULT_TIMER
block|,
comment|/* RMDIR */
name|NFS_DEFAULT_TIMER
block|,
comment|/* RENAME */
name|NFS_DEFAULT_TIMER
block|,
comment|/* LINK */
name|NFS_READ_TIMER
block|,
comment|/* READDIR */
name|NFS_READ_TIMER
block|,
comment|/* READDIRPLUS */
name|NFS_DEFAULT_TIMER
block|,
comment|/* FSSTAT */
name|NFS_DEFAULT_TIMER
block|,
comment|/* FSINFO */
name|NFS_DEFAULT_TIMER
block|,
comment|/* PATHCONF */
name|NFS_DEFAULT_TIMER
block|,
comment|/* COMMIT */
name|NFS_DEFAULT_TIMER
block|,
comment|/* NOOP */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Choose the correct RTT timer for this NFS procedure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|nfs_rto_timer_t
name|nfs_rto_timer
parameter_list|(
name|u_int32_t
name|procnum
parameter_list|)
block|{
return|return
name|nfs_proct
index|[
name|procnum
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the RTT estimator state for a new mount point.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_init_rtt
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_MAX_TIMER
condition|;
name|i
operator|++
control|)
name|nmp
operator|->
name|nm_srtt
index|[
name|i
index|]
operator|=
name|NFS_INITRTT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_MAX_TIMER
condition|;
name|i
operator|++
control|)
name|nmp
operator|->
name|nm_sdrtt
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update a mount point's RTT estimator state using data from the  * passed-in request.  *   * Use a gain of 0.125 on the mean and a gain of 0.25 on the deviation.  *  * NB: Since the timer resolution of NFS_HZ is so course, it can often  * result in r_rtt == 0. Since r_rtt == N means that the actual RTT is  * between N + dt and N + 2 - dt ticks, add 1 before calculating the  * update values.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_update_rtt
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
name|t1
init|=
name|rep
operator|->
name|r_rtt
operator|+
literal|1
decl_stmt|;
name|int
name|index
init|=
name|nfs_rto_timer
argument_list|(
name|rep
operator|->
name|r_procnum
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
modifier|*
name|srtt
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_srtt
index|[
name|index
index|]
decl_stmt|;
name|int
modifier|*
name|sdrtt
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_sdrtt
index|[
name|index
index|]
decl_stmt|;
name|t1
operator|-=
operator|*
name|srtt
operator|>>
literal|3
expr_stmt|;
operator|*
name|srtt
operator|+=
name|t1
expr_stmt|;
if|if
condition|(
name|t1
operator|<
literal|0
condition|)
name|t1
operator|=
operator|-
name|t1
expr_stmt|;
name|t1
operator|-=
operator|*
name|sdrtt
operator|>>
literal|2
expr_stmt|;
operator|*
name|sdrtt
operator|+=
name|t1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Estimate RTO for an NFS RPC sent via an unreliable datagram.  *  * Use the mean and mean deviation of RTT for the appropriate type  * of RPC for the frequent RPCs and a default for the others.  * The justification for doing "other" this way is that these RPCs  * happen so infrequently that timer est. would probably be stale.  * Also, since many of these RPCs are non-idempotent, a conservative  * timeout is desired.  *  * getattr, lookup - A+2D  * read, write     - A+4D  * other           - nm_timeo  */
end_comment

begin_function
specifier|static
name|int
name|nfs_estimate_rto
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_int32_t
name|procnum
parameter_list|)
block|{
name|enum
name|nfs_rto_timer_t
name|timer
init|=
name|nfs_rto_timer
argument_list|(
name|procnum
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|timer
operator|-
literal|1
decl_stmt|;
name|int
name|rto
decl_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
case|case
name|NFS_GETATTR_TIMER
case|:
case|case
name|NFS_LOOKUP_TIMER
case|:
name|rto
operator|=
operator|(
operator|(
name|nmp
operator|->
name|nm_srtt
index|[
name|index
index|]
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
operator|(
name|nmp
operator|->
name|nm_sdrtt
index|[
name|index
index|]
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|NFS_READ_TIMER
case|:
case|case
name|NFS_WRITE_TIMER
case|:
name|rto
operator|=
operator|(
operator|(
name|nmp
operator|->
name|nm_srtt
index|[
name|index
index|]
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
name|nmp
operator|->
name|nm_sdrtt
index|[
name|index
index|]
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
name|rto
operator|=
name|nmp
operator|->
name|nm_timeo
expr_stmt|;
return|return
operator|(
name|rto
operator|)
return|;
block|}
if|if
condition|(
name|rto
operator|<
name|NFS_MINRTO
condition|)
name|rto
operator|=
name|NFS_MINRTO
expr_stmt|;
elseif|else
if|if
condition|(
name|rto
operator|>
name|NFS_MAXRTO
condition|)
name|rto
operator|=
name|NFS_MAXRTO
expr_stmt|;
return|return
operator|(
name|rto
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize sockets and congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_function
name|int
name|nfs_connect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rcvreserve
decl_stmt|,
name|sndreserve
decl_stmt|;
name|int
name|pktscale
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|struct
name|ucred
modifier|*
name|origcred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* 	 * We need to establish the socket using the credentials of 	 * the mountpoint.  Some parts of this process (such as 	 * sobind() and soconnect()) will use the curent thread's 	 * credential instead of the socket credential.  To work 	 * around this, temporarily change the current thread's 	 * credential to that of the mountpoint. 	 * 	 * XXX: It would be better to explicitly pass the correct 	 * credential to sobind() and soconnect(). 	 */
name|origcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_cred
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator||=
name|NFS_TCP_EXPECT_RPCMARKER
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
name|nmp
operator|->
name|nm_so
operator|=
name|NULL
expr_stmt|;
name|saddr
operator|=
name|nmp
operator|->
name|nm_nam
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|saddr
operator|->
name|sa_family
argument_list|,
operator|&
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_sotype
argument_list|,
name|nmp
operator|->
name|nm_soproto
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
comment|/* 	 * Some servers require that the client port be a reserved port number. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_RESVPORT
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|ip
decl_stmt|,
name|ip2
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sockaddr_in6
name|ssin
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|saddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|IP_PORTRANGE
expr_stmt|;
name|ip
operator|=
name|IP_PORTRANGE_LOW
expr_stmt|;
name|ip2
operator|=
name|IP_PORTRANGE_DEFAULT
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|IPV6_PORTRANGE
expr_stmt|;
name|ip
operator|=
name|IPV6_PORTRANGE_LOW
expr_stmt|;
name|ip2
operator|=
name|IPV6_PORTRANGE_DEFAULT
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
goto|goto
name|noresvport
goto|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ssin
expr_stmt|;
name|bzero
argument_list|(
name|sa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
name|len
expr_stmt|;
name|sa
operator|->
name|sa_family
operator|=
name|saddr
operator|->
name|sa_family
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ip
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|sobind
argument_list|(
name|so
argument_list|,
name|sa
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|ip
operator|=
name|ip2
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|noresvport
label|:
empty_stmt|;
block|}
comment|/* 	 * Protocols that do not require connections may be optionally left 	 * unconnected for servers that reply from a port other than NFS_PORT. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|soconnect
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Wait for the connection to complete. Cribbed from the 		 * connect system call but with the wait timing out so 		 * that interruptible mounts don't hang here for a long time. 		 */
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|msleep
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|SOCK_MTX
argument_list|(
name|so
argument_list|)
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
operator|&&
name|rep
operator|&&
operator|(
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTING
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|12
operator|*
name|hz
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|1
operator|*
name|hz
expr_stmt|;
comment|/* 1s snd timeout for NFS/TCP */
else|else
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|5
operator|*
name|hz
expr_stmt|;
comment|/* 	 * Get buffer reservation size from sysctl, but impose reasonable 	 * limits. 	 */
name|pktscale
operator|=
name|nfs_bufpackets
expr_stmt|;
if|if
condition|(
name|pktscale
operator|<
literal|2
condition|)
name|pktscale
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pktscale
operator|>
literal|64
condition|)
name|pktscale
operator|=
literal|64
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_SEQPACKET
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"nfscon sotype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_KEEPALIVE
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|val
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|val
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
name|sopt
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|val
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|val
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|soupcall_set
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|,
name|nfs_clnt_tcp_soupcall
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
else|else
name|soupcall_set
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|,
name|nfs_clnt_udp_soupcall
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* Restore current thread's credentials. */
name|td
operator|->
name|td_ucred
operator|=
name|origcred
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/* Initialize other non-zero congestion variables */
name|nfs_init_rtt
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_MAXCWND
operator|/
literal|2
expr_stmt|;
comment|/* Initial send window */
name|nmp
operator|->
name|nm_sent
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_timeouts
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
comment|/* Restore current thread's credentials. */
name|td
operator|->
name|td_ucred
operator|=
name|origcred
expr_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_wakup_reconnectors
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|mtx_owned
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
argument_list|,
operator|(
literal|"NFS mnt lock not owned !"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|sock_send_inprog
operator|==
literal|0
operator|&&
operator|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_WAIT_WRITE_DRAIN
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&=
operator|~
name|NFS_TCP_WAIT_WRITE_DRAIN
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|sock_send_inprog
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reconnect routine:  * Called when a connection is broken on a reliable protocol.  * - clean up the old socket  * - nfs_connect() again  * - set R_MUSTRESEND for all outstanding requests on mount point  * If this fails the mount point is DEAD!  * nb: Must be called with the nfs_sndlock() set on the mount point.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_reconnect
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|nfsreq
modifier|*
name|rp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|rep
operator|->
name|r_nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|slpflag
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|mtx_owned
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
argument_list|,
operator|(
literal|"NFS mnt lock not owned !"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
comment|/* 	 * Wait for any pending writes to this socket to drain (or timeout). 	 */
while|while
condition|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|sock_send_inprog
operator|>
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator||=
name|NFS_TCP_WAIT_WRITE_DRAIN
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|sock_send_inprog
argument_list|,
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfscon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Grab the nfs_connect_lock to serialize connects.  	 * After grabbing the nfs_connect_lock, check if a reconnect is necessary or 	 * if someone else beat us to the connect ! 	 */
name|error
operator|=
name|nfs_connect_lock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unlock_exit
goto|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_FORCE_RECONNECT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|unlock_exit
goto|;
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nfs_reconnects
operator|++
expr_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|nfs_connect
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EIO
operator|||
name|error
operator|==
name|EINTR
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|fake_wchan
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscon"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Clear the FORCE_RECONNECT flag only after the connect   	 * succeeds. To prevent races between multiple processes   	 * waiting on the mountpoint where the connection is being  	 * torn down. The first one to acquire the sndlock will   	 * retry the connection. The others block on the sndlock  	 * until the connection is established successfully, and   	 * then re-transmit the request.  	 */
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&=
operator|~
name|NFS_TCP_FORCE_RECONNECT
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through outstanding request list and fix up all requests 	 * on old socket. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_nmp
operator|==
name|nmp
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|rp
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rp
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|nfs_connect_unlock
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS disconnect. Clean up and unlink.  */
end_comment

begin_function
name|void
name|nfs_disconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_so
condition|)
block|{
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
name|nmp
operator|->
name|nm_so
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nfs_safedisconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nfsreq
name|dummyreq
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dummyreq
argument_list|,
sizeof|sizeof
argument_list|(
name|dummyreq
argument_list|)
argument_list|)
expr_stmt|;
name|dummyreq
operator|.
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the nfs send routine. For connection based socket types, it  * must be called with an nfs_sndlock() on the socket.  * - return EINTR if the RPC is terminated, 0 otherwise  * - set R_MUSTRESEND if the send fails for any reason  * - do any cleanup required by recoverable socket errors (?)  */
end_comment

begin_function
name|int
name|nfs_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sendnam
decl_stmt|;
name|int
name|error
decl_stmt|,
name|error2
decl_stmt|,
name|soflags
decl_stmt|,
name|flags
decl_stmt|;
name|KASSERT
argument_list|(
name|rep
argument_list|,
operator|(
literal|"nfs_send: called with rep == NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_MUSTRESEND
expr_stmt|;
name|soflags
operator|=
name|rep
operator|->
name|r_nmp
operator|->
name|nm_soflags
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|soflags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
name|sendnam
operator|=
name|NULL
expr_stmt|;
else|else
name|sendnam
operator|=
name|nam
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_SEQPACKET
condition|)
name|flags
operator|=
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sosend
argument_list|(
name|so
argument_list|,
name|sendnam
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|curthread
comment|/*XXX*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOBUFS
operator|&&
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Don't report EPIPE errors on nfs sockets. 		 * These can be due to idle tcp mounts which will be closed by 		 * netapp, solaris, etc. if left idle too long. 		 */
if|if
condition|(
name|error
operator|!=
name|EPIPE
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nfs send error %d for server %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Deal with errors for the client side. 		 */
name|error2
operator|=
name|NFS_SIGREP
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error2
condition|)
name|error
operator|=
name|error2
expr_stmt|;
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle any recoverable (soft) socket errors here. (?) 		 * Make EWOULDBLOCK a recoverable error, we'll rexmit from nfs_timer(). 		 */
if|if
condition|(
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
operator|&&
name|error
operator|!=
name|EIO
operator|&&
name|error
operator|!=
name|EPIPE
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nfs_reply
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sotype
decl_stmt|,
name|slpflag
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|rep
operator|->
name|r_nmp
decl_stmt|;
name|sotype
operator|=
name|nmp
operator|->
name|nm_sotype
expr_stmt|;
comment|/* 	 * For reliable protocols, lock against other senders/receivers 	 * in case a reconnect is necessary. 	 */
if|if
condition|(
name|sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
name|tryagain
label|:
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|so
operator|=
name|nmp
operator|->
name|nm_so
expr_stmt|;
if|if
condition|(
operator|!
name|so
operator|||
operator|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_FORCE_RECONNECT
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator||=
name|NFS_TCP_FORCE_RECONNECT
expr_stmt|;
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|tryagain
goto|;
block|}
while|while
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|sock_send_inprog
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nfs_wakup_reconnectors
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator||=
name|NFS_TCP_FORCE_RECONNECT
expr_stmt|;
name|error
operator|=
name|nfs_reconnect
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|tryagain
goto|;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nfs_wakup_reconnectors
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
name|slpflag
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sotype
operator|==
name|SOCK_DGRAM
operator|)
operator|||
operator|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|error
operator|=
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
operator|&
name|rep
operator|->
name|r_mtx
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsreq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
comment|/* NFS operations aren't restartable. Map ERESTART to EINTR */
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
comment|/* Request was terminated because we exceeded the retries (soft mount) */
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_FORCE_RECONNECT
operator|)
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
operator|)
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX TO DO  * Make nfs_realign() non-blocking. Also make nfsm_dissect() nonblocking.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_clnt_match_xid
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mrep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|u_int32_t
name|rxid
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Search for any mbufs that are not a multiple of 4 bytes long 	 * or with m_data not longword aligned. 	 * These could cause pointer alignment problems, so copy them to 	 * well aligned mbufs. 	 */
if|if
condition|(
name|nfs_realign
argument_list|(
operator|&
name|mrep
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
operator|==
name|ENOMEM
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the xid and check that it is an rpc reply 	 */
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|tl
operator|=
name|nfsm_dissect_nonblock
argument_list|(
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|rxid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
name|rpc_reply
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through the request list to match up the reply 	 * Iff no match, just drop the datagram 	 */
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|rxid
operator|==
name|rep
operator|->
name|r_xid
condition|)
block|{
comment|/* Found it.. */
name|rep
operator|->
name|r_mrep
operator|=
name|mrep
expr_stmt|;
name|rep
operator|->
name|r_md
operator|=
name|md
expr_stmt|;
name|rep
operator|->
name|r_dpos
operator|=
name|dpos
expr_stmt|;
comment|/* 			 * Update congestion window. 			 * Do the additive increase of 			 * one rpc/rtt. 			 */
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|<=
name|nmp
operator|->
name|nm_sent
condition|)
block|{
name|nmp
operator|->
name|nm_cwnd
operator|+=
operator|(
name|NFS_CWNDSCALE
operator|*
name|NFS_CWNDSCALE
operator|+
operator|(
name|nmp
operator|->
name|nm_cwnd
operator|>>
literal|1
operator|)
operator|)
operator|/
name|nmp
operator|->
name|nm_cwnd
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|>
name|NFS_MAXCWND
condition|)
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_MAXCWND
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
name|nfs_update_rtt
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_timeouts
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If not matched to a request, drop it. 	 * If it's mine, wake up requestor. 	 */
if|if
condition|(
name|rep
operator|==
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpcunexpected
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_mark_for_reconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nfsreq
modifier|*
name|rp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator||=
name|NFS_TCP_FORCE_RECONNECT
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/*  	 * Wakeup all processes that are waiting for replies  	 * on this mount point. One of them does the reconnect. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_nmp
operator|==
name|nmp
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|rp
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rp
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfstcp_readable
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>=
operator|(
name|bytes
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|||
name|so
operator|->
name|so_error
operator|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|nfstcp_marker_readable
parameter_list|(
name|so
parameter_list|)
value|nfstcp_readable(so, sizeof(u_int32_t))
end_define

begin_function
specifier|static
name|int
name|nfs_copy_len
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|mp
operator|!=
name|NULL
condition|)
block|{
name|int
name|copylen
init|=
name|min
argument_list|(
name|len
argument_list|,
name|mp
operator|->
name|m_len
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|mp
operator|->
name|m_data
argument_list|,
name|buf
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|copylen
expr_stmt|;
name|len
operator|-=
name|copylen
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_clnt_tcp_soupcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
operator|(
expr|struct
name|nfsmount
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|int
name|rcvflg
decl_stmt|;
comment|/* 	 * Don't pick any more data from the socket if we've marked the  	 * mountpoint for reconnect. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_FORCE_RECONNECT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_EXPECT_RPCMARKER
condition|)
block|{
name|int
name|resid
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nfstcp_marker_readable
argument_list|(
name|so
argument_list|)
condition|)
block|{
comment|/* Marker is not readable */
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
name|NULL
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
name|rcvflg
operator|=
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_SOCALLBCK
operator|)
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
operator|&
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 			 * We've already tested that the socket is readable. 2 cases  			 * here, we either read 0 bytes (client closed connection),  			 * or got some other error. In both cases, we tear down the  			 * connection. 			 */
if|if
condition|(
name|error
operator|||
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ECONNRESET
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nfs/tcp clnt: Error %d reading socket, tearing down TCP connection\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mark_reconnect
goto|;
block|}
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfs_clnt_tcp_soupcall: Got empty mbuf chain from sorecv\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Sigh. We can't do the obvious thing here (which would 			 * be to have soreceive copy the length from mbufs for us). 			 * Calling uiomove() from the context of a socket callback 			 * (even for kernel-kernel copies) leads to LORs (since 			 * we hold network locks at this point). 			 */
if|if
condition|(
operator|(
name|resid
operator|=
name|nfs_copy_len
argument_list|(
name|mp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s (%d) from nfs server %s\n"
argument_list|,
literal|"Bad RPC HDR length"
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|resid
argument_list|)
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
goto|goto
name|mark_reconnect
goto|;
block|}
name|len
operator|=
name|ntohl
argument_list|(
name|len
argument_list|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 			 * This is SERIOUS! We are out of sync with the sender 			 * and forcing a disconnect/reconnect is all I can do. 			 */
if|if
condition|(
name|len
operator|>
name|NFS_MAXPACKET
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s (%d) from nfs server %s\n"
argument_list|,
literal|"impossible packet length"
argument_list|,
name|len
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
goto|goto
name|mark_reconnect
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
operator|=
name|len
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&=
operator|~
operator|(
name|NFS_TCP_EXPECT_RPCMARKER
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/*  		 * Processed RPC marker or no RPC marker to process.  		 * Pull in and process data. 		 */
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nfstcp_readable
argument_list|(
name|so
argument_list|,
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
argument_list|)
condition|)
block|{
comment|/* All data not readable */
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
name|NULL
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
name|rcvflg
operator|=
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_SOCALLBCK
operator|)
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|auio
argument_list|,
operator|&
name|mp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ECONNRESET
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nfs/tcp clnt: Error %d reading socket, tearing down TCP connection\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|mark_reconnect
goto|;
block|}
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfs_clnt_tcp_soupcall: Got empty mbuf chain from sorecv\n"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|rpcresid
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator||=
name|NFS_TCP_EXPECT_RPCMARKER
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/* We got the entire RPC reply. Match XIDs and wake up requestor */
name|nfs_clnt_match_xid
argument_list|(
name|so
argument_list|,
name|nmp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
name|mark_reconnect
label|:
name|nfs_mark_for_reconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_clnt_udp_soupcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
operator|(
expr|struct
name|nfsmount
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rcvflag
decl_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
literal|1000000
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
name|rcvflag
operator|=
name|MSG_DONTWAIT
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
literal|1000000000
expr_stmt|;
do|do
block|{
name|mp
operator|=
name|control
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|auio
argument_list|,
operator|&
name|mp
argument_list|,
operator|&
name|control
argument_list|,
operator|&
name|rcvflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|nfs_clnt_match_xid
argument_list|(
name|so
argument_list|,
name|nmp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mp
operator|&&
operator|!
name|error
condition|)
do|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_send() for first transmit  *	- calls nfs_receive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_function
name|int
name|nfs_request
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mrest
parameter_list|,
name|int
name|procnum
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
parameter_list|,
name|caddr_t
modifier|*
name|dposp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mheadend
decl_stmt|;
name|time_t
name|waituntil
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|mrest_len
decl_stmt|,
name|auth_len
decl_stmt|,
name|auth_type
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|u_int32_t
modifier|*
name|xidp
decl_stmt|;
comment|/* Reject requests while attempting a forced unmount. */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
block|{
name|m_freem
argument_list|(
name|mrest
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|rep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|rep
operator|->
name|r_vp
operator|=
name|vp
expr_stmt|;
name|rep
operator|->
name|r_td
operator|=
name|td
expr_stmt|;
name|rep
operator|->
name|r_procnum
operator|=
name|procnum
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|,
literal|"NFSrep lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_lastmsg
operator|=
name|now
operator|.
name|tv_sec
operator|-
operator|(
operator|(
name|nmp
operator|->
name|nm_tprintf_delay
operator|)
operator|-
operator|(
name|nmp
operator|->
name|nm_tprintf_initial_delay
operator|)
operator|)
expr_stmt|;
name|mrest_len
operator|=
name|m_length
argument_list|(
name|mrest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Get the RPC header with authorization. 	 */
name|auth_type
operator|=
name|RPCAUTH_UNIX
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_ngroups
operator|<
literal|1
condition|)
name|panic
argument_list|(
literal|"nfsreq nogrps"
argument_list|)
expr_stmt|;
name|auth_len
operator|=
operator|(
operator|(
operator|(
operator|(
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
operator|)
operator|>
name|nmp
operator|->
name|nm_numgrps
operator|)
condition|?
name|nmp
operator|->
name|nm_numgrps
else|:
operator|(
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|5
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|m
operator|=
name|nfsm_rpchead
argument_list|(
name|cred
argument_list|,
name|nmp
operator|->
name|nm_flag
argument_list|,
name|procnum
argument_list|,
name|auth_type
argument_list|,
name|auth_len
argument_list|,
name|mrest
argument_list|,
name|mrest_len
argument_list|,
operator|&
name|mheadend
argument_list|,
operator|&
name|xidp
argument_list|)
expr_stmt|;
comment|/* 	 * For stream protocols, insert a Sun RPC Record Mark. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|NFSX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
block|}
name|rep
operator|->
name|r_mreq
operator|=
name|m
expr_stmt|;
name|rep
operator|->
name|r_xid
operator|=
operator|*
name|xidp
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
condition|)
name|rep
operator|->
name|r_retry
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
else|else
name|rep
operator|->
name|r_retry
operator|=
name|NFS_MAXREXMIT
operator|+
literal|1
expr_stmt|;
comment|/* past clip limit */
name|rep
operator|->
name|r_rtt
operator|=
name|rep
operator|->
name|r_rexmit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nfs_rto_timer
argument_list|(
name|procnum
argument_list|)
operator|!=
name|NFS_DEFAULT_TIMER
condition|)
name|rep
operator|->
name|r_flags
operator|=
name|R_TIMING
expr_stmt|;
else|else
name|rep
operator|->
name|r_flags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Do the client side RPC. 	 */
name|nfsstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
comment|/* 	 * Chain request into list of outstanding requests. Be sure 	 * to put it LAST so timer finds oldest requests first. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|nfs_reqq
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|nfs_callout
argument_list|,
name|nfs_ticks
argument_list|,
name|nfs_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfs_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If backing off another request or avoiding congestion, don't 	 * send this one now but let timer do it. If not timing a request, 	 * do it now. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_so
operator|&&
operator|(
operator|(
operator|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|flags
operator|&
name|NFS_TCP_FORCE_RECONNECT
operator|)
operator|)
operator|||
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
operator|)
operator|||
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_cwnd
operator|)
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
name|nmp
operator|->
name|nm_nfstcpstate
operator|.
name|sock_send_inprog
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|m2
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_send
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|m2
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
comment|/*  		 * nfs_timer() could've re-transmitted the request if we ended up 		 * blocking on nfs_send() too long, so check for R_SENT here. 		 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
operator|(
name|R_SENT
operator||
name|R_MUSTRESEND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_sent
operator|+=
name|NFS_CWNDSCALE
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
name|nfs_wakup_reconnectors
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Wait for the reply from our send or the timer's. 	 */
if|if
condition|(
operator|!
name|error
operator|||
name|error
operator|==
name|EPIPE
condition|)
name|error
operator|=
name|nfs_reply
argument_list|(
name|rep
argument_list|)
expr_stmt|;
comment|/* 	 * nfs_timer() may be in the process of re-transmitting this request. 	 * nfs_timer() drops the nfs_reqq_mtx before the pru_send() (to avoid LORs). 	 * Wait till nfs_timer() completes the re-transmission. When the reply  	 * comes back, it will be discarded (since the req struct for it no longer  	 * exists). 	 */
name|wait_for_pinned_req
label|:
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_PIN_REQ
condition|)
block|{
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rep
operator|->
name|r_flags
argument_list|,
operator|&
name|rep
operator|->
name|r_mtx
argument_list|,
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsrxmt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
comment|/* Have to check for R_PIN_REQ after grabbing wlock again */
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_PIN_REQ
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
goto|goto
name|wait_for_pinned_req
goto|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
comment|/* RPC done (timer not active, request not pinned), unlink the request */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfs_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|nfs_reqq
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|nfs_callout
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the outstanding request count. 	 */
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
comment|/* paranoia */
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If there was a successful reply and a tprintf msg. 	 * tprintf a response. 	 */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfs_up
argument_list|(
name|rep
argument_list|,
name|nmp
argument_list|,
name|rep
operator|->
name|r_td
argument_list|,
literal|"is alive again"
argument_list|,
name|NFSSTA_TIMEO
argument_list|)
expr_stmt|;
block|}
name|mrep
operator|=
name|rep
operator|->
name|r_mrep
expr_stmt|;
name|md
operator|=
name|rep
operator|->
name|r_md
expr_stmt|;
name|dpos
operator|=
name|rep
operator|->
name|r_dpos
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If we got interrupted by a signal in nfs_reply(), there's 		 * a very small window where the reply could've come in before 		 * this process got scheduled in. To handle that case, we need  		 * to free the reply if it was delivered. 		 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfs_request: rep->r_mrep shouldn't be NULL if no error\n"
argument_list|)
expr_stmt|;
comment|/* 	 * break down the rpc header and check if ok 	 */
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|==
name|rpc_msgdenied
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|rpc_mismatch
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Just throw away any verifyer (ie: kerberos etc). 	 */
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
comment|/* verf type */
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* len */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 0 == ok */
if|if
condition|(
operator|*
name|tl
operator|==
literal|0
condition|)
block|{
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
operator|&&
name|error
operator|==
name|NFSERR_TRYLATER
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|waituntil
operator|=
name|time_second
operator|+
name|nfs3_jukebox_delay
expr_stmt|;
while|while
condition|(
name|time_second
operator|<
name|waituntil
condition|)
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|fake_wchan
argument_list|,
name|PSOCK
argument_list|,
literal|"nqnfstry"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|rep
operator|->
name|r_xid
operator|=
operator|*
name|xidp
operator|=
name|txdr_unsigned
argument_list|(
name|nfs_xid_gen
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* 			 * If the File Handle was stale, invalidate the 			 * lookup cache, just in case. 			 */
if|if
condition|(
name|error
operator|==
name|ESTALE
condition|)
name|nfs_purgecache
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 			 * Skip wcc data on NFS errors for now. NetApp filers return corrupt 			 * postop attrs in the wcc data for NFS err EROFS. Not sure if they  			 * could return corrupt postop attrs for others errors. 			 */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
operator|&&
operator|!
name|nfs_skip_wcc_data_onerr
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|error
operator||=
name|NFSERR_RETERR
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
name|nfsmout
label|:
name|m_freem
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs timer routine  * Scan the nfsreq list and retranmit any requests that have timed out  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0 (implies nm_retry == 0).  *   * The nfs reqq lock cannot be held while we do the pru_send() because of a  * lock ordering violation. The NFS client socket callback acquires   * inp_lock->nfsreq mutex and pru_send acquires inp_lock. So we drop the   * reqq mutex (and reacquire it after the pru_send()). The req structure  * (for the rexmit) is prevented from being removed by the R_PIN_REQ flag.  */
end_comment

begin_function
name|void
name|nfs_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|timeo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
name|nmp
operator|=
name|rep
operator|->
name|r_nmp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* 			 * Terminate request if force-unmount in progress. 			 * Note that NFS could have vfs_busy'ed the mount, 			 * causing the unmount to wait and making this bit 			 * of logic necessary. 			 */
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
block|{
name|nfs_softterm
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_td
argument_list|)
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_tprintf_initial_delay
operator|!=
literal|0
operator|&&
operator|(
name|rep
operator|->
name|r_rexmit
operator|>
literal|2
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_RESENDERR
operator|)
operator|)
operator|&&
name|rep
operator|->
name|r_lastmsg
operator|+
name|nmp
operator|->
name|nm_tprintf_delay
operator|<
name|now
operator|.
name|tv_sec
condition|)
block|{
name|rep
operator|->
name|r_lastmsg
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
comment|/* 			 * Pin down the request and drop locks for the acquisition 			 * of Giant from tprintf() in nfs_down(). 			 */
name|rep
operator|->
name|r_flags
operator||=
name|R_PIN_REQ
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|nfs_down
argument_list|(
name|rep
argument_list|,
name|nmp
argument_list|,
name|rep
operator|->
name|r_td
argument_list|,
literal|"not responding"
argument_list|,
literal|0
argument_list|,
name|NFSSTA_TIMEO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_PIN_REQ
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rep
operator|->
name|r_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|>=
literal|0
condition|)
block|{
name|rep
operator|->
name|r_rtt
operator|++
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
condition|)
name|timeo
operator|=
name|nmp
operator|->
name|nm_timeo
expr_stmt|;
else|else
name|timeo
operator|=
name|nfs_estimate_rto
argument_list|(
name|nmp
argument_list|,
name|rep
operator|->
name|r_procnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_timeouts
operator|>
literal|0
condition|)
name|timeo
operator|*=
name|nfs_backoff
index|[
name|nmp
operator|->
name|nm_timeouts
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|<=
name|timeo
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_timeouts
operator|<
name|NFS_NBACKOFF
condition|)
name|nmp
operator|->
name|nm_timeouts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rexmit
operator|>=
name|rep
operator|->
name|r_retry
condition|)
block|{
comment|/* too many */
name|nfsstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|nfs_softterm
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
comment|/* 			 * For NFS/TCP, setting R_MUSTRESEND and waking up  			 * the requester will cause the request to be    			 * retransmitted (in nfs_reply()), re-connecting 			 * if necessary. 			 */
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_rtt
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|nmp
operator|->
name|nm_so
operator|)
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If there is enough space and the window allows.. 		 *	Resend it 		 * Set r_rtt to -1 in case we fail to send it now. 		 */
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>=
name|rep
operator|->
name|r_mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|&&
operator|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DUMBTIMR
operator|)
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
operator|)
operator|||
name|nmp
operator|->
name|nm_sent
operator|<
name|nmp
operator|->
name|nm_cwnd
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * Mark the request to indicate that a XMIT is in  				 * progress to prevent the req structure being  				 * removed in nfs_request(). 				 */
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_PIN_REQ
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_PIN_REQ
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rep
operator|->
name|r_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFSIGNORE_SOERROR
argument_list|(
name|nmp
operator|->
name|nm_soflags
argument_list|,
name|error
argument_list|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_RESENDERR
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Iff first send, start timing 					 * else turn timing off, backoff timer 					 * and divide congestion window by 2. 					 */
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_RESENDERR
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|NFS_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|NFS_MAXREXMIT
expr_stmt|;
name|nmp
operator|->
name|nm_cwnd
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_cwnd
operator|<
name|NFS_CWNDSCALE
condition|)
name|nmp
operator|->
name|nm_cwnd
operator|=
name|NFS_CWNDSCALE
expr_stmt|;
name|nfsstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
name|nmp
operator|->
name|nm_sent
operator|+=
name|NFS_CWNDSCALE
expr_stmt|;
block|}
name|rep
operator|->
name|r_rtt
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|nfs_callout
argument_list|,
name|nfs_ticks
argument_list|,
name|nfs_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark all of an nfs mount's outstanding requests with R_SOFTTERM and  * wait for all requests to complete. This is used by forced unmounts  * to terminate any outstanding RPCs.  */
end_comment

begin_function
name|int
name|nfs_nmcancelreqs
parameter_list|(
name|nmp
parameter_list|)
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
block|{
name|struct
name|nfsreq
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|req
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|req
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|req
operator|->
name|r_nmp
operator|||
name|req
operator|->
name|r_mrep
operator|!=
name|NULL
operator|||
operator|(
name|req
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|req
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nfs_softterm
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|req
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|req
argument_list|,
argument|&nfs_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|nmp
operator|==
name|req
operator|->
name|r_nmp
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfs_reqq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tsleep
argument_list|(
operator|&
name|fake_wchan
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscancel"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flag a request as being about to terminate (due to NFSMNT_INT/NFSMNT_SOFT).  * The nm_send count is decremented now to avoid deadlocks when the process in  * soreceive() hasn't yet managed to send its own request.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_softterm
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|mtx_owned
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
argument_list|,
operator|(
literal|"NFS req lock not owned !"
operator|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_nmp
operator|->
name|nm_sent
operator|-=
name|NFS_CWNDSCALE
expr_stmt|;
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
block|}
comment|/*  	 * Request terminated, wakeup the blocked process, so that we 	 * can return EINTR back. 	 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Any signal that can interrupt an NFS operation in an intr mount  * should be added to this set. SIGSTOP and SIGKILL cannot be masked.  */
end_comment

begin_decl_stmt
name|int
name|nfs_sig_set
index|[]
init|=
block|{
name|SIGINT
block|,
name|SIGTERM
block|,
name|SIGHUP
block|,
name|SIGKILL
block|,
name|SIGSTOP
block|,
name|SIGQUIT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check to see if one of the signals in our subset is pending on  * the process (in an intr mount).  */
end_comment

begin_function
specifier|static
name|int
name|nfs_sig_pending
parameter_list|(
name|sigset_t
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nfs_sig_set
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|set
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The set/restore sigmask functions are used to (temporarily) overwrite  * the process p_sigmask during an RPC call (for example). These are also  * used in other places in the NFS client that might tsleep().  */
end_comment

begin_function
name|void
name|nfs_set_sigmask
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|sigset_t
modifier|*
name|oldset
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|SIGFILLSET
argument_list|(
name|newset
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* Remove the NFS set of signals from newset */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nfs_sig_set
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * But make sure we leave the ones already masked 		 * by the process, ie. remove the signal from the 		 * temporary signalmask only if it wasn't already 		 * in p_sigmask. 		 */
if|if
condition|(
operator|!
name|SIGISMEMBER
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|SIGISMEMBER
argument_list|(
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
name|SIGDELSET
argument_list|(
name|newset
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|newset
argument_list|,
name|oldset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nfs_restore_sigmask
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NFS wrapper to msleep(), that shoves a new p_sigmask and restores the  * old one after msleep() returns.  */
end_comment

begin_function
name|int
name|nfs_msleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|ident
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|,
name|int
name|priority
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|sigset_t
name|oldset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|priority
operator|&
name|PCATCH
operator|)
operator|==
literal|0
condition|)
return|return
name|msleep
argument_list|(
name|ident
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
return|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|nfs_set_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|ident
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|nfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for a termination condition pending on the process.  * This is used for NFSMNT_INT mounts.  */
end_comment

begin_function
name|int
name|nfs_sigintr
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|sigset_t
name|tmpset
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate all requests while attempting a forced unmount. */
if|if
condition|(
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tmpset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETOR
argument_list|(
name|tmpset
argument_list|,
name|td
operator|->
name|td_siglist
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|||
name|SIGNOTEMPTY
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|)
operator|)
operator|&&
name|nfs_sig_pending
argument_list|(
name|tmpset
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a socket against others.  * Necessary for STREAM sockets to ensure you get an entire rpc request/reply  * and also to avoid race conditions between the processes with nfs requests  * in progress when a reconnect is necessary.  */
end_comment

begin_function
name|int
name|nfs_connect_lock
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|,
name|slpflag
init|=
literal|0
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
name|td
operator|=
name|rep
operator|->
name|r_td
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
while|while
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_SNDLOCK
condition|)
block|{
name|error
operator|=
name|nfs_sigintr
argument_list|(
name|rep
operator|->
name|r_nmp
argument_list|,
name|rep
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|statep
operator||=
name|NFSSTA_WANTSND
expr_stmt|;
operator|(
name|void
operator|)
name|msleep
argument_list|(
name|statep
argument_list|,
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_mtx
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"nfsndlck"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
operator|*
name|statep
operator||=
name|NFSSTA_SNDLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
name|void
name|nfs_connect_unlock
parameter_list|(
name|struct
name|nfsreq
modifier|*
name|rep
parameter_list|)
block|{
name|int
modifier|*
name|statep
init|=
operator|&
name|rep
operator|->
name|r_nmp
operator|->
name|nm_state
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|statep
operator|&
name|NFSSTA_SNDLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs sndunlock"
argument_list|)
expr_stmt|;
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_SNDLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|statep
operator|&
name|NFSSTA_WANTSND
condition|)
block|{
operator|*
name|statep
operator|&=
operator|~
name|NFSSTA_WANTSND
expr_stmt|;
name|wakeup
argument_list|(
name|statep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	nfs_realign:  *  *	Check for badly aligned mbuf data and realign by copying the unaligned  *	portion of the data into a new mbuf chain and freeing the portions  *	of the old chain that were replaced.  *  *	We cannot simply realign the data within the existing mbuf chain  *	because the underlying buffers may contain other rpc commands and  *	we cannot afford to overwrite them.  *  *	We would prefer to avoid this situation entirely.  The situation does  *	not occur with NFS/UDP and is supposed to only occassionally occur  *	with TCP.  Use vfs.nfs.realign_count and realign_test to check this.  *  */
end_comment

begin_function
specifier|static
name|int
name|nfs_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|hsiz
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
operator|++
name|nfs_realign_test
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|*
name|pm
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|intptr_t
argument_list|)
operator|&
literal|0x3
operator|)
condition|)
block|{
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_ext
operator|.
name|ext_buf
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pm
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * If n is non-NULL, loop on m copying data, then replace the 	 * portion of the chain that had to be realigned. 	 */
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
operator|++
name|nfs_realign_count
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|m_copyback
argument_list|(
name|n
argument_list|,
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|server
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
condition|?
name|td
operator|->
name|td_proc
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s, error %d\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nfs_down
parameter_list|(
name|rep
parameter_list|,
name|nmp
parameter_list|,
name|td
parameter_list|,
name|msg
parameter_list|,
name|error
parameter_list|,
name|flags
parameter_list|)
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_TIMEO
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_TIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_TIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NFSSTA_LOCKTIMEO
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rep
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TPRINTFMSG
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
block|}
name|nfs_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nfs_up
parameter_list|(
name|rep
parameter_list|,
name|nmp
parameter_list|,
name|td
parameter_list|,
name|msg
parameter_list|,
name|flags
parameter_list|)
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|nmp
operator|==
name|NULL
operator|||
name|rep
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|nfs_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|rep
operator|->
name|r_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_TIMEO
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_TIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_TIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NFSSTA_LOCKTIMEO
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_LEGACYRPC */
end_comment

end_unit

