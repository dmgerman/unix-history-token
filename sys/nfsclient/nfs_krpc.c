begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1991, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_socket.c	8.5 (Berkeley) 3/30/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Socket operations for use by nfs  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_kgssapi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsnode.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_decl_stmt
name|dtrace_nfsclient_nfs23_start_probe_func_t
name|dtrace_nfsclient_nfs23_start_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_nfsclient_nfs23_done_probe_func_t
name|dtrace_nfsclient_nfs23_done_probe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Registered probes by RPC type.  */
end_comment

begin_decl_stmt
name|uint32_t
name|nfsclient_nfs2_start_probes
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfsclient_nfs2_done_probes
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfsclient_nfs3_start_probes
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfsclient_nfs3_done_probes
index|[
name|NFS_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|nfs_bufpackets
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_reconnects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs3_jukebox_delay
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_skip_wcc_data_onerr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fake_wchan
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_oldnfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_oldnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufpackets
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_bufpackets
argument_list|,
literal|0
argument_list|,
literal|"Buffer reservation size 2< x< 64"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_oldnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|reconnects
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nfs_reconnects
argument_list|,
literal|0
argument_list|,
literal|"Number of times the nfs client has had to reconnect"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_oldnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs3_jukebox_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs3_jukebox_delay
argument_list|,
literal|0
argument_list|,
literal|"Number of seconds to delay a retry after receiving EJUKEBOX"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_oldnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|skip_wcc_data_onerr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_skip_wcc_data_onerr
argument_list|,
literal|0
argument_list|,
literal|"Disable weak cache consistency checking when server returns an error"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|nfs_down
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfs_up
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|nfsv2_procid
index|[]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|nfs_cached_auth
block|{
name|int
name|ca_refs
decl_stmt|;
comment|/* refcount, including 1 from the cache */
name|uid_t
name|ca_uid
decl_stmt|;
comment|/* uid that corresponds to this auth */
name|AUTH
modifier|*
name|ca_auth
decl_stmt|;
comment|/* RPC auth handle */
block|}
struct|;
end_struct

begin_comment
comment|/*  * RTT estimator  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|nfs_rto_timer_t
name|nfs_proct
index|[
name|NFS_NPROCS
index|]
init|=
block|{
name|NFS_DEFAULT_TIMER
block|,
comment|/* NULL */
name|NFS_GETATTR_TIMER
block|,
comment|/* GETATTR */
name|NFS_DEFAULT_TIMER
block|,
comment|/* SETATTR */
name|NFS_LOOKUP_TIMER
block|,
comment|/* LOOKUP */
name|NFS_GETATTR_TIMER
block|,
comment|/* ACCESS */
name|NFS_READ_TIMER
block|,
comment|/* READLINK */
name|NFS_READ_TIMER
block|,
comment|/* READ */
name|NFS_WRITE_TIMER
block|,
comment|/* WRITE */
name|NFS_DEFAULT_TIMER
block|,
comment|/* CREATE */
name|NFS_DEFAULT_TIMER
block|,
comment|/* MKDIR */
name|NFS_DEFAULT_TIMER
block|,
comment|/* SYMLINK */
name|NFS_DEFAULT_TIMER
block|,
comment|/* MKNOD */
name|NFS_DEFAULT_TIMER
block|,
comment|/* REMOVE */
name|NFS_DEFAULT_TIMER
block|,
comment|/* RMDIR */
name|NFS_DEFAULT_TIMER
block|,
comment|/* RENAME */
name|NFS_DEFAULT_TIMER
block|,
comment|/* LINK */
name|NFS_READ_TIMER
block|,
comment|/* READDIR */
name|NFS_READ_TIMER
block|,
comment|/* READDIRPLUS */
name|NFS_DEFAULT_TIMER
block|,
comment|/* FSSTAT */
name|NFS_DEFAULT_TIMER
block|,
comment|/* FSINFO */
name|NFS_DEFAULT_TIMER
block|,
comment|/* PATHCONF */
name|NFS_DEFAULT_TIMER
block|,
comment|/* COMMIT */
name|NFS_DEFAULT_TIMER
block|,
comment|/* NOOP */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Choose the correct RTT timer for this NFS procedure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|nfs_rto_timer_t
name|nfs_rto_timer
parameter_list|(
name|u_int32_t
name|procnum
parameter_list|)
block|{
return|return
operator|(
name|nfs_proct
index|[
name|procnum
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the RTT estimator state for a new mount point.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_init_rtt
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_MAX_TIMER
condition|;
name|i
operator|++
control|)
block|{
name|nmp
operator|->
name|nm_timers
index|[
name|i
index|]
operator|.
name|rt_srtt
operator|=
name|hz
expr_stmt|;
name|nmp
operator|->
name|nm_timers
index|[
name|i
index|]
operator|.
name|rt_deviate
operator|=
literal|0
expr_stmt|;
name|nmp
operator|->
name|nm_timers
index|[
name|i
index|]
operator|.
name|rt_rtxcur
operator|=
name|hz
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize sockets and congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_function
name|int
name|nfs_connect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|int
name|rcvreserve
decl_stmt|,
name|sndreserve
decl_stmt|;
name|int
name|pktscale
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|struct
name|ucred
modifier|*
name|origcred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
name|rpcvers_t
name|vers
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|,
name|retries
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
comment|/* 	 * We need to establish the socket using the credentials of 	 * the mountpoint.  Some parts of this process (such as 	 * sobind() and soconnect()) will use the curent thread's 	 * credential instead of the socket credential.  To work 	 * around this, temporarily change the current thread's 	 * credential to that of the mountpoint. 	 * 	 * XXX: It would be better to explicitly pass the correct 	 * credential to sobind() and soconnect(). 	 */
name|origcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_cred
expr_stmt|;
name|saddr
operator|=
name|nmp
operator|->
name|nm_nam
expr_stmt|;
name|vers
operator|=
name|NFS_VER2
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
condition|)
name|vers
operator|=
name|NFS_VER3
expr_stmt|;
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV4
condition|)
name|vers
operator|=
name|NFS_VER4
expr_stmt|;
if|if
condition|(
name|saddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"udp"
argument_list|)
expr_stmt|;
else|else
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"udp6"
argument_list|)
expr_stmt|;
else|else
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"tcp6"
argument_list|)
expr_stmt|;
comment|/* 	 * Get buffer reservation size from sysctl, but impose reasonable 	 * limits. 	 */
name|pktscale
operator|=
name|nfs_bufpackets
expr_stmt|;
if|if
condition|(
name|pktscale
operator|<
literal|2
condition|)
name|pktscale
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pktscale
operator|>
literal|64
condition|)
name|pktscale
operator|=
literal|64
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_SEQPACKET
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|max
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|,
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"nfscon sotype"
argument_list|)
expr_stmt|;
name|sndreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|client
operator|=
name|clnt_reconnect_create
argument_list|(
name|nconf
argument_list|,
name|saddr
argument_list|,
name|NFS_PROG
argument_list|,
name|vers
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_WAITCHAN
argument_list|,
literal|"nfsreq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_INTERRUPTIBLE
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_RESVPORT
condition|)
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_PRIVPORT
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
comment|/* 			 * For UDP, the large timeout for a reconnect will 			 * be set to "nm_retry * nm_timeo / 2", so we only 			 * want to do 2 reconnect timeout retries. 			 */
name|retries
operator|=
literal|2
expr_stmt|;
else|else
name|retries
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
block|}
else|else
name|retries
operator|=
name|INT_MAX
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_RETRIES
argument_list|,
operator|&
name|retries
argument_list|)
expr_stmt|;
comment|/* 	 * For UDP, there are 2 timeouts: 	 * - CLSET_RETRY_TIMEOUT sets the initial timeout for the timer 	 *   that does a retransmit of an RPC request using the same socket 	 *   and xid. This is what you normally want to do, since NFS 	 *   servers depend on "same xid" for their Duplicate Request Cache. 	 * - timeout specified in CLNT_CALL_MBUF(), which specifies when 	 *   retransmits on the same socket should fail and a fresh socket 	 *   created. Each of these timeouts counts as one CLSET_RETRIES, 	 *   as set above. 	 * Set the initial retransmit timeout for UDP. This timeout doesn't 	 * exist for TCP and the following call just fails, which is ok. 	 */
name|timo
operator|.
name|tv_sec
operator|=
name|nmp
operator|->
name|nm_timeo
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
operator|(
name|nmp
operator|->
name|nm_timeo
operator|%
name|NFS_HZ
operator|)
operator|*
literal|1000000
operator|/
name|NFS_HZ
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_RETRY_TIMEOUT
argument_list|,
operator|&
name|timo
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_client
condition|)
block|{
comment|/* 		 * Someone else already connected. 		 */
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
else|else
name|nmp
operator|->
name|nm_client
operator|=
name|client
expr_stmt|;
comment|/* 	 * Protocols that do not require connections may be optionally left 	 * unconnected for servers that reply from a port other than NFS_PORT. 	 */
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_CONNECT
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/* Restore current thread's credentials. */
name|td
operator|->
name|td_ucred
operator|=
name|origcred
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
comment|/* Initialize other non-zero congestion variables. */
name|nfs_init_rtt
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS disconnect.  Clean up and unlink.  */
end_comment

begin_function
name|void
name|nfs_disconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_client
condition|)
block|{
name|client
operator|=
name|nmp
operator|->
name|nm_client
expr_stmt|;
name|nmp
operator|->
name|nm_client
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|rpc_gss_secpurge_call
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|CLNT_CLOSE
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nfs_safedisconnect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|nfs_disconnect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|AUTH
modifier|*
name|nfs_getauth
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|rpc_gss_service_t
name|svc
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
switch|switch
condition|(
name|nmp
operator|->
name|nm_secflavor
condition|)
block|{
case|case
name|RPCSEC_GSS_KRB5
case|:
case|case
name|RPCSEC_GSS_KRB5I
case|:
case|case
name|RPCSEC_GSS_KRB5P
case|:
if|if
condition|(
operator|!
name|nmp
operator|->
name|nm_mech_oid
condition|)
if|if
condition|(
operator|!
name|rpc_gss_mech_to_oid_call
argument_list|(
literal|"kerberosv5"
argument_list|,
operator|&
name|nmp
operator|->
name|nm_mech_oid
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nmp
operator|->
name|nm_secflavor
operator|==
name|RPCSEC_GSS_KRB5
condition|)
name|svc
operator|=
name|rpc_gss_svc_none
expr_stmt|;
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_secflavor
operator|==
name|RPCSEC_GSS_KRB5I
condition|)
name|svc
operator|=
name|rpc_gss_svc_integrity
expr_stmt|;
else|else
name|svc
operator|=
name|rpc_gss_svc_privacy
expr_stmt|;
name|auth
operator|=
name|rpc_gss_secfind_call
argument_list|(
name|nmp
operator|->
name|nm_client
argument_list|,
name|cred
argument_list|,
name|nmp
operator|->
name|nm_principal
argument_list|,
name|nmp
operator|->
name|nm_mech_oid
argument_list|,
name|svc
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
condition|)
return|return
operator|(
name|auth
operator|)
return|;
comment|/* fallthrough */
case|case
name|AUTH_SYS
case|:
default|default:
return|return
operator|(
name|authunix_create
argument_list|(
name|cred
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Callback from the RPC code to generate up/down notifications.  */
end_comment

begin_struct
struct|struct
name|nfs_feedback_arg
block|{
name|struct
name|nfsmount
modifier|*
name|nf_mount
decl_stmt|;
name|int
name|nf_lastmsg
decl_stmt|;
comment|/* last tprintf */
name|int
name|nf_tprintfmsg
decl_stmt|;
name|struct
name|thread
modifier|*
name|nf_td
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nfs_feedback
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|proc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nfs_feedback_arg
modifier|*
name|nf
init|=
operator|(
expr|struct
name|nfs_feedback_arg
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|nf
operator|->
name|nf_mount
decl_stmt|;
name|time_t
name|now
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FEEDBACK_REXMIT2
case|:
case|case
name|FEEDBACK_RECONNECT
case|:
name|now
operator|=
name|time_uptime
expr_stmt|;
if|if
condition|(
name|nf
operator|->
name|nf_lastmsg
operator|+
name|nmp
operator|->
name|nm_tprintf_delay
operator|<
name|now
condition|)
block|{
name|nfs_down
argument_list|(
name|nmp
argument_list|,
name|nf
operator|->
name|nf_td
argument_list|,
literal|"not responding"
argument_list|,
literal|0
argument_list|,
name|NFSSTA_TIMEO
argument_list|)
expr_stmt|;
name|nf
operator|->
name|nf_tprintfmsg
operator|=
name|TRUE
expr_stmt|;
name|nf
operator|->
name|nf_lastmsg
operator|=
name|now
expr_stmt|;
block|}
break|break;
case|case
name|FEEDBACK_OK
case|:
name|nfs_up
argument_list|(
name|nf
operator|->
name|nf_mount
argument_list|,
name|nf
operator|->
name|nf_td
argument_list|,
literal|"is alive again"
argument_list|,
name|NFSSTA_TIMEO
argument_list|,
name|nf
operator|->
name|nf_tprintfmsg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * nfs_request - goes something like this  *	- fill in request struct  *	- links it into list  *	- calls nfs_send() for first transmit  *	- calls nfs_receive() to get reply  *	- break down rpc header and return with nfs reply pointed to  *	  by mrep or error  * nb: always frees up mreq mbuf list  */
end_comment

begin_function
name|int
name|nfs_request
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mreq
parameter_list|,
name|int
name|procnum
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mrp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
parameter_list|,
name|caddr_t
modifier|*
name|dposp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|time_t
name|waituntil
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|timeo
decl_stmt|;
name|AUTH
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
name|enum
name|nfs_rto_timer_t
name|timer
decl_stmt|;
name|struct
name|nfs_feedback_arg
name|nf
decl_stmt|;
name|struct
name|rpc_callextra
name|ext
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
comment|/* Reject requests while attempting a forced unmount. */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
block|{
name|m_freem
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|nf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfs_feedback_arg
argument_list|)
argument_list|)
expr_stmt|;
name|nf
operator|.
name|nf_mount
operator|=
name|nmp
expr_stmt|;
name|nf
operator|.
name|nf_td
operator|=
name|td
expr_stmt|;
name|nf
operator|.
name|nf_lastmsg
operator|=
name|time_uptime
operator|-
operator|(
operator|(
name|nmp
operator|->
name|nm_tprintf_delay
operator|)
operator|-
operator|(
name|nmp
operator|->
name|nm_tprintf_initial_delay
operator|)
operator|)
expr_stmt|;
comment|/* 	 * XXX if not already connected call nfs_connect now.  Longer 	 * term, change nfs_mount to call nfs_connect unconditionally 	 * and let clnt_reconnect_create handle reconnects. 	 */
if|if
condition|(
operator|!
name|nmp
operator|->
name|nm_client
condition|)
name|nfs_connect
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|auth
operator|=
name|nfs_getauth
argument_list|(
name|nmp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth
condition|)
block|{
name|m_freem
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|.
name|rc_auth
operator|=
name|auth
expr_stmt|;
name|ext
operator|.
name|rc_feedback
operator|=
name|nfs_feedback
expr_stmt|;
name|ext
operator|.
name|rc_feedback_arg
operator|=
operator|&
name|nf
expr_stmt|;
comment|/* 	 * Use a conservative timeout for RPCs other than getattr, 	 * lookup, read or write.  The justification for doing "other" 	 * this way is that these RPCs happen so infrequently that 	 * timer est. would probably be stale.  Also, since many of 	 * these RPCs are non-idempotent, a conservative timeout is 	 * desired. 	 */
name|timer
operator|=
name|nfs_rto_timer
argument_list|(
name|procnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|!=
name|NFS_DEFAULT_TIMER
condition|)
name|ext
operator|.
name|rc_timers
operator|=
operator|&
name|nmp
operator|->
name|nm_timers
index|[
name|timer
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|ext
operator|.
name|rc_timers
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|dtrace_nfsclient_nfs23_start_probe
operator|!=
name|NULL
condition|)
block|{
name|uint32_t
name|probe_id
decl_stmt|;
name|int
name|probe_procnum
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
condition|)
block|{
name|probe_id
operator|=
name|nfsclient_nfs3_start_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
else|else
block|{
name|probe_id
operator|=
name|nfsclient_nfs2_start_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|nfsv2_procid
index|[
name|procnum
index|]
expr_stmt|;
block|}
if|if
condition|(
name|probe_id
operator|!=
literal|0
condition|)
call|(
name|dtrace_nfsclient_nfs23_start_probe
call|)
argument_list|(
name|probe_id
argument_list|,
name|vp
argument_list|,
name|mreq
argument_list|,
name|cred
argument_list|,
name|probe_procnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|nfsstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
name|tryagain
label|:
comment|/* 	 * This timeout specifies when a new socket should be created, 	 * along with new xid values. For UDP, this should be done 	 * infrequently, since retransmits of RPC requests should normally 	 * use the same xid. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * CLSET_RETRIES is set to 2, so this should be half 			 * of the total timeout required. 			 */
name|timeo
operator|=
name|nmp
operator|->
name|nm_retry
operator|*
name|nmp
operator|->
name|nm_timeo
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|timeo
operator|<
literal|1
condition|)
name|timeo
operator|=
literal|1
expr_stmt|;
name|timo
operator|.
name|tv_sec
operator|=
name|timeo
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
operator|(
name|timeo
operator|%
name|NFS_HZ
operator|)
operator|*
literal|1000000
operator|/
name|NFS_HZ
expr_stmt|;
block|}
else|else
block|{
comment|/* For UDP hard mounts, use a large value. */
name|timo
operator|.
name|tv_sec
operator|=
name|NFS_MAXTIMEO
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|timo
operator|.
name|tv_sec
operator|=
name|nmp
operator|->
name|nm_timeo
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
operator|(
name|nmp
operator|->
name|nm_timeo
operator|%
name|NFS_HZ
operator|)
operator|*
literal|1000000
operator|/
name|NFS_HZ
expr_stmt|;
block|}
name|mrep
operator|=
name|NULL
expr_stmt|;
name|stat
operator|=
name|CLNT_CALL_MBUF
argument_list|(
name|nmp
operator|->
name|nm_client
argument_list|,
operator|&
name|ext
argument_list|,
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
condition|?
name|procnum
else|:
name|nfsv2_procid
index|[
name|procnum
index|]
argument_list|,
name|mreq
argument_list|,
operator|&
name|mrep
argument_list|,
name|timo
argument_list|)
expr_stmt|;
comment|/* 	 * If there was a successful reply and a tprintf msg. 	 * tprintf a response. 	 */
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
name|error
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_TIMEDOUT
condition|)
block|{
name|nfsstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_VERSMISMATCH
condition|)
block|{
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_PROGVERSMISMATCH
condition|)
block|{
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_INTR
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
else|else
block|{
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|KASSERT
argument_list|(
name|mrep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mrep shouldn't be NULL if no error\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search for any mbufs that are not a multiple of 4 bytes long 	 * or with m_data not longword aligned. 	 * These could cause pointer alignment problems, so copy them to 	 * well aligned mbufs. 	 */
name|error
operator|=
name|nfs_realign
argument_list|(
operator|&
name|mrep
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|mrep
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|tl
operator|=
name|nfsm_dissect
argument_list|(
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
operator|&&
name|error
operator|==
name|NFSERR_TRYLATER
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|waituntil
operator|=
name|time_second
operator|+
name|nfs3_jukebox_delay
expr_stmt|;
while|while
condition|(
name|time_second
operator|<
name|waituntil
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|fake_wchan
argument_list|,
name|PSOCK
argument_list|,
literal|"nqnfstry"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* 		 * Make sure NFSERR_RETERR isn't bogusly set by a server 		 * such as amd. (No actual NFS error has bit 31 set.) 		 */
name|error
operator|&=
operator|~
name|NFSERR_RETERR
expr_stmt|;
comment|/* 		 * If the File Handle was stale, invalidate the lookup 		 * cache, just in case. 		 */
if|if
condition|(
name|error
operator|==
name|ESTALE
condition|)
name|nfs_purgecache
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * Skip wcc data on non-ENOENT NFS errors for now. 		 * NetApp filers return corrupt postop attrs in the 		 * wcc data for NFS err EROFS.  Not sure if they could 		 * return corrupt postop attrs for others errors. 		 * Blocking ENOENT post-op attributes breaks negative 		 * name caching, so always allow it through. 		 */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
operator|&&
operator|(
operator|!
name|nfs_skip_wcc_data_onerr
operator|||
name|error
operator|==
name|ENOENT
operator|)
condition|)
block|{
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|error
operator||=
name|NFSERR_RETERR
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|dtrace_nfsclient_nfs23_done_probe
operator|!=
name|NULL
condition|)
block|{
name|uint32_t
name|probe_id
decl_stmt|;
name|int
name|probe_procnum
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
condition|)
block|{
name|probe_id
operator|=
name|nfsclient_nfs3_done_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
else|else
block|{
name|probe_id
operator|=
name|nfsclient_nfs2_done_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
condition|?
name|procnum
else|:
name|nfsv2_procid
index|[
name|procnum
index|]
expr_stmt|;
block|}
if|if
condition|(
name|probe_id
operator|!=
literal|0
condition|)
call|(
name|dtrace_nfsclient_nfs23_done_probe
call|)
argument_list|(
name|probe_id
argument_list|,
name|vp
argument_list|,
name|mreq
argument_list|,
name|cred
argument_list|,
name|probe_procnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
operator|*
name|mrp
operator|=
name|mrep
expr_stmt|;
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
operator|*
name|dposp
operator|=
name|dpos
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|dtrace_nfsclient_nfs23_done_probe
operator|!=
name|NULL
condition|)
block|{
name|uint32_t
name|probe_id
decl_stmt|;
name|int
name|probe_procnum
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
condition|)
block|{
name|probe_id
operator|=
name|nfsclient_nfs3_done_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
else|else
block|{
name|probe_id
operator|=
name|nfsclient_nfs2_done_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV3
operator|)
condition|?
name|procnum
else|:
name|nfsv2_procid
index|[
name|procnum
index|]
expr_stmt|;
block|}
if|if
condition|(
name|probe_id
operator|!=
literal|0
condition|)
call|(
name|dtrace_nfsclient_nfs23_done_probe
call|)
argument_list|(
name|probe_id
argument_list|,
name|vp
argument_list|,
name|mreq
argument_list|,
name|cred
argument_list|,
name|probe_procnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
condition|)
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark all of an nfs mount's outstanding requests with R_SOFTTERM and  * wait for all requests to complete.  This is used by forced unmounts  * to terminate any outstanding RPCs.  */
end_comment

begin_function
name|int
name|nfs_nmcancelreqs
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_client
condition|)
name|CLNT_CLOSE
argument_list|(
name|nmp
operator|->
name|nm_client
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Any signal that can interrupt an NFS operation in an intr mount  * should be added to this set.  SIGSTOP and SIGKILL cannot be masked.  */
end_comment

begin_decl_stmt
name|int
name|nfs_sig_set
index|[]
init|=
block|{
name|SIGINT
block|,
name|SIGTERM
block|,
name|SIGHUP
block|,
name|SIGKILL
block|,
name|SIGQUIT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check to see if one of the signals in our subset is pending on  * the process (in an intr mount).  */
end_comment

begin_function
specifier|static
name|int
name|nfs_sig_pending
parameter_list|(
name|sigset_t
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nfs_sig_set
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|set
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The set/restore sigmask functions are used to (temporarily) overwrite  * the thread td_sigmask during an RPC call (for example).  These are also  * used in other places in the NFS client that might tsleep().  */
end_comment

begin_function
name|void
name|nfs_set_sigmask
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|sigset_t
modifier|*
name|oldset
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|SIGFILLSET
argument_list|(
name|newset
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* Remove the NFS set of signals from newset. */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|nfs_sig_set
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * But make sure we leave the ones already masked 		 * by the process, i.e. remove the signal from the 		 * temporary signalmask only if it wasn't already 		 * in p_sigmask. 		 */
if|if
condition|(
operator|!
name|SIGISMEMBER
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|SIGISMEMBER
argument_list|(
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
name|SIGDELSET
argument_list|(
name|newset
argument_list|,
name|nfs_sig_set
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|newset
argument_list|,
name|oldset
argument_list|,
name|SIGPROCMASK_PROC_LOCKED
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nfs_restore_sigmask
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NFS wrapper to msleep(), that shoves a new p_sigmask and restores the  * old one after msleep() returns.  */
end_comment

begin_function
name|int
name|nfs_msleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|ident
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|,
name|int
name|priority
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|sigset_t
name|oldset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|priority
operator|&
name|PCATCH
operator|)
operator|==
literal|0
condition|)
return|return
name|msleep
argument_list|(
name|ident
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
return|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|nfs_set_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|ident
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|nfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for a termination condition pending on the process.  * This is used for NFSMNT_INT mounts.  */
end_comment

begin_function
name|int
name|nfs_sigintr
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|sigset_t
name|tmpset
decl_stmt|;
comment|/* Terminate all requests while attempting a forced unmount. */
if|if
condition|(
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tmpset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETOR
argument_list|(
name|tmpset
argument_list|,
name|td
operator|->
name|td_siglist
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|||
name|SIGNOTEMPTY
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|)
operator|)
operator|&&
name|nfs_sig_pending
argument_list|(
name|tmpset
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|server
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
condition|?
name|td
operator|->
name|td_proc
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s, error %d\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_down
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_TIMEO
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_TIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_TIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nfs_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_up
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|tprintfmsg
parameter_list|)
block|{
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|tprintfmsg
condition|)
name|nfs_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_TIMEO
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_TIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_TIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

