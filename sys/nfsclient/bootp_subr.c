begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995 Gordon Ross, Adam Glass  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * based on:  *      nfs/krpc_subr.c  *	$NetBSD: krpc_subr.c,v 1.10 1995/08/08 20:43:43 gwr Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bootp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vimage.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsdiskless.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/krpc.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_define
define|#
directive|define
name|BOOTP_MIN_LEN
value|300
end_define

begin_comment
comment|/* Minimum size of bootp udp packet */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BOOTP_SETTLE_DELAY
end_ifndef

begin_define
define|#
directive|define
name|BOOTP_SETTLE_DELAY
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * What is the longest we will wait before re-sending a request?  * Note this is also the frequency of "RPC timeout" messages.  * The re-send loop count sup linearly to this maximum, so the  * first complaint will happen after (1+2+3+4+5)=15 seconds.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RESEND_DELAY
value|5
end_define

begin_comment
comment|/* seconds */
end_comment

begin_comment
comment|/* Definitions from RFC951 */
end_comment

begin_struct
struct|struct
name|bootp_packet
block|{
name|u_int8_t
name|op
decl_stmt|;
name|u_int8_t
name|htype
decl_stmt|;
name|u_int8_t
name|hlen
decl_stmt|;
name|u_int8_t
name|hops
decl_stmt|;
name|u_int32_t
name|xid
decl_stmt|;
name|u_int16_t
name|secs
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
name|struct
name|in_addr
name|ciaddr
decl_stmt|;
name|struct
name|in_addr
name|yiaddr
decl_stmt|;
name|struct
name|in_addr
name|siaddr
decl_stmt|;
name|struct
name|in_addr
name|giaddr
decl_stmt|;
name|unsigned
name|char
name|chaddr
index|[
literal|16
index|]
decl_stmt|;
name|char
name|sname
index|[
literal|64
index|]
decl_stmt|;
name|char
name|file
index|[
literal|128
index|]
decl_stmt|;
name|unsigned
name|char
name|vend
index|[
literal|1222
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bootpc_ifcontext
block|{
name|struct
name|bootpc_ifcontext
modifier|*
name|next
decl_stmt|;
name|struct
name|bootp_packet
name|call
decl_stmt|;
name|struct
name|bootp_packet
name|reply
decl_stmt|;
name|int
name|replylen
decl_stmt|;
name|int
name|overload
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|ifreq
name|ireq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|sockaddr_in
name|myaddr
decl_stmt|;
name|struct
name|sockaddr_in
name|netmask
decl_stmt|;
name|struct
name|sockaddr_in
name|gw
decl_stmt|;
name|struct
name|sockaddr_in
name|broadcast
decl_stmt|;
comment|/* Different for each interface */
name|int
name|gotgw
decl_stmt|;
name|int
name|gotnetmask
decl_stmt|;
name|int
name|gotrootpath
decl_stmt|;
name|int
name|outstanding
decl_stmt|;
name|int
name|sentmsg
decl_stmt|;
name|u_int32_t
name|xid
decl_stmt|;
enum|enum
block|{
name|IF_BOOTP_UNRESOLVED
block|,
name|IF_BOOTP_RESOLVED
block|,
name|IF_BOOTP_FAILED
block|,
name|IF_DHCP_UNRESOLVED
block|,
name|IF_DHCP_OFFERED
block|,
name|IF_DHCP_RESOLVED
block|,
name|IF_DHCP_FAILED
block|, 	}
name|state
enum|;
name|int
name|dhcpquerytype
decl_stmt|;
comment|/* dhcp type sent */
name|struct
name|in_addr
name|dhcpserver
decl_stmt|;
name|int
name|gotdhcpserver
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TAG_MAXLEN
value|1024
end_define

begin_struct
struct|struct
name|bootpc_tagcontext
block|{
name|char
name|buf
index|[
name|TAG_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|overload
decl_stmt|;
name|int
name|badopt
decl_stmt|;
name|int
name|badtag
decl_stmt|;
name|int
name|foundopt
decl_stmt|;
name|int
name|taglen
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bootpc_globalcontext
block|{
name|struct
name|bootpc_ifcontext
modifier|*
name|interfaces
decl_stmt|;
name|struct
name|bootpc_ifcontext
modifier|*
name|lastinterface
decl_stmt|;
name|u_int32_t
name|xid
decl_stmt|;
name|int
name|gotrootpath
decl_stmt|;
name|int
name|gotgw
decl_stmt|;
name|int
name|ifnum
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|int
name|starttime
decl_stmt|;
name|struct
name|bootp_packet
name|reply
decl_stmt|;
name|int
name|replylen
decl_stmt|;
name|struct
name|bootpc_ifcontext
modifier|*
name|setrootfs
decl_stmt|;
name|struct
name|bootpc_ifcontext
modifier|*
name|sethostname
decl_stmt|;
name|struct
name|bootpc_tagcontext
name|tmptag
decl_stmt|;
name|struct
name|bootpc_tagcontext
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IPPORT_BOOTPC
value|68
end_define

begin_define
define|#
directive|define
name|IPPORT_BOOTPS
value|67
end_define

begin_define
define|#
directive|define
name|BOOTP_REQUEST
value|1
end_define

begin_define
define|#
directive|define
name|BOOTP_REPLY
value|2
end_define

begin_comment
comment|/* Common tags */
end_comment

begin_define
define|#
directive|define
name|TAG_PAD
value|0
end_define

begin_comment
comment|/* Pad option, implicit length 1 */
end_comment

begin_define
define|#
directive|define
name|TAG_SUBNETMASK
value|1
end_define

begin_comment
comment|/* RFC 950 subnet mask */
end_comment

begin_define
define|#
directive|define
name|TAG_ROUTERS
value|3
end_define

begin_comment
comment|/* Routers (in order of preference) */
end_comment

begin_define
define|#
directive|define
name|TAG_HOSTNAME
value|12
end_define

begin_comment
comment|/* Client host name */
end_comment

begin_define
define|#
directive|define
name|TAG_ROOT
value|17
end_define

begin_comment
comment|/* Root path */
end_comment

begin_comment
comment|/* DHCP specific tags */
end_comment

begin_define
define|#
directive|define
name|TAG_OVERLOAD
value|52
end_define

begin_comment
comment|/* Option Overload */
end_comment

begin_define
define|#
directive|define
name|TAG_MAXMSGSIZE
value|57
end_define

begin_comment
comment|/* Maximum DHCP Message Size */
end_comment

begin_define
define|#
directive|define
name|TAG_END
value|255
end_define

begin_comment
comment|/* End Option (i.e. no more options) */
end_comment

begin_comment
comment|/* Overload values */
end_comment

begin_define
define|#
directive|define
name|OVERLOAD_FILE
value|1
end_define

begin_define
define|#
directive|define
name|OVERLOAD_SNAME
value|2
end_define

begin_comment
comment|/* Site specific tags: */
end_comment

begin_define
define|#
directive|define
name|TAG_ROOTOPTS
value|130
end_define

begin_define
define|#
directive|define
name|TAG_COOKIE
value|134
end_define

begin_comment
comment|/* ascii info for userland, via sysctl */
end_comment

begin_define
define|#
directive|define
name|TAG_DHCP_MSGTYPE
value|53
end_define

begin_define
define|#
directive|define
name|TAG_DHCP_REQ_ADDR
value|50
end_define

begin_define
define|#
directive|define
name|TAG_DHCP_SERVERID
value|54
end_define

begin_define
define|#
directive|define
name|TAG_DHCP_LEASETIME
value|51
end_define

begin_define
define|#
directive|define
name|TAG_VENDOR_INDENTIFIER
value|60
end_define

begin_define
define|#
directive|define
name|DHCP_NOMSG
value|0
end_define

begin_define
define|#
directive|define
name|DHCP_DISCOVER
value|1
end_define

begin_define
define|#
directive|define
name|DHCP_OFFER
value|2
end_define

begin_define
define|#
directive|define
name|DHCP_REQUEST
value|3
end_define

begin_define
define|#
directive|define
name|DHCP_ACK
value|5
end_define

begin_comment
comment|/* NFS read/write block size */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BOOTP_BLOCKSIZE
end_ifndef

begin_define
define|#
directive|define
name|BOOTP_BLOCKSIZE
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|bootp_cookie
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|bootp_cookie
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|bootp_cookie
argument_list|,
literal|0
argument_list|,
literal|"Cookie (T134) supplied by bootp server"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mountd RPC */
end_comment

begin_function_decl
specifier|static
name|int
name|md_mount
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|mdsin
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|u_char
modifier|*
name|fhp
parameter_list|,
name|int
modifier|*
name|fhsizep
parameter_list|,
name|struct
name|nfs_args
modifier|*
name|args
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setfs
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
name|siaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getdec
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getip
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|in_addr
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mountopts
parameter_list|(
name|struct
name|nfs_args
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xdr_opaque_decode
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|ptr
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xdr_int_decode
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|iptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_in_addr
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_sin_addr
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_sinaddr
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocifctx
parameter_list|(
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bootpc_compose_query
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|bootpc_tag
parameter_list|(
name|struct
name|bootpc_tagcontext
modifier|*
name|tctx
parameter_list|,
name|struct
name|bootp_packet
modifier|*
name|bp
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bootpc_tag_helper
parameter_list|(
name|struct
name|bootpc_tagcontext
modifier|*
name|tctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
end_ifdef

begin_function_decl
name|void
name|bootpboot_p_sa
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|ma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bootpboot_p_rtentry
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bootpboot_p_tree
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bootpboot_p_rtlist
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bootpboot_p_if
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bootpboot_p_iflist
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|bootpc_call
parameter_list|(
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bootpc_fakeup_interface
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bootpc_adjust_interface
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bootpc_decode_reply
parameter_list|(
name|struct
name|nfsv3_diskless
modifier|*
name|nd
parameter_list|,
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bootpc_received
parameter_list|(
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|bootpc_ifctx_isresolved
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|bootpc_ifctx_isunresolved
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|bootpc_ifctx_isfailed
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * In order to have multiple active interfaces with address 0.0.0.0  * and be able to send data to a selected interface, we perform  * some tricks:  *  *  - The 'broadcast' address is different for each interface.  *  *  - We temporarily add routing pointing 255.255.255.255 to the  *    selected interface broadcast address, thus the packet sent  *    goes to that interface.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
end_ifdef

begin_function
name|void
name|bootpboot_p_sa
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|ma
parameter_list|)
block|{
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"(sockaddr *)<null>"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
name|printf
argument_list|(
literal|"inet "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ma
operator|!=
name|NULL
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ma
expr_stmt|;
name|printf
argument_list|(
literal|" mask "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AF_LINK
case|:
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sli
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sli
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|sa
expr_stmt|;
name|printf
argument_list|(
literal|"link %.*s "
argument_list|,
name|sli
operator|->
name|sdl_nlen
argument_list|,
name|sli
operator|->
name|sdl_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sli
operator|->
name|sdl_alen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|LLADDR
argument_list|(
name|sli
argument_list|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"af%d"
argument_list|,
name|sa
operator|->
name|sa_family
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bootpboot_p_rtentry
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|bootpboot_p_sa
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|bootpboot_p_sa
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flags %x"
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|rt
operator|->
name|rt_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|(
name|int
operator|)
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_expire
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|rt
operator|->
name|rt_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bootpboot_p_tree
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|)
block|{
while|while
condition|(
name|rn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rn
operator|->
name|rn_bit
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rn
operator|->
name|rn_flags
operator|&
name|RNF_ROOT
operator|)
operator|!=
literal|0
condition|)
block|{ 			}
else|else
block|{
name|bootpboot_p_rtentry
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rn
argument_list|)
expr_stmt|;
block|}
name|rn
operator|=
name|rn
operator|->
name|rn_dupedkey
expr_stmt|;
block|}
else|else
block|{
name|bootpboot_p_tree
argument_list|(
name|rn
operator|->
name|rn_left
argument_list|)
expr_stmt|;
name|bootpboot_p_tree
argument_list|(
name|rn
operator|->
name|rn_right
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
name|void
name|bootpboot_p_rtlist
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|radix_node_head
modifier|*
name|rnh
decl_stmt|;
name|printf
argument_list|(
literal|"Routing table:\n"
argument_list|)
expr_stmt|;
name|rnh
operator|=
name|rt_tables_get_rnh
argument_list|(
literal|0
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnh
operator|==
name|NULL
condition|)
return|return;
name|RADIX_NODE_HEAD_RLOCK
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
comment|/* could sleep XXX */
name|bootpboot_p_tree
argument_list|(
name|rnh
operator|->
name|rnh_treetop
argument_list|)
expr_stmt|;
name|RADIX_NODE_HEAD_RUNLOCK
argument_list|(
name|rnh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bootpboot_p_if
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s flags %x, addr "
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", broadcast "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_dstaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", netmask "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_netmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bootpboot_p_iflist
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|printf
argument_list|(
literal|"Interface list:\n"
argument_list|)
expr_stmt|;
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
comment|/* could sleep, but okay for debugging XXX */
for|for
control|(
name|ifp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ifnet
argument_list|)
init|;
name|ifp
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifp
argument_list|,
name|if_link
argument_list|)
control|)
block|{
for|for
control|(
name|ifa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
init|;
name|ifa
operator|!=
name|NULL
condition|;
name|ifa
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifa
argument_list|,
name|ifa_link
argument_list|)
control|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|bootpboot_p_if
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(BOOTP_DEBUG) */
end_comment

begin_function
specifier|static
name|void
name|clear_sinaddr
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|)
block|{
name|bzero
argument_list|(
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/* XXX: htonl(INAADDR_ANY) ? */
name|sin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|allocifctx
parameter_list|(
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|)
block|{
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
decl_stmt|;
name|ifctx
operator|=
operator|(
expr|struct
name|bootpc_ifcontext
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ifctx
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifctx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Failed to allocate bootp interface context structure"
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|xid
operator|=
name|gctx
operator|->
name|xid
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_NO_DHCP
name|ifctx
operator|->
name|state
operator|=
name|IF_BOOTP_UNRESOLVED
expr_stmt|;
else|#
directive|else
name|ifctx
operator|->
name|state
operator|=
name|IF_DHCP_UNRESOLVED
expr_stmt|;
endif|#
directive|endif
name|gctx
operator|->
name|xid
operator|+=
literal|0x100
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|interfaces
operator|!=
name|NULL
condition|)
name|gctx
operator|->
name|lastinterface
operator|->
name|next
operator|=
name|ifctx
expr_stmt|;
else|else
name|gctx
operator|->
name|interfaces
operator|=
name|ifctx
expr_stmt|;
name|gctx
operator|->
name|lastinterface
operator|=
name|ifctx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|bootpc_ifctx_isresolved
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
block|{
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_BOOTP_RESOLVED
operator|||
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_RESOLVED
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|bootpc_ifctx_isunresolved
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
block|{
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_BOOTP_UNRESOLVED
operator|||
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_UNRESOLVED
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|bootpc_ifctx_isfailed
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
block|{
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_BOOTP_FAILED
operator|||
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_FAILED
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bootpc_received
parameter_list|(
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|)
block|{
name|unsigned
name|char
name|dhcpreplytype
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Need timeout for fallback to less 	 * desirable alternative. 	 */
comment|/* This call used for the side effect (badopt flag) */
operator|(
name|void
operator|)
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|gctx
operator|->
name|reply
argument_list|,
name|gctx
operator|->
name|replylen
argument_list|,
name|TAG_END
argument_list|)
expr_stmt|;
comment|/* If packet is invalid, ignore it */
if|if
condition|(
name|gctx
operator|->
name|tmptag
operator|.
name|badopt
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|gctx
operator|->
name|reply
argument_list|,
name|gctx
operator|->
name|replylen
argument_list|,
name|TAG_DHCP_MSGTYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|dhcpreplytype
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|dhcpreplytype
operator|=
name|DHCP_NOMSG
expr_stmt|;
switch|switch
condition|(
name|ifctx
operator|->
name|dhcpquerytype
condition|)
block|{
case|case
name|DHCP_DISCOVER
case|:
if|if
condition|(
name|dhcpreplytype
operator|!=
name|DHCP_OFFER
comment|/* Normal DHCP offer */
ifndef|#
directive|ifndef
name|BOOTP_FORCE_DHCP
operator|&&
name|dhcpreplytype
operator|!=
name|DHCP_NOMSG
comment|/* Fallback to BOOTP */
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|DHCP_REQUEST
case|:
if|if
condition|(
name|dhcpreplytype
operator|!=
name|DHCP_ACK
condition|)
return|return
literal|0
return|;
case|case
name|DHCP_NOMSG
case|:
break|break;
block|}
comment|/* Ignore packet unless it gives us a root tag we didn't have */
if|if
condition|(
operator|(
name|ifctx
operator|->
name|state
operator|==
name|IF_BOOTP_RESOLVED
operator|||
operator|(
name|ifctx
operator|->
name|dhcpquerytype
operator|==
name|DHCP_DISCOVER
operator|&&
operator|(
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_OFFERED
operator|||
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_RESOLVED
operator|)
operator|)
operator|)
operator|&&
operator|(
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROOT
argument_list|)
operator|!=
name|NULL
operator|||
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|gctx
operator|->
name|reply
argument_list|,
name|gctx
operator|->
name|replylen
argument_list|,
name|TAG_ROOT
argument_list|)
operator|==
name|NULL
operator|)
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
operator|&
name|gctx
operator|->
name|reply
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|gctx
operator|->
name|replylen
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|replylen
operator|=
name|gctx
operator|->
name|replylen
expr_stmt|;
comment|/* XXX: Only reset if 'perfect' response */
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_BOOTP_UNRESOLVED
condition|)
name|ifctx
operator|->
name|state
operator|=
name|IF_BOOTP_RESOLVED
expr_stmt|;
elseif|else
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_UNRESOLVED
operator|&&
name|ifctx
operator|->
name|dhcpquerytype
operator|==
name|DHCP_DISCOVER
condition|)
block|{
if|if
condition|(
name|dhcpreplytype
operator|==
name|DHCP_OFFER
condition|)
name|ifctx
operator|->
name|state
operator|=
name|IF_DHCP_OFFERED
expr_stmt|;
else|else
name|ifctx
operator|->
name|state
operator|=
name|IF_BOOTP_RESOLVED
expr_stmt|;
comment|/* Fallback */
block|}
elseif|else
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_OFFERED
operator|&&
name|ifctx
operator|->
name|dhcpquerytype
operator|==
name|DHCP_REQUEST
condition|)
name|ifctx
operator|->
name|state
operator|=
name|IF_DHCP_RESOLVED
expr_stmt|;
if|if
condition|(
name|ifctx
operator|->
name|dhcpquerytype
operator|==
name|DHCP_DISCOVER
operator|&&
name|ifctx
operator|->
name|state
operator|!=
name|IF_BOOTP_RESOLVED
condition|)
block|{
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_DHCP_SERVERID
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|gctx
operator|->
name|tmptag
operator|.
name|taglen
operator|==
literal|4
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|ifctx
operator|->
name|dhcpserver
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|gotdhcpserver
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ifctx
operator|->
name|gotdhcpserver
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ifctx
operator|->
name|gotrootpath
operator|=
operator|(
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROOT
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|ifctx
operator|->
name|gotgw
operator|=
operator|(
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROUTERS
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|ifctx
operator|->
name|gotnetmask
operator|=
operator|(
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_SUBNETMASK
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bootpc_call
parameter_list|(
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
name|dst
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|struct
name|iovec
name|aio
decl_stmt|;
name|int
name|error
decl_stmt|,
name|on
decl_stmt|,
name|rcvflg
decl_stmt|,
name|timo
decl_stmt|,
name|len
decl_stmt|;
name|time_t
name|atimo
decl_stmt|;
name|time_t
name|rtimo
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
decl_stmt|;
name|int
name|outstanding
decl_stmt|;
name|int
name|gotrootpath
decl_stmt|;
name|int
name|retry
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 	 * Create socket and set its recieve timeout. 	 */
name|error
operator|=
name|socreate
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|so
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out0
goto|;
name|tv
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sopt
argument_list|,
sizeof|sizeof
argument_list|(
name|sopt
argument_list|)
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_RCVTIMEO
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|tv
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|tv
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Enable broadcast. 	 */
name|on
operator|=
literal|1
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_BROADCAST
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|on
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Disable routing. 	 */
name|on
operator|=
literal|1
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|SO_DONTROUTE
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|&
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
name|on
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Bind the local endpoint to a bootp client port. 	 */
name|sin
operator|=
operator|&
name|dst
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|IPPORT_BOOTPC
argument_list|)
expr_stmt|;
name|error
operator|=
name|sobind
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bind failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Setup socket address for the server. 	 */
name|sin
operator|=
operator|&
name|dst
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|IPPORT_BOOTPS
argument_list|)
expr_stmt|;
comment|/* 	 * Send it, repeatedly, until a reply is received, 	 * but delay each re-send by an increasing amount. 	 * If the delay hits the maximum, start complaining. 	 */
name|timo
operator|=
literal|0
expr_stmt|;
name|rtimo
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outstanding
operator|=
literal|0
expr_stmt|;
name|gotrootpath
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
operator|&&
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROOT
argument_list|)
operator|!=
name|NULL
condition|)
name|gotrootpath
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
name|ifctx
operator|->
name|outstanding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
operator|&&
name|gotrootpath
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bootpc_ifctx_isfailed
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|outstanding
operator|++
expr_stmt|;
name|ifctx
operator|->
name|outstanding
operator|=
literal|1
expr_stmt|;
comment|/* Proceed to next step in DHCP negotiation */
if|if
condition|(
operator|(
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_OFFERED
operator|&&
name|ifctx
operator|->
name|dhcpquerytype
operator|!=
name|DHCP_REQUEST
operator|)
operator|||
operator|(
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_UNRESOLVED
operator|&&
name|ifctx
operator|->
name|dhcpquerytype
operator|!=
name|DHCP_DISCOVER
operator|)
operator|||
operator|(
name|ifctx
operator|->
name|state
operator|==
name|IF_BOOTP_UNRESOLVED
operator|&&
name|ifctx
operator|->
name|dhcpquerytype
operator|!=
name|DHCP_NOMSG
operator|)
condition|)
block|{
name|ifctx
operator|->
name|sentmsg
operator|=
literal|0
expr_stmt|;
name|bootpc_compose_query
argument_list|(
name|ifctx
argument_list|,
name|gctx
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* Send BOOTP request (or re-send). */
if|if
condition|(
name|ifctx
operator|->
name|sentmsg
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|ifctx
operator|->
name|dhcpquerytype
condition|)
block|{
case|case
name|DHCP_DISCOVER
case|:
name|s
operator|=
literal|"DHCP Discover"
expr_stmt|;
break|break;
case|case
name|DHCP_REQUEST
case|:
name|s
operator|=
literal|"DHCP Request"
expr_stmt|;
break|break;
case|case
name|DHCP_NOMSG
case|:
default|default:
name|s
operator|=
literal|"BOOTP Query"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Sending %s packet from "
literal|"interface %s (%*D)\n"
argument_list|,
name|s
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|,
name|ifctx
operator|->
name|sdl
operator|->
name|sdl_alen
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|LLADDR
argument_list|(
name|ifctx
operator|->
name|sdl
argument_list|)
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|sentmsg
operator|=
literal|1
expr_stmt|;
block|}
name|aio
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|ifctx
operator|->
name|call
expr_stmt|;
name|aio
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|call
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aio
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|call
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
comment|/* Set netmask to 0.0.0.0 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|ifctx
operator|->
name|so
argument_list|,
name|SIOCSIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifctx
operator|->
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_call:"
literal|"set if netmask, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|sosend
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
operator|&
name|auio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bootpc_call: sosend: %d state %08x\n"
argument_list|,
name|error
argument_list|,
operator|(
name|int
operator|)
name|so
operator|->
name|so_state
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: Is this needed ? */
name|pause
argument_list|(
literal|"bootpw"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* Set netmask to 255.0.0.0 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0xff000000u
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|ifctx
operator|->
name|so
argument_list|,
name|SIOCSIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifctx
operator|->
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_call:"
literal|"set if netmask, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outstanding
operator|==
literal|0
operator|&&
operator|(
name|rtimo
operator|==
literal|0
operator|||
name|time_second
operator|>=
name|rtimo
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|gotreply
goto|;
block|}
comment|/* Determine new timeout. */
if|if
condition|(
name|timo
operator|<
name|MAX_RESEND_DELAY
condition|)
name|timo
operator|++
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"DHCP/BOOTP timeout for server "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Wait for up to timo seconds for a reply. 		 * The socket receive timeout was set to 1 second. 		 */
name|atimo
operator|=
name|timo
operator|+
name|time_second
expr_stmt|;
while|while
condition|(
name|time_second
operator|<
name|atimo
condition|)
block|{
name|aio
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|gctx
operator|->
name|reply
expr_stmt|;
name|aio
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|gctx
operator|->
name|reply
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aio
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|gctx
operator|->
name|reply
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|auio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|secs
operator|=
name|time_second
operator|-
name|gctx
operator|->
name|starttime
expr_stmt|;
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
operator|||
name|bootpc_ifctx_isfailed
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|ifctx
operator|->
name|call
operator|.
name|secs
operator|=
name|htons
argument_list|(
name|gctx
operator|->
name|secs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
continue|continue;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|gctx
operator|->
name|reply
argument_list|)
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
comment|/* Do we have the required number of bytes ? */
if|if
condition|(
name|len
operator|<
name|BOOTP_MIN_LEN
condition|)
continue|continue;
name|gctx
operator|->
name|replylen
operator|=
name|len
expr_stmt|;
comment|/* Is it a reply? */
if|if
condition|(
name|gctx
operator|->
name|reply
operator|.
name|op
operator|!=
name|BOOTP_REPLY
condition|)
continue|continue;
comment|/* Is this an answer to our query */
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|gctx
operator|->
name|reply
operator|.
name|xid
operator|!=
name|ifctx
operator|->
name|call
operator|.
name|xid
condition|)
continue|continue;
comment|/* Same HW address size ? */
if|if
condition|(
name|gctx
operator|->
name|reply
operator|.
name|hlen
operator|!=
name|ifctx
operator|->
name|call
operator|.
name|hlen
condition|)
continue|continue;
comment|/* Correct HW address ? */
if|if
condition|(
name|bcmp
argument_list|(
name|gctx
operator|->
name|reply
operator|.
name|chaddr
argument_list|,
name|ifctx
operator|->
name|call
operator|.
name|chaddr
argument_list|,
name|ifctx
operator|->
name|call
operator|.
name|hlen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ifctx
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|gctx
operator|->
name|reply
argument_list|,
name|gctx
operator|->
name|replylen
argument_list|,
name|TAG_DHCP_MSGTYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
name|DHCP_OFFER
case|:
name|s
operator|=
literal|"DHCP Offer"
expr_stmt|;
break|break;
case|case
name|DHCP_ACK
case|:
name|s
operator|=
literal|"DHCP Ack"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"DHCP (unexpected)"
expr_stmt|;
break|break;
block|}
block|}
else|else
name|s
operator|=
literal|"BOOTP Reply"
expr_stmt|;
name|printf
argument_list|(
literal|"Received %s packet"
literal|" on %s from "
argument_list|,
name|s
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|print_in_addr
argument_list|(
name|gctx
operator|->
name|reply
operator|.
name|siaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|reply
operator|.
name|giaddr
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" via "
argument_list|)
expr_stmt|;
name|print_in_addr
argument_list|(
name|gctx
operator|->
name|reply
operator|.
name|giaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootpc_received
argument_list|(
name|gctx
argument_list|,
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (accepted)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifctx
operator|->
name|outstanding
condition|)
block|{
name|ifctx
operator|->
name|outstanding
operator|=
literal|0
expr_stmt|;
name|outstanding
operator|--
expr_stmt|;
block|}
comment|/* Network settle delay */
if|if
condition|(
name|outstanding
operator|==
literal|0
condition|)
name|atimo
operator|=
name|time_second
operator|+
name|BOOTP_SETTLE_DELAY
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" (ignored)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifctx
operator|->
name|gotrootpath
condition|)
block|{
name|gotrootpath
operator|=
literal|1
expr_stmt|;
name|rtimo
operator|=
name|time_second
operator|+
name|BOOTP_SETTLE_DELAY
expr_stmt|;
name|printf
argument_list|(
literal|" (got root path)"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" (no root path)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while secs */
ifdef|#
directive|ifdef
name|BOOTP_TIMEOUT
if|if
condition|(
name|gctx
operator|->
name|secs
operator|>
name|BOOTP_TIMEOUT
operator|&&
name|BOOTP_TIMEOUT
operator|>
literal|0
condition|)
break|break;
endif|#
directive|endif
comment|/* Force a retry if halfway in DHCP negotiation */
name|retry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ifctx
operator|->
name|state
operator|==
name|IF_DHCP_OFFERED
condition|)
block|{
if|if
condition|(
name|ifctx
operator|->
name|dhcpquerytype
operator|==
name|DHCP_DISCOVER
condition|)
name|retry
operator|=
literal|1
expr_stmt|;
else|else
name|ifctx
operator|->
name|state
operator|=
name|IF_DHCP_UNRESOLVED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retry
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|gotrootpath
operator|!=
literal|0
condition|)
block|{
name|gctx
operator|->
name|gotrootpath
operator|=
name|gotrootpath
expr_stmt|;
if|if
condition|(
name|rtimo
operator|!=
literal|0
operator|&&
name|time_second
operator|>=
name|rtimo
condition|)
break|break;
block|}
block|}
comment|/* forever send/receive */
comment|/* 	 * XXX: These are errors of varying seriousness being silently 	 * ignored 	 */
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s timeout for interface %s\n"
argument_list|,
name|ifctx
operator|->
name|dhcpquerytype
operator|!=
name|DHCP_NOMSG
condition|?
literal|"DHCP"
else|:
literal|"BOOTP"
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gctx
operator|->
name|gotrootpath
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("Got a root path, ignoring remaining timeout\n");
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifndef|#
directive|ifndef
name|BOOTP_NFSROOT
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|out
goto|;
name|gotreply
label|:
name|out
label|:
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|out0
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bootpc_fakeup_interface
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ireq
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|ifctx
operator|->
name|so
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_boot: socreate, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ireq
operator|=
operator|&
name|ifctx
operator|->
name|ireq
expr_stmt|;
name|so
operator|=
name|ifctx
operator|->
name|so
expr_stmt|;
comment|/* 	 * Bring up the interface. 	 * 	 * Get the old interface flags and or IFF_UP into them; if 	 * IFF_UP set blindly, interface selection can be clobbered. 	 */
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_fakeup_interface: GIFFLAGS, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|ifr_flags
operator||=
name|IFF_UP
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_fakeup_interface: SIFFLAGS, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Do enough of ifconfig(8) so that the chosen interface 	 * can talk to the servers.  (just set the address) 	 */
comment|/* addr is 0.0.0.0 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ireq
operator|->
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|!=
name|EEXIST
operator|||
name|ifctx
operator|==
name|gctx
operator|->
name|interfaces
operator|)
condition|)
name|panic
argument_list|(
literal|"bootpc_fakeup_interface: "
literal|"set if addr, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* netmask is 255.0.0.0 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ireq
operator|->
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0xff000000u
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_fakeup_interface: set if netmask, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Broadcast is 255.255.255.255 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ireq
operator|->
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|clear_sinaddr
argument_list|(
operator|&
name|ifctx
operator|->
name|broadcast
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_BROADCAST
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|broadcast
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFBRDADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_fakeup_interface: "
literal|"set if broadcast addr, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Get HW address */
name|sdl
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifctx->ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sdl
operator|->
name|sdl_type
operator|==
name|IFT_ETHER
condition|)
break|break;
block|}
if|if
condition|(
name|sdl
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"bootpc: Unable to find HW address for %s"
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|sdl
operator|=
name|sdl
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bootpc_adjust_interface
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|sockaddr_in
name|defdst
decl_stmt|;
name|struct
name|sockaddr_in
name|defmask
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ireq
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|myaddr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|netmask
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|gw
decl_stmt|;
name|ireq
operator|=
operator|&
name|ifctx
operator|->
name|ireq
expr_stmt|;
name|so
operator|=
name|ifctx
operator|->
name|so
expr_stmt|;
name|myaddr
operator|=
operator|&
name|ifctx
operator|->
name|myaddr
expr_stmt|;
name|netmask
operator|=
operator|&
name|ifctx
operator|->
name|netmask
expr_stmt|;
name|gw
operator|=
operator|&
name|ifctx
operator|->
name|gw
expr_stmt|;
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Shutdown interfaces where BOOTP failed */
name|printf
argument_list|(
literal|"Shutdown interface %s\n"
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"SIOCGIFFLAGS, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ireq
operator|->
name|ifr_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"SIOCSIFFLAGS, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ireq
operator|->
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCDIFADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|!=
name|EEXIST
operator|||
name|ifctx
operator|==
name|gctx
operator|->
name|interfaces
operator|)
condition|)
name|panic
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"SIOCDIFADDR, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"Adjusted interface %s\n"
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
comment|/* 	 * Do enough of ifconfig(8) so that the chosen interface 	 * can talk to the servers.  (just set the address) 	 */
name|bcopy
argument_list|(
name|netmask
argument_list|,
operator|&
name|ireq
operator|->
name|ifr_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"set if netmask, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Broadcast is with host part of IP address all 1's */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ireq
operator|->
name|ifr_addr
expr_stmt|;
name|clear_sinaddr
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|myaddr
operator|->
name|sin_addr
operator|.
name|s_addr
operator||
operator|~
name|netmask
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFBRDADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"set if broadcast addr, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|ireq
operator|->
name|ifr_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|SIOCSIFADDR
argument_list|,
operator|(
name|caddr_t
operator|)
name|ireq
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|!=
name|EEXIST
operator|||
name|ifctx
operator|==
name|gctx
operator|->
name|interfaces
operator|)
condition|)
name|panic
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"set if addr, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Add new default route */
if|if
condition|(
name|ifctx
operator|->
name|gotgw
operator|!=
literal|0
operator|||
name|gctx
operator|->
name|gotgw
operator|==
literal|0
condition|)
block|{
name|clear_sinaddr
argument_list|(
operator|&
name|defdst
argument_list|)
expr_stmt|;
name|clear_sinaddr
argument_list|(
operator|&
name|defmask
argument_list|)
expr_stmt|;
comment|/* XXX MRT just table 0 */
name|error
operator|=
name|rtrequest_fib
argument_list|(
name|RTM_ADD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|defdst
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|gw
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|defmask
argument_list|,
operator|(
name|RTF_UP
operator||
name|RTF_GATEWAY
operator||
name|RTF_STATIC
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bootpc_adjust_interface: "
literal|"add net route, error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setfs
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
name|siaddr
parameter_list|)
block|{
if|if
condition|(
name|getip
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|addr
operator|->
name|sin_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|siaddr
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|==
literal|'/'
condition|)
name|bcopy
argument_list|(
name|siaddr
argument_list|,
operator|&
name|addr
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
name|p
operator|++
expr_stmt|;
block|}
name|addr
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|strlcpy
argument_list|(
name|path
argument_list|,
name|p
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getip
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|ip
decl_stmt|;
name|int
name|val
decl_stmt|;
name|p
operator|=
operator|*
name|ptr
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|=
name|getdec
argument_list|(
operator|&
name|p
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|val
operator|>
literal|255
operator|)
condition|)
return|return
literal|0
return|;
name|ip
operator|=
name|val
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|=
name|getdec
argument_list|(
operator|&
name|p
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|val
operator|>
literal|255
operator|)
condition|)
return|return
literal|0
return|;
name|ip
operator||=
operator|(
name|val
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|=
name|getdec
argument_list|(
operator|&
name|p
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|val
operator|>
literal|255
operator|)
condition|)
return|return
literal|0
return|;
name|ip
operator||=
operator|(
name|val
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|=
name|getdec
argument_list|(
operator|&
name|p
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|val
operator|>
literal|255
operator|)
condition|)
return|return
literal|0
return|;
name|ip
operator||=
name|val
expr_stmt|;
name|addr
operator|->
name|s_addr
operator|=
name|htonl
argument_list|(
name|ip
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdec
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|p
operator|=
operator|*
name|ptr
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|<
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>
literal|'9'
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ret
operator|=
name|ret
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mountopts
parameter_list|(
name|struct
name|nfs_args
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|args
operator|->
name|version
operator|=
name|NFS_ARGSVERSION
expr_stmt|;
name|args
operator|->
name|rsize
operator|=
name|BOOTP_BLOCKSIZE
expr_stmt|;
name|args
operator|->
name|wsize
operator|=
name|BOOTP_BLOCKSIZE
expr_stmt|;
name|args
operator|->
name|flags
operator|=
name|NFSMNT_RSIZE
operator||
name|NFSMNT_WSIZE
operator||
name|NFSMNT_RESVPORT
expr_stmt|;
name|args
operator|->
name|sotype
operator|=
name|SOCK_DGRAM
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|nfs_parse_options
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xdr_opaque_decode
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mptr
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|alignedlen
decl_stmt|;
name|m
operator|=
operator|*
name|mptr
expr_stmt|;
name|alignedlen
operator|=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|alignedlen
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|alignedlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|mptr
operator|=
name|NULL
expr_stmt|;
return|return
name|EBADRPC
return|;
block|}
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|alignedlen
argument_list|)
expr_stmt|;
operator|*
name|mptr
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xdr_int_decode
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mptr
parameter_list|,
name|int
modifier|*
name|iptr
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|;
if|if
condition|(
name|xdr_opaque_decode
argument_list|(
name|mptr
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EBADRPC
return|;
operator|*
name|iptr
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_sin_addr
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|)
block|{
name|print_in_addr
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_in_addr
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|ip
decl_stmt|;
name|ip
operator|=
name|ntohl
argument_list|(
name|addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d.%d.%d.%d"
argument_list|,
name|ip
operator|>>
literal|24
argument_list|,
operator|(
name|ip
operator|>>
literal|16
operator|)
operator|&
literal|255
argument_list|,
operator|(
name|ip
operator|>>
literal|8
operator|)
operator|&
literal|255
argument_list|,
name|ip
operator|&
literal|255
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bootpc_compose_query
parameter_list|(
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|vendp
decl_stmt|;
name|unsigned
name|char
name|vendor_client
index|[
literal|64
index|]
decl_stmt|;
name|uint32_t
name|leasetime
decl_stmt|;
name|uint8_t
name|vendor_client_len
decl_stmt|;
name|ifctx
operator|->
name|gotrootpath
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ifctx
operator|->
name|call
argument_list|,
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|call
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bootpc part */
name|ifctx
operator|->
name|call
operator|.
name|op
operator|=
name|BOOTP_REQUEST
expr_stmt|;
comment|/* BOOTREQUEST */
name|ifctx
operator|->
name|call
operator|.
name|htype
operator|=
literal|1
expr_stmt|;
comment|/* 10mb ethernet */
name|ifctx
operator|->
name|call
operator|.
name|hlen
operator|=
name|ifctx
operator|->
name|sdl
operator|->
name|sdl_alen
expr_stmt|;
comment|/* Hardware address length */
name|ifctx
operator|->
name|call
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootpc_ifctx_isunresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
name|ifctx
operator|->
name|xid
operator|++
expr_stmt|;
name|ifctx
operator|->
name|call
operator|.
name|xid
operator|=
name|txdr_unsigned
argument_list|(
name|ifctx
operator|->
name|xid
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|ifctx
operator|->
name|sdl
argument_list|)
argument_list|,
operator|&
name|ifctx
operator|->
name|call
operator|.
name|chaddr
argument_list|,
name|ifctx
operator|->
name|sdl
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
name|vendp
operator|=
name|ifctx
operator|->
name|call
operator|.
name|vend
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|99
expr_stmt|;
comment|/* RFC1048 cookie */
operator|*
name|vendp
operator|++
operator|=
literal|130
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|83
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|99
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
name|TAG_MAXMSGSIZE
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|bootp_packet
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bootp_packet
argument_list|)
operator|&
literal|255
expr_stmt|;
name|snprintf
argument_list|(
name|vendor_client
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor_client
argument_list|)
argument_list|,
literal|"%s:%s:%s"
argument_list|,
name|ostype
argument_list|,
name|MACHINE
argument_list|,
name|osrelease
argument_list|)
expr_stmt|;
name|vendor_client_len
operator|=
name|strlen
argument_list|(
name|vendor_client
argument_list|)
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
name|TAG_VENDOR_INDENTIFIER
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
name|vendor_client_len
expr_stmt|;
name|memcpy
argument_list|(
name|vendp
argument_list|,
name|vendor_client
argument_list|,
name|vendor_client_len
argument_list|)
expr_stmt|;
name|vendp
operator|+=
name|vendor_client_len
expr_stmt|;
empty_stmt|;
name|ifctx
operator|->
name|dhcpquerytype
operator|=
name|DHCP_NOMSG
expr_stmt|;
switch|switch
condition|(
name|ifctx
operator|->
name|state
condition|)
block|{
case|case
name|IF_DHCP_UNRESOLVED
case|:
operator|*
name|vendp
operator|++
operator|=
name|TAG_DHCP_MSGTYPE
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
name|DHCP_DISCOVER
expr_stmt|;
name|ifctx
operator|->
name|dhcpquerytype
operator|=
name|DHCP_DISCOVER
expr_stmt|;
name|ifctx
operator|->
name|gotdhcpserver
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IF_DHCP_OFFERED
case|:
operator|*
name|vendp
operator|++
operator|=
name|TAG_DHCP_MSGTYPE
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
name|DHCP_REQUEST
expr_stmt|;
name|ifctx
operator|->
name|dhcpquerytype
operator|=
name|DHCP_REQUEST
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
name|TAG_DHCP_REQ_ADDR
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|vendp
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
operator|.
name|yiaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|vendp
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|ifctx
operator|->
name|gotdhcpserver
operator|!=
literal|0
condition|)
block|{
operator|*
name|vendp
operator|++
operator|=
name|TAG_DHCP_SERVERID
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|vendp
argument_list|,
operator|&
name|ifctx
operator|->
name|dhcpserver
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|vendp
operator|+=
literal|4
expr_stmt|;
block|}
operator|*
name|vendp
operator|++
operator|=
name|TAG_DHCP_LEASETIME
expr_stmt|;
operator|*
name|vendp
operator|++
operator|=
literal|4
expr_stmt|;
name|leasetime
operator|=
name|htonl
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vendp
argument_list|,
operator|&
name|leasetime
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|vendp
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|vendp
operator|=
name|TAG_END
expr_stmt|;
name|ifctx
operator|->
name|call
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|ifctx
operator|->
name|call
operator|.
name|flags
operator|=
name|htons
argument_list|(
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* We need a broadcast answer */
block|}
end_function

begin_function
specifier|static
name|int
name|bootpc_hascookie
parameter_list|(
name|struct
name|bootp_packet
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
name|bp
operator|->
name|vend
index|[
literal|0
index|]
operator|==
literal|99
operator|&&
name|bp
operator|->
name|vend
index|[
literal|1
index|]
operator|==
literal|130
operator|&&
name|bp
operator|->
name|vend
index|[
literal|2
index|]
operator|==
literal|83
operator|&&
name|bp
operator|->
name|vend
index|[
literal|3
index|]
operator|==
literal|99
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bootpc_tag_helper
parameter_list|(
name|struct
name|bootpc_tagcontext
modifier|*
name|tctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ej
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
if|if
condition|(
name|tctx
operator|->
name|badtag
operator|!=
literal|0
operator|||
name|tctx
operator|->
name|badopt
operator|!=
literal|0
condition|)
return|return;
name|j
operator|=
name|start
expr_stmt|;
name|ej
operator|=
name|j
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|ej
condition|)
block|{
name|code
operator|=
operator|*
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TAG_PAD
condition|)
continue|continue;
if|if
condition|(
name|code
operator|==
name|TAG_END
condition|)
return|return;
if|if
condition|(
name|j
operator|>=
name|ej
operator|||
name|j
operator|+
operator|*
name|j
operator|+
literal|1
operator|>
name|ej
condition|)
block|{
name|tctx
operator|->
name|badopt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|len
operator|=
operator|*
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|tag
condition|)
block|{
if|if
condition|(
name|tctx
operator|->
name|taglen
operator|+
name|len
operator|>
name|TAG_MAXLEN
condition|)
block|{
name|tctx
operator|->
name|badtag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|tctx
operator|->
name|foundopt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|tctx
operator|->
name|buf
operator|+
name|tctx
operator|->
name|taglen
argument_list|,
name|j
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|taglen
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|TAG_OVERLOAD
condition|)
name|tctx
operator|->
name|overload
operator|=
operator|*
name|j
expr_stmt|;
name|j
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|bootpc_tag
parameter_list|(
name|struct
name|bootpc_tagcontext
modifier|*
name|tctx
parameter_list|,
name|struct
name|bootp_packet
modifier|*
name|bp
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|tctx
operator|->
name|overload
operator|=
literal|0
expr_stmt|;
name|tctx
operator|->
name|badopt
operator|=
literal|0
expr_stmt|;
name|tctx
operator|->
name|badtag
operator|=
literal|0
expr_stmt|;
name|tctx
operator|->
name|foundopt
operator|=
literal|0
expr_stmt|;
name|tctx
operator|->
name|taglen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootpc_hascookie
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|bootpc_tag_helper
argument_list|(
name|tctx
argument_list|,
operator|&
name|bp
operator|->
name|vend
index|[
literal|4
index|]
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bp
operator|+
name|len
operator|-
operator|&
name|bp
operator|->
name|vend
index|[
literal|4
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tctx
operator|->
name|overload
operator|&
name|OVERLOAD_FILE
operator|)
operator|!=
literal|0
condition|)
name|bootpc_tag_helper
argument_list|(
name|tctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bp
operator|->
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|file
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tctx
operator|->
name|overload
operator|&
name|OVERLOAD_SNAME
operator|)
operator|!=
literal|0
condition|)
name|bootpc_tag_helper
argument_list|(
name|tctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bp
operator|->
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|sname
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|tctx
operator|->
name|badopt
operator|!=
literal|0
operator|||
name|tctx
operator|->
name|badtag
operator|!=
literal|0
operator|||
name|tctx
operator|->
name|foundopt
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|tctx
operator|->
name|buf
index|[
name|tctx
operator|->
name|taglen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tctx
operator|->
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bootpc_decode_reply
parameter_list|(
name|struct
name|nfsv3_diskless
modifier|*
name|nd
parameter_list|,
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
parameter_list|,
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|ip
decl_stmt|;
name|ifctx
operator|->
name|gotgw
operator|=
literal|0
expr_stmt|;
name|ifctx
operator|->
name|gotnetmask
operator|=
literal|0
expr_stmt|;
name|clear_sinaddr
argument_list|(
operator|&
name|ifctx
operator|->
name|myaddr
argument_list|)
expr_stmt|;
name|clear_sinaddr
argument_list|(
operator|&
name|ifctx
operator|->
name|netmask
argument_list|)
expr_stmt|;
name|clear_sinaddr
argument_list|(
operator|&
name|ifctx
operator|->
name|gw
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|myaddr
operator|.
name|sin_addr
operator|=
name|ifctx
operator|->
name|reply
operator|.
name|yiaddr
expr_stmt|;
name|ip
operator|=
name|ntohl
argument_list|(
name|ifctx
operator|->
name|myaddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s at "
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|&
name|ifctx
operator|->
name|myaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" server "
argument_list|)
expr_stmt|;
name|print_in_addr
argument_list|(
name|ifctx
operator|->
name|reply
operator|.
name|siaddr
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|gw
operator|.
name|sin_addr
operator|=
name|ifctx
operator|->
name|reply
operator|.
name|giaddr
expr_stmt|;
if|if
condition|(
name|ifctx
operator|->
name|reply
operator|.
name|giaddr
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" via gateway "
argument_list|)
expr_stmt|;
name|print_in_addr
argument_list|(
name|ifctx
operator|->
name|reply
operator|.
name|giaddr
argument_list|)
expr_stmt|;
block|}
comment|/* This call used for the side effect (overload flag) */
operator|(
name|void
operator|)
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tmptag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_END
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gctx
operator|->
name|tmptag
operator|.
name|overload
operator|&
name|OVERLOAD_SNAME
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ifctx
operator|->
name|reply
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" server name %s"
argument_list|,
name|ifctx
operator|->
name|reply
operator|.
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gctx
operator|->
name|tmptag
operator|.
name|overload
operator|&
name|OVERLOAD_FILE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ifctx
operator|->
name|reply
operator|.
name|file
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" boot file %s"
argument_list|,
name|ifctx
operator|->
name|reply
operator|.
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_SUBNETMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|tag
operator|.
name|taglen
operator|!=
literal|4
condition|)
name|panic
argument_list|(
literal|"bootpc: subnet mask len is %d"
argument_list|,
name|gctx
operator|->
name|tag
operator|.
name|taglen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
operator|&
name|ifctx
operator|->
name|netmask
operator|.
name|sin_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|gotnetmask
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"subnet mask "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|&
name|ifctx
operator|->
name|netmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROUTERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* Routers */
if|if
condition|(
name|gctx
operator|->
name|tag
operator|.
name|taglen
operator|%
literal|4
condition|)
name|panic
argument_list|(
literal|"bootpc: Router Len is %d"
argument_list|,
name|gctx
operator|->
name|tag
operator|.
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|tag
operator|.
name|taglen
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
operator|&
name|ifctx
operator|->
name|gw
operator|.
name|sin_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"router "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|&
name|ifctx
operator|->
name|gw
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|ifctx
operator|->
name|gotgw
operator|=
literal|1
expr_stmt|;
name|gctx
operator|->
name|gotgw
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|setrootfs
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rootfs %s (ignored) "
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setfs
argument_list|(
operator|&
name|nd
operator|->
name|root_saddr
argument_list|,
name|nd
operator|->
name|root_hostnam
argument_list|,
name|p
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
operator|.
name|siaddr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|printf
argument_list|(
literal|"root_server "
argument_list|)
expr_stmt|;
name|print_sin_addr
argument_list|(
operator|&
name|nd
operator|->
name|root_saddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"rootfs %s "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|gotrootpath
operator|=
literal|1
expr_stmt|;
name|ifctx
operator|->
name|gotrootpath
operator|=
literal|1
expr_stmt|;
name|gctx
operator|->
name|setrootfs
operator|=
name|ifctx
expr_stmt|;
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_ROOTOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|mountopts
argument_list|(
operator|&
name|nd
operator|->
name|root_args
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rootopts %s "
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|panic
argument_list|(
literal|"Failed to set rootfs to %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_HOSTNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gctx
operator|->
name|tag
operator|.
name|taglen
operator|>=
name|MAXHOSTNAMELEN
condition|)
name|panic
argument_list|(
literal|"bootpc: hostname>= %d bytes"
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|sethostname
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"hostname %s (ignored) "
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|nd
operator|->
name|my_hostnam
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prison0
operator|.
name|pr_host
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hostname %s "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|sethostname
operator|=
name|ifctx
expr_stmt|;
block|}
block|}
name|p
operator|=
name|bootpc_tag
argument_list|(
operator|&
name|gctx
operator|->
name|tag
argument_list|,
operator|&
name|ifctx
operator|->
name|reply
argument_list|,
name|ifctx
operator|->
name|replylen
argument_list|,
name|TAG_COOKIE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* store in a sysctl variable */
name|int
name|i
decl_stmt|,
name|l
init|=
sizeof|sizeof
argument_list|(
name|bootp_cookie
argument_list|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|&&
name|p
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|bootp_cookie
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifctx
operator|->
name|gotnetmask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|ntohl
argument_list|(
name|ifctx
operator|->
name|myaddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|ifctx
operator|->
name|netmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|IN_CLASSA_NET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|ntohl
argument_list|(
name|ifctx
operator|->
name|myaddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|ifctx
operator|->
name|netmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|IN_CLASSB_NET
argument_list|)
expr_stmt|;
else|else
name|ifctx
operator|->
name|netmask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|IN_CLASSC_NET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifctx
operator|->
name|gotgw
operator|==
literal|0
condition|)
block|{
comment|/* Use proxyarp */
name|ifctx
operator|->
name|gw
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifctx
operator|->
name|myaddr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bootpc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|bootpc_ifcontext
modifier|*
name|ifctx
decl_stmt|,
modifier|*
name|nctx
decl_stmt|;
comment|/* Interface BOOTP contexts */
name|struct
name|bootpc_globalcontext
modifier|*
name|gctx
decl_stmt|;
comment|/* Global BOOTP context */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifndef|#
directive|ifndef
name|BOOTP_WIRED_TO
name|int
name|ifcnt
decl_stmt|;
endif|#
directive|endif
name|struct
name|nfsv3_diskless
modifier|*
name|nd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|nd
operator|=
operator|&
name|nfsv3_diskless
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* 	 * If already filled in, don't touch it here 	 */
if|if
condition|(
name|nfs_diskless_valid
operator|!=
literal|0
condition|)
return|return;
name|gctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gctx
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Failed to allocate bootp global context structure"
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|xid
operator|=
operator|~
literal|0xFFFF
expr_stmt|;
name|gctx
operator|->
name|starttime
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Find a network interface. 	 */
ifdef|#
directive|ifdef
name|BOOTP_WIRED_TO
name|printf
argument_list|(
literal|"bootpc_init: wired to interface '%s'\n"
argument_list|,
name|__XSTRING
argument_list|(
name|BOOTP_WIRED_TO
argument_list|)
argument_list|)
expr_stmt|;
name|allocifctx
argument_list|(
name|gctx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Preallocate interface context storage, if another interface 	 * attaches and wins the race, it won't be eligible for bootp. 	 */
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ifnet
argument_list|)
operator|,
name|ifcnt
operator|=
literal|0
init|;
name|ifp
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifp
argument_list|,
name|if_link
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator||
name|IFF_BROADCAST
operator|)
operator|)
operator|!=
name|IFF_BROADCAST
condition|)
continue|continue;
name|ifcnt
operator|++
expr_stmt|;
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifcnt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc_init: no eligible interfaces"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ifcnt
operator|>
literal|0
condition|;
name|ifcnt
operator|--
control|)
name|allocifctx
argument_list|(
name|gctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ifnet
argument_list|)
operator|,
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifp
operator|!=
name|NULL
operator|&&
name|ifctx
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifp
argument_list|,
name|if_link
argument_list|)
control|)
block|{
name|strlcpy
argument_list|(
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_WIRED_TO
if|if
condition|(
name|strcmp
argument_list|(
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|,
name|__XSTRING
argument_list|(
name|BOOTP_WIRED_TO
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator||
name|IFF_BROADCAST
operator|)
operator|)
operator|!=
name|IFF_BROADCAST
condition|)
continue|continue;
endif|#
directive|endif
name|ifctx
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
expr_stmt|;
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|interfaces
operator|==
name|NULL
operator|||
name|gctx
operator|->
name|interfaces
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BOOTP_WIRED_TO
name|panic
argument_list|(
literal|"bootpc_init: Could not find interface specified "
literal|"by BOOTP_WIRED_TO: "
name|__XSTRING
argument_list|(
name|BOOTP_WIRED_TO
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|panic
argument_list|(
literal|"bootpc_init: no suitable interface"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
name|bootpc_fakeup_interface
argument_list|(
name|ifctx
argument_list|,
name|gctx
argument_list|,
name|td
argument_list|)
expr_stmt|;
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
name|bootpc_compose_query
argument_list|(
name|ifctx
argument_list|,
name|gctx
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|bootpc_call
argument_list|(
name|gctx
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BOOTP_NFSROOT
name|panic
argument_list|(
literal|"BOOTP call failed"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"BOOTP call failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rootdevnames
index|[
literal|0
index|]
operator|=
literal|"nfs:"
expr_stmt|;
name|mountopts
argument_list|(
operator|&
name|nd
operator|->
name|root_args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
name|bootpc_decode_reply
argument_list|(
name|nd
argument_list|,
name|ifctx
argument_list|,
name|gctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_NFSROOT
if|if
condition|(
name|gctx
operator|->
name|gotrootpath
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bootpc: No root path offered"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
block|{
name|bootpc_adjust_interface
argument_list|(
name|ifctx
argument_list|,
name|gctx
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|ifctx
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
if|if
condition|(
name|ifctx
operator|->
name|gotrootpath
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|ifctx
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|ifctx
operator|->
name|next
control|)
if|if
condition|(
name|bootpc_ifctx_isresolved
argument_list|(
name|ifctx
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ifctx
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|gctx
operator|->
name|gotrootpath
operator|!=
literal|0
condition|)
block|{
name|setenv
argument_list|(
literal|"boot.netif.name"
argument_list|,
name|ifctx
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_mount
argument_list|(
operator|&
name|nd
operator|->
name|root_saddr
argument_list|,
name|nd
operator|->
name|root_hostnam
argument_list|,
name|nd
operator|->
name|root_fh
argument_list|,
operator|&
name|nd
operator|->
name|root_fhsize
argument_list|,
operator|&
name|nd
operator|->
name|root_args
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_boot: mountd root, error=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nfs_diskless_valid
operator|=
literal|3
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|nd
operator|->
name|myif
operator|.
name|ifra_name
argument_list|,
name|ifctx
operator|->
name|ireq
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ifctx
operator|->
name|myaddr
argument_list|,
operator|&
name|nd
operator|->
name|myif
operator|.
name|ifra_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ifctx
operator|->
name|myaddr
argument_list|,
operator|&
name|nd
operator|->
name|myif
operator|.
name|ifra_broadaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|nd
operator|->
name|myif
operator|.
name|ifra_broadaddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifctx
operator|->
name|myaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator||
operator|~
name|ifctx
operator|->
name|netmask
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ifctx
operator|->
name|netmask
argument_list|,
operator|&
name|nd
operator|->
name|myif
operator|.
name|ifra_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|ifctx
operator|->
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
for|for
control|(
name|ifctx
operator|=
name|gctx
operator|->
name|interfaces
init|;
name|ifctx
operator|!=
name|NULL
condition|;
name|ifctx
operator|=
name|nctx
control|)
block|{
name|nctx
operator|=
name|ifctx
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ifctx
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|gctx
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * RPC: mountd/mount  * Given a server pathname, get an NFS file handle.  * Also, sets sin->sin_port to the NFS service port.  */
end_comment

begin_function
specifier|static
name|int
name|md_mount
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|mdsin
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|u_char
modifier|*
name|fhp
parameter_list|,
name|int
modifier|*
name|fhsizep
parameter_list|,
name|struct
name|nfs_args
modifier|*
name|args
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|authunixok
decl_stmt|;
name|int
name|authcount
decl_stmt|;
name|int
name|authver
decl_stmt|;
comment|/* XXX honor v2/v3 flags in args->flags? */
ifdef|#
directive|ifdef
name|BOOTP_NFSV3
comment|/* First try NFS v3 */
comment|/* Get port number for MOUNTD. */
name|error
operator|=
name|krpc_portmap
argument_list|(
name|mdsin
argument_list|,
name|RPCPROG_MNT
argument_list|,
name|RPCMNT_VER3
argument_list|,
operator|&
name|mdsin
operator|->
name|sin_port
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|xdr_string_encode
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do RPC to mountd. */
name|error
operator|=
name|krpc_call
argument_list|(
name|mdsin
argument_list|,
name|RPCPROG_MNT
argument_list|,
name|RPCMNT_VER3
argument_list|,
name|RPCMNT_MOUNT
argument_list|,
operator|&
name|m
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|NFSMNT_NFSV3
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Fallback to NFS v2 */
comment|/* Get port number for MOUNTD. */
name|error
operator|=
name|krpc_portmap
argument_list|(
name|mdsin
argument_list|,
name|RPCPROG_MNT
argument_list|,
name|RPCMNT_VER1
argument_list|,
operator|&
name|mdsin
operator|->
name|sin_port
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|m
operator|=
name|xdr_string_encode
argument_list|(
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do RPC to mountd. */
name|error
operator|=
name|krpc_call
argument_list|(
name|mdsin
argument_list|,
name|RPCPROG_MNT
argument_list|,
name|RPCMNT_VER1
argument_list|,
name|RPCMNT_MOUNT
argument_list|,
operator|&
name|m
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* message already freed */
ifdef|#
directive|ifdef
name|BOOTP_NFSV3
block|}
endif|#
directive|endif
if|if
condition|(
name|xdr_int_decode
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|error
argument_list|)
operator|!=
literal|0
operator|||
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|NFSMNT_NFSV3
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|xdr_int_decode
argument_list|(
operator|&
name|m
argument_list|,
name|fhsizep
argument_list|)
operator|!=
literal|0
operator|||
operator|*
name|fhsizep
operator|>
name|NFSX_V3FHMAX
operator|||
operator|*
name|fhsizep
operator|<=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
operator|*
name|fhsizep
operator|=
name|NFSX_V2FH
expr_stmt|;
if|if
condition|(
name|xdr_opaque_decode
argument_list|(
operator|&
name|m
argument_list|,
name|fhp
argument_list|,
operator|*
name|fhsizep
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|NFSMNT_NFSV3
condition|)
block|{
if|if
condition|(
name|xdr_int_decode
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|authcount
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|authunixok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|authcount
operator|<
literal|0
operator|||
name|authcount
operator|>
literal|100
condition|)
goto|goto
name|bad
goto|;
while|while
condition|(
name|authcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xdr_int_decode
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|authver
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|authver
operator|==
name|RPCAUTH_UNIX
condition|)
name|authunixok
operator|=
literal|1
expr_stmt|;
name|authcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|authunixok
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* Set port number for NFS use. */
name|error
operator|=
name|krpc_portmap
argument_list|(
name|mdsin
argument_list|,
name|NFS_PROG
argument_list|,
operator|(
name|args
operator|->
name|flags
operator|&
name|NFSMNT_NFSV3
operator|)
condition|?
name|NFS_VER3
else|:
name|NFS_VER2
argument_list|,
operator|&
name|mdsin
operator|->
name|sin_port
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|bad
label|:
name|error
operator|=
name|EBADRPC
expr_stmt|;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|bootp_rootconf
argument_list|,
name|SI_SUB_ROOT_CONF
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|bootpc_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

