begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|_ittyid
index|[]
init|=
literal|"@(#)$Id: iitty.c,v 1.17 1995/12/08 23:19:42 phk Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************************  *  II - Version 0.1 $Revision: 1.17 $   $State: Exp $  *  * Copyright 1994 Dietmar Friede  *******************************************************************************  * Bug reports, patches, comments, suggestions should be sent to:  *  *	jkr@saarlink.de or jkrause@guug.de  *  *******************************************************************************  * $Log: iitty.c,v $  * Revision 1.17  1995/12/08  23:19:42  phk  * Julian forgot to make the *devsw structures static.  *  * Revision 1.16  1995/12/08  11:12:56  julian  * Pass 3 of the great devsw changes  * most devsw referenced functions are now static, as they are  * in the same file as their devsw structure. I've also added DEVFS  * support for nearly every device in the system, however  * many of the devices have 'incorrect' names under DEVFS  * because I couldn't quickly work out the correct naming conventions.  * (but devfs won't be coming on line for a month or so anyhow so that doesn't  * matter)  *  * If you "OWN" a device which would normally have an entry in /dev  * then search for the devfs_add_devsw() entries and munge to make them right..  * check out similar devices to see what I might have done in them in you  * can't see what's going on..  * for a laugh compare conf.c conf.h defore and after... :)  * I have not doen DEVFS entries for any DISKSLICE devices yet as that will be  * a much more complicated job.. (pass 5 :)  *  * pass 4 will be to make the devsw tables of type (cdevsw * )  * rather than (cdevsw)  * seems to work here..  * complaints to the usual places.. :)  *  * Revision 1.15  1995/12/05  20:33:47  bde  * Fixed ity's d_stop entry.  itystop() wasn't used.  itystop() is inadequate  * but probably harmless.  It's hard to tell because apparently no one runs  * ity.  *  * Fixed ity's d_reset entry.  `nx' entries should never be used for existing  * devices.  *  * conf.c:  * Moved a prototype to a better place.  *  * Removed a stale #define.  *  * Revision 1.14  1995/11/29  14:39:12  julian  * If you're going to mechanically replicate something in 50 files  * it's best to not have a (compiles cleanly) typo in it! (sigh)  *  * Revision 1.13  1995/11/29  10:47:09  julian  * OK, that's it..  * That's EVERY SINGLE driver that has an entry in conf.c..  * my next trick will be to define cdevsw[] and bdevsw[]  * as empty arrays and remove all those DAMNED defines as well..  *  * Revision 1.12  1995/11/16  10:35:29  bde  * Fixed the type of ity_input().  A trailing arg was missing.  *  * Completed function declarations.  *  * Added prototypes.  *  * Removed some useless includes.  *  * Revision 1.11  1995/07/31  21:28:42  bde  * Use tsleep() instead of ttysleep() to wait for carrier since a generation  * change isn't an error.  *  * Revision 1.10  1995/07/31  21:01:03  bde  * Obtained from:	partly from ancient patches of mine via 1.1.5  *  * Introduce TS_CONNECTED and TS_ZOMBIE states.  TS_CONNECTED is set  * while a connection is established.  It is set while (TS_CARR_ON or  * CLOCAL is set) and TS_ZOMBIE is clear.  TS_ZOMBIE is set for on to  * off transitions of TS_CARR_ON that occur when CLOCAL is clear and  * is cleared for off to on transitions of CLOCAL.  I/o can only occur  * while TS_CONNECTED is set.  TS_ZOMBIE prevents further i/o.  *  * Split the input-event sleep address TSA_CARR_ON(tp) into TSA_CARR_ON(tp)  * and TSA_HUP_OR_INPUT(tp).  The former address is now used only for  * off to on carrier transitions and equivalent CLOCAL transitions.  * The latter is used for all input events, all carrier transitions  * and certain CLOCAL transitions.  There are some harmless extra  * wakeups for rare connection- related events.  Previously there were  * too many extra wakeups for non-rare input events.  *  * Drivers now call l_modem() instead of setting TS_CARR_ON directly  * to handle even the initial off to on transition of carrier.  They  * should always have done this.  l_modem() now handles TS_CONNECTED  * and TS_ZOMBIE as well as TS_CARR_ON.  *  * gnu/isdn/iitty.c:  * Set TS_CONNECTED for first open ourself to go with bogusly setting  * CLOCAL.  *  * i386/isa/syscons.c, i386/isa/pcvt/pcvt_drv.c:  * We fake carrier, so don't also fake CLOCAL.  *  * kern/tty.c:  * Testing TS_CONNECTED instead of TS_CARR_ON fixes TIOCCONS forgetting to  * test CLOCAL.  TS_ISOPEN was tested instead, but that broke when we disabled  * the clearing of TS_ISOPEN for certain transitions of CLOCAL.  *  * Testing TS_CONNECTED fixes ttyselect() returning false success for output  * to devices in state !TS_CARR_ON&& !CLOCAL.  *  * Optimize the other selwakeup() call (this is not related to the other  * changes).  *  * kern/tty_pty.c:  * ptcopen() can be declared in traditional C now that dev_t isn't short.  *  * Revision 1.9  1995/07/22  16:44:26  bde  * Obtained from:	partly from ancient patches of mine via 1.1.5  *  * Give names to the magic tty i/o sleep addresses and use them.  This makes  * it easier to remember what the addresses are for and to keep them unique.  *  * Revision 1.8  1995/07/22  01:29:28  bde  * Move the inline code for waking up writers to a new function  * ttwwakeup().  The conditions for doing the wakeup will soon become  * more complicated and I don't want them duplicated in all drivers.  *  * It's probably not worth making ttwwakeup() a macro or an inline  * function.  The cost of the function call is relatively small when  * there is a process to wake up.  There is usually a process to wake  * up for large writes and the system call overhead dwarfs the function  * call overhead for small writes.  *  * Revision 1.7  1995/07/21  20:52:21  bde  * Obtained from:	partly from ancient patches by ache and me via 1.1.5  *  * Nuke `symbolic sleep message strings'.  Use unique literal messages so that  * `ps l' shows unambiguously where processes are sleeping.  *  * Revision 1.6  1995/07/21  16:30:37  bde  * Obtained from:	partly from an ancient patch of mine via 1.1.5  *  * Temporarily nuke TS_WOPEN.  It was only used for the obscure MDMBUF  * flow control option in the kernel and for informational purposes  * in `pstat -t'.  The latter worked properly only for ptys.  In  * general there may be multiple processes sleeping in open() and  * multiple processes that successfully opened the tty by opening it  * in O_NONBLOCK mode or during a window when CLOCAL was set.  tty.c  * doesn't have enough information to maintain the flag but always  * cleared it in ttyopen().  *  * TS_WOPEN should be restored someday just so that `pstat -t' can  * display it (MDMBUF is already fixed).  Fixing it requires counting  * of processes sleeping in open() in too many serial drivers.  *  * Revision 1.5  1995/03/28  07:54:43  bde  * Add and move declarations to fix all of the warnings from `gcc -Wimplicit'  * (except in netccitt, netiso and netns) that I didn't notice when I fixed  * "all" such warnings before.  *  * Revision 1.4  1995/02/28  00:20:30  pst  * Incorporate bde's code-review comments.  *  * (a) bring back ttselect, now that we have xxxdevtotty() it isn't dangerous.  * (b) remove all of the wrappers that have been replaced by ttselect  * (c) fix formatting in syscons.c and definition in syscons.h  * (d) add cxdevtotty  *  * NOT DONE:  * (e) make pcvt work... it was already broken...when someone fixes pcvt to  * 	link properly, just rename get_pccons to xxxdevtotty and we're done  *  * Revision 1.3  1995/02/25  20:08:52  pst  * (a) remove the pointer to each driver's tty structure array from cdevsw  * (b) add a function callback vector to tty drivers that will return a pointer  *     to a valid tty structure based upon a dev_t  * (c) make syscons structures the same size whether or not APM is enabled so  *     utilities don't crash if NAPM changes (and make the damn kernel compile!)  * (d) rewrite /dev/snp ioctl interface so that it is device driver and i386  *     independant  *  * Revision 1.2  1995/02/15  06:28:28  jkh  * Fix up include paths, nuke some warnings.  *  * Revision 1.1  1995/02/14  15:00:32  jkh  * An ISDN driver that supports the EDSS1 and the 1TR6 ISDN interfaces.  * EDSS1 is the "Euro-ISDN", 1TR6 is the soon obsolete german ISDN Interface.  * Obtained from: Dietmar Friede<dfriede@drnhh.neuhaus.de> and  * 	Juergen Krause<jkr@saarlink.de>  *  * This is only one part - the rest to follow in a couple of hours.  * This part is a benign import, since it doesn't affect anything else.  *  *  ******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"ity.h"
end_include

begin_if
if|#
directive|if
name|NITY
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|"gnu/isdn/isdn_ioctl.h"
end_include

begin_decl_stmt
specifier|static
name|d_open_t
name|ityopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|ityclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|ityread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|itywrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ityioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_stop_t
name|itystop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|itydevtotty
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|56
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ity_cdevsw
init|=
block|{
name|ityopen
block|,
name|ityclose
block|,
name|ityread
block|,
name|itywrite
block|,
comment|/*56*/
name|ityioctl
block|,
name|itystop
block|,
name|noreset
block|,
name|itydevtotty
block|,
comment|/* ity */
name|ttselect
block|,
name|nommap
block|,
name|NULL
block|,
literal|"ity"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ityparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|itystart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nity
init|=
name|NITY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|itydefaultrate
init|=
literal|64000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ity_addr
index|[
name|NITY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|ity_tty
index|[
name|NITY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|applnr
index|[
name|NITY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_if
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
name|void
modifier|*
name|devfs_token
index|[
name|NITY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|devfs_token_out
index|[
name|NITY
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|(minor(x)&0x3f)
end_define

begin_define
define|#
directive|define
name|OUTBOUND
parameter_list|(
name|x
parameter_list|)
value|((minor(x)&0x80)==0x80)
end_define

begin_function
name|int
name|ityattach
parameter_list|(
name|int
name|ap
parameter_list|)
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|next_if
operator|>=
name|NITY
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|applnr
index|[
name|next_if
index|]
operator|=
name|ap
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ity%d"
argument_list|,
name|next_if
argument_list|)
expr_stmt|;
name|devfs_token
index|[
name|next_if
index|]
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/isdn"
argument_list|,
name|name
argument_list|,
operator|&
name|ity_cdevsw
argument_list|,
name|next_if
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"Oity%d"
argument_list|,
name|next_if
argument_list|)
expr_stmt|;
comment|/* XXX find out real name */
name|devfs_token
index|[
name|next_if
index|]
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/isdn"
argument_list|,
name|name
argument_list|,
operator|&
name|ity_cdevsw
argument_list|,
operator|(
name|next_if
operator||
literal|0x80
operator|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|next_if
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ityopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|next_if
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|ity_tty
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|itystart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|ityparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|itydefaultrate
expr_stmt|;
block|}
name|ityparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
operator|(
name|void
operator|)
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|OUTBOUND
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* 		 * XXX should call l_modem() here and not meddle with CLOCAL, 		 * but itystart() wants TS_CARR_ON to give the true carrier. 		 */
name|tp
operator|->
name|t_cflag
operator||=
name|CLOCAL
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_CONNECTED
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"iidcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ityclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|ity
expr_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ity
operator|=
name|ity_addr
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|=
operator|&
name|ity_tty
index|[
name|unit
index|]
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|isdn_disconnect
argument_list|(
name|applnr
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ityread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|ity_tty
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|itywrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|ity_tty
index|[
name|unit
index|]
decl_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ity_input
parameter_list|(
name|int
name|no
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|ity_tty
index|[
name|no
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|i
index|]
operator|,
name|tp
operator|)
expr_stmt|;
else|else
name|len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|void
name|itystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
if|if
condition|(
name|OUTBOUND
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|)
condition|)
name|isdn_msg
argument_list|(
name|applnr
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
else|else
name|isdn_output
argument_list|(
name|applnr
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ity_out
parameter_list|(
name|int
name|no
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|ity_tty
index|[
name|no
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|;
operator|++
name|i
control|)
name|buf
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|itystart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ity_connect
parameter_list|(
name|int
name|no
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|ity_tty
index|[
name|no
index|]
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|OUTBOUND
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
condition|)
name|tp
operator|->
name|t_cflag
operator|&=
operator|~
name|CLOCAL
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|itystart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ity_disconnect
parameter_list|(
name|int
name|no
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|ity_tty
index|[
name|no
index|]
decl_stmt|;
if|if
condition|(
name|tp
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ityioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|tp
operator|=
operator|&
name|ity_tty
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ityparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|ity
expr_stmt|;
specifier|register
name|int
name|cfcr
decl_stmt|,
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|int
name|ospeed
init|=
name|t
operator|->
name|c_ospeed
decl_stmt|;
comment|/* check requested parameters */
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
operator|(
name|t
operator|->
name|c_ispeed
operator|&&
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
if|if
condition|(
name|ospeed
operator|==
literal|0
condition|)
block|{
name|isdn_disconnect
argument_list|(
name|applnr
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|itystop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|itydevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|next_if
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|ity_tty
index|[
name|unit
index|]
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|ity_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ity_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|ity_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|ity_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ity_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|itydev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|ity_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

