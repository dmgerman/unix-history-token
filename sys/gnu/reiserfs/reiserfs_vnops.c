begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2000 Hans Reiser  * See README for licensing and copyright details  *   * Ported to FreeBSD by Jean-Sébastien Pédron<jspedron@club-internet.fr>  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<gnu/reiserfs/reiserfs_fs.h>
end_include

begin_decl_stmt
specifier|static
name|vop_access_t
name|reiserfs_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_bmap_t
name|reiserfs_bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getattr_t
name|reiserfs_getattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_open_t
name|reiserfs_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_pathconf_t
name|reiserfs_pathconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readlink_t
name|reiserfs_readlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_strategy_t
name|reiserfs_strategy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global vfs data structures for ReiserFS */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|reiserfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|reiserfs_access
block|,
operator|.
name|vop_bmap
operator|=
name|reiserfs_bmap
block|,
operator|.
name|vop_cachedlookup
operator|=
name|reiserfs_lookup
block|,
operator|.
name|vop_getattr
operator|=
name|reiserfs_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|reiserfs_inactive
block|,
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_open
operator|=
name|reiserfs_open
block|,
operator|.
name|vop_reclaim
operator|=
name|reiserfs_reclaim
block|,
operator|.
name|vop_read
operator|=
name|reiserfs_read
block|,
operator|.
name|vop_readdir
operator|=
name|reiserfs_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|reiserfs_readlink
block|,
operator|.
name|vop_pathconf
operator|=
name|reiserfs_pathconf
block|,
operator|.
name|vop_strategy
operator|=
name|reiserfs_strategy
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|reiserfs_specops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|reiserfs_access
block|,
operator|.
name|vop_getattr
operator|=
name|reiserfs_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|reiserfs_inactive
block|,
operator|.
name|vop_reclaim
operator|=
name|reiserfs_reclaim
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------  * vnode operations  * -------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|reiserfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|mode_t
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
comment|/* 	 * Disallow write attempts on read-only file systems; unless the file 	 * is a socket, fifo, or a block or character device resident on the 	 * file system. 	 */
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"no write access (read-only fs)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If immutable bit set, nobody gets to write it. */
if|if
condition|(
operator|(
name|mode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_flags
operator|&
operator|(
name|IMMUTABLE
operator||
name|SF_SNAPSHOT
operator|)
operator|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"no write access (immutable)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|error
operator|=
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|ip
operator|->
name|i_mode
argument_list|,
name|ip
operator|->
name|i_uid
argument_list|,
name|ip
operator|->
name|i_gid
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reiserfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|dev2udev
argument_list|(
name|ip
operator|->
name|i_dev
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|ip
operator|->
name|i_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|ip
operator|->
name|i_nlink
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|ip
operator|->
name|i_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|ip
operator|->
name|i_gid
expr_stmt|;
comment|//XXX vap->va_rdev      = ip->i_rdev;
name|vap
operator|->
name|va_size
operator|=
name|ip
operator|->
name|i_size
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|ip
operator|->
name|i_atime
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|ip
operator|->
name|i_mtime
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|ip
operator|->
name|i_ctime
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
name|ip
operator|->
name|i_flags
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
name|ip
operator|->
name|i_generation
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|dbtob
argument_list|(
operator|(
name|u_quad_t
operator|)
name|ip
operator|->
name|i_blocks
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
comment|//XXX vap->va_filerev   = ip->i_modrev;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return POSIX pathconf information applicable to ReiserFS filesystems */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_pathconf
parameter_list|(
name|struct
name|vop_pathconf_args
modifier|*
name|ap
parameter_list|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|REISERFS_LINK_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|REISERFS_MAX_NAME
argument_list|(
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|i_reiserfs
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PATH_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PIPE_BUF
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PIPE_BUF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|reiserfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
block|{
comment|/* Files marked append-only must be opened for appending. */
if|if
condition|(
operator|(
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|i_flags
operator|&
name|APPEND
operator|)
operator|&&
operator|(
name|ap
operator|->
name|a_mode
operator|&
operator|(
name|FWRITE
operator||
name|O_APPEND
operator|)
operator|)
operator|==
name|FWRITE
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|vnode_create_vobject
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|i_size
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return target name of a symbolic link */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"redirect to VOP_READ()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VOP_READ
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bmap converts the logical block number of a file to its physical  * block number on the disk. */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 				struct vnode *a_vp; 				daddr_t a_bn; 				struct bufobj **a_bop; 				daddr_t *a_bnp; 				int *a_runp; 				int *a_runb; 				} */
modifier|*
name|ap
decl_stmt|;
block|{
name|daddr_t
name|blkno
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|cpu_key
name|key
decl_stmt|;
name|struct
name|item_head
modifier|*
name|ih
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
init|=
name|ip
operator|->
name|i_reiserfs
decl_stmt|;
name|INITIALIZE_PATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Prepare the key to look for the 'block'-th block of file 	 * (XXX we suppose that statfs.f_iosize == sbi->s_blocksize) */
name|make_cpu_key
argument_list|(
operator|&
name|key
argument_list|,
name|ip
argument_list|,
operator|(
name|off_t
operator|)
name|ap
operator|->
name|a_bn
operator|*
name|sbi
operator|->
name|s_blocksize
operator|+
literal|1
argument_list|,
name|TYPE_ANY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Search item */
if|if
condition|(
name|search_for_position_by_key
argument_list|(
name|sbi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
name|POSITION_FOUND
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"position not found\n"
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|bp
operator|=
name|get_last_bp
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|ih
operator|=
name|get_ih
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_indirect_le_ih
argument_list|(
name|ih
argument_list|)
condition|)
block|{
comment|/* Indirect item can be read by the underlying layer, instead of 		 * VOP_STRATEGY. */
name|int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|ind_item
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|B_I_PITEM
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|)
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"found an INDIRECT item\n"
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|get_block_num
argument_list|(
name|ind_item
argument_list|,
name|path
operator|.
name|pos_in_item
argument_list|)
expr_stmt|;
comment|/* Read-ahead */
if|if
condition|(
name|ap
operator|->
name|a_runb
condition|)
block|{
name|uint32_t
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|path
operator|.
name|pos_in_item
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|blkno
operator|-
name|get_block_num
argument_list|(
name|ind_item
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
name|count
operator|+
literal|1
condition|)
break|break;
operator|++
name|count
expr_stmt|;
block|}
comment|/* 			 * This count isn't expressed in DEV_BSIZE base but 			 * in fs' own block base 			 * (see sys/vm/vnode_pager.c:vnode_pager_addr()) 			 */
operator|*
name|ap
operator|->
name|a_runb
operator|=
name|count
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|" read-ahead: %d blocks before\n"
argument_list|,
operator|*
name|ap
operator|->
name|a_runb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_runp
condition|)
block|{
name|uint32_t
name|count
init|=
literal|0
decl_stmt|;
comment|/* 			 * ih is an uint32_t array, that's why we use 			 * its length (in bytes) divided by 4 to know 			 * the number of items 			 */
for|for
control|(
name|i
operator|=
name|path
operator|.
name|pos_in_item
operator|+
literal|1
init|;
name|i
operator|<
name|ih_item_len
argument_list|(
name|ih
argument_list|)
operator|/
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|get_block_num
argument_list|(
name|ind_item
argument_list|,
name|i
argument_list|)
operator|-
name|blkno
operator|)
operator|!=
name|count
operator|+
literal|1
condition|)
break|break;
operator|++
name|count
expr_stmt|;
block|}
comment|/* 			 * This count isn't expressed in DEV_BSIZE base but 			 * in fs' own block base 			 * (see sys/vm/vnode_pager.c:vnode_pager_addr()) */
operator|*
name|ap
operator|->
name|a_runp
operator|=
name|count
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|" read-ahead: %d blocks after\n"
argument_list|,
operator|*
name|ap
operator|->
name|a_runp
argument_list|)
expr_stmt|;
block|}
comment|/* Indirect items can be read using the device VOP_STRATEGY */
if|if
condition|(
name|ap
operator|->
name|a_bop
condition|)
operator|*
name|ap
operator|->
name|a_bop
operator|=
operator|&
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|i_devvp
operator|->
name|v_bufobj
expr_stmt|;
comment|/* Convert the block number into DEV_BSIZE base */
name|blkno
operator|*=
name|btodb
argument_list|(
name|sbi
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Direct item are not DEV_BSIZE aligned, VOP_STRATEGY will 		 * have to handle this case specifically 		 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"found a DIRECT item\n"
argument_list|)
expr_stmt|;
name|blkno
operator|=
name|ap
operator|->
name|a_bn
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runp
condition|)
operator|*
name|ap
operator|->
name|a_runp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runb
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
comment|/* Direct item must be read by reiserfs_strategy */
if|if
condition|(
name|ap
operator|->
name|a_bop
condition|)
operator|*
name|ap
operator|->
name|a_bop
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_bnp
condition|)
operator|*
name|ap
operator|->
name|a_bnp
operator|=
name|blkno
expr_stmt|;
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bnp
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"logical block: %ju (%ju),"
literal|" physical block: %ju (%ju)\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ap
operator|->
name|a_bn
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|ap
operator|->
name|a_bn
operator|/
name|btodb
argument_list|(
name|sbi
operator|->
name|s_blocksize
argument_list|)
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
operator|*
name|ap
operator|->
name|a_bnp
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
operator|*
name|ap
operator|->
name|a_bnp
operator|/
name|btodb
argument_list|(
name|sbi
operator|->
name|s_blocksize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Does simply the same as reiserfs_read. It's called when reiserfs_bmap find  * an direct item. */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_strategy
parameter_list|(
name|struct
name|vop_strategy_args
comment|/* { 					      struct vnode *a_vp; 					      struct buf *a_bp; 					      } */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"logical block: %ju,"
literal|" physical block: %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* Prepare the uio structure */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"prepare uio structure\n"
argument_list|)
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|MIN
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  vector length: %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|aiov
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  buffer length: %u\n"
argument_list|,
name|auio
operator|.
name|uio_resid
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reading block #%ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|reiserfs_get_block
argument_list|(
name|ip
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
literal|0
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No write support yet */
name|error
operator|=
operator|(
name|EOPNOTSUPP
operator|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
block|}
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

