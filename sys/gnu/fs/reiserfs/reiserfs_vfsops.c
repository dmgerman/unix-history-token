begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2000 Hans Reiser  * See README for licensing and copyright details  *   * Ported to FreeBSD by Jean-Sébastien Pédron<jspedron@club-internet.fr>  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<gnu/fs/reiserfs/reiserfs_fs.h>
end_include

begin_decl_stmt
specifier|const
name|char
name|reiserfs_3_5_magic_string
index|[]
init|=
name|REISERFS_SUPER_MAGIC_STRING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|reiserfs_3_6_magic_string
index|[]
init|=
name|REISER2FS_SUPER_MAGIC_STRING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|reiserfs_jr_magic_string
index|[]
init|=
name|REISER2FS_JR_SUPER_MAGIC_STRING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default recommended I/O size is 128k. There might be broken  * applications that are confused by this. Use nolargeio mount option to  * get usual i/o size = PAGE_SIZE.  */
end_comment

begin_decl_stmt
name|int
name|reiserfs_default_io_size
init|=
literal|128
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_cmount_t
name|reiserfs_cmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_fhtovp_t
name|reiserfs_fhtovp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|reiserfs_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|reiserfs_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|reiserfs_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|reiserfs_unmount
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|reiserfs_mountfs
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_bitmap_info_data
parameter_list|(
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
parameter_list|,
name|struct
name|reiserfs_bitmap_info
modifier|*
name|bi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_bitmaps
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_old_bitmaps
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_super_block
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashf_t
name|hash_function
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_root_node
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|,
name|struct
name|reiserfs_node
modifier|*
modifier|*
name|root
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|find_hash_out
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_REISERFSMNT
argument_list|,
literal|"reiserfs_mount"
argument_list|,
literal|"ReiserFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_REISERFSPATH
argument_list|,
literal|"reiserfs_path"
argument_list|,
literal|"ReiserFS path structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_REISERFSNODE
argument_list|,
literal|"reiserfs_node"
argument_list|,
literal|"ReiserFS vnode private part"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------  * VFS operations  * -------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|reiserfs_cmount
parameter_list|(
name|struct
name|mntarg
modifier|*
name|ma
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|reiserfs_args
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ma
operator|=
name|mount_argsu
argument_list|(
name|ma
argument_list|,
literal|"from"
argument_list|,
name|args
operator|.
name|fspec
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"export"
argument_list|,
operator|&
name|args
operator|.
name|export
argument_list|,
sizeof|sizeof
name|args
operator|.
name|export
argument_list|)
expr_stmt|;
name|error
operator|=
name|kernel_mount
argument_list|(
name|ma
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mount system call  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|mode_t
name|accessmode
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|fspec
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
decl_stmt|;
name|struct
name|reiserfs_mount
modifier|*
name|rmp
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|,
modifier|*
name|ndp
init|=
operator|&
name|nd
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
name|EROFS
return|;
comment|/* Get the new options passed to mount */
name|opts
operator|=
name|mp
operator|->
name|mnt_optnew
expr_stmt|;
comment|/* `fspath' contains the mount point (eg. /mnt/linux); REQUIRED */
name|vfs_getopt
argument_list|(
name|opts
argument_list|,
literal|"fspath"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"mount point is `%s'\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* `from' contains the device name (eg. /dev/ad0s1); REQUIRED */
name|fspec
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vfs_getopt
argument_list|(
name|opts
argument_list|,
literal|"from"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fspec
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|fspec
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"device is `%s'\n"
argument_list|,
name|fspec
argument_list|)
expr_stmt|;
comment|/* Handle MNT_UPDATE (mp->mnt_flag) */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
comment|/* For now, only NFS export is supported. */
if|if
condition|(
name|vfs_flagopt
argument_list|(
name|opts
argument_list|,
literal|"export"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not an update, or updating the name: look up the name 	 * and verify that it refers to a sensible disk device. */
if|if
condition|(
name|fspec
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|fspec
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* If mount by non-root, then verify that user has necessary 	 * permissions on the device. */
name|accessmode
operator|=
name|VREAD
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
name|accessmode
operator||=
name|VWRITE
expr_stmt|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|devvp
argument_list|,
name|accessmode
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VFS_MOUNT_PERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|reiserfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO Handle MNT_UPDATE */
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rmp
operator|=
name|VFSTOREISERFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sbi
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
comment|/* 	 * Note that this strncpy() is ok because of a check at the start 	 * of reiserfs_mount(). 	 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"prepare statfs data\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|copystr
argument_list|(
name|fspec
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|MNAMELEN
operator|-
literal|1
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
operator|+
name|size
argument_list|,
name|MNAMELEN
operator|-
name|size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reiserfs_statfs
argument_list|(
name|mp
argument_list|,
operator|&
name|mp
operator|->
name|mnt_stat
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount system call  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|struct
name|reiserfs_mount
modifier|*
name|rmp
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"get private data\n"
argument_list|)
expr_stmt|;
name|rmp
operator|=
name|VFSTOREISERFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sbi
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
comment|/* Flangs handling */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"handle mntflags\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
comment|/* Flush files -> vflush */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"flush vnodes\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX Super block update */
if|if
condition|(
name|sbi
condition|)
block|{
if|if
condition|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"release bitmap buffers (total: %d)\n"
argument_list|,
name|SB_BMAP_NR
argument_list|(
name|sbi
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SB_BMAP_NR
argument_list|(
name|sbi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
condition|)
block|{
name|free
argument_list|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"free bitmaps structure\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sbi
operator|->
name|s_rs
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"free super block data\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sbi
operator|->
name|s_rs
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
name|sbi
operator|->
name|s_rs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"close device\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|si_mountpoint
argument_list|)
name|rmp
operator|->
name|rm_devvp
operator|->
name|v_rdev
operator|->
name|si_mountpoint
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_wither_geom_close
argument_list|(
name|rmp
operator|->
name|rm_cp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|vrele
argument_list|(
name|rmp
operator|->
name|rm_devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbi
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"free sbi\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sbi
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
name|sbi
operator|=
name|rmp
operator|->
name|rm_reiserfs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rmp
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"free rmp\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rmp
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
name|rmp
operator|=
name|NULL
expr_stmt|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the root of a filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|cpu_key
name|rootkey
decl_stmt|;
name|rootkey
operator|.
name|on_disk_key
operator|.
name|k_dir_id
operator|=
name|REISERFS_ROOT_PARENT_OBJECTID
expr_stmt|;
name|rootkey
operator|.
name|on_disk_key
operator|.
name|k_objectid
operator|=
name|REISERFS_ROOT_OBJECTID
expr_stmt|;
name|error
operator|=
name|reiserfs_iget
argument_list|(
name|mp
argument_list|,
operator|&
name|rootkey
argument_list|,
operator|&
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The statfs syscall  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|reiserfs_mount
modifier|*
name|rmp
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|struct
name|reiserfs_super_block
modifier|*
name|rs
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"get private data\n"
argument_list|)
expr_stmt|;
name|rmp
operator|=
name|VFSTOREISERFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sbi
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
name|rs
operator|=
name|sbi
operator|->
name|s_rs
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fill statfs structure\n"
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|sbi
operator|->
name|s_blocksize
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|sbp
operator|->
name|f_bsize
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|sb_block_count
argument_list|(
name|rs
argument_list|)
operator|-
name|sb_bmap_nr
argument_list|(
name|rs
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sb_free_blocks
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
name|sbp
operator|->
name|f_bfree
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  block size   = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sbp
operator|->
name|f_bsize
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  IO size      = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sbp
operator|->
name|f_iosize
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  block count  = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sbp
operator|->
name|f_blocks
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  free blocks  = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sbp
operator|->
name|f_bfree
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  avail blocks = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sbp
operator|->
name|f_bavail
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"...done\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
operator|&
name|mp
operator|->
name|mnt_stat
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"copying monut point info\n"
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntonname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntfromname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  mount from: %s\n"
argument_list|,
name|sbp
operator|->
name|f_mntfromname
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  mount on:   %s\n"
argument_list|,
name|sbp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"...done\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * File handle to vnode  *  * Have to be really careful about stale file handles:  * - check that the inode key is valid  * - call ffs_vget() to get the locked inode  * - check for an unallocated inode (i_mode == 0)  * - check that the given client host has export rights and return  *   those rights via. exflagsp and credanonp  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rfid
modifier|*
name|rfhp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|cpu_key
name|key
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|rfhp
operator|=
operator|(
expr|struct
name|rfid
operator|*
operator|)
name|fhp
expr_stmt|;
name|sbi
operator|=
name|VFSTOREISERFS
argument_list|(
name|mp
argument_list|)
operator|->
name|rm_reiserfs
expr_stmt|;
comment|/* Check that the key is valid */
if|if
condition|(
name|rfhp
operator|->
name|rfid_dirid
operator|<
name|REISERFS_ROOT_PARENT_OBJECTID
operator|&&
name|rfhp
operator|->
name|rfid_objectid
operator|<
name|REISERFS_ROOT_OBJECTID
condition|)
return|return
operator|(
name|ESTALE
operator|)
return|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"file handle key is (dirid=%d, objectid=%d)\n"
argument_list|,
name|rfhp
operator|->
name|rfid_dirid
argument_list|,
name|rfhp
operator|->
name|rfid_objectid
argument_list|)
expr_stmt|;
name|key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
operator|=
name|rfhp
operator|->
name|rfid_dirid
expr_stmt|;
name|key
operator|.
name|on_disk_key
operator|.
name|k_objectid
operator|=
name|rfhp
operator|->
name|rfid_objectid
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"read this inode\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|reiserfs_iget
argument_list|(
name|mp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|nvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"check validity\n"
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_mode
operator|==
literal|0
operator|||
name|ip
operator|->
name|i_generation
operator|!=
name|rfhp
operator|->
name|rfid_gen
condition|)
block|{
name|vput
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"return it\n"
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Functions for the journal  * -------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|is_reiserfs_3_5
parameter_list|(
name|struct
name|reiserfs_super_block
modifier|*
name|rs
parameter_list|)
block|{
return|return
operator|(
operator|!
name|strncmp
argument_list|(
name|rs
operator|->
name|s_v1
operator|.
name|s_magic
argument_list|,
name|reiserfs_3_5_magic_string
argument_list|,
name|strlen
argument_list|(
name|reiserfs_3_5_magic_string
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_reiserfs_3_6
parameter_list|(
name|struct
name|reiserfs_super_block
modifier|*
name|rs
parameter_list|)
block|{
return|return
operator|(
operator|!
name|strncmp
argument_list|(
name|rs
operator|->
name|s_v1
operator|.
name|s_magic
argument_list|,
name|reiserfs_3_6_magic_string
argument_list|,
name|strlen
argument_list|(
name|reiserfs_3_6_magic_string
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_reiserfs_jr
parameter_list|(
name|struct
name|reiserfs_super_block
modifier|*
name|rs
parameter_list|)
block|{
return|return
operator|(
operator|!
name|strncmp
argument_list|(
name|rs
operator|->
name|s_v1
operator|.
name|s_magic
argument_list|,
name|reiserfs_jr_magic_string
argument_list|,
name|strlen
argument_list|(
name|reiserfs_jr_magic_string
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_any_reiserfs_magic_string
parameter_list|(
name|struct
name|reiserfs_super_block
modifier|*
name|rs
parameter_list|)
block|{
return|return
operator|(
operator|(
name|is_reiserfs_3_5
argument_list|(
name|rs
argument_list|)
operator|||
name|is_reiserfs_3_6
argument_list|(
name|rs
argument_list|)
operator|||
name|is_reiserfs_jr
argument_list|(
name|rs
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Internal functions  * -------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Common code for mount and mountroot  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_mountfs
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|old_format
init|=
literal|0
decl_stmt|;
name|struct
name|reiserfs_mount
modifier|*
name|rmp
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|struct
name|reiserfs_super_block
modifier|*
name|rs
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
init|=
name|devvp
operator|->
name|v_rdev
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|600000
operator|)
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
endif|#
directive|endif
comment|//ronly = (mp->mnt_flag& MNT_RDONLY) != 0;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|600000
operator|)
comment|/* 	 * Disallow multiple mounts of the same device. 	 * Disallow mounting of a device that is currently in use 	 * (except for root, which might share swap device for miniroot). 	 * Flush out any old buffers remaining from a previous use. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vfs_mountedon
argument_list|(
name|devvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vcount
argument_list|(
name|devvp
argument_list|)
operator|>
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|error
operator|=
name|vinvalbuf
argument_list|(
name|devvp
argument_list|,
name|V_SAVE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Open the device in read-only, 'cause we don't support write 	 * for now 	 */
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|devvp
argument_list|,
name|FREAD
argument_list|,
name|FSCRED
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"reiserfs"
argument_list|,
comment|/* read-only */
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bo
operator|->
name|bo_private
operator|=
name|cp
expr_stmt|;
name|bo
operator|->
name|bo_ops
operator|=
name|g_vfs_bufops
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|devvp
operator|->
name|v_rdev
operator|->
name|si_iosize_max
operator|!=
literal|0
condition|)
name|mp
operator|->
name|mnt_iosize_max
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_iosize_max
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_iosize_max
operator|>
name|MAXPHYS
condition|)
name|mp
operator|->
name|mnt_iosize_max
operator|=
name|MAXPHYS
expr_stmt|;
name|rmp
operator|=
name|NULL
expr_stmt|;
name|sbi
operator|=
name|NULL
expr_stmt|;
comment|/* rmp contains any information about this specific mount */
name|rmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|rmp
argument_list|,
name|M_REISERFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rmp
condition|)
block|{
name|error
operator|=
operator|(
name|ENOMEM
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sbi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sbi
argument_list|,
name|M_REISERFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sbi
condition|)
block|{
name|error
operator|=
operator|(
name|ENOMEM
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rmp
operator|->
name|rm_reiserfs
operator|=
name|sbi
expr_stmt|;
name|rmp
operator|->
name|rm_mountp
operator|=
name|mp
expr_stmt|;
name|rmp
operator|->
name|rm_devvp
operator|=
name|devvp
expr_stmt|;
name|rmp
operator|->
name|rm_dev
operator|=
name|dev
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|600000
operator|)
name|rmp
operator|->
name|rm_bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
name|rmp
operator|->
name|rm_cp
operator|=
name|cp
expr_stmt|;
endif|#
directive|endif
comment|/* Set default values for options: non-aggressive tails */
name|REISERFS_SB
argument_list|(
name|sbi
argument_list|)
operator|->
name|s_mount_opt
operator|=
operator|(
literal|1
operator|<<
name|REISERFS_SMALLTAIL
operator|)
expr_stmt|;
name|REISERFS_SB
argument_list|(
name|sbi
argument_list|)
operator|->
name|s_rd_only
operator|=
literal|1
expr_stmt|;
name|REISERFS_SB
argument_list|(
name|sbi
argument_list|)
operator|->
name|s_devvp
operator|=
name|devvp
expr_stmt|;
comment|/* Read the super block */
if|if
condition|(
operator|(
name|error
operator|=
name|read_super_block
argument_list|(
name|rmp
argument_list|,
name|REISERFS_OLD_DISK_OFFSET
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The read process succeeded, it's an old format */
name|old_format
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|read_super_block
argument_list|(
name|rmp
argument_list|,
name|REISERFS_DISK_OFFSET
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not find a ReiserFS filesystem\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rs
operator|=
name|SB_DISK_SUPER_BLOCK
argument_list|(
name|sbi
argument_list|)
expr_stmt|;
comment|/* 	 * Let's do basic sanity check to verify that underlying device is 	 * not smaller than the filesystem. If the check fails then abort and 	 * scream, because bad stuff will happen otherwise. 	 */
if|#
directive|if
literal|0
block|if (s->s_bdev&& s->s_bdev->bd_inode&& 	    i_size_read(s->s_bdev->bd_inode)< 	    sb_block_count(rs) * sb_blocksize(rs)) { 		reiserfs_log(LOG_ERR, 		    "reiserfs: filesystem cannot be mounted because it is " 		    "bigger than the device.\n"); 		reiserfs_log(LOG_ERR, "reiserfs: you may need to run fsck " 		    "rr may be you forgot to reboot after fdisk when it " 		    "told you to.\n"); 		goto out; 	}
endif|#
directive|endif
comment|/* 	 * XXX This is from the original Linux code, but why affecting 2 values 	 * to the same variable? 	 */
name|sbi
operator|->
name|s_mount_state
operator|=
name|SB_REISERFS_STATE
argument_list|(
name|sbi
argument_list|)
expr_stmt|;
name|sbi
operator|->
name|s_mount_state
operator|=
name|REISERFS_VALID_FS
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|old_format
condition|?
name|read_old_bitmaps
argument_list|(
name|rmp
argument_list|)
else|:
name|read_bitmaps
argument_list|(
name|rmp
argument_list|)
operator|)
operator|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to read bitmap\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Make data=ordered the default */
if|if
condition|(
operator|!
name|reiserfs_data_log
argument_list|(
name|sbi
argument_list|)
operator|&&
operator|!
name|reiserfs_data_ordered
argument_list|(
name|sbi
argument_list|)
operator|&&
operator|!
name|reiserfs_data_writeback
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|REISERFS_SB
argument_list|(
name|sbi
argument_list|)
operator|->
name|s_mount_opt
operator||=
operator|(
literal|1
operator|<<
name|REISERFS_DATA_ORDERED
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|reiserfs_data_log
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using journaled data mode\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reiserfs_data_ordered
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using ordered data mode\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using writeback data mode\n"
argument_list|)
expr_stmt|;
block|}
comment|/* TODO Not yet supported */
if|#
directive|if
literal|0
block|if(journal_init(sbi, jdev_name, old_format, commit_max_age)) { 		reiserfs_log(LOG_ERR, "unable to initialize journal space\n"); 		goto out; 	} else { 		jinit_done = 1 ;
comment|/* once this is set, journal_release must 				    be called if we error out of the mount */
block|}  	if (reread_meta_blocks(sbi)) { 		reiserfs_log(LOG_ERR, 		    "unable to reread meta blocks after journal init\n"); 		goto out; 	}
endif|#
directive|endif
comment|/* Define and initialize hash function */
name|sbi
operator|->
name|s_hash_function
operator|=
name|hash_function
argument_list|(
name|rmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbi
operator|->
name|s_hash_function
operator|==
name|NULL
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't determined hash function\n"
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|EINVAL
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|is_reiserfs_3_5
argument_list|(
name|rs
argument_list|)
operator|||
operator|(
name|is_reiserfs_jr
argument_list|(
name|rs
argument_list|)
operator|&&
name|SB_VERSION
argument_list|(
name|sbi
argument_list|)
operator|==
name|REISERFS_VERSION_1
operator|)
condition|)
name|bit_set
argument_list|(
operator|&
operator|(
name|sbi
operator|->
name|s_properties
operator|)
argument_list|,
name|REISERFS_3_5
argument_list|)
expr_stmt|;
else|else
name|bit_set
argument_list|(
operator|&
operator|(
name|sbi
operator|->
name|s_properties
operator|)
argument_list|,
name|REISERFS_3_6
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|rmp
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|si_mountpoint
argument_list|)
name|devvp
operator|->
name|v_rdev
operator|->
name|si_mountpoint
operator|=
name|mp
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"*** error during mount ***\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbi
condition|)
block|{
if|if
condition|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SB_BMAP_NR
argument_list|(
name|sbi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
condition|)
break|break;
name|free
argument_list|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbi
operator|->
name|s_rs
condition|)
block|{
name|free
argument_list|(
name|sbi
operator|->
name|s_rs
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
name|sbi
operator|->
name|s_rs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|600000
operator|)
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|devvp
argument_list|,
name|FREAD
argument_list|,
name|NOCRED
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_wither_geom_close
argument_list|(
name|cp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sbi
condition|)
name|free
argument_list|(
name|sbi
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmp
condition|)
name|free
argument_list|(
name|rmp
argument_list|,
name|M_REISERFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the super block  */
end_comment

begin_function
specifier|static
name|int
name|read_super_block
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|bits
decl_stmt|;
name|struct
name|reiserfs_super_block
modifier|*
name|rs
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|uint16_t
name|fs_blocksize
decl_stmt|;
if|if
condition|(
name|offset
operator|==
name|REISERFS_OLD_DISK_OFFSET
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs/super: read old format super block\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs/super: read new format super block\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Read the super block */
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|rmp
operator|->
name|rm_devvp
argument_list|,
name|offset
operator|*
name|btodb
argument_list|(
name|REISERFS_BSIZE
argument_list|)
argument_list|,
name|REISERFS_BSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't read device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get it from the buffer data */
name|rs
operator|=
operator|(
expr|struct
name|reiserfs_super_block
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|is_any_reiserfs_magic_string
argument_list|(
name|rs
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fs_blocksize
operator|=
name|sb_blocksize
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fs_blocksize
operator|<=
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unexpected null block size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Read the super block (for double check) 	 * We can't read the same blkno with a different size: it causes 	 * panic() if INVARIANTS is set. So we keep REISERFS_BSIZE */
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|rmp
operator|->
name|rm_devvp
argument_list|,
name|offset
operator|*
name|REISERFS_BSIZE
operator|/
name|fs_blocksize
operator|*
name|btodb
argument_list|(
name|fs_blocksize
argument_list|)
argument_list|,
name|REISERFS_BSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't reread the super block\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rs
operator|=
operator|(
expr|struct
name|reiserfs_super_block
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|sb_blocksize
argument_list|(
name|rs
argument_list|)
operator|!=
name|fs_blocksize
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unexpected block size "
literal|"(found=%u, expected=%u)\n"
argument_list|,
name|sb_blocksize
argument_list|(
name|rs
argument_list|)
argument_list|,
name|fs_blocksize
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"magic: `%s'\n"
argument_list|,
name|rs
operator|->
name|s_v1
operator|.
name|s_magic
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"label: `%s'\n"
argument_list|,
name|rs
operator|->
name|s_label
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"block size:     %6d\n"
argument_list|,
name|sb_blocksize
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"block count:    %6u\n"
argument_list|,
name|rs
operator|->
name|s_v1
operator|.
name|s_block_count
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bitmaps number: %6u\n"
argument_list|,
name|rs
operator|->
name|s_v1
operator|.
name|s_bmap_nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|s_v1
operator|.
name|s_root_block
operator|==
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"reiserfs: Unfinished reiserfsck --rebuild-tree run "
literal|"detected. Please\n"
literal|"run reiserfsck --rebuild-tree and wait for a "
literal|"completion. If that\n"
literal|"fails, get newer reiserfsprogs package"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sbi
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
name|sbi
operator|->
name|s_blocksize
operator|=
name|fs_blocksize
expr_stmt|;
for|for
control|(
name|bits
operator|=
literal|9
operator|,
name|fs_blocksize
operator|>>=
literal|9
init|;
name|fs_blocksize
operator|>>=
literal|1
condition|;
name|bits
operator|++
control|)
empty_stmt|;
name|sbi
operator|->
name|s_blocksize_bits
operator|=
name|bits
expr_stmt|;
comment|/* Copy the buffer and release it */
name|sbi
operator|->
name|s_rs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|rs
argument_list|,
name|M_REISERFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sbi
operator|->
name|s_rs
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can not read the super block\n"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|rs
argument_list|,
name|sbi
operator|->
name|s_rs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reiserfs_super_block
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reiserfs_jr
argument_list|(
name|rs
argument_list|)
condition|)
block|{
if|if
condition|(
name|sb_version
argument_list|(
name|rs
argument_list|)
operator|==
name|REISERFS_VERSION_2
condition|)
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"found reiserfs format \"3.6\""
literal|" with non-standard journal"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sb_version
argument_list|(
name|rs
argument_list|)
operator|==
name|REISERFS_VERSION_1
condition|)
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"found reiserfs format \"3.5\""
literal|" with non-standard journal"
argument_list|)
expr_stmt|;
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"found unknown "
literal|"format \"%u\" of reiserfs with non-standard magic"
argument_list|,
name|sb_version
argument_list|(
name|rs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * s_version of standard format may contain incorrect 		 * information, so we just look at the magic string 		 */
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"found reiserfs format \"%s\" with standard journal\n"
argument_list|,
name|is_reiserfs_3_5
argument_list|(
name|rs
argument_list|)
condition|?
literal|"3.5"
else|:
literal|"3.6"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * load_bitmap_info_data - Sets up the reiserfs_bitmap_info structure  * from disk.  * @sbi - superblock info for this filesystem  * @bi  - the bitmap info to be loaded. Requires that bi->bp is valid.  *  * This routine counts how many free bits there are, finding the first  * zero as a side effect. Could also be implemented as a loop of  * test_bit() calls, or a loop of find_first_zero_bit() calls. This  * implementation is similar to find_first_zero_bit(), but doesn't  * return after it finds the first bit. Should only be called on fs  * mount, but should be fairly efficient anyways.  *  * bi->first_zero_hint is considered unset if it == 0, since the bitmap  * itself will invariably occupt block 0 represented in the bitmap. The  * only exception to this is when free_count also == 0, since there will  * be no free blocks at all.  */
end_comment

begin_function
specifier|static
name|void
name|load_bitmap_info_data
parameter_list|(
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
parameter_list|,
name|struct
name|reiserfs_bitmap_info
modifier|*
name|bi
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|cur
decl_stmt|;
name|cur
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|bi
operator|->
name|bp_data
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|cur
operator|<
operator|(
name|bi
operator|->
name|bp_data
operator|+
name|sbi
operator|->
name|s_blocksize
operator|)
condition|)
block|{
comment|/* 		 * No need to scan if all 0's or all 1's. 		 * Since we're only counting 0's, we can simply ignore 		 * all 1's 		 */
if|if
condition|(
operator|*
name|cur
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bi
operator|->
name|first_zero_hint
operator|==
literal|0
condition|)
block|{
name|bi
operator|->
name|first_zero_hint
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|cur
operator|-
name|bi
operator|->
name|bp_data
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
name|bi
operator|->
name|free_count
operator|+=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cur
operator|!=
operator|~
literal|0L
condition|)
block|{
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
literal|8
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|reiserfs_test_le_bit
argument_list|(
name|b
argument_list|,
name|cur
argument_list|)
condition|)
block|{
name|bi
operator|->
name|free_count
operator|++
expr_stmt|;
if|if
condition|(
name|bi
operator|->
name|first_zero_hint
operator|==
literal|0
condition|)
name|bi
operator|->
name|first_zero_hint
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|cur
operator|-
name|bi
operator|->
name|bp_data
operator|)
operator|<<
literal|3
operator|)
operator|+
name|b
expr_stmt|;
block|}
block|}
block|}
name|cur
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the bitmaps  */
end_comment

begin_function
specifier|static
name|int
name|read_bitmaps
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bmap_nr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
init|=
name|rmp
operator|->
name|rm_reiserfs
decl_stmt|;
comment|/* Allocate memory for the table of bitmaps */
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reiserfs_bitmap_info
argument_list|)
operator|*
name|SB_BMAP_NR
argument_list|(
name|sbi
argument_list|)
argument_list|,
name|M_REISERFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Read all the bitmaps */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bmap_nr
operator|=
operator|(
name|REISERFS_DISK_OFFSET_IN_BYTES
operator|/
name|sbi
operator|->
name|s_blocksize
operator|+
literal|1
operator|)
operator|*
name|btodb
argument_list|(
name|sbi
operator|->
name|s_blocksize
argument_list|)
init|;
name|i
operator|<
name|SB_BMAP_NR
argument_list|(
name|sbi
argument_list|)
condition|;
name|i
operator|++
operator|,
name|bmap_nr
operator|=
name|sbi
operator|->
name|s_blocksize
operator|*
literal|8
operator|*
name|i
control|)
block|{
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
operator|=
name|malloc
argument_list|(
name|sbi
operator|->
name|s_blocksize
argument_list|,
name|M_REISERFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bread
argument_list|(
name|rmp
operator|->
name|rm_devvp
argument_list|,
name|bmap_nr
argument_list|,
name|sbi
operator|->
name|s_blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|bp_data
argument_list|,
name|sbi
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/*if (!buffer_uptodate(SB_AP_BITMAP(s)[i].bh)) 			ll_rw_block(READ, 1,&SB_AP_BITMAP(s)[i].bh);*/
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SB_BMAP_NR
argument_list|(
name|sbi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*if (!buffer_uptodate(SB_AP_BITMAP(s)[i].bh)) { 		  reiserfs_warning(s,"sh-2029: reiserfs read_bitmaps: " 		  "bitmap block (#%lu) reading failed", 		  SB_AP_BITMAP(s)[i].bh->b_blocknr); 		  for (i = 0; i< SB_BMAP_NR(s); i++) 		  brelse(SB_AP_BITMAP(s)[i].bh); 		  vfree(SB_AP_BITMAP(s)); 		  SB_AP_BITMAP(s) = NULL; 		  return 1; 		  }*/
name|load_bitmap_info_data
argument_list|(
name|sbi
argument_list|,
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%d free blocks (starting at block %ld)\n"
argument_list|,
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|free_count
argument_list|,
operator|(
name|long
operator|)
name|SB_AP_BITMAP
argument_list|(
name|sbi
argument_list|)
index|[
name|i
index|]
operator|.
name|first_zero_hint
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|// TODO Not supported
end_comment

begin_function
specifier|static
name|int
name|read_old_bitmaps
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|#
directive|if
literal|0
block|int i; 	struct reiserfs_sb_info *sbi = rmp->rm_reiserfs; 	struct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(sbi);
comment|/* First of bitmap blocks */
block|int bmp1 = (REISERFS_OLD_DISK_OFFSET / sbi->s_blocksize) * 	    btodb(sbi->s_blocksize);
comment|/* Read true bitmap */
block|SB_AP_BITMAP(sbi) = 	    malloc(sizeof (struct reiserfs_buffer_info *) * sb_bmap_nr(rs), 		M_REISERFSMNT, M_WAITOK | M_ZERO); 	if (!SB_AP_BITMAP(sbi)) 		return 1;  	for (i = 0; i< sb_bmap_nr(rs); i ++) { 		SB_AP_BITMAP(sbi)[i].bp = getblk(rmp->rm_devvp, 		    (bmp1 + i) * btodb(sbi->s_blocksize), sbi->s_blocksize, 0, 0, 0); 		if (!SB_AP_BITMAP(sbi)[i].bp) 			return 1; 		load_bitmap_info_data(sbi, SB_AP_BITMAP(sbi) + i); 	}  	return 0;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Hash detection stuff  * -------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|get_root_node
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|,
name|struct
name|reiserfs_node
modifier|*
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|reiserfs_iget_args
name|args
decl_stmt|;
comment|/* Allocate the node structure */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"malloc(struct reiserfs_node)\n"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ip
argument_list|,
expr|struct
name|reiserfs_node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reiserfs_node
argument_list|)
argument_list|,
name|M_REISERFSNODE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Fill the structure */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"filling *ip\n"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_dev
operator|=
name|rmp
operator|->
name|rm_dev
expr_stmt|;
name|ip
operator|->
name|i_number
operator|=
name|REISERFS_ROOT_OBJECTID
expr_stmt|;
name|ip
operator|->
name|i_ino
operator|=
name|REISERFS_ROOT_PARENT_OBJECTID
expr_stmt|;
name|ip
operator|->
name|i_reiserfs
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
comment|/* Read the inode */
name|args
operator|.
name|objectid
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|args
operator|.
name|dirid
operator|=
name|ip
operator|->
name|i_ino
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"call reiserfs_read_locked_inode("
literal|"objectid=%d,dirid=%d)\n"
argument_list|,
name|args
operator|.
name|objectid
argument_list|,
name|args
operator|.
name|dirid
argument_list|)
expr_stmt|;
name|reiserfs_read_locked_inode
argument_list|(
name|ip
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_devvp
operator|=
name|rmp
operator|->
name|rm_devvp
expr_stmt|;
comment|//XXX VREF(ip->i_devvp); Is it necessary ?
operator|*
name|root
operator|=
name|ip
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If root directory is empty - we set default - Yura's - hash and warn  * about it.  * FIXME: we look for only one name in a directory. If tea and yura both  * have the same value - we ask user to send report to the mailing list  */
end_comment

begin_function
name|uint32_t
name|find_hash_out
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|cpu_key
name|key
decl_stmt|;
name|INITIALIZE_PATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|struct
name|reiserfs_dir_entry
name|de
decl_stmt|;
name|uint32_t
name|hash
init|=
name|DEFAULT_HASH
decl_stmt|;
name|get_root_node
argument_list|(
name|rmp
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
return|return
operator|(
name|UNSET_HASH
operator|)
return|;
name|sbi
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
do|do
block|{
name|uint32_t
name|teahash
decl_stmt|,
name|r5hash
decl_stmt|,
name|yurahash
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"make_cpu_key\n"
argument_list|)
expr_stmt|;
name|make_cpu_key
argument_list|(
operator|&
name|key
argument_list|,
name|ip
argument_list|,
operator|~
literal|0
argument_list|,
name|TYPE_DIRENTRY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search_by_entry_key for "
literal|"key(objectid=%d,dirid=%d)\n"
argument_list|,
name|key
operator|.
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|search_by_entry_key
argument_list|(
name|sbi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|IO_ERROR
condition|)
block|{
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNSET_HASH
operator|)
return|;
block|}
if|if
condition|(
name|retval
operator|==
name|NAME_NOT_FOUND
condition|)
name|de
operator|.
name|de_entry_num
operator|--
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"name found\n"
argument_list|)
expr_stmt|;
name|set_de_name_and_namelen
argument_list|(
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
operator|==
name|DOT_DOT_OFFSET
condition|)
block|{
comment|/* Allow override in this case */
if|if
condition|(
name|reiserfs_rupasov_hash
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|hash
operator|=
name|YURA_HASH
expr_stmt|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"FS seems to be empty, autodetect "
literal|"is using the default hash"
argument_list|)
expr_stmt|;
break|break;
block|}
name|r5hash
operator|=
name|GET_HASH_VALUE
argument_list|(
name|r5_hash
argument_list|(
name|de
operator|.
name|de_name
argument_list|,
name|de
operator|.
name|de_namelen
argument_list|)
argument_list|)
expr_stmt|;
name|teahash
operator|=
name|GET_HASH_VALUE
argument_list|(
name|keyed_hash
argument_list|(
name|de
operator|.
name|de_name
argument_list|,
name|de
operator|.
name|de_namelen
argument_list|)
argument_list|)
expr_stmt|;
name|yurahash
operator|=
name|GET_HASH_VALUE
argument_list|(
name|yura_hash
argument_list|(
name|de
operator|.
name|de_name
argument_list|,
name|de
operator|.
name|de_namelen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|teahash
operator|==
name|r5hash
operator|)
operator|&&
operator|(
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
argument_list|)
operator|==
name|r5hash
operator|)
operator|)
operator|||
operator|(
operator|(
name|teahash
operator|==
name|yurahash
operator|)
operator|&&
operator|(
name|yurahash
operator|==
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|r5hash
operator|==
name|yurahash
operator|)
operator|&&
operator|(
name|yurahash
operator|==
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to automatically detect hash "
literal|"function. Please mount with -o "
literal|"hash={tea,rupasov,r5}"
argument_list|)
expr_stmt|;
name|hash
operator|=
name|UNSET_HASH
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
argument_list|)
operator|==
name|yurahash
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"detected YURA hash\n"
argument_list|)
expr_stmt|;
name|hash
operator|=
name|YURA_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
argument_list|)
operator|==
name|teahash
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"detected TEA hash\n"
argument_list|)
expr_stmt|;
name|hash
operator|=
name|TEA_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
operator|&
operator|(
name|de
operator|.
name|de_deh
index|[
name|de
operator|.
name|de_entry_num
index|]
operator|)
argument_list|)
argument_list|)
operator|==
name|r5hash
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"detected R5 hash\n"
argument_list|)
expr_stmt|;
name|hash
operator|=
name|R5_HASH
expr_stmt|;
block|}
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unrecognised hash function"
argument_list|)
expr_stmt|;
name|hash
operator|=
name|UNSET_HASH
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds out which hash names are sorted with */
end_comment

begin_function
specifier|static
name|int
name|what_hash
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
block|{
name|uint32_t
name|code
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
init|=
name|rmp
operator|->
name|rm_reiserfs
decl_stmt|;
name|find_hash_out
argument_list|(
name|rmp
argument_list|)
expr_stmt|;
name|code
operator|=
name|sb_hash_function_code
argument_list|(
name|SB_DISK_SUPER_BLOCK
argument_list|(
name|sbi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * reiserfs_hash_detect() == true if any of the hash mount options 	 * were used. We must check them to make sure the user isn't using a 	 * bad hash value 	 */
if|if
condition|(
name|code
operator|==
name|UNSET_HASH
operator|||
name|reiserfs_hash_detect
argument_list|(
name|sbi
argument_list|)
condition|)
name|code
operator|=
name|find_hash_out
argument_list|(
name|rmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|UNSET_HASH
operator|&&
name|reiserfs_hash_detect
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
comment|/* 		 * Detection has found the hash, and we must check against 		 * the mount options 		 */
if|if
condition|(
name|reiserfs_rupasov_hash
argument_list|(
name|sbi
argument_list|)
operator|&&
name|code
operator|!=
name|YURA_HASH
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error, %s hash detected, "
literal|"unable to force rupasov hash"
argument_list|,
name|reiserfs_hashname
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|UNSET_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reiserfs_tea_hash
argument_list|(
name|sbi
argument_list|)
operator|&&
name|code
operator|!=
name|TEA_HASH
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error, %s hash detected, "
literal|"unable to force tea hash"
argument_list|,
name|reiserfs_hashname
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|UNSET_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reiserfs_r5_hash
argument_list|(
name|sbi
argument_list|)
operator|&&
name|code
operator|!=
name|R5_HASH
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error, %s hash detected, "
literal|"unable to force r5 hash"
argument_list|,
name|reiserfs_hashname
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|UNSET_HASH
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Find_hash_out was not called or could not determine 		 * the hash 		 */
if|if
condition|(
name|reiserfs_rupasov_hash
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|code
operator|=
name|YURA_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reiserfs_tea_hash
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|code
operator|=
name|TEA_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reiserfs_r5_hash
argument_list|(
name|sbi
argument_list|)
condition|)
block|{
name|code
operator|=
name|R5_HASH
expr_stmt|;
block|}
block|}
comment|/* TODO Not supported yet */
if|#
directive|if
literal|0
comment|/* If we are mounted RW, and we have a new valid hash code, update 	 * the super */
block|if (code != UNSET_HASH&& 	    !(s->s_flags& MS_RDONLY)&& 	    code != sb_hash_function_code(SB_DISK_SUPER_BLOCK(s))) { 		set_sb_hash_function_code(SB_DISK_SUPER_BLOCK(s), code); 	}
endif|#
directive|endif
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return pointer to appropriate function */
end_comment

begin_function
specifier|static
name|hashf_t
name|hash_function
parameter_list|(
name|struct
name|reiserfs_mount
modifier|*
name|rmp
parameter_list|)
block|{
switch|switch
condition|(
name|what_hash
argument_list|(
name|rmp
argument_list|)
condition|)
block|{
case|case
name|TEA_HASH
case|:
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using tea hash to sort names\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|keyed_hash
operator|)
return|;
case|case
name|YURA_HASH
case|:
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using rupasov hash to sort names\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|yura_hash
operator|)
return|;
case|case
name|R5_HASH
case|:
name|reiserfs_log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using r5 hash to sort names\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r5_hash
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * VFS registration  * -------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|reiser_vfsops
init|=
block|{
operator|.
name|vfs_cmount
operator|=
name|reiserfs_cmount
block|,
operator|.
name|vfs_mount
operator|=
name|reiserfs_mount
block|,
operator|.
name|vfs_unmount
operator|=
name|reiserfs_unmount
block|,
comment|//.vfs_checkexp	= reiserfs_checkexp,
comment|//.vfs_extattrctl = reiserfs_extattrctl,
operator|.
name|vfs_fhtovp
operator|=
name|reiserfs_fhtovp
block|,
comment|//.vfs_quotactl	= reiserfs_quotactl,
operator|.
name|vfs_root
operator|=
name|reiserfs_root
block|,
comment|//.vfs_start	= reiserfs_start,
operator|.
name|vfs_statfs
operator|=
name|reiserfs_statfs
block|,
comment|//.vfs_sync	= reiserfs_sync,
comment|//.vfs_vget	= reiserfs_vget,
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|reiser_vfsops
argument_list|,
name|reiserfs
argument_list|,
name|VFCF_READONLY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

