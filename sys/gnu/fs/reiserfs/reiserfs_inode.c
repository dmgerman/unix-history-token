begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2000 Hans Reiser  * See README for licensing and copyright details  *   * Ported to FreeBSD by Jean-SÃ©bastien PÃ©dron<dumbbell@FreeBSD.org>  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<gnu/fs/reiserfs/reiserfs_fs.h>
end_include

begin_decl_stmt
specifier|static
name|b_strategy_t
name|reiserfs_bufstrategy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Buffer operations for ReiserFS vnodes.  * We punt on VOP_BMAP, so we need to do strategy on the file's vnode  * rather than the underlying device's.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf_ops
name|reiserfs_vnbufops
init|=
block|{
operator|.
name|bop_name
operator|=
literal|"ReiserFS"
block|,
operator|.
name|bop_strategy
operator|=
name|reiserfs_bufstrategy
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default io size devuned in super.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|reiserfs_default_io_size
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|inode_set_bytes
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|off_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Args for the create parameter of reiserfs_get_block */
end_comment

begin_define
define|#
directive|define
name|GET_BLOCK_NO_CREATE
value|0
end_define

begin_comment
comment|/* Don't create new blocks or convert 				      tails */
end_comment

begin_define
define|#
directive|define
name|GET_BLOCK_CREATE
value|1
end_define

begin_comment
comment|/* Add anything you need to find block */
end_comment

begin_define
define|#
directive|define
name|GET_BLOCK_NO_HOLE
value|2
end_define

begin_comment
comment|/* Return ENOENT for file holes */
end_comment

begin_define
define|#
directive|define
name|GET_BLOCK_READ_DIRECT
value|4
end_define

begin_comment
comment|/* Read the tail if indirect item not 				      found */
end_comment

begin_define
define|#
directive|define
name|GET_BLOCK_NO_ISEM
value|8
end_define

begin_comment
comment|/* i_sem is not held, don't preallocate */
end_comment

begin_define
define|#
directive|define
name|GET_BLOCK_NO_DANGLE
value|16
end_define

begin_comment
comment|/* Don't leave any transactions running */
end_comment

begin_comment
comment|/* -------------------------------------------------------------------  * vnode operations  * -------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|reiserfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|long
name|size
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|off_t
name|bytesinfile
decl_stmt|,
name|offset
decl_stmt|;
name|uio
operator|=
name|ap
operator|->
name|a_uio
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sbi
operator|=
name|ip
operator|->
name|i_reiserfs
expr_stmt|;
name|size
operator|=
name|sbi
operator|->
name|s_blocksize
expr_stmt|;
for|for
control|(
name|error
operator|=
literal|0
init|;
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|bytesinfile
operator|=
name|ip
operator|->
name|i_size
operator|-
name|uio
operator|->
name|uio_offset
operator|)
operator|<=
literal|0
condition|)
break|break;
comment|/* Compute the logical block number and its offset */
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|/
name|size
expr_stmt|;
name|offset
operator|=
name|uio
operator|->
name|uio_offset
operator|%
name|size
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"logical block number: %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lbn
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"block offset:         %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Read file blocks */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs_get_block(%ju)\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|reiserfs_get_block
argument_list|(
name|ip
argument_list|,
name|lbn
argument_list|,
name|offset
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs_get_block returned the error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reiserfs_bufstrategy
parameter_list|(
name|struct
name|bufobj
modifier|*
name|bo
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|vp
operator|=
name|bo
operator|->
name|bo_private
expr_stmt|;
name|KASSERT
argument_list|(
name|bo
operator|==
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|,
operator|(
literal|"BO/VP mismatch: vp %p bo %p != %p"
operator|,
name|vp
operator|,
operator|&
name|vp
operator|->
name|v_bufobj
operator|,
name|bo
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|VOP_STRATEGY
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
argument_list|,
operator|(
literal|"ReiserFS VOP_STRATEGY failed: bp=%p, "
literal|"vp=%p, rc=%d"
operator|,
name|bp
operator|,
name|vp
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|reiserfs_inactive
parameter_list|(
name|struct
name|vop_inactive_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"deactivating inode used %d times\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Ignore inodes related to stale file handles. */
block|if (ip->i_mode == 0) 		goto out;  out:
endif|#
directive|endif
comment|/* 	 * If we are done with the inode, reclaim it so that it can be reused 	 * immediately. 	 */
if|if
condition|(
name|ip
operator|->
name|i_mode
operator|==
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"recyling\n"
argument_list|)
expr_stmt|;
name|vrecycle
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reiserfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reclaiming inode used %d times\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* XXX Update this node (write to the disk) */
comment|/* Remove the inode from its hash chain. */
name|vfs_hash_remove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"free private data\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vp
operator|->
name|v_data
argument_list|,
name|M_REISERFSNODE
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|vnode_destroy_vobject
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Functions from linux/fs/reiserfs/inode.c  * -------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|_make_cpu_key
parameter_list|(
name|struct
name|cpu_key
modifier|*
name|key
parameter_list|,
name|int
name|version
parameter_list|,
name|uint32_t
name|dirid
parameter_list|,
name|uint32_t
name|objectid
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|key
operator|->
name|version
operator|=
name|version
expr_stmt|;
name|key
operator|->
name|on_disk_key
operator|.
name|k_dir_id
operator|=
name|dirid
expr_stmt|;
name|key
operator|->
name|on_disk_key
operator|.
name|k_objectid
operator|=
name|objectid
expr_stmt|;
name|set_cpu_key_k_offset
argument_list|(
name|key
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|set_cpu_key_k_type
argument_list|(
name|key
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|key
operator|->
name|key_length
operator|=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take base of inode_key (it comes from inode always) (dirid, objectid)  * and version from an inode, set offset and type of key  */
end_comment

begin_function
name|void
name|make_cpu_key
parameter_list|(
name|struct
name|cpu_key
modifier|*
name|key
parameter_list|,
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|_make_cpu_key
argument_list|(
name|key
argument_list|,
name|get_inode_item_key_version
argument_list|(
name|ip
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|INODE_PKEY
argument_list|(
name|ip
argument_list|)
operator|->
name|k_dir_id
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|INODE_PKEY
argument_list|(
name|ip
argument_list|)
operator|->
name|k_objectid
argument_list|)
argument_list|,
name|offset
argument_list|,
name|type
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|reiserfs_get_block
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|long
name|block
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|caddr_t
name|blk
init|=
name|NULL
decl_stmt|,
name|p
decl_stmt|;
name|struct
name|cpu_key
name|key
decl_stmt|;
comment|/* unsigned long offset; */
name|INITIALIZE_PATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|blk_bp
decl_stmt|;
name|struct
name|item_head
modifier|*
name|ih
decl_stmt|;
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
decl_stmt|;
name|int
name|blocknr
decl_stmt|,
name|chars
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|args
init|=
literal|0
decl_stmt|;
name|sbi
operator|=
name|ip
operator|->
name|i_reiserfs
expr_stmt|;
comment|/* Prepare the key to look for the 'block'-th block of file */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"prepare cpu key\n"
argument_list|)
expr_stmt|;
name|make_cpu_key
argument_list|(
operator|&
name|key
argument_list|,
name|ip
argument_list|,
operator|(
name|off_t
operator|)
name|block
operator|*
name|sbi
operator|->
name|s_blocksize
operator|+
literal|1
argument_list|,
name|TYPE_ANY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* research: */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search for position\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_for_position_by_key
argument_list|(
name|sbi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
name|POSITION_FOUND
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"position not found\n"
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (blk) 			kunmap(bh_result->b_page);
endif|#
directive|endif
comment|/* 		 * We do not return ENOENT if there is a hole but page is 		 * uptodate, because it means that there is some MMAPED data 		 * associated with it that is yet to be written to disk. 		 */
if|if
condition|(
operator|(
name|args
operator|&
name|GET_BLOCK_NO_HOLE
operator|)
comment|/*&& 		    !PageUptodate(bh_result->b_page)*/
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"position found\n"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_last_bp
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|ih
operator|=
name|get_ih
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_indirect_le_ih
argument_list|(
name|ih
argument_list|)
condition|)
block|{
name|off_t
name|xfersize
decl_stmt|;
name|uint32_t
modifier|*
name|ind_item
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|B_I_PITEM
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|)
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"item is INDIRECT\n"
argument_list|)
expr_stmt|;
name|blocknr
operator|=
name|get_block_num
argument_list|(
name|ind_item
argument_list|,
name|path
operator|.
name|pos_in_item
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"block number: %d "
literal|"(ind_item=%p, pos_in_item=%u)\n"
argument_list|,
name|blocknr
argument_list|,
name|ind_item
argument_list|,
name|path
operator|.
name|pos_in_item
argument_list|)
expr_stmt|;
name|xfersize
operator|=
name|MIN
argument_list|(
name|sbi
operator|->
name|s_blocksize
operator|-
name|offset
argument_list|,
name|ip
operator|->
name|i_size
operator|-
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|xfersize
operator|=
name|MIN
argument_list|(
name|xfersize
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocknr
condition|)
block|{
name|ret
operator|=
name|bread
argument_list|(
name|sbi
operator|->
name|s_devvp
argument_list|,
name|blocknr
operator|*
name|btodb
argument_list|(
name|sbi
operator|->
name|s_blocksize
argument_list|)
argument_list|,
name|sbi
operator|->
name|s_blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|blk_bp
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"xfersize: %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|xfersize
argument_list|)
expr_stmt|;
name|ret
operator|=
name|uiomove
argument_list|(
name|blk_bp
operator|->
name|b_data
operator|+
name|offset
argument_list|,
name|xfersize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|blk_bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We do not return ENOENT if there is a hole but 			 * page is uptodate, because it means That there 			 * is some MMAPED data associated with it that 			 * is yet to be written to disk. 			 */
if|if
condition|(
operator|(
name|args
operator|&
name|GET_BLOCK_NO_HOLE
operator|)
comment|/*&& 			    !PageUptodate(bh_result->b_page)*/
condition|)
name|ret
operator|=
operator|(
name|ENOENT
operator|)
expr_stmt|;
comment|/* Skip this hole */
name|uio
operator|->
name|uio_resid
operator|-=
name|xfersize
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|+=
name|xfersize
expr_stmt|;
block|}
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"item should be DIRECT\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Requested data are in direct item(s) */
block|if (!(args& GET_BLOCK_READ_DIRECT)) {
comment|/* 		 * We are called by bmap. FIXME: we can not map block of 		 * file when it is stored in direct item(s) 		 */
block|pathrelse(&path);
if|#
directive|if
literal|0
block|if (blk) 			kunmap(bh_result->b_page);
endif|#
directive|endif
block|return (ENOENT); 	}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * If we've got a direct item, and the buffer or page was uptodate, we 	 * don't want to pull data off disk again. Skip to the end, where we 	 * map the buffer and return 	 */
block|if (buffer_uptodate(bh_result)) { 		goto finished; 	} else
comment|/* 		 * grab_tail_page can trigger calls to reiserfs_get_block 		 * on up to date pages without any buffers. If the page 		 * is up to date, we don't want read old data off disk. 		 * Set the up to date bit on the buffer instead and jump 		 * to the end 		 */
block|if (!bh_result->b_page || PageUptodate(bh_result->b_page)) { 			set_buffer_uptodate(bh_result); 			goto finished; 		}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Read file tail into part of page */
block|offset = (cpu_key_k_offset(&key) - 1)& (PAGE_CACHE_SIZE - 1); 	fs_gen = get_generation(ip->i_reiserfs); 	copy_item_head(&tmp_ih, ih);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * We only want to kmap if we are reading the tail into the page. this 	 * is not the common case, so we don't kmap until we are sure we need 	 * to. But, this means the item might move if kmap schedules 	 */
block|if (!blk) { 		blk = (char *)kmap(bh_result->b_page); 		if (fs_changed (fs_gen, sbi)&& item_moved(&tmp_ih,&path)) 			goto research; 	} 	blk += offset; 	memset(blk, 0, sbi->s_blocksize);
endif|#
directive|endif
if|if
condition|(
operator|!
name|blk
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"allocating buffer\n"
argument_list|)
expr_stmt|;
name|blk
operator|=
name|malloc
argument_list|(
name|ip
operator|->
name|i_size
argument_list|,
name|M_REISERFSNODE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blk
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* p += offset; */
name|p
operator|=
name|blk
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|is_direct_le_ih
argument_list|(
name|ih
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BUG\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* XXX Wrong error code */
block|}
comment|/* 		 * Make sure we don't read more bytes than actually exist 		 * in the file. This can happen in odd cases where i_size 		 * isn't correct, and when direct item padding results in 		 * a few extra bytes at the end of the direct item 		 */
if|if
condition|(
operator|(
name|le_ih_k_offset
argument_list|(
name|ih
argument_list|)
operator|+
name|path
operator|.
name|pos_in_item
operator|)
operator|>
name|ip
operator|->
name|i_size
condition|)
break|break;
if|if
condition|(
operator|(
name|le_ih_k_offset
argument_list|(
name|ih
argument_list|)
operator|-
literal|1
operator|+
name|ih_item_len
argument_list|(
name|ih
argument_list|)
operator|)
operator|>
name|ip
operator|->
name|i_size
condition|)
block|{
name|chars
operator|=
name|ip
operator|->
name|i_size
operator|-
operator|(
name|le_ih_k_offset
argument_list|(
name|ih
argument_list|)
operator|-
literal|1
operator|)
operator|-
name|path
operator|.
name|pos_in_item
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|chars
operator|=
name|ih_item_len
argument_list|(
name|ih
argument_list|)
operator|-
name|path
operator|.
name|pos_in_item
expr_stmt|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"copying %d bytes\n"
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|B_I_PITEM
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|)
operator|+
name|path
operator|.
name|pos_in_item
argument_list|,
name|chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"copy done\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|chars
expr_stmt|;
if|if
condition|(
name|PATH_LAST_POSITION
argument_list|(
operator|&
name|path
argument_list|)
operator|!=
operator|(
name|B_NR_ITEMS
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
operator|)
condition|)
comment|/* 			 * We done, if read direct item is not the last 			 * item of node 			 * FIXME: we could try to check right delimiting 			 * key to see whether direct item continues in 			 * the right neighbor or rely on i_size 			 */
break|break;
comment|/* Update key to look for the next piece */
name|set_cpu_key_k_offset
argument_list|(
operator|&
name|key
argument_list|,
name|cpu_key_k_offset
argument_list|(
operator|&
name|key
argument_list|)
operator|+
name|chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_for_position_by_key
argument_list|(
name|sbi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
name|POSITION_FOUND
condition|)
comment|/* 			 * We read something from tail, even if now we got 			 * IO_ERROR 			 */
break|break;
name|bp
operator|=
name|get_last_bp
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|ih
operator|=
name|get_ih
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* finished: */
name|pathrelse
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * This buffer has valid data, but isn't valid for io. mapping it to 	 * block #0 tells the rest of reiserfs it just has a tail in it 	 */
name|ret
operator|=
name|uiomove
argument_list|(
name|blk
argument_list|,
name|ip
operator|->
name|i_size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blk
argument_list|,
name|M_REISERFSNODE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute real number of used bytes by file  * Following three functions can go away when we'll have enough space in  * stat item  */
end_comment

begin_function
specifier|static
name|int
name|real_space_diff
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|int
name|sd_size
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|off_t
name|blocksize
init|=
name|ip
operator|->
name|i_reiserfs
operator|->
name|s_blocksize
decl_stmt|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
operator|||
name|S_ISDIR
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
return|return
operator|(
name|sd_size
operator|)
return|;
comment|/* End of file is also in full block with indirect reference, so round 	 * up to the next block. 	 * 	 * There is just no way to know if the tail is actually packed on the 	 * file, so we have to assume it isn't. When we pack the tail, we add 	 * 4 bytes to pretend there really is an unformatted node pointer. */
name|bytes
operator|=
operator|(
operator|(
name|ip
operator|->
name|i_size
operator|+
operator|(
name|blocksize
operator|-
literal|1
operator|)
operator|)
operator|>>
name|ip
operator|->
name|i_reiserfs
operator|->
name|s_blocksize_bits
operator|)
operator|*
name|UNFM_P_SIZE
operator|+
name|sd_size
expr_stmt|;
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|off_t
name|to_real_used_space
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|unsigned
name|long
name|blocks
parameter_list|,
name|int
name|sd_size
parameter_list|)
block|{
if|if
condition|(
name|S_ISLNK
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
operator|||
name|S_ISDIR
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
block|{
return|return
name|ip
operator|->
name|i_size
operator|+
call|(
name|off_t
call|)
argument_list|(
name|real_space_diff
argument_list|(
name|ip
argument_list|,
name|sd_size
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|(
operator|(
name|off_t
operator|)
name|real_space_diff
argument_list|(
name|ip
argument_list|,
name|sd_size
argument_list|)
operator|)
operator|+
operator|(
operator|(
operator|(
name|off_t
operator|)
name|blocks
operator|)
operator|<<
literal|9
operator|)
return|;
block|}
end_function

begin_function
name|void
name|inode_set_bytes
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|off_t
name|bytes
parameter_list|)
block|{
name|ip
operator|->
name|i_blocks
operator|=
name|bytes
operator|>>
literal|9
expr_stmt|;
name|ip
operator|->
name|i_bytes
operator|=
name|bytes
operator|&
literal|511
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by read_locked_inode */
end_comment

begin_function
specifier|static
name|void
name|init_inode
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|struct
name|path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|item_head
modifier|*
name|ih
decl_stmt|;
name|uint32_t
name|rdev
decl_stmt|;
name|bp
operator|=
name|PATH_PLAST_BUFFER
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|ih
operator|=
name|PATH_PITEM_HEAD
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"copy the key (objectid=%d, dirid=%d)\n"
argument_list|,
name|ih
operator|->
name|ih_key
operator|.
name|k_objectid
argument_list|,
name|ih
operator|->
name|ih_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
name|copy_key
argument_list|(
name|INODE_PKEY
argument_list|(
name|ip
argument_list|)
argument_list|,
operator|&
operator|(
name|ih
operator|->
name|ih_key
operator|)
argument_list|)
expr_stmt|;
comment|/* ip->i_blksize = reiserfs_default_io_size; */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reset some inode structure members\n"
argument_list|)
expr_stmt|;
name|REISERFS_I
argument_list|(
name|ip
argument_list|)
operator|->
name|i_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|REISERFS_I(ip)->i_prealloc_block = 0; 	REISERFS_I(ip)->i_prealloc_count = 0; 	REISERFS_I(ip)->i_trans_id = 0; 	REISERFS_I(ip)->i_jl = NULL; 	REISERFS_I(ip)->i_acl_access = NULL; 	REISERFS_I(ip)->i_acl_default = NULL;
endif|#
directive|endif
if|if
condition|(
name|stat_data_v1
argument_list|(
name|ih
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs/init_inode: stat data v1\n"
argument_list|)
expr_stmt|;
name|struct
name|stat_data_v1
modifier|*
name|sd
decl_stmt|;
name|unsigned
name|long
name|blocks
decl_stmt|;
name|sd
operator|=
operator|(
expr|struct
name|stat_data_v1
operator|*
operator|)
name|B_I_PITEM
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs/init_inode: filling more members\n"
argument_list|)
expr_stmt|;
name|set_inode_item_key_version
argument_list|(
name|ip
argument_list|,
name|KEY_FORMAT_3_5
argument_list|)
expr_stmt|;
name|set_inode_sd_version
argument_list|(
name|ip
argument_list|,
name|STAT_DATA_V1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mode
operator|=
name|sd_v1_mode
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_nlink
operator|=
name|sd_v1_nlink
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_uid
operator|=
name|sd_v1_uid
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_gid
operator|=
name|sd_v1_gid
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_size
operator|=
name|sd_v1_size
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_atime
operator|.
name|tv_sec
operator|=
name|sd_v1_atime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mtime
operator|.
name|tv_sec
operator|=
name|sd_v1_mtime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_ctime
operator|.
name|tv_sec
operator|=
name|sd_v1_ctime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_atime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_ctime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_mtime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  mode  = %08x\n"
argument_list|,
name|ip
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  nlink = %d\n"
argument_list|,
name|ip
operator|->
name|i_nlink
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  owner = %d:%d\n"
argument_list|,
name|ip
operator|->
name|i_uid
argument_list|,
name|ip
operator|->
name|i_gid
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  size  = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  atime = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_atime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  mtime = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_mtime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  ctime = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_ctime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|=
name|sd_v1_blocks
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_generation
operator|=
name|le32toh
argument_list|(
name|INODE_PKEY
argument_list|(
name|ip
argument_list|)
operator|->
name|k_dir_id
argument_list|)
expr_stmt|;
name|blocks
operator|=
operator|(
name|ip
operator|->
name|i_size
operator|+
literal|511
operator|)
operator|>>
literal|9
expr_stmt|;
name|blocks
operator|=
name|_ROUND_UP
argument_list|(
name|blocks
argument_list|,
name|ip
operator|->
name|i_reiserfs
operator|->
name|s_blocksize
operator|>>
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_blocks
operator|>
name|blocks
condition|)
block|{
comment|/* 			 * There was a bug in<= 3.5.23 when i_blocks could 			 * take negative values. Starting from 3.5.17 this 			 * value could even be stored in stat data. For such 			 * files we set i_blocks based on file size. Just 2 			 * notes: this can be wrong for sparce files. On-disk 			 * value will be only updated if file's inode will 			 * ever change. 			 */
name|ip
operator|->
name|i_blocks
operator|=
name|blocks
expr_stmt|;
block|}
name|rdev
operator|=
name|sd_v1_rdev
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|REISERFS_I
argument_list|(
name|ip
argument_list|)
operator|->
name|i_first_direct_byte
operator|=
name|sd_v1_first_direct_byte
argument_list|(
name|sd
argument_list|)
expr_stmt|;
comment|/* 		 * An early bug in the quota code can give us an odd number 		 * for the block count. This is incorrect, fix it here. 		 */
if|if
condition|(
name|ip
operator|->
name|i_blocks
operator|&
literal|1
condition|)
block|{
name|ip
operator|->
name|i_blocks
operator|++
expr_stmt|;
block|}
name|inode_set_bytes
argument_list|(
name|ip
argument_list|,
name|to_real_used_space
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|i_blocks
argument_list|,
name|SD_V1_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * nopack is initially zero for v1 objects. For v2 objects, 		 * nopack is initialised from sd_attrs 		 */
name|REISERFS_I
argument_list|(
name|ip
argument_list|)
operator|->
name|i_flags
operator|&=
operator|~
name|i_nopack_mask
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"...done\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"stat data v2\n"
argument_list|)
expr_stmt|;
comment|/* 		 * New stat data found, but object may have old items 		 * (directories and symlinks) 		 */
name|struct
name|stat_data
modifier|*
name|sd
init|=
operator|(
expr|struct
name|stat_data
operator|*
operator|)
name|B_I_PITEM
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|)
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"filling more members\n"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mode
operator|=
name|sd_v2_mode
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_nlink
operator|=
name|sd_v2_nlink
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_uid
operator|=
name|sd_v2_uid
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_size
operator|=
name|sd_v2_size
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_gid
operator|=
name|sd_v2_gid
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mtime
operator|.
name|tv_sec
operator|=
name|sd_v2_mtime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_atime
operator|.
name|tv_sec
operator|=
name|sd_v2_atime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_ctime
operator|.
name|tv_sec
operator|=
name|sd_v2_ctime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_ctime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_mtime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_atime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  mode  = %08x\n"
argument_list|,
name|ip
operator|->
name|i_mode
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  nlink = %d\n"
argument_list|,
name|ip
operator|->
name|i_nlink
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  owner = %d:%d\n"
argument_list|,
name|ip
operator|->
name|i_uid
argument_list|,
name|ip
operator|->
name|i_gid
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  size  = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  atime = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_atime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  mtime = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_mtime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  ctime = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ip
operator|->
name|i_ctime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|=
name|sd_v2_blocks
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|rdev
operator|=
name|sd_v2_rdev
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  blocks = %u\n"
argument_list|,
name|ip
operator|->
name|i_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
operator|||
name|S_ISBLK
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
name|ip
operator|->
name|i_generation
operator|=
name|le32toh
argument_list|(
name|INODE_PKEY
argument_list|(
name|ip
argument_list|)
operator|->
name|k_dir_id
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|i_generation
operator|=
name|sd_v2_generation
argument_list|(
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
name|set_inode_item_key_version
argument_list|(
name|ip
argument_list|,
name|KEY_FORMAT_3_5
argument_list|)
expr_stmt|;
else|else
name|set_inode_item_key_version
argument_list|(
name|ip
argument_list|,
name|KEY_FORMAT_3_6
argument_list|)
expr_stmt|;
name|REISERFS_I
argument_list|(
name|ip
argument_list|)
operator|->
name|i_first_direct_byte
operator|=
literal|0
expr_stmt|;
name|set_inode_sd_version
argument_list|(
name|ip
argument_list|,
name|STAT_DATA_V2
argument_list|)
expr_stmt|;
name|inode_set_bytes
argument_list|(
name|ip
argument_list|,
name|to_real_used_space
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|i_blocks
argument_list|,
name|SD_V2_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Read persistent inode attributes from sd and initalise 		 * generic inode flags from them 		 */
name|REISERFS_I
argument_list|(
name|ip
argument_list|)
operator|->
name|i_attrs
operator|=
name|sd_v2_attrs
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|sd_attrs_to_i_attrs
argument_list|(
name|sd_v2_attrs
argument_list|(
name|sd
argument_list|)
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"...done\n"
argument_list|)
expr_stmt|;
block|}
name|pathrelse
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"this inode is a regular file\n"
argument_list|)
expr_stmt|;
comment|//ip->i_op =&reiserfs_file_ip_operations;
comment|//ip->i_fop =&reiserfs_file_operations;
comment|//ip->i_mapping->a_ops =&reiserfs_address_space_operations ;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"this inode is a directory\n"
argument_list|)
expr_stmt|;
comment|//ip->i_op =&reiserfs_dir_ip_operations;
comment|//ip->i_fop =&reiserfs_dir_operations;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"this inode is a symlink\n"
argument_list|)
expr_stmt|;
comment|//ip->i_op =&reiserfs_symlink_ip_operations;
comment|//ip->i_mapping->a_ops =&reiserfs_address_space_operations;
block|}
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"this inode is something unknown in "
literal|"this universe\n"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|=
literal|0
expr_stmt|;
comment|//ip->i_op =&reiserfs_special_ip_operations;
comment|//init_special_ip(ip, ip->i_mode, new_decode_dev(rdev));
block|}
block|}
end_function

begin_comment
comment|/*  * reiserfs_read_locked_inode is called to read the inode off disk, and  * it does a make_bad_inode when things go wrong. But, we need to make  * sure and clear the key in the private portion of the inode, otherwise  * a corresponding iput might try to delete whatever object the inode  * last represented.  */
end_comment

begin_function
specifier|static
name|void
name|reiserfs_make_bad_inode
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|)
block|{
name|memset
argument_list|(
name|INODE_PKEY
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|0
argument_list|,
name|KEY_SIZE
argument_list|)
expr_stmt|;
comment|//make_bad_inode(inode);
block|}
end_function

begin_function
name|void
name|reiserfs_read_locked_inode
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|struct
name|reiserfs_iget_args
modifier|*
name|args
parameter_list|)
block|{
name|INITIALIZE_PATH
argument_list|(
name|path_to_sd
argument_list|)
expr_stmt|;
name|struct
name|cpu_key
name|key
decl_stmt|;
name|unsigned
name|long
name|dirino
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|dirino
operator|=
name|args
operator|->
name|dirid
expr_stmt|;
comment|/* 	 * Set version 1, version 2 could be used too, because stat data 	 * key is the same in both versions 	 */
name|key
operator|.
name|version
operator|=
name|KEY_FORMAT_3_5
expr_stmt|;
name|key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
operator|=
name|dirino
expr_stmt|;
name|key
operator|.
name|on_disk_key
operator|.
name|k_objectid
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|key
operator|.
name|on_disk_key
operator|.
name|u
operator|.
name|k_offset_v1
operator|.
name|k_offset
operator|=
name|SD_OFFSET
expr_stmt|;
name|key
operator|.
name|on_disk_key
operator|.
name|u
operator|.
name|k_offset_v1
operator|.
name|k_uniqueness
operator|=
name|SD_UNIQUENESS
expr_stmt|;
comment|/* Look for the object's stat data */
name|retval
operator|=
name|search_item
argument_list|(
name|ip
operator|->
name|i_reiserfs
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|path_to_sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|IO_ERROR
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"I/O failure occured trying to find stat"
literal|"data %u/%u\n"
argument_list|,
name|key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
argument_list|,
name|key
operator|.
name|on_disk_key
operator|.
name|k_objectid
argument_list|)
expr_stmt|;
name|reiserfs_make_bad_inode
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|retval
operator|!=
name|ITEM_FOUND
condition|)
block|{
comment|/* 		 * A stale NFS handle can trigger this without it being 		 * an error 		 */
name|reiserfs_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"item not found (objectid=%u, dirid=%u)\n"
argument_list|,
name|key
operator|.
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
operator|&
name|path_to_sd
argument_list|)
expr_stmt|;
name|reiserfs_make_bad_inode
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_nlink
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|init_inode
argument_list|(
name|ip
argument_list|,
operator|&
name|path_to_sd
argument_list|)
expr_stmt|;
comment|/* 	 * It is possible that knfsd is trying to access inode of a file 	 * that is being removed from the disk by some other thread. As 	 * we update sd on unlink all that is required is to check for 	 * nlink here. This bug was first found by Sizif when debugging 	 * SquidNG/Butterfly, forgotten, and found again after Philippe 	 * Gramoulle<philippe.gramoulle@mmania.com> reproduced it. 	 *  	 * More logical fix would require changes in fs/inode.c:iput() to 	 * remove inode from hash-table _after_ fs cleaned disk stuff up and 	 * in iget() to return NULL if I_FREEING inode is found in hash-table. 	 */
comment|/* 	 * Currently there is one place where it's ok to meet inode with 	 * nlink == 0: processing of open-unlinked and half-truncated files 	 * during mount (fs/reiserfs/super.c:finish_unfinished()). 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_nlink
operator|==
literal|0
operator|)
operator|&&
operator|!
name|REISERFS_SB
argument_list|(
name|ip
operator|->
name|i_reiserfs
argument_list|)
operator|->
name|s_is_unlinked_ok
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dead inode read from disk. This is "
literal|"likely to be race with knfsd. Ignore"
argument_list|)
expr_stmt|;
name|reiserfs_make_bad_inode
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* Init inode should be relsing */
name|reiserfs_check_path
argument_list|(
operator|&
name|path_to_sd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|reiserfs_iget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
specifier|const
name|struct
name|cpu_key
modifier|*
name|key
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|reiserfs_mount
modifier|*
name|rmp
decl_stmt|;
name|struct
name|reiserfs_iget_args
name|args
decl_stmt|;
comment|//restart:
comment|/* Check if the inode cache contains it */
comment|// XXX LK_EXCLUSIVE ?
name|flags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|mp
argument_list|,
name|key
operator|->
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|flags
argument_list|,
name|td
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|vpp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rmp
operator|=
name|VFSTOREISERFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dev
operator|=
name|rmp
operator|->
name|rm_dev
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"malloc(struct reiserfs_node)\n"
argument_list|)
expr_stmt|;
name|ip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reiserfs_node
argument_list|)
argument_list|,
name|M_REISERFSNODE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Allocate a new vnode/inode. */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"getnewvnode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"reiserfs"
argument_list|,
name|mp
argument_list|,
operator|&
name|reiserfs_vnodeops
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ip
argument_list|,
name|M_REISERFSNODE
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"getnewvnode FAILED\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|args
operator|.
name|dirid
operator|=
name|key
operator|->
name|on_disk_key
operator|.
name|k_dir_id
expr_stmt|;
name|args
operator|.
name|objectid
operator|=
name|key
operator|->
name|on_disk_key
operator|.
name|k_objectid
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"filling *ip\n"
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_vnode
operator|=
name|vp
expr_stmt|;
name|ip
operator|->
name|i_dev
operator|=
name|dev
expr_stmt|;
name|ip
operator|->
name|i_number
operator|=
name|args
operator|.
name|objectid
expr_stmt|;
name|ip
operator|->
name|i_ino
operator|=
name|args
operator|.
name|dirid
expr_stmt|;
name|ip
operator|->
name|i_reiserfs
operator|=
name|rmp
operator|->
name|rm_reiserfs
expr_stmt|;
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_ops
operator|=
operator|&
name|reiserfs_vnbufops
expr_stmt|;
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_private
operator|=
name|vp
expr_stmt|;
comment|/* If this is the root node, set the VV_ROOT flag */
if|if
condition|(
name|ip
operator|->
name|i_number
operator|==
name|REISERFS_ROOT_OBJECTID
operator|&&
name|ip
operator|->
name|i_ino
operator|==
name|REISERFS_ROOT_PARENT_OBJECTID
condition|)
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
if|#
directive|if
literal|0
block|if (VOP_LOCK(vp, LK_EXCLUSIVE) != 0) 		panic("reiserfs/iget: unexpected lock failure");
comment|/* 	 * Exclusively lock the vnode before adding to hash. Note, that we 	 * must not release nor downgrade the lock (despite flags argument 	 * says) till it is fully initialized. 	 */
block|lockmgr(vp->v_vnlock, LK_EXCLUSIVE, (struct mtx *)0);
endif|#
directive|endif
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ip
argument_list|,
name|M_REISERFSNODE
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"insmntque FAILED\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|vfs_hash_insert
argument_list|(
name|vp
argument_list|,
name|key
operator|->
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|flags
argument_list|,
name|td
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|vpp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read the inode */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"call reiserfs_read_locked_inode ("
literal|"objectid=%d,dirid=%d)\n"
argument_list|,
name|args
operator|.
name|objectid
argument_list|,
name|args
operator|.
name|dirid
argument_list|)
expr_stmt|;
name|reiserfs_read_locked_inode
argument_list|(
name|ip
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_devvp
operator|=
name|rmp
operator|->
name|rm_devvp
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
operator|=
name|IFTOVT
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
block|{
case|case
name|VBLK
case|:
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"vnode type VBLK\n"
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_op
operator|=
operator|&
name|reiserfs_specops
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case VCHR: 		reiserfs_log(LOG_DEBUG, "vnode type VCHR\n"); 		vp->v_op =&reiserfs_specops; 		vp = addaliasu(vp, ip->i_rdev); 		ip->i_vnode = vp; 		break; 	case VFIFO: 		reiserfs_log(LOG_DEBUG, "vnode type VFIFO\n"); 		vp->v_op = reiserfs_fifoop_p; 		break;
endif|#
directive|endif
default|default:
break|break;
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sd_attrs_to_i_attrs
parameter_list|(
name|uint16_t
name|sd_attrs
parameter_list|,
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|)
block|{
if|if
condition|(
name|reiserfs_attrs
argument_list|(
name|ip
operator|->
name|i_reiserfs
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (sd_attrs& REISERFS_SYNC_FL) 			ip->i_flags |= S_SYNC; 		else 			ip->i_flags&= ~S_SYNC;
endif|#
directive|endif
if|if
condition|(
name|sd_attrs
operator|&
name|REISERFS_IMMUTABLE_FL
condition|)
name|ip
operator|->
name|i_flags
operator||=
name|IMMUTABLE
expr_stmt|;
else|else
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|IMMUTABLE
expr_stmt|;
if|if
condition|(
name|sd_attrs
operator|&
name|REISERFS_APPEND_FL
condition|)
name|ip
operator|->
name|i_flags
operator||=
name|APPEND
expr_stmt|;
else|else
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|APPEND
expr_stmt|;
if|#
directive|if
literal|0
block|if (sd_attrs& REISERFS_NOATIME_FL) 			ip->i_flags |= S_NOATIME; 		else 			ip->i_flags&= ~S_NOATIME; 		if (sd_attrs& REISERFS_NOTAIL_FL) 			REISERFS_I(ip)->i_flags |= i_nopack_mask; 		else 			REISERFS_I(ip)->i_flags&= ~i_nopack_mask;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|i_attrs_to_sd_attrs
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|ip
parameter_list|,
name|uint16_t
modifier|*
name|sd_attrs
parameter_list|)
block|{
if|if
condition|(
name|reiserfs_attrs
argument_list|(
name|ip
operator|->
name|i_reiserfs
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (ip->i_flags& S_SYNC) 			*sd_attrs |= REISERFS_SYNC_FL; 		else 			*sd_attrs&= ~REISERFS_SYNC_FL;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|i_flags
operator|&
name|IMMUTABLE
condition|)
operator|*
name|sd_attrs
operator||=
name|REISERFS_IMMUTABLE_FL
expr_stmt|;
else|else
operator|*
name|sd_attrs
operator|&=
operator|~
name|REISERFS_IMMUTABLE_FL
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_flags
operator|&
name|APPEND
condition|)
operator|*
name|sd_attrs
operator||=
name|REISERFS_APPEND_FL
expr_stmt|;
else|else
operator|*
name|sd_attrs
operator|&=
operator|~
name|REISERFS_APPEND_FL
expr_stmt|;
if|#
directive|if
literal|0
block|if (ip->i_flags& S_NOATIME) 			*sd_attrs |= REISERFS_NOATIME_FL; 		else 			*sd_attrs&= ~REISERFS_NOATIME_FL; 		if (REISERFS_I(ip)->i_flags& i_nopack_mask) 			*sd_attrs |= REISERFS_NOTAIL_FL; 		else 			*sd_attrs&= ~REISERFS_NOTAIL_FL;
endif|#
directive|endif
block|}
block|}
end_function

end_unit

