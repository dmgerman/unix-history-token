begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2000 Hans Reiser  * See README for licensing and copyright details  *   * Ported to FreeBSD by Jean-Sébastien Pédron<jspedron@club-internet.fr>  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<gnu/fs/reiserfs/reiserfs_fs.h>
end_include

begin_comment
comment|/* Minimal possible key. It is never in the tree. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|key
name|MIN_KEY
init|=
block|{
literal|0
block|,
literal|0
block|,
block|{
block|{
literal|0
block|,
literal|0
block|}
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximal possible key. It is never in the tree. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|key
name|MAX_KEY
init|=
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|,
block|{
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|}
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Does the buffer contain a disk block which is in the tree. */
end_comment

begin_function
specifier|inline
name|int
name|B_IS_IN_TREE
parameter_list|(
specifier|const
name|struct
name|buf
modifier|*
name|p_s_bp
parameter_list|)
block|{
return|return
operator|(
name|B_LEVEL
argument_list|(
name|p_s_bp
argument_list|)
operator|!=
name|FREE_LEVEL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* To gets item head in le form */
end_comment

begin_function
specifier|inline
name|void
name|copy_item_head
parameter_list|(
name|struct
name|item_head
modifier|*
name|p_v_to
parameter_list|,
specifier|const
name|struct
name|item_head
modifier|*
name|p_v_from
parameter_list|)
block|{
name|memcpy
argument_list|(
name|p_v_to
argument_list|,
name|p_v_from
argument_list|,
name|IH_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * k1 is pointer to on-disk structure which is stored in little-endian  * form. k2 is pointer to cpu variable. For key of items of the same  * object this returns 0.  * Returns: -1 if key1< key2, 0 if key1 == key2 or 1 if key1> key2  */
end_comment

begin_comment
comment|/*inline*/
end_comment

begin_function
name|int
name|comp_short_keys
parameter_list|(
specifier|const
name|struct
name|key
modifier|*
name|le_key
parameter_list|,
specifier|const
name|struct
name|cpu_key
modifier|*
name|cpu_key
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|p_s_le_u32
decl_stmt|,
modifier|*
name|p_s_cpu_u32
decl_stmt|;
name|int
name|n_key_length
init|=
name|REISERFS_SHORT_KEY_LEN
decl_stmt|;
name|p_s_le_u32
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|le_key
expr_stmt|;
name|p_s_cpu_u32
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|&
name|cpu_key
operator|->
name|on_disk_key
expr_stmt|;
for|for
control|(
init|;
name|n_key_length
operator|--
condition|;
operator|++
name|p_s_le_u32
operator|,
operator|++
name|p_s_cpu_u32
control|)
block|{
if|if
condition|(
name|le32toh
argument_list|(
operator|*
name|p_s_le_u32
argument_list|)
operator|<
operator|*
name|p_s_cpu_u32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|le32toh
argument_list|(
operator|*
name|p_s_le_u32
argument_list|)
operator|>
operator|*
name|p_s_cpu_u32
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * k1 is pointer to on-disk structure which is stored in little-endian  * form. k2 is pointer to cpu variable. Compare keys using all 4 key  * fields.  * Returns: -1 if key1< key2, 0 if key1 = key2 or 1 if key1> key2  */
end_comment

begin_comment
comment|/*inline*/
end_comment

begin_function
name|int
name|comp_keys
parameter_list|(
specifier|const
name|struct
name|key
modifier|*
name|le_key
parameter_list|,
specifier|const
name|struct
name|cpu_key
modifier|*
name|cpu_key
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|comp_short_keys
argument_list|(
name|le_key
argument_list|,
name|cpu_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
return|;
if|if
condition|(
name|le_key_k_offset
argument_list|(
name|le_key_version
argument_list|(
name|le_key
argument_list|)
argument_list|,
name|le_key
argument_list|)
operator|<
name|cpu_key_k_offset
argument_list|(
name|cpu_key
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|le_key_k_offset
argument_list|(
name|le_key_version
argument_list|(
name|le_key
argument_list|)
argument_list|,
name|le_key
argument_list|)
operator|>
name|cpu_key_k_offset
argument_list|(
name|cpu_key
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cpu_key
operator|->
name|key_length
operator|==
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* This part is needed only when tail conversion is in progress */
if|if
condition|(
name|le_key_k_type
argument_list|(
name|le_key_version
argument_list|(
name|le_key
argument_list|)
argument_list|,
name|le_key
argument_list|)
operator|<
name|cpu_key_k_type
argument_list|(
name|cpu_key
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|le_key_k_type
argument_list|(
name|le_key_version
argument_list|(
name|le_key
argument_list|)
argument_list|,
name|le_key
argument_list|)
operator|>
name|cpu_key_k_type
argument_list|(
name|cpu_key
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release all buffers in the path. */
end_comment

begin_function
name|void
name|pathrelse
parameter_list|(
name|struct
name|path
modifier|*
name|p_s_search_path
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|n_path_offset
init|=
name|p_s_search_path
operator|->
name|path_length
decl_stmt|;
while|while
condition|(
name|n_path_offset
operator|>
name|ILLEGAL_PATH_ELEMENT_OFFSET
condition|)
block|{
name|bp
operator|=
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_search_path
argument_list|,
name|n_path_offset
operator|--
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|M_REISERFSPATH
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|,
name|M_REISERFSPATH
argument_list|)
expr_stmt|;
block|}
name|p_s_search_path
operator|->
name|path_length
operator|=
name|ILLEGAL_PATH_ELEMENT_OFFSET
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This does not say which one is bigger, it only returns 1 if keys  * are not equal, 0 otherwise  */
end_comment

begin_function
specifier|inline
name|int
name|comp_le_keys
parameter_list|(
specifier|const
name|struct
name|key
modifier|*
name|k1
parameter_list|,
specifier|const
name|struct
name|key
modifier|*
name|k2
parameter_list|)
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|k1
argument_list|,
name|k2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Binary search toolkit function. Search for an item in the array by  * the item key.  * Returns: 1 if found,  0 if not found;  *          *p_n_pos = number of the searched element if found, else the  *          number of the first element that is larger than p_v_key.  */
end_comment

begin_comment
comment|/*  * For those not familiar with binary search: n_lbound is the leftmost  * item that it could be, n_rbound the rightmost item that it could be.  * We examine the item halfway between n_lbound and n_rbound, and that  * tells us either that we can increase n_lbound, or decrease n_rbound,  * or that we have found it, or if n_lbound<= n_rbound that there are  * no possible items, and we have not found it. With each examination we  * cut the number of possible items it could be by one more than half  * rounded down, or we find it.  */
end_comment

begin_function
specifier|inline
name|int
name|bin_search
parameter_list|(
specifier|const
name|void
modifier|*
name|p_v_key
parameter_list|,
comment|/* Key to search for. */
specifier|const
name|void
modifier|*
name|p_v_base
parameter_list|,
comment|/* First item in the array. */
name|int
name|p_n_num
parameter_list|,
comment|/* Number of items in the array. */
name|int
name|p_n_width
parameter_list|,
comment|/* Item size in the array. searched. Lest the 			     reader be confused, note that this is crafted 			     as a general function, and when it is applied 			     specifically to the array of item headers in 			     a node, p_n_width is actually the item header 			     size not the item size. */
name|int
modifier|*
name|p_n_pos
parameter_list|)
comment|/* Number of the searched for element. */
block|{
name|int
name|n_rbound
decl_stmt|,
name|n_lbound
decl_stmt|,
name|n_j
decl_stmt|;
for|for
control|(
name|n_j
operator|=
operator|(
operator|(
name|n_rbound
operator|=
name|p_n_num
operator|-
literal|1
operator|)
operator|+
operator|(
name|n_lbound
operator|=
literal|0
operator|)
operator|)
operator|/
literal|2
init|;
name|n_lbound
operator|<=
name|n_rbound
condition|;
name|n_j
operator|=
operator|(
name|n_rbound
operator|+
name|n_lbound
operator|)
operator|/
literal|2
control|)
block|{
switch|switch
condition|(
name|COMP_KEYS
argument_list|(
operator|(
specifier|const
expr|struct
name|key
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p_v_base
operator|+
name|n_j
operator|*
name|p_n_width
operator|)
argument_list|,
operator|(
specifier|const
expr|struct
name|cpu_key
operator|*
operator|)
name|p_v_key
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|n_lbound
operator|=
name|n_j
operator|+
literal|1
expr_stmt|;
continue|continue;
case|case
literal|1
case|:
name|n_rbound
operator|=
name|n_j
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|0
case|:
operator|*
name|p_n_pos
operator|=
name|n_j
expr_stmt|;
return|return
operator|(
name|ITEM_FOUND
operator|)
return|;
comment|/* Key found in the array. */
block|}
block|}
comment|/* 	 * bin_search did not find given key, it returns position of key, 	 * that is minimal and greater than the given one. 	 */
operator|*
name|p_n_pos
operator|=
name|n_lbound
expr_stmt|;
return|return
operator|(
name|ITEM_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get delimiting key of the buffer by looking for it in the buffers in  * the path, starting from the bottom of the path, and going upwards. We  * must check the path's validity at each step. If the key is not in the  * path, there is no delimiting key in the tree (buffer is first or last  * buffer in tree), and in this case we return a special key, either  * MIN_KEY or MAX_KEY.  */
end_comment

begin_function
specifier|inline
specifier|const
name|struct
name|key
modifier|*
name|get_lkey
parameter_list|(
specifier|const
name|struct
name|path
modifier|*
name|p_s_chk_path
parameter_list|,
specifier|const
name|struct
name|reiserfs_sb_info
modifier|*
name|p_s_sbi
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|p_s_parent
decl_stmt|;
name|int
name|n_position
decl_stmt|,
name|n_path_offset
init|=
name|p_s_chk_path
operator|->
name|path_length
decl_stmt|;
comment|/* While not higher in path than first element. */
while|while
condition|(
name|n_path_offset
operator|--
operator|>
name|FIRST_PATH_ELEMENT_OFFSET
condition|)
block|{
comment|/* Parent at the path is not in the tree now. */
if|if
condition|(
operator|!
name|B_IS_IN_TREE
argument_list|(
name|p_s_parent
operator|=
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_chk_path
argument_list|,
name|n_path_offset
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|&
name|MAX_KEY
operator|)
return|;
comment|/* Check whether position in the parent is correct. */
if|if
condition|(
operator|(
name|n_position
operator|=
name|PATH_OFFSET_POSITION
argument_list|(
name|p_s_chk_path
argument_list|,
name|n_path_offset
argument_list|)
operator|)
operator|>
name|B_NR_ITEMS
argument_list|(
name|p_s_parent
argument_list|)
condition|)
return|return
operator|(
operator|&
name|MAX_KEY
operator|)
return|;
comment|/* 		 * Check whether parent at the path really points to 		 * the child. 		 */
if|if
condition|(
name|B_N_CHILD_NUM
argument_list|(
name|p_s_parent
argument_list|,
name|n_position
argument_list|)
operator|!=
operator|(
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_chk_path
argument_list|,
name|n_path_offset
operator|+
literal|1
argument_list|)
operator|->
name|b_blkno
operator|/
name|btodb
argument_list|(
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|&
name|MAX_KEY
operator|)
return|;
comment|/* 		 * Return delimiting key if position in the parent is not 		 * equal to zero. 		 */
if|if
condition|(
name|n_position
condition|)
return|return
operator|(
name|B_N_PDELIM_KEY
argument_list|(
name|p_s_parent
argument_list|,
name|n_position
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
comment|/* Return MIN_KEY if we are in the root of the buffer tree. */
if|if
condition|(
operator|(
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_chk_path
argument_list|,
name|FIRST_PATH_ELEMENT_OFFSET
argument_list|)
operator|->
name|b_blkno
operator|/
name|btodb
argument_list|(
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|)
operator|)
operator|==
name|SB_ROOT_BLOCK
argument_list|(
name|p_s_sbi
argument_list|)
condition|)
return|return
operator|(
operator|&
name|MIN_KEY
operator|)
return|;
return|return
operator|(
operator|&
name|MAX_KEY
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get delimiting key of the buffer at the path and its right neighbor. */
end_comment

begin_function
specifier|inline
specifier|const
name|struct
name|key
modifier|*
name|get_rkey
parameter_list|(
specifier|const
name|struct
name|path
modifier|*
name|p_s_chk_path
parameter_list|,
specifier|const
name|struct
name|reiserfs_sb_info
modifier|*
name|p_s_sbi
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|p_s_parent
decl_stmt|;
name|int
name|n_position
decl_stmt|,
name|n_path_offset
init|=
name|p_s_chk_path
operator|->
name|path_length
decl_stmt|;
while|while
condition|(
name|n_path_offset
operator|--
operator|>
name|FIRST_PATH_ELEMENT_OFFSET
condition|)
block|{
comment|/* Parent at the path is not in the tree now. */
if|if
condition|(
operator|!
name|B_IS_IN_TREE
argument_list|(
name|p_s_parent
operator|=
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_chk_path
argument_list|,
name|n_path_offset
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|&
name|MIN_KEY
operator|)
return|;
comment|/* Check whether position in the parent is correct. */
if|if
condition|(
operator|(
name|n_position
operator|=
name|PATH_OFFSET_POSITION
argument_list|(
name|p_s_chk_path
argument_list|,
name|n_path_offset
argument_list|)
operator|)
operator|>
name|B_NR_ITEMS
argument_list|(
name|p_s_parent
argument_list|)
condition|)
return|return
operator|(
operator|&
name|MIN_KEY
operator|)
return|;
comment|/* 		 * Check whether parent at the path really points to the 		 * child. 		 */
if|if
condition|(
name|B_N_CHILD_NUM
argument_list|(
name|p_s_parent
argument_list|,
name|n_position
argument_list|)
operator|!=
operator|(
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_chk_path
argument_list|,
name|n_path_offset
operator|+
literal|1
argument_list|)
operator|->
name|b_blkno
operator|/
name|btodb
argument_list|(
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|&
name|MIN_KEY
operator|)
return|;
comment|/* 		 * Return delimiting key if position in the parent is not 		 * the last one. 		 */
if|if
condition|(
name|n_position
operator|!=
name|B_NR_ITEMS
argument_list|(
name|p_s_parent
argument_list|)
condition|)
return|return
operator|(
name|B_N_PDELIM_KEY
argument_list|(
name|p_s_parent
argument_list|,
name|n_position
argument_list|)
operator|)
return|;
block|}
comment|/* Return MAX_KEY if we are in the root of the buffer tree. */
if|if
condition|(
operator|(
name|PATH_OFFSET_PBUFFER
argument_list|(
name|p_s_chk_path
argument_list|,
name|FIRST_PATH_ELEMENT_OFFSET
argument_list|)
operator|->
name|b_blkno
operator|/
name|btodb
argument_list|(
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|)
operator|)
operator|==
name|SB_ROOT_BLOCK
argument_list|(
name|p_s_sbi
argument_list|)
condition|)
return|return
operator|(
operator|&
name|MAX_KEY
operator|)
return|;
return|return
operator|(
operator|&
name|MIN_KEY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reiserfs_check_path
parameter_list|(
name|struct
name|path
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|path_length
operator|!=
name|ILLEGAL_PATH_ELEMENT_OFFSET
condition|)
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"path not properly relsed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether a key is contained in the tree rooted from a buffer at  * a path. This works by looking at the left and right delimiting keys  * for the buffer in the last path_element in the path. These delimiting  * keys are stored at least one level above that buffer in the tree.  * If the buffer is the first or last node in the tree order then one  * of the delimiting keys may be absent, and in this case get_lkey and  * get_rkey return a special key which is MIN_KEY or MAX_KEY.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|key_in_buffer
parameter_list|(
name|struct
name|path
modifier|*
name|p_s_chk_path
parameter_list|,
comment|/* Path which should be checked. */
specifier|const
name|struct
name|cpu_key
modifier|*
name|p_s_key
parameter_list|,
comment|/* Key which should be checked. */
name|struct
name|reiserfs_sb_info
modifier|*
name|p_s_sbi
parameter_list|)
comment|/* Super block pointer. */
block|{
if|if
condition|(
name|COMP_KEYS
argument_list|(
name|get_lkey
argument_list|(
name|p_s_chk_path
argument_list|,
name|p_s_sbi
argument_list|)
argument_list|,
name|p_s_key
argument_list|)
operator|==
literal|1
condition|)
comment|/* left delimiting key is bigger, that the key we look for */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|COMP_KEYS
argument_list|(
name|get_rkey
argument_list|(
name|p_s_chk_path
argument_list|,
name|p_s_sbi
argument_list|)
argument_list|,
name|p_s_key
argument_list|)
operator|!=
literal|1
condition|)
comment|/* p_s_key must be less than right delimitiing key */
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX Il ne semble pas y avoir de compteur de référence dans struct buf */
end_comment

begin_endif
unit|inline void decrement_bcount(struct buf *p_s_bp) {  	if (p_s_bp) { 		if (atomic_read(&(p_s_bp->b_count))) { 			put_bh(p_s_bp); 			return; 		} 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decrement b_count field of the all buffers in the path. */
end_comment

begin_function
name|void
name|decrement_counters_in_path
parameter_list|(
name|struct
name|path
modifier|*
name|p_s_search_path
parameter_list|)
block|{
name|pathrelse
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|int n_path_offset = p_s_search_path->path_length;  	while (n_path_offset> ILLEGAL_PATH_ELEMENT_OFFSET) { 		struct buf *bp;  		bp = PATH_OFFSET_PBUFFER(p_s_search_path, n_path_offset--); 		decrement_bcount(bp); 	}  	p_s_search_path->path_length = ILLEGAL_PATH_ELEMENT_OFFSET;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|is_leaf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|item_head
modifier|*
name|ih
decl_stmt|;
name|struct
name|block_head
modifier|*
name|blkh
decl_stmt|;
name|int
name|used_space
decl_stmt|,
name|prev_location
decl_stmt|,
name|i
decl_stmt|,
name|nr
decl_stmt|;
name|blkh
operator|=
operator|(
expr|struct
name|block_head
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|blkh_level
argument_list|(
name|blkh
argument_list|)
operator|!=
name|DISK_LEAF_NODE_LEVEL
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"this should be caught earlier"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nr
operator|=
name|blkh_nr_item
argument_list|(
name|blkh
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|1
operator|||
name|nr
operator|>
operator|(
operator|(
name|blocksize
operator|-
name|BLKH_SIZE
operator|)
operator|/
operator|(
name|IH_SIZE
operator|+
name|MIN_ITEM_LEN
operator|)
operator|)
condition|)
block|{
comment|/* Item number is too big or too small */
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nr_item seems wrong\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ih
operator|=
operator|(
expr|struct
name|item_head
operator|*
operator|)
operator|(
name|buf
operator|+
name|BLKH_SIZE
operator|)
operator|+
name|nr
operator|-
literal|1
expr_stmt|;
name|used_space
operator|=
name|BLKH_SIZE
operator|+
name|IH_SIZE
operator|*
name|nr
operator|+
operator|(
name|blocksize
operator|-
name|ih_location
argument_list|(
name|ih
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|used_space
operator|!=
name|blocksize
operator|-
name|blkh_free_space
argument_list|(
name|blkh
argument_list|)
condition|)
block|{
comment|/* 		 * Free space does not match to calculated amount of 		 * use space 		 */
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"free space seems wrong\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* FIXME: it is_leaf will hit performance too much - we may have 	 * return 1 here */
comment|/* Check tables of item heads */
name|ih
operator|=
operator|(
expr|struct
name|item_head
operator|*
operator|)
operator|(
name|buf
operator|+
name|BLKH_SIZE
operator|)
expr_stmt|;
name|prev_location
operator|=
name|blocksize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
operator|,
name|ih
operator|++
control|)
block|{
if|if
condition|(
name|le_ih_k_type
argument_list|(
name|ih
argument_list|)
operator|==
name|TYPE_ANY
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wrong item type for item\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ih_location
argument_list|(
name|ih
argument_list|)
operator|>=
name|blocksize
operator|||
name|ih_location
argument_list|(
name|ih
argument_list|)
operator|<
name|IH_SIZE
operator|*
name|nr
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"item location seems wrong\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ih_item_len
argument_list|(
name|ih
argument_list|)
operator|<
literal|1
operator|||
name|ih_item_len
argument_list|(
name|ih
argument_list|)
operator|>
name|MAX_ITEM_LEN
argument_list|(
name|blocksize
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"item length seems wrong\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|prev_location
operator|-
name|ih_location
argument_list|(
name|ih
argument_list|)
operator|!=
name|ih_item_len
argument_list|(
name|ih
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"item location seems wrong (second one)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|prev_location
operator|=
name|ih_location
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
comment|/* One may imagine much more checks */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if buf looks like an internal node, 0 otherwise */
end_comment

begin_function
specifier|static
name|int
name|is_internal
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|nr
decl_stmt|,
name|used_space
decl_stmt|;
name|struct
name|block_head
modifier|*
name|blkh
decl_stmt|;
name|blkh
operator|=
operator|(
expr|struct
name|block_head
operator|*
operator|)
name|buf
expr_stmt|;
name|nr
operator|=
name|blkh_level
argument_list|(
name|blkh
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|<=
name|DISK_LEAF_NODE_LEVEL
operator|||
name|nr
operator|>
name|MAX_HEIGHT
condition|)
block|{
comment|/* This level is not possible for internal nodes */
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"this should be caught earlier\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nr
operator|=
name|blkh_nr_item
argument_list|(
name|blkh
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|>
operator|(
name|blocksize
operator|-
name|BLKH_SIZE
operator|-
name|DC_SIZE
operator|)
operator|/
operator|(
name|KEY_SIZE
operator|+
name|DC_SIZE
operator|)
condition|)
block|{
comment|/* 		 * For internal which is not root we might check min 		 * number of keys 		 */
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"number of key seems wrong\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|used_space
operator|=
name|BLKH_SIZE
operator|+
name|KEY_SIZE
operator|*
name|nr
operator|+
name|DC_SIZE
operator|*
operator|(
name|nr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|used_space
operator|!=
name|blocksize
operator|-
name|blkh_free_space
argument_list|(
name|blkh
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"is_internal: free space seems wrong\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* One may imagine much more checks */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure that bh contains formatted node of reiserfs tree of  * 'level'-th level  */
end_comment

begin_function
specifier|static
name|int
name|is_tree_node
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|B_LEVEL
argument_list|(
name|bp
argument_list|)
operator|!=
name|level
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"node level (%d) doesn't match to the "
literal|"expected one (%d)\n"
argument_list|,
name|B_LEVEL
argument_list|(
name|bp
argument_list|)
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|level
operator|==
name|DISK_LEAF_NODE_LEVEL
condition|)
return|return
operator|(
name|is_leaf
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
argument_list|)
operator|)
return|;
return|return
operator|(
name|is_internal
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|search_by_key
parameter_list|(
name|struct
name|reiserfs_sb_info
modifier|*
name|p_s_sbi
parameter_list|,
specifier|const
name|struct
name|cpu_key
modifier|*
name|p_s_key
parameter_list|,
comment|/* Key to search. */
name|struct
name|path
modifier|*
name|p_s_search_path
parameter_list|,
comment|/* This structure was allocated and 				       initialized by the calling function. 				       It is filled up by this function. */
name|int
name|n_stop_level
parameter_list|)
comment|/* How far down the tree to search. To 				       stop at leaf level - set to 				       DISK_LEAF_NODE_LEVEL */
block|{
name|int
name|error
decl_stmt|;
name|int
name|n_node_level
decl_stmt|,
name|n_retval
decl_stmt|;
name|int
name|n_block_number
decl_stmt|,
name|expected_level
decl_stmt|,
name|fs_gen
decl_stmt|;
name|struct
name|path_element
modifier|*
name|p_s_last_element
decl_stmt|;
name|struct
name|buf
modifier|*
name|p_s_bp
decl_stmt|,
modifier|*
name|tmp_bp
decl_stmt|;
comment|/* 	 * As we add each node to a path we increase its count. This means that 	 * we must be careful to release all nodes in a path before we either 	 * discard the path struct or re-use the path struct, as we do here. 	 */
name|decrement_counters_in_path
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
comment|/* 	 * With each iteration of this loop we search through the items in the 	 * current node, and calculate the next current node(next path element) 	 * for the next iteration of this loop... 	 */
name|n_block_number
operator|=
name|SB_ROOT_BLOCK
argument_list|(
name|p_s_sbi
argument_list|)
expr_stmt|;
name|expected_level
operator|=
operator|-
literal|1
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"root block: #%d\n"
argument_list|,
name|n_block_number
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Prep path to have another element added to it. */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"path element #%d\n"
argument_list|,
name|p_s_search_path
operator|->
name|path_length
argument_list|)
expr_stmt|;
name|p_s_last_element
operator|=
name|PATH_OFFSET_PELEMENT
argument_list|(
name|p_s_search_path
argument_list|,
operator|++
name|p_s_search_path
operator|->
name|path_length
argument_list|)
expr_stmt|;
name|fs_gen
operator|=
name|get_generation
argument_list|(
name|p_s_sbi
argument_list|)
expr_stmt|;
comment|/* 		 * Read the next tree node, and set the last element in the 		 * path to have a pointer to it. 		 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reading block #%d\n"
argument_list|,
name|n_block_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|p_s_sbi
operator|->
name|s_devvp
argument_list|,
name|n_block_number
operator|*
name|btodb
argument_list|(
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|)
argument_list|,
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|tmp_bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"error reading block\n"
argument_list|)
expr_stmt|;
name|p_s_search_path
operator|->
name|path_length
operator|--
expr_stmt|;
name|pathrelse
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_ERROR
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"blkno = %ju, lblkno = %ju\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|tmp_bp
operator|->
name|b_blkno
argument_list|,
operator|(
name|intmax_t
operator|)
name|tmp_bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
comment|/* 		 * As i didn't found a way to handle the lock correctly, 		 * i copy the data into a fake buffer 		 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"allocating p_s_bp\n"
argument_list|)
expr_stmt|;
name|p_s_bp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|p_s_bp
argument_list|,
name|M_REISERFSPATH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_s_bp
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"error allocating memory\n"
argument_list|)
expr_stmt|;
name|p_s_search_path
operator|->
name|path_length
operator|--
expr_stmt|;
name|pathrelse
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|tmp_bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_ERROR
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"copying struct buf\n"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmp_bp
argument_list|,
name|p_s_bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"allocating p_s_bp->b_data\n"
argument_list|)
expr_stmt|;
name|p_s_bp
operator|->
name|b_data
operator|=
name|malloc
argument_list|(
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|,
name|M_REISERFSPATH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_s_bp
operator|->
name|b_data
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"error allocating memory\n"
argument_list|)
expr_stmt|;
name|p_s_search_path
operator|->
name|path_length
operator|--
expr_stmt|;
name|pathrelse
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_s_bp
argument_list|,
name|M_REISERFSPATH
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|tmp_bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_ERROR
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"copying buffer data\n"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmp_bp
operator|->
name|b_data
argument_list|,
name|p_s_bp
operator|->
name|b_data
argument_list|,
name|p_s_sbi
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|tmp_bp
argument_list|)
expr_stmt|;
name|tmp_bp
operator|=
name|NULL
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"...done\n"
argument_list|)
expr_stmt|;
name|p_s_last_element
operator|->
name|pe_buffer
operator|=
name|p_s_bp
expr_stmt|;
if|if
condition|(
name|expected_level
operator|==
operator|-
literal|1
condition|)
name|expected_level
operator|=
name|SB_TREE_HEIGHT
argument_list|(
name|p_s_sbi
argument_list|)
expr_stmt|;
name|expected_level
operator|--
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"expected level: %d (%d)\n"
argument_list|,
name|expected_level
argument_list|,
name|SB_TREE_HEIGHT
argument_list|(
name|p_s_sbi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 		 * It is possible that schedule occurred. We must check 		 * whether the key to search is still in the tree rooted 		 * from the current buffer. If not then repeat search 		 * from the root. 		 */
if|if
condition|(
name|fs_changed
argument_list|(
name|fs_gen
argument_list|,
name|p_s_sbi
argument_list|)
operator|&&
operator|(
operator|!
name|B_IS_IN_TREE
argument_list|(
name|p_s_bp
argument_list|)
operator|||
name|B_LEVEL
argument_list|(
name|p_s_bp
argument_list|)
operator|!=
name|expected_level
operator|||
operator|!
name|key_in_buffer
argument_list|(
name|p_s_search_path
argument_list|,
name|p_s_key
argument_list|,
name|p_s_sbi
argument_list|)
operator|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"the key isn't in the tree anymore\n"
argument_list|)
expr_stmt|;
name|decrement_counters_in_path
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
comment|/* 			 * Get the root block number so that we can repeat 			 * the search starting from the root. 			 */
name|n_block_number
operator|=
name|SB_ROOT_BLOCK
argument_list|(
name|p_s_sbi
argument_list|)
expr_stmt|;
name|expected_level
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Repeat search from the root */
continue|continue;
block|}
comment|/* 		 * Make sure, that the node contents look like a node of 		 * certain level 		 */
if|if
condition|(
operator|!
name|is_tree_node
argument_list|(
name|p_s_bp
argument_list|,
name|expected_level
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"invalid format found in block %ju. Fsck?"
argument_list|,
operator|(
name|intmax_t
operator|)
name|p_s_bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
name|p_s_search_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_ERROR
operator|)
return|;
block|}
comment|/* Ok, we have acquired next formatted node in the tree */
name|n_node_level
operator|=
name|B_LEVEL
argument_list|(
name|p_s_bp
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"block info:\n"
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  node level:  %d\n"
argument_list|,
name|n_node_level
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  nb of items: %d\n"
argument_list|,
name|B_NR_ITEMS
argument_list|(
name|p_s_bp
argument_list|)
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  free space:  %d bytes\n"
argument_list|,
name|B_FREE_SPACE
argument_list|(
name|p_s_bp
argument_list|)
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bin_search with :\n"
literal|"  p_s_key = (objectid=%d, dirid=%d)\n"
literal|"  B_NR_ITEMS(p_s_bp) = %d\n"
literal|"  p_s_last_element->pe_position = %d (path_length = %d)\n"
argument_list|,
name|p_s_key
operator|->
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|p_s_key
operator|->
name|on_disk_key
operator|.
name|k_dir_id
argument_list|,
name|B_NR_ITEMS
argument_list|(
name|p_s_bp
argument_list|)
argument_list|,
name|p_s_last_element
operator|->
name|pe_position
argument_list|,
name|p_s_search_path
operator|->
name|path_length
argument_list|)
expr_stmt|;
name|n_retval
operator|=
name|bin_search
argument_list|(
name|p_s_key
argument_list|,
name|B_N_PITEM_HEAD
argument_list|(
name|p_s_bp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|B_NR_ITEMS
argument_list|(
name|p_s_bp
argument_list|)
argument_list|,
operator|(
name|n_node_level
operator|==
name|DISK_LEAF_NODE_LEVEL
operator|)
condition|?
name|IH_SIZE
else|:
name|KEY_SIZE
argument_list|,
operator|&
operator|(
name|p_s_last_element
operator|->
name|pe_position
operator|)
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bin_search result: %d\n"
argument_list|,
name|n_retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_node_level
operator|==
name|n_stop_level
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"stop level reached (%s)\n"
argument_list|,
name|n_retval
operator|==
name|ITEM_FOUND
condition|?
literal|"found"
else|:
literal|"not found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|n_retval
operator|)
return|;
block|}
comment|/* We are not in the stop level */
if|if
condition|(
name|n_retval
operator|==
name|ITEM_FOUND
condition|)
comment|/* 			 * Item has been found, so we choose the pointer 			 * which is to the right of the found one 			 */
name|p_s_last_element
operator|->
name|pe_position
operator|++
expr_stmt|;
comment|/* 		 * If item was not found we choose the position which is 		 * to the left of the found item. This requires no code, 		 * bin_search did it already. 		 */
comment|/* 		 * So we have chosen a position in the current node which 		 * is an internal node. Now we calculate child block number 		 * by position in the node. 		 */
name|n_block_number
operator|=
name|B_N_CHILD_NUM
argument_list|(
name|p_s_bp
argument_list|,
name|p_s_last_element
operator|->
name|pe_position
argument_list|)
expr_stmt|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Form the path to an item and position in this item which contains  * file byte defined by p_s_key. If there is no such item corresponding  * to the key, we point the path to the item with maximal key less than  * p_s_key, and *p_n_pos_in_item is set to one past the last entry/byte  * in the item. If searching for entry in a directory item, and it is  * not found, *p_n_pos_in_item is set to one entry more than the entry  * with maximal key which is less than the sought key.  *  * Note that if there is no entry in this same node which is one more,  * then we point to an imaginary entry. For direct items, the position  * is in units of bytes, for indirect items the position is in units  * of blocknr entries, for directory items the position is in units of  * directory entries.  */
end_comment

begin_comment
comment|/* The function is NOT SCHEDULE-SAFE! */
end_comment

begin_function
name|int
name|search_for_position_by_key
parameter_list|(
name|struct
name|reiserfs_sb_info
modifier|*
name|p_s_sbi
parameter_list|,
specifier|const
name|struct
name|cpu_key
modifier|*
name|p_cpu_key
parameter_list|,
comment|/* Key to search (cpu variable) */
name|struct
name|path
modifier|*
name|p_s_search_path
parameter_list|)
comment|/* Filled up by this function.  */
block|{
name|int
name|retval
decl_stmt|,
name|n_blk_size
decl_stmt|;
name|off_t
name|item_offset
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|item_head
modifier|*
name|p_le_ih
decl_stmt|;
comment|/* Pointer to on-disk structure */
name|struct
name|reiserfs_dir_entry
name|de
decl_stmt|;
comment|/* If searching for directory entry. */
if|if
condition|(
name|is_direntry_cpu_key
argument_list|(
name|p_cpu_key
argument_list|)
condition|)
return|return
operator|(
name|search_by_entry_key
argument_list|(
name|p_s_sbi
argument_list|,
name|p_cpu_key
argument_list|,
name|p_s_search_path
argument_list|,
operator|&
name|de
argument_list|)
operator|)
return|;
comment|/* If not searching for directory entry. */
comment|/* If item is found. */
name|retval
operator|=
name|search_item
argument_list|(
name|p_s_sbi
argument_list|,
name|p_cpu_key
argument_list|,
name|p_s_search_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|IO_ERROR
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
name|retval
operator|==
name|ITEM_FOUND
condition|)
block|{
if|if
condition|(
name|ih_item_len
argument_list|(
name|B_N_PITEM_HEAD
argument_list|(
name|PATH_PLAST_BUFFER
argument_list|(
name|p_s_search_path
argument_list|)
argument_list|,
name|PATH_LAST_POSITION
argument_list|(
name|p_s_search_path
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"item length equals zero\n"
argument_list|)
expr_stmt|;
block|}
name|pos_in_item
argument_list|(
name|p_s_search_path
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|POSITION_FOUND
operator|)
return|;
block|}
if|if
condition|(
name|PATH_LAST_POSITION
argument_list|(
name|p_s_search_path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"position equals zero\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Item is not found. Set path to the previous item. */
name|p_le_ih
operator|=
name|B_N_PITEM_HEAD
argument_list|(
name|PATH_PLAST_BUFFER
argument_list|(
name|p_s_search_path
argument_list|)
argument_list|,
operator|--
name|PATH_LAST_POSITION
argument_list|(
name|p_s_search_path
argument_list|)
argument_list|)
expr_stmt|;
name|n_blk_size
operator|=
name|p_s_sbi
operator|->
name|s_blocksize
expr_stmt|;
if|if
condition|(
name|comp_short_keys
argument_list|(
operator|&
operator|(
name|p_le_ih
operator|->
name|ih_key
operator|)
argument_list|,
name|p_cpu_key
argument_list|)
condition|)
block|{
return|return
operator|(
name|FILE_NOT_FOUND
operator|)
return|;
block|}
name|item_offset
operator|=
name|le_ih_k_offset
argument_list|(
name|p_le_ih
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cpu_key_k_offset
argument_list|(
name|p_cpu_key
argument_list|)
expr_stmt|;
comment|/* Needed byte is contained in the item pointed to by the path.*/
if|if
condition|(
name|item_offset
operator|<=
name|offset
operator|&&
name|item_offset
operator|+
name|op_bytes_number
argument_list|(
name|p_le_ih
argument_list|,
name|n_blk_size
argument_list|)
operator|>
name|offset
condition|)
block|{
name|pos_in_item
argument_list|(
name|p_s_search_path
argument_list|)
operator|=
name|offset
operator|-
name|item_offset
expr_stmt|;
if|if
condition|(
name|is_indirect_le_ih
argument_list|(
name|p_le_ih
argument_list|)
condition|)
block|{
name|pos_in_item
argument_list|(
name|p_s_search_path
argument_list|)
operator|/=
name|n_blk_size
expr_stmt|;
block|}
return|return
operator|(
name|POSITION_FOUND
operator|)
return|;
block|}
comment|/* Needed byte is not contained in the item pointed to by the 	 * path. Set pos_in_item out of the item. */
if|if
condition|(
name|is_indirect_le_ih
argument_list|(
name|p_le_ih
argument_list|)
condition|)
name|pos_in_item
argument_list|(
name|p_s_search_path
argument_list|)
operator|=
name|ih_item_len
argument_list|(
name|p_le_ih
argument_list|)
operator|/
name|UNFM_P_SIZE
expr_stmt|;
else|else
name|pos_in_item
argument_list|(
name|p_s_search_path
argument_list|)
operator|=
name|ih_item_len
argument_list|(
name|p_le_ih
argument_list|)
expr_stmt|;
return|return
operator|(
name|POSITION_NOT_FOUND
operator|)
return|;
block|}
end_function

end_unit

