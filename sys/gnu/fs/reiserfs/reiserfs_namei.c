begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2000 Hans Reiser  * See README for licensing and copyright details  *   * Ported to FreeBSD by Jean-Sébastien Pédron<jspedron@club-internet.fr>  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<gnu/fs/reiserfs/reiserfs_fs.h>
end_include

begin_function_decl
specifier|static
name|int
name|reiserfs_find_entry
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|path
modifier|*
name|path_to_entry
parameter_list|,
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_REISERFSCOOKIES
argument_list|,
literal|"ReiserFS cookies"
argument_list|,
literal|"ReiserFS VOP_READDIR cookies"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------  * Lookup functions  * -------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|reiserfs_lookup
parameter_list|(
name|struct
name|vop_cachedlookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vdp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|cpu_key
modifier|*
name|saved_ino
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|pdp
decl_stmt|;
comment|/* Saved dp during symlink work */
name|struct
name|reiserfs_node
modifier|*
name|dp
decl_stmt|;
name|struct
name|reiserfs_dir_entry
name|de
decl_stmt|;
name|INITIALIZE_PATH
argument_list|(
name|path_to_entry
argument_list|)
expr_stmt|;
name|char
name|c
init|=
name|cnp
operator|->
name|cn_nameptr
index|[
name|cnp
operator|->
name|cn_namelen
index|]
decl_stmt|;
name|cnp
operator|->
name|cn_nameptr
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"looking for `%s', %ld (%s)\n"
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
name|c
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|VTOI
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|REISERFS_MAX_NAME
argument_list|(
name|dp
operator|->
name|i_reiserfs
operator|->
name|s_blocksize
argument_list|)
operator|<
name|cnp
operator|->
name|cn_namelen
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"searching entry\n"
argument_list|)
expr_stmt|;
name|de
operator|.
name|de_gen_number_bit_string
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|reiserfs_find_entry
argument_list|(
name|dp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
operator|&
name|path_to_entry
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
operator|&
name|path_to_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NAME_FOUND
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"found\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"not found\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
name|NAME_FOUND
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Hide the .reiserfs_priv directory */
block|if (reiserfs_xattrs(dp->i_reiserfs)&& 		    !old_format_only(dp->i_reiserfs)&& 		    REISERFS_SB(dp->i_reiserfs)->priv_root&& 		    REISERFS_SB(dp->i_reiserfs)->priv_root->d_inode&& 		    de.de_objectid == le32toh(INODE_PKEY(REISERFS_SB( 		    dp->i_reiserfs)->priv_root->d_inode)->k_objectid)) { 			return (EACCES); 		}
endif|#
directive|endif
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reading vnode\n"
argument_list|)
expr_stmt|;
name|pdp
operator|=
name|vdp
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|saved_ino
operator|=
operator|(
expr|struct
name|cpu_key
operator|*
operator|)
operator|&
operator|(
name|de
operator|.
name|de_dir_id
operator|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|pdp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|reiserfs_iget
argument_list|(
name|vdp
operator|->
name|v_mount
argument_list|,
name|saved_ino
argument_list|,
operator|&
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|pdp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|de
operator|.
name|de_objectid
operator|==
name|dp
operator|->
name|i_number
operator|&&
name|de
operator|.
name|de_dir_id
operator|==
name|dp
operator|->
name|i_ino
condition|)
block|{
name|VREF
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
comment|/* We want ourself, ie "." */
operator|*
name|vpp
operator|=
name|vdp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|reiserfs_iget
argument_list|(
name|vdp
operator|->
name|v_mount
argument_list|,
operator|(
expr|struct
name|cpu_key
operator|*
operator|)
operator|&
operator|(
name|de
operator|.
name|de_dir_id
operator|)
argument_list|,
operator|&
name|vp
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
comment|/* 		 * Propogate the priv_object flag so we know we're in the 		 * priv tree 		 */
comment|/*if (is_reiserfs_priv_object(dir)) 			REISERFS_I(inode)->i_flags |= i_priv_object;*/
block|}
else|else
block|{
if|if
condition|(
name|retval
operator|==
name|IO_ERROR
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"IO error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Insert name into cache if appropriate. */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|vdp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|key
name|MIN_KEY
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|reiserfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|dirent
name|dstdp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|off_t
name|next_pos
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|item_head
modifier|*
name|ih
decl_stmt|;
name|struct
name|cpu_key
name|pos_key
decl_stmt|;
specifier|const
name|struct
name|key
modifier|*
name|rkey
decl_stmt|;
name|struct
name|reiserfs_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|reiserfs_dir_entry
name|de
decl_stmt|;
name|INITIALIZE_PATH
argument_list|(
name|path_to_entry
argument_list|)
expr_stmt|;
name|int
name|entry_num
decl_stmt|,
name|item_num
decl_stmt|,
name|search_res
decl_stmt|;
comment|/* The NFS part */
name|int
name|ncookies
init|=
literal|0
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Form key for search the next directory entry using f_pos field of 	 * file structure 	 */
name|ip
operator|=
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|make_cpu_key
argument_list|(
operator|&
name|pos_key
argument_list|,
name|ip
argument_list|,
name|uio
operator|->
name|uio_offset
condition|?
name|uio
operator|->
name|uio_offset
else|:
name|DOT_OFFSET
argument_list|,
name|TYPE_DIRENTRY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|next_pos
operator|=
name|cpu_key_k_offset
argument_list|(
operator|&
name|pos_key
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"listing entries for "
literal|"(objectid=%d, dirid=%d)\n"
argument_list|,
name|pos_key
operator|.
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|pos_key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"uio_offset = %jd, uio_resid = %d\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|uio
operator|->
name|uio_offset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|&&
name|ap
operator|->
name|a_cookies
condition|)
block|{
name|cookies
operator|=
operator|(
name|u_long
operator|*
operator|)
name|malloc
argument_list|(
name|uio
operator|->
name|uio_resid
operator|/
literal|16
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_REISERFSCOOKIES
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|//research:
comment|/* 		 * Search the directory item, containing entry with 		 * specified key 		 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search directory to read\n"
argument_list|)
expr_stmt|;
name|search_res
operator|=
name|search_by_entry_key
argument_list|(
name|ip
operator|->
name|i_reiserfs
argument_list|,
operator|&
name|pos_key
argument_list|,
operator|&
name|path_to_entry
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_res
operator|==
name|IO_ERROR
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|entry_num
operator|=
name|de
operator|.
name|de_entry_num
expr_stmt|;
name|item_num
operator|=
name|de
operator|.
name|de_item_num
expr_stmt|;
name|bp
operator|=
name|de
operator|.
name|de_bp
expr_stmt|;
name|ih
operator|=
name|de
operator|.
name|de_ih
expr_stmt|;
if|if
condition|(
name|search_res
operator|==
name|POSITION_FOUND
operator|||
name|entry_num
operator|<
name|I_ENTRY_COUNT
argument_list|(
name|ih
argument_list|)
condition|)
block|{
comment|/* 			 * Go through all entries in the directory item 			 * beginning from the entry, that has been found. 			 */
name|struct
name|reiserfs_de_head
modifier|*
name|deh
init|=
name|B_I_DEH
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|)
operator|+
name|entry_num
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|==
name|NULL
condition|)
block|{
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|//ncookies =
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"walking through directory entries\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|entry_num
operator|<
name|I_ENTRY_COUNT
argument_list|(
name|ih
argument_list|)
condition|;
name|entry_num
operator|++
operator|,
name|deh
operator|++
control|)
block|{
name|int
name|d_namlen
decl_stmt|;
name|char
modifier|*
name|d_name
decl_stmt|;
name|off_t
name|d_off
decl_stmt|;
name|ino_t
name|d_ino
decl_stmt|;
if|if
condition|(
operator|!
name|de_visible
argument_list|(
name|deh
argument_list|)
condition|)
block|{
comment|/* It is hidden entry */
continue|continue;
block|}
name|d_namlen
operator|=
name|entry_length
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|,
name|entry_num
argument_list|)
expr_stmt|;
name|d_name
operator|=
name|B_I_DEH_ENTRY_FILE_NAME
argument_list|(
name|bp
argument_list|,
name|ih
argument_list|,
name|deh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d_name
index|[
name|d_namlen
operator|-
literal|1
index|]
condition|)
name|d_namlen
operator|=
name|strlen
argument_list|(
name|d_name
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"  - `%s' (len=%d)\n"
argument_list|,
name|d_name
argument_list|,
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_namlen
operator|>
name|REISERFS_MAX_NAME
argument_list|(
name|ip
operator|->
name|i_reiserfs
operator|->
name|s_blocksize
argument_list|)
condition|)
block|{
comment|/* Too big to send back to VFS */
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* Ignore the .reiserfs_priv entry */
block|if (reiserfs_xattrs(ip->i_reiserfs)&& 				    !old_format_only(ip->i_reiserfs)&& 				    filp->f_dentry == ip->i_reiserfs->s_root&& 				    REISERFS_SB(ip->i_reiserfs)->priv_root&& 				    REISERFS_SB(ip->i_reiserfs)->priv_root->d_inode&& 				    deh_objectid(deh) == 				    le32toh(INODE_PKEY(REISERFS_SB( 				    ip->i_reiserfs)->priv_root->d_inode)->k_objectid)) { 					continue; 				}
endif|#
directive|endif
name|d_off
operator|=
name|deh_offset
argument_list|(
name|deh
argument_list|)
expr_stmt|;
name|d_ino
operator|=
name|deh_objectid
argument_list|(
name|deh
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|d_off
expr_stmt|;
comment|/* Copy to user land */
name|dstdp
operator|.
name|d_fileno
operator|=
name|d_ino
expr_stmt|;
name|dstdp
operator|.
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|dstdp
operator|.
name|d_namlen
operator|=
name|d_namlen
expr_stmt|;
name|dstdp
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|dstdp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|d_name
argument_list|,
name|dstdp
operator|.
name|d_name
argument_list|,
name|dstdp
operator|.
name|d_namlen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dstdp
operator|.
name|d_name
operator|+
name|dstdp
operator|.
name|d_namlen
argument_list|,
name|dstdp
operator|.
name|d_reclen
operator|-
name|offsetof
argument_list|(
expr|struct
name|dirent
argument_list|,
name|d_name
argument_list|)
operator|-
name|dstdp
operator|.
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_namlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dstdp
operator|.
name|d_reclen
operator|<=
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"     copying to user land\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|dstdp
argument_list|,
name|dstdp
operator|.
name|d_reclen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|cookies
operator|!=
name|NULL
condition|)
block|{
name|cookies
index|[
name|ncookies
index|]
operator|=
name|d_off
expr_stmt|;
name|ncookies
operator|++
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|next_pos
operator|=
name|deh_offset
argument_list|(
name|deh
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"...done\n"
argument_list|)
expr_stmt|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"checking item num (%d == %d ?)\n"
argument_list|,
name|item_num
argument_list|,
name|B_NR_ITEMS
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_num
operator|!=
name|B_NR_ITEMS
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
condition|)
block|{
comment|/* End of directory has been reached */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"end reached\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_eofflag
condition|)
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* 		 * Item we went through is last item of node. Using right 		 * delimiting key check is it directory end 		 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"get right key\n"
argument_list|)
expr_stmt|;
name|rkey
operator|=
name|get_rkey
argument_list|(
operator|&
name|path_to_entry
argument_list|,
name|ip
operator|->
name|i_reiserfs
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"right key = (objectid=%d, dirid=%d)\n"
argument_list|,
name|rkey
operator|->
name|k_objectid
argument_list|,
name|rkey
operator|->
name|k_dir_id
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"compare it to MIN_KEY\n"
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"MIN KEY = (objectid=%d, dirid=%d)\n"
argument_list|,
name|MIN_KEY
operator|.
name|k_objectid
argument_list|,
name|MIN_KEY
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_le_keys
argument_list|(
name|rkey
argument_list|,
operator|&
name|MIN_KEY
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Set pos_key to key, that is the smallest and greater 			 * that key of the last entry in the item */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"continuing on the right\n"
argument_list|)
expr_stmt|;
name|set_cpu_key_k_offset
argument_list|(
operator|&
name|pos_key
argument_list|,
name|next_pos
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"compare it to pos_key\n"
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pos key = (objectid=%d, dirid=%d)\n"
argument_list|,
name|pos_key
operator|.
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|pos_key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMP_SHORT_KEYS
argument_list|(
name|rkey
argument_list|,
operator|&
name|pos_key
argument_list|)
condition|)
block|{
comment|/* End of directory has been reached */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"end reached (right)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_eofflag
condition|)
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Directory continues in the right neighboring block */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"continuing with a new offset\n"
argument_list|)
expr_stmt|;
name|set_cpu_key_k_offset
argument_list|(
operator|&
name|pos_key
argument_list|,
name|le_key_k_offset
argument_list|(
name|KEY_FORMAT_3_5
argument_list|,
name|rkey
argument_list|)
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"new pos key = (objectid=%d, dirid=%d)\n"
argument_list|,
name|pos_key
operator|.
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|pos_key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|uio
operator|->
name|uio_offset
operator|=
name|next_pos
expr_stmt|;
name|pathrelse
argument_list|(
operator|&
name|path_to_entry
argument_list|)
expr_stmt|;
name|reiserfs_check_path
argument_list|(
operator|&
name|path_to_entry
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|&&
name|cookies
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cookies
argument_list|,
name|M_REISERFSCOOKIES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|!=
name|NULL
operator|&&
name|ap
operator|->
name|a_cookies
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
name|ncookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|cookies
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * Functions from linux/fs/reiserfs/namei.c  * -------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Directory item contains array of entry headers. This performs binary  * search through that array.  */
end_comment

begin_function
specifier|static
name|int
name|bin_search_in_dir_item
parameter_list|(
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|struct
name|item_head
modifier|*
name|ih
init|=
name|de
operator|->
name|de_ih
decl_stmt|;
name|struct
name|reiserfs_de_head
modifier|*
name|deh
init|=
name|de
operator|->
name|de_deh
decl_stmt|;
name|int
name|rbound
decl_stmt|,
name|lbound
decl_stmt|,
name|j
decl_stmt|;
name|lbound
operator|=
literal|0
expr_stmt|;
name|rbound
operator|=
name|I_ENTRY_COUNT
argument_list|(
name|ih
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|rbound
operator|+
name|lbound
operator|)
operator|/
literal|2
init|;
name|lbound
operator|<=
name|rbound
condition|;
name|j
operator|=
operator|(
name|rbound
operator|+
name|lbound
operator|)
operator|/
literal|2
control|)
block|{
if|if
condition|(
name|off
operator|<
name|deh_offset
argument_list|(
name|deh
operator|+
name|j
argument_list|)
condition|)
block|{
name|rbound
operator|=
name|j
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|off
operator|>
name|deh_offset
argument_list|(
name|deh
operator|+
name|j
argument_list|)
condition|)
block|{
name|lbound
operator|=
name|j
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* This is not name found, but matched third key component */
name|de
operator|->
name|de_entry_num
operator|=
name|j
expr_stmt|;
return|return
operator|(
name|NAME_FOUND
operator|)
return|;
block|}
name|de
operator|->
name|de_entry_num
operator|=
name|lbound
expr_stmt|;
return|return
operator|(
name|NAME_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Comment?  Maybe something like set de to point to what the path  * points to?  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_de_item_location
parameter_list|(
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|,
name|struct
name|path
modifier|*
name|path
parameter_list|)
block|{
name|de
operator|->
name|de_bp
operator|=
name|get_last_bp
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_ih
operator|=
name|get_ih
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_deh
operator|=
name|B_I_DEH
argument_list|(
name|de
operator|->
name|de_bp
argument_list|,
name|de
operator|->
name|de_ih
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_item_num
operator|=
name|PATH_LAST_POSITION
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * de_bh, de_ih, de_deh (points to first element of array), de_item_num  * is set  */
end_comment

begin_function
specifier|inline
name|void
name|set_de_name_and_namelen
parameter_list|(
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|reiserfs_de_head
modifier|*
name|deh
init|=
name|de
operator|->
name|de_deh
operator|+
name|de
operator|->
name|de_entry_num
decl_stmt|;
if|if
condition|(
name|de
operator|->
name|de_entry_num
operator|>=
name|ih_entry_count
argument_list|(
name|de
operator|->
name|de_ih
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"BUG\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|de
operator|->
name|de_entrylen
operator|=
name|entry_length
argument_list|(
name|de
operator|->
name|de_bp
argument_list|,
name|de
operator|->
name|de_ih
argument_list|,
name|de
operator|->
name|de_entry_num
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_namelen
operator|=
name|de
operator|->
name|de_entrylen
operator|-
operator|(
name|de_with_sd
argument_list|(
name|deh
argument_list|)
condition|?
name|SD_SIZE
else|:
literal|0
operator|)
expr_stmt|;
name|de
operator|->
name|de_name
operator|=
name|B_I_PITEM
argument_list|(
name|de
operator|->
name|de_bp
argument_list|,
name|de
operator|->
name|de_ih
argument_list|)
operator|+
name|deh_location
argument_list|(
name|deh
argument_list|)
expr_stmt|;
if|if
condition|(
name|de
operator|->
name|de_name
index|[
name|de
operator|->
name|de_namelen
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|de
operator|->
name|de_namelen
operator|=
name|strlen
argument_list|(
name|de
operator|->
name|de_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* What entry points to */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_de_object_key
parameter_list|(
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|)
block|{
if|if
condition|(
name|de
operator|->
name|de_entry_num
operator|>=
name|ih_entry_count
argument_list|(
name|de
operator|->
name|de_ih
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"BUG\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|de
operator|->
name|de_dir_id
operator|=
name|deh_dir_id
argument_list|(
operator|&
operator|(
name|de
operator|->
name|de_deh
index|[
name|de
operator|->
name|de_entry_num
index|]
operator|)
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_objectid
operator|=
name|deh_objectid
argument_list|(
operator|&
operator|(
name|de
operator|->
name|de_deh
index|[
name|de
operator|->
name|de_entry_num
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|store_de_entry_key
parameter_list|(
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|reiserfs_de_head
modifier|*
name|deh
init|=
name|de
operator|->
name|de_deh
operator|+
name|de
operator|->
name|de_entry_num
decl_stmt|;
if|if
condition|(
name|de
operator|->
name|de_entry_num
operator|>=
name|ih_entry_count
argument_list|(
name|de
operator|->
name|de_ih
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"BUG\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Store key of the found entry */
name|de
operator|->
name|de_entry_key
operator|.
name|version
operator|=
name|KEY_FORMAT_3_5
expr_stmt|;
name|de
operator|->
name|de_entry_key
operator|.
name|on_disk_key
operator|.
name|k_dir_id
operator|=
name|le32toh
argument_list|(
name|de
operator|->
name|de_ih
operator|->
name|ih_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
name|de
operator|->
name|de_entry_key
operator|.
name|on_disk_key
operator|.
name|k_objectid
operator|=
name|le32toh
argument_list|(
name|de
operator|->
name|de_ih
operator|->
name|ih_key
operator|.
name|k_objectid
argument_list|)
expr_stmt|;
name|set_cpu_key_k_offset
argument_list|(
operator|&
operator|(
name|de
operator|->
name|de_entry_key
operator|)
argument_list|,
name|deh_offset
argument_list|(
name|deh
argument_list|)
argument_list|)
expr_stmt|;
name|set_cpu_key_k_type
argument_list|(
operator|&
operator|(
name|de
operator|->
name|de_entry_key
operator|)
argument_list|,
name|TYPE_DIRENTRY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We assign a key to each directory item, and place multiple entries in  * a single directory item. A directory item has a key equal to the key  * of the first directory entry in it.  *  * This function first calls search_by_key, then, if item whose first  * entry matches is not found it looks for the entry inside directory  * item found by search_by_key. Fills the path to the entry, and to the  * entry position in the item  */
end_comment

begin_function
name|int
name|search_by_entry_key
parameter_list|(
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
parameter_list|,
specifier|const
name|struct
name|cpu_key
modifier|*
name|key
parameter_list|,
name|struct
name|path
modifier|*
name|path
parameter_list|,
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"searching in (objectid=%d,dirid=%d)\n"
argument_list|,
name|key
operator|->
name|on_disk_key
operator|.
name|k_objectid
argument_list|,
name|key
operator|->
name|on_disk_key
operator|.
name|k_dir_id
argument_list|)
expr_stmt|;
name|retval
operator|=
name|search_item
argument_list|(
name|sbi
argument_list|,
name|key
argument_list|,
name|path
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|ITEM_NOT_FOUND
case|:
if|if
condition|(
operator|!
name|PATH_LAST_POSITION
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search_by_key returned item position == 0"
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_ERROR
operator|)
return|;
block|}
name|PATH_LAST_POSITION
argument_list|(
name|path
argument_list|)
operator|--
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search_by_key did not found it\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITEM_FOUND
case|:
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search_by_key found it\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IO_ERROR
case|:
return|return
operator|(
name|retval
operator|)
return|;
default|default:
name|pathrelse
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"no path to here"
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_ERROR
operator|)
return|;
block|}
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"set item location\n"
argument_list|)
expr_stmt|;
name|set_de_item_location
argument_list|(
name|de
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Binary search in directory item by third component of the 	 * key. Sets de->de_entry_num of de 	 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"bin_search_in_dir_item\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|bin_search_in_dir_item
argument_list|(
name|de
argument_list|,
name|cpu_key_k_offset
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|->
name|pos_in_item
operator|=
name|de
operator|->
name|de_entry_num
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NAME_NOT_FOUND
condition|)
block|{
comment|/* 		 * Ugly, but rename needs de_bp, de_deh, de_name, de_namelen, 		 * de_objectid set 		 */
name|set_de_name_and_namelen
argument_list|(
name|de
argument_list|)
expr_stmt|;
name|set_de_object_key
argument_list|(
name|de
argument_list|)
expr_stmt|;
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"set (objectid=%d,dirid=%d)\n"
argument_list|,
name|de
operator|->
name|de_objectid
argument_list|,
name|de
operator|->
name|de_dir_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|get_third_component
parameter_list|(
name|struct
name|reiserfs_sb_info
modifier|*
name|sbi
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint32_t
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|(
name|len
operator|==
literal|1
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
return|return
operator|(
name|DOT_OFFSET
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
operator|(
name|DOT_DOT_OFFSET
operator|)
return|;
name|res
operator|=
name|REISERFS_SB
argument_list|(
name|sbi
argument_list|)
operator|->
name|s_hash_function
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Take bits from 7-th to 30-th including both bounds */
name|res
operator|=
name|GET_HASH_VALUE
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
comment|/* 		 * Needed to have no names before "." and ".." those have hash 		 * value == 0 and generation counters 1 and 2 accordingly 		 */
name|res
operator|=
literal|128
expr_stmt|;
return|return
operator|(
name|res
operator|+
name|MAX_GENERATION_NUMBER
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reiserfs_match
parameter_list|(
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|int
name|retval
init|=
name|NAME_NOT_FOUND
decl_stmt|;
if|if
condition|(
operator|(
name|namelen
operator|==
name|de
operator|->
name|de_namelen
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|de
operator|->
name|de_name
argument_list|,
name|name
argument_list|,
name|de
operator|->
name|de_namelen
argument_list|)
condition|)
name|retval
operator|=
operator|(
name|de_visible
argument_list|(
name|de
operator|->
name|de_deh
operator|+
name|de
operator|->
name|de_entry_num
argument_list|)
condition|?
name|NAME_FOUND
else|:
name|NAME_FOUND_INVISIBLE
operator|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * de's de_bh, de_ih, de_deh, de_item_num, de_entry_num are set already  * Used when hash collisions exist  */
end_comment

begin_function
specifier|static
name|int
name|linear_search_in_dir_item
parameter_list|(
name|struct
name|cpu_key
modifier|*
name|key
parameter_list|,
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|reiserfs_de_head
modifier|*
name|deh
init|=
name|de
operator|->
name|de_deh
decl_stmt|;
name|i
operator|=
name|de
operator|->
name|de_entry_num
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|I_ENTRY_COUNT
argument_list|(
name|de
operator|->
name|de_ih
argument_list|)
operator|||
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
name|deh
operator|+
name|i
argument_list|)
argument_list|)
operator|!=
name|GET_HASH_VALUE
argument_list|(
name|cpu_key_k_offset
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
block|}
comment|/*RFALSE( de->de_deh != B_I_DEH (de->de_bh, de->de_ih), 	  "vs-7010: array of entry headers not found");*/
name|deh
operator|+=
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|deh
operator|--
control|)
block|{
if|if
condition|(
name|GET_HASH_VALUE
argument_list|(
name|deh_offset
argument_list|(
name|deh
argument_list|)
argument_list|)
operator|!=
name|GET_HASH_VALUE
argument_list|(
name|cpu_key_k_offset
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 			 * Hash value does not match, no need to check 			 * whole name 			 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"name `%s' not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAME_NOT_FOUND
operator|)
return|;
block|}
comment|/* Mark that this generation number is used */
if|if
condition|(
name|de
operator|->
name|de_gen_number_bit_string
condition|)
name|set_bit
argument_list|(
name|GET_GENERATION_NUMBER
argument_list|(
name|deh_offset
argument_list|(
name|deh
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|de
operator|->
name|de_gen_number_bit_string
argument_list|)
expr_stmt|;
comment|/* Calculate pointer to name and namelen */
name|de
operator|->
name|de_entry_num
operator|=
name|i
expr_stmt|;
name|set_de_name_and_namelen
argument_list|(
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|reiserfs_match
argument_list|(
name|de
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|)
operator|!=
name|NAME_NOT_FOUND
condition|)
block|{
comment|/* 			 * de's de_name, de_namelen, de_recordlen are set. 			 * Fill the rest: 			 */
comment|/* key of pointed object */
name|set_de_object_key
argument_list|(
name|de
argument_list|)
expr_stmt|;
name|store_de_entry_key
argument_list|(
name|de
argument_list|)
expr_stmt|;
comment|/* retval can be NAME_FOUND or NAME_FOUND_INVISIBLE */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"reiserfs_match answered `%d'\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
if|if
condition|(
name|GET_GENERATION_NUMBER
argument_list|(
name|le_ih_k_offset
argument_list|(
name|de
operator|->
name|de_ih
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
comment|/* 		 * We have reached left most entry in the node. In common 		 * we have to go to the left neighbor, but if generation 		 * counter is 0 already, we know for sure, that there is 		 * no name with the same hash value 		 */
comment|/* FIXME: this work correctly only because hash value can 		 * not be 0. Btw, in case of Yura's hash it is probably 		 * possible, so, this is a bug 		 */
return|return
operator|(
name|NAME_NOT_FOUND
operator|)
return|;
comment|/*RFALSE(de->de_item_num, 	    "vs-7015: two diritems of the same directory in one node?");*/
return|return
operator|(
name|GOTO_PREVIOUS_ITEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * May return NAME_FOUND, NAME_FOUND_INVISIBLE, NAME_NOT_FOUND  * FIXME: should add something like IOERROR  */
end_comment

begin_function
specifier|static
name|int
name|reiserfs_find_entry
parameter_list|(
name|struct
name|reiserfs_node
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|path
modifier|*
name|path_to_entry
parameter_list|,
name|struct
name|reiserfs_dir_entry
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|cpu_key
name|key_to_search
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|namelen
operator|>
name|REISERFS_MAX_NAME
argument_list|(
name|dp
operator|->
name|i_reiserfs
operator|->
name|s_blocksize
argument_list|)
condition|)
return|return
name|NAME_NOT_FOUND
return|;
comment|/* We will search for this key in the tree */
name|make_cpu_key
argument_list|(
operator|&
name|key_to_search
argument_list|,
name|dp
argument_list|,
name|get_third_component
argument_list|(
name|dp
operator|->
name|i_reiserfs
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
argument_list|,
name|TYPE_DIRENTRY
argument_list|,
literal|3
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"search by entry key\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|search_by_entry_key
argument_list|(
name|dp
operator|->
name|i_reiserfs
argument_list|,
operator|&
name|key_to_search
argument_list|,
name|path_to_entry
argument_list|,
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|IO_ERROR
condition|)
block|{
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"IO error in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|IO_ERROR
return|;
block|}
comment|/* Compare names for all entries having given hash value */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"linear search for `%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|linear_search_in_dir_item
argument_list|(
operator|&
name|key_to_search
argument_list|,
name|de
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|GOTO_PREVIOUS_ITEM
condition|)
block|{
comment|/* 			 * There is no need to scan directory anymore. 			 * Given entry found or does not exist 			 */
name|reiserfs_log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"linear search returned "
literal|"(objectid=%d,dirid=%d)\n"
argument_list|,
name|de
operator|->
name|de_objectid
argument_list|,
name|de
operator|->
name|de_dir_id
argument_list|)
expr_stmt|;
name|path_to_entry
operator|->
name|pos_in_item
operator|=
name|de
operator|->
name|de_entry_num
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* 		 * There is left neighboring item of this directory and 		 * given entry can be there 		 */
name|set_cpu_key_k_offset
argument_list|(
operator|&
name|key_to_search
argument_list|,
name|le_ih_k_offset
argument_list|(
name|de
operator|->
name|de_ih
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pathrelse
argument_list|(
name|path_to_entry
argument_list|)
expr_stmt|;
block|}
comment|/* while (1) */
block|}
end_function

end_unit

