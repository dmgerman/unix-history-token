begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_comment
comment|//#include<linux/capability.h>
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_comment
comment|/*  * xfs_attr.c  *  * Provide the external interfaces to manage attribute lists.  */
end_comment

begin_define
define|#
directive|define
name|ATTR_SYSCOUNT
value|2
end_define

begin_decl_stmt
name|STATIC
name|struct
name|attrnames
name|posix_acl_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|attrnames
name|posix_acl_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|attrnames
modifier|*
name|attr_system_names
index|[
name|ATTR_SYSCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*========================================================================  * Function prototypes for the kernel.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Internal routines when attribute list fits inside the inode.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_attr_shortform_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Internal routines when attribute list is one block.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_get
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_list
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Internal routines when attribute list is more than one block.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_attr_node_get
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_node_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_node_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_node_list
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_fillstate
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_refillstate
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Routines to manipulate out-of-line attribute values.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_attr_rmtval_get
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_rmtval_set
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_rmtval_remove
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ATTR_RMTVALUE_MAPSIZE
value|1
end_define

begin_comment
comment|/* # of map entries at once */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_ATTR_TRACE
argument_list|)
end_if

begin_decl_stmt
name|ktrace_t
modifier|*
name|xfs_attr_trace_buf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*========================================================================  * Overall external interface routines.  *========================================================================*/
end_comment

begin_function
name|int
name|xfs_attr_fetch
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|valuelenp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cred
modifier|*
name|cred
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|ENOATTR
operator|)
return|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|args
operator|.
name|valuelen
operator|=
operator|*
name|valuelenp
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|args
operator|.
name|name
argument_list|,
name|args
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|ip
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_ATTR_FORK
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|error
operator|=
name|xfs_attr_shortform_getvalue
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|ip
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_attr_leaf_get
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_attr_node_get
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the number of bytes in the value to the caller. 	 */
operator|*
name|valuelenp
operator|=
name|args
operator|.
name|valuelen
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xfs_attr_get
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|valuelenp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cred
modifier|*
name|cred
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
init|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|namelen
decl_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_attr_get
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|>=
name|MAXNAMELEN
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* match IRIX behaviour */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_fetch
argument_list|(
name|ip
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|value
argument_list|,
name|valuelenp
argument_list|,
name|flags
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_attr_set_int
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|valuelen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|xfs_fsblock_t
name|firstblock
decl_stmt|;
name|xfs_bmap_free_t
name|flist
decl_stmt|;
name|int
name|error
decl_stmt|,
name|err2
decl_stmt|,
name|committed
decl_stmt|;
name|int
name|local
decl_stmt|,
name|size
decl_stmt|;
name|uint
name|nblks
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
init|=
name|dp
operator|->
name|i_mount
decl_stmt|;
name|int
name|rsvd
init|=
operator|(
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* 	 * Attach the dquots to the inode. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Determine space new attribute will use, and if it would be 	 * "local" or "remote" (note: local != inline). 	 */
name|size
operator|=
name|xfs_attr_leaf_newentsize
argument_list|(
name|namelen
argument_list|,
name|valuelen
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
operator|&
name|local
argument_list|)
expr_stmt|;
comment|/* 	 * If the inode doesn't have an attribute fork, add one. 	 * (inode must not be locked when we call this routine) 	 */
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_attrfork
argument_list|(
name|dp
argument_list|,
name|size
argument_list|,
name|rsvd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|args
operator|.
name|valuelen
operator|=
name|valuelen
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|args
operator|.
name|name
argument_list|,
name|args
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
operator|&
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
operator|&
name|flist
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_ATTR_FORK
expr_stmt|;
name|args
operator|.
name|addname
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
name|nblks
operator|=
name|XFS_DAENTER_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
block|{
if|if
condition|(
name|size
operator|>
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|>>
literal|1
operator|)
condition|)
block|{
comment|/* Double split possible */
name|nblks
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint
name|dblocks
init|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|valuelen
argument_list|)
decl_stmt|;
comment|/* Out of line attribute, cannot double split, but make 		 * room for the attribute value itself. 		 */
name|nblks
operator|+=
name|dblocks
expr_stmt|;
name|nblks
operator|+=
name|XFS_NEXTENTADD_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|dblocks
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
block|}
comment|/* Size is now blocks for attribute data */
name|args
operator|.
name|total
operator|=
name|nblks
expr_stmt|;
comment|/* 	 * Start our first transaction of the day. 	 * 	 * All future transactions during this code must be "chained" off 	 * this one via the trans_dup() call.  All transactions will contain 	 * the inode, and the inode will always be marked with trans_ihold(). 	 * Since the inode will be locked in all transactions, we must log 	 * the inode in every transaction to let it float upward through 	 * the log. 	 */
name|args
operator|.
name|trans
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_ATTR_SET
argument_list|)
expr_stmt|;
comment|/* 	 * Root fork attributes can use reserved data blocks for this 	 * operation if necessary 	 */
if|if
condition|(
name|rsvd
condition|)
name|args
operator|.
name|trans
operator|->
name|t_flags
operator||=
name|XFS_TRANS_RESERVE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|args
operator|.
name|trans
argument_list|,
operator|(
name|uint
operator|)
name|nblks
argument_list|,
name|XFS_ATTRSET_LOG_RES
argument_list|(
name|mp
argument_list|,
name|nblks
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ATTRSET_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|args
operator|.
name|trans
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|,
name|nblks
argument_list|,
literal|0
argument_list|,
name|rsvd
condition|?
name|XFS_QMOPT_RES_REGBLKS
operator||
name|XFS_QMOPT_FORCE_RES
else|:
name|XFS_QMOPT_RES_REGBLKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|xfs_trans_ijoin
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * If the attribute list is non-existent or a shortform list, 	 * upgrade it to a single-leaf-block attribute list. 	 */
if|if
condition|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_LOCAL
operator|)
operator|||
operator|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|)
operator|&&
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Build initial attribute list (if required). 		 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
condition|)
name|xfs_attr_shortform_create
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
comment|/* 		 * Try to add the attr to the attribute list in 		 * the inode. 		 */
name|error
operator|=
name|xfs_attr_shortform_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOSPC
condition|)
block|{
comment|/* 			 * Commit the shortform mods, and we're done. 			 * NOTE: this is also the error path (EEXIST, etc). 			 */
name|ASSERT
argument_list|(
name|args
operator|.
name|trans
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * If this is a synchronous mount, make sure that 			 * the transaction goes to disk before returning 			 * to the user. 			 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|args
operator|.
name|trans
argument_list|)
expr_stmt|;
block|}
name|err2
operator|=
name|xfs_trans_commit
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 			 * Hit the inode change time. 			 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|flags
operator|&
name|ATTR_KERNOTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|==
literal|0
condition|?
name|err2
else|:
name|error
operator|)
return|;
block|}
comment|/* 		 * It won't fit in the shortform, transform to a leaf block. 		 * GROT: another possible req'mt for a double-split btree op. 		 */
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|.
name|flist
argument_list|,
name|args
operator|.
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_shortform_to_leaf
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|.
name|trans
argument_list|,
name|args
operator|.
name|flist
argument_list|,
operator|*
name|args
operator|.
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
operator|&
name|flist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Commit the leaf transformation.  We'll need another (linked) 		 * transaction to add the new attribute to the leaf. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_attr_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_attr_node_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * transaction goes to disk before returning to the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|args
operator|.
name|trans
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Commit the last in the sequence of transactions. 	 */
name|xfs_trans_log_inode
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Hit the inode change time. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|flags
operator|&
name|ATTR_KERNOTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
if|if
condition|(
name|args
operator|.
name|trans
condition|)
name|xfs_trans_cancel
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xfs_attr_set
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|valuelen
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cred
modifier|*
name|cred
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|>=
name|MAXNAMELEN
condition|)
return|return
name|EFAULT
return|;
comment|/* match IRIX behaviour */
name|XFS_STATS_INC
argument_list|(
name|xs_attr_set
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
name|xfs_attr_set_int
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|value
argument_list|,
name|valuelen
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic handler routine to remove a name from an attribute list.  * Transitions attribute list from Btree to shortform as necessary.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_remove_int
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|xfs_fsblock_t
name|firstblock
decl_stmt|;
name|xfs_bmap_free_t
name|flist
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
init|=
name|dp
operator|->
name|i_mount
decl_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|args
operator|.
name|name
argument_list|,
name|args
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
operator|&
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
operator|&
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_ATTR_FORK
expr_stmt|;
comment|/* 	 * Attach the dquots to the inode. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Start our first transaction of the day. 	 * 	 * All future transactions during this code must be "chained" off 	 * this one via the trans_dup() call.  All transactions will contain 	 * the inode, and the inode will always be marked with trans_ihold(). 	 * Since the inode will be locked in all transactions, we must log 	 * the inode in every transaction to let it float upward through 	 * the log. 	 */
name|args
operator|.
name|trans
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_ATTR_RM
argument_list|)
expr_stmt|;
comment|/* 	 * Root fork attributes can use reserved data blocks for this 	 * operation if necessary 	 */
if|if
condition|(
name|flags
operator|&
name|ATTR_ROOT
condition|)
name|args
operator|.
name|trans
operator|->
name|t_flags
operator||=
name|XFS_TRANS_RESERVE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_ATTRRM_SPACE_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
name|XFS_ATTRRM_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ATTRRM_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|args
operator|.
name|trans
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * No need to make quota reservations here. We expect to release some 	 * blocks not allocate in the common case. 	 */
name|xfs_trans_ijoin
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_afp
operator|->
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_shortform_remove
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_attr_leaf_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_attr_node_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * transaction goes to disk before returning to the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|args
operator|.
name|trans
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Commit the last in the sequence of transactions. 	 */
name|xfs_trans_log_inode
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Hit the inode change time. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|flags
operator|&
name|ATTR_KERNOTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
if|if
condition|(
name|args
operator|.
name|trans
condition|)
name|xfs_trans_cancel
argument_list|(
name|args
operator|.
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xfs_attr_remove
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cred
modifier|*
name|cred
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|>=
name|MAXNAMELEN
condition|)
return|return
name|EFAULT
return|;
comment|/* match IRIX behaviour */
name|XFS_STATS_INC
argument_list|(
name|xs_attr_remove
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
operator|)
return|;
block|}
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|xfs_attr_remove_int
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a list of extended attribute names and optionally  * also value lengths.  Positive return value follows the XFS  * convention of being an error, zero or negative return code  * is the length of the buffer returned (negated), indicating  * success.  */
end_comment

begin_function
name|int
name|xfs_attr_list
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|int
name|flags
parameter_list|,
name|attrlist_cursor_kern_t
modifier|*
name|cursor
parameter_list|,
name|struct
name|cred
modifier|*
name|cred
parameter_list|)
block|{
name|xfs_attr_list_context_t
name|context
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_attr_list
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the cursor. 	 */
if|if
condition|(
name|cursor
operator|->
name|pad1
operator|||
name|cursor
operator|->
name|pad2
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|cursor
operator|->
name|initted
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cursor
operator|->
name|hashval
operator|||
name|cursor
operator|->
name|blkno
operator|||
name|cursor
operator|->
name|offset
operator|)
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * Check for a properly aligned buffer. 	 */
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|buffer
operator|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
name|bufsize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize the output buffer. 	 */
name|context
operator|.
name|dp
operator|=
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|context
operator|.
name|cursor
operator|=
name|cursor
expr_stmt|;
name|context
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|context
operator|.
name|dupcnt
operator|=
literal|0
expr_stmt|;
name|context
operator|.
name|resynch
operator|=
literal|1
expr_stmt|;
name|context
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ATTR_KERNAMELS
operator|)
condition|)
block|{
name|context
operator|.
name|bufsize
operator|=
operator|(
name|bufsize
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* align */
name|context
operator|.
name|firstu
operator|=
name|context
operator|.
name|bufsize
expr_stmt|;
name|context
operator|.
name|alist
operator|=
operator|(
name|attrlist_t
operator|*
operator|)
name|buffer
expr_stmt|;
name|context
operator|.
name|alist
operator|->
name|al_count
operator|=
literal|0
expr_stmt|;
name|context
operator|.
name|alist
operator|->
name|al_more
operator|=
literal|0
expr_stmt|;
name|context
operator|.
name|alist
operator|->
name|al_offset
index|[
literal|0
index|]
operator|=
name|context
operator|.
name|bufsize
expr_stmt|;
block|}
else|else
block|{
name|context
operator|.
name|bufsize
operator|=
name|bufsize
expr_stmt|;
name|context
operator|.
name|firstu
operator|=
name|context
operator|.
name|bufsize
expr_stmt|;
name|context
operator|.
name|alist
operator|=
operator|(
name|attrlist_t
operator|*
operator|)
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
name|xfs_attr_trace_l_c
argument_list|(
literal|"syscall start"
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|error
operator|=
name|xfs_attr_shortform_list
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_attr_leaf_list
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_attr_node_list
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|xfs_attr_trace_l_c
argument_list|(
literal|"syscall end"
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
operator|.
name|flags
operator|&
operator|(
name|ATTR_KERNOVAL
operator||
name|ATTR_KERNAMELS
operator|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* must return negated buffer size or the error */
if|if
condition|(
name|context
operator|.
name|count
operator|<
literal|0
condition|)
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ERANGE
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
operator|-
name|context
operator|.
name|count
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* error */
name|xfs_attr_inactive
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|trans
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_NOT_DQATTACHED
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_LOCAL
operator|)
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
comment|/* 	 * Start our first transaction of the day. 	 * 	 * All future transactions during this code must be "chained" off 	 * this one via the trans_dup() call.  All transactions will contain 	 * the inode, and the inode will always be marked with trans_ihold(). 	 * Since the inode will be locked in all transactions, we must log 	 * the inode in every transaction to let it float upward through 	 * the log. 	 */
name|trans
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_ATTRINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|trans
argument_list|,
literal|0
argument_list|,
name|XFS_ATTRINVAL_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ATTRINVAL_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|trans
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * No need to make quota reservations here. We expect to release some 	 * blocks, not allocate, in the common case. 	 */
name|xfs_trans_ijoin
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_LOCAL
operator|)
operator|||
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|xfs_attr_root_inactive
argument_list|(
operator|&
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * signal synchronous inactive transactions unless this 	 * is a synchronous mount filesystem in which case we 	 * know that we're here because we've been called out of 	 * xfs_inactive which means that the last reference is gone 	 * and the unlink transaction has already hit the disk so 	 * async inactive transactions are safe. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_itruncate_finish
argument_list|(
operator|&
name|trans
argument_list|,
name|dp
argument_list|,
literal|0LL
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
operator|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Commit the last in the sequence of transactions. 	 */
name|xfs_trans_log_inode
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|xfs_trans_cancel
argument_list|(
name|trans
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * External routines when attribute list is inside the inode  *========================================================================*/
end_comment

begin_comment
comment|/*  * Add a name to the shortform attribute list structure  * This is the external routine.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_shortform_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|,
name|forkoff
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
name|xfs_attr_shortform_lookup
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_REPLACE
operator|)
operator|&&
operator|(
name|retval
operator|==
name|ENOATTR
operator|)
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|ATTR_CREATE
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|retval
operator|=
name|xfs_attr_shortform_remove
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|retval
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|namelen
operator|>=
name|XFS_ATTR_SF_ENTSIZE_MAX
operator|||
name|args
operator|->
name|valuelen
operator|>=
name|XFS_ATTR_SF_ENTSIZE_MAX
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
name|newsize
operator|=
name|XFS_ATTR_SF_TOTSIZE
argument_list|(
name|args
operator|->
name|dp
argument_list|)
expr_stmt|;
name|newsize
operator|+=
name|XFS_ATTR_SF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|->
name|namelen
argument_list|,
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|forkoff
operator|=
name|xfs_attr_shortform_bytesfit
argument_list|(
name|args
operator|->
name|dp
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forkoff
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
name|xfs_attr_shortform_add
argument_list|(
name|args
argument_list|,
name|forkoff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * External routines when attribute list is one block  *========================================================================*/
end_comment

begin_comment
comment|/*  * Add a name to the leaf attribute list structure  *  * This leaf block cannot have a "remote" value, we only call this routine  * if bmap_one_block() says there is only one block (ie: no remote blks).  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|error
decl_stmt|,
name|committed
decl_stmt|,
name|forkoff
decl_stmt|;
comment|/* 	 * Read the (only) block in the attribute list in. 	 */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the given attribute in the leaf block.  Figure out if 	 * the given flags produce an error or call for an atomic rename. 	 */
name|retval
operator|=
name|xfs_attr_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_REPLACE
operator|)
operator|&&
operator|(
name|retval
operator|==
name|ENOATTR
operator|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|ATTR_CREATE
condition|)
block|{
comment|/* pure create op */
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|args
operator|->
name|rename
operator|=
literal|1
expr_stmt|;
comment|/* an atomic rename */
name|args
operator|->
name|blkno2
operator|=
name|args
operator|->
name|blkno
expr_stmt|;
comment|/* set 2nd entry info*/
name|args
operator|->
name|index2
operator|=
name|args
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|rmtblkno2
operator|=
name|args
operator|->
name|rmtblkno
expr_stmt|;
name|args
operator|->
name|rmtblkcnt2
operator|=
name|args
operator|->
name|rmtblkcnt
expr_stmt|;
block|}
comment|/* 	 * Add the attribute to the leaf block, transitioning to a Btree 	 * if required. 	 */
name|retval
operator|=
name|xfs_attr_leaf_add
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|ENOSPC
condition|)
block|{
comment|/* 		 * Promote the attribute list to the Btree format, then 		 * Commit that transaction so that the node_addname() call 		 * can manage its own transactions. 		 */
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_to_node
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Commit the current trans (including the inode) and start 		 * a new one. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Fob the whole rest of the problem off on the Btree code. 		 */
name|error
operator|=
name|xfs_attr_node_addname
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Commit the transaction that added the attr name so that 	 * later routines can manage their own transactions. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If there was an out-of-line value, allocate the blocks we 	 * identified for its storage and copy the value.  This is done 	 * after we create the attribute so that we don't overflow the 	 * maximum size of a transaction and/or hit a deadlock. 	 */
if|if
condition|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_attr_rmtval_set
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If this is an atomic rename operation, we must "flip" the 	 * incomplete flags on the "new" and "old" attribute/value pairs 	 * so that one disappears and one appears atomically.  Then we 	 * must remove the "old" attribute/value pair. 	 */
if|if
condition|(
name|args
operator|->
name|rename
condition|)
block|{
comment|/* 		 * In a separate transaction, set the incomplete flag on the 		 * "old" attr and clear the incomplete flag on the "new" attr. 		 */
name|error
operator|=
name|xfs_attr_leaf_flipflags
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Dismantle the "old" attribute/value pair by removing 		 * a "remote" value (if it exists). 		 */
name|args
operator|->
name|index
operator|=
name|args
operator|->
name|index2
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|args
operator|->
name|blkno2
expr_stmt|;
name|args
operator|->
name|rmtblkno
operator|=
name|args
operator|->
name|rmtblkno2
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
name|args
operator|->
name|rmtblkcnt2
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rmtblkno
condition|)
block|{
name|error
operator|=
name|xfs_attr_rmtval_remove
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Read in the block containing the "old" attr, then 		 * remove the "old" attr from that block (neat, huh!) 		 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_attr_leaf_remove
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 		 * If the result is small enough, shrink it all into the inode. 		 */
if|if
condition|(
operator|(
name|forkoff
operator|=
name|xfs_attr_shortform_allfit
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
block|{
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_to_shortform
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|forkoff
argument_list|)
expr_stmt|;
comment|/* bp is gone due to xfs_da_shrink_inode */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 			 * bmap_finish() may have committed the last trans 			 * and started a new one.  We need the inode to be 			 * in all transactions. 			 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Commit the remove and start the next trans in series. 		 */
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Added a "remote" value, just clear the incomplete flag. 		 */
name|error
operator|=
name|xfs_attr_leaf_clearflag
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from the leaf attribute list structure  *  * This leaf block cannot have a "remote" value, we only call this routine  * if bmap_one_block() says there is only one block (ie: no remote blks).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|committed
decl_stmt|,
name|forkoff
decl_stmt|;
comment|/* 	 * Remove the attribute. 	 */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOATTR
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|xfs_attr_leaf_remove
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * If the result is small enough, shrink it all into the inode. 	 */
if|if
condition|(
operator|(
name|forkoff
operator|=
name|xfs_attr_shortform_allfit
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
block|{
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_to_shortform
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|forkoff
argument_list|)
expr_stmt|;
comment|/* bp is gone due to xfs_da_shrink_inode */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a leaf attribute list structure.  *  * This leaf block cannot have a "remote" value, we only call this routine  * if bmap_one_block() says there is only one block (ie: no remote blks).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_get
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|xfs_attr_leaf_getvalue
argument_list|(
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_attr_rmtval_get
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy out attribute entries for attr_list(), for leaf attribute lists.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_list
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|context
operator|->
name|cursor
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|NULL
argument_list|,
name|context
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_attr_leaf_list"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|context
operator|->
name|dp
operator|->
name|i_mount
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|xfs_attr_leaf_list_int
argument_list|(
name|bp
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * External routines when attribute list size> XFS_LBSIZE(mp).  *========================================================================*/
end_comment

begin_comment
comment|/*  * Add a name to a Btree-format attribute list.  *  * This will involve walking down the Btree, and may involve splitting  * leaf nodes and even splitting intermediate nodes up to and including  * the root node (a special case of an intermediate node).  *  * "Remote" attribute values confuse the issue and atomic rename operations  * add a whole extra layer of confusion on top of that.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_node_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|committed
decl_stmt|,
name|retval
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Fill in bucket of arguments/results/context to carry around. 	 */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|restart
label|:
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|mp
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_attr_node_ents
expr_stmt|;
comment|/* 	 * Search to see if name already exists, and get back a pointer 	 * to where it should go. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_REPLACE
operator|)
operator|&&
operator|(
name|retval
operator|==
name|ENOATTR
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|ATTR_CREATE
condition|)
goto|goto
name|out
goto|;
name|args
operator|->
name|rename
operator|=
literal|1
expr_stmt|;
comment|/* atomic rename op */
name|args
operator|->
name|blkno2
operator|=
name|args
operator|->
name|blkno
expr_stmt|;
comment|/* set 2nd entry info*/
name|args
operator|->
name|index2
operator|=
name|args
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|rmtblkno2
operator|=
name|args
operator|->
name|rmtblkno
expr_stmt|;
name|args
operator|->
name|rmtblkcnt2
operator|=
name|args
operator|->
name|rmtblkcnt
expr_stmt|;
name|args
operator|->
name|rmtblkno
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
name|xfs_attr_leaf_add
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|state
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|ENOSPC
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|path
operator|.
name|active
operator|==
literal|1
condition|)
block|{
comment|/* 			 * Its really a single leaf node, but it had 			 * out-of-line values so it looked like it *might* 			 * have been a b-tree. 			 */
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_to_node
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * bmap_finish() may have committed the last trans 			 * and started a new one.  We need the inode to be 			 * in all transactions. 			 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Commit the node conversion and start the next 			 * trans in the chain. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
goto|goto
name|restart
goto|;
block|}
comment|/* 		 * Split as many Btree elements as required. 		 * This code tracks the new and old attr's location 		 * in the index/blkno/rmtblkno/rmtblkcnt fields and 		 * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields. 		 */
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_split
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Addition succeeded, update Btree hashvals. 		 */
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Kill the state structure, we're done with it and need to 	 * allow the buffers to come back later. 	 */
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Commit the leaf addition or btree split and start the next 	 * trans in the chain. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If there was an out-of-line value, allocate the blocks we 	 * identified for its storage and copy the value.  This is done 	 * after we create the attribute so that we don't overflow the 	 * maximum size of a transaction and/or hit a deadlock. 	 */
if|if
condition|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_attr_rmtval_set
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If this is an atomic rename operation, we must "flip" the 	 * incomplete flags on the "new" and "old" attribute/value pairs 	 * so that one disappears and one appears atomically.  Then we 	 * must remove the "old" attribute/value pair. 	 */
if|if
condition|(
name|args
operator|->
name|rename
condition|)
block|{
comment|/* 		 * In a separate transaction, set the incomplete flag on the 		 * "old" attr and clear the incomplete flag on the "new" attr. 		 */
name|error
operator|=
name|xfs_attr_leaf_flipflags
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Dismantle the "old" attribute/value pair by removing 		 * a "remote" value (if it exists). 		 */
name|args
operator|->
name|index
operator|=
name|args
operator|->
name|index2
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|args
operator|->
name|blkno2
expr_stmt|;
name|args
operator|->
name|rmtblkno
operator|=
name|args
operator|->
name|rmtblkno2
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
name|args
operator|->
name|rmtblkcnt2
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rmtblkno
condition|)
block|{
name|error
operator|=
name|xfs_attr_rmtval_remove
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Re-find the "old" attribute entry after any split ops. 		 * The INCOMPLETE flag means that we will find the "old" 		 * attr, not the "new" one. 		 */
name|args
operator|->
name|flags
operator||=
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|mp
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_attr_node_ents
expr_stmt|;
name|state
operator|->
name|inleaf
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Remove the name and update the hashvals in the tree. 		 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_remove
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if the tree needs to be collapsed. 		 */
if|if
condition|(
name|retval
operator|&&
operator|(
name|state
operator|->
name|path
operator|.
name|active
operator|>
literal|1
operator|)
condition|)
block|{
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_join
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * bmap_finish() may have committed the last trans 			 * and started a new one.  We need the inode to be 			 * in all transactions. 			 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Commit and start the next trans in the chain. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Added a "remote" value, just clear the incomplete flag. 		 */
name|error
operator|=
name|xfs_attr_leaf_clearflag
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|retval
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|state
condition|)
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from a B-tree attribute list.  *  * This will involve walking down the Btree, and may involve joining  * leaf nodes and even joining intermediate nodes up to and including  * the root node (a special case of an intermediate node).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_node_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|error
decl_stmt|,
name|committed
decl_stmt|,
name|forkoff
decl_stmt|;
comment|/* 	 * Tie a string around our finger to remind us where we are. 	 */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_attr_node_ents
expr_stmt|;
comment|/* 	 * Search to see if name exists, and get back a pointer to it. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|retval
operator|!=
name|EEXIST
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|retval
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If there is an out-of-line value, de-allocate the blocks. 	 * This is done before we remove the attribute so that we don't 	 * overflow the maximum size of a transaction and/or hit a deadlock. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Fill in disk block numbers in the state structure 		 * so that we can get the buffers back after we commit 		 * several transactions in the following calls. 		 */
name|error
operator|=
name|xfs_attr_fillstate
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Mark the attribute as INCOMPLETE, then bunmapi() the 		 * remote value. 		 */
name|error
operator|=
name|xfs_attr_leaf_setflag
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|xfs_attr_rmtval_remove
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Refill the state structure with buffers, the prior calls 		 * released our buffers. 		 */
name|error
operator|=
name|xfs_attr_refillstate
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Remove the name and update the hashvals in the tree. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_attr_leaf_remove
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if the tree needs to be collapsed. 	 */
if|if
condition|(
name|retval
operator|&&
operator|(
name|state
operator|->
name|path
operator|.
name|active
operator|>
literal|1
operator|)
condition|)
block|{
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_join
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Commit the Btree join operation and start a new trans. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the result is small enough, push it all into the inode. 	 */
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
condition|)
block|{
comment|/* 		 * Have to get rid of the copy of this dabuf in the state. 		 */
name|ASSERT
argument_list|(
name|state
operator|->
name|path
operator|.
name|active
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
operator|(
operator|(
name|xfs_attr_leafblock_t
operator|*
operator|)
name|bp
operator|->
name|data
operator|)
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|forkoff
operator|=
name|xfs_attr_shortform_allfit
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
block|{
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_to_shortform
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|forkoff
argument_list|)
expr_stmt|;
comment|/* bp is gone due to xfs_da_shrink_inode */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * bmap_finish() may have committed the last trans 			 * and started a new one.  We need the inode to be 			 * in all transactions. 			 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the disk block numbers in the state structure for the buffers  * that are attached to the state structure.  * This is done so that we can quickly reattach ourselves to those buffers  * after some set of transaction commits have released these buffers.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_fillstate
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
block|{
name|xfs_da_state_path_t
modifier|*
name|path
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* 	 * Roll down the "path" in the state structure, storing the on-disk 	 * block number for those buffers in the "path". 	 */
name|path
operator|=
operator|&
name|state
operator|->
name|path
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|path
operator|->
name|active
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|path
operator|->
name|active
operator|<
name|XFS_DA_NODE_MAXDEPTH
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|path
operator|->
name|blk
operator|,
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|path
operator|->
name|active
condition|;
name|blk
operator|++
operator|,
name|level
operator|++
control|)
block|{
if|if
condition|(
name|blk
operator|->
name|bp
condition|)
block|{
name|blk
operator|->
name|disk_blkno
operator|=
name|xfs_da_blkno
argument_list|(
name|blk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|blk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|blk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|blk
operator|->
name|disk_blkno
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Roll down the "altpath" in the state structure, storing the on-disk 	 * block number for those buffers in the "altpath". 	 */
name|path
operator|=
operator|&
name|state
operator|->
name|altpath
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|path
operator|->
name|active
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|path
operator|->
name|active
operator|<
name|XFS_DA_NODE_MAXDEPTH
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|path
operator|->
name|blk
operator|,
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|path
operator|->
name|active
condition|;
name|blk
operator|++
operator|,
name|level
operator|++
control|)
block|{
if|if
condition|(
name|blk
operator|->
name|bp
condition|)
block|{
name|blk
operator|->
name|disk_blkno
operator|=
name|xfs_da_blkno
argument_list|(
name|blk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|blk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|blk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|blk
operator|->
name|disk_blkno
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reattach the buffers to the state structure based on the disk block  * numbers stored in the state structure.  * This is done after some set of transaction commits have released those  * buffers from our grip.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_refillstate
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
block|{
name|xfs_da_state_path_t
modifier|*
name|path
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|int
name|level
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Roll down the "path" in the state structure, storing the on-disk 	 * block number for those buffers in the "path". 	 */
name|path
operator|=
operator|&
name|state
operator|->
name|path
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|path
operator|->
name|active
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|path
operator|->
name|active
operator|<
name|XFS_DA_NODE_MAXDEPTH
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|path
operator|->
name|blk
operator|,
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|path
operator|->
name|active
condition|;
name|blk
operator|++
operator|,
name|level
operator|++
control|)
block|{
if|if
condition|(
name|blk
operator|->
name|disk_blkno
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|args
operator|->
name|dp
argument_list|,
name|blk
operator|->
name|blkno
argument_list|,
name|blk
operator|->
name|disk_blkno
argument_list|,
operator|&
name|blk
operator|->
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|blk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Roll down the "altpath" in the state structure, storing the on-disk 	 * block number for those buffers in the "altpath". 	 */
name|path
operator|=
operator|&
name|state
operator|->
name|altpath
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|path
operator|->
name|active
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|path
operator|->
name|active
operator|<
name|XFS_DA_NODE_MAXDEPTH
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|path
operator|->
name|blk
operator|,
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|path
operator|->
name|active
condition|;
name|blk
operator|++
operator|,
name|level
operator|++
control|)
block|{
if|if
condition|(
name|blk
operator|->
name|disk_blkno
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|args
operator|->
name|dp
argument_list|,
name|blk
operator|->
name|blkno
argument_list|,
name|blk
operator|->
name|disk_blkno
argument_list|,
operator|&
name|blk
operator|->
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|blk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a filename in a node attribute list.  *  * This routine gets called for any attribute fork that has more than one  * block, ie: both true Btree attr lists and for single-leaf-blocks with  * "remote" values taking up more blocks.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_node_get
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_attr_node_ents
expr_stmt|;
comment|/* 	 * Search to see if name exists, and get back a pointer to it. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|retval
operator|=
name|error
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
comment|/* 		 * Get the value, local or "remote" 		 */
name|retval
operator|=
name|xfs_attr_leaf_getvalue
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
operator|&&
operator|(
name|args
operator|->
name|rmtblkno
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
operator|)
condition|)
block|{
name|retval
operator|=
name|xfs_attr_rmtval_get
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If not in a transaction, we have to release all the buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|path
operator|.
name|active
condition|;
name|i
operator|++
control|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_attr_node_list
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|)
block|{
name|attrlist_cursor_kern_t
modifier|*
name|cursor
decl_stmt|;
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|cursor
operator|=
name|context
operator|->
name|cursor
expr_stmt|;
name|cursor
operator|->
name|initted
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Do all sorts of validation on the passed-in cursor structure. 	 * If anything is amiss, ignore the cursor and look up the hashval 	 * starting from the btree root. 	 */
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cursor
operator|->
name|blkno
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|NULL
argument_list|,
name|context
operator|->
name|dp
argument_list|,
name|cursor
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EFSCORRUPTED
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bp
condition|)
block|{
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
condition|)
block|{
case|case
name|XFS_DA_NODE_MAGIC
case|:
name|xfs_attr_trace_l_cn
argument_list|(
literal|"wrong blk"
argument_list|,
name|context
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|XFS_ATTR_LEAF_MAGIC
case|:
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|cursor
operator|->
name|hashval
operator|>
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
condition|)
block|{
name|xfs_attr_trace_l_cl
argument_list|(
literal|"wrong blk"
argument_list|,
name|context
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor
operator|->
name|hashval
operator|<=
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|)
condition|)
block|{
name|xfs_attr_trace_l_cl
argument_list|(
literal|"maybe wrong blk"
argument_list|,
name|context
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|xfs_attr_trace_l_c
argument_list|(
literal|"wrong blk - ??"
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * We did not find what we expected given the cursor's contents, 	 * so we start from the top and work down based on the hash value. 	 * Note that start of node block is same as start of leaf block. 	 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|cursor
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|NULL
argument_list|,
name|context
operator|->
name|dp
argument_list|,
name|cursor
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|unlikely
argument_list|(
name|bp
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_attr_node_list(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|context
operator|->
name|dp
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
block|}
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
condition|)
break|break;
if|if
condition|(
name|unlikely
argument_list|(
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_DA_NODE_MAGIC
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_attr_node_list(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|context
operator|->
name|dp
operator|->
name|i_mount
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
block|}
name|btree
operator|=
name|node
operator|->
name|btree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|btree
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cursor
operator|->
name|hashval
operator|<=
name|be32_to_cpu
argument_list|(
name|btree
operator|->
name|hashval
argument_list|)
condition|)
block|{
name|cursor
operator|->
name|blkno
operator|=
name|be32_to_cpu
argument_list|(
name|btree
operator|->
name|before
argument_list|)
expr_stmt|;
name|xfs_attr_trace_l_cb
argument_list|(
literal|"descending"
argument_list|,
name|context
argument_list|,
name|btree
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Roll upward through the blocks, processing each leaf block in 	 * order.  As long as there is space in the result buffer, keep 	 * adding the information. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_attr_node_list(4)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|context
operator|->
name|dp
operator|->
name|i_mount
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|xfs_attr_leaf_list_int
argument_list|(
name|bp
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
condition|)
break|break;
comment|/* not really an error, buffer full or EOF */
name|cursor
operator|->
name|blkno
operator|=
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|NULL
argument_list|,
name|context
operator|->
name|dp
argument_list|,
name|cursor
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|bp
operator|==
name|NULL
operator|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_attr_node_list(5)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|context
operator|->
name|dp
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
block|}
block|}
name|xfs_da_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * External routines for manipulating out-of-line attribute values.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Read the value associated with an attribute from the out-of-line buffer  * that we stored it in.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_rmtval_get
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_bmbt_irec_t
name|map
index|[
name|ATTR_RMTVALUE_MAPSIZE
index|]
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_daddr_t
name|dblkno
decl_stmt|;
name|xfs_caddr_t
name|dst
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|nmap
decl_stmt|,
name|error
decl_stmt|,
name|tmp
decl_stmt|,
name|valuelen
decl_stmt|,
name|blkcnt
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dablk_t
name|lblkno
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|dst
operator|=
name|args
operator|->
name|value
expr_stmt|;
name|valuelen
operator|=
name|args
operator|->
name|valuelen
expr_stmt|;
name|lblkno
operator|=
name|args
operator|->
name|rmtblkno
expr_stmt|;
while|while
condition|(
name|valuelen
operator|>
literal|0
condition|)
block|{
name|nmap
operator|=
name|ATTR_RMTVALUE_MAPSIZE
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|lblkno
argument_list|,
name|args
operator|->
name|rmtblkcnt
argument_list|,
name|XFS_BMAPI_ATTRFORK
operator||
name|XFS_BMAPI_METADATA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|nmap
operator|>=
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nmap
operator|)
operator|&&
operator|(
name|valuelen
operator|>
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
operator|(
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|)
operator|&&
operator|(
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|)
argument_list|)
expr_stmt|;
name|dblkno
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|blkcnt
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|dblkno
argument_list|,
name|blkcnt
argument_list|,
name|XFS_BUF_LOCK
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tmp
operator|=
operator|(
name|valuelen
operator|<
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
operator|)
condition|?
name|valuelen
else|:
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_biomove
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|,
name|dst
argument_list|,
name|XFS_B_READ
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|tmp
expr_stmt|;
name|valuelen
operator|-=
name|tmp
expr_stmt|;
name|lblkno
operator|+=
name|map
index|[
name|i
index|]
operator|.
name|br_blockcount
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|valuelen
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the value associated with an attribute into the out-of-line buffer  * that we have defined for it.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_rmtval_set
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_fileoff_t
name|lfileoff
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
name|xfs_daddr_t
name|dblkno
decl_stmt|;
name|xfs_caddr_t
name|src
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_dablk_t
name|lblkno
decl_stmt|;
name|int
name|blkcnt
decl_stmt|,
name|valuelen
decl_stmt|,
name|nmap
decl_stmt|,
name|error
decl_stmt|,
name|tmp
decl_stmt|,
name|committed
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|src
operator|=
name|args
operator|->
name|value
expr_stmt|;
comment|/* 	 * Find a "hole" in the attribute address space large enough for 	 * us to drop the new attribute's value into. 	 */
name|blkcnt
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|lfileoff
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_bmap_first_unused
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|blkcnt
argument_list|,
operator|&
name|lfileoff
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|args
operator|->
name|rmtblkno
operator|=
name|lblkno
operator|=
operator|(
name|xfs_dablk_t
operator|)
name|lfileoff
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
name|blkcnt
expr_stmt|;
comment|/* 	 * Roll through the "value", allocating blocks on disk as required. 	 */
while|while
condition|(
name|blkcnt
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Allocate a single extent, up to the size of the value. 		 */
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|nmap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|lblkno
argument_list|,
name|blkcnt
argument_list|,
name|XFS_BMAPI_ATTRFORK
operator||
name|XFS_BMAPI_METADATA
operator||
name|XFS_BMAPI_WRITE
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|total
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|args
operator|->
name|flist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|nmap
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|map
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|)
operator|&&
operator|(
name|map
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|)
argument_list|)
expr_stmt|;
name|lblkno
operator|+=
name|map
operator|.
name|br_blockcount
expr_stmt|;
name|blkcnt
operator|-=
name|map
operator|.
name|br_blockcount
expr_stmt|;
comment|/* 		 * Start the next trans in the chain. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Roll through the "value", copying the attribute value to the 	 * already-allocated blocks.  Blocks are written synchronously 	 * so that we can know they are all on disk before we turn off 	 * the INCOMPLETE flag. 	 */
name|lblkno
operator|=
name|args
operator|->
name|rmtblkno
expr_stmt|;
name|valuelen
operator|=
name|args
operator|->
name|valuelen
expr_stmt|;
while|while
condition|(
name|valuelen
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Try to remember where we decided to put the value. 		 */
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|nmap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|NULL
argument_list|,
name|dp
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|lblkno
argument_list|,
name|args
operator|->
name|rmtblkcnt
argument_list|,
name|XFS_BMAPI_ATTRFORK
operator||
name|XFS_BMAPI_METADATA
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|nmap
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|map
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|)
operator|&&
operator|(
name|map
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|)
argument_list|)
expr_stmt|;
name|dblkno
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|map
operator|.
name|br_startblock
argument_list|)
operator|,
name|blkcnt
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|map
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_buf_get_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|dblkno
argument_list|,
name|blkcnt
argument_list|,
name|XFS_BUF_LOCK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|valuelen
operator|<
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
operator|)
condition|?
name|valuelen
else|:
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_biomove
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|,
name|src
argument_list|,
name|XFS_B_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
condition|)
name|xfs_biozero
argument_list|(
name|bp
argument_list|,
name|tmp
argument_list|,
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
operator|-
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
block|{
comment|/* GROT: NOTE: synchronous write */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|src
operator|+=
name|tmp
expr_stmt|;
name|valuelen
operator|-=
name|tmp
expr_stmt|;
name|lblkno
operator|+=
name|map
operator|.
name|br_blockcount
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|valuelen
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the value associated with an attribute by deleting the  * out-of-line buffer that it is stored on.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_rmtval_remove
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_daddr_t
name|dblkno
decl_stmt|;
name|xfs_dablk_t
name|lblkno
decl_stmt|;
name|int
name|valuelen
decl_stmt|,
name|blkcnt
decl_stmt|,
name|nmap
decl_stmt|,
name|error
decl_stmt|,
name|done
decl_stmt|,
name|committed
decl_stmt|;
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * Roll through the "value", invalidating the attribute value's 	 * blocks. 	 */
name|lblkno
operator|=
name|args
operator|->
name|rmtblkno
expr_stmt|;
name|valuelen
operator|=
name|args
operator|->
name|rmtblkcnt
expr_stmt|;
while|while
condition|(
name|valuelen
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Try to remember where we decided to put the value. 		 */
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|nmap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|NULL
argument_list|,
name|args
operator|->
name|dp
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|lblkno
argument_list|,
name|args
operator|->
name|rmtblkcnt
argument_list|,
name|XFS_BMAPI_ATTRFORK
operator||
name|XFS_BMAPI_METADATA
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|args
operator|->
name|flist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|nmap
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|map
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|)
operator|&&
operator|(
name|map
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|)
argument_list|)
expr_stmt|;
name|dblkno
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|map
operator|.
name|br_startblock
argument_list|)
operator|,
name|blkcnt
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|map
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
comment|/* 		 * If the "remote" value is in the cache, remove it. 		 */
name|bp
operator|=
name|xfs_incore
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|dblkno
argument_list|,
name|blkcnt
argument_list|,
name|XFS_INCORE_TRYLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
name|valuelen
operator|-=
name|map
operator|.
name|br_blockcount
expr_stmt|;
name|lblkno
operator|+=
name|map
operator|.
name|br_blockcount
expr_stmt|;
block|}
comment|/* 	 * Keep de-allocating extents until the remote-value region is gone. 	 */
name|lblkno
operator|=
name|args
operator|->
name|rmtblkno
expr_stmt|;
name|blkcnt
operator|=
name|args
operator|->
name|rmtblkcnt
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|XFS_BMAP_INIT
argument_list|(
name|args
operator|->
name|flist
argument_list|,
name|args
operator|->
name|firstblock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bunmapi
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|lblkno
argument_list|,
name|blkcnt
argument_list|,
name|XFS_BMAPI_ATTRFORK
operator||
name|XFS_BMAPI_METADATA
argument_list|,
literal|1
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|flist
argument_list|,
name|NULL
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|*
name|args
operator|->
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
name|args
operator|->
name|trans
operator|=
name|NULL
expr_stmt|;
name|xfs_bmap_cancel
argument_list|(
name|args
operator|->
name|flist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * bmap_finish() may have committed the last trans and started 		 * a new one.  We need the inode to be in all transactions. 		 */
if|if
condition|(
name|committed
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Close out trans and start the next one in the chain. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_ATTR_TRACE
argument_list|)
end_if

begin_comment
comment|/*  * Add a trace buffer entry for an attr_list context structure.  */
end_comment

begin_function
name|void
name|xfs_attr_trace_l_c
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|xfs_attr_list_context
modifier|*
name|context
parameter_list|)
block|{
name|xfs_attr_trace_enter
argument_list|(
name|XFS_ATTR_KTRACE_L_C
argument_list|,
name|where
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dp
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|hashval
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|blkno
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|offset
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|alist
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|bufsize
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|count
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|firstu
argument_list|,
operator|(
name|__psunsigned_t
operator|)
operator|(
operator|(
name|context
operator|->
name|count
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
operator|(
name|ATTR_KERNAMELS
operator||
name|ATTR_KERNOVAL
operator|)
operator|)
operator|)
condition|?
operator|(
name|ATTR_ENTRY
argument_list|(
name|context
operator|->
name|alist
argument_list|,
name|context
operator|->
name|count
operator|-
literal|1
argument_list|)
operator|->
name|a_valuelen
operator|)
else|:
literal|0
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dupcnt
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|flags
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|NULL
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|NULL
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for a context structure and a Btree node.  */
end_comment

begin_function
name|void
name|xfs_attr_trace_l_cn
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|xfs_attr_list_context
modifier|*
name|context
parameter_list|,
name|struct
name|xfs_da_intnode
modifier|*
name|node
parameter_list|)
block|{
name|xfs_attr_trace_enter
argument_list|(
name|XFS_ATTR_KTRACE_L_CN
argument_list|,
name|where
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dp
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|hashval
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|blkno
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|offset
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|alist
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|bufsize
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|count
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|firstu
argument_list|,
operator|(
name|__psunsigned_t
operator|)
operator|(
operator|(
name|context
operator|->
name|count
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
operator|(
name|ATTR_KERNAMELS
operator||
name|ATTR_KERNOVAL
operator|)
operator|)
operator|)
condition|?
operator|(
name|ATTR_ENTRY
argument_list|(
name|context
operator|->
name|alist
argument_list|,
name|context
operator|->
name|count
operator|-
literal|1
argument_list|)
operator|->
name|a_valuelen
operator|)
else|:
literal|0
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dupcnt
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|flags
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|)
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|btree
index|[
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for a context structure and a Btree element.  */
end_comment

begin_function
name|void
name|xfs_attr_trace_l_cb
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|xfs_attr_list_context
modifier|*
name|context
parameter_list|,
name|struct
name|xfs_da_node_entry
modifier|*
name|btree
parameter_list|)
block|{
name|xfs_attr_trace_enter
argument_list|(
name|XFS_ATTR_KTRACE_L_CB
argument_list|,
name|where
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dp
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|hashval
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|blkno
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|offset
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|alist
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|bufsize
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|count
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|firstu
argument_list|,
operator|(
name|__psunsigned_t
operator|)
operator|(
operator|(
name|context
operator|->
name|count
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
operator|(
name|ATTR_KERNAMELS
operator||
name|ATTR_KERNOVAL
operator|)
operator|)
operator|)
condition|?
operator|(
name|ATTR_ENTRY
argument_list|(
name|context
operator|->
name|alist
argument_list|,
name|context
operator|->
name|count
operator|-
literal|1
argument_list|)
operator|->
name|a_valuelen
operator|)
else|:
literal|0
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dupcnt
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|flags
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|btree
operator|->
name|hashval
argument_list|)
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|btree
operator|->
name|before
argument_list|)
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for a context structure and a leaf block.  */
end_comment

begin_function
name|void
name|xfs_attr_trace_l_cl
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|struct
name|xfs_attr_list_context
modifier|*
name|context
parameter_list|,
name|struct
name|xfs_attr_leafblock
modifier|*
name|leaf
parameter_list|)
block|{
name|xfs_attr_trace_enter
argument_list|(
name|XFS_ATTR_KTRACE_L_CL
argument_list|,
name|where
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dp
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|hashval
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|blkno
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|cursor
operator|->
name|offset
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|alist
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|bufsize
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|count
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|firstu
argument_list|,
operator|(
name|__psunsigned_t
operator|)
operator|(
operator|(
name|context
operator|->
name|count
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
operator|(
name|ATTR_KERNAMELS
operator||
name|ATTR_KERNOVAL
operator|)
operator|)
operator|)
condition|?
operator|(
name|ATTR_ENTRY
argument_list|(
name|context
operator|->
name|alist
argument_list|,
name|context
operator|->
name|count
operator|-
literal|1
argument_list|)
operator|->
name|a_valuelen
operator|)
else|:
literal|0
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|dupcnt
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|context
operator|->
name|flags
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|)
argument_list|,
operator|(
name|__psunsigned_t
operator|)
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for the arguments given to the routine,  * generic form.  */
end_comment

begin_function
name|void
name|xfs_attr_trace_enter
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|where
parameter_list|,
name|__psunsigned_t
name|a2
parameter_list|,
name|__psunsigned_t
name|a3
parameter_list|,
name|__psunsigned_t
name|a4
parameter_list|,
name|__psunsigned_t
name|a5
parameter_list|,
name|__psunsigned_t
name|a6
parameter_list|,
name|__psunsigned_t
name|a7
parameter_list|,
name|__psunsigned_t
name|a8
parameter_list|,
name|__psunsigned_t
name|a9
parameter_list|,
name|__psunsigned_t
name|a10
parameter_list|,
name|__psunsigned_t
name|a11
parameter_list|,
name|__psunsigned_t
name|a12
parameter_list|,
name|__psunsigned_t
name|a13
parameter_list|,
name|__psunsigned_t
name|a14
parameter_list|,
name|__psunsigned_t
name|a15
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|xfs_attr_trace_buf
argument_list|)
expr_stmt|;
name|ktrace_enter
argument_list|(
name|xfs_attr_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|__psunsigned_t
operator|)
name|type
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a2
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a3
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a4
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a5
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a6
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a7
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a8
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a9
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a10
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a11
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a12
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a13
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a14
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a15
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_ATTR_TRACE */
end_comment

begin_comment
comment|/*========================================================================  * System (pseudo) namespace attribute interface routines.  *========================================================================*/
end_comment

begin_function
name|STATIC
name|int
name|posix_acl_access_set
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
return|return
name|xfs_acl_vset
argument_list|(
name|vp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_access_remove
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
return|return
name|xfs_acl_vremove
argument_list|(
name|vp
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_access_get
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
return|return
name|xfs_acl_vget
argument_list|(
name|vp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_access_exists
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
name|xfs_acl_vhasacl_access
argument_list|(
name|vp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_default_set
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
return|return
name|xfs_acl_vset
argument_list|(
name|vp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|_ACL_TYPE_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_default_get
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
return|return
name|xfs_acl_vget
argument_list|(
name|vp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|_ACL_TYPE_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_default_remove
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
return|return
name|xfs_acl_vremove
argument_list|(
name|vp
argument_list|,
name|_ACL_TYPE_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|posix_acl_default_exists
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
name|xfs_acl_vhasacl_default
argument_list|(
name|vp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|STATIC
name|struct
name|attrnames
name|posix_acl_access
init|=
block|{
operator|.
name|attr_name
operator|=
literal|"posix_acl_access"
block|,
operator|.
name|attr_namelen
operator|=
sizeof|sizeof
argument_list|(
literal|"posix_acl_access"
argument_list|)
operator|-
literal|1
block|,
operator|.
name|attr_get
operator|=
name|posix_acl_access_get
block|,
operator|.
name|attr_set
operator|=
name|posix_acl_access_set
block|,
operator|.
name|attr_remove
operator|=
name|posix_acl_access_remove
block|,
operator|.
name|attr_exists
operator|=
name|posix_acl_access_exists
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|attrnames
name|posix_acl_default
init|=
block|{
operator|.
name|attr_name
operator|=
literal|"posix_acl_default"
block|,
operator|.
name|attr_namelen
operator|=
sizeof|sizeof
argument_list|(
literal|"posix_acl_default"
argument_list|)
operator|-
literal|1
block|,
operator|.
name|attr_get
operator|=
name|posix_acl_default_get
block|,
operator|.
name|attr_set
operator|=
name|posix_acl_default_set
block|,
operator|.
name|attr_remove
operator|=
name|posix_acl_default_remove
block|,
operator|.
name|attr_exists
operator|=
name|posix_acl_default_exists
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|attrnames
modifier|*
name|attr_system_names
index|[]
init|=
block|{
operator|&
name|posix_acl_access
block|,
operator|&
name|posix_acl_default
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*========================================================================  * Namespace-prefix-style attribute name interface routines.  *========================================================================*/
end_comment

begin_function
name|STATIC
name|int
name|attr_generic_set
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|XVOP_ATTR_SET
argument_list|(
name|vp
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|xflags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_generic_get
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|asize
init|=
name|size
decl_stmt|;
name|XVOP_ATTR_GET
argument_list|(
name|vp
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
operator|&
name|asize
argument_list|,
name|xflags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
name|asize
return|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_generic_remove
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|XVOP_ATTR_REMOVE
argument_list|(
name|vp
argument_list|,
name|name
argument_list|,
name|xflags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_generic_listadd
parameter_list|(
name|attrnames_t
modifier|*
name|prefix
parameter_list|,
name|attrnames_t
modifier|*
name|namesp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ssize_t
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
operator|*
name|result
decl_stmt|;
operator|*
name|result
operator|+=
name|prefix
operator|->
name|attr_namelen
expr_stmt|;
operator|*
name|result
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|result
operator|>
name|size
condition|)
return|return
operator|-
name|ERANGE
return|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|prefix
operator|->
name|attr_name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|prefix
operator|->
name|attr_namelen
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|namesp
operator|->
name|attr_name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_system_list
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|ssize_t
modifier|*
name|result
parameter_list|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATTR_SYSCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|namesp
operator|=
name|attr_system_names
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|namesp
operator|->
name|attr_exists
operator|||
operator|!
name|namesp
operator|->
name|attr_exists
argument_list|(
name|vp
argument_list|)
condition|)
continue|continue;
name|error
operator|=
name|attr_generic_listadd
argument_list|(
operator|&
name|attr_system
argument_list|,
name|namesp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|attr_generic_list
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|,
name|ssize_t
modifier|*
name|result
parameter_list|)
block|{
name|attrlist_cursor_kern_t
name|cursor
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|XVOP_ATTR_LIST
argument_list|(
name|vp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|xflags
argument_list|,
operator|&
name|cursor
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
return|return
operator|-
name|error
return|;
operator|*
name|result
operator|=
operator|-
name|error
expr_stmt|;
return|return
name|attr_system_list
argument_list|(
name|vp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_function
name|attrnames_t
modifier|*
name|attr_lookup_namespace
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|attrnames
modifier|*
modifier|*
name|names
parameter_list|,
name|int
name|nnames
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nnames
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|names
index|[
name|i
index|]
operator|->
name|attr_name
argument_list|,
name|names
index|[
name|i
index|]
operator|->
name|attr_namelen
argument_list|)
condition|)
return|return
name|names
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Some checks to prevent people abusing EAs to get over quota:  * - Don't allow modifying user EAs on devices/symlinks;  * - Don't allow modifying user EAs if sticky bit set;  */
end_comment

begin_function
name|STATIC
name|int
name|attr_user_capable
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XXXKAN
name|struct
name|inode
modifier|*
name|inode
init|=
name|vn_to_inode
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
operator|||
name|IS_APPEND
argument_list|(
name|inode
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
operator|&&
operator|(
name|inode
operator|->
name|i_mode
operator|&
name|S_ISVTX
operator|)
operator|&&
operator|(
name|current_fsuid
argument_list|(
name|cred
argument_list|)
operator|!=
name|inode
operator|->
name|i_uid
operator|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_FOWNER
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_trusted_capable
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XXXKAN
name|struct
name|inode
modifier|*
name|inode
init|=
name|vn_to_inode
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
operator|||
name|IS_APPEND
argument_list|(
name|inode
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_secure_capable
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|)
block|{
return|return
operator|-
name|ENOSECURITY
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_system_set
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|xflags
operator|&
name|ATTR_CREATE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|namesp
operator|=
name|attr_lookup_namespace
argument_list|(
name|name
argument_list|,
name|attr_system_names
argument_list|,
name|ATTR_SYSCOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namesp
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
name|error
operator|=
name|namesp
operator|->
name|attr_set
argument_list|(
name|vp
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|xflags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XXXKAN
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|vn_revalidate
argument_list|(
name|vp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_system_get
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
name|namesp
operator|=
name|attr_lookup_namespace
argument_list|(
name|name
argument_list|,
name|attr_system_names
argument_list|,
name|ATTR_SYSCOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namesp
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
return|return
name|namesp
operator|->
name|attr_get
argument_list|(
name|vp
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|xflags
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|attr_system_remove
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|xflags
parameter_list|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
name|namesp
operator|=
name|attr_lookup_namespace
argument_list|(
name|name
argument_list|,
name|attr_system_names
argument_list|,
name|ATTR_SYSCOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|namesp
condition|)
return|return
operator|-
name|EOPNOTSUPP
return|;
return|return
name|namesp
operator|->
name|attr_remove
argument_list|(
name|vp
argument_list|,
name|name
argument_list|,
name|xflags
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|attrnames
name|attr_system
init|=
block|{
operator|.
name|attr_name
operator|=
literal|"system."
block|,
operator|.
name|attr_namelen
operator|=
sizeof|sizeof
argument_list|(
literal|"system."
argument_list|)
operator|-
literal|1
block|,
operator|.
name|attr_flag
operator|=
name|ATTR_SYSTEM
block|,
operator|.
name|attr_get
operator|=
name|attr_system_get
block|,
operator|.
name|attr_set
operator|=
name|attr_system_set
block|,
operator|.
name|attr_remove
operator|=
name|attr_system_remove
block|,
operator|.
name|attr_capable
operator|=
operator|(
name|attrcapable_t
operator|)
name|fs_noerr
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attrnames
name|attr_trusted
init|=
block|{
operator|.
name|attr_name
operator|=
literal|"trusted."
block|,
operator|.
name|attr_namelen
operator|=
sizeof|sizeof
argument_list|(
literal|"trusted."
argument_list|)
operator|-
literal|1
block|,
operator|.
name|attr_flag
operator|=
name|ATTR_ROOT
block|,
operator|.
name|attr_get
operator|=
name|attr_generic_get
block|,
operator|.
name|attr_set
operator|=
name|attr_generic_set
block|,
operator|.
name|attr_remove
operator|=
name|attr_generic_remove
block|,
operator|.
name|attr_capable
operator|=
name|attr_trusted_capable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attrnames
name|attr_secure
init|=
block|{
operator|.
name|attr_name
operator|=
literal|"security."
block|,
operator|.
name|attr_namelen
operator|=
sizeof|sizeof
argument_list|(
literal|"security."
argument_list|)
operator|-
literal|1
block|,
operator|.
name|attr_flag
operator|=
name|ATTR_SECURE
block|,
operator|.
name|attr_get
operator|=
name|attr_generic_get
block|,
operator|.
name|attr_set
operator|=
name|attr_generic_set
block|,
operator|.
name|attr_remove
operator|=
name|attr_generic_remove
block|,
operator|.
name|attr_capable
operator|=
name|attr_secure_capable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attrnames
name|attr_user
init|=
block|{
operator|.
name|attr_name
operator|=
literal|"user."
block|,
operator|.
name|attr_namelen
operator|=
sizeof|sizeof
argument_list|(
literal|"user."
argument_list|)
operator|-
literal|1
block|,
operator|.
name|attr_get
operator|=
name|attr_generic_get
block|,
operator|.
name|attr_set
operator|=
name|attr_generic_set
block|,
operator|.
name|attr_remove
operator|=
name|attr_generic_remove
block|,
operator|.
name|attr_capable
operator|=
name|attr_user_capable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attrnames
modifier|*
name|attr_namespaces
index|[]
init|=
block|{
operator|&
name|attr_system
block|,
operator|&
name|attr_trusted
block|,
operator|&
name|attr_secure
block|,
operator|&
name|attr_user
block|}
decl_stmt|;
end_decl_stmt

end_unit

