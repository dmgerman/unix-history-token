begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_buf_item_zone
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
end_ifdef

begin_comment
comment|/*  * This function uses an alternate strategy for tracking the bytes  * that the user requests to be logged.  This can then be used  * in conjunction with the bli_orig array in the buf log item to  * catch bugs in our callers' code.  *  * We also double check the bits set in xfs_buf_item_log using a  * simple algorithm to check that every byte is accounted for.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_log_debug
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|uint
name|first
parameter_list|,
name|uint
name|last
parameter_list|)
block|{
name|uint
name|x
decl_stmt|;
name|uint
name|byte
decl_stmt|;
name|uint
name|nbytes
decl_stmt|;
name|uint
name|chunk_num
decl_stmt|;
name|uint
name|word_num
decl_stmt|;
name|uint
name|bit_num
decl_stmt|;
name|uint
name|bit_set
decl_stmt|;
name|uint
modifier|*
name|wordp
decl_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_logged
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|byte
operator|=
name|first
expr_stmt|;
name|nbytes
operator|=
name|last
operator|-
name|first
operator|+
literal|1
expr_stmt|;
name|bfset
argument_list|(
name|bip
operator|->
name|bli_logged
argument_list|,
name|first
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nbytes
condition|;
name|x
operator|++
control|)
block|{
name|chunk_num
operator|=
name|byte
operator|>>
name|XFS_BLI_SHIFT
expr_stmt|;
name|word_num
operator|=
name|chunk_num
operator|>>
name|BIT_TO_WORD_SHIFT
expr_stmt|;
name|bit_num
operator|=
name|chunk_num
operator|&
operator|(
name|NBWORD
operator|-
literal|1
operator|)
expr_stmt|;
name|wordp
operator|=
operator|&
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
index|[
name|word_num
index|]
operator|)
expr_stmt|;
name|bit_set
operator|=
operator|*
name|wordp
operator|&
operator|(
literal|1
operator|<<
name|bit_num
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bit_set
argument_list|)
expr_stmt|;
name|byte
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function is called when we flush something into a buffer without  * logging it.  This happens for things like inodes which are logged  * separately from the buffer.  */
end_comment

begin_function
name|void
name|xfs_buf_item_flush_log_debug
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|uint
name|first
parameter_list|,
name|uint
name|last
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|uint
name|nbytes
decl_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|bip
operator|->
name|bli_item
operator|.
name|li_type
operator|!=
name|XFS_LI_BUF
operator|)
condition|)
block|{
return|return;
block|}
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_logged
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|last
operator|-
name|first
operator|+
literal|1
expr_stmt|;
name|bfset
argument_list|(
name|bip
operator|->
name|bli_logged
argument_list|,
name|first
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called to verify that our callers have logged  * all the bytes that they changed.  *  * It does this by comparing the original copy of the buffer stored in  * the buf log item's bli_orig array to the current copy of the buffer  * and ensuring that all bytes which mismatch are set in the bli_logged  * array of the buf log item.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_log_check
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|char
modifier|*
name|orig
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|x
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_orig
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_logged
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|orig
operator|=
name|bip
operator|->
name|bli_orig
expr_stmt|;
name|buffer
operator|=
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|orig
index|[
name|x
index|]
operator|!=
name|buffer
index|[
name|x
index|]
operator|&&
operator|!
name|btst
argument_list|(
name|bip
operator|->
name|bli_logged
argument_list|,
name|x
argument_list|)
condition|)
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"xfs_buf_item_log_check bip %x buffer %x orig %x index %d"
argument_list|,
name|bip
argument_list|,
name|bp
argument_list|,
name|orig
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_buf_item_log_debug
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xfs_buf_item_log_check
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|STATIC
name|void
name|xfs_buf_error_relse
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_buf_do_callbacks
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This returns the number of log iovecs needed to log the  * given buf log item.  *  * It calculates this as 1 iovec for the buf log format structure  * and 1 for each stretch of non-contiguous chunks to be logged.  * Contiguous chunks are logged in a single iovec.  *  * If the XFS_BLI_STALE flag has been set, then log nothing.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_buf_item_size
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|uint
name|nvecs
decl_stmt|;
name|int
name|next_bit
decl_stmt|;
name|int
name|last_bit
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
condition|)
block|{
comment|/* 		 * The buffer is stale, so all we need to log 		 * is the buf log format structure with the 		 * cancel flag in it. 		 */
name|xfs_buf_item_trace
argument_list|(
literal|"SIZE STALE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
argument_list|)
expr_stmt|;
name|nvecs
operator|=
literal|1
expr_stmt|;
name|last_bit
operator|=
name|xfs_next_bit
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
argument_list|,
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|last_bit
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
while|while
condition|(
name|last_bit
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * This takes the bit number to start looking from and 		 * returns the next set bit from there.  It returns -1 		 * if there are no more bits set or the start bit is 		 * beyond the end of the bitmap. 		 */
name|next_bit
operator|=
name|xfs_next_bit
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
argument_list|,
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
argument_list|,
name|last_bit
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If we run out of bits, leave the loop, 		 * else if we find a new set of bits bump the number of vecs, 		 * else keep scanning the current set of bits. 		 */
if|if
condition|(
name|next_bit
operator|==
operator|-
literal|1
condition|)
block|{
name|last_bit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_bit
operator|!=
name|last_bit
operator|+
literal|1
condition|)
block|{
name|last_bit
operator|=
name|next_bit
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|next_bit
operator|*
name|XFS_BLI_CHUNK
argument_list|)
operator|!=
operator|(
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|last_bit
operator|*
name|XFS_BLI_CHUNK
argument_list|)
operator|+
name|XFS_BLI_CHUNK
operator|)
condition|)
block|{
name|last_bit
operator|=
name|next_bit
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|last_bit
operator|++
expr_stmt|;
block|}
block|}
name|xfs_buf_item_trace
argument_list|(
literal|"SIZE NORM"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return
name|nvecs
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to fill in the vector of log iovecs for the  * given log buf item.  It fills the first entry with a buf log  * format structure, and the rest point to contiguous chunks  * within the buffer.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_format
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|xfs_log_iovec_t
modifier|*
name|log_vector
parameter_list|)
block|{
name|uint
name|base_size
decl_stmt|;
name|uint
name|nvecs
decl_stmt|;
name|xfs_log_iovec_t
modifier|*
name|vecp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|first_bit
decl_stmt|;
name|int
name|last_bit
decl_stmt|;
name|int
name|next_bit
decl_stmt|;
name|uint
name|nbits
decl_stmt|;
name|uint
name|buffer_offset
decl_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
operator|||
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_BP_ISMAPPED
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|vecp
operator|=
name|log_vector
expr_stmt|;
comment|/* 	 * The size of the base structure is the size of the 	 * declared structure plus the space for the extra words 	 * of the bitmap.  We subtract one from the map size, because 	 * the first element of the bitmap is accounted for in the 	 * size of the base structure. 	 */
name|base_size
operator|=
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_buf_log_format_t
argument_list|)
operator|+
operator|(
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|bip
operator|->
name|bli_format
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|base_size
expr_stmt|;
name|XLOG_VEC_SET_TYPE
argument_list|(
name|vecp
argument_list|,
name|XLOG_REG_TYPE_BFORMAT
argument_list|)
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
condition|)
block|{
comment|/* 		 * The buffer is stale, so all we need to log 		 * is the buf log format structure with the 		 * cancel flag in it. 		 */
name|xfs_buf_item_trace
argument_list|(
literal|"FORMAT STALE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_size
operator|=
name|nvecs
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in an iovec for each set of contiguous chunks. 	 */
name|first_bit
operator|=
name|xfs_next_bit
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
argument_list|,
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|first_bit
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last_bit
operator|=
name|first_bit
expr_stmt|;
name|nbits
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * This takes the bit number to start looking from and 		 * returns the next set bit from there.  It returns -1 		 * if there are no more bits set or the start bit is 		 * beyond the end of the bitmap. 		 */
name|next_bit
operator|=
name|xfs_next_bit
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
argument_list|,
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
argument_list|,
operator|(
name|uint
operator|)
name|last_bit
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If we run out of bits fill in the last iovec and get 		 * out of the loop. 		 * Else if we start a new set of bits then fill in the 		 * iovec for the series we were looking at and start 		 * counting the bits in the new one. 		 * Else we're still in the same set of bits so just 		 * keep counting and scanning. 		 */
if|if
condition|(
name|next_bit
operator|==
operator|-
literal|1
condition|)
block|{
name|buffer_offset
operator|=
name|first_bit
operator|*
name|XFS_BLI_CHUNK
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|buffer_offset
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|nbits
operator|*
name|XFS_BLI_CHUNK
expr_stmt|;
name|XLOG_VEC_SET_TYPE
argument_list|(
name|vecp
argument_list|,
name|XLOG_REG_TYPE_BCHUNK
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|next_bit
operator|!=
name|last_bit
operator|+
literal|1
condition|)
block|{
name|buffer_offset
operator|=
name|first_bit
operator|*
name|XFS_BLI_CHUNK
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|buffer_offset
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|nbits
operator|*
name|XFS_BLI_CHUNK
expr_stmt|;
name|XLOG_VEC_SET_TYPE
argument_list|(
name|vecp
argument_list|,
name|XLOG_REG_TYPE_BCHUNK
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|first_bit
operator|=
name|next_bit
expr_stmt|;
name|last_bit
operator|=
name|next_bit
expr_stmt|;
name|nbits
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|next_bit
operator|<<
name|XFS_BLI_SHIFT
argument_list|)
operator|!=
operator|(
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|last_bit
operator|<<
name|XFS_BLI_SHIFT
argument_list|)
operator|+
name|XFS_BLI_CHUNK
operator|)
condition|)
block|{
name|buffer_offset
operator|=
name|first_bit
operator|*
name|XFS_BLI_CHUNK
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|buffer_offset
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|nbits
operator|*
name|XFS_BLI_CHUNK
expr_stmt|;
name|XLOG_VEC_SET_TYPE
argument_list|(
name|vecp
argument_list|,
name|XLOG_REG_TYPE_BCHUNK
argument_list|)
expr_stmt|;
comment|/* You would think we need to bump the nvecs here too, but we do not  * this number is used by recovery, and it gets confused by the boundary  * split here  *			nvecs++;  */
name|vecp
operator|++
expr_stmt|;
name|first_bit
operator|=
name|next_bit
expr_stmt|;
name|last_bit
operator|=
name|next_bit
expr_stmt|;
name|nbits
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_bit
operator|++
expr_stmt|;
name|nbits
operator|++
expr_stmt|;
block|}
block|}
name|bip
operator|->
name|bli_format
operator|.
name|blf_size
operator|=
name|nvecs
expr_stmt|;
comment|/* 	 * Check to make sure everything is consistent. 	 */
name|xfs_buf_item_trace
argument_list|(
literal|"FORMAT NORM"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|xfs_buf_item_log_check
argument_list|(
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to pin the buffer associated with the buf log  * item in memory so it cannot be written out.  Simply call bpin()  * on the buffer to do this.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_pin
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
operator|||
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"PIN"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_PIN"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_bpin
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to unpin the buffer associated with the buf log  * item which was previously pinned with a call to xfs_buf_item_pin().  * Just call bunpin() on the buffer to do this.  *  * Also drop the reference to the buf item for the current transaction.  * If the XFS_BLI_STALE flag is set and we are the last reference,  * then free up the buf log item and unlock the buffer.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_unpin
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|int
name|stale
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|freed
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
operator|==
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"UNPIN"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_UNPIN"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|freed
operator|=
name|atomic_dec_and_test
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
name|mp
operator|=
name|bip
operator|->
name|bli_item
operator|.
name|li_mountp
expr_stmt|;
name|xfs_bunpin
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freed
operator|&&
name|stale
condition|)
block|{
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISSTALE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"UNPIN STALE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_UNPIN STALE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If we get called here because of an IO error, we may 		 * or may not have the item on the AIL. xfs_trans_delete_ail() 		 * will take care of that situation. 		 * xfs_trans_delete_ail() drops the AIL lock. 		 */
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE_INODE
condition|)
block|{
name|xfs_buf_do_callbacks
argument_list|(
name|bp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_buf_item_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this is called from uncommit in the forced-shutdown path.  * we need to check to see if the reference count on the log item  * is going to drop to zero.  If so, unpin will free the log item  * so we need to free the item's descriptor (that points to the item)  * in the transaction.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_unpin_remove
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|int
name|stale
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
comment|/* 	 * will xfs_buf_item_unpin() call xfs_buf_item_relse()? 	 */
if|if
condition|(
operator|(
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bip
operator|->
name|bli_buf
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"UNPIN REMOVE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_UNPIN_REMOVE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * yes -- clear the xaction descriptor in-use flag 		 * and free the chunk if required.  We can safely 		 * do some work here and then call buf_item_unpin 		 * to do the rest because if the if is true, then 		 * we are holding the buffer locked so no one else 		 * will be able to bump up the refcount. 		 */
name|lidp
operator|=
name|xfs_trans_find_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|)
expr_stmt|;
name|stale
operator|=
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_BUF_STALE
expr_stmt|;
name|xfs_trans_free_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
comment|/* 		 * Since the transaction no longer refers to the buffer, 		 * the buffer should no longer refer to the transaction. 		 */
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|xfs_buf_item_unpin
argument_list|(
name|bip
argument_list|,
name|stale
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is called to attempt to lock the buffer associated with this  * buf log item.  Don't sleep on the buffer lock.  If we can't get  * the lock right away, return 0.  If we can get the lock, pull the  * buffer from the free list, mark it busy, and return 1.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_buf_item_trylock
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISPINNED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
return|return
name|XFS_ITEM_PINNED
return|;
block|}
if|if
condition|(
operator|!
name|XFS_BUF_CPSEMA
argument_list|(
name|bp
argument_list|)
condition|)
block|{
return|return
name|XFS_ITEM_LOCKED
return|;
block|}
comment|/* 	 * Remove the buffer from the free list.  Only do this 	 * if it's on the free list.  Private buffers like the 	 * superblock buffer are not. 	 */
name|XFS_BUF_HOLD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"TRYLOCK SUCCESS"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
return|return
name|XFS_ITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Release the buffer associated with the buf log item.  * If there is no dirty logged data associated with the  * buffer recorded in the buf log item, then free the  * buf log item and remove the reference to it in the  * buffer.  *  * This call ignores the recursion count.  It is only called  * when the buffer should REALLY be unlocked, regardless  * of the recursion count.  *  * If the XFS_BLI_HOLD flag is set in the buf log item, then  * free the log item if necessary but do not unlock the buffer.  * This is for support of xfs_trans_bhold(). Make sure the  * XFS_BLI_HOLD field is cleared if we don't free the item.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_unlock
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|int
name|aborted
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|uint
name|hold
decl_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_UNLOCK"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the buffer's association with this transaction. 	 */
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a transaction abort, don't return early. 	 * Instead, allow the brelse to happen. 	 * Normally it would be done for stale (cancelled) buffers 	 * at unpin time, but we'll never go through the pin/unpin 	 * cycle if we abort inside commit. 	 */
name|aborted
operator|=
operator|(
name|bip
operator|->
name|bli_item
operator|.
name|li_flags
operator|&
name|XFS_LI_ABORTED
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * If the buf item is marked stale, then don't do anything. 	 * We'll unlock the buffer and free the buf item when the 	 * buffer is unpinned for the last time. 	 */
if|if
condition|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
condition|)
block|{
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
name|XFS_BLI_LOGGED
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"UNLOCK STALE"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_flags
operator|&
name|XFS_BLI_CANCEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aborted
condition|)
return|return;
block|}
comment|/* 	 * Drop the transaction's reference to the log item if 	 * it was not logged as part of the transaction.  Otherwise 	 * we'll drop the reference in xfs_buf_item_unpin() when 	 * the transaction is really through with the buffer. 	 */
if|if
condition|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_LOGGED
operator|)
condition|)
block|{
name|atomic_dec
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Clear the logged flag since this is per 		 * transaction state. 		 */
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
name|XFS_BLI_LOGGED
expr_stmt|;
block|}
comment|/* 	 * Before possibly freeing the buf item, determine if we should 	 * release the buffer at the end of this routine. 	 */
name|hold
operator|=
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_HOLD
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"UNLOCK"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
comment|/* 	 * If the buf item isn't tracking any data, free it. 	 * Otherwise, if XFS_BLI_HOLD is set clear it. 	 */
if|if
condition|(
name|xfs_count_bits
argument_list|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
argument_list|,
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfs_buf_item_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hold
condition|)
block|{
name|bip
operator|->
name|bli_flags
operator|&=
operator|~
name|XFS_BLI_HOLD
expr_stmt|;
block|}
comment|/* 	 * Release the buffer if XFS_BLI_HOLD was not set. 	 */
if|if
condition|(
operator|!
name|hold
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called to find out where the oldest active copy of the  * buf log item in the on disk log resides now that the last log  * write of it completed at the given lsn.  * We always re-log all the dirty data in a buffer, so usually the  * latest copy in the on disk log is the only one that matters.  For  * those cases we simply return the given lsn.  *  * The one exception to this is for buffers full of newly allocated  * inodes.  These buffers are only relogged with the XFS_BLI_INODE_BUF  * flag set, indicating that only the di_next_unlinked fields from the  * inodes in the buffers will be replayed during recovery.  If the  * original newly allocated inode images have not yet been flushed  * when the buffer is so relogged, then we need to make sure that we  * keep the old images in the 'active' portion of the log.  We do this  * by returning the original lsn of that transaction here rather than  * the current one.  */
end_comment

begin_function
name|STATIC
name|xfs_lsn_t
name|xfs_buf_item_committed
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
name|xfs_buf_item_trace
argument_list|(
literal|"COMMITTED"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_INODE_ALLOC_BUF
operator|)
operator|&&
operator|(
name|bip
operator|->
name|bli_item
operator|.
name|li_lsn
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
name|bip
operator|->
name|bli_item
operator|.
name|li_lsn
return|;
block|}
return|return
operator|(
name|lsn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the transaction holding the buffer is aborted.  * Just behave as if the transaction had been cancelled. If we're shutting down  * and have aborted this transaction, we'll trap this buffer when it tries to  * get written out.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_abort
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_ABORT"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SUPER_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_item_unlock
argument_list|(
name|bip
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is called to asynchronously write the buffer associated with this  * buf log item out to disk. The buffer will already have been locked by  * a successful call to xfs_buf_item_trylock().  If the buffer still has  * B_DELWRI set, then get it going out to disk with a call to bawrite().  * If not, then just release the buffer.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_push
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_STALE
operator|)
argument_list|)
expr_stmt|;
name|xfs_buf_item_trace
argument_list|(
literal|"PUSH"
argument_list|,
name|bip
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_bawrite
argument_list|(
name|bip
operator|->
name|bli_item
operator|.
name|li_mountp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_item_committing
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|xfs_lsn_t
name|commit_lsn
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * This is the ops vector shared by all buf log items.  */
end_comment

begin_decl_stmt
name|STATIC
name|struct
name|xfs_item_ops
name|xfs_buf_item_ops
init|=
block|{
operator|.
name|iop_size
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_size
block|,
operator|.
name|iop_format
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_log_iovec_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_format
block|,
operator|.
name|iop_pin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_pin
block|,
operator|.
name|iop_unpin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|xfs_buf_item_unpin
block|,
operator|.
name|iop_unpin_remove
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_unpin_remove
block|,
operator|.
name|iop_trylock
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_trylock
block|,
operator|.
name|iop_unlock
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_unlock
block|,
operator|.
name|iop_committed
operator|=
operator|(
name|xfs_lsn_t
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_buf_item_committed
block|,
operator|.
name|iop_push
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_push
block|,
operator|.
name|iop_abort
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_buf_item_abort
block|,
operator|.
name|iop_pushbuf
operator|=
name|NULL
block|,
operator|.
name|iop_committing
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_buf_item_committing
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a new buf log item to go with the given buffer.  * Set the buffer's b_fsprivate field to point to the new  * buf log item.  If there are other item's attached to the  * buffer (see xfs_buf_attach_iodone() below), then put the  * buf log item at the front.  */
end_comment

begin_function
name|void
name|xfs_buf_item_init
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|int
name|chunks
decl_stmt|;
name|int
name|map_size
decl_stmt|;
comment|/* 	 * Check to see if there is already a buf log item for 	 * this buffer.  If there is, it is guaranteed to be 	 * the first.  If we do already have one, there is 	 * nothing to do here so return. 	 */
if|if
condition|(
name|XFS_BUF_FSPRIVATE3
argument_list|(
name|bp
argument_list|,
name|xfs_mount_t
operator|*
argument_list|)
operator|!=
name|mp
condition|)
name|XFS_BUF_SET_FSPRIVATE3
argument_list|(
name|bp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|,
name|xfs_bdstrat_cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|->
name|li_type
operator|==
name|XFS_LI_BUF
condition|)
block|{
return|return;
block|}
block|}
comment|/* 	 * chunks is the number of XFS_BLI_CHUNK size pieces 	 * the buffer can be divided into. Make sure not to 	 * truncate any pieces.  map_size is the size of the 	 * bitmap needed to describe the chunks of the buffer. 	 */
name|chunks
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|+
operator|(
name|XFS_BLI_CHUNK
operator|-
literal|1
operator|)
operator|)
operator|>>
name|XFS_BLI_SHIFT
argument_list|)
expr_stmt|;
name|map_size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|chunks
operator|+
name|NBWORD
operator|)
operator|>>
name|BIT_TO_WORD_SHIFT
argument_list|)
expr_stmt|;
name|bip
operator|=
operator|(
name|xfs_buf_log_item_t
operator|*
operator|)
name|kmem_zone_zalloc
argument_list|(
name|xfs_buf_item_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_item
operator|.
name|li_type
operator|=
name|XFS_LI_BUF
expr_stmt|;
name|bip
operator|->
name|bli_item
operator|.
name|li_ops
operator|=
operator|&
name|xfs_buf_item_ops
expr_stmt|;
name|bip
operator|->
name|bli_item
operator|.
name|li_mountp
operator|=
name|mp
expr_stmt|;
name|bip
operator|->
name|bli_buf
operator|=
name|bp
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_type
operator|=
name|XFS_LI_BUF
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_blkno
operator|=
operator|(
name|__int64_t
operator|)
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_len
operator|=
operator|(
name|ushort
operator|)
name|BTOBB
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_format
operator|.
name|blf_map_size
operator|=
name|map_size
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_BLI_TRACE
name|bip
operator|->
name|bli_trace
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_BLI_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
comment|/* 	 * Allocate the arrays for tracking what needs to be logged 	 * and what our callers request to be logged.  bli_orig 	 * holds a copy of the original, clean buffer for comparison 	 * against, and bli_logged keeps a 1 bit flag per byte in 	 * the buffer to indicate which bytes the callers have asked 	 * to have logged. 	 */
name|bip
operator|->
name|bli_orig
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bip
operator|->
name|bli_orig
argument_list|,
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_logged
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|/
name|NBBY
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Put the buf item into the list of items attached to the 	 * buffer at the front. 	 */
if|if
condition|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|bip
operator|->
name|bli_item
operator|.
name|li_bio_list
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
block|}
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark bytes first through last inclusive as dirty in the buf  * item's bitmap.  */
end_comment

begin_function
name|void
name|xfs_buf_item_log
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|,
name|uint
name|first
parameter_list|,
name|uint
name|last
parameter_list|)
block|{
name|uint
name|first_bit
decl_stmt|;
name|uint
name|last_bit
decl_stmt|;
name|uint
name|bits_to_set
decl_stmt|;
name|uint
name|bits_set
decl_stmt|;
name|uint
name|word_num
decl_stmt|;
name|uint
modifier|*
name|wordp
decl_stmt|;
name|uint
name|bit
decl_stmt|;
name|uint
name|end_bit
decl_stmt|;
name|uint
name|mask
decl_stmt|;
comment|/* 	 * Mark the item as having some dirty data for 	 * quick reference in xfs_buf_item_dirty. 	 */
name|bip
operator|->
name|bli_flags
operator||=
name|XFS_BLI_DIRTY
expr_stmt|;
comment|/* 	 * Convert byte offsets to bit numbers. 	 */
name|first_bit
operator|=
name|first
operator|>>
name|XFS_BLI_SHIFT
expr_stmt|;
name|last_bit
operator|=
name|last
operator|>>
name|XFS_BLI_SHIFT
expr_stmt|;
comment|/* 	 * Calculate the total number of bits to be set. 	 */
name|bits_to_set
operator|=
name|last_bit
operator|-
name|first_bit
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Get a pointer to the first word in the bitmap 	 * to set a bit in. 	 */
name|word_num
operator|=
name|first_bit
operator|>>
name|BIT_TO_WORD_SHIFT
expr_stmt|;
name|wordp
operator|=
operator|&
operator|(
name|bip
operator|->
name|bli_format
operator|.
name|blf_data_map
index|[
name|word_num
index|]
operator|)
expr_stmt|;
comment|/* 	 * Calculate the starting bit in the first word. 	 */
name|bit
operator|=
name|first_bit
operator|&
call|(
name|uint
call|)
argument_list|(
name|NBWORD
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * First set any bits in the first word of our range. 	 * If it starts at bit 0 of the word, it will be 	 * set below rather than here.  That is what the variable 	 * bit tells us. The variable bits_set tracks the number 	 * of bits that have been set so far.  End_bit is the number 	 * of the last bit to be set in this word plus one. 	 */
if|if
condition|(
name|bit
condition|)
block|{
name|end_bit
operator|=
name|MIN
argument_list|(
name|bit
operator|+
name|bits_to_set
argument_list|,
operator|(
name|uint
operator|)
name|NBWORD
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|end_bit
operator|-
name|bit
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bit
expr_stmt|;
operator|*
name|wordp
operator||=
name|mask
expr_stmt|;
name|wordp
operator|++
expr_stmt|;
name|bits_set
operator|=
name|end_bit
operator|-
name|bit
expr_stmt|;
block|}
else|else
block|{
name|bits_set
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now set bits a whole word at a time that are between 	 * first_bit and last_bit. 	 */
while|while
condition|(
operator|(
name|bits_to_set
operator|-
name|bits_set
operator|)
operator|>=
name|NBWORD
condition|)
block|{
operator|*
name|wordp
operator||=
literal|0xffffffff
expr_stmt|;
name|bits_set
operator|+=
name|NBWORD
expr_stmt|;
name|wordp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Finally, set any bits left to be set in one last partial word. 	 */
name|end_bit
operator|=
name|bits_to_set
operator|-
name|bits_set
expr_stmt|;
if|if
condition|(
name|end_bit
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|end_bit
operator|)
operator|-
literal|1
expr_stmt|;
operator|*
name|wordp
operator||=
name|mask
expr_stmt|;
block|}
name|xfs_buf_item_log_debug
argument_list|(
name|bip
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if the buffer has some data that has been logged (at any  * point, not just the current transaction) and 0 if not.  */
end_comment

begin_function
name|uint
name|xfs_buf_item_dirty
parameter_list|(
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
return|return
operator|(
name|bip
operator|->
name|bli_flags
operator|&
name|XFS_BLI_DIRTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the buf log item is no longer needed.  It should  * free the buf log item associated with the given buffer and clear  * the buffer's pointer to the buf log item.  If there are no more  * items in the list, clear the b_iodone field of the buffer (see  * xfs_buf_attach_iodone() below).  */
end_comment

begin_function
name|void
name|xfs_buf_item_relse
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS_RELSE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|bip
operator|->
name|bli_item
operator|.
name|li_bio_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|XFS_BUF_ISUNINITIAL
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
name|kmem_free
argument_list|(
name|bip
operator|->
name|bli_orig
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_orig
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|bip
operator|->
name|bli_logged
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|/
name|NBBY
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_logged
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* XFS_TRANS_DEBUG */
ifdef|#
directive|ifdef
name|XFS_BLI_TRACE
name|ktrace_free
argument_list|(
name|bip
operator|->
name|bli_trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_zone_free
argument_list|(
name|xfs_buf_item_zone
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the given log item with its callback to the list of callbacks  * to be called when the buffer's I/O completes.  If it is not set  * already, set the buffer's b_iodone() routine to be  * xfs_buf_iodone_callbacks() and link the log item into the list of  * items rooted at b_fsprivate.  Items are always added as the second  * entry in the list if there is a first, because the buf item code  * assumes that the buf log item is first.  */
end_comment

begin_function
name|void
name|xfs_buf_attach_iodone
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|xfs_buf_t
modifier|*
parameter_list|,
name|xfs_log_item_t
modifier|*
parameter_list|)
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|head_lip
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|lip
operator|->
name|li_cb
operator|=
name|cb
expr_stmt|;
if|if
condition|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|head_lip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|lip
operator|->
name|li_bio_list
operator|=
name|head_lip
operator|->
name|li_bio_list
expr_stmt|;
name|head_lip
operator|->
name|li_bio_list
operator|=
name|lip
expr_stmt|;
block|}
else|else
block|{
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|==
name|xfs_buf_iodone_callbacks
operator|)
operator|||
operator|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xfs_buf_iodone_callbacks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xfs_buf_do_callbacks
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|nlip
decl_stmt|;
while|while
condition|(
name|lip
operator|!=
name|NULL
condition|)
block|{
name|nlip
operator|=
name|lip
operator|->
name|li_bio_list
expr_stmt|;
name|ASSERT
argument_list|(
name|lip
operator|->
name|li_cb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Clear the next pointer so we don't have any 		 * confusion if the item is added to another buf. 		 * Don't touch the log item after calling its 		 * callback, because it could have freed itself. 		 */
name|lip
operator|->
name|li_bio_list
operator|=
name|NULL
expr_stmt|;
name|lip
operator|->
name|li_cb
argument_list|(
name|bp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|lip
operator|=
name|nlip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the iodone() function for buffers which have had callbacks  * attached to them by xfs_buf_attach_iodone().  It should remove each  * log item from the buffer's list and call the callback of each in turn.  * When done, the buffer's fsprivate field is set to NULL and the buffer  * is unlocked with a call to iodone().  */
end_comment

begin_function
name|void
name|xfs_buf_iodone_callbacks
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
specifier|static
name|ulong
name|lasttime
decl_stmt|;
specifier|static
name|xfs_buftarg_t
modifier|*
name|lasttarg
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we've already decided to shutdown the filesystem 		 * because of IO errors, there's no point in giving this 		 * a retry. 		 */
name|mp
operator|=
name|lip
operator|->
name|li_mountp
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
operator|==
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|XFS_BUF_SUPER_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"BUF_IODONE_CB"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_do_callbacks
argument_list|(
name|bp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * XFS_SHUT flag gets set when we go thru the 			 * entire buffer cache and deliberately start 			 * throwing away delayed write buffers. 			 * Since there's no biowait done on those, 			 * we should just brelse them. 			 */
if|if
condition|(
name|XFS_BUF_ISSHUT
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|XFS_BUF_UNSHUT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
operator|!=
name|lasttarg
operator|)
operator|||
operator|(
name|ticks
operator|>
operator|(
name|lasttime
operator|+
literal|5
operator|*
name|HZ
operator|)
operator|)
condition|)
block|{
name|lasttime
operator|=
name|ticks
expr_stmt|;
name|prdev
argument_list|(
literal|"XFS write error in file system meta-data "
literal|"block 0x%jx in %s"
argument_list|,
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
block|}
name|lasttarg
operator|=
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISASYNC
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* 			 * If the write was asynchronous then noone will be 			 * looking for the error.  Clear the error state 			 * and write the buffer out again delayed write. 			 * 			 * XXXsup This is OK, so long as we catch these 			 * before we start the umount; we don't want these 			 * DELWRI metadata bufs to be hanging around. 			 */
name|XFS_BUF_ERROR
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* errno of 0 unsets the flag */
if|if
condition|(
operator|!
operator|(
name|XFS_BUF_ISSTALE
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|XFS_BUF_DELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_START
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"BUF_IODONE ASYNC"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the write of the buffer was not asynchronous, 			 * then we want to make sure to return the error 			 * to the caller of bwrite().  Because of this we 			 * cannot clear the B_ERROR state at this point. 			 * Instead we install a callback function that 			 * will be called when the buffer is released, and 			 * that routine will clear the error state and 			 * set the buffer to be written out again after 			 * some delay. 			 */
comment|/* We actually overwrite the existing b-relse 			   function at times, but we're gonna be shutting down 			   anyway. */
name|XFS_BUF_SET_BRELSE_FUNC
argument_list|(
name|bp
argument_list|,
name|xfs_buf_error_relse
argument_list|)
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_V_IODONESEMA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|XFSERRORDEBUG
name|xfs_buftrace
argument_list|(
literal|"XFS BUFCB NOERR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfs_buf_do_callbacks
argument_list|(
name|bp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a callback routine attached to a buffer which gets an error  * when being written out synchronously.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_buf_error_relse
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|lip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|(
name|xfs_mount_t
operator|*
operator|)
name|lip
operator|->
name|li_mountp
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
operator|==
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_ERROR
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"BUF_ERROR_RELSE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
comment|/* 	 * We have to unpin the pinned buffers so do the 	 * callbacks. 	 */
name|xfs_buf_do_callbacks
argument_list|(
name|bp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_BRELSE_FUNC
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the iodone() function for buffers which have been  * logged.  It is called when they are eventually flushed out.  * It should remove the buf item from the AIL, and free the buf item.  * It is called by xfs_buf_iodone_callbacks() above which will take  * care of cleaning up the buffer itself.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_buf_iodone
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|struct
name|xfs_mount
modifier|*
name|mp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_buf
operator|==
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|bip
operator|->
name|bli_item
operator|.
name|li_mountp
expr_stmt|;
comment|/* 	 * If we are forcibly shutting down, this may well be 	 * off the AIL already. That's because we simulate the 	 * log-committed callbacks to unpin these buffers. Or we may never 	 * have put this item on AIL because of the transaction was 	 * aborted forcibly. xfs_trans_delete_ail() takes care of these. 	 * 	 * Either way, AIL is useless if we're forcing a shutdown. 	 */
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * xfs_trans_delete_ail() drops the AIL lock. 	 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|bip
argument_list|,
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
name|kmem_free
argument_list|(
name|bip
operator|->
name|bli_orig
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_orig
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|bip
operator|->
name|bli_logged
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|/
name|NBBY
argument_list|)
expr_stmt|;
name|bip
operator|->
name|bli_logged
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* XFS_TRANS_DEBUG */
ifdef|#
directive|ifdef
name|XFS_BLI_TRACE
name|ktrace_free
argument_list|(
name|bip
operator|->
name|bli_trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_zone_free
argument_list|(
name|xfs_buf_item_zone
argument_list|,
name|bip
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_BLI_TRACE
argument_list|)
end_if

begin_function
name|void
name|xfs_buf_item_trace
parameter_list|(
name|char
modifier|*
name|id
parameter_list|,
name|xfs_buf_log_item_t
modifier|*
name|bip
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|ASSERT
argument_list|(
name|bip
operator|->
name|bli_trace
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
name|ktrace_enter
argument_list|(
name|bip
operator|->
name|bli_trace
argument_list|,
operator|(
name|void
operator|*
operator|)
name|id
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bip
operator|->
name|bli_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|bip
operator|->
name|bli_flags
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|bip
operator|->
name|bli_recur
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|atomic_read
argument_list|(
operator|&
name|bip
operator|->
name|bli_refcount
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
literal|0xFFFFFFFF
operator|&
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
literal|0xFFFFFFFF
operator|&
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|XFS_BUF_BFLAGS
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|,
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|XFS_BUF_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|XFS_BUF_ISPINNED
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bip
operator|->
name|bli_item
operator|.
name|li_desc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|bip
operator|->
name|bli_item
operator|.
name|li_flags
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_BLI_TRACE */
end_comment

end_unit

