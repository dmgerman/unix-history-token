begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * xfs_attr_leaf.c  *  * Routines to implement leaf blocks of attributes as Btrees of hashed names.  */
end_comment

begin_comment
comment|/*========================================================================  * Function prototypes for the kernel.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Routines used for growing the Btree.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_create
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
name|which_block
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_add_work
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|leaf_buffer
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|freemap_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_attr_leaf_compact
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|leaf_buffer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_attr_leaf_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_figure_balance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|leaf_blk_1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|leaf_blk_2
parameter_list|,
name|int
modifier|*
name|number_entries_in_blk1
parameter_list|,
name|int
modifier|*
name|number_usedbytes_in_blk1
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Routines used for shrinking the Btree.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_attr_node_inactive
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_inactive
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_freextent
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|blkno
parameter_list|,
name|int
name|blkcnt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_attr_leaf_moveents
parameter_list|(
name|xfs_attr_leafblock_t
modifier|*
name|src_leaf
parameter_list|,
name|int
name|src_start
parameter_list|,
name|xfs_attr_leafblock_t
modifier|*
name|dst_leaf
parameter_list|,
name|int
name|dst_start
parameter_list|,
name|int
name|move_count
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_leaf_entsize
parameter_list|(
name|xfs_attr_leafblock_t
modifier|*
name|leaf
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_attr_put_listent
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|,
name|attrnames_t
modifier|*
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|valuelen
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*========================================================================  * External routines when attribute fork size< XFS_LITINO(mp).  *========================================================================*/
end_comment

begin_comment
comment|/*  * Query whether the requested number of additional bytes of extended  * attribute space will be able to fit inline.  * Returns zero if not, else the di_forkoff fork offset to be used in the  * literal area for attribute data once the new bytes have been added.  *  * di_forkoff must be 8 byte aligned, hence is stored as a>>3 value;  * special case for dev/uuid inodes, they have fixed size data forks.  */
end_comment

begin_function
name|int
name|xfs_attr_shortform_bytesfit
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|int
name|minforkoff
decl_stmt|;
comment|/* lower limit on valid forkoff locations */
name|int
name|maxforkoff
decl_stmt|;
comment|/* upper limit on valid forkoff locations */
name|xfs_mount_t
modifier|*
name|mp
init|=
name|dp
operator|->
name|i_mount
decl_stmt|;
name|offset
operator|=
operator|(
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
operator|-
name|bytes
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* rounded down */
switch|switch
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_DEV
case|:
name|minforkoff
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_dev_t
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
expr_stmt|;
return|return
operator|(
name|offset
operator|>=
name|minforkoff
operator|)
condition|?
name|minforkoff
else|:
literal|0
return|;
case|case
name|XFS_DINODE_FMT_UUID
case|:
name|minforkoff
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
expr_stmt|;
return|return
operator|(
name|offset
operator|>=
name|minforkoff
operator|)
condition|?
name|minforkoff
else|:
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
condition|)
block|{
if|if
condition|(
name|bytes
operator|<=
name|XFS_IFORK_ASIZE
argument_list|(
name|dp
argument_list|)
condition|)
return|return
name|mp
operator|->
name|m_attroffset
operator|>>
literal|3
return|;
return|return
literal|0
return|;
block|}
comment|/* data fork btree root can have at least this many key/ptr pairs */
name|minforkoff
operator|=
name|MAX
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
argument_list|,
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|MINDBTPTRS
argument_list|)
argument_list|)
expr_stmt|;
name|minforkoff
operator|=
name|roundup
argument_list|(
name|minforkoff
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
expr_stmt|;
comment|/* attr fork btree root can have at least this many key/ptr pairs */
name|maxforkoff
operator|=
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
operator|-
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|MINABTPTRS
argument_list|)
expr_stmt|;
name|maxforkoff
operator|=
name|maxforkoff
operator|>>
literal|3
expr_stmt|;
comment|/* rounded down */
if|if
condition|(
name|offset
operator|>=
name|minforkoff
operator|&&
name|offset
operator|<
name|maxforkoff
condition|)
return|return
name|offset
return|;
if|if
condition|(
name|offset
operator|>=
name|maxforkoff
condition|)
return|return
name|maxforkoff
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Switch on the ATTR2 superblock bit (implies also FEATURES2)  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_sbversion_add_attr2
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
operator|&&
operator|!
operator|(
name|XFS_SB_VERSION_HASATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|)
condition|)
block|{
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|XFS_SB_VERSION_ADDATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
expr_stmt|;
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_SB_VERSIONNUM
operator||
name|XFS_SB_FEATURES2
argument_list|)
expr_stmt|;
block|}
else|else
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create the initial contents of a shortform attribute list.  */
end_comment

begin_function
name|void
name|xfs_attr_shortform_create
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_sf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|dp
operator|->
name|i_afp
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|XFS_IFEXTENTS
expr_stmt|;
comment|/* just in case */
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|=
name|XFS_DINODE_FMT_LOCAL
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFINLINE
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
block|}
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
name|xfs_attr_sf_hdr_t
operator|*
operator|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|hdr
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|totsize
operator|=
name|cpu_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_ADATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a name/value pair to the shortform attribute list.  * Overflow from the inode has already been checked for.  */
end_comment

begin_function
name|void
name|xfs_attr_shortform_add
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|forkoff
parameter_list|)
block|{
name|xfs_attr_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_attr_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|forkoff
expr_stmt|;
name|dp
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_afp
operator|->
name|if_ext_max
operator|=
name|XFS_IFORK_ASIZE
argument_list|(
name|dp
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|dp
operator|->
name|i_afp
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|!=
name|args
operator|->
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
name|sfe
operator|-
operator|(
name|char
operator|*
operator|)
name|sf
expr_stmt|;
name|size
operator|=
name|XFS_ATTR_SF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|->
name|namelen
argument_list|,
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
name|size
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|(
name|xfs_attr_sf_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|+
name|offset
operator|)
expr_stmt|;
name|sfe
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|sfe
operator|->
name|valuelen
operator|=
name|args
operator|->
name|valuelen
expr_stmt|;
name|sfe
operator|->
name|flags
operator|=
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
condition|?
name|XFS_ATTR_SECURE
else|:
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
condition|?
name|XFS_ATTR_ROOT
else|:
literal|0
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|sfe
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sfe
operator|->
name|nameval
index|[
name|args
operator|->
name|namelen
index|]
argument_list|,
name|args
operator|->
name|value
argument_list|,
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|sf
operator|->
name|hdr
operator|.
name|count
operator|++
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|sf
operator|->
name|hdr
operator|.
name|totsize
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_ADATA
argument_list|)
expr_stmt|;
name|xfs_sbversion_add_attr2
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|trans
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an attribute from the shortform attribute list structure.  */
end_comment

begin_function
name|int
name|xfs_attr_shortform_remove
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_attr_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|base
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|,
name|end
decl_stmt|,
name|totsize
decl_stmt|,
name|i
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|base
operator|=
sizeof|sizeof
argument_list|(
name|xfs_attr_sf_hdr_t
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
name|end
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
operator|,
name|base
operator|+=
name|size
operator|,
name|i
operator|++
control|)
block|{
name|size
operator|=
name|XFS_ATTR_SF_ENTSIZE
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|!=
name|args
operator|->
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|sfe
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|end
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
operator|)
return|;
comment|/* 	 * Fix up the attribute fork data, covering the hole 	 */
name|end
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|totsize
operator|=
name|be16_to_cpu
argument_list|(
name|sf
operator|->
name|hdr
operator|.
name|totsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|totsize
condition|)
name|memmove
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|)
index|[
name|base
index|]
argument_list|,
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|)
index|[
name|end
index|]
argument_list|,
name|totsize
operator|-
name|end
argument_list|)
expr_stmt|;
name|sf
operator|->
name|hdr
operator|.
name|count
operator|--
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|sf
operator|->
name|hdr
operator|.
name|totsize
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the start offset of the attribute fork 	 */
name|totsize
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|totsize
operator|==
sizeof|sizeof
argument_list|(
name|xfs_attr_sf_hdr_t
argument_list|)
operator|&&
operator|!
name|args
operator|->
name|addname
operator|&&
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
condition|)
block|{
comment|/* 		 * Last attribute now removed, revert to original 		 * inode format making all literal area available 		 * to the data fork once more. 		 */
name|xfs_idestroy_fork
argument_list|(
name|dp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_afp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
operator|-
name|size
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|xfs_attr_shortform_bytesfit
argument_list|(
name|dp
argument_list|,
name|totsize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_d
operator|.
name|di_forkoff
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|totsize
operator|>
sizeof|sizeof
argument_list|(
name|xfs_attr_sf_hdr_t
argument_list|)
operator|||
name|args
operator|->
name|addname
operator|||
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_afp
operator|->
name|if_ext_max
operator|=
name|XFS_IFORK_ASIZE
argument_list|(
name|dp
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_ADATA
argument_list|)
expr_stmt|;
block|}
name|xfs_sbversion_add_attr2
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|trans
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a shortform attribute list structure.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xfs_attr_shortform_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_attr_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_afp
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|!=
name|args
operator|->
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a shortform attribute list structure.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xfs_attr_shortform_getvalue
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_attr_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|args
operator|->
name|dp
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|!=
name|args
operator|->
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|args
operator|->
name|valuelen
operator|=
name|sfe
operator|->
name|valuelen
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|args
operator|->
name|valuelen
operator|<
name|sfe
operator|->
name|valuelen
condition|)
block|{
name|args
operator|->
name|valuelen
operator|=
name|sfe
operator|->
name|valuelen
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
block|}
name|args
operator|->
name|valuelen
operator|=
name|sfe
operator|->
name|valuelen
expr_stmt|;
name|memcpy
argument_list|(
name|args
operator|->
name|value
argument_list|,
operator|&
name|sfe
operator|->
name|nameval
index|[
name|args
operator|->
name|namelen
index|]
argument_list|,
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from using the shortform to the leaf.  */
end_comment

begin_function
name|int
name|xfs_attr_shortform_to_leaf
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_attr_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_attr_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|xfs_da_args_t
name|nargs
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|size
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ifp
operator|=
name|dp
operator|->
name|i_afp
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|size
operator|=
name|be16_to_cpu
argument_list|(
name|sf
operator|->
name|hdr
operator|.
name|totsize
argument_list|)
expr_stmt|;
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer
argument_list|,
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
operator|-
name|size
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If we hit an IO error middle of the transaction inside 		 * grow_inode(), we may have inconsistent data. Bail out. 		 */
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
goto|goto
name|out
goto|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
name|size
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
comment|/* try to put */
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|tmpbuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* it back */
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|blkno
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_create
argument_list|(
name|args
argument_list|,
name|blkno
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|xfs_da_shrink_inode
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
name|size
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
comment|/* try to put */
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|tmpbuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* it back */
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nargs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
name|nargs
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|nargs
operator|.
name|firstblock
operator|=
name|args
operator|->
name|firstblock
expr_stmt|;
name|nargs
operator|.
name|flist
operator|=
name|args
operator|->
name|flist
expr_stmt|;
name|nargs
operator|.
name|total
operator|=
name|args
operator|->
name|total
expr_stmt|;
name|nargs
operator|.
name|whichfork
operator|=
name|XFS_ATTR_FORK
expr_stmt|;
name|nargs
operator|.
name|trans
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|nargs
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|nargs
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|nameval
expr_stmt|;
name|nargs
operator|.
name|namelen
operator|=
name|sfe
operator|->
name|namelen
expr_stmt|;
name|nargs
operator|.
name|value
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|sfe
operator|->
name|nameval
index|[
name|nargs
operator|.
name|namelen
index|]
expr_stmt|;
name|nargs
operator|.
name|valuelen
operator|=
name|sfe
operator|->
name|valuelen
expr_stmt|;
name|nargs
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|nameval
argument_list|,
name|sfe
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|nargs
operator|.
name|flags
operator|=
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
condition|?
name|ATTR_SECURE
else|:
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
condition|?
name|ATTR_ROOT
else|:
literal|0
operator|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
comment|/* set a->index */
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOATTR
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_leaf_add
argument_list|(
name|bp
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|bp
condition|)
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_attr_shortform_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|xfs_attr_sf_sort_t
modifier|*
name|sa
decl_stmt|,
modifier|*
name|sb
decl_stmt|;
name|sa
operator|=
operator|(
specifier|const
name|xfs_attr_sf_sort_t
operator|*
operator|)
name|a
expr_stmt|;
name|sb
operator|=
operator|(
specifier|const
name|xfs_attr_sf_sort_t
operator|*
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|hash
operator|<
name|sb
operator|->
name|hash
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|hash
operator|>
name|sb
operator|->
name|hash
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|sa
operator|->
name|entno
operator|-
name|sb
operator|->
name|entno
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy out entries of shortform attribute lists for attr_list().  * Shortform attribute lists are not stored in hashval sorted order.  * If the output buffer is not large enough to hold them all, then we  * we have to calculate each entries' hashvalue and sort them before  * we can begin returning them to the user.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xfs_attr_shortform_list
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|)
block|{
name|attrlist_cursor_kern_t
modifier|*
name|cursor
decl_stmt|;
name|xfs_attr_sf_sort_t
modifier|*
name|sbuf
decl_stmt|,
modifier|*
name|sbp
decl_stmt|;
name|xfs_attr_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_attr_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|sbsize
decl_stmt|,
name|nsbuf
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|context
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|=
name|context
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_afp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|ASSERT
argument_list|(
name|sf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sf
operator|->
name|hdr
operator|.
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cursor
operator|=
name|context
operator|->
name|cursor
expr_stmt|;
name|ASSERT
argument_list|(
name|cursor
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xfs_attr_trace_l_c
argument_list|(
literal|"sf start"
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* 	 * If the buffer is large enough, do not bother with sorting. 	 * Note the generous fudge factor of 16 overhead bytes per entry. 	 */
if|if
condition|(
operator|(
name|dp
operator|->
name|i_afp
operator|->
name|if_bytes
operator|+
name|sf
operator|->
name|hdr
operator|.
name|count
operator|*
literal|16
operator|)
operator|<
name|context
operator|->
name|bufsize
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNORMALS
operator|)
condition|)
block|{
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNROOTLS
operator|)
condition|)
block|{
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|namesp
operator|=
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
condition|?
operator|&
name|attr_secure
else|:
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
condition|?
operator|&
name|attr_trusted
else|:
operator|&
name|attr_user
operator|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|ASSERT
argument_list|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNAMELS
argument_list|)
expr_stmt|;
name|context
operator|->
name|count
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
name|sfe
operator|->
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xfs_attr_put_listent
argument_list|(
name|context
argument_list|,
name|namesp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|nameval
argument_list|,
operator|(
name|int
operator|)
name|sfe
operator|->
name|namelen
argument_list|,
operator|(
name|int
operator|)
name|sfe
operator|->
name|valuelen
argument_list|)
condition|)
break|break;
block|}
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
name|xfs_attr_trace_l_c
argument_list|(
literal|"sf big-gulp"
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * It didn't all fit, so we have to sort everything on hashval. 	 */
name|sbsize
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sbuf
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|sbuf
operator|=
name|kmem_alloc
argument_list|(
name|sbsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the attribute list for the rest of the entries, storing 	 * the relevant info from only those that match into a buffer. 	 */
name|nsbuf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|<
operator|(
name|char
operator|*
operator|)
name|sf
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|>=
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|+
name|dp
operator|->
name|i_afp
operator|->
name|if_bytes
operator|)
operator|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_attr_shortform_list"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|context
operator|->
name|dp
operator|->
name|i_mount
argument_list|,
name|sfe
argument_list|)
expr_stmt|;
name|xfs_attr_trace_l_c
argument_list|(
literal|"sf corrupted"
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNORMALS
operator|)
condition|)
block|{
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|sfe
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNROOTLS
operator|)
condition|)
block|{
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sbp
operator|->
name|entno
operator|=
name|i
expr_stmt|;
name|sbp
operator|->
name|hash
operator|=
name|xfs_da_hashname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|nameval
argument_list|,
name|sfe
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|nameval
expr_stmt|;
name|sbp
operator|->
name|namelen
operator|=
name|sfe
operator|->
name|namelen
expr_stmt|;
comment|/* These are bytes, and both on-disk, don't endian-flip */
name|sbp
operator|->
name|valuelen
operator|=
name|sfe
operator|->
name|valuelen
expr_stmt|;
name|sbp
operator|->
name|flags
operator|=
name|sfe
operator|->
name|flags
expr_stmt|;
name|sfe
operator|=
name|XFS_ATTR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
name|sbp
operator|++
expr_stmt|;
name|nsbuf
operator|++
expr_stmt|;
block|}
comment|/* 	 * Sort the entries on hash then entno. 	 */
name|xfs_sort
argument_list|(
name|sbuf
argument_list|,
name|nsbuf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbuf
argument_list|)
argument_list|,
name|xfs_attr_shortform_compare
argument_list|)
expr_stmt|;
comment|/* 	 * Re-find our place IN THE SORTED LIST. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|cursor
operator|->
name|initted
operator|=
literal|1
expr_stmt|;
name|cursor
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sbp
operator|=
name|sbuf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsbuf
condition|;
name|i
operator|++
operator|,
name|sbp
operator|++
control|)
block|{
if|if
condition|(
name|sbp
operator|->
name|hash
operator|==
name|cursor
operator|->
name|hashval
condition|)
block|{
if|if
condition|(
name|cursor
operator|->
name|offset
operator|==
name|count
condition|)
block|{
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sbp
operator|->
name|hash
operator|>
name|cursor
operator|->
name|hashval
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|nsbuf
condition|)
block|{
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
name|xfs_attr_trace_l_c
argument_list|(
literal|"blk end"
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Loop putting entries into the user buffer. 	 */
for|for
control|(
init|;
name|i
operator|<
name|nsbuf
condition|;
name|i
operator|++
operator|,
name|sbp
operator|++
control|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
name|namesp
operator|=
operator|(
name|sbp
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
condition|?
operator|&
name|attr_secure
else|:
operator|(
operator|(
name|sbp
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
condition|?
operator|&
name|attr_trusted
else|:
operator|&
name|attr_user
operator|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|->
name|hashval
operator|!=
name|sbp
operator|->
name|hash
condition|)
block|{
name|cursor
operator|->
name|hashval
operator|=
name|sbp
operator|->
name|hash
expr_stmt|;
name|cursor
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|ASSERT
argument_list|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNAMELS
argument_list|)
expr_stmt|;
name|context
operator|->
name|count
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
name|sbp
operator|->
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xfs_attr_put_listent
argument_list|(
name|context
argument_list|,
name|namesp
argument_list|,
name|sbp
operator|->
name|name
argument_list|,
name|sbp
operator|->
name|namelen
argument_list|,
name|sbp
operator|->
name|valuelen
argument_list|)
condition|)
break|break;
block|}
name|cursor
operator|->
name|offset
operator|++
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
name|xfs_attr_trace_l_c
argument_list|(
literal|"sf E-O-F"
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check a leaf attribute block to see if all the entries would fit into  * a shortform attribute list.  */
end_comment

begin_function
name|int
name|xfs_attr_shortform_allfit
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|i
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
name|bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xfs_attr_sf_hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
condition|)
continue|continue;
comment|/* don't copy partial entries */
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_loc
operator|->
name|namelen
operator|>=
name|XFS_ATTR_SF_ENTSIZE_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
operator|>=
name|XFS_ATTR_SF_ENTSIZE_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bytes
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|xfs_attr_sf_entry
argument_list|)
operator|-
literal|1
operator|+
name|name_loc
operator|->
name|namelen
operator|+
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dp
operator|->
name|i_mount
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
operator|&&
operator|(
name|bytes
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|xfs_attr_sf_hdr
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|xfs_attr_shortform_bytesfit
argument_list|(
name|dp
argument_list|,
name|bytes
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a leaf attribute list to shortform attribute list  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_to_shortform
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|forkoff
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|xfs_da_args_t
name|nargs
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_attr_leafblock_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bp
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clean out the prior contents of the attribute list. 	 */
name|error
operator|=
name|xfs_da_shrink_inode
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|forkoff
operator|==
operator|-
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_mount
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
argument_list|)
expr_stmt|;
comment|/* 		 * Last attribute was removed, revert to original 		 * inode format making all literal area available 		 * to the data fork once more. 		 */
name|xfs_idestroy_fork
argument_list|(
name|dp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_aformat
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_afp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|xfs_attr_shortform_create
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the attributes 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nargs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
name|nargs
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|nargs
operator|.
name|firstblock
operator|=
name|args
operator|->
name|firstblock
expr_stmt|;
name|nargs
operator|.
name|flist
operator|=
name|args
operator|->
name|flist
expr_stmt|;
name|nargs
operator|.
name|total
operator|=
name|args
operator|->
name|total
expr_stmt|;
name|nargs
operator|.
name|whichfork
operator|=
name|XFS_ATTR_FORK
expr_stmt|;
name|nargs
operator|.
name|trans
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|nargs
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
condition|)
continue|continue;
comment|/* don't copy partial entries */
if|if
condition|(
operator|!
name|entry
operator|->
name|nameidx
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
argument_list|)
expr_stmt|;
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nargs
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
expr_stmt|;
name|nargs
operator|.
name|namelen
operator|=
name|name_loc
operator|->
name|namelen
expr_stmt|;
name|nargs
operator|.
name|value
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|name_loc
operator|->
name|nameval
index|[
name|nargs
operator|.
name|namelen
index|]
expr_stmt|;
name|nargs
operator|.
name|valuelen
operator|=
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|nargs
operator|.
name|hashval
operator|=
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|nargs
operator|.
name|flags
operator|=
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
condition|?
name|ATTR_SECURE
else|:
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
condition|?
name|ATTR_ROOT
else|:
literal|0
operator|)
expr_stmt|;
name|xfs_attr_shortform_add
argument_list|(
operator|&
name|nargs
argument_list|,
name|forkoff
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from using a single leaf to a root node and a leaf.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_to_node
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp1
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|bp1
operator|=
name|bp2
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp1
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|bp1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp2
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp2
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|bp2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp2
operator|->
name|data
argument_list|,
name|bp1
operator|->
name|data
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
name|bp1
operator|=
name|NULL
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp2
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the new root node. 	 */
name|error
operator|=
name|xfs_da_node_create
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|bp1
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|node
operator|=
name|bp1
operator|->
name|data
expr_stmt|;
name|leaf
operator|=
name|bp2
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
comment|/* both on-disk, don't endian-flip twice */
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
operator|=
name|leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
expr_stmt|;
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|before
operator|=
name|cpu_to_be32
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
name|node
operator|->
name|hdr
operator|.
name|count
operator|=
name|cpu_to_be16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp1
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|bp1
condition|)
name|xfs_da_buf_done
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp2
condition|)
name|xfs_da_buf_done
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for growing the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Create the initial contents of a leaf attribute list  * or a leaf in a node attribute list.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_create
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
name|blkno
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|hdr
operator|->
name|info
operator|.
name|magic
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|firstused
condition|)
block|{
name|hdr
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
name|XFS_ATTR_LEAF_NAME_ALIGN
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|cpu_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|cpu_to_be16
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split the leaf node, rebalance, then add the new entry.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|oldblk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|newblk
parameter_list|)
block|{
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Allocate space for a new leaf node. 	 */
name|ASSERT
argument_list|(
name|oldblk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|state
operator|->
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|xfs_attr_leaf_create
argument_list|(
name|state
operator|->
name|args
argument_list|,
name|blkno
argument_list|,
operator|&
name|newblk
operator|->
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newblk
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|newblk
operator|->
name|magic
operator|=
name|XFS_ATTR_LEAF_MAGIC
expr_stmt|;
comment|/* 	 * Rebalance the entries across the two leaves. 	 * NOTE: rebalance() currently depends on the 2nd block being empty. 	 */
name|xfs_attr_leaf_rebalance
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_blk_link
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Save info on "old" attribute for "atomic rename" ops, leaf_add() 	 * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the 	 * "new" attrs info.  Will need the "old" info to remove it later. 	 * 	 * Insert the "new" entry in the correct block. 	 */
if|if
condition|(
name|state
operator|->
name|inleaf
condition|)
name|error
operator|=
name|xfs_attr_leaf_add
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|,
name|state
operator|->
name|args
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|xfs_attr_leaf_add
argument_list|(
name|newblk
operator|->
name|bp
argument_list|,
name|state
operator|->
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Update last hashval in each block since we added the name. 	 */
name|oldblk
operator|->
name|hashval
operator|=
name|xfs_attr_leaf_lasthash
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|hashval
operator|=
name|xfs_attr_leaf_lasthash
argument_list|(
name|newblk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a name to the leaf attribute list structure.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_add
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_attr_leaf_map_t
modifier|*
name|map
decl_stmt|;
name|int
name|tablesize
decl_stmt|,
name|entsize
decl_stmt|,
name|sum
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|args
operator|->
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|args
operator|->
name|index
operator|<=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|entsize
operator|=
name|xfs_attr_leaf_newentsize
argument_list|(
name|args
operator|->
name|namelen
argument_list|,
name|args
operator|->
name|valuelen
argument_list|,
name|args
operator|->
name|trans
operator|->
name|t_mountp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Search through freemap for first-fit on new name length. 	 * (may need to figure in size of entry struct too) 	 */
name|tablesize
operator|=
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|XFS_ATTR_LEAF_MAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
name|XFS_ATTR_LEAF_MAPSIZE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|map
operator|--
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|tablesize
operator|>
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|map
operator|->
name|size
condition|)
continue|continue;
comment|/* no space in this map */
name|tmp
operator|=
name|entsize
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|<
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
condition|)
name|tmp
operator|+=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|>=
name|tmp
condition|)
block|{
name|tmp
operator|=
name|xfs_attr_leaf_add_work
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
name|sum
operator|+=
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are no holes in the address space of the block, 	 * and we don't have enough freespace, then compaction will do us 	 * no good and we should just give up. 	 */
if|if
condition|(
operator|!
name|hdr
operator|->
name|holes
operator|&&
operator|(
name|sum
operator|<
name|entsize
operator|)
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
comment|/* 	 * Compact the entries to coalesce free space. 	 * This may change the hdr->count via dropping INCOMPLETE entries. 	 */
name|xfs_attr_leaf_compact
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * After compaction, the block is guaranteed to have only one 	 * free region, in freemap[0].  If it is not big enough, give up. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
argument_list|)
operator|<
operator|(
name|entsize
operator|+
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|)
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
return|return
operator|(
name|xfs_attr_leaf_add_work
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a name to a leaf attribute list structure.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_add_work
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|mapindex
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|xfs_attr_leaf_map_t
modifier|*
name|map
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|mapindex
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|mapindex
operator|<
name|XFS_ATTR_LEAF_MAPSIZE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|args
operator|->
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|args
operator|->
name|index
operator|<=
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Force open some space in the entry array and fill it in. 	 */
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|args
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|-
name|args
operator|->
name|index
expr_stmt|;
name|tmp
operator|*=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|entry
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
name|tmp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|be16_add
argument_list|(
operator|&
name|hdr
operator|->
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for the new string (at the end of the run). 	 */
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|mapindex
index|]
expr_stmt|;
name|mp
operator|=
name|args
operator|->
name|trans
operator|->
name|t_mountp
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|>=
name|xfs_attr_leaf_newentsize
argument_list|(
name|args
operator|->
name|namelen
argument_list|,
name|args
operator|->
name|valuelen
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
operator|-
name|xfs_attr_leaf_newentsize
argument_list|(
name|args
operator|->
name|namelen
argument_list|,
name|args
operator|->
name|valuelen
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
operator|&
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nameidx
operator|=
name|cpu_to_be16
argument_list|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|+
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|hashval
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|tmp
condition|?
name|XFS_ATTR_LOCAL
else|:
literal|0
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
condition|?
name|XFS_ATTR_SECURE
else|:
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
condition|?
name|XFS_ATTR_ROOT
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rename
condition|)
block|{
name|entry
operator|->
name|flags
operator||=
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|args
operator|->
name|blkno2
operator|==
name|args
operator|->
name|blkno
operator|)
operator|&&
operator|(
name|args
operator|->
name|index2
operator|<=
name|args
operator|->
name|index
operator|)
condition|)
block|{
name|args
operator|->
name|index2
operator|++
expr_stmt|;
block|}
block|}
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|args
operator|->
name|index
operator|==
literal|0
operator|)
operator|||
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|>=
name|be32_to_cpu
argument_list|(
operator|(
name|entry
operator|-
literal|1
operator|)
operator|->
name|hashval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|args
operator|->
name|index
operator|==
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|<=
name|be32_to_cpu
argument_list|(
operator|(
name|entry
operator|+
literal|1
operator|)
operator|->
name|hashval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the attribute name and value into the new space. 	 * 	 * For "remote" attribute values, simply note that we need to 	 * allocate space for the "remote" value.  We can't actually 	 * allocate the extents in this transaction, and we can't decide 	 * which blocks they should be as we might allocate more blocks 	 * as part of this transaction (a split operation for example). 	 */
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|name_loc
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|name_loc
operator|->
name|valuelen
operator|=
name|cpu_to_be16
argument_list|(
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|name_loc
operator|->
name|nameval
index|[
name|args
operator|->
name|namelen
index|]
argument_list|,
name|args
operator|->
name|value
argument_list|,
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name_rmt
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
comment|/* just in case */
name|name_rmt
operator|->
name|valuelen
operator|=
literal|0
expr_stmt|;
name|name_rmt
operator|->
name|valueblk
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|rmtblkno
operator|=
literal|1
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
block|}
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
argument_list|,
name|xfs_attr_leaf_entsize
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the control info for this leaf node 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|<
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
condition|)
block|{
comment|/* both on-disk, don't endian-flip twice */
name|hdr
operator|->
name|firstused
operator|=
name|entry
operator|->
name|nameidx
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
operator|>=
operator|(
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XFS_ATTR_LEAF_MAPSIZE
condition|;
name|map
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|==
name|tmp
condition|)
block|{
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
operator|-
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|be16_add
argument_list|(
operator|&
name|hdr
operator|->
name|usedbytes
argument_list|,
name|xfs_attr_leaf_entsize
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Garbage collect a leaf attribute list block by copying it to a new buffer.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_attr_leaf_compact
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf_s
decl_stmt|,
modifier|*
name|leaf_d
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr_s
decl_stmt|,
modifier|*
name|hdr_d
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
name|mp
operator|=
name|trans
operator|->
name|t_mountp
expr_stmt|;
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bp
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy basic information 	 */
name|leaf_s
operator|=
operator|(
name|xfs_attr_leafblock_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|leaf_d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|hdr_s
operator|=
operator|&
name|leaf_s
operator|->
name|hdr
expr_stmt|;
name|hdr_d
operator|=
operator|&
name|leaf_d
operator|->
name|hdr
expr_stmt|;
name|hdr_d
operator|->
name|info
operator|=
name|hdr_s
operator|->
name|info
expr_stmt|;
comment|/* struct copy */
name|hdr_d
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* handle truncation gracefully */
if|if
condition|(
operator|!
name|hdr_d
operator|->
name|firstused
condition|)
block|{
name|hdr_d
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|-
name|XFS_ATTR_LEAF_NAME_ALIGN
argument_list|)
expr_stmt|;
block|}
name|hdr_d
operator|->
name|usedbytes
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|holes
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|cpu_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|cpu_to_be16
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy all entry's in the same (sorted) order, 	 * but allocate name/value pairs packed and in sequence. 	 */
name|xfs_attr_leaf_moveents
argument_list|(
name|leaf_s
argument_list|,
literal|0
argument_list|,
name|leaf_d
argument_list|,
literal|0
argument_list|,
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Redistribute the attribute list entries between two leaf nodes,  * taking into account the size of the new entry.  *  * NOTE: if new block is empty, then it will get the upper half of the  * old block.  At present, all (one) callers pass in an empty second block.  *  * This code adjusts the args->index/blkno and args->index2/blkno2 fields  * to match what it is doing in splitting the attribute leaf block.  Those  * values are used in "atomic rename" operations on attributes.  Note that  * the "new" and "old" values can end up in different blocks.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_attr_leaf_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
block|{
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|tmp_blk
decl_stmt|;
name|xfs_attr_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr1
decl_stmt|,
modifier|*
name|hdr2
decl_stmt|;
name|int
name|count
decl_stmt|,
name|totallen
decl_stmt|,
name|max
decl_stmt|,
name|space
decl_stmt|,
name|swap
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|ASSERT
argument_list|(
name|blk1
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk2
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
comment|/* 	 * Check ordering of blocks, reverse if it makes things simpler. 	 * 	 * NOTE: Given that all (current) callers pass in an empty 	 * second block, this code should never set "swap". 	 */
name|swap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfs_attr_leaf_order
argument_list|(
name|blk1
operator|->
name|bp
argument_list|,
name|blk2
operator|->
name|bp
argument_list|)
condition|)
block|{
name|tmp_blk
operator|=
name|blk1
expr_stmt|;
name|blk1
operator|=
name|blk2
expr_stmt|;
name|blk2
operator|=
name|tmp_blk
expr_stmt|;
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|swap
operator|=
literal|1
expr_stmt|;
block|}
name|hdr1
operator|=
operator|&
name|leaf1
operator|->
name|hdr
expr_stmt|;
name|hdr2
operator|=
operator|&
name|leaf2
operator|->
name|hdr
expr_stmt|;
comment|/* 	 * Examine entries until we reduce the absolute difference in 	 * byte usage between the two blocks to a minimum.  Then get 	 * the direction to copy and the number of elements to move. 	 * 	 * "inleaf" is true if the new entry should be inserted into blk1. 	 * If "swap" is also true, then reverse the sense of "inleaf". 	 */
name|state
operator|->
name|inleaf
operator|=
name|xfs_attr_leaf_figure_balance
argument_list|(
name|state
argument_list|,
name|blk1
argument_list|,
name|blk2
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|totallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|state
operator|->
name|inleaf
operator|=
operator|!
name|state
operator|->
name|inleaf
expr_stmt|;
comment|/* 	 * Move any entries required from leaf to leaf: 	 */
if|if
condition|(
name|count
operator|<
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
condition|)
block|{
comment|/* 		 * Figure the total bytes to be added to the destination leaf. 		 */
comment|/* number entries being moved */
name|count
operator|=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
operator|-
name|count
expr_stmt|;
name|space
operator|=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|usedbytes
argument_list|)
operator|-
name|totallen
expr_stmt|;
name|space
operator|+=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
comment|/* 		 * leaf2 is the destination, compact it if it looks tight. 		 */
name|max
operator|=
name|be16_to_cpu
argument_list|(
name|hdr2
operator|->
name|firstused
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|max
operator|-=
name|be16_to_cpu
argument_list|(
name|hdr2
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
name|max
condition|)
block|{
name|xfs_attr_leaf_compact
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk2
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move high entries from leaf1 to low end of leaf2. 		 */
name|xfs_attr_leaf_moveents
argument_list|(
name|leaf1
argument_list|,
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
operator|-
name|count
argument_list|,
name|leaf2
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|state
operator|->
name|mp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
condition|)
block|{
comment|/* 		 * I assert that since all callers pass in an empty 		 * second buffer, this code should never execute. 		 */
comment|/* 		 * Figure the total bytes to be added to the destination leaf. 		 */
comment|/* number entries being moved */
name|count
operator|-=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
expr_stmt|;
name|space
operator|=
name|totallen
operator|-
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|usedbytes
argument_list|)
expr_stmt|;
name|space
operator|+=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
comment|/* 		 * leaf1 is the destination, compact it if it looks tight. 		 */
name|max
operator|=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|firstused
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|max
operator|-=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
name|max
condition|)
block|{
name|xfs_attr_leaf_compact
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk1
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move low entries from leaf2 to high end of leaf1. 		 */
name|xfs_attr_leaf_moveents
argument_list|(
name|leaf2
argument_list|,
literal|0
argument_list|,
name|leaf1
argument_list|,
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
argument_list|,
name|count
argument_list|,
name|state
operator|->
name|mp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy out last hashval in each block for B-tree code. 	 */
name|blk1
operator|->
name|hashval
operator|=
name|be32_to_cpu
argument_list|(
name|leaf1
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
expr_stmt|;
name|blk2
operator|->
name|hashval
operator|=
name|be32_to_cpu
argument_list|(
name|leaf2
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the expected index for insertion. 	 * NOTE: this code depends on the (current) situation that the 	 * second block was originally empty. 	 * 	 * If the insertion point moved to the 2nd block, we must adjust 	 * the index.  We must also track the entry just following the 	 * new entry for use in an "atomic rename" operation, that entry 	 * is always the "old" entry and the "new" entry is what we are 	 * inserting.  The index/blkno fields refer to the "old" entry, 	 * while the index2/blkno2 fields refer to the "new" entry. 	 */
if|if
condition|(
name|blk1
operator|->
name|index
operator|>
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|inleaf
operator|==
literal|0
argument_list|)
expr_stmt|;
name|blk2
operator|->
name|index
operator|=
name|blk1
operator|->
name|index
operator|-
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|args
operator|->
name|index
operator|=
name|args
operator|->
name|index2
operator|=
name|blk2
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|args
operator|->
name|blkno2
operator|=
name|blk2
operator|->
name|blkno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blk1
operator|->
name|index
operator|==
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|inleaf
condition|)
block|{
name|args
operator|->
name|index
operator|=
name|blk1
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|blk1
operator|->
name|blkno
expr_stmt|;
name|args
operator|->
name|index2
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|blkno2
operator|=
name|blk2
operator|->
name|blkno
expr_stmt|;
block|}
else|else
block|{
name|blk2
operator|->
name|index
operator|=
name|blk1
operator|->
name|index
operator|-
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|args
operator|->
name|index
operator|=
name|args
operator|->
name|index2
operator|=
name|blk2
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|args
operator|->
name|blkno2
operator|=
name|blk2
operator|->
name|blkno
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|inleaf
operator|==
literal|1
argument_list|)
expr_stmt|;
name|args
operator|->
name|index
operator|=
name|args
operator|->
name|index2
operator|=
name|blk1
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|args
operator|->
name|blkno2
operator|=
name|blk1
operator|->
name|blkno
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Examine entries until we reduce the absolute difference in  * byte usage between the two blocks to a minimum.  * GROT: Is this really necessary?  With other than a 512 byte blocksize,  * GROT: there will always be enough room in either block for a new entry.  * GROT: Do a double-split for this case?  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_figure_balance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|,
name|int
modifier|*
name|countarg
parameter_list|,
name|int
modifier|*
name|usedbytesarg
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr1
decl_stmt|,
modifier|*
name|hdr2
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|int
name|count
decl_stmt|,
name|max
decl_stmt|,
name|index
decl_stmt|,
name|totallen
decl_stmt|,
name|half
decl_stmt|;
name|int
name|lastdelta
decl_stmt|,
name|foundit
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|hdr1
operator|=
operator|&
name|leaf1
operator|->
name|hdr
expr_stmt|;
name|hdr2
operator|=
operator|&
name|leaf2
operator|->
name|hdr
expr_stmt|;
name|foundit
operator|=
literal|0
expr_stmt|;
name|totallen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Examine entries until we reduce the absolute difference in 	 * byte usage between the two blocks to a minimum. 	 */
name|max
operator|=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
operator|+
name|be16_to_cpu
argument_list|(
name|hdr2
operator|->
name|count
argument_list|)
expr_stmt|;
name|half
operator|=
operator|(
name|max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
expr_stmt|;
name|half
operator|+=
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|usedbytes
argument_list|)
operator|+
name|be16_to_cpu
argument_list|(
name|hdr2
operator|->
name|usedbytes
argument_list|)
operator|+
name|xfs_attr_leaf_newentsize
argument_list|(
name|state
operator|->
name|args
operator|->
name|namelen
argument_list|,
name|state
operator|->
name|args
operator|->
name|valuelen
argument_list|,
name|state
operator|->
name|blocksize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|half
operator|/=
literal|2
expr_stmt|;
name|lastdelta
operator|=
name|state
operator|->
name|blocksize
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf1
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|count
operator|=
name|index
operator|=
literal|0
init|;
name|count
operator|<
name|max
condition|;
name|entry
operator|++
operator|,
name|index
operator|++
operator|,
name|count
operator|++
control|)
block|{
define|#
directive|define
name|XFS_ATTR_ABS
parameter_list|(
name|A
parameter_list|)
value|(((A)< 0) ? -(A) : (A))
comment|/* 		 * The new entry is in the first block, account for it. 		 */
if|if
condition|(
name|count
operator|==
name|blk1
operator|->
name|index
condition|)
block|{
name|tmp
operator|=
name|totallen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
name|xfs_attr_leaf_newentsize
argument_list|(
name|state
operator|->
name|args
operator|->
name|namelen
argument_list|,
name|state
operator|->
name|args
operator|->
name|valuelen
argument_list|,
name|state
operator|->
name|blocksize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_ATTR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
operator|>
name|lastdelta
condition|)
break|break;
name|lastdelta
operator|=
name|XFS_ATTR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|tmp
expr_stmt|;
name|foundit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Wrap around into the second block if necessary. 		 */
if|if
condition|(
name|count
operator|==
name|be16_to_cpu
argument_list|(
name|hdr1
operator|->
name|count
argument_list|)
condition|)
block|{
name|leaf1
operator|=
name|leaf2
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf1
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Figure out if next leaf entry would be too much. 		 */
name|tmp
operator|=
name|totallen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
name|xfs_attr_leaf_entsize
argument_list|(
name|leaf1
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_ATTR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
operator|>
name|lastdelta
condition|)
break|break;
name|lastdelta
operator|=
name|XFS_ATTR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|tmp
expr_stmt|;
undef|#
directive|undef
name|XFS_ATTR_ABS
block|}
comment|/* 	 * Calculate the number of usedbytes that will end up in lower block. 	 * If new entry not in lower block, fix up the count. 	 */
name|totallen
operator|-=
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundit
condition|)
block|{
name|totallen
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
name|xfs_attr_leaf_newentsize
argument_list|(
name|state
operator|->
name|args
operator|->
name|namelen
argument_list|,
name|state
operator|->
name|args
operator|->
name|valuelen
argument_list|,
name|state
operator|->
name|blocksize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|countarg
operator|=
name|count
expr_stmt|;
operator|*
name|usedbytesarg
operator|=
name|totallen
expr_stmt|;
return|return
operator|(
name|foundit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for shrinking the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Check a leaf block and its neighbors to see if the block should be  * collapsed into one or the other neighbor.  Always keep the block  * with the smaller block number.  * If the current block is over 50% full, don't try to join it, return 0.  * If the block is empty, fill in the state structure and return 2.  * If it can be collapsed, fill in the state structure and return 1.  * If nothing can be done, return 0.  *  * GROT: allow for INCOMPLETE entries in calculation.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_toosmall
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|action
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|int
name|count
decl_stmt|,
name|bytes
decl_stmt|,
name|forward
decl_stmt|,
name|error
decl_stmt|,
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Check for the degenerate case of the block being over 50% full. 	 * If so, it's not worth even looking to see if we might be able 	 * to coalesce with a sibling. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|info
operator|->
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_attr_leafblock_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|bytes
operator|=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|+
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|usedbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
operator|(
name|state
operator|->
name|blocksize
operator|>>
literal|1
operator|)
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
comment|/* blk over 50%, don't try to join */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for the degenerate case of the block being empty. 	 * If the block is empty, we'll simply delete it, no need to 	 * coalesce it with a sibling block.  We choose (arbitrarily) 	 * to merge with the forward block unless it is NULL. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Make altpath point to the block we want to keep and 		 * path point to the block we want to drop (this one). 		 */
name|forward
operator|=
operator|(
name|info
operator|->
name|forw
operator|!=
literal|0
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|action
operator|=
literal|2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Examine each sibling block to see if we can coalesce with 	 * at least 25% free space to spare.  We need to figure out 	 * whether to merge with the forward or the backward block. 	 * We prefer coalescing with the lower numbered sibling so as 	 * to shrink an attribute list over time. 	 */
comment|/* start with smaller blk num */
name|forward
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|forw
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|back
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|forward
operator|=
operator|!
name|forward
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|forward
condition|)
name|blkno
operator|=
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|forw
argument_list|)
expr_stmt|;
else|else
name|blkno
operator|=
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_attr_leafblock_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|state
operator|->
name|blocksize
operator|-
operator|(
name|state
operator|->
name|blocksize
operator|>>
literal|2
operator|)
expr_stmt|;
name|bytes
operator|-=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|usedbytes
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|count
operator|+=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|usedbytes
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|bytes
operator|-=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|0
condition|)
break|break;
comment|/* fits with at least 25% to spare */
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make altpath point to the block we want to keep (the lower 	 * numbered block) and path point to the block we want to drop. 	 */
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|blk
operator|->
name|blkno
condition|)
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|action
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from the leaf attribute list structure.  *  * Return 1 if leaf is less than 37% full, 0 if>= 37% full.  * If two leaves are 37% full, when combined they will leave 25% free.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_remove
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_attr_leaf_map_t
modifier|*
name|map
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|int
name|before
decl_stmt|,
name|after
decl_stmt|,
name|smallest
decl_stmt|,
name|entsize
decl_stmt|;
name|int
name|tablesize
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|mp
operator|=
name|args
operator|->
name|trans
operator|->
name|t_mountp
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|/
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|args
operator|->
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|args
operator|->
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
operator|>=
operator|(
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|args
operator|->
name|index
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Scan through free region table: 	 *    check for adjacency of free'd entry with an existing one, 	 *    find smallest free region in case we need to replace it, 	 *    adjust any map that borders the entry table, 	 */
name|tablesize
operator|=
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
expr_stmt|;
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
name|before
operator|=
name|after
operator|=
operator|-
literal|1
expr_stmt|;
name|smallest
operator|=
name|XFS_ATTR_LEAF_MAPSIZE
operator|-
literal|1
expr_stmt|;
name|entsize
operator|=
name|xfs_attr_leaf_entsize
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XFS_ATTR_LEAF_MAPSIZE
condition|;
name|map
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|==
name|tablesize
condition|)
block|{
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|base
argument_list|,
operator|-
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|+
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|)
operator|==
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
condition|)
block|{
name|before
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|base
argument_list|)
operator|==
operator|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|+
name|entsize
operator|)
condition|)
block|{
name|after
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|<
name|tmp
condition|)
block|{
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
expr_stmt|;
name|smallest
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * Coalesce adjacent freemap regions, 	 * or replace the smallest region. 	 */
if|if
condition|(
operator|(
name|before
operator|>=
literal|0
operator|)
operator|||
operator|(
name|after
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|before
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|after
operator|>=
literal|0
operator|)
condition|)
block|{
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|before
index|]
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|before
operator|>=
literal|0
condition|)
block|{
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|before
index|]
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
expr_stmt|;
comment|/* both on-disk, don't endian flip twice */
name|map
operator|->
name|base
operator|=
name|entry
operator|->
name|nameidx
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|map
operator|->
name|size
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Replace smallest region (if it is smaller than free'd entry) 		 */
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|smallest
index|]
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|map
operator|->
name|size
argument_list|)
operator|<
name|entsize
condition|)
block|{
name|map
operator|->
name|base
operator|=
name|cpu_to_be16
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|cpu_to_be16
argument_list|(
name|entsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Did we remove the first entry? 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|==
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
condition|)
name|smallest
operator|=
literal|1
expr_stmt|;
else|else
name|smallest
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compress the remaining entries and zero out the removed stuff. 	 */
name|memset
argument_list|(
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
argument_list|,
literal|0
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr
operator|->
name|usedbytes
argument_list|,
operator|-
name|entsize
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
argument_list|,
name|entsize
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|-
name|args
operator|->
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|entry
operator|+
literal|1
operator|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr
operator|->
name|count
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
name|tmp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
index|]
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we removed the first entry, re-find the first used byte 	 * in the name area.  Note that if the entry was the "firstused", 	 * then we don't have a "hole" in our block resulting from 	 * removing the name. 	 */
if|if
condition|(
name|smallest
condition|)
block|{
name|tmp
operator|=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|count
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|entry
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|<
name|tmp
condition|)
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|firstused
condition|)
block|{
name|hdr
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|tmp
operator|-
name|XFS_ATTR_LEAF_NAME_ALIGN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hdr
operator|->
name|holes
operator|=
literal|1
expr_stmt|;
comment|/* mark as needing compaction */
block|}
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if leaf is less than 50% full, caller may want to 	 * "join" the leaf with a sibling if so. 	 */
name|tmp
operator|=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|usedbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|<
name|mp
operator|->
name|m_attr_magicpct
operator|)
return|;
comment|/* leaf is< 37% full */
block|}
end_function

begin_comment
comment|/*  * Move all the attribute list entries from drop_leaf into save_leaf.  */
end_comment

begin_function
name|void
name|xfs_attr_leaf_unbalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|save_blk
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|drop_leaf
decl_stmt|,
modifier|*
name|save_leaf
decl_stmt|,
modifier|*
name|tmp_leaf
decl_stmt|;
name|xfs_attr_leaf_hdr_t
modifier|*
name|drop_hdr
decl_stmt|,
modifier|*
name|save_hdr
decl_stmt|,
modifier|*
name|tmp_hdr
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|mp
operator|=
name|state
operator|->
name|mp
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|save_blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|drop_leaf
operator|=
name|drop_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|save_leaf
operator|=
name|save_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|drop_hdr
operator|=
operator|&
name|drop_leaf
operator|->
name|hdr
expr_stmt|;
name|save_hdr
operator|=
operator|&
name|save_leaf
operator|->
name|hdr
expr_stmt|;
comment|/* 	 * Save last hashval from dying block for later Btree fixup. 	 */
name|drop_blk
operator|->
name|hashval
operator|=
name|be32_to_cpu
argument_list|(
name|drop_leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we need a temp buffer, or can we do it in place. 	 * Note that we don't check "leaf" for holes because we will 	 * always be dropping it, toosmall() decided that for us already. 	 */
if|if
condition|(
name|save_hdr
operator|->
name|holes
operator|==
literal|0
condition|)
block|{
comment|/* 		 * dest leaf has no holes, so we add there.  May need 		 * to make some room in the entry array. 		 */
if|if
condition|(
name|xfs_attr_leaf_order
argument_list|(
name|save_blk
operator|->
name|bp
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
condition|)
block|{
name|xfs_attr_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|save_leaf
argument_list|,
literal|0
argument_list|,
name|be16_to_cpu
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_attr_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|save_leaf
argument_list|,
name|be16_to_cpu
argument_list|(
name|save_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|be16_to_cpu
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Destination has holes, so we make a temporary copy 		 * of the leaf and add them both to that. 		 */
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|state
operator|->
name|blocksize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmpbuffer
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|tmp_leaf
operator|=
operator|(
name|xfs_attr_leafblock_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|tmp_hdr
operator|=
operator|&
name|tmp_leaf
operator|->
name|hdr
expr_stmt|;
name|tmp_hdr
operator|->
name|info
operator|=
name|save_hdr
operator|->
name|info
expr_stmt|;
comment|/* struct copy */
name|tmp_hdr
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|tmp_hdr
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_hdr
operator|->
name|firstused
condition|)
block|{
name|tmp_hdr
operator|->
name|firstused
operator|=
name|cpu_to_be16
argument_list|(
name|state
operator|->
name|blocksize
operator|-
name|XFS_ATTR_LEAF_NAME_ALIGN
argument_list|)
expr_stmt|;
block|}
name|tmp_hdr
operator|->
name|usedbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfs_attr_leaf_order
argument_list|(
name|save_blk
operator|->
name|bp
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
condition|)
block|{
name|xfs_attr_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
literal|0
argument_list|,
name|be16_to_cpu
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_attr_leaf_moveents
argument_list|(
name|save_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
name|be16_to_cpu
argument_list|(
name|tmp_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|,
name|be16_to_cpu
argument_list|(
name|save_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_attr_leaf_moveents
argument_list|(
name|save_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
literal|0
argument_list|,
name|be16_to_cpu
argument_list|(
name|save_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_attr_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
name|be16_to_cpu
argument_list|(
name|tmp_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|,
name|be16_to_cpu
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save_leaf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp_leaf
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Copy out last hashval in each block for B-tree code. 	 */
name|save_blk
operator|->
name|hashval
operator|=
name|be32_to_cpu
argument_list|(
name|save_leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for finding things in the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Look up a name in a leaf attribute list structure.  * This is the internal routine, it uses the caller's buffer.  *  * Note that duplicate keys are allowed, but only check within the  * current leaf node.  The Btree code must check in adjacent leaf nodes.  *  * Return in args->index the index into the entry[] array of either  * the found entry, or where the entry should have been (insert before  * that entry).  *  * Don't change the args->value unless we find the attribute.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_lookup_int
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|int
name|probe
decl_stmt|,
name|span
decl_stmt|;
name|xfs_dahash_t
name|hashval
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|args
operator|->
name|dp
operator|->
name|i_mount
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Binary search.  (note: small blocks will skip this loop) 	 */
name|hashval
operator|=
name|args
operator|->
name|hashval
expr_stmt|;
name|probe
operator|=
name|span
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|probe
index|]
init|;
name|span
operator|>
literal|4
condition|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|probe
index|]
control|)
block|{
name|span
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|<
name|hashval
condition|)
name|probe
operator|+=
name|span
expr_stmt|;
elseif|else
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|>
name|hashval
condition|)
name|probe
operator|-=
name|span
expr_stmt|;
else|else
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|probe
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|count
operator|||
operator|(
name|probe
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|span
operator|<=
literal|4
operator|)
operator|||
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|==
name|hashval
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Since we may have duplicate hashval's, find the first matching 	 * hashval in the leaf. 	 */
while|while
condition|(
operator|(
name|probe
operator|>
literal|0
operator|)
operator|&&
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|>=
name|hashval
operator|)
condition|)
block|{
name|entry
operator|--
expr_stmt|;
name|probe
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|probe
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|)
operator|&&
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|<
name|hashval
operator|)
condition|)
block|{
name|entry
operator|++
expr_stmt|;
name|probe
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|probe
operator|==
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|)
operator|||
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|!=
name|hashval
operator|)
condition|)
block|{
name|args
operator|->
name|index
operator|=
name|probe
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Duplicate keys may be present, so search all of them for a match. 	 */
for|for
control|(
init|;
operator|(
name|probe
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|)
operator|&&
operator|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|==
name|hashval
operator|)
condition|;
name|entry
operator|++
operator|,
name|probe
operator|++
control|)
block|{
comment|/*  * GROT: Add code to remove incomplete entries.  */
comment|/* 		 * If we are looking for INCOMPLETE entries, show only those. 		 * If we are looking for complete entries, show only those. 		 */
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
operator|)
operator|!=
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_loc
operator|->
name|namelen
operator|!=
name|args
operator|->
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
name|args
operator|->
name|index
operator|=
name|probe
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_rmt
operator|->
name|namelen
operator|!=
name|args
operator|->
name|namelen
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name_rmt
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|args
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
name|args
operator|->
name|index
operator|=
name|probe
expr_stmt|;
name|args
operator|->
name|rmtblkno
operator|=
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valueblk
argument_list|)
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|args
operator|->
name|dp
operator|->
name|i_mount
argument_list|,
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valuelen
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
block|}
name|args
operator|->
name|index
operator|=
name|probe
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the value associated with an attribute name from a leaf attribute  * list structure.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_getvalue
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|int
name|valuelen
decl_stmt|;
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|args
operator|->
name|dp
operator|->
name|i_mount
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|args
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|name_loc
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|name_loc
operator|->
name|nameval
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|valuelen
operator|=
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|args
operator|->
name|valuelen
operator|=
name|valuelen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|args
operator|->
name|valuelen
operator|<
name|valuelen
condition|)
block|{
name|args
operator|->
name|valuelen
operator|=
name|valuelen
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
block|}
name|args
operator|->
name|valuelen
operator|=
name|valuelen
expr_stmt|;
name|memcpy
argument_list|(
name|args
operator|->
name|value
argument_list|,
operator|&
name|name_loc
operator|->
name|nameval
index|[
name|args
operator|->
name|namelen
index|]
argument_list|,
name|valuelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|name_rmt
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|name_rmt
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|valuelen
operator|=
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|args
operator|->
name|rmtblkno
operator|=
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valueblk
argument_list|)
expr_stmt|;
name|args
operator|->
name|rmtblkcnt
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|args
operator|->
name|dp
operator|->
name|i_mount
argument_list|,
name|valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|args
operator|->
name|valuelen
operator|=
name|valuelen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|args
operator|->
name|valuelen
operator|<
name|valuelen
condition|)
block|{
name|args
operator|->
name|valuelen
operator|=
name|valuelen
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
block|}
name|args
operator|->
name|valuelen
operator|=
name|valuelen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Utility routines.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Move the indicated entries from one leaf to another.  * NOTE: this routine modifies both source and destination leaves.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_attr_leaf_moveents
parameter_list|(
name|xfs_attr_leafblock_t
modifier|*
name|leaf_s
parameter_list|,
name|int
name|start_s
parameter_list|,
name|xfs_attr_leafblock_t
modifier|*
name|leaf_d
parameter_list|,
name|int
name|start_d
parameter_list|,
name|int
name|count
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_attr_leaf_hdr_t
modifier|*
name|hdr_s
decl_stmt|,
modifier|*
name|hdr_d
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry_s
decl_stmt|,
modifier|*
name|entry_d
decl_stmt|;
name|int
name|desti
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Check for nothing to do. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Set up environment. 	 */
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf_s
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr_s
operator|=
operator|&
name|leaf_s
operator|->
name|hdr
expr_stmt|;
name|hdr_d
operator|=
operator|&
name|leaf_d
operator|->
name|hdr
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|/
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|firstused
argument_list|)
operator|>=
operator|(
operator|(
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry_s
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr_s
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|)
operator|>=
operator|(
operator|(
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry_d
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr_d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|start_s
operator|<
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|start_d
operator|<=
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|count
operator|<=
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Move the entries in the destination leaf up to make a hole? 	 */
if|if
condition|(
name|start_d
operator|<
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
operator|-
name|start_d
expr_stmt|;
name|tmp
operator|*=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_d
operator|->
name|entries
index|[
name|start_d
index|]
expr_stmt|;
name|entry_d
operator|=
operator|&
name|leaf_d
operator|->
name|entries
index|[
name|start_d
operator|+
name|count
index|]
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_d
argument_list|,
operator|(
name|char
operator|*
operator|)
name|entry_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy all entry's in the same (sorted) order, 	 * but allocate attribute info packed and in sequence. 	 */
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
index|]
expr_stmt|;
name|entry_d
operator|=
operator|&
name|leaf_d
operator|->
name|entries
index|[
name|start_d
index|]
expr_stmt|;
name|desti
operator|=
name|start_d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|entry_s
operator|++
operator|,
name|entry_d
operator|++
operator|,
name|desti
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry_s
operator|->
name|nameidx
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|firstused
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xfs_attr_leaf_entsize
argument_list|(
name|leaf_s
argument_list|,
name|start_s
operator|+
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GROT
comment|/* 		 * Code to drop INCOMPLETE entries.  Difficult to use as we 		 * may also need to change the insertion index.  Code turned 		 * off for 6.2, should be revisited later. 		 */
if|if
condition|(
name|entry_s
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
condition|)
block|{
comment|/* skip partials? */
name|memset
argument_list|(
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf_s
argument_list|,
name|start_s
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_s
operator|->
name|usedbytes
argument_list|,
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_s
operator|->
name|count
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|entry_d
operator|--
expr_stmt|;
comment|/* to compensate for ++ in loop hdr */
name|desti
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|start_s
operator|+
name|i
operator|)
operator|<
name|offset
condition|)
name|result
operator|++
expr_stmt|;
comment|/* insertion index adjustment */
block|}
else|else
block|{
endif|#
directive|endif
comment|/* GROT */
name|be16_add
argument_list|(
operator|&
name|hdr_d
operator|->
name|firstused
argument_list|,
operator|-
name|tmp
argument_list|)
expr_stmt|;
comment|/* both on-disk, don't endian flip twice */
name|entry_d
operator|->
name|hashval
operator|=
name|entry_s
operator|->
name|hashval
expr_stmt|;
comment|/* both on-disk, don't endian flip twice */
name|entry_d
operator|->
name|nameidx
operator|=
name|hdr_d
operator|->
name|firstused
expr_stmt|;
name|entry_d
operator|->
name|flags
operator|=
name|entry_s
operator|->
name|flags
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry_d
operator|->
name|nameidx
argument_list|)
operator|+
name|tmp
operator|<=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf_d
argument_list|,
name|desti
argument_list|)
argument_list|,
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf_s
argument_list|,
name|start_s
operator|+
name|i
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|entry_s
operator|->
name|nameidx
argument_list|)
operator|+
name|tmp
operator|<=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|XFS_ATTR_LEAF_NAME
argument_list|(
name|leaf_s
argument_list|,
name|start_s
operator|+
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_s
operator|->
name|usedbytes
argument_list|,
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_d
operator|->
name|usedbytes
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_s
operator|->
name|count
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_d
operator|->
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|)
operator|>=
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GROT
block|}
endif|#
directive|endif
comment|/* GROT */
block|}
comment|/* 	 * Zero out the entries we just copied. 	 */
if|if
condition|(
name|start_s
operator|==
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
index|]
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|entry_s
operator|+
name|tmp
operator|)
operator|<=
operator|(
operator|(
name|char
operator|*
operator|)
name|leaf_s
operator|+
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_s
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Move the remaining entries down to fill the hole, 		 * then zero the entries at the top. 		 */
name|tmp
operator|=
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
operator|-
name|count
expr_stmt|;
name|tmp
operator|*=
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
operator|+
name|count
index|]
expr_stmt|;
name|entry_d
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
index|]
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_d
argument_list|,
operator|(
name|char
operator|*
operator|)
name|entry_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|)
index|]
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|entry_s
operator|+
name|tmp
operator|)
operator|<=
operator|(
operator|(
name|char
operator|*
operator|)
name|leaf_s
operator|+
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_s
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the freemap information 	 */
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
operator|=
name|cpu_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|cpu_to_be16
argument_list|(
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|)
operator|-
name|be16_to_cpu
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|1
index|]
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|2
index|]
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|1
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|freemap
index|[
literal|2
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|hdr_s
operator|->
name|holes
operator|=
literal|1
expr_stmt|;
comment|/* leaf may not be compact */
block|}
end_function

begin_comment
comment|/*  * Compare two leaf blocks "order".  * Return 0 unless leaf2 should go before leaf1.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_order
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|leaf1_bp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|leaf2_bp
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|leaf1
operator|=
name|leaf1_bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|leaf2_bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
operator|)
operator|&&
operator|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|be32_to_cpu
argument_list|(
name|leaf2
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|leaf1
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|)
operator|)
operator|||
operator|(
name|be32_to_cpu
argument_list|(
name|leaf2
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|leaf1
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pick up the last hashvalue from a leaf block.  */
end_comment

begin_function
name|xfs_dahash_t
name|xfs_attr_leaf_lasthash
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the number of bytes used to store the indicated attribute  * (whether local or remote only calculate bytes in this block).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_entsize
parameter_list|(
name|xfs_attr_leafblock_t
modifier|*
name|leaf
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|int
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf
operator|->
name|entries
index|[
name|index
index|]
operator|.
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|size
operator|=
name|XFS_ATTR_LEAF_ENTSIZE_LOCAL
argument_list|(
name|name_loc
operator|->
name|namelen
argument_list|,
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|size
operator|=
name|XFS_ATTR_LEAF_ENTSIZE_REMOTE
argument_list|(
name|name_rmt
operator|->
name|namelen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the number of bytes that would be required to store the new  * attribute (whether local or remote only calculate bytes in this block).  * This routine decides as a side effect whether the attribute will be  * a "local" or a "remote" attribute.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_newentsize
parameter_list|(
name|int
name|namelen
parameter_list|,
name|int
name|valuelen
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|int
modifier|*
name|local
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|XFS_ATTR_LEAF_ENTSIZE_LOCAL
argument_list|(
name|namelen
argument_list|,
name|valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX
argument_list|(
name|blocksize
argument_list|)
condition|)
block|{
if|if
condition|(
name|local
condition|)
block|{
operator|*
name|local
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|size
operator|=
name|XFS_ATTR_LEAF_ENTSIZE_REMOTE
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
block|{
operator|*
name|local
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy out attribute list entries for attr_list(), for leaf attribute lists.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_list_int
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|)
block|{
name|attrlist_cursor_kern_t
modifier|*
name|cursor
decl_stmt|;
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|cursor
operator|=
name|context
operator|->
name|cursor
expr_stmt|;
name|cursor
operator|->
name|initted
operator|=
literal|1
expr_stmt|;
name|xfs_attr_trace_l_cl
argument_list|(
literal|"blk start"
argument_list|,
name|context
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
comment|/* 	 * Re-find our place in the leaf block if this is a new syscall. 	 */
if|if
condition|(
name|context
operator|->
name|resynch
condition|)
block|{
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|==
name|cursor
operator|->
name|hashval
condition|)
block|{
if|if
condition|(
name|cursor
operator|->
name|offset
operator|==
name|context
operator|->
name|dupcnt
condition|)
block|{
name|context
operator|->
name|dupcnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|context
operator|->
name|dupcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|>
name|cursor
operator|->
name|hashval
condition|)
block|{
name|context
operator|->
name|dupcnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
block|{
name|xfs_attr_trace_l_c
argument_list|(
literal|"not found"
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|context
operator|->
name|resynch
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We have found our place, start copying out the new attributes. 	 */
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|)
operator|&&
operator|(
name|retval
operator|==
literal|0
operator|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|attrnames_t
modifier|*
name|namesp
decl_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|!=
name|cursor
operator|->
name|hashval
condition|)
block|{
name|cursor
operator|->
name|hashval
operator|=
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|cursor
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
condition|)
continue|continue;
comment|/* skip incomplete entries */
if|if
condition|(
operator|(
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNORMALS
operator|)
condition|)
continue|continue;
comment|/* skip non-matching entries */
if|if
condition|(
operator|(
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNROOTLS
operator|)
condition|)
continue|continue;
comment|/* skip non-matching entries */
name|namesp
operator|=
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_SECURE
operator|)
condition|?
operator|&
name|attr_secure
else|:
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_ROOT
operator|)
condition|?
operator|&
name|attr_trusted
else|:
operator|&
name|attr_user
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|ASSERT
argument_list|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNAMELS
argument_list|)
expr_stmt|;
name|context
operator|->
name|count
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
operator|(
name|int
operator|)
name|name_loc
operator|->
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|xfs_attr_put_listent
argument_list|(
name|context
argument_list|,
name|namesp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
argument_list|,
operator|(
name|int
operator|)
name|name_loc
operator|->
name|namelen
argument_list|,
name|be16_to_cpu
argument_list|(
name|name_loc
operator|->
name|valuelen
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
condition|)
block|{
name|ASSERT
argument_list|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNAMELS
argument_list|)
expr_stmt|;
name|context
operator|->
name|count
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
operator|(
name|int
operator|)
name|name_rmt
operator|->
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|xfs_attr_put_listent
argument_list|(
name|context
argument_list|,
name|namesp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name_rmt
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|name_rmt
operator|->
name|namelen
argument_list|,
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valuelen
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|cursor
operator|->
name|offset
operator|++
expr_stmt|;
block|}
block|}
name|xfs_attr_trace_l_cl
argument_list|(
literal|"blk end"
argument_list|,
name|context
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ATTR_ENTBASESIZE
comment|/* minimum bytes used by an attr */
define|\
value|(((struct attrlist_ent *) 0)->a_name - (char *) 0)
end_define

begin_define
define|#
directive|define
name|ATTR_ENTSIZE
parameter_list|(
name|namelen
parameter_list|)
comment|/* actual bytes used by an attr */
define|\
value|((ATTR_ENTBASESIZE + (namelen) + 1 + sizeof(u_int32_t)-1) \& ~(sizeof(u_int32_t)-1))
end_define

begin_comment
comment|/*  * Format an attribute and copy it out to the user's buffer.  * Take care to check values and protect against them changing later,  * we may be reading them directly out of a user buffer.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_put_listent
parameter_list|(
name|xfs_attr_list_context_t
modifier|*
name|context
parameter_list|,
name|attrnames_t
modifier|*
name|namesp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|int
name|valuelen
parameter_list|)
block|{
name|attrlist_ent_t
modifier|*
name|aep
decl_stmt|;
name|int
name|arraytop
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNOVAL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|flags
operator|&
name|ATTR_KERNAMELS
condition|)
block|{
name|char
modifier|*
name|offset
decl_stmt|;
name|ASSERT
argument_list|(
name|context
operator|->
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|arraytop
operator|=
name|context
operator|->
name|count
operator|+
name|namesp
operator|->
name|attr_namelen
operator|+
name|namelen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|arraytop
operator|>
name|context
operator|->
name|firstu
condition|)
block|{
name|context
operator|->
name|count
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* insufficient space */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
name|context
operator|->
name|alist
operator|+
name|context
operator|->
name|count
expr_stmt|;
name|strncpy
argument_list|(
name|offset
argument_list|,
name|namesp
operator|->
name|attr_name
argument_list|,
name|namesp
operator|->
name|attr_namelen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|namesp
operator|->
name|attr_namelen
expr_stmt|;
name|strncpy
argument_list|(
name|offset
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* real name */
name|offset
operator|+=
name|namelen
expr_stmt|;
operator|*
name|offset
operator|=
literal|'\0'
expr_stmt|;
name|context
operator|->
name|count
operator|+=
name|namesp
operator|->
name|attr_namelen
operator|+
name|namelen
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|context
operator|->
name|count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|context
operator|->
name|count
operator|<
operator|(
name|ATTR_MAX_VALUELEN
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|context
operator|->
name|firstu
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|context
operator|->
name|alist
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|context
operator|->
name|firstu
operator|<=
name|context
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|arraytop
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|context
operator|->
name|alist
argument_list|)
operator|+
name|context
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|context
operator|->
name|alist
operator|->
name|al_offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|context
operator|->
name|firstu
operator|-=
name|ATTR_ENTSIZE
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|firstu
operator|<
name|arraytop
condition|)
block|{
name|xfs_attr_trace_l_c
argument_list|(
literal|"buffer full"
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|context
operator|->
name|alist
operator|->
name|al_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|aep
operator|=
operator|(
name|attrlist_ent_t
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|context
operator|->
name|alist
operator|)
index|[
name|context
operator|->
name|firstu
index|]
operator|)
expr_stmt|;
name|aep
operator|->
name|a_valuelen
operator|=
name|valuelen
expr_stmt|;
name|memcpy
argument_list|(
name|aep
operator|->
name|a_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|aep
operator|->
name|a_name
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|alist
operator|->
name|al_offset
index|[
name|context
operator|->
name|count
operator|++
index|]
operator|=
name|context
operator|->
name|firstu
expr_stmt|;
name|context
operator|->
name|alist
operator|->
name|al_count
operator|=
name|context
operator|->
name|count
expr_stmt|;
name|xfs_attr_trace_l_c
argument_list|(
literal|"add"
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Manage the INCOMPLETE flag in a leaf entry  *========================================================================*/
end_comment

begin_comment
comment|/*  * Clear the INCOMPLETE flag on an entry in a leaf block.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_clearflag
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Set up the operation. 	 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|args
operator|->
name|index
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|name_loc
operator|->
name|namelen
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
expr_stmt|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|name_rmt
operator|->
name|namelen
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|name_rmt
operator|->
name|name
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|entry
operator|->
name|hashval
argument_list|)
operator|==
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|namelen
operator|==
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|memcmp
argument_list|(
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|entry
operator|->
name|flags
operator|&=
operator|~
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rmtblkno
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|valueblk
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|->
name|rmtblkno
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|valuelen
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|name_rmt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|name_rmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the flag value change and start the next trans in series. 	 */
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the INCOMPLETE flag on an entry in a leaf block.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_setflag
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Set up the operation. 	 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|args
operator|->
name|index
index|]
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|valueblk
operator|=
literal|0
expr_stmt|;
name|name_rmt
operator|->
name|valuelen
operator|=
literal|0
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|name_rmt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|name_rmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the flag value change and start the next trans in series. 	 */
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In a single transaction, clear the INCOMPLETE flag on the leaf entry  * given by args->blkno/index and set the INCOMPLETE flag on the leaf  * entry given by args->blkno2/index2.  *  * Note that they could be in different blocks, or in the same block.  */
end_comment

begin_function
name|int
name|xfs_attr_leaf_flipflags
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry1
decl_stmt|,
modifier|*
name|entry2
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp1
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_attr_leaf_name_local_t
modifier|*
name|name_loc
decl_stmt|;
name|int
name|namelen1
decl_stmt|,
name|namelen2
decl_stmt|;
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Read the block containing the "old" attr 	 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp1
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|bp1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Read the block containing the "new" attr, if it is different 	 */
if|if
condition|(
name|args
operator|->
name|blkno2
operator|!=
name|args
operator|->
name|blkno
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|args
operator|->
name|blkno2
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp2
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|bp2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp2
operator|=
name|bp1
expr_stmt|;
block|}
name|leaf1
operator|=
name|bp1
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|entry1
operator|=
operator|&
name|leaf1
operator|->
name|entries
index|[
name|args
operator|->
name|index
index|]
expr_stmt|;
name|leaf2
operator|=
name|bp2
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index2
operator|<
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|index2
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|entry2
operator|=
operator|&
name|leaf2
operator|->
name|entries
index|[
name|args
operator|->
name|index2
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|entry1
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf1
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|namelen1
operator|=
name|name_loc
operator|->
name|namelen
expr_stmt|;
name|name1
operator|=
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
expr_stmt|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf1
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|namelen1
operator|=
name|name_rmt
operator|->
name|namelen
expr_stmt|;
name|name1
operator|=
operator|(
name|char
operator|*
operator|)
name|name_rmt
operator|->
name|name
expr_stmt|;
block|}
if|if
condition|(
name|entry2
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
condition|)
block|{
name|name_loc
operator|=
name|XFS_ATTR_LEAF_NAME_LOCAL
argument_list|(
name|leaf2
argument_list|,
name|args
operator|->
name|index2
argument_list|)
expr_stmt|;
name|namelen2
operator|=
name|name_loc
operator|->
name|namelen
expr_stmt|;
name|name2
operator|=
operator|(
name|char
operator|*
operator|)
name|name_loc
operator|->
name|nameval
expr_stmt|;
block|}
else|else
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf2
argument_list|,
name|args
operator|->
name|index2
argument_list|)
expr_stmt|;
name|namelen2
operator|=
name|name_rmt
operator|->
name|namelen
expr_stmt|;
name|name2
operator|=
operator|(
name|char
operator|*
operator|)
name|name_rmt
operator|->
name|name
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|entry1
operator|->
name|hashval
argument_list|)
operator|==
name|be32_to_cpu
argument_list|(
name|entry2
operator|->
name|hashval
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|namelen1
operator|==
name|namelen2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|memcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|,
name|namelen1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|ASSERT
argument_list|(
name|entry1
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|entry2
operator|->
name|flags
operator|&
name|XFS_ATTR_INCOMPLETE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|entry1
operator|->
name|flags
operator|&=
operator|~
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp1
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf1
argument_list|,
name|entry1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rmtblkno
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|entry1
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf1
argument_list|,
name|args
operator|->
name|index
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|valueblk
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|->
name|rmtblkno
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|valuelen
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|->
name|valuelen
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp1
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf1
argument_list|,
name|name_rmt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|name_rmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|entry2
operator|->
name|flags
operator||=
name|XFS_ATTR_INCOMPLETE
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp2
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf2
argument_list|,
name|entry2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry2
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf2
argument_list|,
name|args
operator|->
name|index2
argument_list|)
expr_stmt|;
name|name_rmt
operator|->
name|valueblk
operator|=
literal|0
expr_stmt|;
name|name_rmt
operator|->
name|valuelen
operator|=
literal|0
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp2
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf2
argument_list|,
name|name_rmt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|name_rmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp1
operator|!=
name|bp2
condition|)
name|xfs_da_buf_done
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the flag value change and start the next trans in series. 	 */
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
operator|&
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Indiscriminately delete the entire attribute fork  *========================================================================*/
end_comment

begin_comment
comment|/*  * Recurse (gasp!) through the attribute nodes until we find leaves.  * We're doing a depth-first traversal in order to invalidate everything.  */
end_comment

begin_function
name|int
name|xfs_attr_root_inactive
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
block|{
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|xfs_daddr_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Read block 0 to see what we have to work with. 	 * We only get here if we have extents, since we remove 	 * the extents in reverse order the extent containing 	 * block 0 must still be there. 	 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|blkno
operator|=
name|xfs_da_blkno
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate the tree, even if the "tree" is only a single leaf block. 	 * This is a depth-first traversal! 	 */
name|info
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|info
operator|->
name|magic
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
condition|)
block|{
name|error
operator|=
name|xfs_attr_node_inactive
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|info
operator|->
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
condition|)
block|{
name|error
operator|=
name|xfs_attr_leaf_inactive
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Invalidate the incore copy of the root block. 	 */
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
name|blkno
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xfs_da_binval
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* remove from cache */
comment|/* 	 * Commit the invalidate and start the next transaction. 	 */
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recurse (gasp!) through the attribute nodes until we find leaves.  * We're doing a depth-first traversal in order to invalidate everything.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_node_inactive
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_dablk_t
name|child_fsb
decl_stmt|;
name|xfs_daddr_t
name|parent_blkno
decl_stmt|,
name|child_blkno
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|child_bp
decl_stmt|;
comment|/* 	 * Since this code is recursive (gasp!) we must protect ourselves. 	 */
if|if
condition|(
name|level
operator|>
name|XFS_DA_NODE_MAXDEPTH
condition|)
block|{
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* no locks for later trans */
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|parent_blkno
operator|=
name|xfs_da_blkno
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* save for re-read later */
name|count
operator|=
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|child_fsb
operator|=
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|before
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* no locks for later trans */
comment|/* 	 * If this is the node level just above the leaves, simply loop 	 * over the leaves removing all of them.  If this is higher up 	 * in the tree, recurse downward. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Read the subsidiary block to see what we have to work with. 		 * Don't do this in a transaction.  This is a depth-first 		 * traversal of the tree so we may deal with many blocks 		 * before we come back to this one. 		 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
argument_list|,
name|child_fsb
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|child_bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|child_bp
condition|)
block|{
comment|/* save for re-read later */
name|child_blkno
operator|=
name|xfs_da_blkno
argument_list|(
name|child_bp
argument_list|)
expr_stmt|;
comment|/* 			 * Invalidate the subtree, however we have to. 			 */
name|info
operator|=
name|child_bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|info
operator|->
name|magic
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
condition|)
block|{
name|error
operator|=
name|xfs_attr_node_inactive
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|child_bp
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|info
operator|->
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
condition|)
block|{
name|error
operator|=
name|xfs_attr_leaf_inactive
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|child_bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|child_bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 			 * Remove the subsidiary block from the cache 			 * and from the log. 			 */
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
name|child_blkno
argument_list|,
operator|&
name|child_bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xfs_da_binval
argument_list|(
operator|*
name|trans
argument_list|,
name|child_bp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we're not done, re-read the parent to get the next 		 * child block number. 		 */
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|count
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
name|parent_blkno
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|child_fsb
operator|=
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|btree
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|before
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Atomically commit the whole invalidate stuff. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invalidate all of the "remote" value regions pointed to by a particular  * leaf block.  * Note that we must release the lock on the buffer so that we are not  * caught holding something that the logging code wants to flush to disk.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_inactive
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_attr_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_attr_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_attr_leaf_name_remote_t
modifier|*
name|name_rmt
decl_stmt|;
name|xfs_attr_inactive_list_t
modifier|*
name|list
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|,
name|size
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Count the number of "remote" value extents. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_rmt
operator|->
name|valueblk
condition|)
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If there are no "remote" values, we're done. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate storage for a list of all the "remote" value extents. 	 */
name|size
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_attr_inactive_list_t
argument_list|)
expr_stmt|;
name|list
operator|=
operator|(
name|xfs_attr_inactive_list_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Identify each of the "remote" value extents. 	 */
name|lp
operator|=
name|list
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XFS_ATTR_LOCAL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|name_rmt
operator|=
name|XFS_ATTR_LEAF_NAME_REMOTE
argument_list|(
name|leaf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_rmt
operator|->
name|valueblk
condition|)
block|{
name|lp
operator|->
name|valueblk
operator|=
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valueblk
argument_list|)
expr_stmt|;
name|lp
operator|->
name|valuelen
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|be32_to_cpu
argument_list|(
name|name_rmt
operator|->
name|valuelen
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
block|}
block|}
name|xfs_da_brelse
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* unlock for trans. in freextent() */
comment|/* 	 * Invalidate each of the "remote" value extents. 	 */
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|list
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|lp
operator|++
control|)
block|{
name|tmp
operator|=
name|xfs_attr_leaf_freextent
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|lp
operator|->
name|valueblk
argument_list|,
name|lp
operator|->
name|valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|tmp
expr_stmt|;
comment|/* save only the 1st errno */
block|}
name|kmem_free
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|list
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look at all the extents for this logical region,  * invalidate any buffers that are incore/in transactions.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_attr_leaf_freextent
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|blkno
parameter_list|,
name|int
name|blkcnt
parameter_list|)
block|{
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
name|xfs_dablk_t
name|tblkno
decl_stmt|;
name|int
name|tblkcnt
decl_stmt|,
name|dblkcnt
decl_stmt|,
name|nmap
decl_stmt|,
name|error
decl_stmt|;
name|xfs_daddr_t
name|dblkno
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Roll through the "value", invalidating the attribute value's 	 * blocks. 	 */
name|tblkno
operator|=
name|blkno
expr_stmt|;
name|tblkcnt
operator|=
name|blkcnt
expr_stmt|;
while|while
condition|(
name|tblkcnt
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Try to remember where we decided to put the value. 		 */
name|nmap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|tblkno
argument_list|,
name|tblkcnt
argument_list|,
name|XFS_BMAPI_ATTRFORK
operator||
name|XFS_BMAPI_METADATA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|nmap
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|map
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
argument_list|)
expr_stmt|;
comment|/* 		 * If it's a hole, these are already unmapped 		 * so there's nothing to invalidate. 		 */
if|if
condition|(
name|map
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
condition|)
block|{
name|dblkno
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|map
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|dblkcnt
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|map
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
operator|*
name|trans
argument_list|,
name|dp
operator|->
name|i_mount
operator|->
name|m_ddev_targp
argument_list|,
name|dblkno
argument_list|,
name|dblkcnt
argument_list|,
name|XFS_BUF_LOCK
argument_list|)
expr_stmt|;
name|xfs_trans_binval
argument_list|(
operator|*
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Roll to next transaction. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_attr_rolltrans
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tblkno
operator|+=
name|map
operator|.
name|br_blockcount
expr_stmt|;
name|tblkcnt
operator|-=
name|map
operator|.
name|br_blockcount
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Roll from one trans in the sequence of PERMANENT transactions to the next.  */
end_comment

begin_function
name|int
name|xfs_attr_rolltrans
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|transp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|trans
decl_stmt|;
name|unsigned
name|int
name|logres
decl_stmt|,
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Ensure that the inode is always logged. 	 */
name|trans
operator|=
operator|*
name|transp
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the critical parameters from one trans to the next. 	 */
name|logres
operator|=
name|trans
operator|->
name|t_log_res
expr_stmt|;
name|count
operator|=
name|trans
operator|->
name|t_log_count
expr_stmt|;
operator|*
name|transp
operator|=
name|xfs_trans_dup
argument_list|(
name|trans
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the current transaction. 	 * If this commit failed, then it'd just unlock those items that 	 * are not marked ihold. That also means that a filesystem shutdown 	 * is in progress. The caller takes the responsibility to cancel 	 * the duplicate transaction that gets returned. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|trans
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|trans
operator|=
operator|*
name|transp
expr_stmt|;
comment|/* 	 * Reserve space in the log for th next transaction. 	 * This also pushes items in the "AIL", the list of logged items, 	 * out to disk if they are taking up space at the tail of the log 	 * that we want to use.  This requires that either nothing be locked 	 * across this call, or that anything that is locked be logged in 	 * the prior and the next transactions. 	 */
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|trans
argument_list|,
literal|0
argument_list|,
name|logres
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 *  Ensure that the inode is in the new transaction and locked. 	 */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

