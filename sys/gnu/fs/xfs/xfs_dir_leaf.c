begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * xfs_dir_leaf.c  *  * Routines to implement leaf blocks of directories as Btrees of hashed names.  */
end_comment

begin_comment
comment|/*========================================================================  * Function prototypes for the kernel.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Routines used for growing the Btree.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_dir_leaf_add_work
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|leaf_buffer
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|insertion_index
parameter_list|,
name|int
name|freemap_index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_compact
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|leaf_buffer
parameter_list|,
name|int
name|musthave
parameter_list|,
name|int
name|justcheck
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_dir_leaf_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_figure_balance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|leaf_blk_1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|leaf_blk_2
parameter_list|,
name|int
modifier|*
name|number_entries_in_blk1
parameter_list|,
name|int
modifier|*
name|number_namebytes_in_blk1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_create
parameter_list|(
name|struct
name|xfs_da_args
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
name|which_block
parameter_list|,
name|struct
name|xfs_dabuf
modifier|*
modifier|*
name|bpp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_dir_leaf_moveents
parameter_list|(
name|xfs_dir_leafblock_t
modifier|*
name|src_leaf
parameter_list|,
name|int
name|src_start
parameter_list|,
name|xfs_dir_leafblock_t
modifier|*
name|dst_leaf
parameter_list|,
name|int
name|dst_start
parameter_list|,
name|int
name|move_count
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*========================================================================  * External routines when dirsize< XFS_IFORK_DSIZE(dp).  *========================================================================*/
end_comment

begin_comment
comment|/*  * Validate a given inode number.  */
end_comment

begin_function
name|int
name|xfs_dir_ino_validate
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|)
block|{
name|xfs_agblock_t
name|agblkno
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|int
name|ino_ok
decl_stmt|;
name|int
name|ioff
decl_stmt|;
name|agno
operator|=
name|XFS_INO_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|agblkno
operator|=
name|XFS_INO_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|ioff
operator|=
name|XFS_INO_TO_OFFSET
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|agino
operator|=
name|XFS_OFFBNO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|agblkno
argument_list|,
name|ioff
argument_list|)
expr_stmt|;
name|ino_ok
operator|=
name|agno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|&&
name|agblkno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
operator|&&
name|agblkno
operator|!=
literal|0
operator|&&
name|ioff
operator|<
operator|(
literal|1
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblog
operator|)
operator|&&
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agino
argument_list|)
operator|==
name|ino
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|ino_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_DIR_INO_VALIDATE
argument_list|,
name|XFS_RANDOM_DIR_INO_VALIDATE
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"Invalid inode number 0x%Lx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ino
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_dir_ino_validate"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Create the initial contents of a shortform directory.  */
end_comment

begin_function
name|int
name|xfs_dir_shortform_create
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_ino_t
name|parent
parameter_list|)
block|{
name|xfs_dir_sf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_EXTENTS
condition|)
block|{
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator|&=
operator|~
name|XFS_IFEXTENTS
expr_stmt|;
comment|/* just in case */
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|XFS_DINODE_FMT_LOCAL
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator||=
name|XFS_IFINLINE
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
name|xfs_dir_sf_hdr_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|parent
argument_list|,
operator|&
name|hdr
operator|->
name|parent
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DDATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a name to the shortform directory structure.  * Overflow from the inode has already been checked for.  */
end_comment

begin_function
name|int
name|xfs_dir_shortform_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
comment|/* 	 * Catch the case where the conversion from shortform to leaf 	 * failed part way through. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|<
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
name|dp
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|sfe
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
return|;
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|-
operator|(
name|char
operator|*
operator|)
name|sf
argument_list|)
expr_stmt|;
name|size
operator|=
name|XFS_DIR_SF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
name|size
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|(
name|xfs_dir_sf_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|+
name|offset
operator|)
expr_stmt|;
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|args
operator|->
name|inumber
argument_list|,
operator|&
name|sfe
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|sfe
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|memcpy
argument_list|(
name|sfe
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|sf
operator|->
name|hdr
operator|.
name|count
operator|++
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|+=
name|size
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DDATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from the shortform directory structure.  */
end_comment

begin_function
name|int
name|xfs_dir_shortform_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|base
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
comment|/* 	 * Catch the case where the conversion from shortform to leaf 	 * failed part way through. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|<
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
name|dp
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|base
operator|=
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|size
operator|=
name|XFS_DIR_SF_ENTSIZE_BYENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|sfe
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|sfe
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|base
operator|+=
name|size
expr_stmt|;
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|base
operator|+
name|size
operator|)
operator|!=
name|dp
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|memmove
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|)
index|[
name|base
index|]
argument_list|,
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|)
index|[
name|base
operator|+
name|size
index|]
argument_list|,
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|-
operator|(
name|base
operator|+
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
name|sf
operator|->
name|hdr
operator|.
name|count
operator|--
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
operator|-
name|size
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|-=
name|size
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DDATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a shortform directory structure.  */
end_comment

begin_function
name|int
name|xfs_dir_shortform_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
comment|/* 	 * Catch the case where the conversion from shortform to leaf 	 * failed part way through. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|<
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
name|dp
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|namelen
operator|==
literal|2
operator|&&
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|args
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|sf
operator|->
name|hdr
operator|.
name|parent
argument_list|,
operator|&
name|args
operator|->
name|inumber
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|args
operator|->
name|namelen
operator|==
literal|1
operator|&&
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|args
operator|->
name|inumber
operator|=
name|dp
operator|->
name|i_ino
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|sfe
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|sfe
operator|->
name|inumber
argument_list|,
operator|&
name|args
operator|->
name|inumber
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from using the shortform to the leaf.  */
end_comment

begin_function
name|int
name|xfs_dir_shortform_to_leaf
parameter_list|(
name|xfs_da_args_t
modifier|*
name|iargs
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|xfs_da_args_t
name|args
decl_stmt|;
name|xfs_ino_t
name|inumber
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|,
name|size
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
name|iargs
operator|->
name|dp
expr_stmt|;
comment|/* 	 * Catch the case where the conversion from shortform to leaf 	 * failed part way through. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|<
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
name|dp
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
expr_stmt|;
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer
argument_list|,
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|sf
operator|->
name|hdr
operator|.
name|parent
argument_list|,
operator|&
name|inumber
argument_list|)
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|dp
argument_list|,
operator|-
name|size
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|=
literal|0
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|iargs
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_da_grow_inode
argument_list|(
name|iargs
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|blkno
operator|==
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_create
argument_list|(
name|iargs
argument_list|,
name|blkno
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
literal|"."
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_dir_hash_dot
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|dp
operator|->
name|i_ino
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|iargs
operator|->
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|iargs
operator|->
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|iargs
operator|->
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|iargs
operator|->
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|args
operator|.
name|name
operator|=
literal|".."
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
literal|2
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_dir_hash_dotdot
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|inumber
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|args
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sfe
operator|->
name|name
operator|)
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|sfe
operator|->
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|sfe
operator|->
name|name
operator|)
argument_list|,
name|sfe
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|sfe
operator|->
name|inumber
argument_list|,
operator|&
name|args
operator|.
name|inumber
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_dir_shortform_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|xfs_dir_sf_sort_t
modifier|*
name|sa
decl_stmt|,
modifier|*
name|sb
decl_stmt|;
name|sa
operator|=
operator|(
specifier|const
name|xfs_dir_sf_sort_t
operator|*
operator|)
name|a
expr_stmt|;
name|sb
operator|=
operator|(
specifier|const
name|xfs_dir_sf_sort_t
operator|*
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|hash
operator|<
name|sb
operator|->
name|hash
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sa
operator|->
name|hash
operator|>
name|sb
operator|->
name|hash
condition|)
return|return
literal|1
return|;
else|else
return|return
name|sa
operator|->
name|entno
operator|-
name|sb
operator|->
name|entno
return|;
block|}
end_function

begin_comment
comment|/*  * Copy out directory entries for getdents(), for shortform directories.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xfs_dir_shortform_getdents
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
name|xfs_dir_put_t
name|put
parameter_list|)
block|{
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|,
name|sbsize
decl_stmt|,
name|nsbuf
decl_stmt|,
name|lastresid
init|=
literal|0
decl_stmt|,
name|want_entno
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_dahash_t
name|cookhash
decl_stmt|,
name|hash
decl_stmt|;
name|xfs_dir_put_args_t
name|p
decl_stmt|;
name|xfs_dir_sf_sort_t
modifier|*
name|sbuf
decl_stmt|,
modifier|*
name|sbp
decl_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
name|cookhash
operator|=
name|XFS_DA_COOKIE_HASH
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|want_entno
operator|=
name|XFS_DA_COOKIE_ENTRY
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|nsbuf
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|+
literal|2
expr_stmt|;
name|sbsize
operator|=
operator|(
name|nsbuf
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sbuf
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|sbuf
operator|=
name|kmem_alloc
argument_list|(
name|sbsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"sf: start"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 	 * Collect all the entries into the buffer. 	 * Entry 0 is . 	 */
name|sbp
operator|->
name|entno
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|seqno
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|hash
operator|=
name|xfs_dir_hash_dot
expr_stmt|;
name|sbp
operator|->
name|ino
operator|=
name|dp
operator|->
name|i_ino
expr_stmt|;
name|sbp
operator|->
name|name
operator|=
literal|"."
expr_stmt|;
name|sbp
operator|->
name|namelen
operator|=
literal|1
expr_stmt|;
name|sbp
operator|++
expr_stmt|;
comment|/* 	 * Entry 1 is .. 	 */
name|sbp
operator|->
name|entno
operator|=
literal|1
expr_stmt|;
name|sbp
operator|->
name|seqno
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|hash
operator|=
name|xfs_dir_hash_dotdot
expr_stmt|;
name|sbp
operator|->
name|ino
operator|=
name|XFS_GET_DIR_INO8
argument_list|(
name|sf
operator|->
name|hdr
operator|.
name|parent
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|name
operator|=
literal|".."
expr_stmt|;
name|sbp
operator|->
name|namelen
operator|=
literal|2
expr_stmt|;
name|sbp
operator|++
expr_stmt|;
comment|/* 	 * Scan the directory data for the rest of the entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
init|;
name|i
operator|<
name|sf
operator|->
name|hdr
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|<
operator|(
name|char
operator|*
operator|)
name|sf
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|>=
operator|(
operator|(
name|char
operator|*
operator|)
name|sf
operator|+
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|)
operator|)
argument_list|)
condition|)
block|{
name|xfs_dir_trace_g_du
argument_list|(
literal|"sf: corrupted"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_dir_shortform_getdents"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|sfe
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|sbp
operator|->
name|entno
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|sbp
operator|->
name|seqno
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|hash
operator|=
name|xfs_da_hashname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|ino
operator|=
name|XFS_GET_DIR_INO8
argument_list|(
name|sfe
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|sfe
operator|->
name|name
expr_stmt|;
name|sbp
operator|->
name|namelen
operator|=
name|sfe
operator|->
name|namelen
expr_stmt|;
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
name|sbp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Sort the entries on hash then entno. 	 */
name|xfs_sort
argument_list|(
name|sbuf
argument_list|,
name|nsbuf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbuf
argument_list|)
argument_list|,
name|xfs_dir_shortform_compare
argument_list|)
expr_stmt|;
comment|/* 	 * Stuff in last entry. 	 */
name|sbp
operator|->
name|entno
operator|=
name|nsbuf
expr_stmt|;
name|sbp
operator|->
name|hash
operator|=
name|XFS_DA_MAXHASH
expr_stmt|;
name|sbp
operator|->
name|seqno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Figure out the sequence numbers in case there's a hash duplicate. 	 */
for|for
control|(
name|hash
operator|=
name|sbuf
operator|->
name|hash
operator|,
name|sbp
operator|=
name|sbuf
operator|+
literal|1
init|;
name|sbp
operator|<
operator|&
name|sbuf
index|[
name|nsbuf
operator|+
literal|1
index|]
condition|;
name|sbp
operator|++
control|)
block|{
if|if
condition|(
name|sbp
operator|->
name|hash
operator|==
name|hash
condition|)
name|sbp
operator|->
name|seqno
operator|=
name|sbp
index|[
operator|-
literal|1
index|]
operator|.
name|seqno
operator|+
literal|1
expr_stmt|;
else|else
name|hash
operator|=
name|sbp
operator|->
name|hash
expr_stmt|;
block|}
comment|/* 	 * Set up put routine. 	 */
name|p
operator|.
name|dbp
operator|=
name|dbp
expr_stmt|;
name|p
operator|.
name|put
operator|=
name|put
expr_stmt|;
name|p
operator|.
name|uio
operator|=
name|uio
expr_stmt|;
comment|/* 	 * Find our place. 	 */
for|for
control|(
name|sbp
operator|=
name|sbuf
init|;
name|sbp
operator|<
operator|&
name|sbuf
index|[
name|nsbuf
operator|+
literal|1
index|]
condition|;
name|sbp
operator|++
control|)
block|{
if|if
condition|(
name|sbp
operator|->
name|hash
operator|>
name|cookhash
operator|||
operator|(
name|sbp
operator|->
name|hash
operator|==
name|cookhash
operator|&&
name|sbp
operator|->
name|seqno
operator|>=
name|want_entno
operator|)
condition|)
break|break;
block|}
comment|/* 	 * Did we fail to find anything?  We stop at the last entry, 	 * the one we put maxhash into. 	 */
if|if
condition|(
name|sbp
operator|==
operator|&
name|sbuf
index|[
name|nsbuf
index|]
condition|)
block|{
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"sf: hash beyond end"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|XFS_DA_MAKE_COOKIE
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XFS_DA_MAXHASH
argument_list|)
expr_stmt|;
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Loop putting entries into the user buffer. 	 */
while|while
condition|(
name|sbp
operator|<
operator|&
name|sbuf
index|[
name|nsbuf
index|]
condition|)
block|{
comment|/* 		 * Save the first resid in a run of equal-hashval entries 		 * so that we can back them out if they don't all fit. 		 */
if|if
condition|(
name|sbp
operator|->
name|seqno
operator|==
literal|0
operator|||
name|sbp
operator|==
name|sbuf
condition|)
name|lastresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|XFS_PUT_COOKIE
argument_list|(
name|p
operator|.
name|cook
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|,
name|sbp
index|[
literal|1
index|]
operator|.
name|seqno
argument_list|,
name|sbp
index|[
literal|1
index|]
operator|.
name|hash
argument_list|)
expr_stmt|;
name|p
operator|.
name|ino
operator|=
name|sbp
operator|->
name|ino
expr_stmt|;
if|#
directive|if
name|XFS_BIG_INUMS
name|p
operator|.
name|ino
operator|+=
name|mp
operator|->
name|m_inoadd
expr_stmt|;
endif|#
directive|endif
name|p
operator|.
name|name
operator|=
name|sbp
operator|->
name|name
expr_stmt|;
name|p
operator|.
name|namelen
operator|=
name|sbp
operator|->
name|namelen
expr_stmt|;
name|retval
operator|=
name|p
operator|.
name|put
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|done
condition|)
block|{
name|uio
operator|->
name|uio_offset
operator|=
name|XFS_DA_MAKE_COOKIE
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sbp
operator|->
name|hash
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|lastresid
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"sf: E-O-B"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|sbp
operator|++
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|sbuf
argument_list|,
name|sbsize
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|p
operator|.
name|cook
operator|.
name|o
expr_stmt|;
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"sf: E-O-F"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a shortform directory structure, replace the inode number.  */
end_comment

begin_function
name|int
name|xfs_dir_shortform_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
comment|/* 	 * Catch the case where the conversion from shortform to leaf 	 * failed part way through. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|<
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
name|dp
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|namelen
operator|==
literal|2
operator|&&
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|args
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* XXX - replace assert? */
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|args
operator|->
name|inumber
argument_list|,
operator|&
name|sf
operator|->
name|hdr
operator|.
name|parent
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_DDATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|args
operator|->
name|namelen
operator|!=
literal|1
operator|||
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
argument_list|)
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|sfe
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|sfe
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|args
operator|->
name|inumber
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sfe
operator|->
name|inumber
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_ino_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|args
operator|->
name|inumber
argument_list|,
operator|&
name|sfe
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_DDATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a leaf directory to shortform structure  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_to_shortform
parameter_list|(
name|xfs_da_args_t
modifier|*
name|iargs
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|xfs_da_args_t
name|args
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_ino_t
name|parent
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|dp
operator|=
name|iargs
operator|->
name|dp
expr_stmt|;
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|iargs
operator|->
name|trans
argument_list|,
name|iargs
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_dir_leafblock_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bp
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find and special case the parent inode number 	 */
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|entry
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|namelen
operator|==
literal|2
operator|)
operator|&&
operator|(
name|namest
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|namest
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|namest
operator|->
name|inumber
argument_list|,
operator|&
name|parent
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nameidx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|entry
operator|->
name|namelen
operator|==
literal|1
operator|)
operator|&&
operator|(
name|namest
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|entry
operator|->
name|nameidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|retval
operator|=
name|xfs_da_shrink_inode
argument_list|(
name|iargs
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
name|retval
operator|=
name|xfs_dir_shortform_create
argument_list|(
name|iargs
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Copy the rest of the filenames 	 */
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|iargs
operator|->
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|iargs
operator|->
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|iargs
operator|->
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|iargs
operator|->
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|entry
operator|->
name|nameidx
condition|)
continue|continue;
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|namest
operator|->
name|name
operator|)
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|entry
operator|->
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|namest
operator|->
name|inumber
argument_list|,
operator|&
name|args
operator|.
name|inumber
argument_list|)
expr_stmt|;
name|xfs_dir_shortform_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from using a single leaf to a root node and a leaf.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_to_node
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp1
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|retval
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blkno
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
return|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
return|;
name|ASSERT
argument_list|(
name|bp1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_da_get_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp2
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|xfs_da_buf_done
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|ASSERT
argument_list|(
name|bp2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp2
operator|->
name|data
argument_list|,
name|bp1
operator|->
name|data
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp2
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the new root node. 	 */
name|retval
operator|=
name|xfs_da_node_create
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|bp1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|xfs_da_buf_done
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|node
operator|=
name|bp1
operator|->
name|data
expr_stmt|;
name|leaf
operator|=
name|bp2
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
operator|=
name|cpu_to_be32
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|before
operator|=
name|cpu_to_be32
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
name|node
operator|->
name|hdr
operator|.
name|count
operator|=
name|cpu_to_be16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp1
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|btree
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|btree
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for growing the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Create the initial contents of a leaf directory  * or a leaf in a node directory.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_create
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
name|blkno
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_da_get_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|hdr
operator|->
name|info
operator|.
name|magic
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|firstused
condition|)
name|INT_SET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|XFS_LBSIZE
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Split the leaf node, rebalance, then add the new entry.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|oldblk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|newblk
parameter_list|)
block|{
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Allocate space for a new leaf node. 	 */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldblk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|xfs_dir_leaf_create
argument_list|(
name|args
argument_list|,
name|blkno
argument_list|,
operator|&
name|newblk
operator|->
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|newblk
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|newblk
operator|->
name|magic
operator|=
name|XFS_DIR_LEAF_MAGIC
expr_stmt|;
comment|/* 	 * Rebalance the entries across the two leaves. 	 */
name|xfs_dir_leaf_rebalance
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_blk_link
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * Insert the new entry in the correct block. 	 */
if|if
condition|(
name|state
operator|->
name|inleaf
condition|)
block|{
name|error
operator|=
name|xfs_dir_leaf_add
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
name|oldblk
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_dir_leaf_add
argument_list|(
name|newblk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
name|newblk
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update last hashval in each block since we added the name. 	 */
name|oldblk
operator|->
name|hashval
operator|=
name|xfs_dir_leaf_lasthash
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|hashval
operator|=
name|xfs_dir_leaf_lasthash
argument_list|(
name|newblk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Add a name to the leaf directory structure.  *  * Must take into account fragmented leaves and leaves where spacemap has  * lost some freespace information (ie: holes).  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_add
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_dir_leaf_map_t
modifier|*
name|map
decl_stmt|;
name|int
name|tablesize
decl_stmt|,
name|entsize
decl_stmt|,
name|sum
decl_stmt|,
name|i
decl_stmt|,
name|tmp
decl_stmt|,
name|error
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|entsize
operator|=
name|XFS_DIR_LEAF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
comment|/* 	 * Search through freemap for first-fit on new name length. 	 * (may need to figure in size of entry struct too) 	 */
name|tablesize
operator|=
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|XFS_DIR_LEAF_MAPSIZE
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
name|XFS_DIR_LEAF_MAPSIZE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|map
operator|--
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|tablesize
operator|>
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|map
operator|->
name|size
condition|)
continue|continue;
comment|/* no space in this map */
name|tmp
operator|=
name|entsize
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|tmp
operator|+=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|tmp
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|->
name|justcheck
condition|)
name|xfs_dir_leaf_add_work
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|index
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sum
operator|+=
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are no holes in the address space of the block, 	 * and we don't have enough freespace, then compaction will do us 	 * no good and we should just give up. 	 */
if|if
condition|(
operator|!
name|hdr
operator|->
name|holes
operator|&&
operator|(
name|sum
operator|<
name|entsize
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
comment|/* 	 * Compact the entries to coalesce free space. 	 * Pass the justcheck flag so the checking pass can return 	 * an error, without changing anything, if it won't fit. 	 */
name|error
operator|=
name|xfs_dir_leaf_compact
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|args
operator|->
name|total
operator|==
literal|0
condition|?
name|entsize
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
else|:
literal|0
argument_list|,
name|args
operator|->
name|justcheck
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * After compaction, the block is guaranteed to have only one 	 * free region, in freemap[0].  If it is not big enough, give up. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
operator|(
name|entsize
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
if|if
condition|(
operator|!
name|args
operator|->
name|justcheck
condition|)
name|xfs_dir_leaf_add_work
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a name to a leaf directory structure.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_dir_leaf_add_work
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|mapindex
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|xfs_dir_leaf_map_t
modifier|*
name|map
decl_stmt|;
comment|/* REFERENCED */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|mapindex
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|mapindex
operator|<
name|XFS_DIR_LEAF_MAPSIZE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Force open some space in the entry array and fill it in. 	 */
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|index
expr_stmt|;
name|tmp
operator|*=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|entry
operator|+
literal|1
argument_list|,
name|entry
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
name|tmp
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|INT_MOD
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for the new string (at the end of the run). 	 */
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|mapindex
index|]
expr_stmt|;
name|mp
operator|=
name|args
operator|->
name|trans
operator|->
name|t_mountp
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|XFS_DIR_LEAF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|XFS_DIR_LEAF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|entry
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the string and inode number into the new space. 	 */
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|args
operator|->
name|inumber
argument_list|,
operator|&
name|namest
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|namest
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|namest
argument_list|,
name|XFS_DIR_LEAF_ENTSIZE_BYENTRY
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the control info for this leaf node 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|INT_COPY
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
operator|(
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
operator|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XFS_DIR_LEAF_MAPSIZE
condition|;
name|map
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|tmp
condition|)
block|{
name|INT_MOD
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|INT_MOD
argument_list|(
name|hdr
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Garbage collect a leaf directory block by copying it to a new buffer.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_compact
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
name|musthave
parameter_list|,
name|int
name|justcheck
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf_s
decl_stmt|,
modifier|*
name|leaf_d
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr_s
decl_stmt|,
modifier|*
name|hdr_d
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
name|char
modifier|*
name|tmpbuffer2
init|=
name|NULL
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|lbsize
decl_stmt|;
name|mp
operator|=
name|trans
operator|->
name|t_mountp
expr_stmt|;
name|lbsize
operator|=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|lbsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
comment|/* 	 * Make a second copy in case xfs_dir_leaf_moveents() 	 * below destroys the original. 	 */
if|if
condition|(
name|musthave
operator|||
name|justcheck
condition|)
block|{
name|tmpbuffer2
operator|=
name|kmem_alloc
argument_list|(
name|lbsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmpbuffer2
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|bp
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
comment|/* 	 * Copy basic information 	 */
name|leaf_s
operator|=
operator|(
name|xfs_dir_leafblock_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|leaf_d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|hdr_s
operator|=
operator|&
name|leaf_s
operator|->
name|hdr
expr_stmt|;
name|hdr_d
operator|=
operator|&
name|leaf_d
operator|->
name|hdr
expr_stmt|;
name|hdr_d
operator|->
name|info
operator|=
name|hdr_s
operator|->
name|info
expr_stmt|;
comment|/* struct copy */
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr_d
operator|->
name|firstused
condition|)
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|lbsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hdr_d
operator|->
name|namebytes
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|hdr_d
operator|->
name|holes
operator|=
literal|0
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy all entry's in the same (sorted) order, 	 * but allocate filenames packed and in sequence. 	 * This changes the source (leaf_s) as well. 	 */
name|xfs_dir_leaf_moveents
argument_list|(
name|leaf_s
argument_list|,
literal|0
argument_list|,
name|leaf_d
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|musthave
operator|&&
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|musthave
condition|)
name|rval
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|justcheck
operator|||
name|rval
operator|==
name|ENOSPC
condition|)
block|{
name|ASSERT
argument_list|(
name|tmpbuffer2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|->
name|data
argument_list|,
name|tmpbuffer2
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_da_log_buf
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|lbsize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|musthave
operator|||
name|justcheck
condition|)
name|kmem_free
argument_list|(
name|tmpbuffer2
argument_list|,
name|lbsize
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Redistribute the directory entries between two leaf nodes,  * taking into account the size of the new entry.  *  * NOTE: if new block is empty, then it will get the upper half of old block.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_dir_leaf_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|tmp_blk
decl_stmt|;
name|xfs_dir_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr1
decl_stmt|,
modifier|*
name|hdr2
decl_stmt|;
name|int
name|count
decl_stmt|,
name|totallen
decl_stmt|,
name|max
decl_stmt|,
name|space
decl_stmt|,
name|swap
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|ASSERT
argument_list|(
name|blk1
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk2
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Check ordering of blocks, reverse if it makes things simpler. 	 */
name|swap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfs_dir_leaf_order
argument_list|(
name|blk1
operator|->
name|bp
argument_list|,
name|blk2
operator|->
name|bp
argument_list|)
condition|)
block|{
name|tmp_blk
operator|=
name|blk1
expr_stmt|;
name|blk1
operator|=
name|blk2
expr_stmt|;
name|blk2
operator|=
name|tmp_blk
expr_stmt|;
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|swap
operator|=
literal|1
expr_stmt|;
block|}
name|hdr1
operator|=
operator|&
name|leaf1
operator|->
name|hdr
expr_stmt|;
name|hdr2
operator|=
operator|&
name|leaf2
operator|->
name|hdr
expr_stmt|;
comment|/* 	 * Examine entries until we reduce the absolute difference in 	 * byte usage between the two blocks to a minimum.  Then get 	 * the direction to copy and the number of elements to move. 	 */
name|state
operator|->
name|inleaf
operator|=
name|xfs_dir_leaf_figure_balance
argument_list|(
name|state
argument_list|,
name|blk1
argument_list|,
name|blk2
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|totallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
name|state
operator|->
name|inleaf
operator|=
operator|!
name|state
operator|->
name|inleaf
expr_stmt|;
comment|/* 	 * Move any entries required from leaf to leaf: 	 */
if|if
condition|(
name|count
operator|<
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
comment|/* 		 * Figure the total bytes to be added to the destination leaf. 		 */
name|count
operator|=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|count
expr_stmt|;
comment|/* number entries being moved */
name|space
operator|=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|totallen
expr_stmt|;
name|space
operator|+=
name|count
operator|*
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|space
operator|+=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
comment|/* 		 * leaf2 is the destination, compact it if it looks tight. 		 */
name|max
operator|=
name|INT_GET
argument_list|(
name|hdr2
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|max
operator|-=
name|INT_GET
argument_list|(
name|hdr2
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
name|max
condition|)
block|{
name|xfs_dir_leaf_compact
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move high entries from leaf1 to low end of leaf2. 		 */
name|xfs_dir_leaf_moveents
argument_list|(
name|leaf1
argument_list|,
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|count
argument_list|,
name|leaf2
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|state
operator|->
name|mp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
comment|/* 		 * Figure the total bytes to be added to the destination leaf. 		 */
name|count
operator|-=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* number entries being moved */
name|space
operator|=
name|totallen
operator|-
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|space
operator|+=
name|count
operator|*
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|space
operator|+=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
comment|/* 		 * leaf1 is the destination, compact it if it looks tight. 		 */
name|max
operator|=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|max
operator|-=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
name|max
condition|)
block|{
name|xfs_dir_leaf_compact
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move low entries from leaf2 to high end of leaf1. 		 */
name|xfs_dir_leaf_moveents
argument_list|(
name|leaf2
argument_list|,
literal|0
argument_list|,
name|leaf1
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|count
argument_list|,
name|state
operator|->
name|mp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy out last hashval in each block for B-tree code. 	 */
name|blk1
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|blk2
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the expected index for insertion. 	 * GROT: this doesn't work unless blk2 was originally empty. 	 */
if|if
condition|(
operator|!
name|state
operator|->
name|inleaf
condition|)
block|{
name|blk2
operator|->
name|index
operator|=
name|blk1
operator|->
name|index
operator|-
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Examine entries until we reduce the absolute difference in  * byte usage between the two blocks to a minimum.  * GROT: Is this really necessary?  With other than a 512 byte blocksize,  * GROT: there will always be enough room in either block for a new entry.  * GROT: Do a double-split for this case?  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_figure_balance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|,
name|int
modifier|*
name|countarg
parameter_list|,
name|int
modifier|*
name|namebytesarg
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr1
decl_stmt|,
modifier|*
name|hdr2
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|int
name|count
decl_stmt|,
name|max
decl_stmt|,
name|totallen
decl_stmt|,
name|half
decl_stmt|;
name|int
name|lastdelta
decl_stmt|,
name|foundit
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|hdr1
operator|=
operator|&
name|leaf1
operator|->
name|hdr
expr_stmt|;
name|hdr2
operator|=
operator|&
name|leaf2
operator|->
name|hdr
expr_stmt|;
name|foundit
operator|=
literal|0
expr_stmt|;
name|totallen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Examine entries until we reduce the absolute difference in 	 * byte usage between the two blocks to a minimum. 	 */
name|max
operator|=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|hdr2
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|half
operator|=
operator|(
name|max
operator|+
literal|1
operator|)
operator|*
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|half
operator|+=
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|hdr2
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|state
operator|->
name|args
operator|->
name|namelen
expr_stmt|;
name|half
operator|/=
literal|2
expr_stmt|;
name|lastdelta
operator|=
name|state
operator|->
name|blocksize
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf1
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|max
condition|;
name|entry
operator|++
operator|,
name|count
operator|++
control|)
block|{
define|#
directive|define
name|XFS_DIR_ABS
parameter_list|(
name|A
parameter_list|)
value|(((A)< 0) ? -(A) : (A))
comment|/* 		 * The new entry is in the first block, account for it. 		 */
if|if
condition|(
name|count
operator|==
name|blk1
operator|->
name|index
condition|)
block|{
name|tmp
operator|=
name|totallen
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
name|XFS_DIR_LEAF_ENTSIZE_BYNAME
argument_list|(
name|state
operator|->
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_DIR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
operator|>
name|lastdelta
condition|)
break|break;
name|lastdelta
operator|=
name|XFS_DIR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|tmp
expr_stmt|;
name|foundit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Wrap around into the second block if necessary. 		 */
if|if
condition|(
name|count
operator|==
name|INT_GET
argument_list|(
name|hdr1
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|leaf1
operator|=
name|leaf2
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf1
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 		 * Figure out if next leaf entry would be too much. 		 */
name|tmp
operator|=
name|totallen
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
name|XFS_DIR_LEAF_ENTSIZE_BYENTRY
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_DIR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
operator|>
name|lastdelta
condition|)
break|break;
name|lastdelta
operator|=
name|XFS_DIR_ABS
argument_list|(
name|half
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|tmp
expr_stmt|;
undef|#
directive|undef
name|XFS_DIR_ABS
block|}
comment|/* 	 * Calculate the number of namebytes that will end up in lower block. 	 * If new entry not in lower block, fix up the count. 	 */
name|totallen
operator|-=
name|count
operator|*
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundit
condition|)
block|{
name|totallen
operator|-=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|-
literal|1
operator|)
operator|+
name|state
operator|->
name|args
operator|->
name|namelen
expr_stmt|;
block|}
operator|*
name|countarg
operator|=
name|count
expr_stmt|;
operator|*
name|namebytesarg
operator|=
name|totallen
expr_stmt|;
return|return
name|foundit
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for shrinking the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Check a leaf block and its neighbors to see if the block should be  * collapsed into one or the other neighbor.  Always keep the block  * with the smaller block number.  * If the current block is over 50% full, don't try to join it, return 0.  * If the block is empty, fill in the state structure and return 2.  * If it can be collapsed, fill in the state structure and return 1.  * If nothing can be done, return 0.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_toosmall
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|action
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|int
name|count
decl_stmt|,
name|bytes
decl_stmt|,
name|forward
decl_stmt|,
name|error
decl_stmt|,
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Check for the degenerate case of the block being over 50% full. 	 * If so, it's not worth even looking to see if we might be able 	 * to coalesce with a sibling. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|info
operator|->
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_dir_leafblock_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
operator|+
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
name|count
operator|*
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|-
literal|1
operator|)
operator|+
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
operator|(
name|state
operator|->
name|blocksize
operator|>>
literal|1
operator|)
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
comment|/* blk over 50%, don't try to join */
return|return
literal|0
return|;
block|}
comment|/* 	 * Check for the degenerate case of the block being empty. 	 * If the block is empty, we'll simply delete it, no need to 	 * coalesce it with a sibling block.  We choose (arbitrarily) 	 * to merge with the forward block unless it is NULL. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Make altpath point to the block we want to keep and 		 * path point to the block we want to drop (this one). 		 */
name|forward
operator|=
operator|(
name|info
operator|->
name|forw
operator|!=
literal|0
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|action
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* 	 * Examine each sibling block to see if we can coalesce with 	 * at least 25% free space to spare.  We need to figure out 	 * whether to merge with the forward or the backward block. 	 * We prefer coalescing with the lower numbered sibling so as 	 * to shrink a directory over time. 	 */
name|forward
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|forw
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|back
argument_list|)
operator|)
expr_stmt|;
comment|/* start with smaller blk num */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|forward
operator|=
operator|!
name|forward
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|forward
condition|)
name|blkno
operator|=
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|forw
argument_list|)
expr_stmt|;
else|else
name|blkno
operator|=
name|be32_to_cpu
argument_list|(
name|info
operator|->
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_dir_leafblock_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|state
operator|->
name|blocksize
operator|-
operator|(
name|state
operator|->
name|blocksize
operator|>>
literal|2
operator|)
expr_stmt|;
name|bytes
operator|-=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|count
operator|+=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|count
operator|*
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bytes
operator|-=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|bytes
operator|-=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|0
condition|)
break|break;
comment|/* fits with at least 25% to spare */
name|xfs_da_brelse
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Make altpath point to the block we want to keep (the lower 	 * numbered block) and path point to the block we want to drop. 	 */
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|blk
operator|->
name|blkno
condition|)
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|action
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from the leaf directory structure.  *  * Return 1 if leaf is less than 37% full, 0 if>= 37% full.  * If two leaves are 37% full, when combined they will leave 25% free.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_remove
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|xfs_dir_leaf_map_t
modifier|*
name|map
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|int
name|before
decl_stmt|,
name|after
decl_stmt|,
name|smallest
decl_stmt|,
name|entsize
decl_stmt|;
name|int
name|tablesize
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|leaf
operator|->
name|hdr
expr_stmt|;
name|mp
operator|=
name|trans
operator|->
name|t_mountp
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|/
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
operator|(
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Scan through free region table: 	 *    check for adjacency of free'd entry with an existing one, 	 *    find smallest free region in case we need to replace it, 	 *    adjust any map that borders the entry table, 	 */
name|tablesize
operator|=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
literal|0
index|]
expr_stmt|;
name|tmp
operator|=
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|before
operator|=
name|after
operator|=
operator|-
literal|1
expr_stmt|;
name|smallest
operator|=
name|XFS_DIR_LEAF_MAPSIZE
operator|-
literal|1
expr_stmt|;
name|entsize
operator|=
name|XFS_DIR_LEAF_ENTSIZE_BYENTRY
argument_list|(
name|entry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XFS_DIR_LEAF_MAPSIZE
condition|;
name|map
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|tablesize
condition|)
block|{
name|INT_MOD
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|==
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|before
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
operator|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|entsize
operator|)
condition|)
block|{
name|after
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|tmp
condition|)
block|{
name|tmp
operator|=
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|smallest
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * Coalesce adjacent freemap regions, 	 * or replace the smallest region. 	 */
if|if
condition|(
operator|(
name|before
operator|>=
literal|0
operator|)
operator|||
operator|(
name|after
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|before
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|after
operator|>=
literal|0
operator|)
condition|)
block|{
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|before
index|]
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|before
operator|>=
literal|0
condition|)
block|{
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|before
index|]
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|after
index|]
expr_stmt|;
name|INT_COPY
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Replace smallest region (if it is smaller than free'd entry) 		 */
name|map
operator|=
operator|&
name|hdr
operator|->
name|freemap
index|[
name|smallest
index|]
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|entsize
condition|)
block|{
name|INT_COPY
argument_list|(
name|map
operator|->
name|base
argument_list|,
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|map
operator|->
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Did we remove the first entry? 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|smallest
operator|=
literal|1
expr_stmt|;
else|else
name|smallest
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compress the remaining entries and zero out the removed stuff. 	 */
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|namest
argument_list|,
literal|0
argument_list|,
name|entsize
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|namest
argument_list|,
name|entsize
argument_list|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|entry
operator|->
name|namelen
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|index
operator|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|entry
argument_list|,
name|entry
operator|+
literal|1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|entry
argument_list|,
name|tmp
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we removed the first entry, re-find the first used byte 	 * in the name area.  Note that if the entry was the "firstused", 	 * then we don't have a "hole" in our block resulting from 	 * removing the name. 	 */
if|if
condition|(
name|smallest
condition|)
block|{
name|tmp
operator|=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|entry
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|INT_GET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|tmp
condition|)
name|tmp
operator|=
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|->
name|firstused
condition|)
name|INT_SET
argument_list|(
name|hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tmp
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|holes
operator|=
literal|1
expr_stmt|;
comment|/* mark as needing compaction */
block|}
name|xfs_da_log_buf
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if leaf is less than 50% full, caller may want to 	 * "join" the leaf with a sibling if so. 	 */
name|tmp
operator|=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|tmp
operator|+=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|mp
operator|->
name|m_dir_magicpct
condition|)
return|return
literal|1
return|;
comment|/* leaf is< 37% full */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Move all the directory entries from drop_leaf into save_leaf.  */
end_comment

begin_function
name|void
name|xfs_dir_leaf_unbalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|save_blk
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|drop_leaf
decl_stmt|,
modifier|*
name|save_leaf
decl_stmt|,
modifier|*
name|tmp_leaf
decl_stmt|;
name|xfs_dir_leaf_hdr_t
modifier|*
name|drop_hdr
decl_stmt|,
modifier|*
name|save_hdr
decl_stmt|,
modifier|*
name|tmp_hdr
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|tmpbuffer
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|mp
operator|=
name|state
operator|->
name|mp
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|save_blk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|drop_leaf
operator|=
name|drop_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|save_leaf
operator|=
name|save_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|drop_hdr
operator|=
operator|&
name|drop_leaf
operator|->
name|hdr
expr_stmt|;
name|save_hdr
operator|=
operator|&
name|save_leaf
operator|->
name|hdr
expr_stmt|;
comment|/* 	 * Save last hashval from dying block for later Btree fixup. 	 */
name|drop_blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|entries
index|[
name|drop_leaf
operator|->
name|hdr
operator|.
name|count
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we need a temp buffer, or can we do it in place. 	 * Note that we don't check "leaf" for holes because we will 	 * always be dropping it, toosmall() decided that for us already. 	 */
if|if
condition|(
name|save_hdr
operator|->
name|holes
operator|==
literal|0
condition|)
block|{
comment|/* 		 * dest leaf has no holes, so we add there.  May need 		 * to make some room in the entry array. 		 */
if|if
condition|(
name|xfs_dir_leaf_order
argument_list|(
name|save_blk
operator|->
name|bp
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
condition|)
block|{
name|xfs_dir_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|save_leaf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_dir_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|save_leaf
argument_list|,
name|INT_GET
argument_list|(
name|save_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Destination has holes, so we make a temporary copy 		 * of the leaf and add them both to that. 		 */
name|tmpbuffer
operator|=
name|kmem_alloc
argument_list|(
name|state
operator|->
name|blocksize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tmpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmpbuffer
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|tmp_leaf
operator|=
operator|(
name|xfs_dir_leafblock_t
operator|*
operator|)
name|tmpbuffer
expr_stmt|;
name|tmp_hdr
operator|=
operator|&
name|tmp_leaf
operator|->
name|hdr
expr_stmt|;
name|tmp_hdr
operator|->
name|info
operator|=
name|save_hdr
operator|->
name|info
expr_stmt|;
comment|/* struct copy */
name|tmp_hdr
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|INT_SET
argument_list|(
name|tmp_hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_hdr
operator|->
name|firstused
condition|)
name|INT_SET
argument_list|(
name|tmp_hdr
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tmp_hdr
operator|->
name|namebytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfs_dir_leaf_order
argument_list|(
name|save_blk
operator|->
name|bp
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
condition|)
block|{
name|xfs_dir_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_dir_leaf_moveents
argument_list|(
name|save_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
name|INT_GET
argument_list|(
name|tmp_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|save_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_dir_leaf_moveents
argument_list|(
name|save_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|save_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_dir_leaf_moveents
argument_list|(
name|drop_leaf
argument_list|,
literal|0
argument_list|,
name|tmp_leaf
argument_list|,
name|INT_GET
argument_list|(
name|tmp_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|drop_hdr
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|save_leaf
argument_list|,
name|tmp_leaf
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmpbuffer
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Copy out last hashval in each block for B-tree code. 	 */
name|save_blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for finding things in the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Look up a name in a leaf directory structure.  * This is the internal routine, it uses the caller's buffer.  *  * Note that duplicate keys are allowed, but only check within the  * current leaf node.  The Btree code must check in adjacent leaf nodes.  *  * Return in *index the index into the entry[] array of either the found  * entry, or where the entry should have been (insert before that entry).  *  * Don't change the args->inumber unless we find the filename.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_lookup_int
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|int
name|probe
decl_stmt|,
name|span
decl_stmt|;
name|xfs_dahash_t
name|hashval
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|args
operator|->
name|dp
operator|->
name|i_mount
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Binary search.  (note: small blocks will skip this loop) 	 */
name|hashval
operator|=
name|args
operator|->
name|hashval
expr_stmt|;
name|probe
operator|=
name|span
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|probe
index|]
init|;
name|span
operator|>
literal|4
condition|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|probe
index|]
control|)
block|{
name|span
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|hashval
condition|)
name|probe
operator|+=
name|span
expr_stmt|;
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
name|hashval
condition|)
name|probe
operator|-=
name|span
expr_stmt|;
else|else
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|probe
operator|>=
literal|0
operator|)
operator|&&
expr|\
operator|(
operator|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|count
operator|)
operator|||
operator|(
name|probe
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|span
operator|<=
literal|4
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|hashval
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Since we may have duplicate hashval's, find the first matching 	 * hashval in the leaf. 	 */
while|while
condition|(
operator|(
name|probe
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|hashval
operator|)
condition|)
block|{
name|entry
operator|--
expr_stmt|;
name|probe
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|probe
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|hashval
operator|)
condition|)
block|{
name|entry
operator|++
expr_stmt|;
name|probe
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|probe
operator|==
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|hashval
operator|)
condition|)
block|{
operator|*
name|index
operator|=
name|probe
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
comment|/* 	 * Duplicate keys may be present, so search all of them for a match. 	 */
while|while
condition|(
operator|(
name|probe
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|hashval
operator|)
condition|)
block|{
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|namest
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|namest
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XFS_DIR_SF_GET_DIRINO
argument_list|(
operator|&
name|namest
operator|->
name|inumber
argument_list|,
operator|&
name|args
operator|->
name|inumber
argument_list|)
expr_stmt|;
operator|*
name|index
operator|=
name|probe
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
return|;
block|}
name|entry
operator|++
expr_stmt|;
name|probe
operator|++
expr_stmt|;
block|}
operator|*
name|index
operator|=
name|probe
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|==
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|||
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Utility routines.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Move the indicated entries from one leaf to another.  * NOTE: this routine modifies both source and destination leaves.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|void
name|xfs_dir_leaf_moveents
parameter_list|(
name|xfs_dir_leafblock_t
modifier|*
name|leaf_s
parameter_list|,
name|int
name|start_s
parameter_list|,
name|xfs_dir_leafblock_t
modifier|*
name|leaf_d
parameter_list|,
name|int
name|start_d
parameter_list|,
name|int
name|count
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_dir_leaf_hdr_t
modifier|*
name|hdr_s
decl_stmt|,
modifier|*
name|hdr_d
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry_s
decl_stmt|,
modifier|*
name|entry_d
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Check for nothing to do. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Set up environment. 	 */
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf_s
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|hdr_s
operator|=
operator|&
name|leaf_s
operator|->
name|hdr
expr_stmt|;
name|hdr_d
operator|=
operator|&
name|leaf_d
operator|->
name|hdr
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|/
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
operator|(
operator|(
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry_s
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr_s
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
operator|(
operator|(
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|entry_d
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr_d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|start_s
operator|<
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|start_d
operator|<=
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|count
operator|<=
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Move the entries in the destination leaf up to make a hole? 	 */
if|if
condition|(
name|start_d
operator|<
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|start_d
expr_stmt|;
name|tmp
operator|*=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_d
operator|->
name|entries
index|[
name|start_d
index|]
expr_stmt|;
name|entry_d
operator|=
operator|&
name|leaf_d
operator|->
name|entries
index|[
name|start_d
operator|+
name|count
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|entry_d
argument_list|,
name|entry_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy all entry's in the same (sorted) order, 	 * but allocate filenames packed and in sequence. 	 */
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
index|]
expr_stmt|;
name|entry_d
operator|=
operator|&
name|leaf_d
operator|->
name|entries
index|[
name|start_d
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|entry_s
operator|++
operator|,
name|entry_d
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry_s
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XFS_DIR_LEAF_ENTSIZE_BYENTRY
argument_list|(
name|entry_s
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|tmp
operator|)
argument_list|)
expr_stmt|;
name|entry_d
operator|->
name|hashval
operator|=
name|entry_s
operator|->
name|hashval
expr_stmt|;
comment|/* INT_: direct copy */
name|INT_COPY
argument_list|(
name|entry_d
operator|->
name|nameidx
argument_list|,
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|entry_d
operator|->
name|namelen
operator|=
name|entry_s
operator|->
name|namelen
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry_d
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|tmp
operator|<=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf_d
argument_list|,
name|INT_GET
argument_list|(
name|entry_d
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|,
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf_s
argument_list|,
name|INT_GET
argument_list|(
name|entry_s
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|entry_s
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|tmp
operator|<=
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf_s
argument_list|,
name|INT_GET
argument_list|(
name|entry_s
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr_s
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|entry_d
operator|->
name|namelen
operator|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr_d
operator|->
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|entry_d
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Zero out the entries we just copied. 	 */
if|if
condition|(
name|start_s
operator|==
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
index|]
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_s
operator|+
name|tmp
operator|<=
operator|(
name|char
operator|*
operator|)
name|leaf_s
operator|+
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_s
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Move the remaining entries down to fill the hole, 		 * then zero the entries at the top. 		 */
name|tmp
operator|=
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|count
expr_stmt|;
name|tmp
operator|*=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
operator|+
name|count
index|]
expr_stmt|;
name|entry_d
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|start_s
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|entry_d
argument_list|,
name|entry_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
expr_stmt|;
name|entry_s
operator|=
operator|&
name|leaf_s
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|hdr_s
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_s
operator|+
name|tmp
operator|<=
operator|(
name|char
operator|*
operator|)
name|leaf_s
operator|+
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry_s
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the freemap information 	 */
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|firstused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|1
index|]
operator|.
name|base
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|(
name|hdr_d
operator|->
name|freemap
index|[
literal|2
index|]
operator|.
name|base
operator|=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|hdr_d
operator|->
name|freemap
index|[
literal|1
index|]
operator|.
name|size
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|(
name|hdr_d
operator|->
name|freemap
index|[
literal|2
index|]
operator|.
name|size
operator|=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|hdr_s
operator|->
name|holes
operator|=
literal|1
expr_stmt|;
comment|/* leaf may not be compact */
block|}
end_function

begin_comment
comment|/*  * Compare two leaf blocks "order".  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_order
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|leaf1_bp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|leaf2_bp
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf1
decl_stmt|,
modifier|*
name|leaf2
decl_stmt|;
name|leaf1
operator|=
name|leaf1_bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|leaf2_bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
operator|)
operator|&&
operator|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pick up the last hashvalue from a leaf block.  */
end_comment

begin_function
name|xfs_dahash_t
name|xfs_dir_leaf_lasthash
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy out directory entries for getdents(), for leaf directories.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_getdents_int
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eobp
parameter_list|,
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
name|xfs_dir_put_t
name|put
parameter_list|,
name|xfs_daddr_t
name|nextda
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|int
name|entno
decl_stmt|,
name|want_entno
decl_stmt|,
name|i
decl_stmt|,
name|nextentno
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_dahash_t
name|cookhash
decl_stmt|;
name|xfs_dahash_t
name|nexthash
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|(
name|BITS_PER_LONG
operator|==
literal|32
operator|)
name|xfs_dahash_t
name|lasthash
init|=
name|XFS_DA_MAXHASH
decl_stmt|;
endif|#
directive|endif
name|xfs_dir_put_args_t
name|p
decl_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_DIR_LEAF_MAGIC
condition|)
block|{
operator|*
name|eobp
operator|=
literal|1
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
comment|/* XXX wrong code */
block|}
name|want_entno
operator|=
name|XFS_DA_COOKIE_ENTRY
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|cookhash
operator|=
name|XFS_DA_COOKIE_HASH
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_dul
argument_list|(
literal|"leaf: start"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
comment|/* 	 * Re-find our place. 	 */
for|for
control|(
name|i
operator|=
name|entno
operator|=
literal|0
operator|,
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
init|;
name|i
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|namest
operator|<
operator|(
name|char
operator|*
operator|)
name|leaf
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|namest
operator|>=
operator|(
name|char
operator|*
operator|)
name|leaf
operator|+
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_dir_leaf_getdents_int(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"leaf: corrupted"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|cookhash
condition|)
block|{
if|if
condition|(
name|entno
operator|<
name|want_entno
operator|&&
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|cookhash
condition|)
block|{
comment|/* 				 * Trying to get to a particular offset in a 				 * run of equal-hashval entries. 				 */
name|entno
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|want_entno
operator|>
literal|0
operator|&&
name|entno
operator|==
name|want_entno
operator|&&
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|cookhash
condition|)
block|{
break|break;
block|}
else|else
block|{
name|entno
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|==
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|xfs_dir_trace_g_du
argument_list|(
literal|"leaf: hash not found"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|XFS_DA_MAKE_COOKIE
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XFS_DA_MAXHASH
argument_list|)
expr_stmt|;
comment|/* 		 * Don't set uio_offset if there's another block: 		 * the node code will be setting uio_offset anyway. 		 */
operator|*
name|eobp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xfs_dir_trace_g_due
argument_list|(
literal|"leaf: hash found"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|p
operator|.
name|dbp
operator|=
name|dbp
expr_stmt|;
name|p
operator|.
name|put
operator|=
name|put
expr_stmt|;
name|p
operator|.
name|uio
operator|=
name|uio
expr_stmt|;
comment|/* 	 * We're synchronized, start copying entries out to the user. 	 */
for|for
control|(
init|;
name|entno
operator|>=
literal|0
operator|&&
name|i
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|;
name|entry
operator|++
operator|,
name|i
operator|++
operator|,
operator|(
name|entno
operator|=
name|nextentno
operator|)
control|)
block|{
name|int
name|lastresid
init|=
literal|0
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dircook_t
name|lastoffset
decl_stmt|;
name|xfs_dahash_t
name|thishash
decl_stmt|;
comment|/* 		 * Check for a damaged directory leaf block and pick up 		 * the inode number from this entry. 		 */
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|namest
operator|<
operator|(
name|char
operator|*
operator|)
name|leaf
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|namest
operator|>=
operator|(
name|char
operator|*
operator|)
name|leaf
operator|+
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_dir_leaf_getdents_int(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"leaf: corrupted"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|xfs_dir_trace_g_duc
argument_list|(
literal|"leaf: middle cookie  "
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|p
operator|.
name|cook
operator|.
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|nexthash
operator|=
name|INT_GET
argument_list|(
name|entry
index|[
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexthash
operator|==
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|nextentno
operator|=
name|entno
operator|+
literal|1
expr_stmt|;
else|else
name|nextentno
operator|=
literal|0
expr_stmt|;
name|XFS_PUT_COOKIE
argument_list|(
name|p
operator|.
name|cook
argument_list|,
name|mp
argument_list|,
name|bno
argument_list|,
name|nextentno
argument_list|,
name|nexthash
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_duc
argument_list|(
literal|"leaf: middle cookie  "
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|p
operator|.
name|cook
operator|.
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|thishash
operator|=
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|)
operator|)
condition|)
block|{
name|xfs_dabuf_t
modifier|*
name|bp2
decl_stmt|;
name|xfs_dir_leafblock_t
modifier|*
name|leaf2
decl_stmt|;
name|ASSERT
argument_list|(
name|nextda
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|dp
operator|->
name|i_transp
argument_list|,
name|dp
argument_list|,
name|thishash
argument_list|,
name|nextda
argument_list|,
operator|&
name|bp2
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
return|;
name|ASSERT
argument_list|(
name|bp2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf2
operator|=
name|bp2
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|be16_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_DIR_LEAF_MAGIC
operator|)
operator|||
operator|(
name|be32_to_cpu
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
argument_list|)
operator|!=
name|bno
operator|)
argument_list|)
condition|)
block|{
comment|/* GROT */
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_dir_leaf_getdents_int(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|leaf2
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|dp
operator|->
name|i_transp
argument_list|,
name|bp2
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|nexthash
operator|=
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|nextentno
operator|=
operator|-
literal|1
expr_stmt|;
name|XFS_PUT_COOKIE
argument_list|(
name|p
operator|.
name|cook
argument_list|,
name|mp
argument_list|,
name|thishash
argument_list|,
literal|0
argument_list|,
name|nexthash
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|dp
operator|->
name|i_transp
argument_list|,
name|bp2
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_duc
argument_list|(
literal|"leaf: next blk cookie"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|p
operator|.
name|cook
operator|.
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextentno
operator|=
operator|-
literal|1
expr_stmt|;
name|XFS_PUT_COOKIE
argument_list|(
name|p
operator|.
name|cook
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XFS_DA_MAXHASH
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Save off the cookie so we can fall back should the 		 * 'put' into the outgoing buffer fails.  To handle a run 		 * of equal-hashvals, the off_t structure on 64bit 		 * builds has entno built into the cookie to ID the 		 * entry.  On 32bit builds, we only have space for the 		 * hashval so we can't ID specific entries within a group 		 * of same hashval entries.   For this, lastoffset is set 		 * to the first in the run of equal hashvals so we don't 		 * include any entries unless we can include all entries 		 * that share the same hashval.  Hopefully the buffer 		 * provided is big enough to handle it (see pv763517). 		 */
if|#
directive|if
operator|(
name|BITS_PER_LONG
operator|==
literal|32
operator|)
if|if
condition|(
operator|(
name|thishash
operator|=
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|!=
name|lasthash
condition|)
block|{
name|XFS_PUT_COOKIE
argument_list|(
name|lastoffset
argument_list|,
name|mp
argument_list|,
name|bno
argument_list|,
name|entno
argument_list|,
name|thishash
argument_list|)
expr_stmt|;
name|lastresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|lasthash
operator|=
name|thishash
expr_stmt|;
block|}
else|else
block|{
name|xfs_dir_trace_g_duc
argument_list|(
literal|"leaf: DUP COOKIES, skipped"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|p
operator|.
name|cook
operator|.
name|o
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|thishash
operator|=
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|XFS_PUT_COOKIE
argument_list|(
name|lastoffset
argument_list|,
name|mp
argument_list|,
name|bno
argument_list|,
name|entno
argument_list|,
name|thishash
argument_list|)
expr_stmt|;
name|lastresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
endif|#
directive|endif
comment|/* BITS_PER_LONG == 32 */
comment|/* 		 * Put the current entry into the outgoing buffer.  If we fail 		 * then restore the UIO to the first entry in the current 		 * run of equal-hashval entries (probably one 1 entry long). 		 */
name|p
operator|.
name|ino
operator|=
name|XFS_GET_DIR_INO8
argument_list|(
name|namest
operator|->
name|inumber
argument_list|)
expr_stmt|;
if|#
directive|if
name|XFS_BIG_INUMS
name|p
operator|.
name|ino
operator|+=
name|mp
operator|->
name|m_inoadd
expr_stmt|;
endif|#
directive|endif
name|p
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|namest
operator|->
name|name
expr_stmt|;
name|p
operator|.
name|namelen
operator|=
name|entry
operator|->
name|namelen
expr_stmt|;
name|retval
operator|=
name|p
operator|.
name|put
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|done
condition|)
block|{
name|uio
operator|->
name|uio_offset
operator|=
name|lastoffset
operator|.
name|o
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|lastresid
expr_stmt|;
operator|*
name|eobp
operator|=
literal|1
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"leaf: E-O-B"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
name|uio
operator|->
name|uio_offset
operator|=
name|p
operator|.
name|cook
operator|.
name|o
expr_stmt|;
operator|*
name|eobp
operator|=
literal|0
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"leaf: E-O-F"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Format a dirent64 structure and copy it out the the user's buffer.  */
end_comment

begin_function
name|int
name|xfs_dir_put_dirent64_direct
parameter_list|(
name|xfs_dir_put_args_t
modifier|*
name|pa
parameter_list|)
block|{
name|iovec_t
modifier|*
name|iovp
decl_stmt|;
name|int
name|reclen
decl_stmt|,
name|namelen
decl_stmt|;
name|xfs_dirent_t
modifier|*
name|idbp
decl_stmt|;
name|uio_t
modifier|*
name|uio
decl_stmt|;
name|namelen
operator|=
name|pa
operator|->
name|namelen
expr_stmt|;
name|reclen
operator|=
name|DIRENTSIZE
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|uio
operator|=
name|pa
operator|->
name|uio
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|pa
operator|->
name|done
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iovp
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|idbp
operator|=
operator|(
name|xfs_dirent_t
operator|*
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
name|iovp
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|idbp
operator|+
name|reclen
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|-=
name|reclen
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|reclen
expr_stmt|;
name|idbp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
name|idbp
operator|->
name|d_ino
operator|=
name|pa
operator|->
name|ino
expr_stmt|;
name|idbp
operator|->
name|d_off
operator|=
name|pa
operator|->
name|cook
operator|.
name|o
expr_stmt|;
name|idbp
operator|->
name|d_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pa
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|idbp
operator|->
name|d_name
argument_list|,
name|pa
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Format a dirent64 structure and copy it out the the user's buffer.  */
end_comment

begin_function
name|int
name|xfs_dir_put_dirent64_uio
parameter_list|(
name|xfs_dir_put_args_t
modifier|*
name|pa
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|reclen
decl_stmt|,
name|namelen
decl_stmt|;
name|xfs_dirent_t
modifier|*
name|idbp
decl_stmt|;
name|uio_t
modifier|*
name|uio
decl_stmt|;
name|namelen
operator|=
name|pa
operator|->
name|namelen
expr_stmt|;
name|reclen
operator|=
name|DIRENTSIZE
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|uio
operator|=
name|pa
operator|->
name|uio
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|pa
operator|->
name|done
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|idbp
operator|=
name|pa
operator|->
name|dbp
expr_stmt|;
name|idbp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
name|idbp
operator|->
name|d_ino
operator|=
name|pa
operator|->
name|ino
expr_stmt|;
name|idbp
operator|->
name|d_off
operator|=
name|pa
operator|->
name|cook
operator|.
name|o
expr_stmt|;
name|idbp
operator|->
name|d_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|idbp
operator|->
name|d_name
argument_list|,
name|pa
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|retval
operator|=
name|uio_read
argument_list|(
operator|(
name|caddr_t
operator|)
name|idbp
argument_list|,
name|reclen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|pa
operator|->
name|done
operator|=
operator|(
name|retval
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

