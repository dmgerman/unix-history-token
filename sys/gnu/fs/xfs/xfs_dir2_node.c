begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_comment
comment|/*  * xfs_dir2_node.c  * XFS directory implementation, version 2, node form files  * See data structures in xfs_dir2_node.h and xfs_da_btree.h.  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_data.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_block.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_node.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_trace.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * Function declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xfs_dir2_free_log_header
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_leafn_add
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|xfs_dir2_leafn_check
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_dir2_leafn_check
parameter_list|(
name|dp
parameter_list|,
name|bp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|xfs_dir2_leafn_moveents
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp_s
parameter_list|,
name|int
name|start_s
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp_d
parameter_list|,
name|int
name|start_d
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfs_dir2_leafn_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_leafn_remove
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
name|index
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|dblk
parameter_list|,
name|int
modifier|*
name|rval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir2_node_addname_int
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|fblk
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Log entries from a freespace block.  */
end_comment

begin_function
name|void
name|xfs_dir2_free_log_bests
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* freespace buffer */
name|int
name|first
parameter_list|,
comment|/* first entry to log */
name|int
name|last
parameter_list|)
comment|/* last entry to log */
block|{
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
comment|/* freespace structure */
name|free
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|free
operator|->
name|bests
index|[
name|first
index|]
operator|-
operator|(
name|char
operator|*
operator|)
name|free
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|free
operator|->
name|bests
index|[
name|last
index|]
operator|-
operator|(
name|char
operator|*
operator|)
name|free
operator|+
sizeof|sizeof
argument_list|(
name|free
operator|->
name|bests
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log header from a freespace block.  */
end_comment

begin_function
specifier|static
name|void
name|xfs_dir2_free_log_header
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* freespace buffer */
block|{
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
comment|/* freespace structure */
name|free
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|free
operator|->
name|hdr
operator|-
operator|(
name|char
operator|*
operator|)
name|free
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_dir2_free_hdr_t
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a leaf-format directory to a node-format directory.  * We need to change the magic number of the leaf block, and copy  * the freespace table out of the leaf block into its own block.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leaf_to_node
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|lbp
parameter_list|)
comment|/* leaf buffer */
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_dabuf_t
modifier|*
name|fbp
decl_stmt|;
comment|/* freespace buffer */
name|xfs_dir2_db_t
name|fdb
decl_stmt|;
comment|/* freespace block number */
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
comment|/* freespace structure */
name|xfs_dir2_data_off_t
modifier|*
name|from
decl_stmt|;
comment|/* pointer to freespace entry */
name|int
name|i
decl_stmt|;
comment|/* leaf freespace index */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|n
decl_stmt|;
comment|/* count of live freespc ents */
name|xfs_dir2_data_off_t
name|off
decl_stmt|;
comment|/* freespace entry value */
name|xfs_dir2_data_off_t
modifier|*
name|to
decl_stmt|;
comment|/* pointer to freespace entry */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_b
argument_list|(
literal|"leaf_to_node"
argument_list|,
name|args
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Add a freespace block to the directory. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_grow_inode
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_FREE_SPACE
argument_list|,
operator|&
name|fdb
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|fdb
operator|==
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the buffer for the new freespace block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|fdb
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|fbp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the freespace block header. 	 */
name|INT_SET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<=
operator|(
name|uint
operator|)
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|/
name|mp
operator|->
name|m_dirblksize
argument_list|)
expr_stmt|;
name|INT_COPY
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ltp
operator|->
name|bestcount
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 	 * Copy freespace entries from the leaf block to the new block. 	 * Count active entries. 	 */
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
operator|,
name|from
operator|=
name|XFS_DIR2_LEAF_BESTS_P_ARCH
argument_list|(
name|ltp
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|,
name|to
operator|=
name|free
operator|->
name|bests
init|;
name|i
operator|<
name|INT_GET
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|;
name|i
operator|++
operator|,
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|off
operator|=
name|INT_GET
argument_list|(
operator|*
name|from
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|!=
name|NULLDATAOFF
condition|)
name|n
operator|++
expr_stmt|;
name|INT_SET
argument_list|(
operator|*
name|to
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nused
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Log everything. 	 */
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_free_log_header
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
name|xfs_dir2_free_log_bests
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|,
literal|0
argument_list|,
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a leaf entry to a leaf block in a node-form directory.  * The other work necessary is done from the caller.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_leafn_add
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|int
name|index
parameter_list|)
comment|/* insertion pt for new entry */
block|{
name|int
name|compact
decl_stmt|;
comment|/* compacting stale leaves */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|highstale
decl_stmt|;
comment|/* next stale entry */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|int
name|lfloghigh
decl_stmt|;
comment|/* high leaf entry logging */
name|int
name|lfloglow
decl_stmt|;
comment|/* low leaf entry logging */
name|int
name|lowstale
decl_stmt|;
comment|/* previous stale entry */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_sb
argument_list|(
literal|"leafn_add"
argument_list|,
name|args
argument_list|,
name|index
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
comment|/* 	 * If there are already the maximum number of leaf entries in 	 * the block, if there are no stale entries it won't fit. 	 * Caller will do a split.  If there are stale entries we'll do 	 * a compact. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_MAX_LEAF_ENTS
argument_list|(
name|mp
argument_list|)
condition|)
block|{
if|if
condition|(
name|INT_ISZERO
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|compact
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|1
expr_stmt|;
block|}
else|else
name|compact
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|==
literal|0
operator|||
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|index
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<=
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|==
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|||
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|index
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|justcheck
condition|)
return|return
literal|0
return|;
comment|/* 	 * Compact out all but one stale leaf entry.  Leaves behind 	 * the entry closest to index. 	 */
if|if
condition|(
name|compact
condition|)
block|{
name|xfs_dir2_leaf_compact_x1
argument_list|(
name|bp
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|lowstale
argument_list|,
operator|&
name|highstale
argument_list|,
operator|&
name|lfloglow
argument_list|,
operator|&
name|lfloghigh
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set impossible logging indices for this case. 	 */
elseif|else
if|if
condition|(
operator|!
name|INT_ISZERO
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|lfloglow
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|lfloghigh
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * No stale entries, just insert a space for the new entry. 	 */
if|if
condition|(
name|INT_ISZERO
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|memmove
argument_list|(
name|lep
operator|+
literal|1
argument_list|,
name|lep
argument_list|,
operator|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lep
argument_list|)
argument_list|)
expr_stmt|;
name|lfloglow
operator|=
name|index
expr_stmt|;
name|lfloghigh
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There are stale entries.  We'll use one for the new entry. 	 */
else|else
block|{
comment|/* 		 * If we didn't do a compact then we need to figure out 		 * which stale entry will be used. 		 */
if|if
condition|(
name|compact
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Find first stale entry before our insertion point. 			 */
for|for
control|(
name|lowstale
operator|=
name|index
operator|-
literal|1
init|;
name|lowstale
operator|>=
literal|0
operator|&&
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
operator|.
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DIR2_NULL_DATAPTR
condition|;
name|lowstale
operator|--
control|)
continue|continue;
comment|/* 			 * Find next stale entry after insertion point. 			 * Stop looking if the answer would be worse than 			 * lowstale already found. 			 */
for|for
control|(
name|highstale
operator|=
name|index
init|;
name|highstale
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&&
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|highstale
index|]
operator|.
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DIR2_NULL_DATAPTR
operator|&&
operator|(
name|lowstale
operator|<
literal|0
operator|||
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|>=
name|highstale
operator|-
name|index
operator|)
condition|;
name|highstale
operator|++
control|)
continue|continue;
block|}
comment|/* 		 * Using the low stale entry. 		 * Shift entries up toward the stale slot. 		 */
if|if
condition|(
name|lowstale
operator|>=
literal|0
operator|&&
operator|(
name|highstale
operator|==
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|||
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|<
name|highstale
operator|-
name|index
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
operator|.
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|>
literal|0
condition|)
name|memmove
argument_list|(
operator|&
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
argument_list|,
operator|&
name|leaf
operator|->
name|ents
index|[
name|lowstale
operator|+
literal|1
index|]
argument_list|,
operator|(
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lep
argument_list|)
argument_list|)
expr_stmt|;
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
operator|-
literal|1
index|]
expr_stmt|;
name|lfloglow
operator|=
name|MIN
argument_list|(
name|lowstale
argument_list|,
name|lfloglow
argument_list|)
expr_stmt|;
name|lfloghigh
operator|=
name|MAX
argument_list|(
name|index
operator|-
literal|1
argument_list|,
name|lfloghigh
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Using the high stale entry. 		 * Shift entries down toward the stale slot. 		 */
else|else
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|highstale
index|]
operator|.
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|highstale
operator|-
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|highstale
operator|-
name|index
operator|>
literal|0
condition|)
name|memmove
argument_list|(
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
argument_list|,
operator|(
name|highstale
operator|-
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lep
argument_list|)
argument_list|)
expr_stmt|;
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
name|lfloglow
operator|=
name|MIN
argument_list|(
name|index
argument_list|,
name|lfloglow
argument_list|)
expr_stmt|;
name|lfloghigh
operator|=
name|MAX
argument_list|(
name|highstale
argument_list|,
name|lfloghigh
argument_list|)
expr_stmt|;
block|}
name|INT_MOD
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert the new entry, log everything. 	 */
name|INT_SET
argument_list|(
name|lep
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DIR2_DB_OFF_TO_DATAPTR
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|blkno
argument_list|,
name|args
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|lfloglow
argument_list|,
name|lfloghigh
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Check internal consistency of a leafn block.  */
end_comment

begin_function
name|void
name|xfs_dir2_leafn_check
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* leaf buffer */
block|{
name|int
name|i
decl_stmt|;
comment|/* leaf index */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|stale
decl_stmt|;
comment|/* count of stale leaves */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<=
name|XFS_DIR2_MAX_LEAF_ENTS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|stale
operator|=
literal|0
init|;
name|i
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|i
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
name|stale
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|stale
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Return the last hash value in the leaf.  * Stale entries are ok.  */
end_comment

begin_function
name|xfs_dahash_t
comment|/* hash value */
name|xfs_dir2_leafn_lasthash
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|int
modifier|*
name|count
parameter_list|)
comment|/* count of entries in leaf */
block|{
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_ISZERO
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|INT_GET
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a leaf entry in a node-format leaf block.  * If this is an addname then the extrablk in state is a freespace block,  * otherwise it's a data block.  */
end_comment

begin_function
name|int
name|xfs_dir2_leafn_lookup_int
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|int
modifier|*
name|indexp
parameter_list|,
comment|/* out: leaf entry index */
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
comment|/* state to fill in */
block|{
name|xfs_dabuf_t
modifier|*
name|curbp
decl_stmt|;
comment|/* current data/free buffer */
name|xfs_dir2_db_t
name|curdb
decl_stmt|;
comment|/* current data block number */
name|xfs_dir2_db_t
name|curfdb
decl_stmt|;
comment|/* current free block number */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data block entry */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|fi
decl_stmt|;
comment|/* free entry index */
name|xfs_dir2_free_t
modifier|*
name|free
init|=
name|NULL
decl_stmt|;
comment|/* free block structure */
name|int
name|index
decl_stmt|;
comment|/* leaf entry index */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|int
name|length
init|=
literal|0
decl_stmt|;
comment|/* length of new data entry */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_dir2_db_t
name|newdb
decl_stmt|;
comment|/* new data block number */
name|xfs_dir2_db_t
name|newfdb
decl_stmt|;
comment|/* new free block number */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__KERNEL__
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfs_dir2_leafn_check
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the hash value in the leaf entries. 	 */
name|index
operator|=
name|xfs_dir2_leaf_search_hash
argument_list|(
name|args
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Do we have a buffer coming in? 	 */
if|if
condition|(
name|state
operator|->
name|extravalid
condition|)
name|curbp
operator|=
name|state
operator|->
name|extrablk
operator|.
name|bp
expr_stmt|;
else|else
name|curbp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For addname, it's a free block buffer, get the block number. 	 */
if|if
condition|(
name|args
operator|->
name|addname
condition|)
block|{
name|curfdb
operator|=
name|curbp
condition|?
name|state
operator|->
name|extrablk
operator|.
name|blkno
else|:
operator|-
literal|1
expr_stmt|;
name|curdb
operator|=
operator|-
literal|1
expr_stmt|;
name|length
operator|=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|free
operator|=
operator|(
name|curbp
condition|?
name|curbp
operator|->
name|data
else|:
name|NULL
operator|)
operator|)
condition|)
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For others, it's a data block buffer, get the block number. 	 */
else|else
block|{
name|curfdb
operator|=
operator|-
literal|1
expr_stmt|;
name|curdb
operator|=
name|curbp
condition|?
name|state
operator|->
name|extrablk
operator|.
name|blkno
else|:
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Loop over leaf entries with the right hash value. 	 */
for|for
control|(
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
init|;
name|index
operator|<
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&&
name|INT_GET
argument_list|(
name|lep
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|args
operator|->
name|hashval
condition|;
name|lep
operator|++
operator|,
name|index
operator|++
control|)
block|{
comment|/* 		 * Skip stale leaf entries. 		 */
if|if
condition|(
name|INT_GET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
continue|continue;
comment|/* 		 * Pull the data block number from the entry. 		 */
name|newdb
operator|=
name|XFS_DIR2_DATAPTR_TO_DB
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * For addname, we're looking for a place to put the new entry. 		 * We want to use a data block with an entry of equal 		 * hash value to ours if there is one with room. 		 */
if|if
condition|(
name|args
operator|->
name|addname
condition|)
block|{
comment|/* 			 * If this block isn't the data block we already have 			 * in hand, take a look at it. 			 */
if|if
condition|(
name|newdb
operator|!=
name|curdb
condition|)
block|{
name|curdb
operator|=
name|newdb
expr_stmt|;
comment|/* 				 * Convert the data block to the free block 				 * holding its freespace information. 				 */
name|newfdb
operator|=
name|XFS_DIR2_DB_TO_FDB
argument_list|(
name|mp
argument_list|,
name|newdb
argument_list|)
expr_stmt|;
comment|/* 				 * If it's not the one we have in hand, 				 * read it in. 				 */
if|if
condition|(
name|newfdb
operator|!=
name|curfdb
condition|)
block|{
comment|/* 					 * If we had one before, drop it. 					 */
if|if
condition|(
name|curbp
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|curbp
argument_list|)
expr_stmt|;
comment|/* 					 * Read the free block. 					 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|newfdb
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|curbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|curfdb
operator|=
name|newfdb
expr_stmt|;
name|free
operator|=
name|curbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|%
name|XFS_DIR2_MAX_FREE_BESTS
argument_list|(
name|mp
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<=
name|curdb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curdb
operator|<
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Get the index for our entry. 				 */
name|fi
operator|=
name|XFS_DIR2_DB_TO_FDINDEX
argument_list|(
name|mp
argument_list|,
name|curdb
argument_list|)
expr_stmt|;
comment|/* 				 * If it has room, return it. 				 */
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|fi
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|NULLDATAOFF
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_dir2_leafn_lookup_int"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|fi
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|length
condition|)
block|{
operator|*
name|indexp
operator|=
name|index
expr_stmt|;
name|state
operator|->
name|extravalid
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|bp
operator|=
name|curbp
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|blkno
operator|=
name|curfdb
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|index
operator|=
name|fi
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|magic
operator|=
name|XFS_DIR2_FREE_MAGIC
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
block|}
block|}
comment|/* 		 * Not adding a new entry, so we really want to find 		 * the name given to us. 		 */
else|else
block|{
comment|/* 			 * If it's a different data block, go get it. 			 */
if|if
condition|(
name|newdb
operator|!=
name|curdb
condition|)
block|{
comment|/* 				 * If we had a block before, drop it. 				 */
if|if
condition|(
name|curbp
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|curbp
argument_list|)
expr_stmt|;
comment|/* 				 * Read the data block. 				 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|newdb
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|curbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|curbp
argument_list|)
expr_stmt|;
name|curdb
operator|=
name|newdb
expr_stmt|;
block|}
comment|/* 			 * Point to the data entry. 			 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|curbp
operator|->
name|data
operator|+
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* 			 * Compare the entry, return it if it matches. 			 */
if|if
condition|(
name|dep
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|dep
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|dep
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|args
operator|->
name|inumber
operator|=
name|INT_GET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
operator|*
name|indexp
operator|=
name|index
expr_stmt|;
name|state
operator|->
name|extravalid
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|bp
operator|=
name|curbp
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|blkno
operator|=
name|curdb
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|index
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|curbp
operator|->
name|data
argument_list|)
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|magic
operator|=
name|XFS_DIR2_DATA_MAGIC
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
return|;
block|}
block|}
block|}
comment|/* 	 * Didn't find a match. 	 * If we are holding a buffer, give it back in case our caller 	 * finds it useful. 	 */
if|if
condition|(
operator|(
name|state
operator|->
name|extravalid
operator|=
operator|(
name|curbp
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|state
operator|->
name|extrablk
operator|.
name|bp
operator|=
name|curbp
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * For addname, giving back a free block. 		 */
if|if
condition|(
name|args
operator|->
name|addname
condition|)
block|{
name|state
operator|->
name|extrablk
operator|.
name|blkno
operator|=
name|curfdb
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|magic
operator|=
name|XFS_DIR2_FREE_MAGIC
expr_stmt|;
block|}
comment|/* 		 * For other callers, giving back a data block. 		 */
else|else
block|{
name|state
operator|->
name|extrablk
operator|.
name|blkno
operator|=
name|curdb
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|magic
operator|=
name|XFS_DIR2_DATA_MAGIC
expr_stmt|;
block|}
block|}
comment|/* 	 * Return the final index, that will be the insertion point. 	 */
operator|*
name|indexp
operator|=
name|index
expr_stmt|;
name|ASSERT
argument_list|(
name|index
operator|==
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|||
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move count leaf entries from source to destination leaf.  * Log entries and headers.  Stale entries are preserved.  */
end_comment

begin_function
specifier|static
name|void
name|xfs_dir2_leafn_moveents
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|bp_s
parameter_list|,
comment|/* source leaf buffer */
name|int
name|start_s
parameter_list|,
comment|/* source leaf index */
name|xfs_dabuf_t
modifier|*
name|bp_d
parameter_list|,
comment|/* destination leaf buffer */
name|int
name|start_d
parameter_list|,
comment|/* destination leaf index */
name|int
name|count
parameter_list|)
comment|/* count of leaves to copy */
block|{
name|xfs_dir2_leaf_t
modifier|*
name|leaf_d
decl_stmt|;
comment|/* destination leaf structure */
name|xfs_dir2_leaf_t
modifier|*
name|leaf_s
decl_stmt|;
comment|/* source leaf structure */
name|int
name|stale
decl_stmt|;
comment|/* count stale leaves copied */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_bibii
argument_list|(
literal|"leafn_moveents"
argument_list|,
name|args
argument_list|,
name|bp_s
argument_list|,
name|start_s
argument_list|,
name|bp_d
argument_list|,
name|start_d
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Silently return if nothing to do. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|leaf_s
operator|=
name|bp_s
operator|->
name|data
expr_stmt|;
name|leaf_d
operator|=
name|bp_d
operator|->
name|data
expr_stmt|;
comment|/* 	 * If the destination index is not the end of the current 	 * destination leaf entries, open up a hole in the destination 	 * to hold the new entries. 	 */
if|if
condition|(
name|start_d
operator|<
name|INT_GET
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|leaf_d
operator|->
name|ents
index|[
name|start_d
operator|+
name|count
index|]
argument_list|,
operator|&
name|leaf_d
operator|->
name|ents
index|[
name|start_d
index|]
argument_list|,
operator|(
name|INT_GET
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|start_d
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_dir2_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|bp_d
argument_list|,
name|start_d
operator|+
name|count
argument_list|,
name|count
operator|+
name|INT_GET
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the source has stale leaves, count the ones in the copy range 	 * so we can update the header correctly. 	 */
if|if
condition|(
operator|!
name|INT_ISZERO
argument_list|(
name|leaf_s
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* temp leaf index */
for|for
control|(
name|i
operator|=
name|start_s
operator|,
name|stale
operator|=
literal|0
init|;
name|i
operator|<
name|start_s
operator|+
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|INT_GET
argument_list|(
name|leaf_s
operator|->
name|ents
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
name|stale
operator|++
expr_stmt|;
block|}
block|}
else|else
name|stale
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Copy the leaf entries from source to destination. 	 */
name|memcpy
argument_list|(
operator|&
name|leaf_d
operator|->
name|ents
index|[
name|start_d
index|]
argument_list|,
operator|&
name|leaf_s
operator|->
name|ents
index|[
name|start_s
index|]
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_dir2_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|bp_d
argument_list|,
name|start_d
argument_list|,
name|start_d
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If there are source entries after the ones we copied, 	 * delete the ones we copied by sliding the next ones down. 	 */
if|if
condition|(
name|start_s
operator|+
name|count
operator|<
name|INT_GET
argument_list|(
name|leaf_s
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|leaf_s
operator|->
name|ents
index|[
name|start_s
index|]
argument_list|,
operator|&
name|leaf_s
operator|->
name|ents
index|[
name|start_s
operator|+
name|count
index|]
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_dir2_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|bp_s
argument_list|,
name|start_s
argument_list|,
name|start_s
operator|+
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the headers and log them. 	 */
name|INT_MOD
argument_list|(
name|leaf_s
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|count
operator|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|leaf_s
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|stale
operator|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|leaf_d
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|stale
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|bp_s
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|bp_d
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|args
operator|->
name|dp
argument_list|,
name|bp_s
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|args
operator|->
name|dp
argument_list|,
name|bp_d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the sort order of two leaf blocks.  * Returns 1 if both are valid and leaf2 should be before leaf1, else 0.  */
end_comment

begin_function
name|int
comment|/* sort order */
name|xfs_dir2_leafn_order
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|leaf1_bp
parameter_list|,
comment|/* leaf1 buffer */
name|xfs_dabuf_t
modifier|*
name|leaf2_bp
parameter_list|)
comment|/* leaf2 buffer */
block|{
name|xfs_dir2_leaf_t
modifier|*
name|leaf1
decl_stmt|;
comment|/* leaf1 structure */
name|xfs_dir2_leaf_t
modifier|*
name|leaf2
decl_stmt|;
comment|/* leaf2 structure */
name|leaf1
operator|=
name|leaf1_bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|leaf2_bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|&&
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|ents
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|ents
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|||
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Rebalance leaf entries between two leaf blocks.  * This is actually only called when the second block is new,  * though the code deals with the general case.  * A new entry will be inserted in one of the blocks, and that  * entry is taken into account when balancing.  */
end_comment

begin_function
specifier|static
name|void
name|xfs_dir2_leafn_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
comment|/* btree cursor */
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
comment|/* first btree block */
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
comment|/* second btree block */
block|{
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
comment|/* operation arguments */
name|int
name|count
decl_stmt|;
comment|/* count (& direction) leaves */
name|int
name|isleft
decl_stmt|;
comment|/* new goes in left leaf */
name|xfs_dir2_leaf_t
modifier|*
name|leaf1
decl_stmt|;
comment|/* first leaf structure */
name|xfs_dir2_leaf_t
modifier|*
name|leaf2
decl_stmt|;
comment|/* second leaf structure */
name|int
name|mid
decl_stmt|;
comment|/* midpoint leaf index */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|oldstale
decl_stmt|;
comment|/* old count of stale leaves */
endif|#
directive|endif
name|int
name|oldsum
decl_stmt|;
comment|/* old total leaf count */
name|int
name|swap
decl_stmt|;
comment|/* swapped leaf blocks */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
comment|/* 	 * If the block order is wrong, swap the arguments. 	 */
if|if
condition|(
operator|(
name|swap
operator|=
name|xfs_dir2_leafn_order
argument_list|(
name|blk1
operator|->
name|bp
argument_list|,
name|blk2
operator|->
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|tmp
decl_stmt|;
comment|/* temp for block swap */
name|tmp
operator|=
name|blk1
expr_stmt|;
name|blk1
operator|=
name|blk2
expr_stmt|;
name|blk2
operator|=
name|tmp
expr_stmt|;
block|}
name|leaf1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|leaf2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|oldsum
operator|=
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|oldstale
operator|=
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mid
operator|=
name|oldsum
operator|>>
literal|1
expr_stmt|;
comment|/* 	 * If the old leaf count was odd then the new one will be even, 	 * so we need to divide the new count evenly. 	 */
if|if
condition|(
name|oldsum
operator|&
literal|1
condition|)
block|{
name|xfs_dahash_t
name|midhash
decl_stmt|;
comment|/* middle entry hash value */
if|if
condition|(
name|mid
operator|>=
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|midhash
operator|=
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|ents
index|[
name|mid
operator|-
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
else|else
name|midhash
operator|=
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|ents
index|[
name|mid
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|isleft
operator|=
name|args
operator|->
name|hashval
operator|<=
name|midhash
expr_stmt|;
block|}
comment|/* 	 * If the old count is even then the new count is odd, so there's 	 * no preferred side for the new entry. 	 * Pick the left one. 	 */
else|else
name|isleft
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Calculate moved entry count.  Positive means left-to-right, 	 * negative means right-to-left.  Then move the entries. 	 */
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|mid
operator|+
operator|(
name|isleft
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|xfs_dir2_leafn_moveents
argument_list|(
name|args
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|count
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|xfs_dir2_leafn_moveents
argument_list|(
name|args
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|oldsum
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|oldstale
argument_list|)
expr_stmt|;
comment|/* 	 * Mark whether we're inserting into the old or new leaf. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|state
operator|->
name|inleaf
operator|=
name|swap
expr_stmt|;
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|state
operator|->
name|inleaf
operator|=
operator|!
name|swap
expr_stmt|;
else|else
name|state
operator|->
name|inleaf
operator|=
name|swap
operator|^
operator|(
name|args
operator|->
name|hashval
operator|<
name|INT_GET
argument_list|(
name|leaf2
operator|->
name|ents
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Adjust the expected index for insertion. 	 */
if|if
condition|(
operator|!
name|state
operator|->
name|inleaf
condition|)
name|blk2
operator|->
name|index
operator|=
name|blk1
operator|->
name|index
operator|-
name|INT_GET
argument_list|(
name|leaf1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a node directory.  * This removes the leaf entry and the data entry,  * and updates the free block if necessary.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_leafn_remove
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|int
name|index
parameter_list|,
comment|/* leaf entry index */
name|xfs_da_state_blk_t
modifier|*
name|dblk
parameter_list|,
comment|/* data block */
name|int
modifier|*
name|rval
parameter_list|)
comment|/* resulting block needs join */
block|{
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
name|xfs_dir2_db_t
name|db
decl_stmt|;
comment|/* data block number */
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data block entry */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|int
name|longest
decl_stmt|;
comment|/* longest data free entry */
name|int
name|off
decl_stmt|;
comment|/* data block entry offset */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|needlog
decl_stmt|;
comment|/* need to log data header */
name|int
name|needscan
decl_stmt|;
comment|/* need to rescan data frees */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_sb
argument_list|(
literal|"leafn_remove"
argument_list|,
name|args
argument_list|,
name|index
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Point to the entry we're removing. 	 */
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
comment|/* 	 * Extract the data block and offset from the entry. 	 */
name|db
operator|=
name|XFS_DIR2_DATAPTR_TO_DB
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dblk
operator|->
name|blkno
operator|==
name|db
argument_list|)
expr_stmt|;
name|off
operator|=
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dblk
operator|->
name|index
operator|==
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * Kill the leaf entry by marking it stale. 	 * Log the leaf block changes. 	 */
name|INT_MOD
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DIR2_NULL_DATAPTR
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* 	 * Make the data entry free.  Keep track of the longest freespace 	 * in the data block in case it changes. 	 */
name|dbp
operator|=
name|dblk
operator|->
name|bp
expr_stmt|;
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|off
operator|)
expr_stmt|;
name|longest
operator|=
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|needlog
operator|=
name|needscan
operator|=
literal|0
expr_stmt|;
name|xfs_dir2_data_make_free
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
name|off
argument_list|,
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|dep
operator|->
name|namelen
argument_list|)
argument_list|,
operator|&
name|needlog
argument_list|,
operator|&
name|needscan
argument_list|)
expr_stmt|;
comment|/* 	 * Rescan the data block freespaces for bestfree. 	 * Log the data block header if needed. 	 */
if|if
condition|(
name|needscan
condition|)
name|xfs_dir2_data_freescan
argument_list|(
name|mp
argument_list|,
name|data
argument_list|,
operator|&
name|needlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|needlog
condition|)
name|xfs_dir2_data_log_header
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* 	 * If the longest data block freespace changes, need to update 	 * the corresponding freeblock entry. 	 */
if|if
condition|(
name|longest
operator|<
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_dabuf_t
modifier|*
name|fbp
decl_stmt|;
comment|/* freeblock buffer */
name|xfs_dir2_db_t
name|fdb
decl_stmt|;
comment|/* freeblock block number */
name|int
name|findex
decl_stmt|;
comment|/* index in freeblock entries */
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
comment|/* freeblock structure */
name|int
name|logfree
decl_stmt|;
comment|/* need to log free entry */
comment|/* 		 * Convert the data block number to a free block, 		 * read in the free block. 		 */
name|fdb
operator|=
name|XFS_DIR2_DB_TO_FDB
argument_list|(
name|mp
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|fdb
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_MAX_FREE_BESTS
argument_list|(
name|mp
argument_list|)
operator|*
operator|(
name|fdb
operator|-
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate which entry we need to fix. 		 */
name|findex
operator|=
name|XFS_DIR2_DB_TO_FDINDEX
argument_list|(
name|mp
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|longest
operator|=
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 		 * If the data block is now empty we can get rid of it 		 * (usually). 		 */
if|if
condition|(
name|longest
operator|==
name|mp
operator|->
name|m_dirblksize
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|data
operator|->
name|hdr
argument_list|)
condition|)
block|{
comment|/* 			 * Try to punch out the data block. 			 */
name|error
operator|=
name|xfs_dir2_shrink_inode
argument_list|(
name|args
argument_list|,
name|db
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dblk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 			 * We can get ENOSPC if there's no space reservation. 			 * In this case just drop the buffer and some one else 			 * will eventually get rid of the empty block. 			 */
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|&&
name|args
operator|->
name|total
operator|==
literal|0
condition|)
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
else|else
return|return
name|error
return|;
block|}
comment|/* 		 * If we got rid of the data block, we can eliminate that entry 		 * in the free block. 		 */
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * One less used entry in the free table. 			 */
name|INT_MOD
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nused
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir2_free_log_header
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
comment|/* 			 * If this was the last entry in the table, we can 			 * trim the table size back.  There might be other 			 * entries at the end referring to non-existent 			 * data blocks, get those too. 			 */
if|if
condition|(
name|findex
operator|==
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* free entry index */
for|for
control|(
name|i
operator|=
name|findex
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|i
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|NULLDATAOFF
condition|;
name|i
operator|--
control|)
continue|continue;
name|INT_SET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|logfree
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Not the last entry, just punch it out. 			 */
else|else
block|{
name|INT_SET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|NULLDATAOFF
argument_list|)
expr_stmt|;
name|logfree
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * If there are no useful entries left in the block, 			 * get rid of the block if we can. 			 */
if|if
condition|(
name|INT_ISZERO
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nused
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_dir2_shrink_inode
argument_list|(
name|args
argument_list|,
name|fdb
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|fbp
operator|=
name|NULL
expr_stmt|;
name|logfree
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
name|ENOSPC
operator|||
name|args
operator|->
name|total
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 				 * It's possible to get ENOSPC if there is no 				 * space reservation.  In this case some one 				 * else will eventually get rid of this block. 				 */
block|}
block|}
comment|/* 		 * Data block is not empty, just set the free entry to 		 * the new value. 		 */
else|else
block|{
name|INT_SET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|longest
argument_list|)
expr_stmt|;
name|logfree
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Log the free entry that changed, unless we got rid of it. 		 */
if|if
condition|(
name|logfree
condition|)
name|xfs_dir2_free_log_bests
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|,
name|findex
argument_list|,
name|findex
argument_list|)
expr_stmt|;
comment|/* 		 * Drop the buffer if we still have it. 		 */
if|if
condition|(
name|fbp
condition|)
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
block|}
name|xfs_dir2_leafn_check
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Return indication of whether this leaf block is emtpy enough 	 * to justify trying to join it with a neighbor. 	 */
operator|*
name|rval
operator|=
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|hdr
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|ents
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|)
operator|<
name|mp
operator|->
name|m_dir_magicpct
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Split the leaf entries in the old block into old and new blocks.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leafn_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
comment|/* btree cursor */
name|xfs_da_state_blk_t
modifier|*
name|oldblk
parameter_list|,
comment|/* original block */
name|xfs_da_state_blk_t
modifier|*
name|newblk
parameter_list|)
comment|/* newly created block */
block|{
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
comment|/* operation arguments */
name|xfs_dablk_t
name|blkno
decl_stmt|;
comment|/* new leaf block number */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
comment|/* 	 * Allocate space for a new leaf node. 	 */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldblk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Initialize the new leaf block. 	 */
name|error
operator|=
name|xfs_dir2_leaf_init
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_DA_TO_DB
argument_list|(
name|mp
argument_list|,
name|blkno
argument_list|)
argument_list|,
operator|&
name|newblk
operator|->
name|bp
argument_list|,
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|newblk
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|newblk
operator|->
name|magic
operator|=
name|XFS_DIR2_LEAFN_MAGIC
expr_stmt|;
comment|/* 	 * Rebalance the entries across the two leaves, link the new 	 * block into the leaves. 	 */
name|xfs_dir2_leafn_rebalance
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_blk_link
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Insert the new entry in the correct block. 	 */
if|if
condition|(
name|state
operator|->
name|inleaf
condition|)
name|error
operator|=
name|xfs_dir2_leafn_add
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
name|oldblk
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|xfs_dir2_leafn_add
argument_list|(
name|newblk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
name|newblk
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* 	 * Update last hashval in each block since we added the name. 	 */
name|oldblk
operator|->
name|hashval
operator|=
name|xfs_dir2_leafn_lasthash
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newblk
operator|->
name|hashval
operator|=
name|xfs_dir2_leafn_lasthash
argument_list|(
name|newblk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|args
operator|->
name|dp
argument_list|,
name|oldblk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|args
operator|->
name|dp
argument_list|,
name|newblk
operator|->
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Check a leaf block and its neighbors to see if the block should be  * collapsed into one or the other neighbor.  Always keep the block  * with the smaller block number.  * If the current block is over 50% full, don't try to join it, return 0.  * If the block is empty, fill in the state structure and return 2.  * If it can be collapsed, fill in the state structure and return 1.  * If nothing can be done, return 0.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leafn_toosmall
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
comment|/* btree cursor */
name|int
modifier|*
name|action
parameter_list|)
comment|/* resulting action to take */
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
comment|/* leaf block */
name|xfs_dablk_t
name|blkno
decl_stmt|;
comment|/* leaf block number */
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* leaf buffer */
name|int
name|bytes
decl_stmt|;
comment|/* bytes in use */
name|int
name|count
decl_stmt|;
comment|/* leaf live entry count */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|forward
decl_stmt|;
comment|/* sibling block direction */
name|int
name|i
decl_stmt|;
comment|/* sibling counter */
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
comment|/* leaf block header */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|int
name|rval
decl_stmt|;
comment|/* result from path_shift */
comment|/* 	 * Check for the degenerate case of the block being over 50% full. 	 * If so, it's not worth even looking to see if we might be able 	 * to coalesce with a sibling. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_dir2_leaf_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|hdr
argument_list|)
operator|+
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|ents
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
operator|(
name|state
operator|->
name|blocksize
operator|>>
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Blk over 50%, don't try to join. 		 */
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Check for the degenerate case of the block being empty. 	 * If the block is empty, we'll simply delete it, no need to 	 * coalesce it with a sibling block.  We choose (arbitrarily) 	 * to merge with the forward block unless it is NULL. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Make altpath point to the block we want to keep and 		 * path point to the block we want to drop (this one). 		 */
name|forward
operator|=
operator|!
name|INT_ISZERO
argument_list|(
name|info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|action
operator|=
name|rval
condition|?
literal|2
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Examine each sibling block to see if we can coalesce with 	 * at least 25% free space to spare.  We need to figure out 	 * whether to merge with the forward or the backward block. 	 * We prefer coalescing with the lower numbered sibling so as 	 * to shrink a directory over time. 	 */
name|forward
operator|=
name|INT_GET
argument_list|(
name|info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bp
operator|=
name|NULL
init|;
name|i
operator|<
literal|2
condition|;
name|forward
operator|=
operator|!
name|forward
operator|,
name|i
operator|++
control|)
block|{
name|blkno
operator|=
name|forward
condition|?
name|INT_GET
argument_list|(
name|info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
else|:
name|INT_GET
argument_list|(
name|info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Read the sibling leaf block. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Count bytes in the two blocks combined. 		 */
name|leaf
operator|=
operator|(
name|xfs_dir2_leaf_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|state
operator|->
name|blocksize
operator|-
operator|(
name|state
operator|->
name|blocksize
operator|>>
literal|2
operator|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|count
operator|+=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bytes
operator|-=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|ents
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Fits with at least 25% to spare. 		 */
if|if
condition|(
name|bytes
operator|>=
literal|0
condition|)
break|break;
name|xfs_da_brelse
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Didn't like either block, give up. 	 */
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Done with the sibling leaf block here, drop the dabuf 	 * so path_shift can get it. 	 */
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Make altpath point to the block we want to keep (the lower 	 * numbered block) and path point to the block we want to drop. 	 */
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|blk
operator|->
name|blkno
condition|)
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|action
operator|=
name|rval
condition|?
literal|0
else|:
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Move all the leaf entries from drop_blk to save_blk.  * This is done as part of a join operation.  */
end_comment

begin_function
name|void
name|xfs_dir2_leafn_unbalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
comment|/* cursor */
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|,
comment|/* dead block */
name|xfs_da_state_blk_t
modifier|*
name|save_blk
parameter_list|)
comment|/* surviving block */
block|{
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
comment|/* operation arguments */
name|xfs_dir2_leaf_t
modifier|*
name|drop_leaf
decl_stmt|;
comment|/* dead leaf structure */
name|xfs_dir2_leaf_t
modifier|*
name|save_leaf
decl_stmt|;
comment|/* surviving leaf structure */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|save_blk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|drop_leaf
operator|=
name|drop_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|save_leaf
operator|=
name|save_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any stale leaf entries, take this opportunity 	 * to purge them. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|xfs_dir2_leaf_compact
argument_list|(
name|args
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
name|xfs_dir2_leaf_compact
argument_list|(
name|args
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Move the entries from drop to the appropriate end of save. 	 */
name|drop_blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_dir2_leafn_order
argument_list|(
name|save_blk
operator|->
name|bp
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
condition|)
name|xfs_dir2_leafn_moveents
argument_list|(
name|args
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xfs_dir2_leafn_moveents
argument_list|(
name|args
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|INT_GET
argument_list|(
name|drop_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|save_blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|save_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_dir2_leafn_check
argument_list|(
name|args
operator|->
name|dp
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Top-level node form directory addname routine.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_node_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
comment|/* leaf block for insert */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|rval
decl_stmt|;
comment|/* sub-return value */
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
comment|/* btree cursor */
name|xfs_dir2_trace_args
argument_list|(
literal|"node_addname"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the state (btree cursor). 	 */
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
comment|/* 	 * Look up the name.  We're not supposed to find it, but 	 * this gives us the insertion point. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|rval
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|ENOENT
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Add the data entry to a data block. 	 * Extravalid is set to a freeblock found by lookup. 	 */
name|rval
operator|=
name|xfs_dir2_node_addname_int
argument_list|(
name|args
argument_list|,
name|state
operator|->
name|extravalid
condition|?
operator|&
name|state
operator|->
name|extrablk
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Add the new leaf entry. 	 */
name|rval
operator|=
name|xfs_dir2_leafn_add
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
name|blk
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
comment|/* 		 * It worked, fix the hash values up the btree. 		 */
if|if
condition|(
operator|!
name|args
operator|->
name|justcheck
condition|)
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It didn't work, we need to split the leaf block. 		 */
if|if
condition|(
name|args
operator|->
name|total
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|rval
operator|==
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Split the leaf block and insert the new entry. 		 */
name|rval
operator|=
name|xfs_da_split
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Add the data entry for a node-format directory name addition.  * The leaf entry is added in xfs_dir2_leafn_add.  * We may enter with a freespace block that the lookup found.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_node_addname_int
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_da_state_blk_t
modifier|*
name|fblk
parameter_list|)
comment|/* optional freespace block */
block|{
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
name|xfs_dir2_db_t
name|dbno
decl_stmt|;
comment|/* data block number */
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data entry pointer */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
decl_stmt|;
comment|/* data unused entry pointer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_dir2_db_t
name|fbno
decl_stmt|;
comment|/* freespace block number */
name|xfs_dabuf_t
modifier|*
name|fbp
decl_stmt|;
comment|/* freespace buffer */
name|int
name|findex
decl_stmt|;
comment|/* freespace entry index */
name|xfs_dir2_free_t
modifier|*
name|free
init|=
name|NULL
decl_stmt|;
comment|/* freespace block structure */
name|xfs_dir2_db_t
name|ifbno
decl_stmt|;
comment|/* initial freespace block no */
name|xfs_dir2_db_t
name|lastfbno
init|=
literal|0
decl_stmt|;
comment|/* highest freespace block no */
name|int
name|length
decl_stmt|;
comment|/* length of the new entry */
name|int
name|logfree
decl_stmt|;
comment|/* need to log free entry */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|needlog
decl_stmt|;
comment|/* need to log data header */
name|int
name|needscan
decl_stmt|;
comment|/* need to rescan data frees */
name|xfs_dir2_data_off_t
modifier|*
name|tagp
decl_stmt|;
comment|/* data entry tag pointer */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|length
operator|=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
comment|/* 	 * If we came in with a freespace block that means that lookup 	 * found an entry with our hash value.  This is the freespace 	 * block for that data entry. 	 */
if|if
condition|(
name|fblk
condition|)
block|{
name|fbp
operator|=
name|fblk
operator|->
name|bp
expr_stmt|;
comment|/* 		 * Remember initial freespace block number. 		 */
name|ifbno
operator|=
name|fblk
operator|->
name|blkno
expr_stmt|;
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|findex
operator|=
name|fblk
operator|->
name|index
expr_stmt|;
comment|/* 		 * This means the free entry showed that the data block had 		 * space for our entry, so we remembered it. 		 * Use that data block. 		 */
if|if
condition|(
name|findex
operator|>=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|findex
operator|<
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLDATAOFF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|length
argument_list|)
expr_stmt|;
name|dbno
operator|=
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|findex
expr_stmt|;
block|}
comment|/* 		 * The data block looked at didn't have enough room. 		 * We'll start at the beginning of the freespace entries. 		 */
else|else
block|{
name|dbno
operator|=
operator|-
literal|1
expr_stmt|;
name|findex
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Didn't come in with a freespace block, so don't have a data block. 	 */
else|else
block|{
name|ifbno
operator|=
name|dbno
operator|=
operator|-
literal|1
expr_stmt|;
name|fbp
operator|=
name|NULL
expr_stmt|;
name|findex
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we don't have a data block yet, we're going to scan the 	 * freespace blocks looking for one.  Figure out what the 	 * highest freespace block number is. 	 */
if|if
condition|(
name|dbno
operator|==
operator|-
literal|1
condition|)
block|{
name|xfs_fileoff_t
name|fo
decl_stmt|;
comment|/* freespace block number */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|fo
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|lastfbno
operator|=
name|XFS_DIR2_DA_TO_DB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dablk_t
operator|)
name|fo
argument_list|)
expr_stmt|;
name|fbno
operator|=
name|ifbno
expr_stmt|;
block|}
comment|/* 	 * While we haven't identified a data block, search the freeblock 	 * data for a good data block.  If we find a null freeblock entry, 	 * indicating a hole in the data blocks, remember that. 	 */
while|while
condition|(
name|dbno
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * If we don't have a freeblock in hand, get the next one. 		 */
if|if
condition|(
name|fbp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Happens the first time through unless lookup gave 			 * us a freespace block to start with. 			 */
if|if
condition|(
operator|++
name|fbno
operator|==
literal|0
condition|)
name|fbno
operator|=
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 			 * If it's ifbno we already looked at it. 			 */
if|if
condition|(
name|fbno
operator|==
name|ifbno
condition|)
name|fbno
operator|++
expr_stmt|;
comment|/* 			 * If it's off the end we're done. 			 */
if|if
condition|(
name|fbno
operator|>=
name|lastfbno
condition|)
break|break;
comment|/* 			 * Read the block.  There can be holes in the 			 * freespace blocks, so this might not succeed. 			 * This should be really rare, so there's no reason 			 * to avoid it. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|fbno
argument_list|)
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|fbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|fbp
operator|==
name|NULL
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|findex
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Look at the current free entry.  Is it good enough? 		 */
if|if
condition|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLDATAOFF
operator|&&
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|length
condition|)
name|dbno
operator|=
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|findex
expr_stmt|;
else|else
block|{
comment|/* 			 * Are we done with the freeblock? 			 */
if|if
condition|(
operator|++
name|findex
operator|==
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
comment|/* 				 * Drop the block. 				 */
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
name|fbp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fblk
operator|&&
name|fblk
operator|->
name|bp
condition|)
name|fblk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we don't have a data block, we need to allocate one and make 	 * the freespace entries refer to it. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|dbno
operator|==
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* 		 * Not allowed to allocate, return failure. 		 */
if|if
condition|(
name|args
operator|->
name|justcheck
operator|||
name|args
operator|->
name|total
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Drop the freespace buffer unless it came from our 			 * caller. 			 */
if|if
condition|(
operator|(
name|fblk
operator|==
name|NULL
operator|||
name|fblk
operator|->
name|bp
operator|==
name|NULL
operator|)
operator|&&
name|fbp
operator|!=
name|NULL
condition|)
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* 		 * Allocate and initialize the new data block. 		 */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|error
operator|=
name|xfs_dir2_grow_inode
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_DATA_SPACE
argument_list|,
operator|&
name|dbno
argument_list|)
operator|)
operator|||
operator|(
name|error
operator|=
name|xfs_dir2_data_init
argument_list|(
name|args
argument_list|,
name|dbno
argument_list|,
operator|&
name|dbp
argument_list|)
operator|)
argument_list|)
condition|)
block|{
comment|/* 			 * Drop the freespace buffer unless it came from our 			 * caller. 			 */
if|if
condition|(
operator|(
name|fblk
operator|==
name|NULL
operator|||
name|fblk
operator|->
name|bp
operator|==
name|NULL
operator|)
operator|&&
name|fbp
operator|!=
name|NULL
condition|)
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * If (somehow) we have a freespace block, get rid of it. 		 */
if|if
condition|(
name|fbp
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fblk
operator|&&
name|fblk
operator|->
name|bp
condition|)
name|fblk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Get the freespace block corresponding to the data block 		 * that was just allocated. 		 */
name|fbno
operator|=
name|XFS_DIR2_DB_TO_FDB
argument_list|(
name|mp
argument_list|,
name|dbno
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|fbno
argument_list|)
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|fbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * If there wasn't a freespace block, the read will 		 * return a NULL fbp.  Allocate and initialize a new one. 		 */
if|if
condition|(
name|fbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_grow_inode
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_FREE_SPACE
argument_list|,
operator|&
name|fbno
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_DIR2_DB_TO_FDB
argument_list|(
name|mp
argument_list|,
name|dbno
argument_list|)
operator|!=
name|fbno
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"xfs_dir2_node_addname_int: dir ino "
literal|"%llu needed freesp block %lld for\n"
literal|"  data block %lld, got %lld\n"
literal|"  ifbno %llu lastfbno %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dp
operator|->
name|i_ino
argument_list|,
operator|(
name|long
name|long
operator|)
name|XFS_DIR2_DB_TO_FDB
argument_list|(
name|mp
argument_list|,
name|dbno
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|dbno
argument_list|,
operator|(
name|long
name|long
operator|)
name|fbno
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ifbno
argument_list|,
name|lastfbno
argument_list|)
expr_stmt|;
if|if
condition|(
name|fblk
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|" fblk 0x%p blkno %llu "
literal|"index %d magic 0x%x\n"
argument_list|,
name|fblk
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fblk
operator|->
name|blkno
argument_list|,
name|fblk
operator|->
name|index
argument_list|,
name|fblk
operator|->
name|magic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|" ... fblk is NULL\n"
argument_list|)
expr_stmt|;
block|}
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_dir2_node_addname_int"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 			 * Get a buffer for the new block. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|fbno
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|fbp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Initialize the new block to be empty, and remember 			 * its first slot as our empty slot. 			 */
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|INT_SET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|(
name|fbno
operator|-
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
operator|)
operator|*
name|XFS_DIR2_MAX_FREE_BESTS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nused
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set the freespace block index from the data block number. 		 */
name|findex
operator|=
name|XFS_DIR2_DB_TO_FDINDEX
argument_list|(
name|mp
argument_list|,
name|dbno
argument_list|)
expr_stmt|;
comment|/* 		 * If it's after the end of the current entries in the 		 * freespace block, extend that table. 		 */
if|if
condition|(
name|findex
operator|>=
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|findex
operator|<
name|XFS_DIR2_MAX_FREE_BESTS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|findex
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Tag new entry so nused will go up. 			 */
name|INT_SET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|NULLDATAOFF
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this entry was for an empty data block 		 * (this should always be true) then update the header. 		 */
if|if
condition|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|NULLDATAOFF
condition|)
block|{
name|INT_MOD
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nused
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir2_free_log_header
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Update the real value in the table. 		 * We haven't allocated the data entry yet so this will 		 * change again. 		 */
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|INT_COPY
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|logfree
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We had a data block so we don't have to make a new one. 	 */
else|else
block|{
comment|/* 		 * If just checking, we succeeded. 		 */
if|if
condition|(
name|args
operator|->
name|justcheck
condition|)
block|{
if|if
condition|(
operator|(
name|fblk
operator|==
name|NULL
operator|||
name|fblk
operator|->
name|bp
operator|==
name|NULL
operator|)
operator|&&
name|fbp
operator|!=
name|NULL
condition|)
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * Read the data block in. 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|dbno
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|dbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fblk
operator|==
name|NULL
operator|||
name|fblk
operator|->
name|bp
operator|==
name|NULL
operator|)
operator|&&
name|fbp
operator|!=
name|NULL
condition|)
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|logfree
operator|=
literal|0
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * Point to the existing unused space. 	 */
name|dup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
expr_stmt|;
name|needscan
operator|=
name|needlog
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mark the first part of the unused space, inuse for us. 	 */
name|xfs_dir2_data_use_free
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
name|dup
argument_list|,
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|length
argument_list|,
operator|&
name|needlog
argument_list|,
operator|&
name|needscan
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the new entry and log it. 	 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
name|dup
expr_stmt|;
name|INT_SET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|dep
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|memcpy
argument_list|(
name|dep
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|dep
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|tagp
operator|=
name|XFS_DIR2_DATA_ENTRY_TAG_P
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
operator|*
name|tagp
argument_list|,
name|ARCH_CONVERT
argument_list|,
call|(
name|xfs_dir2_data_off_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_entry
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
name|dep
argument_list|)
expr_stmt|;
comment|/* 	 * Rescan the block for bestfree if needed. 	 */
if|if
condition|(
name|needscan
condition|)
name|xfs_dir2_data_freescan
argument_list|(
name|mp
argument_list|,
name|data
argument_list|,
operator|&
name|needlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Log the data block header if needed. 	 */
if|if
condition|(
name|needlog
condition|)
name|xfs_dir2_data_log_header
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* 	 * If the freespace entry is now wrong, update it. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|INT_COPY
argument_list|(
name|free
operator|->
name|bests
index|[
name|findex
index|]
argument_list|,
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|logfree
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Log the freespace entry if needed. 	 */
if|if
condition|(
name|logfree
condition|)
name|xfs_dir2_free_log_bests
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|,
name|findex
argument_list|,
name|findex
argument_list|)
expr_stmt|;
comment|/* 	 * If the caller didn't hand us the freespace block, drop it. 	 */
if|if
condition|(
operator|(
name|fblk
operator|==
name|NULL
operator|||
name|fblk
operator|->
name|bp
operator|==
name|NULL
operator|)
operator|&&
name|fbp
operator|!=
name|NULL
condition|)
name|xfs_da_buf_done
argument_list|(
name|fbp
argument_list|)
expr_stmt|;
comment|/* 	 * Return the data block and offset in args, then drop the data block. 	 */
name|args
operator|->
name|blkno
operator|=
operator|(
name|xfs_dablk_t
operator|)
name|dbno
expr_stmt|;
name|args
operator|->
name|index
operator|=
name|INT_GET
argument_list|(
operator|*
name|tagp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup an entry in a node-format directory.  * All the real work happens in xfs_da_node_lookup_int.  * The only real output is the inode number of the entry.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_node_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* btree level */
name|int
name|rval
decl_stmt|;
comment|/* operation return value */
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
comment|/* btree cursor */
name|xfs_dir2_trace_args
argument_list|(
literal|"node_lookup"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the btree cursor. 	 */
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
comment|/* 	 * Fill in the path to the entry in the cursor. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|rval
operator|=
name|error
expr_stmt|;
comment|/* 	 * Release the btree blocks and leaf block. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|path
operator|.
name|active
condition|;
name|i
operator|++
control|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Release the data block if we have it. 	 */
if|if
condition|(
name|state
operator|->
name|extravalid
operator|&&
name|state
operator|->
name|extrablk
operator|.
name|bp
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|extrablk
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a node-format directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_node_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
comment|/* leaf block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|rval
decl_stmt|;
comment|/* operation return value */
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
comment|/* btree cursor */
name|xfs_dir2_trace_args
argument_list|(
literal|"node_removename"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the btree cursor. 	 */
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
comment|/* 	 * Look up the entry we're deleting, set up the cursor. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|rval
operator|=
name|error
expr_stmt|;
block|}
comment|/* 	 * Didn't find it, upper layer screwed up. 	 */
if|if
condition|(
name|rval
operator|!=
name|EEXIST
condition|)
block|{
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|extravalid
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the leaf and data entries. 	 * Extrablk refers to the data block. 	 */
name|error
operator|=
name|xfs_dir2_leafn_remove
argument_list|(
name|args
argument_list|,
name|blk
operator|->
name|bp
argument_list|,
name|blk
operator|->
name|index
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Fix the hash values up the btree. 	 */
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to join leaf blocks, do it. 	 */
if|if
condition|(
name|rval
operator|&&
name|state
operator|->
name|path
operator|.
name|active
operator|>
literal|1
condition|)
name|error
operator|=
name|xfs_da_join
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* 	 * If no errors so far, try conversion to leaf format. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|xfs_dir2_node_to_leaf
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Replace an entry's inode number in a node-format directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_node_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
comment|/* leaf block */
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data entry changed */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* btree level */
name|xfs_ino_t
name|inum
decl_stmt|;
comment|/* new inode number */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry being changed */
name|int
name|rval
decl_stmt|;
comment|/* internal return value */
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
comment|/* btree cursor */
name|xfs_dir2_trace_args
argument_list|(
literal|"node_replace"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the btree cursor. 	 */
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
name|inum
operator|=
name|args
operator|->
name|inumber
expr_stmt|;
comment|/* 	 * Lookup the entry to change in the btree. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|rval
operator|=
name|error
expr_stmt|;
block|}
comment|/* 	 * It should be found, since the vnodeops layer has looked it up 	 * and locked it.  But paranoia is good. 	 */
if|if
condition|(
name|rval
operator|==
name|EEXIST
condition|)
block|{
comment|/* 		 * Find the leaf entry. 		 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|blk
operator|->
name|index
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|extravalid
argument_list|)
expr_stmt|;
comment|/* 		 * Point to the data entry. 		 */
name|data
operator|=
name|state
operator|->
name|extrablk
operator|.
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
argument_list|)
expr_stmt|;
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|state
operator|->
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|lep
operator|->
name|address
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|inum
operator|!=
name|INT_GET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Fill in the new inode number and log the entry. 		 */
name|INT_SET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_entry
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|extrablk
operator|.
name|bp
argument_list|,
name|dep
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Didn't find it, and we're holding a data block.  Drop it. 	 */
elseif|else
if|if
condition|(
name|state
operator|->
name|extravalid
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|extrablk
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|extrablk
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Release all the buffers in the cursor. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|path
operator|.
name|active
condition|;
name|i
operator|++
control|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Trim off a trailing empty freespace block.  * Return (in rvalp) 1 if we did it, 0 if not.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_node_trim_free
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_fileoff_t
name|fo
parameter_list|,
comment|/* free block number */
name|int
modifier|*
name|rvalp
parameter_list|)
comment|/* out: did something */
block|{
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* freespace buffer */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
comment|/* freespace structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Read the freespace block. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|(
name|xfs_dablk_t
operator|)
name|fo
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * There can be holes in freespace.  If fo is a hole, there's 	 * nothing to do. 	 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|free
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * If there are used entries, there's nothing to do. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nused
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|rvalp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Blow the block away. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_shrink_inode
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_DA_TO_DB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dablk_t
operator|)
name|fo
argument_list|)
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Can't fail with ENOSPC since that only happens with no 		 * space reservation, when breaking up an extent into two 		 * pieces.  This is the last block of an extent. 		 */
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Return that we succeeded. 	 */
operator|*
name|rvalp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

