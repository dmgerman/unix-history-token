begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_function_decl
name|STATIC
name|void
name|xfs_ail_insert
parameter_list|(
name|xfs_ail_entry_t
modifier|*
parameter_list|,
name|xfs_log_item_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xfs_log_item_t
modifier|*
name|xfs_ail_delete
parameter_list|(
name|xfs_ail_entry_t
modifier|*
parameter_list|,
name|xfs_log_item_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xfs_log_item_t
modifier|*
name|xfs_ail_min
parameter_list|(
name|xfs_ail_entry_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xfs_log_item_t
modifier|*
name|xfs_ail_next
parameter_list|(
name|xfs_ail_entry_t
modifier|*
parameter_list|,
name|xfs_log_item_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|STATIC
name|void
name|xfs_ail_check
parameter_list|(
name|xfs_ail_entry_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_ail_check
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * This is called by the log manager code to determine the LSN  * of the tail of the log.  This is exactly the LSN of the first  * item in the AIL.  If the AIL is empty, then this function  * returns 0.  *  * We need the AIL lock in order to get a coherent read of the  * lsn of the last item in the AIL.  */
end_comment

begin_function
name|xfs_lsn_t
name|xfs_trans_tail_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_lsn_t
name|lsn
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|==
name|NULL
condition|)
block|{
name|lsn
operator|=
operator|(
name|xfs_lsn_t
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lsn
operator|=
name|lip
operator|->
name|li_lsn
expr_stmt|;
block|}
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|lsn
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_trans_push_ail  *  * This routine is called to move the tail of the AIL  * forward.  It does this by trying to flush items in the AIL  * whose lsns are below the given threshold_lsn.  *  * The routine returns the lsn of the tail of the log.  */
end_comment

begin_function
name|xfs_lsn_t
name|xfs_trans_push_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_lsn_t
name|threshold_lsn
parameter_list|)
block|{
name|xfs_lsn_t
name|lsn
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|int
name|gen
decl_stmt|;
name|int
name|restarts
decl_stmt|;
name|int
name|lock_result
decl_stmt|;
name|int
name|flush_log
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
define|#
directive|define
name|XFS_TRANS_PUSH_AIL_RESTARTS
value|10
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lip
operator|=
name|xfs_trans_first_ail
argument_list|(
name|mp
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|==
name|NULL
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
comment|/* 		 * Just return if the AIL is empty. 		 */
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|xfs_lsn_t
operator|)
literal|0
return|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail
argument_list|)
expr_stmt|;
comment|/* 	 * While the item we are looking at is below the given threshold 	 * try to flush it out.  Make sure to limit the number of times 	 * we allow xfs_trans_next_ail() to restart scanning from the 	 * beginning of the list.  We'd like not to stop until we've at least 	 * tried to push on everything in the AIL with an LSN less than 	 * the given threshold. However, we may give up before that if 	 * we realize that we've been holding the AIL_LOCK for 'too long', 	 * blocking interrupts. Currently, too long is< 500us roughly. 	 */
name|flush_log
operator|=
literal|0
expr_stmt|;
name|restarts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|restarts
operator|<
name|XFS_TRANS_PUSH_AIL_RESTARTS
operator|)
operator|&&
operator|(
name|XFS_LSN_CMP
argument_list|(
name|lip
operator|->
name|li_lsn
argument_list|,
name|threshold_lsn
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If we can lock the item without sleeping, unlock 		 * the AIL lock and flush the item.  Then re-grab the 		 * AIL lock so we can look for the next item on the 		 * AIL.  Since we unlock the AIL while we flush the 		 * item, the next routine may start over again at the 		 * the beginning of the list if anything has changed. 		 * That is what the generation count is for. 		 * 		 * If we can't lock the item, either its holder will flush 		 * it or it is already being flushed or it is being relogged. 		 * In any of these case it is being taken care of and we 		 * can just skip to the next item in the list. 		 */
name|lock_result
operator|=
name|IOP_TRYLOCK
argument_list|(
name|lip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lock_result
condition|)
block|{
case|case
name|XFS_ITEM_SUCCESS
case|:
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_success
argument_list|)
expr_stmt|;
name|IOP_PUSH
argument_list|(
name|lip
argument_list|)
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ITEM_PUSHBUF
case|:
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_pushbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFSRACEDEBUG
name|delay_for_intr
argument_list|()
expr_stmt|;
name|delay
argument_list|(
literal|300
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|lip
operator|->
name|li_ops
operator|->
name|iop_pushbuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lip
argument_list|)
expr_stmt|;
name|IOP_PUSHBUF
argument_list|(
name|lip
argument_list|)
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ITEM_PINNED
case|:
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_pinned
argument_list|)
expr_stmt|;
name|flush_log
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XFS_ITEM_LOCKED
case|:
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ITEM_FLUSHING
case|:
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_flushing
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|lip
operator|=
name|xfs_trans_next_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
operator|&
name|gen
argument_list|,
operator|&
name|restarts
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
comment|/* 			 * Just return if we shut down during the last try. 			 */
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|xfs_lsn_t
operator|)
literal|0
return|;
block|}
block|}
if|if
condition|(
name|flush_log
condition|)
block|{
comment|/* 		 * If something we need to push out was pinned, then 		 * push out the log so it will become unpinned and 		 * move forward in the AIL. 		 */
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_flush
argument_list|)
expr_stmt|;
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
argument_list|)
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|lip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|==
name|NULL
condition|)
block|{
name|lsn
operator|=
operator|(
name|xfs_lsn_t
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lsn
operator|=
name|lip
operator|->
name|li_lsn
expr_stmt|;
block|}
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|lsn
return|;
block|}
end_function

begin_comment
comment|/* xfs_trans_push_ail */
end_comment

begin_comment
comment|/*  * This is to be called when an item is unlocked that may have  * been in the AIL.  It will wake up the first member of the AIL  * wait list if this item's unlocking might allow it to progress.  * If the item is in the AIL, then we need to get the AIL lock  * while doing our checking so we don't race with someone going  * to sleep waiting for this event in xfs_trans_push_ail().  */
end_comment

begin_function
name|void
name|xfs_trans_unlocked_item
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|min_lip
decl_stmt|;
comment|/* 	 * If we're forcibly shutting down, we may have 	 * unlocked log items arbitrarily. The last thing 	 * we want to do is to move the tail of the log 	 * over some potentially valid data. 	 */
if|if
condition|(
operator|!
operator|(
name|lip
operator|->
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* 	 * This is the one case where we can call into xfs_ail_min() 	 * without holding the AIL lock because we only care about the 	 * case where we are at the tail of the AIL.  If the object isn't 	 * at the tail, it doesn't matter what result we get back.  This 	 * is slightly racy because since we were just unlocked, we could 	 * go to sleep between the call to xfs_ail_min and the call to 	 * xfs_log_move_tail, have someone else lock us, commit to us disk, 	 * move us out of the tail of the AIL, and then we wake up.  However, 	 * the call to xfs_log_move_tail() doesn't do anything if there's 	 * not enough free space to wake people up so we're safe calling it. 	 */
name|min_lip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
name|mp
operator|->
name|m_ail
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_lip
operator|==
name|lip
condition|)
name|xfs_log_move_tail
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xfs_trans_unlocked_item */
end_comment

begin_comment
comment|/*  * Update the position of the item in the AIL with the new  * lsn.  If it is not yet in the AIL, add it.  Otherwise, move  * it to its new position by removing it and re-adding it.  *  * Wakeup anyone with an lsn less than the item's lsn.  If the item  * we move in the AIL is the minimum one, update the tail lsn in the  * log manager.  *  * Increment the AIL's generation count to indicate that the tree  * has changed.  *  * This function must be called with the AIL lock held.  The lock  * is dropped before returning, so the caller must pass in the  * cookie returned by AIL_LOCK.  */
end_comment

begin_function
name|void
name|xfs_trans_update_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|,
name|unsigned
name|long
name|s
parameter_list|)
block|{
name|xfs_ail_entry_t
modifier|*
name|ailp
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|dlip
init|=
name|NULL
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|mlip
decl_stmt|;
comment|/* ptr to minimum lip */
name|ailp
operator|=
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
expr_stmt|;
name|mlip
operator|=
name|xfs_ail_min
argument_list|(
name|ailp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
operator|->
name|li_flags
operator|&
name|XFS_LI_IN_AIL
condition|)
block|{
name|dlip
operator|=
name|xfs_ail_delete
argument_list|(
name|ailp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dlip
operator|==
name|lip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lip
operator|->
name|li_flags
operator||=
name|XFS_LI_IN_AIL
expr_stmt|;
block|}
name|lip
operator|->
name|li_lsn
operator|=
name|lsn
expr_stmt|;
name|xfs_ail_insert
argument_list|(
name|ailp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ail_gen
operator|++
expr_stmt|;
if|if
condition|(
name|mlip
operator|==
name|dlip
condition|)
block|{
name|mlip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|)
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_log_move_tail
argument_list|(
name|mp
argument_list|,
name|mlip
operator|->
name|li_lsn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* xfs_trans_update_ail */
end_comment

begin_comment
comment|/*  * Delete the given item from the AIL.  It must already be in  * the AIL.  *  * Wakeup anyone with an lsn less than item's lsn.    If the item  * we delete in the AIL is the minimum one, update the tail lsn in the  * log manager.  *  * Clear the IN_AIL flag from the item, reset its lsn to 0, and  * bump the AIL's generation count to indicate that the tree  * has changed.  *  * This function must be called with the AIL lock held.  The lock  * is dropped before returning, so the caller must pass in the  * cookie returned by AIL_LOCK.  */
end_comment

begin_function
name|void
name|xfs_trans_delete_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|,
name|unsigned
name|long
name|s
parameter_list|)
block|{
name|xfs_ail_entry_t
modifier|*
name|ailp
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|dlip
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|mlip
decl_stmt|;
if|if
condition|(
name|lip
operator|->
name|li_flags
operator|&
name|XFS_LI_IN_AIL
condition|)
block|{
name|ailp
operator|=
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
expr_stmt|;
name|mlip
operator|=
name|xfs_ail_min
argument_list|(
name|ailp
argument_list|)
expr_stmt|;
name|dlip
operator|=
name|xfs_ail_delete
argument_list|(
name|ailp
argument_list|,
name|lip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dlip
operator|==
name|lip
argument_list|)
expr_stmt|;
name|lip
operator|->
name|li_flags
operator|&=
operator|~
name|XFS_LI_IN_AIL
expr_stmt|;
name|lip
operator|->
name|li_lsn
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_ail_gen
operator|++
expr_stmt|;
if|if
condition|(
name|mlip
operator|==
name|dlip
condition|)
block|{
name|mlip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|)
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_log_move_tail
argument_list|(
name|mp
argument_list|,
operator|(
name|mlip
condition|?
name|mlip
operator|->
name|li_lsn
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If the file system is not being shutdown, we are in 		 * serious trouble if we get to this stage. 		 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_AILDELETE
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_trans_delete_ail: attempting to delete a log item that is not in the AIL"
argument_list|)
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_CORRUPT_INCORE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return the item in the AIL with the smallest lsn.  * Return the current tree generation number for use  * in calls to xfs_trans_next_ail().  */
end_comment

begin_function
name|xfs_log_item_t
modifier|*
name|xfs_trans_first_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|gen
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|lip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|)
expr_stmt|;
operator|*
name|gen
operator|=
operator|(
name|int
operator|)
name|mp
operator|->
name|m_ail_gen
expr_stmt|;
return|return
operator|(
name|lip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the generation count of the tree has not changed since the  * caller last took something from the AIL, then return the elmt  * in the tree which follows the one given.  If the count has changed,  * then return the minimum elmt of the AIL and bump the restarts counter  * if one is given.  */
end_comment

begin_function
name|xfs_log_item_t
modifier|*
name|xfs_trans_next_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|,
name|int
modifier|*
name|gen
parameter_list|,
name|int
modifier|*
name|restarts
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|nlip
decl_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|&&
name|lip
operator|&&
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_ail_gen
operator|==
operator|*
name|gen
condition|)
block|{
name|nlip
operator|=
name|xfs_ail_next
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|,
name|lip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlip
operator|=
name|xfs_ail_min
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
argument_list|)
expr_stmt|;
operator|*
name|gen
operator|=
operator|(
name|int
operator|)
name|mp
operator|->
name|m_ail_gen
expr_stmt|;
if|if
condition|(
name|restarts
operator|!=
name|NULL
condition|)
block|{
name|XFS_STATS_INC
argument_list|(
name|xs_push_ail_restarts
argument_list|)
expr_stmt|;
operator|(
operator|*
name|restarts
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nlip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The active item list (AIL) is a doubly linked list of log  * items sorted by ascending lsn.  The base of the list is  * a forw/back pointer pair embedded in the xfs mount structure.  * The base is initialized with both pointers pointing to the  * base.  This case always needs to be distinguished, because  * the base has no lsn to look at.  We almost always insert  * at the end of the list, so on inserts we search from the  * end of the list to find where the new item belongs.  */
end_comment

begin_comment
comment|/*  * Initialize the doubly linked list to point only to itself.  */
end_comment

begin_function
name|void
name|xfs_trans_ail_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|mp
operator|->
name|m_ail
operator|.
name|ail_forw
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
expr_stmt|;
name|mp
operator|->
name|m_ail
operator|.
name|ail_back
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|&
operator|(
name|mp
operator|->
name|m_ail
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert the given log item into the AIL.  * We almost always insert at the end of the list, so on inserts  * we search from the end of the list to find where the  * new item belongs.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_ail_insert
parameter_list|(
name|xfs_ail_entry_t
modifier|*
name|base
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
comment|/* ARGSUSED */
block|{
name|xfs_log_item_t
modifier|*
name|next_lip
decl_stmt|;
comment|/* 	 * If the list is empty, just insert the item. 	 */
if|if
condition|(
name|base
operator|->
name|ail_back
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
condition|)
block|{
name|base
operator|->
name|ail_forw
operator|=
name|lip
expr_stmt|;
name|base
operator|->
name|ail_back
operator|=
name|lip
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_back
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
expr_stmt|;
return|return;
block|}
name|next_lip
operator|=
name|base
operator|->
name|ail_back
expr_stmt|;
while|while
condition|(
operator|(
name|next_lip
operator|!=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
operator|)
operator|&&
operator|(
name|XFS_LSN_CMP
argument_list|(
name|next_lip
operator|->
name|li_lsn
argument_list|,
name|lip
operator|->
name|li_lsn
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|next_lip
operator|=
name|next_lip
operator|->
name|li_ail
operator|.
name|ail_back
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|next_lip
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
operator|)
operator|||
operator|(
name|XFS_LSN_CMP
argument_list|(
name|next_lip
operator|->
name|li_lsn
argument_list|,
name|lip
operator|->
name|li_lsn
argument_list|)
operator|<=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|=
name|next_lip
operator|->
name|li_ail
operator|.
name|ail_forw
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_back
operator|=
name|next_lip
expr_stmt|;
name|next_lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|=
name|lip
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|->
name|li_ail
operator|.
name|ail_back
operator|=
name|lip
expr_stmt|;
name|xfs_ail_check
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Delete the given item from the AIL.  Return a pointer to the item.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|xfs_log_item_t
modifier|*
name|xfs_ail_delete
parameter_list|(
name|xfs_ail_entry_t
modifier|*
name|base
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
comment|/* ARGSUSED */
block|{
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|->
name|li_ail
operator|.
name|ail_back
operator|=
name|lip
operator|->
name|li_ail
operator|.
name|ail_back
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_back
operator|->
name|li_ail
operator|.
name|ail_forw
operator|=
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|=
name|NULL
expr_stmt|;
name|lip
operator|->
name|li_ail
operator|.
name|ail_back
operator|=
name|NULL
expr_stmt|;
name|xfs_ail_check
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|lip
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the first item in the AIL.  * If the AIL is empty, then return NULL.  */
end_comment

begin_function
name|STATIC
name|xfs_log_item_t
modifier|*
name|xfs_ail_min
parameter_list|(
name|xfs_ail_entry_t
modifier|*
name|base
parameter_list|)
comment|/* ARGSUSED */
block|{
specifier|register
name|xfs_log_item_t
modifier|*
name|forw
init|=
name|base
operator|->
name|ail_forw
decl_stmt|;
if|if
condition|(
name|forw
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|forw
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the item which follows  * the given item in the AIL.  If the given item  * is the last item in the list, then return NULL.  */
end_comment

begin_function
name|STATIC
name|xfs_log_item_t
modifier|*
name|xfs_ail_next
parameter_list|(
name|xfs_ail_entry_t
modifier|*
name|base
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
comment|/* ARGSUSED */
block|{
if|if
condition|(
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Check that the list is sorted as it should be.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_ail_check
parameter_list|(
name|xfs_ail_entry_t
modifier|*
name|base
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|prev_lip
decl_stmt|;
name|lip
operator|=
name|base
operator|->
name|ail_forw
expr_stmt|;
if|if
condition|(
name|lip
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
condition|)
block|{
comment|/* 		 * Make sure the pointers are correct when the list 		 * is empty. 		 */
name|ASSERT
argument_list|(
name|base
operator|->
name|ail_back
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Walk the list checking forward and backward pointers, 	 * lsn ordering, and that every entry has the XFS_LI_IN_AIL 	 * flag set. 	 */
name|prev_lip
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
expr_stmt|;
while|while
condition|(
name|lip
operator|!=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
condition|)
block|{
if|if
condition|(
name|prev_lip
operator|!=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
condition|)
block|{
name|ASSERT
argument_list|(
name|prev_lip
operator|->
name|li_ail
operator|.
name|ail_forw
operator|==
name|lip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_LSN_CMP
argument_list|(
name|prev_lip
operator|->
name|li_lsn
argument_list|,
name|lip
operator|->
name|li_lsn
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|lip
operator|->
name|li_ail
operator|.
name|ail_back
operator|==
name|prev_lip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lip
operator|->
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|prev_lip
operator|=
name|lip
expr_stmt|;
name|lip
operator|=
name|lip
operator|->
name|li_ail
operator|.
name|ail_forw
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|lip
operator|==
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|base
operator|->
name|ail_back
operator|==
name|prev_lip
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

