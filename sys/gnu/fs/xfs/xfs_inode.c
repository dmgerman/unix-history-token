begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_imap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_trace.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_ifork_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_inode_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_chashlist_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Used in xfs_itruncate().  This is the maximum number of extents  * freed from a file in a single transaction.  */
end_comment

begin_define
define|#
directive|define
name|XFS_ITRUNC_MAX_EXTENTS
value|2
end_define

begin_function_decl
name|STATIC
name|int
name|xfs_iflush_int
parameter_list|(
name|xfs_inode_t
modifier|*
parameter_list|,
name|xfs_buf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_iformat_local
parameter_list|(
name|xfs_inode_t
modifier|*
parameter_list|,
name|xfs_dinode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_iformat_extents
parameter_list|(
name|xfs_inode_t
modifier|*
parameter_list|,
name|xfs_dinode_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_iformat_btree
parameter_list|(
name|xfs_inode_t
modifier|*
parameter_list|,
name|xfs_dinode_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Make sure that the extents in the given memory buffer  * are valid.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_validate_extents
parameter_list|(
name|xfs_bmbt_rec_t
modifier|*
name|ep
parameter_list|,
name|int
name|nrecs
parameter_list|,
name|int
name|disk
parameter_list|,
name|xfs_exntfmt_t
name|fmt
parameter_list|)
block|{
name|xfs_bmbt_irec_t
name|irec
decl_stmt|;
name|xfs_bmbt_rec_t
name|rec
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrecs
condition|;
name|i
operator|++
control|)
block|{
name|rec
operator|.
name|l0
operator|=
name|get_unaligned
argument_list|(
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|ep
operator|->
name|l0
argument_list|)
expr_stmt|;
name|rec
operator|.
name|l1
operator|=
name|get_unaligned
argument_list|(
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|ep
operator|->
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
condition|)
name|xfs_bmbt_disk_get_all
argument_list|(
operator|&
name|rec
argument_list|,
operator|&
name|irec
argument_list|)
expr_stmt|;
else|else
name|xfs_bmbt_get_all
argument_list|(
operator|&
name|rec
argument_list|,
operator|&
name|irec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XFS_EXTFMT_NOSTATE
condition|)
name|ASSERT
argument_list|(
name|irec
operator|.
name|br_state
operator|==
name|XFS_EXT_NORM
argument_list|)
expr_stmt|;
name|ep
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_define
define|#
directive|define
name|xfs_validate_extents
parameter_list|(
name|ep
parameter_list|,
name|nrecs
parameter_list|,
name|disk
parameter_list|,
name|fmt
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Check that none of the inode's in the buffer have a next  * unlinked field of 0.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_function
name|void
name|xfs_inobp_check
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|j
operator|=
name|mp
operator|->
name|m_inode_cluster_size
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|i
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_ISZERO
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"Detected a bogus zero next_unlinked field in incore inode buffer 0x%p.  About to pop an ASSERT."
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|INT_ISZERO
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine is called to map an inode number within a file  * system to the buffer containing the on-disk version of the  * inode.  It returns a pointer to the buffer containing the  * on-disk inode in the bpp parameter, and in the dip parameter  * it returns a pointer to the on-disk inode within that buffer.  *  * If a non-zero error is returned, then the contents of bpp and  * dipp are undefined.  *  * Use xfs_imap() to determine the size and location of the  * buffer to read from disk.  */
end_comment

begin_function
name|int
name|xfs_inotobp
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_dinode_t
modifier|*
modifier|*
name|dipp
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|di_ok
decl_stmt|;
name|xfs_imap_t
name|imap
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
comment|/* 	 * Call the space managment code to find the location of the 	 * inode on disk. 	 */
name|imap
operator|.
name|im_blkno
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_imap
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
operator|&
name|imap
argument_list|,
name|XFS_IMAP_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_inotobp: xfs_imap()  returned an "
literal|"error %d on %s.  Returning error."
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * If the inode number maps to a block outside the bounds of the 	 * file system then return NULL rather than calling read_buf 	 * and panicing when we get an error from the driver. 	 */
if|if
condition|(
operator|(
name|imap
operator|.
name|im_blkno
operator|+
name|imap
operator|.
name|im_len
operator|)
operator|>
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_inotobp: inode number (%d + %d) maps to a block outside the bounds "
literal|"of the file system %s.  Returning EINVAL."
argument_list|,
name|imap
operator|.
name|im_blkno
argument_list|,
name|imap
operator|.
name|im_len
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * Read in the buffer.  If tp is NULL, xfs_trans_read_buf() will 	 * default to just a read_buf() call. 	 */
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|imap
operator|.
name|im_blkno
argument_list|,
operator|(
name|int
operator|)
name|imap
operator|.
name|im_len
argument_list|,
name|XFS_BUF_LOCK
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_inotobp: xfs_trans_read_buf()  returned an "
literal|"error %d on %s.  Returning error."
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|di_ok
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DINODE_MAGIC
operator|&&
name|XFS_DINODE_GOOD_VERSION
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|di_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_ITOBP_INOTOBP
argument_list|,
name|XFS_RANDOM_ITOBP_INOTOBP
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_inotobp"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|dip
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_inotobp: XFS_TEST_ERROR()  returned an "
literal|"error on %s.  Returning EFSCORRUPTED."
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Set *dipp to point to the on-disk inode in the buffer. 	 */
operator|*
name|dipp
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|imap
operator|.
name|im_boffset
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
operator|*
name|offset
operator|=
name|imap
operator|.
name|im_boffset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called to map an inode to the buffer containing  * the on-disk version of the inode.  It returns a pointer to the  * buffer containing the on-disk inode in the bpp parameter, and in  * the dip parameter it returns a pointer to the on-disk inode within  * that buffer.  *  * If a non-zero error is returned, then the contents of bpp and  * dipp are undefined.  *  * If the inode is new and has not yet been initialized, use xfs_imap()  * to determine the size and location of the buffer to read from disk.  * If the inode has already been mapped to its buffer and read in once,  * then use the mapping information stored in the inode rather than  * calling xfs_imap().  This allows us to avoid the overhead of looking  * at the inode btree for small block file systems (see xfs_dilocate()).  * We can tell whether the inode has been mapped in before by comparing  * its disk block address to 0.  Only uninitialized inodes will have  * 0 for the disk block address.  */
end_comment

begin_function
name|int
name|xfs_itobp
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_dinode_t
modifier|*
modifier|*
name|dipp
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
name|xfs_daddr_t
name|bno
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_imap_t
name|imap
decl_stmt|;
ifdef|#
directive|ifdef
name|__KERNEL__
name|int
name|i
decl_stmt|;
name|int
name|ni
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|i_blkno
operator|==
operator|(
name|xfs_daddr_t
operator|)
literal|0
condition|)
block|{
comment|/* 		 * Call the space management code to find the location of the 		 * inode on disk. 		 */
name|imap
operator|.
name|im_blkno
operator|=
name|bno
expr_stmt|;
name|error
operator|=
name|xfs_imap
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
operator|&
name|imap
argument_list|,
name|XFS_IMAP_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 		 * If the inode number maps to a block outside the bounds 		 * of the file system then return NULL rather than calling 		 * read_buf and panicing when we get an error from the 		 * driver. 		 */
if|if
condition|(
operator|(
name|imap
operator|.
name|im_blkno
operator|+
name|imap
operator|.
name|im_len
operator|)
operator|>
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_itobp: "
literal|"(imap.im_blkno (0x%llx) "
literal|"+ imap.im_len (0x%llx))> "
literal|" XFS_FSB_TO_BB(mp, "
literal|"mp->m_sb.sb_dblocks) (0x%llx)"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|imap
operator|.
name|im_blkno
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|imap
operator|.
name|im_len
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 		 * Fill in the fields in the inode that will be used to 		 * map the inode to its buffer from now on. 		 */
name|ip
operator|->
name|i_blkno
operator|=
name|imap
operator|.
name|im_blkno
expr_stmt|;
name|ip
operator|->
name|i_len
operator|=
name|imap
operator|.
name|im_len
expr_stmt|;
name|ip
operator|->
name|i_boffset
operator|=
name|imap
operator|.
name|im_boffset
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We've already mapped the inode once, so just use the 		 * mapping that we saved the first time. 		 */
name|imap
operator|.
name|im_blkno
operator|=
name|ip
operator|->
name|i_blkno
expr_stmt|;
name|imap
operator|.
name|im_len
operator|=
name|ip
operator|->
name|i_len
expr_stmt|;
name|imap
operator|.
name|im_boffset
operator|=
name|ip
operator|->
name|i_boffset
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|bno
operator|==
literal|0
operator|||
name|bno
operator|==
name|imap
operator|.
name|im_blkno
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the buffer.  If tp is NULL, xfs_trans_read_buf() will 	 * default to just a read_buf() call. 	 */
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|imap
operator|.
name|im_blkno
argument_list|,
operator|(
name|int
operator|)
name|imap
operator|.
name|im_len
argument_list|,
name|XFS_BUF_LOCK
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_itobp: "
literal|"xfs_trans_read_buf() returned error %d, "
literal|"imap.im_blkno 0x%llx, imap.im_len 0x%llx"
argument_list|,
name|error
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|imap
operator|.
name|im_blkno
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|imap
operator|.
name|im_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|__KERNEL__
comment|/* 	 * Validate the magic number and version of every inode in the buffer 	 * (if DEBUG kernel) or the first inode in the buffer, otherwise. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|ni
operator|=
name|BBTOB
argument_list|(
name|imap
operator|.
name|im_len
argument_list|)
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
expr_stmt|;
else|#
directive|else
name|ni
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
condition|;
name|i
operator|++
control|)
block|{
name|int
name|di_ok
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
operator|(
name|i
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
operator|)
argument_list|)
expr_stmt|;
name|di_ok
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DINODE_MAGIC
operator|&&
name|XFS_DINODE_GOOD_VERSION
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|di_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_ITOBP_INOTOBP
argument_list|,
name|XFS_RANDOM_ITOBP_INOTOBP
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|prdev
argument_list|(
literal|"bad inode magic/vsn daddr %lld #%d (magic=%x)"
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|imap
operator|.
name|im_blkno
argument_list|,
name|i
argument_list|,
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_itobp"
argument_list|,
name|XFS_ERRLEVEL_HIGH
argument_list|,
name|mp
argument_list|,
name|dip
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* __KERNEL__ */
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the buffer as an inode buffer now that it looks good 	 */
name|XFS_BUF_SET_VTYPE
argument_list|(
name|bp
argument_list|,
name|B_FS_INO
argument_list|)
expr_stmt|;
comment|/* 	 * Set *dipp to point to the on-disk inode in the buffer. 	 */
operator|*
name|dipp
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|imap
operator|.
name|im_boffset
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Move inode type and inode format specific information from the  * on-disk inode to the in-core inode.  For fifos, devs, and sockets  * this means set if_rdev to the proper value.  For files, directories,  * and symlinks this means to bring in the in-line data or extent  * pointers.  For a file in B-tree format, only the root is immediately  * brought in-core.  The rest will be in-lined in if_extents when it  * is first referenced (see xfs_iread_extents()).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_iformat
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|)
block|{
name|xfs_attr_shortform_t
modifier|*
name|atp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_fsize_t
name|di_size
decl_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_nextents
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_anextents
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_nblocks
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt dinode %Lu, extent total = %d, nblocks = %Lu."
literal|"  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
call|(
name|int
call|)
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_nextents
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_anextents
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_nblocks
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_forkoff
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
name|ip
operator|->
name|i_mount
operator|->
name|m_sb
operator|.
name|sb_inodesize
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt dinode %Lu, forkoff = 0x%x."
literal|"  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
call|(
name|int
call|)
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_forkoff
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
case|case
name|S_IFSOCK
case|:
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_format
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DINODE_FMT_DEV
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_rdev
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_u
operator|.
name|di_dev
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
case|case
name|S_IFLNK
case|:
case|case
name|S_IFDIR
case|:
switch|switch
condition|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_format
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
comment|/* 			 * no local regular files yet 			 */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_mode
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt inode (local format for regular file) %Lu.  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat(4)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|di_size
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|di_size
operator|>
name|XFS_DFORK_DSIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt inode %Lu (bad size %Ld for local inode).  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
operator|(
name|long
name|long
operator|)
name|di_size
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat(5)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|size
operator|=
operator|(
name|int
operator|)
name|di_size
expr_stmt|;
name|error
operator|=
name|xfs_iformat_local
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|XFS_DATA_FORK
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|error
operator|=
name|xfs_iformat_extents
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|error
operator|=
name|xfs_iformat_btree
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
break|break;
default|default:
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_iformat(6)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
break|break;
default|default:
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_iformat(7)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|XFS_DFORK_Q_ARCH
argument_list|(
name|dip
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
return|return
literal|0
return|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_ifork_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|->
name|if_ext_max
operator|=
name|XFS_IFORK_ASIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_aformat
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
name|atp
operator|=
operator|(
name|xfs_attr_shortform_t
operator|*
operator|)
name|XFS_DFORK_APTR_ARCH
argument_list|(
name|dip
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|atp
operator|->
name|hdr
operator|.
name|totsize
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iformat_local
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|error
operator|=
name|xfs_iformat_extents
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|error
operator|=
name|xfs_iformat_btree
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_ifork_zone
argument_list|,
name|ip
operator|->
name|i_afp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|=
name|NULL
expr_stmt|;
name|xfs_idestroy_fork
argument_list|(
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * The file is in-lined in the on-disk inode.  * If it fits into if_inline_data, then copy  * it there, otherwise allocate a buffer for it  * and copy the data there.  Either way, set  * if_data to point at the data.  * If we allocate a buffer for the data, make  * sure that its size is a multiple of 4 and  * record the real size in i_real_bytes.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_iformat_local
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|,
name|int
name|whichfork
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|int
name|real_size
decl_stmt|;
comment|/* 	 * If the size is unreasonable, then something 	 * is wrong and we just bail out rather than crash in 	 * kmem_alloc() or memcpy() below. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|XFS_DFORK_SIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt inode %Lu (bad size %d for local fork, size = %d).  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
name|size
argument_list|,
name|XFS_DFORK_SIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat_local"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|real_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
sizeof|sizeof
argument_list|(
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
argument_list|)
condition|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
expr_stmt|;
else|else
block|{
name|real_size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|kmem_alloc
argument_list|(
name|real_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_bytes
operator|=
name|size
expr_stmt|;
name|ifp
operator|->
name|if_real_bytes
operator|=
name|real_size
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|XFS_DFORK_PTR_ARCH
argument_list|(
name|dip
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|XFS_IFEXTENTS
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFINLINE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The file consists of a set of extents all  * of which fit into the on-disk inode.  * If there are few enough extents to fit into  * the if_inline_ext, then copy them there.  * Otherwise allocate a buffer for them and copy  * them into it.  Either way, set if_extents  * to point at the extents.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_iformat_extents
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|int
name|nex
decl_stmt|;
name|int
name|real_size
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|nex
operator|=
name|XFS_DFORK_NEXTENTS_ARCH
argument_list|(
name|dip
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|size
operator|=
name|nex
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
comment|/* 	 * If the number of extents is unreasonable, then something 	 * is wrong and we just bail out rather than crash in 	 * kmem_alloc() or memcpy() below. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|XFS_DFORK_SIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt inode %Lu ((a)extents = %d).  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
name|nex
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iformat_extents(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|dip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|real_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nex
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|nex
operator|<=
name|XFS_INLINE_EXTS
condition|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|real_size
operator|=
name|size
expr_stmt|;
block|}
name|ifp
operator|->
name|if_bytes
operator|=
name|size
expr_stmt|;
name|ifp
operator|->
name|if_real_bytes
operator|=
name|real_size
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|dp
operator|=
operator|(
name|xfs_bmbt_rec_t
operator|*
operator|)
name|XFS_DFORK_PTR_ARCH
argument_list|(
name|dip
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_validate_extents
argument_list|(
name|dp
argument_list|,
name|nex
argument_list|,
literal|1
argument_list|,
name|XFS_EXTFMT_INODE
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nex
condition|;
name|i
operator|++
operator|,
name|ep
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|ep
operator|->
name|l0
operator|=
name|INT_GET
argument_list|(
name|get_unaligned
argument_list|(
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|l0
argument_list|)
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ep
operator|->
name|l1
operator|=
name|INT_GET
argument_list|(
name|get_unaligned
argument_list|(
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|l1
argument_list|)
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
name|xfs_bmap_trace_exlist
argument_list|(
literal|"xfs_iformat_extents"
argument_list|,
name|ip
argument_list|,
name|nex
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|whichfork
operator|!=
name|XFS_DATA_FORK
operator|||
name|XFS_EXTFMT_INODE
argument_list|(
name|ip
argument_list|)
operator|==
name|XFS_EXTFMT_NOSTATE
condition|)
if|if
condition|(
name|unlikely
argument_list|(
name|xfs_check_nostate_extents
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|nex
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_iformat_extents(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
block|}
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFEXTENTS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The file has too many extents to fit into  * the inode, so they are in B-tree format.  * Allocate a buffer for the root of the B-tree  * and copy the root into it.  The i_extents  * field will remain NULL until all of the  * extents are read in (when they are needed).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_iformat_btree
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|xfs_bmdr_block_t
modifier|*
name|dfp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* REFERENCED */
name|int
name|nrecs
decl_stmt|;
name|int
name|size
decl_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|dfp
operator|=
operator|(
name|xfs_bmdr_block_t
operator|*
operator|)
name|XFS_DFORK_PTR_ARCH
argument_list|(
name|dip
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|size
operator|=
name|XFS_BMAP_BROOT_SPACE
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
name|nrecs
operator|=
name|XFS_BMAP_BROOT_NUMRECS
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
comment|/* 	 * blow out if -- fork has less extents than can fit in 	 * fork (fork shouldn't be a btree format), root btree 	 * block has more records than can fit into the fork, 	 * or the number of extents is greater than the number of 	 * blocks. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|<=
name|ifp
operator|->
name|if_ext_max
operator|||
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|nrecs
argument_list|)
operator|>
name|XFS_DFORK_SIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|||
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt inode %Lu (btree).  Unmount and run xfs_repair."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_iformat_btree"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|ifp
operator|->
name|if_broot_bytes
operator|=
name|size
expr_stmt|;
name|ifp
operator|->
name|if_broot
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_broot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Copy and convert from the on-disk structure 	 * to the in-memory structure. 	 */
name|xfs_bmdr_to_bmbt
argument_list|(
name|dfp
argument_list|,
name|XFS_DFORK_SIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_broot
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|XFS_IFEXTENTS
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFBROOT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_xlate_dinode_core - translate an xfs_inode_core_t between ondisk  * and native format  *  * buf  = on-disk representation  * dip  = native representation  * dir  = direction - +ve -> disk to native  *                    -ve -> native to disk  * arch = on-disk architecture  */
end_comment

begin_function
name|void
name|xfs_xlate_dinode_core
parameter_list|(
name|xfs_caddr_t
name|buf
parameter_list|,
name|xfs_dinode_core_t
modifier|*
name|dip
parameter_list|,
name|int
name|dir
parameter_list|,
name|xfs_arch_t
name|arch
parameter_list|)
block|{
name|xfs_dinode_core_t
modifier|*
name|buf_core
init|=
operator|(
name|xfs_dinode_core_t
operator|*
operator|)
name|buf
decl_stmt|;
name|xfs_dinode_core_t
modifier|*
name|mem_core
init|=
operator|(
name|xfs_dinode_core_t
operator|*
operator|)
name|dip
decl_stmt|;
name|ASSERT
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|ARCH_NOCONVERT
condition|)
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|mem_core
argument_list|,
operator|(
name|xfs_caddr_t
operator|)
name|buf_core
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|buf_core
argument_list|,
operator|(
name|xfs_caddr_t
operator|)
name|mem_core
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_magic
argument_list|,
name|mem_core
operator|->
name|di_magic
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_mode
argument_list|,
name|mem_core
operator|->
name|di_mode
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_version
argument_list|,
name|mem_core
operator|->
name|di_version
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_format
argument_list|,
name|mem_core
operator|->
name|di_format
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_onlink
argument_list|,
name|mem_core
operator|->
name|di_onlink
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_uid
argument_list|,
name|mem_core
operator|->
name|di_uid
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_gid
argument_list|,
name|mem_core
operator|->
name|di_gid
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_nlink
argument_list|,
name|mem_core
operator|->
name|di_nlink
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_projid
argument_list|,
name|mem_core
operator|->
name|di_projid
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|mem_core
operator|->
name|di_pad
argument_list|,
name|buf_core
operator|->
name|di_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|buf_core
operator|->
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buf_core
operator|->
name|di_pad
argument_list|,
name|mem_core
operator|->
name|di_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|buf_core
operator|->
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_flushiter
argument_list|,
name|mem_core
operator|->
name|di_flushiter
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_atime
operator|.
name|t_sec
argument_list|,
name|mem_core
operator|->
name|di_atime
operator|.
name|t_sec
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_atime
operator|.
name|t_nsec
argument_list|,
name|mem_core
operator|->
name|di_atime
operator|.
name|t_nsec
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_mtime
operator|.
name|t_sec
argument_list|,
name|mem_core
operator|->
name|di_mtime
operator|.
name|t_sec
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_mtime
operator|.
name|t_nsec
argument_list|,
name|mem_core
operator|->
name|di_mtime
operator|.
name|t_nsec
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_ctime
operator|.
name|t_sec
argument_list|,
name|mem_core
operator|->
name|di_ctime
operator|.
name|t_sec
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_ctime
operator|.
name|t_nsec
argument_list|,
name|mem_core
operator|->
name|di_ctime
operator|.
name|t_nsec
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_size
argument_list|,
name|mem_core
operator|->
name|di_size
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_nblocks
argument_list|,
name|mem_core
operator|->
name|di_nblocks
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_extsize
argument_list|,
name|mem_core
operator|->
name|di_extsize
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_nextents
argument_list|,
name|mem_core
operator|->
name|di_nextents
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_anextents
argument_list|,
name|mem_core
operator|->
name|di_anextents
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_forkoff
argument_list|,
name|mem_core
operator|->
name|di_forkoff
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_aformat
argument_list|,
name|mem_core
operator|->
name|di_aformat
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_dmevmask
argument_list|,
name|mem_core
operator|->
name|di_dmevmask
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_dmstate
argument_list|,
name|mem_core
operator|->
name|di_dmstate
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_flags
argument_list|,
name|mem_core
operator|->
name|di_flags
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|INT_XLATE
argument_list|(
name|buf_core
operator|->
name|di_gen
argument_list|,
name|mem_core
operator|->
name|di_gen
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a mount structure and an inode number, return a pointer  * to a newly allocated in-core inode coresponding to the given  * inode number.  *  * Initialize the inode's attributes and extent pointers if it  * already has them (it will not if the inode has no links).  */
end_comment

begin_function
name|int
name|xfs_iread
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|,
name|xfs_daddr_t
name|bno
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|xfs_inode_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_inode_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_ino
operator|=
name|ino
expr_stmt|;
name|ip
operator|->
name|i_mount
operator|=
name|mp
expr_stmt|;
comment|/* 	 * Get pointer's to the on-disk inode and the buffer containing it. 	 * If the inode number refers to a block outside the file system 	 * then xfs_itobp() will return NULL.  In this case we should 	 * return NULL as well.  Set i_blkno to 0 so that xfs_itobp() will 	 * know that this is a new incore inode. 	 */
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|bp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_inode_zone
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Initialize inode's trace buffers. 	 * Do this before xfs_iformat in case it adds entries. 	 */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
name|ip
operator|->
name|i_xtrace
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_BMAP_KTRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_BMBT_TRACE
name|ip
operator|->
name|i_btrace
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_BMBT_KTRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_RW_TRACE
name|ip
operator|->
name|i_rwtrace
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_RW_KTRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_ILOCK_TRACE
name|ip
operator|->
name|i_lock_trace
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_ILOCK_KTRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_DIR2_TRACE
name|ip
operator|->
name|i_dir_trace
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_DIR2_KTRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we got something that isn't an inode it means someone 	 * (nfs or dmi) has a stale handle. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DINODE_MAGIC
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_inode_zone
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iread: "
literal|"dip->di_core.di_magic (0x%x) != "
literal|"XFS_DINODE_MAGIC (0x%x)"
argument_list|,
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|XFS_DINODE_MAGIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * If the on-disk inode is already linked to a directory 	 * entry, copy all of the inode into the in-core inode. 	 * xfs_iformat() handles copying in the inode format 	 * specific information. 	 * Otherwise, just get the truly permanent information. 	 */
if|if
condition|(
operator|!
name|INT_ISZERO
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_mode
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|xfs_xlate_dinode_core
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|dip
operator|->
name|di_core
argument_list|,
operator|&
operator|(
name|ip
operator|->
name|i_d
operator|)
argument_list|,
literal|1
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iformat
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_inode_zone
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iread: "
literal|"xfs_iformat() returned error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|error
return|;
block|}
block|}
else|else
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_magic
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_gen
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_gen
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_flushiter
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_flushiter
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure to pull in the mode here as well in 		 * case the inode is released without being used. 		 * This ensures that xfs_inactive() will see that 		 * the inode is already free and not try to mess 		 * with the uninitialized part of it. 		 */
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Initialize the per-fork minima and maxima for a new 		 * inode here.  xfs_iformat will do it for old inodes. 		 */
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
block|}
comment|/* XXXKAN: initialize i_reclaim */
name|bzero
argument_list|(
operator|&
name|ip
operator|->
name|i_reclaim
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|ip
operator|->
name|i_reclaim
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The inode format changed when we moved the link count and 	 * made it 32 bits long.  If this is an old format inode, 	 * convert it in memory to look like a new one.  If it gets 	 * flushed to disk we will convert back before flushing or 	 * logging it.  We zero out the new projid field and the old link 	 * count field.  We'll handle clearing the pad field (the remains 	 * of the old uuid field) when we actually convert the inode to 	 * the new format. We don't change the version number so that we 	 * can distinguish this from a real new format inode. 	 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_projid
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|->
name|i_delayed_blks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mark the buffer containing the inode as something to keep 	 * around for a while.  This helps to keep recently accessed 	 * meta-data in-core longer. 	 */
name|XFS_BUF_SET_REF
argument_list|(
name|bp
argument_list|,
name|XFS_INO_REF
argument_list|)
expr_stmt|;
comment|/* 	 * Use xfs_trans_brelse() to release the buffer containing the 	 * on-disk inode, because it was acquired with xfs_trans_read_buf() 	 * in xfs_itobp() above.  If tp is NULL, this is just a normal 	 * brelse().  If we're within a transaction, then xfs_trans_brelse() 	 * will only release the buffer if it is not dirty within the 	 * transaction.  It will be OK to release the buffer in this case, 	 * because inodes on disk are never destroyed and we will be 	 * locking the new in-core inode before putting it in the hash 	 * table where other processes can find it.  Thus we don't have 	 * to worry about the inode being changed just because we released 	 * the buffer. 	 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read in extents from a btree-format inode.  * Allocate and fill in if_extents.  Real work is done in xfs_bmap.c.  */
end_comment

begin_function
name|int
name|xfs_iread_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_iread_extents"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|size
operator|=
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
comment|/* 	 * We know that the size is valid (it's checked in iformat_btree) 	 */
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|NULLEXTNUM
expr_stmt|;
name|ifp
operator|->
name|if_bytes
operator|=
name|ifp
operator|->
name|if_real_bytes
operator|=
operator|(
name|int
operator|)
name|size
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFEXTENTS
expr_stmt|;
name|error
operator|=
name|xfs_bmap_read_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_bytes
operator|=
name|ifp
operator|->
name|if_real_bytes
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|XFS_IFEXTENTS
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_validate_extents
argument_list|(
operator|(
name|xfs_bmbt_rec_t
operator|*
operator|)
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_EXTFMT_INODE
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an inode on disk and return a copy of its in-core version.  * The in-core inode is locked exclusively.  Set mode, nlink, and rdev  * appropriately within the inode.  The uid and gid for the inode are  * set according to the contents of the given cred structure.  *  * Use xfs_dialloc() to allocate the on-disk inode. If xfs_dialloc()  * has a free inode available, call xfs_iget()  * to obtain the in-core version of the allocated inode.  Finally,  * fill in the inode and log its initial contents.  In this case,  * ialloc_context would be set to NULL and call_again set to false.  *  * If xfs_dialloc() does not have an available inode,  * it will replenish its supply by doing an allocation. Since we can  * only do one allocation within a transaction without deadlocks, we  * must commit the current transaction before returning the inode itself.  * In this case, therefore, we will set call_again to true and return.  * The caller should then commit the current transaction, start a new  * transaction, and call xfs_ialloc() again to actually get the inode.  *  * To ensure that some other process does not grab the inode that  * was allocated during the first call to xfs_ialloc(), this routine  * also returns the [locked] bp pointing to the head of the freelist  * as ialloc_context.  The caller should hold this buffer across  * the commit and pass it back into this routine on the second call.  */
end_comment

begin_function
name|int
name|xfs_ialloc
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|pip
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|nlink_t
name|nlink
parameter_list|,
name|xfs_dev_t
name|rdev
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|xfs_prid_t
name|prid
parameter_list|,
name|int
name|okalloc
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|ialloc_context
parameter_list|,
name|boolean_t
modifier|*
name|call_again
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|)
block|{
name|xfs_ino_t
name|ino
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|uint
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Call the space management code to pick 	 * the on-disk inode to be allocated. 	 */
name|ASSERT
argument_list|(
name|pip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_dialloc
argument_list|(
name|tp
argument_list|,
name|pip
condition|?
name|pip
operator|->
name|i_ino
else|:
literal|0
argument_list|,
name|mode
argument_list|,
name|okalloc
argument_list|,
name|ialloc_context
argument_list|,
name|call_again
argument_list|,
operator|&
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|*
name|call_again
operator|||
name|ino
operator|==
name|NULLFSINO
condition|)
block|{
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
operator|*
name|ialloc_context
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Get the in-core inode with the lock held exclusively. 	 * This is because we're setting fields here we need 	 * to prevent others from looking at until we're done. 	 */
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|ip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|IFTOVT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|=
operator|(
name|__uint16_t
operator|)
name|mode
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|=
name|nlink
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
name|nlink
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_uid
operator|=
name|curthread
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_gid
operator|=
name|curthread
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_projid
operator|=
name|prid
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the superblock version is up to where we support new format 	 * inodes and this is currently an old format inode, then change 	 * the inode version number now.  This way we only do the conversion 	 * here rather than here and in the flush/logging code. 	 */
if|if
condition|(
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|tp
operator|->
name|t_mountp
operator|->
name|m_sb
argument_list|)
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|=
name|XFS_DINODE_VERSION_2
expr_stmt|;
comment|/* 		 * We've already zeroed the old link count, the projid field, 		 * and the pad field. 		 */
block|}
comment|/* 	 * Project ids won't be stored on disk if we are using a version 1 inode. 	 */
if|if
condition|(
operator|(
name|prid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
operator|)
condition|)
name|xfs_bump_ino_vers2
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_INHERIT_GID
argument_list|(
name|pip
argument_list|,
name|vp
operator|->
name|v_vfsp
argument_list|)
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_gid
operator|=
name|pip
operator|->
name|i_d
operator|.
name|di_gid
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_ISGID
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator||=
name|S_ISGID
expr_stmt|;
block|}
block|}
comment|/* 	 * If the group ID of the new file does not match the effective group 	 * ID or one of the supplementary group IDs, the S_ISGID bit is cleared 	 * (and only if the irix_sgid_inherit compatibility variable is set). 	 */
if|if
condition|(
operator|(
name|irix_sgid_inherit
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_ISGID
operator|)
operator|&&
operator|(
operator|!
name|groupmember
argument_list|(
operator|(
name|gid_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_gid
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_CHG
operator||
name|XFS_ICHGTIME_ACC
operator||
name|XFS_ICHGTIME_MOD
argument_list|)
expr_stmt|;
comment|/* 	 * di_gen will have been taken care of in xfs_iread. 	 */
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_dmevmask
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_dmstate
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
case|case
name|S_IFSOCK
case|:
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|XFS_DINODE_FMT_DEV
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_rdev
operator|=
name|rdev
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|XFS_ILOG_DEV
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
case|case
name|S_IFDIR
case|:
if|if
condition|(
name|pip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
operator|(
name|XFS_DIFLAG_NOATIME
operator||
name|XFS_DIFLAG_NODUMP
operator||
name|XFS_DIFLAG_SYNC
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_NOATIME
operator|)
operator|&&
name|xfs_inherit_noatime
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator||=
name|XFS_DIFLAG_NOATIME
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_NODUMP
operator|)
operator|&&
name|xfs_inherit_nodump
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator||=
name|XFS_DIFLAG_NODUMP
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_SYNC
operator|)
operator|&&
name|xfs_inherit_sync
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator||=
name|XFS_DIFLAG_SYNC
expr_stmt|;
block|}
case|case
name|S_IFLNK
case|:
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|=
name|XFS_IFEXTENTS
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_real_bytes
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_extents
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Attribute fork settings for new inode. 	 */
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Log the new values stuffed into the inode. 	 */
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* now that we have a v_type we can set Linux inode ops (& unlock) */
name|XVFS_INIT_VNODE
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check to make sure that there are no blocks allocated to the  * file beyond the size of the file.  We don't check this for  * files with fixed size extents or real time extents, but we  * at least do it for regular files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|xfs_isize_check
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_fsize_t
name|isize
parameter_list|)
block|{
name|xfs_fileoff_t
name|map_first
decl_stmt|;
name|int
name|nimaps
decl_stmt|;
name|xfs_bmbt_irec_t
name|imaps
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
return|return;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
condition|)
return|return;
name|nimaps
operator|=
literal|2
expr_stmt|;
name|map_first
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|isize
argument_list|)
expr_stmt|;
comment|/* 	 * The filesystem could be shutting down, so bmapi may return 	 * an error. 	 */
if|if
condition|(
name|xfs_bmapi
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
name|map_first
argument_list|,
operator|(
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
argument_list|)
operator|-
name|map_first
operator|)
argument_list|,
name|XFS_BMAPI_ENTIRE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|imaps
argument_list|,
operator|&
name|nimaps
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|nimaps
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|imaps
index|[
literal|0
index|]
operator|.
name|br_startblock
operator|==
name|HOLESTARTBLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Calculate the last possible buffered byte in a file.  This must  * include data that was buffered beyond the EOF by the write code.  * This also needs to deal with overflowing the xfs_fsize_t type  * which can happen for sizes near the limit.  *  * We also need to take into account any blocks beyond the EOF.  It  * may be the case that they were buffered by a write which failed.  * In that case the pages will still be in memory, but the inode size  * will never have been updated.  */
end_comment

begin_function
name|xfs_fsize_t
name|xfs_file_last_byte
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_fsize_t
name|last_byte
decl_stmt|;
name|xfs_fileoff_t
name|last_block
decl_stmt|;
name|xfs_fileoff_t
name|size_last_block
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_iolock
operator|)
argument_list|,
name|MR_UPDATE
operator||
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * Only check for blocks beyond the EOF if the extents have 	 * been read in.  This eliminates the need for the inode lock, 	 * and it also saves us from looking when it really isn't 	 * necessary. 	 */
if|if
condition|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFEXTENTS
condition|)
block|{
name|error
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
operator|&
name|last_block
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|last_block
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_block
operator|=
literal|0
expr_stmt|;
block|}
name|size_last_block
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|last_block
operator|=
name|XFS_FILEOFF_MAX
argument_list|(
name|last_block
argument_list|,
name|size_last_block
argument_list|)
expr_stmt|;
name|last_byte
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|last_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_byte
operator|<
literal|0
condition|)
block|{
return|return
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
return|;
block|}
name|last_byte
operator|+=
operator|(
literal|1
operator|<<
name|mp
operator|->
name|m_writeio_log
operator|)
expr_stmt|;
if|if
condition|(
name|last_byte
operator|<
literal|0
condition|)
block|{
return|return
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
return|;
block|}
return|return
name|last_byte
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_RW_TRACE
argument_list|)
end_if

begin_function
name|STATIC
name|void
name|xfs_itrunc_trace
parameter_list|(
name|int
name|tag
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|flag
parameter_list|,
name|xfs_fsize_t
name|new_size
parameter_list|,
name|xfs_off_t
name|toss_start
parameter_list|,
name|xfs_off_t
name|toss_finish
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_rwtrace
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|ktrace_enter
argument_list|(
name|ip
operator|->
name|i_rwtrace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|tag
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|flag
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|new_size
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|new_size
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|toss_start
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|toss_start
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|toss_finish
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|toss_finish
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|current_cpu
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_itrunc_trace
parameter_list|(
name|tag
parameter_list|,
name|ip
parameter_list|,
name|flag
parameter_list|,
name|new_size
parameter_list|,
name|toss_start
parameter_list|,
name|toss_finish
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Start the truncation of the file to new_size.  The new size  * must be smaller than the current size.  This routine will  * clear the buffer and page caches of file data in the removed  * range, and xfs_itruncate_finish() will remove the underlying  * disk blocks.  *  * The inode must have its I/O lock locked EXCLUSIVELY, and it  * must NOT have the inode lock held at all.  This is because we're  * calling into the buffer/page cache code and we can't hold the  * inode lock when we do so.  *  * The flags parameter can have either the value XFS_ITRUNC_DEFINITE  * or XFS_ITRUNC_MAYBE.  The XFS_ITRUNC_MAYBE value should be used  * in the case that the caller is locking things out of order and  * may not be able to call xfs_itruncate_finish() with the inode lock  * held without dropping the I/O lock.  If the caller must drop the  * I/O lock before calling xfs_itruncate_finish(), then xfs_itruncate_start()  * must be called again with all the same restrictions as the initial  * call.  */
end_comment

begin_function
name|void
name|xfs_itruncate_start
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|flags
parameter_list|,
name|xfs_fsize_t
name|new_size
parameter_list|)
block|{
name|xfs_fsize_t
name|last_byte
decl_stmt|;
name|xfs_off_t
name|toss_start
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|new_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|new_size
operator|<=
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|flags
operator|==
name|XFS_ITRUNC_DEFINITE
operator|)
operator|||
operator|(
name|flags
operator|==
name|XFS_ITRUNC_MAYBE
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Call VOP_TOSS_PAGES() or VOP_FLUSHINVAL_PAGES() to get rid of pages and buffers 	 * overlapping the region being removed.  We have to use 	 * the less efficient VOP_FLUSHINVAL_PAGES() in the case that the 	 * caller may not be able to finish the truncate without 	 * dropping the inode's I/O lock.  Make sure 	 * to catch any pages brought in by buffers overlapping 	 * the EOF by searching out beyond the isize by our 	 * block size. We round new_size up to a block boundary 	 * so that we don't toss things on the same block as 	 * new_size but before it. 	 * 	 * Before calling VOP_TOSS_PAGES() or VOP_FLUSHINVAL_PAGES(), make sure to 	 * call remapf() over the same region if the file is mapped. 	 * This frees up mapped file references to the pages in the 	 * given range and for the VOP_FLUSHINVAL_PAGES() case it ensures 	 * that we get the latest mapped changes flushed out. 	 */
name|toss_start
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|new_size
argument_list|)
expr_stmt|;
name|toss_start
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|toss_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|toss_start
operator|<
literal|0
condition|)
block|{
comment|/* 		 * The place to start tossing is beyond our maximum 		 * file size, so there is no way that the data extended 		 * out there. 		 */
return|return;
block|}
name|last_byte
operator|=
name|xfs_file_last_byte
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_itrunc_trace
argument_list|(
name|XFS_ITRUNC_START
argument_list|,
name|ip
argument_list|,
name|flags
argument_list|,
name|new_size
argument_list|,
name|toss_start
argument_list|,
name|last_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_byte
operator|>
name|toss_start
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_ITRUNC_DEFINITE
condition|)
block|{
name|XVOP_TOSS_PAGES
argument_list|(
name|vp
argument_list|,
name|toss_start
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XVOP_FLUSHINVAL_PAGES
argument_list|(
name|vp
argument_list|,
name|toss_start
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|new_size
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|VN_CACHED
argument_list|(
name|vp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Shrink the file to the given new_size.  The new  * size must be smaller than the current size.  * This will free up the underlying blocks  * in the removed range after a call to xfs_itruncate_start()  * or xfs_atruncate_start().  *  * The transaction passed to this routine must have made  * a permanent log reservation of at least XFS_ITRUNCATE_LOG_RES.  * This routine may commit the given transaction and  * start new ones, so make sure everything involved in  * the transaction is tidy before calling here.  * Some transaction will be returned to the caller to be  * committed.  The incoming transaction must already include  * the inode, and both inode locks must be held exclusively.  * The inode must also be "held" within the transaction.  On  * return the inode will be "held" within the returned transaction.  * This routine does NOT require any disk space to be reserved  * for it within the transaction.  *  * The fork parameter must be either xfs_attr_fork or xfs_data_fork,  * and it indicates the fork which is to be truncated.  For the  * attribute fork we only support truncation to size 0.  *  * We use the sync parameter to indicate whether or not the first  * transaction we perform might have to be synchronous.  For the attr fork,  * it needs to be so if the unlink of the inode is not yet known to be  * permanent in the log.  This keeps us from freeing and reusing the  * blocks of the attribute fork before the unlink of the inode becomes  * permanent.  *  * For the data fork, we normally have to run synchronously if we're  * being called out of the inactive path or we're being called  * out of the create path where we're truncating an existing file.  * Either way, the truncate needs to be sync so blocks don't reappear  * in the file with altered data in case of a crash.  wsync filesystems  * can run the first case async because anything that shrinks the inode  * has to run sync so by the time we're called here from inactive, the  * inode size is permanently set to 0.  *  * Calls from the truncate path always need to be sync unless we're  * in a wsync filesystem and the file has already been unlinked.  *  * The caller is responsible for correctly setting the sync parameter.  * It gets too hard for us to guess here which path we're being called  * out of just based on inode state.  */
end_comment

begin_function
name|int
name|xfs_itruncate_finish
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_fsize_t
name|new_size
parameter_list|,
name|int
name|fork
parameter_list|,
name|int
name|sync
parameter_list|)
block|{
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|xfs_fileoff_t
name|first_unmap_block
decl_stmt|;
name|xfs_fileoff_t
name|last_block
decl_stmt|;
name|xfs_filblks_t
name|unmap_len
init|=
literal|0
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|ntp
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|new_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|new_size
operator|<=
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|*
name|tp
operator|)
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
operator|*
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_flags
operator|&
name|XFS_ILI_HOLD
argument_list|)
expr_stmt|;
name|ntp
operator|=
operator|*
name|tp
expr_stmt|;
name|mp
operator|=
operator|(
name|ntp
operator|)
operator|->
name|t_mountp
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_NOT_DQATTACHED
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We only support truncating the entire attribute fork. 	 */
if|if
condition|(
name|fork
operator|==
name|XFS_ATTR_FORK
condition|)
block|{
name|new_size
operator|=
literal|0LL
expr_stmt|;
block|}
name|first_unmap_block
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|new_size
argument_list|)
expr_stmt|;
name|xfs_itrunc_trace
argument_list|(
name|XFS_ITRUNC_FINISH1
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The first thing we do is set the size to new_size permanently 	 * on disk.  This way we don't have to worry about anyone ever 	 * being able to look at the data being freed even in the face 	 * of a crash.  What we're getting around here is the case where 	 * we free a block, it is allocated to another file, it is written 	 * to, and then we crash.  If the new data gets written to the 	 * file but the log buffers containing the free and reallocation 	 * don't, then we'd end up with garbage in the blocks being freed. 	 * As long as we make the new_size permanent before actually 	 * freeing any blocks it doesn't matter if they get writtten to. 	 * 	 * The callers must signal into us whether or not the size 	 * setting here must be synchronous.  There are a few cases 	 * where it doesn't have to be synchronous.  Those cases 	 * occur if the file is unlinked and we know the unlink is 	 * permanent or if the blocks being truncated are guaranteed 	 * to be beyond the inode eof (regardless of the link count) 	 * and the eof value is permanent.  Both of these cases occur 	 * only on wsync-mounted filesystems.  In those cases, we're 	 * guaranteed that no user will ever see the data in the blocks 	 * that are being truncated so the truncate can run async. 	 * In the free beyond eof case, the file may wind up with 	 * more blocks allocated to it than it needs if we crash 	 * and that won't get fixed until the next time the file 	 * is re-opened and closed but that's ok as that shouldn't 	 * be too many blocks. 	 * 	 * However, we can't just make all wsync xactions run async 	 * because there's one call out of the create path that needs 	 * to run sync where it's truncating an existing file to size 	 * 0 whose size is> 0. 	 * 	 * It's probably possible to come up with a test in this 	 * routine that would correctly distinguish all the above 	 * cases from the values of the function parameters and the 	 * inode state but for sanity's sake, I've decided to let the 	 * layers above just tell us.  It's simpler to correctly figure 	 * out in the layer above exactly under what conditions we 	 * can run async and I think it's easier for others read and 	 * follow the logic in case something has to be changed. 	 * cscope is your friend -- rcc. 	 * 	 * The attribute fork is much simpler. 	 * 	 * For the attribute fork we allow the caller to tell us whether 	 * the unlink of the inode that led to this call is yet permanent 	 * in the on disk log.  If it is not and we will be freeing extents 	 * in this inode then we make the first transaction synchronous 	 * to make sure that the unlink is permanent by the time we free 	 * the blocks. 	 */
if|if
condition|(
name|fork
operator|==
name|XFS_DATA_FORK
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|new_size
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sync
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
condition|)
name|xfs_trans_set_sync
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|fork
operator|==
name|XFS_DATA_FORK
operator|||
operator|(
name|fork
operator|==
name|XFS_ATTR_FORK
operator|&&
operator|(
operator|(
name|sync
operator|&&
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
operator|)
operator|||
operator|(
name|sync
operator|==
literal|0
operator|&&
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Since it is possible for space to become allocated beyond 	 * the end of the file (in a crash where the space is allocated 	 * but the inode size is not yet updated), simply remove any 	 * blocks which show up between the new EOF and the maximum 	 * possible file size.  If the first block to be removed is 	 * beyond the maximum file size (ie it is the same as last_block), 	 * then there is nothing to do. 	 */
name|last_block
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|first_unmap_block
operator|<=
name|last_block
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_block
operator|==
name|first_unmap_block
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|unmap_len
operator|=
name|last_block
operator|-
name|first_unmap_block
operator|+
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
comment|/* 		 * Free up up to XFS_ITRUNC_MAX_EXTENTS.  xfs_bunmapi() 		 * will tell us whether it freed the entire range or 		 * not.  If this is a synchronous mount (wsync), 		 * then we can tell bunmapi to keep all the 		 * transactions asynchronous since the unlink 		 * transaction that made this inode inactive has 		 * already hit the disk.  There's no danger of 		 * the freed blocks being reused, there being a 		 * crash, and the reused blocks suddenly reappearing 		 * in this file with garbage in them once recovery 		 * runs. 		 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bunmapi
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|first_unmap_block
argument_list|,
name|unmap_len
argument_list|,
name|XFS_BMAPI_AFLAG
argument_list|(
name|fork
argument_list|)
operator||
operator|(
name|sync
condition|?
literal|0
else|:
name|XFS_BMAPI_ASYNC
operator|)
argument_list|,
name|XFS_ITRUNC_MAX_EXTENTS
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * If the bunmapi call encounters an error, 			 * return to the caller where the transaction 			 * can be properly aborted.  We just need to 			 * make sure we're not holding any resources 			 * that we were not when we came in. 			 */
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * Duplicate the transaction that has the permanent 		 * reservation and commit the old transaction. 		 */
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
name|ntp
operator|=
operator|*
name|tp
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * If the bmap finish call encounters an error, 			 * return to the caller where the transaction 			 * can be properly aborted.  We just need to 			 * make sure we're not holding any resources 			 * that we were not when we came in. 			 * 			 * Aborting from this point might lose some 			 * blocks in the file system, but oh well. 			 */
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|committed
condition|)
block|{
comment|/* 				 * If the passed in transaction committed 				 * in xfs_bmap_finish(), then we want to 				 * add the inode to this one before returning. 				 * This keeps things simple for the higher 				 * level code, because it always knows that 				 * the inode is locked and held in the 				 * transaction that returns to it whether 				 * errors occur or not.  We don't mark the 				 * inode dirty so that this transaction can 				 * be easily aborted if possible. 				 */
name|xfs_trans_ijoin
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
if|if
condition|(
name|committed
condition|)
block|{
comment|/* 			 * The first xact was committed, 			 * so add the inode to the new one. 			 * Mark it dirty so it will be logged 			 * and moved forward in the log as 			 * part of every commit. 			 */
name|xfs_trans_ijoin
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
name|ntp
operator|=
name|xfs_trans_dup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_trans_commit
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|ntp
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|ntp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
expr_stmt|;
comment|/* 		 * Add the inode being truncated to the next chained 		 * transaction. 		 */
name|xfs_trans_ijoin
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Only update the size in the case of the data fork, but 	 * always re-log the inode so that our permanent transaction 	 * can keep on rolling it forward in the log. 	 */
if|if
condition|(
name|fork
operator|==
name|XFS_DATA_FORK
condition|)
block|{
name|xfs_isize_check
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|new_size
expr_stmt|;
block|}
name|xfs_trans_log_inode
argument_list|(
name|ntp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|new_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fork
operator|==
name|XFS_ATTR_FORK
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_delayed_blks
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|new_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fork
operator|==
name|XFS_ATTR_FORK
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|xfs_itrunc_trace
argument_list|(
name|XFS_ITRUNC_FINISH2
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_igrow_start  *  * Do the first part of growing a file: zero any data in the last  * block that is beyond the old EOF.  We need to do this before  * the inode is joined to the transaction to modify the i_size.  * That way we can drop the inode lock and call into the buffer  * cache to get the buffer mapping the EOF.  */
end_comment

begin_function
name|int
name|xfs_igrow_start
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_fsize_t
name|new_size
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_fsize_t
name|isize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_lock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_iolock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_size
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|isize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
comment|/* 	 * Zero any pages that may have been created by 	 * xfs_write_file() beyond the end of the file 	 * and any blocks between the old and new file sizes. 	 */
name|error
operator|=
name|xfs_zero_eof
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|new_size
argument_list|,
name|isize
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_igrow_finish  *  * This routine is called to extend the size of a file.  * The inode must have both the iolock and the ilock locked  * for update and it must be a part of the current transaction.  * The xfs_igrow_start() function must have been called previously.  * If the change_flag is not zero, the inode change timestamp will  * be updated.  */
end_comment

begin_function
name|void
name|xfs_igrow_finish
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_fsize_t
name|new_size
parameter_list|,
name|int
name|change_flag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_lock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_iolock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_size
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
comment|/* 	 * Update the file size.  Update the inode change timestamp 	 * if change_flag set. 	 */
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|new_size
expr_stmt|;
if|if
condition|(
name|change_flag
condition|)
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when the inode's link count goes to 0.  * We place the on-disk inode on a list in the AGI.  It  * will be pulled from this list when the inode is freed.  */
end_comment

begin_function
name|int
name|xfs_iunlink
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|agibp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|ibp
decl_stmt|;
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|xfs_daddr_t
name|agdaddr
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|short
name|bucket_index
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|agi_ok
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|agno
operator|=
name|XFS_INO_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|agdaddr
operator|=
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the agi buffer first.  It ensures lock ordering 	 * on the list. 	 */
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|agdaddr
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|agibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Validate the magic number of the agi block. 	 */
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
name|agi_ok
operator|=
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_magicnum
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_AGI_MAGIC
operator|&&
name|XFS_AGI_GOOD_VERSION
argument_list|(
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_versionnum
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|agi_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IUNLINK
argument_list|,
name|XFS_RANDOM_IUNLINK
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iunlink"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|agi
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|agibp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Get the index into the agi hash table for the 	 * list this inode will go on. 	 */
name|agino
operator|=
name|XFS_INO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bucket_index
operator|=
name|agino
operator|%
name|XFS_AGI_UNLINKED_BUCKETS
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|INT_ISZERO
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|agino
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLAGINO
condition|)
block|{
comment|/* 		 * There is already another inode in the bucket we need 		 * to add ourselves to.  Add us at the front of the list. 		 * Here we put the head pointer into our next pointer, 		 * and then we fall through to point the head at us. 		 */
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|ibp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|NULLAGINO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|INT_ISZERO
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* both on-disk, don't endian flip twice */
name|dip
operator|->
name|di_next_unlinked
operator|=
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
expr_stmt|;
name|offset
operator|=
name|ip
operator|->
name|i_boffset
operator|+
name|offsetof
argument_list|(
name|xfs_dinode_t
argument_list|,
name|di_next_unlinked
argument_list|)
expr_stmt|;
name|xfs_trans_inode_buf
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point the bucket head pointer at the inode being inserted. 	 */
name|ASSERT
argument_list|(
name|agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|agino
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offsetof
argument_list|(
name|xfs_agi_t
argument_list|,
name|agi_unlinked
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|*
name|bucket_index
operator|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|agibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pull the on-disk inode from the AGI unlinked list.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_iunlink_remove
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_ino_t
name|next_ino
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|agibp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|ibp
decl_stmt|;
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|xfs_daddr_t
name|agdaddr
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|xfs_agino_t
name|next_agino
decl_stmt|;
name|xfs_buf_t
modifier|*
name|last_ibp
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|last_dip
decl_stmt|;
name|short
name|bucket_index
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|last_offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|agi_ok
decl_stmt|;
comment|/* 	 * First pull the on-disk inode from the AGI unlinked list. 	 */
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|agno
operator|=
name|XFS_INO_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|agdaddr
operator|=
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the agi buffer first.  It ensures lock ordering 	 * on the list. 	 */
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|agdaddr
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|agibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_iunlink_remove: xfs_trans_read_buf()  returned an error %d on %s.  Returning error."
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Validate the magic number of the agi block. 	 */
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
name|agi_ok
operator|=
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_magicnum
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_AGI_MAGIC
operator|&&
name|XFS_AGI_GOOD_VERSION
argument_list|(
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_versionnum
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|agi_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IUNLINK_REMOVE
argument_list|,
name|XFS_RANDOM_IUNLINK_REMOVE
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_iunlink_remove"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|agi
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|agibp
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_iunlink_remove: XFS_TEST_ERROR()  returned an error on %s.  Returning EFSCORRUPTED."
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Get the index into the agi hash table for the 	 * list this inode will go on. 	 */
name|agino
operator|=
name|XFS_INO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bucket_index
operator|=
name|agino
operator|%
name|XFS_AGI_UNLINKED_BUCKETS
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLAGINO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|INT_ISZERO
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|agino
condition|)
block|{
comment|/* 		 * We're at the head of the list.  Get the inode's 		 * on-disk buffer to see if there is anyone after us 		 * on the list.  Only modify our next pointer if it 		 * is not already NULLAGINO.  This saves us the overhead 		 * of dealing with the buffer when there is no need to 		 * change it. 		 */
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|ibp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_iunlink_remove: xfs_itobp()  returned an error %d on %s.  Returning error."
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|next_agino
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_agino
operator|!=
name|NULLAGINO
condition|)
block|{
name|INT_SET
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|NULLAGINO
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ip
operator|->
name|i_boffset
operator|+
name|offsetof
argument_list|(
name|xfs_dinode_t
argument_list|,
name|di_next_unlinked
argument_list|)
expr_stmt|;
name|xfs_trans_inode_buf
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Point the bucket head pointer at the next inode. 		 */
name|ASSERT
argument_list|(
name|next_agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
name|agino
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|next_agino
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offsetof
argument_list|(
name|xfs_agi_t
argument_list|,
name|agi_unlinked
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|*
name|bucket_index
operator|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|agibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We need to search the list for the inode being freed. 		 */
name|next_agino
operator|=
name|INT_GET
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket_index
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|last_ibp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next_agino
operator|!=
name|agino
condition|)
block|{
comment|/* 			 * If the last inode wasn't the one pointing to 			 * us, then release its buffer since we're not 			 * going to do anything with it. 			 */
if|if
condition|(
name|last_ibp
operator|!=
name|NULL
condition|)
block|{
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|last_ibp
argument_list|)
expr_stmt|;
block|}
name|next_ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|next_agino
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_inotobp
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|next_ino
argument_list|,
operator|&
name|last_dip
argument_list|,
operator|&
name|last_ibp
argument_list|,
operator|&
name|last_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_iunlink_remove: xfs_inotobp()  returned an error %d on %s.  Returning error."
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|next_agino
operator|=
name|INT_GET
argument_list|(
name|last_dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
name|NULLAGINO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now last_ibp points to the buffer previous to us on 		 * the unlinked list.  Pull us from the list. 		 */
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|ibp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_iunlink_remove: xfs_itobp()  returned an error %d on %s.  Returning error."
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|next_agino
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
name|agino
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_agino
operator|!=
name|NULLAGINO
condition|)
block|{
name|INT_SET
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|NULLAGINO
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ip
operator|->
name|i_boffset
operator|+
name|offsetof
argument_list|(
name|xfs_dinode_t
argument_list|,
name|di_next_unlinked
argument_list|)
expr_stmt|;
name|xfs_trans_inode_buf
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|ibp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Point the previous inode on the list to the next inode. 		 */
name|INT_SET
argument_list|(
name|last_dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|next_agino
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next_agino
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|last_offset
operator|+
name|offsetof
argument_list|(
name|xfs_dinode_t
argument_list|,
name|di_next_unlinked
argument_list|)
expr_stmt|;
name|xfs_trans_inode_buf
argument_list|(
name|tp
argument_list|,
name|last_ibp
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|last_ibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|last_ibp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline__
name|int
name|xfs_inode_clean
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xfs_ifree_cluster
parameter_list|(
name|xfs_inode_t
modifier|*
name|free_ip
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|inum
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|free_ip
operator|->
name|i_mount
decl_stmt|;
name|int
name|blks_per_cluster
decl_stmt|;
name|int
name|nbufs
decl_stmt|;
name|int
name|ninodes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|found
decl_stmt|,
name|pre_flushed
decl_stmt|;
name|xfs_daddr_t
name|blkno
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|,
modifier|*
modifier|*
name|ip_found
decl_stmt|;
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|>=
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|blks_per_cluster
operator|=
literal|1
expr_stmt|;
name|ninodes
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblock
expr_stmt|;
name|nbufs
operator|=
name|XFS_IALLOC_BLOCKS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blks_per_cluster
operator|=
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|mp
argument_list|)
operator|/
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|ninodes
operator|=
name|blks_per_cluster
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblock
expr_stmt|;
name|nbufs
operator|=
name|XFS_IALLOC_BLOCKS
argument_list|(
name|mp
argument_list|)
operator|/
name|blks_per_cluster
expr_stmt|;
block|}
name|ip_found
operator|=
name|kmem_alloc
argument_list|(
name|ninodes
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|,
name|KM_NOFS
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nbufs
condition|;
name|j
operator|++
operator|,
name|inum
operator|+=
name|ninodes
control|)
block|{
name|blkno
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|XFS_INO_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|)
argument_list|,
name|XFS_INO_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|inum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Look for each inode in memory and attempt to lock it, 		 * we can be racing with flush and tail pushing here. 		 * any inode we get the locks on, add to an array of 		 * inode items to process later. 		 * 		 * The get the buffer lock, we could beat a flush 		 * or tail pushing thread to the lock here, in which 		 * case they will go looking for the inode buffer 		 * and fail, we need some other form of interlock 		 * here. 		 */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninodes
condition|;
name|i
operator|++
control|)
block|{
name|ih
operator|=
name|XFS_IHASH
argument_list|(
name|mp
argument_list|,
name|inum
operator|+
name|i
argument_list|)
expr_stmt|;
name|read_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ih
operator|->
name|ih_next
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|inum
operator|+
name|i
condition|)
break|break;
block|}
comment|/* Inode not in memory or we found it already, 			 * nothing to do 			 */
if|if
condition|(
operator|!
name|ip
operator|||
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_ISTALE
operator|)
condition|)
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|xfs_inode_clean
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If we can get the locks then add it to the 			 * list, otherwise by the time we get the bp lock 			 * below it will already be attached to the 			 * inode buffer. 			 */
comment|/* This inode will already be locked - by us, lets 			 * keep it that way. 			 */
if|if
condition|(
name|ip
operator|==
name|free_ip
condition|)
block|{
if|if
condition|(
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|ip
operator|->
name|i_flags
operator||=
name|XFS_ISTALE
expr_stmt|;
if|if
condition|(
name|xfs_inode_clean
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip_found
index|[
name|found
operator|++
index|]
operator|=
name|ip
expr_stmt|;
block|}
block|}
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
condition|)
block|{
if|if
condition|(
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|ip
operator|->
name|i_flags
operator||=
name|XFS_ISTALE
expr_stmt|;
if|if
condition|(
name|xfs_inode_clean
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip_found
index|[
name|found
operator|++
index|]
operator|=
name|ip
expr_stmt|;
block|}
block|}
else|else
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
block|}
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|blkno
argument_list|,
name|mp
operator|->
name|m_bsize
operator|*
name|blks_per_cluster
argument_list|,
name|XFS_BUF_LOCK
argument_list|)
expr_stmt|;
name|pre_flushed
operator|=
literal|0
expr_stmt|;
name|lip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|lip
condition|)
block|{
if|if
condition|(
name|lip
operator|->
name|li_type
operator|==
name|XFS_LI_INODE
condition|)
block|{
name|iip
operator|=
operator|(
name|xfs_inode_log_item_t
operator|*
operator|)
name|lip
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_logged
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lip
operator|->
name|li_cb
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_buf_t
operator|*
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_istale_done
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_flush_lsn
operator|=
name|iip
operator|->
name|ili_item
operator|.
name|li_lsn
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_inode
operator|->
name|i_flags
operator||=
name|XFS_ISTALE
expr_stmt|;
name|pre_flushed
operator|++
expr_stmt|;
block|}
name|lip
operator|=
name|lip
operator|->
name|li_bio_list
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|found
condition|;
name|i
operator|++
control|)
block|{
name|ip
operator|=
name|ip_found
index|[
name|i
index|]
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
operator|!
name|iip
condition|)
block|{
name|ip
operator|->
name|i_update_core
operator|=
literal|0
expr_stmt|;
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|iip
operator|->
name|ili_last_fields
operator|=
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|=
literal|0
expr_stmt|;
name|iip
operator|->
name|ili_logged
operator|=
literal|1
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_flush_lsn
operator|=
name|iip
operator|->
name|ili_item
operator|.
name|li_lsn
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_buf_attach_iodone
argument_list|(
name|bp
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_buf_t
operator|*
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_istale_done
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|iip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|free_ip
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|||
name|pre_flushed
condition|)
name|xfs_trans_stale_inode_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_trans_binval
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|ip_found
argument_list|,
name|ninodes
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to return an inode to the inode free list.  * The inode should already be truncated to 0 length and have  * no pages associated with it.  This routine also assumes that  * the inode is already a part of the transaction.  *  * The on-disk copy of the inode will have been added to the list  * of unlinked inodes in the AGI. We need to remove the inode from  * that list atomically with respect to freeing it here.  */
end_comment

begin_function
name|int
name|xfs_ifree
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|delete
decl_stmt|;
name|xfs_ino_t
name|first_ino
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Pull the on-disk inode from the AGI unlinked list. 	 */
name|error
operator|=
name|xfs_iunlink_remove
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|xfs_difree
argument_list|(
name|tp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
name|flist
argument_list|,
operator|&
name|delete
argument_list|,
operator|&
name|first_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|=
literal|0
expr_stmt|;
comment|/* mark incore inode as free */
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_dmevmask
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
literal|0
expr_stmt|;
comment|/* mark the attr fork not in use */
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
comment|/* 	 * Bump the generation count so no one will be confused 	 * by reincarnations of this inode. 	 */
name|ip
operator|->
name|i_d
operator|.
name|di_gen
operator|++
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|xfs_ifree_cluster
argument_list|(
name|ip
argument_list|,
name|tp
argument_list|,
name|first_ino
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reallocate the space for if_broot based on the number of records  * being added or deleted as indicated in rec_diff.  Move the records  * and pointers in if_broot to fit the new size.  When shrinking this  * will eliminate holes between the records and pointers created by  * the caller.  When growing this will create holes to be filled in  * by the caller.  *  * The caller must not request to add more records than would fit in  * the on-disk inode root.  If the if_broot is currently NULL, then  * if we adding records one will be allocated.  The caller must also  * not request that the number of records go below zero, although  * it can go to zero.  *  * ip -- the inode whose if_broot area is changing  * ext_diff -- the change in the number of records, positive or negative,  *	 requested for the if_broot array.  */
end_comment

begin_function
name|void
name|xfs_iroot_realloc
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|rec_diff
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|int
name|cur_max
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|xfs_bmbt_block_t
modifier|*
name|new_broot
decl_stmt|;
name|int
name|new_max
decl_stmt|;
name|size_t
name|new_size
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
comment|/* 	 * Handle the degenerate case quietly. 	 */
if|if
condition|(
name|rec_diff
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec_diff
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If there wasn't any memory allocated before, just 		 * allocate it now and get out. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_broot_bytes
operator|==
literal|0
condition|)
block|{
name|new_size
operator|=
operator|(
name|size_t
operator|)
name|XFS_BMAP_BROOT_SPACE_CALC
argument_list|(
name|rec_diff
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broot
operator|=
operator|(
name|xfs_bmbt_block_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|new_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broot_bytes
operator|=
operator|(
name|int
operator|)
name|new_size
expr_stmt|;
return|return;
block|}
comment|/* 		 * If there is already an existing if_broot, then we need 		 * to realloc() it and shift the pointers to their new 		 * location.  The records don't change location because 		 * they are kept butted up against the btree block header. 		 */
name|cur_max
operator|=
name|XFS_BMAP_BROOT_MAXRECS
argument_list|(
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|new_max
operator|=
name|cur_max
operator|+
name|rec_diff
expr_stmt|;
name|new_size
operator|=
operator|(
name|size_t
operator|)
name|XFS_BMAP_BROOT_SPACE_CALC
argument_list|(
name|new_max
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broot
operator|=
operator|(
name|xfs_bmbt_block_t
operator|*
operator|)
name|kmem_realloc
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
name|new_size
argument_list|,
operator|(
name|size_t
operator|)
name|XFS_BMAP_BROOT_SPACE_CALC
argument_list|(
name|cur_max
argument_list|)
argument_list|,
comment|/* old size */
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|op
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|new_size
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broot_bytes
operator|=
operator|(
name|int
operator|)
name|new_size
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_broot_bytes
operator|<=
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|+
name|XFS_BROOT_SIZE_ADJ
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|np
argument_list|,
name|op
argument_list|,
name|cur_max
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dfsbno_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * rec_diff is less than 0.  In this case, we are shrinking the 	 * if_broot buffer.  It must already exist.  If we go to zero 	 * records, just get rid of the root and clear the status bit. 	 */
name|ASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_broot
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_broot_bytes
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
name|cur_max
operator|=
name|XFS_BMAP_BROOT_MAXRECS
argument_list|(
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|new_max
operator|=
name|cur_max
operator|+
name|rec_diff
expr_stmt|;
name|ASSERT
argument_list|(
name|new_max
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_max
operator|>
literal|0
condition|)
name|new_size
operator|=
operator|(
name|size_t
operator|)
name|XFS_BMAP_BROOT_SPACE_CALC
argument_list|(
name|new_max
argument_list|)
expr_stmt|;
else|else
name|new_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_size
operator|>
literal|0
condition|)
block|{
name|new_broot
operator|=
operator|(
name|xfs_bmbt_block_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|new_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 		 * First copy over the btree block header. 		 */
name|memcpy
argument_list|(
name|new_broot
argument_list|,
name|ifp
operator|->
name|if_broot
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_bmbt_block_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_broot
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|XFS_IFBROOT
expr_stmt|;
block|}
comment|/* 	 * Only copy the records and pointers if there are any. 	 */
if|if
condition|(
name|new_max
operator|>
literal|0
condition|)
block|{
comment|/* 		 * First copy the records. 		 */
name|op
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_BMAP_BROOT_REC_ADDR
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_BMAP_BROOT_REC_ADDR
argument_list|(
name|new_broot
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|np
argument_list|,
name|op
argument_list|,
name|new_max
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Then copy the pointers. 		 */
name|op
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|new_broot
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|np
argument_list|,
name|op
argument_list|,
name|new_max
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dfsbno_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broot
operator|=
name|new_broot
expr_stmt|;
name|ifp
operator|->
name|if_broot_bytes
operator|=
operator|(
name|int
operator|)
name|new_size
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_broot_bytes
operator|<=
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|+
name|XFS_BROOT_SIZE_ADJ
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is called when the amount of space needed for if_extents  * is increased or decreased.  The change in size is indicated by  * the number of extents that need to be added or deleted in the  * ext_diff parameter.  *  * If the amount of space needed has decreased below the size of the  * inline buffer, then switch to using the inline buffer.  Otherwise,  * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer  * to what is needed.  *  * ip -- the inode whose if_extents area is changing  * ext_diff -- the change in the number of extents, positive or negative,  *	 requested for the if_extents array.  */
end_comment

begin_function
name|void
name|xfs_iext_realloc
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|ext_diff
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|int
name|byte_diff
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|int
name|new_size
decl_stmt|;
name|uint
name|rnew_size
decl_stmt|;
if|if
condition|(
name|ext_diff
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|byte_diff
operator|=
name|ext_diff
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|new_size
operator|=
operator|(
name|int
operator|)
name|ifp
operator|->
name|if_bytes
operator|+
name|byte_diff
expr_stmt|;
name|ASSERT
argument_list|(
name|new_size
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|NULL
expr_stmt|;
name|rnew_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_size
operator|<=
sizeof|sizeof
argument_list|(
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
argument_list|)
condition|)
block|{
comment|/* 		 * If the valid extents can fit in if_inline_ext, 		 * copy them from the malloc'd vector and free it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
condition|)
block|{
comment|/* 			 * For now, empty files are format EXTENTS, 			 * so the if_extents pointer is null. 			 */
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
condition|)
block|{
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
argument_list|,
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
expr_stmt|;
block|}
name|rnew_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rnew_size
operator|=
name|new_size
expr_stmt|;
if|if
condition|(
operator|(
name|rnew_size
operator|&
operator|(
name|rnew_size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|rnew_size
operator|=
name|xfs_iroundup
argument_list|(
name|rnew_size
argument_list|)
expr_stmt|;
comment|/* 		 * Stuck with malloc/realloc. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|==
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
condition|)
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
operator|(
name|xfs_bmbt_rec_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|rnew_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rnew_size
operator|!=
name|ifp
operator|->
name|if_real_bytes
condition|)
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
operator|(
name|xfs_bmbt_rec_t
operator|*
operator|)
name|kmem_realloc
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|rnew_size
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|,
name|KM_NOFS
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_real_bytes
operator|=
name|rnew_size
expr_stmt|;
name|ifp
operator|->
name|if_bytes
operator|=
name|new_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when the amount of space needed for if_data  * is increased or decreased.  The change in size is indicated by  * the number of bytes that need to be added or deleted in the  * byte_diff parameter.  *  * If the amount of space needed has decreased below the size of the  * inline buffer, then switch to using the inline buffer.  Otherwise,  * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer  * to what is needed.  *  * ip -- the inode whose if_data area is changing  * byte_diff -- the change in the number of bytes, positive or negative,  *	 requested for the if_data array.  */
end_comment

begin_function
name|void
name|xfs_idata_realloc
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|byte_diff
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|int
name|new_size
decl_stmt|;
name|int
name|real_size
decl_stmt|;
if|if
condition|(
name|byte_diff
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|new_size
operator|=
operator|(
name|int
operator|)
name|ifp
operator|->
name|if_bytes
operator|+
name|byte_diff
expr_stmt|;
name|ASSERT
argument_list|(
name|new_size
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
condition|)
block|{
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|NULL
expr_stmt|;
name|real_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_size
operator|<=
sizeof|sizeof
argument_list|(
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
argument_list|)
condition|)
block|{
comment|/* 		 * If the valid extents/data can fit in if_inline_ext/data, 		 * copy them from the malloc'd vector and free it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
argument_list|,
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
expr_stmt|;
block|}
name|real_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Stuck with malloc/realloc. 		 * For inline data, the underlying buffer must be 		 * a multiple of 4 bytes in size so that it can be 		 * logged and stay on word boundaries.  We enforce 		 * that here. 		 */
name|real_size
operator|=
name|roundup
argument_list|(
name|new_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|kmem_alloc
argument_list|(
name|real_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
condition|)
block|{
comment|/* 			 * Only do the realloc if the underlying size 			 * is really changing. 			 */
if|if
condition|(
name|ifp
operator|->
name|if_real_bytes
operator|!=
name|real_size
condition|)
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|kmem_realloc
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|real_size
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|kmem_alloc
argument_list|(
name|real_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
argument_list|,
name|ifp
operator|->
name|if_bytes
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_real_bytes
operator|=
name|real_size
expr_stmt|;
name|ifp
operator|->
name|if_bytes
operator|=
name|new_size
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_bytes
operator|<=
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map inode to disk block and offset.  *  * mp -- the mount point structure for the current file system  * tp -- the current transaction  * ino -- the inode number of the inode to be located  * imap -- this structure is filled in with the information necessary  *	 to retrieve the given inode from disk  * flags -- flags to pass to xfs_dilocate indicating whether or not  *	 lookups in the inode btree were OK or not  */
end_comment

begin_function
name|int
name|xfs_imap
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_imap_t
modifier|*
name|imap
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xfs_fsblock_t
name|fsbno
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fsbno
operator|=
name|imap
operator|->
name|im_blkno
condition|?
name|XFS_DADDR_TO_FSB
argument_list|(
name|mp
argument_list|,
name|imap
operator|->
name|im_blkno
argument_list|)
else|:
name|NULLFSBLOCK
expr_stmt|;
name|error
operator|=
name|xfs_dilocate
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
operator|&
name|fsbno
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|off
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|imap
operator|->
name|im_blkno
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|fsbno
argument_list|)
expr_stmt|;
name|imap
operator|->
name|im_len
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|imap
operator|->
name|im_agblkno
operator|=
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|fsbno
argument_list|)
expr_stmt|;
name|imap
operator|->
name|im_ioffset
operator|=
operator|(
name|ushort
operator|)
name|off
expr_stmt|;
name|imap
operator|->
name|im_boffset
operator|=
call|(
name|ushort
call|)
argument_list|(
name|off
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xfs_idestroy_fork
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_broot
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broot
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the format is local, then we can't have an extents 	 * array so just look for an inline data array.  If we're 	 * not local then we may or may not have an extents list, 	 * so check and free it up if we do. 	 */
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_data
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_real_bytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
argument_list|,
name|ifp
operator|->
name|if_real_bytes
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_real_bytes
operator|=
literal|0
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|==
name|NULL
operator|||
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|==
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_real_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|whichfork
operator|==
name|XFS_ATTR_FORK
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_ifork_zone
argument_list|,
name|ip
operator|->
name|i_afp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called free all the memory associated with an inode.  * It must free the inode itself and any buffers allocated for  * if_extents/if_data and if_broot.  It must also free the lock  * associated with the inode.  */
end_comment

begin_function
name|void
name|xfs_idestroy
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
case|case
name|S_IFDIR
case|:
case|case
name|S_IFLNK
case|:
name|xfs_idestroy_fork
argument_list|(
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|->
name|i_afp
condition|)
name|xfs_idestroy_fork
argument_list|(
name|ip
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|mrfree
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
name|mrfree
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
name|freesema
argument_list|(
operator|&
name|ip
operator|->
name|i_flock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
name|ktrace_free
argument_list|(
name|ip
operator|->
name|i_xtrace
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_BMBT_TRACE
name|ktrace_free
argument_list|(
name|ip
operator|->
name|i_btrace
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_RW_TRACE
name|ktrace_free
argument_list|(
name|ip
operator|->
name|i_rwtrace
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_ILOCK_TRACE
name|ktrace_free
argument_list|(
name|ip
operator|->
name|i_lock_trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_DIR2_TRACE
name|ktrace_free
argument_list|(
name|ip
operator|->
name|i_dir_trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|i_itemp
condition|)
block|{
comment|/* XXXdpd should be able to assert this but shutdown 		 * is leaving the AIL behind. */
name|ASSERT
argument_list|(
operator|(
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
operator|==
literal|0
operator|)
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inode_item_destroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|kmem_zone_free
argument_list|(
name|xfs_inode_zone
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Increment the pin count of the given buffer.  * This value is protected by ipinlock spinlock in the mount structure.  */
end_comment

begin_function
name|void
name|xfs_ipin
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decrement the pin count of the given inode, and wake up  * anyone in xfs_iwait_unpin() if the count goes to 0.  The  * inode must have been previoulsy pinned with a call to xfs_ipin().  */
end_comment

begin_function
name|void
name|xfs_iunpin
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_dec_and_test
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|)
condition|)
block|{
if|#
directive|if
name|XXXKAN
comment|/* 		 * Should I mark FreeBSD vnode as dirty here? 		 */
name|printf
argument_list|(
literal|"%s:%d: Should I mark FreeBSD vnode as dirty here?\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
decl_stmt|;
comment|/* make sync come back and flush this inode */
if|if
condition|(
name|vp
condition|)
block|{
name|struct
name|inode
modifier|*
name|inode
init|=
name|LINVFS_GET_IP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|inode
operator|->
name|i_state
operator|&
name|I_NEW
operator|)
condition|)
name|mark_inode_dirty_sync
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|wakeup
argument_list|(
operator|&
name|ip
operator|->
name|i_ipin_wait
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called to wait for the given inode to be unpinned.  * It will sleep until this happens.  The caller must have the  * inode locked in at least shared mode so that the buffer cannot  * be subsequently pinned once someone is waiting for it to be  * unpinned.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_iunpin_wait
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|xfs_lsn_t
name|lsn
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
operator||
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
name|iip
operator|&&
name|iip
operator|->
name|ili_last_lsn
condition|)
block|{
name|lsn
operator|=
name|iip
operator|->
name|ili_last_lsn
expr_stmt|;
block|}
else|else
block|{
name|lsn
operator|=
operator|(
name|xfs_lsn_t
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 	 * Give the log a push so we don't wait here too long. 	 */
name|xfs_log_force
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|lsn
argument_list|,
name|XFS_LOG_FORCE
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKAN: xfs_iunpin is not locking inode 	 * at all? 	 */
while|while
condition|(
name|atomic_read
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|)
operator|!=
literal|0
condition|)
name|tsleep
argument_list|(
operator|&
name|ip
operator|->
name|i_ipin_wait
argument_list|,
name|PRIBIO
argument_list|,
literal|"iunpin"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xfs_iextents_copy()  *  * This is called to copy the REAL extents (as opposed to the delayed  * allocation extents) from the inode into the given buffer.  It  * returns the number of bytes copied into the buffer.  *  * If there are no delayed allocation extents, then we can just  * memcpy() the extents into the buffer.  Otherwise, we need to  * examine each extent in turn and skip those which are delayed.  */
end_comment

begin_function
name|int
name|xfs_iextents_copy
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_bmbt_rec_t
modifier|*
name|buffer
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|int
name|copied
decl_stmt|;
name|xfs_bmbt_rec_t
modifier|*
name|dest_ep
decl_stmt|;
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_iextents_copy"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|int
name|nrecs
decl_stmt|;
name|xfs_fsblock_t
name|start_block
decl_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
operator||
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nrecs
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_exlist
argument_list|(
name|fname
argument_list|,
name|ip
argument_list|,
name|nrecs
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nrecs
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * There are some delayed allocation extents in the 	 * inode, so copy the extents one at a time and skip 	 * the delayed ones.  There must be at least one 	 * non-delayed extent. 	 */
name|ep
operator|=
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
expr_stmt|;
name|dest_ep
operator|=
name|buffer
expr_stmt|;
name|copied
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrecs
condition|;
name|i
operator|++
control|)
block|{
name|start_block
operator|=
name|xfs_bmbt_get_startblock
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISNULLSTARTBLOCK
argument_list|(
name|start_block
argument_list|)
condition|)
block|{
comment|/* 			 * It's a delayed allocation extent, so skip it. 			 */
name|ep
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Translate to on disk format */
name|put_unaligned
argument_list|(
name|INT_GET
argument_list|(
name|ep
operator|->
name|l0
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|dest_ep
operator|->
name|l0
argument_list|)
expr_stmt|;
name|put_unaligned
argument_list|(
name|INT_GET
argument_list|(
name|ep
operator|->
name|l1
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|dest_ep
operator|->
name|l1
argument_list|)
expr_stmt|;
name|dest_ep
operator|++
expr_stmt|;
name|ep
operator|++
expr_stmt|;
name|copied
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|copied
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|xfs_validate_extents
argument_list|(
name|buffer
argument_list|,
name|copied
argument_list|,
literal|1
argument_list|,
name|XFS_EXTFMT_INODE
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|copied
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Each of the following cases stores data into the same region  * of the on-disk inode, so only one of them can be valid at  * any given time. While it is possible to have conflicting formats  * and log flags, e.g. having XFS_ILOG_?DATA set when the fork is  * in EXTENTS format, this can only happen when the fork has  * changed formats after being modified but before being flushed.  * In these cases, the format always takes precedence, because the  * format indicates the current state of the fork.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|int
name|xfs_iflush_fork
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|,
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|,
name|int
name|whichfork
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
name|int
name|first
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|short
name|brootflag
index|[
literal|2
index|]
init|=
block|{
name|XFS_ILOG_DBROOT
block|,
name|XFS_ILOG_ABROOT
block|}
decl_stmt|;
specifier|static
specifier|const
name|short
name|dataflag
index|[
literal|2
index|]
init|=
block|{
name|XFS_ILOG_DDATA
block|,
name|XFS_ILOG_ADATA
block|}
decl_stmt|;
specifier|static
specifier|const
name|short
name|extflag
index|[
literal|2
index|]
init|=
block|{
name|XFS_ILOG_DEXT
block|,
name|XFS_ILOG_AEXT
block|}
decl_stmt|;
if|if
condition|(
name|iip
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
comment|/* 	 * This can happen if we gave up in iformat in an error path, 	 * for the attribute fork. 	 */
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cp
operator|=
name|XFS_DFORK_PTR_ARCH
argument_list|(
name|dip
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
switch|switch
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
condition|)
block|{
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|dataflag
index|[
name|whichfork
index|]
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_bytes
operator|<=
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|ifp
operator|->
name|if_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_DIR_SHORTFORM_VALIDATE_ONDISK
argument_list|(
name|mp
argument_list|,
name|dip
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_iflush_fork"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|ASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|||
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|extflag
index|[
name|whichfork
index|]
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_bytes
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ifp
operator|->
name|if_bytes
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|extflag
index|[
name|whichfork
index|]
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_iextents_copy
argument_list|(
name|ip
argument_list|,
operator|(
name|xfs_bmbt_rec_t
operator|*
operator|)
name|cp
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|brootflag
index|[
name|whichfork
index|]
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_broot_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_broot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_broot_bytes
operator|<=
operator|(
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|+
name|XFS_BROOT_SIZE_ADJ
operator|)
argument_list|)
expr_stmt|;
name|xfs_bmbt_to_bmdr
argument_list|(
name|ifp
operator|->
name|if_broot
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|,
operator|(
name|xfs_bmdr_block_t
operator|*
operator|)
name|cp
argument_list|,
name|XFS_DFORK_SIZE_ARCH
argument_list|(
name|dip
argument_list|,
name|mp
argument_list|,
name|whichfork
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_DEV
case|:
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DEV
condition|)
block|{
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|dip
operator|->
name|di_u
operator|.
name|di_dev
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_rdev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_UUID
case|:
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_UUID
condition|)
block|{
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dip
operator|->
name|di_u
operator|.
name|di_muuid
argument_list|,
operator|&
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_iflush() will write a modified inode's changes out to the  * inode's on disk home.  The caller must have the inode lock held  * in at least shared mode and the inode flush semaphore must be  * held as well.  The inode lock will still be held upon return from  * the call and the caller is free to unlock it.  * The inode flush lock will be unlocked when the inode reaches the disk.  * The flags indicate how the inode's buffer should be written out.  */
end_comment

begin_function
name|int
name|xfs_iflush
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* REFERENCED */
name|xfs_chash_t
modifier|*
name|ch
decl_stmt|;
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
name|int
name|clcount
decl_stmt|;
comment|/* count of inodes clustered */
name|int
name|bufwasdelwri
decl_stmt|;
enum|enum
block|{
name|INT_DELWRI
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|INT_ASYNC
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|}
enum|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_iflush_count
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
operator||
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|valusema
argument_list|(
operator|&
name|ip
operator|->
name|i_flock
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|||
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * If the inode isn't dirty, then just release the inode 	 * flush lock and do nothing. 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|iip
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|iip
operator|!=
name|NULL
operator|)
condition|?
operator|!
operator|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
else|:
literal|1
argument_list|)
expr_stmt|;
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * We can't flush the inode until it is unpinned, so 	 * wait for it.  We know noone new can pin it, because 	 * we are holding the inode lock shared and you need 	 * to hold it exclusively to pin the inode. 	 */
name|xfs_iunpin_wait
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * This may have been unpinned because the filesystem is shutting 	 * down forcibly. If that's the case we must not write this inode 	 * to disk, because the log record didn't make it to disk! 	 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ip
operator|->
name|i_update_core
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iip
condition|)
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|=
literal|0
expr_stmt|;
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
comment|/* 	 * Get the buffer containing the on-disk inode. 	 */
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Decide how buffer will be flushed out.  This is done before 	 * the call to xfs_iflush_int because this field is zeroed by it. 	 */
if|if
condition|(
name|iip
operator|!=
name|NULL
operator|&&
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Flush out the inode buffer according to the directions 		 * of the caller.  In the cases where the caller has given 		 * us a choice choose the non-delwri case.  This is because 		 * the inode is in the AIL and we need to get it out soon. 		 */
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|XFS_IFLUSH_SYNC
case|:
case|case
name|XFS_IFLUSH_DELWRI_ELSE_SYNC
case|:
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XFS_IFLUSH_ASYNC
case|:
case|case
name|XFS_IFLUSH_DELWRI_ELSE_ASYNC
case|:
name|flags
operator|=
name|INT_ASYNC
expr_stmt|;
break|break;
case|case
name|XFS_IFLUSH_DELWRI
case|:
name|flags
operator|=
name|INT_DELWRI
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|XFS_IFLUSH_DELWRI_ELSE_SYNC
case|:
case|case
name|XFS_IFLUSH_DELWRI_ELSE_ASYNC
case|:
case|case
name|XFS_IFLUSH_DELWRI
case|:
name|flags
operator|=
name|INT_DELWRI
expr_stmt|;
break|break;
case|case
name|XFS_IFLUSH_ASYNC
case|:
name|flags
operator|=
name|INT_ASYNC
expr_stmt|;
break|break;
case|case
name|XFS_IFLUSH_SYNC
case|:
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * First flush out the inode that xfs_iflush was called with. 	 */
name|error
operator|=
name|xfs_iflush_int
argument_list|(
name|ip
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|corrupt_out
goto|;
block|}
comment|/* 	 * inode clustering: 	 * see if other inodes can be gathered into this write 	 */
name|ip
operator|->
name|i_chash
operator|->
name|chl_buf
operator|=
name|bp
expr_stmt|;
name|ch
operator|=
name|XFS_CHASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_blkno
argument_list|)
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|)
expr_stmt|;
name|clcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|iq
operator|=
name|ip
operator|->
name|i_cnext
init|;
name|iq
operator|!=
name|ip
condition|;
name|iq
operator|=
name|iq
operator|->
name|i_cnext
control|)
block|{
comment|/* 		 * Do an un-protected check to see if the inode is dirty and 		 * is a candidate for flushing.  These checks will be repeated 		 * later after the appropriate locks are acquired. 		 */
name|iip
operator|=
name|iq
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|->
name|i_update_core
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|iip
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
operator|&&
name|xfs_ipincount
argument_list|(
name|iq
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Try to get locks.  If any are unavailable, 		 * then this inode cannot be flushed and is skipped. 		 */
comment|/* get inode locks (just i_lock) */
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|iq
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
condition|)
block|{
comment|/* get inode flush lock */
if|if
condition|(
name|xfs_iflock_nowait
argument_list|(
name|iq
argument_list|)
condition|)
block|{
comment|/* check if pinned */
if|if
condition|(
name|xfs_ipincount
argument_list|(
name|iq
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* arriving here means that 					 * this inode can be flushed. 					 * first re-check that it's 					 * dirty 					 */
name|iip
operator|=
name|iq
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|->
name|i_update_core
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|iip
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
condition|)
block|{
name|clcount
operator|++
expr_stmt|;
name|error
operator|=
name|xfs_iflush_int
argument_list|(
name|iq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|iq
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
goto|goto
name|cluster_corrupt_out
goto|;
block|}
block|}
else|else
block|{
name|xfs_ifunlock
argument_list|(
name|iq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|xfs_ifunlock
argument_list|(
name|iq
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_iunlock
argument_list|(
name|iq
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|clcount
condition|)
block|{
name|XFS_STATS_INC
argument_list|(
name|xs_icluster_flushcnt
argument_list|)
expr_stmt|;
name|XFS_STATS_ADD
argument_list|(
name|xs_icluster_flushinode
argument_list|,
name|clcount
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the buffer is pinned then push on the log so we won't 	 * get stuck waiting in the write for too long. 	 */
if|if
condition|(
name|XFS_BUF_ISPINNED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|INT_DELWRI
condition|)
block|{
name|xfs_bdwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|INT_ASYNC
condition|)
block|{
name|xfs_bawrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|corrupt_out
label|:
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_CORRUPT_INCORE
argument_list|)
expr_stmt|;
name|xfs_iflush_abort
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Unlocks the flush lock 	 */
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
name|cluster_corrupt_out
label|:
comment|/* Corruption detected in the clustering loop.  Invalidate the 	 * inode buffer and shut down the filesystem. 	 */
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up the buffer.  If it was B_DELWRI, just release it -- 	 * brelse can handle it with no problems.  If not, shut down the 	 * filesystem before releasing the buffer. 	 */
if|if
condition|(
operator|(
name|bufwasdelwri
operator|=
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_CORRUPT_INCORE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufwasdelwri
condition|)
block|{
comment|/* 		 * Just like incore_relse: if we have b_iodone functions, 		 * mark the buffer as an error and call them.  Otherwise 		 * mark it as stale and brelse. 		 */
if|if
condition|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|XFS_BUF_CLR_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SHUT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_ERROR
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|xfs_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_iflush_abort
argument_list|(
name|iq
argument_list|)
expr_stmt|;
comment|/* 	 * Unlocks the flush lock 	 */
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_iflush_int
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
name|int
name|first
decl_stmt|;
endif|#
directive|endif
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
operator||
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|valusema
argument_list|(
operator|&
name|ip
operator|->
name|i_flock
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|||
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * If the inode isn't dirty, then just release the inode 	 * flush lock and do nothing. 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|iip
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* set *dip = inode's place in the buffer */
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|ip
operator|->
name|i_boffset
argument_list|)
expr_stmt|;
comment|/* 	 * Clear i_update_core before copying out the data. 	 * This is for coordination with our timestamp updates 	 * that don't hold the inode lock. They will always 	 * update the timestamps BEFORE setting i_update_core, 	 * so if we clear i_update_core after they set it we 	 * are guaranteed to see their updates to the timestamps. 	 * I believe that this depends on strongly ordered memory 	 * semantics, but we have that.  We use the SYNCHRONIZE 	 * macro to make sure that the compiler does not reorder 	 * the i_update_core access below the data copy below. 	 */
name|ip
operator|->
name|i_update_core
operator|=
literal|0
expr_stmt|;
name|SYNCHRONIZE
argument_list|()
expr_stmt|;
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DINODE_MAGIC
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IFLUSH_1
argument_list|,
name|XFS_RANDOM_IFLUSH_1
argument_list|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_IFLUSH
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iflush: Bad inode %Lu magic number 0x%x, ptr 0x%p"
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
operator|(
name|int
operator|)
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|dip
argument_list|)
expr_stmt|;
goto|goto
name|corrupt_out
goto|;
block|}
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_magic
operator|!=
name|XFS_DINODE_MAGIC
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IFLUSH_2
argument_list|,
name|XFS_RANDOM_IFLUSH_2
argument_list|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_IFLUSH
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iflush: Bad inode %Lu, ptr 0x%p, magic number 0x%x"
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
name|ip
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_magic
argument_list|)
expr_stmt|;
goto|goto
name|corrupt_out
goto|;
block|}
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|)
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IFLUSH_3
argument_list|,
name|XFS_RANDOM_IFLUSH_3
argument_list|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_IFLUSH
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iflush: Bad regular inode %Lu, ptr 0x%p"
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|corrupt_out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IFLUSH_4
argument_list|,
name|XFS_RANDOM_IFLUSH_4
argument_list|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_IFLUSH
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iflush: Bad directory inode %Lu, ptr 0x%p"
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|corrupt_out
goto|;
block|}
block|}
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|+
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IFLUSH_5
argument_list|,
name|XFS_RANDOM_IFLUSH_5
argument_list|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_IFLUSH
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iflush: detected corrupt incore inode %Lu, total extents = %d, nblocks = %Ld, ptr 0x%p"
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|+
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
argument_list|,
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|corrupt_out
goto|;
block|}
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodesize
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_IFLUSH_6
argument_list|,
name|XFS_RANDOM_IFLUSH_6
argument_list|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_IFLUSH
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_iflush: bad inode %Lu, forkoff 0x%x, ptr 0x%p"
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
argument_list|,
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|corrupt_out
goto|;
block|}
comment|/* 	 * bump the flush iteration count, used to detect flushes which 	 * postdate a log record during recovery. 	 */
name|ip
operator|->
name|i_d
operator|.
name|di_flushiter
operator|++
expr_stmt|;
comment|/* 	 * Copy the dirty parts of the inode into the on-disk 	 * inode.  We always copy out the core of the inode, 	 * because if the inode is dirty at all the core must 	 * be. 	 */
name|xfs_xlate_dinode_core
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|dip
operator|->
name|di_core
operator|)
argument_list|,
operator|&
operator|(
name|ip
operator|->
name|i_d
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* Wrap, we never let the log put out DI_MAX_FLUSH */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flushiter
operator|==
name|DI_MAX_FLUSH
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flushiter
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If this is really an old format inode and the superblock version 	 * has not been updated to support only new format inodes, then 	 * convert back to the old inode format.  If the superblock version 	 * has been updated, then make the conversion permanent. 	 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
operator|||
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
condition|)
block|{
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
comment|/* 			 * Convert it back. 			 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|<=
name|XFS_MAXLINK_1
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_onlink
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The superblock version has already been bumped, 			 * so just make the conversion to the new inode 			 * format permanent. 			 */
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|=
name|XFS_DINODE_VERSION_2
expr_stmt|;
name|INT_SET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_version
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DINODE_VERSION_2
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
operator|=
literal|0
expr_stmt|;
name|INT_ZERO
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_onlink
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|dip
operator|->
name|di_core
operator|.
name|di_pad
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_projid
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xfs_iflush_fork
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|iip
argument_list|,
name|XFS_DATA_FORK
argument_list|,
name|bp
argument_list|)
operator|==
name|EFSCORRUPTED
condition|)
block|{
goto|goto
name|corrupt_out
goto|;
block|}
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
condition|)
block|{
comment|/* 		 * The only error from xfs_iflush_fork is on the data fork. 		 */
operator|(
name|void
operator|)
name|xfs_iflush_fork
argument_list|(
name|ip
argument_list|,
name|dip
argument_list|,
name|iip
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|xfs_inobp_check
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * We've recorded everything logged in the inode, so we'd 	 * like to clear the ilf_fields bits so we don't log and 	 * flush things unnecessarily.  However, we can't stop 	 * logging all this information until the data we've copied 	 * into the disk buffer is written to disk.  If we did we might 	 * overwrite the copy of the inode in the log with all the 	 * data after re-logging only part of it, and in the face of 	 * a crash we wouldn't have all the data we need to recover. 	 * 	 * What we do is move the bits to the ili_last_fields field. 	 * When logging the inode, these bits are moved back to the 	 * ilf_fields field.  In the xfs_iflush_done() routine we 	 * clear ili_last_fields, since we know that the information 	 * those bits represent is permanently on disk.  As long as 	 * the flush completes before the inode is logged again, then 	 * both ilf_fields and ili_last_fields will be cleared. 	 * 	 * We can play with the ilf_fields bits here, because the inode 	 * lock must be held exclusively in order to set bits there 	 * and the flush lock protects the ili_last_fields bits. 	 * Set ili_logged so the flush done 	 * routine can tell whether or not to look in the AIL. 	 * Also, store the current LSN of the inode so that we can tell 	 * whether the item has moved in the AIL from xfs_iflush_done(). 	 * In order to read the lsn we need the AIL lock, because 	 * it is a 64 bit value that cannot be read atomically. 	 */
if|if
condition|(
name|iip
operator|!=
name|NULL
operator|&&
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
condition|)
block|{
name|iip
operator|->
name|ili_last_fields
operator|=
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|=
literal|0
expr_stmt|;
name|iip
operator|->
name|ili_logged
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_lsn_t
argument_list|)
operator|==
literal|8
argument_list|)
expr_stmt|;
comment|/* don't lock if it shrinks */
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_flush_lsn
operator|=
name|iip
operator|->
name|ili_item
operator|.
name|li_lsn
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Attach the function xfs_iflush_done to the inode's 		 * buffer.  This will remove the inode from the AIL 		 * and unlock the inode's flush lock when the inode is 		 * completely written to disk. 		 */
name|xfs_buf_attach_iodone
argument_list|(
name|bp
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_buf_t
operator|*
argument_list|,
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_iflush_done
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|iip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're flushing an inode which is not in the AIL and has 		 * not been logged but has i_update_core set.  For this 		 * case we can use a B_DELWRI flush and immediately drop 		 * the inode flush lock because we can avoid the whole 		 * AIL state thing.  It's OK to drop the flush lock now, 		 * because we've already locked the buffer and to do anything 		 * you really need both. 		 */
if|if
condition|(
name|iip
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_logged
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_last_fields
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|corrupt_out
label|:
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all inactive inodes in mp.  Return true if no user references  * were found, false otherwise.  */
end_comment

begin_function
name|int
name|xfs_iflush_all
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|busy
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|purged
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|vmap_t
name|vmap
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|busy
operator|=
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|purged
operator|=
literal|0
expr_stmt|;
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mp
operator|->
name|m_inodes
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
do|do
block|{
comment|/* Make sure we skip markers inserted by sync */
if|if
condition|(
name|ip
operator|->
name|i_mount
operator|==
name|NULL
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * It's up to our caller to purge the root 			 * and quota vnodes later. 			 */
name|vp
operator|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
block|{
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_finish_reclaim
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|XFS_IFLUSH_ASYNC
argument_list|)
expr_stmt|;
name|purged
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vn_count
argument_list|(
name|vp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vn_count
argument_list|(
name|vp
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|ip
operator|==
name|mp
operator|->
name|m_rootip
operator|||
operator|(
name|mp
operator|->
name|m_quotainfo
operator|&&
operator|(
name|ip
operator|->
name|i_ino
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_uquotino
operator|||
name|ip
operator|->
name|i_ino
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_gquotino
operator|)
operator|)
operator|)
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|XFS_FLUSH_ALL
operator|)
condition|)
block|{
name|busy
operator|=
literal|1
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 				 * Ignore busy inodes but continue flushing 				 * others. 				 */
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Sample vp mapping while holding mp locked on MP 			 * systems, so we don't purge a reclaimed or 			 * nonexistent vnode.  We break from the loop 			 * since we know that we modify 			 * it by pulling ourselves from it in xfs_reclaim() 			 * called via vn_purge() below.  Set ip to the next 			 * entry in the list anyway so we'll know below 			 * whether we reached the end or not. 			 */
name|VMAP
argument_list|(
name|vp
argument_list|,
name|vmap
argument_list|)
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_purge
argument_list|(
name|vp
argument_list|,
operator|&
name|vmap
argument_list|)
expr_stmt|;
name|purged
operator|=
literal|1
expr_stmt|;
break|break;
block|}
do|while
condition|(
name|ip
operator|!=
name|mp
operator|->
name|m_inodes
condition|)
do|;
comment|/* 		 * We need to distinguish between when we exit the loop 		 * after a purge and when we simply hit the end of the 		 * list.  We can't use the (ip == mp->m_inodes) test, 		 * because when we purge an inode at the start of the list 		 * the next inode on the list becomes mp->m_inodes.  That 		 * would cause such a test to bail out early.  The purged 		 * variable tells us how we got out of the loop. 		 */
if|if
condition|(
operator|!
name|purged
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|!
name|busy
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_iaccess: check accessibility of inode for mode.  */
end_comment

begin_function
name|int
name|xfs_iaccess
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mode_t
name|imode
decl_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|imode
operator|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|MODEMASK
operator|)
operator||
name|VTTOIF
argument_list|(
name|vp
operator|->
name|v_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
if|if
condition|(
operator|(
name|XVFSTOMNT
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|)
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|imode
argument_list|)
operator|||
name|S_ISDIR
argument_list|(
name|imode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|imode
argument_list|)
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EROFS
argument_list|)
return|;
if|#
directive|if
name|XXXKAN
if|if
condition|(
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EACCES
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/* 	 * If there's an Access Control List it's used instead of 	 * the mode bits. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|_ACL_XFS_IACCESS
argument_list|(
name|ip
argument_list|,
name|mode
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|error
condition|?
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
else|:
literal|0
return|;
name|error
operator|=
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|imode
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_uid
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_gid
argument_list|,
name|mode
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_iroundup: round up argument to next power of two  */
end_comment

begin_function
name|uint
name|xfs_iroundup
parameter_list|(
name|uint
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|v
return|;
name|ASSERT
argument_list|(
operator|(
name|v
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|v
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|v
operator|+
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
literal|1
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
operator|,
name|m
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|v
operator|&
name|m
condition|)
continue|continue;
name|v
operator||=
name|m
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
operator|(
name|v
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|v
operator|+
literal|1
return|;
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change the requested timestamp in the given inode.  * We don't lock across timestamp updates, and we don't log them but  * we do record the fact that there is dirty information in core.  *  * NOTE -- callers MUST combine XFS_ICHGTIME_MOD or XFS_ICHGTIME_CHG  *		with XFS_ICHGTIME_ACC to be sure that access time  *		update will take.  Calling first with XFS_ICHGTIME_ACC  *		and then XFS_ICHGTIME_MOD may fail to modify the access  *		timestamp if the filesystem is mounted noacctm.  */
end_comment

begin_function
name|void
name|xfs_ichgtime
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|timespec_t
name|tv
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
comment|/* 	 * We're not supposed to change timestamps in readonly-mounted 	 * filesystems.  Throw it away if anyone asks us. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
argument_list|)
condition|)
return|return;
comment|/* 	 * Don't update access timestamps on reads if mounted "noatime" 	 * Throw it away if anyone asks us. 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mount
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOATIME
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_NOATIME
operator|)
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|XFS_ICHGTIME_ACC
operator||
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
operator|)
operator|)
operator|==
name|XFS_ICHGTIME_ACC
operator|)
condition|)
return|return;
name|nanotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFS_ICHGTIME_MOD
condition|)
block|{
name|VN_MTIMESET
argument_list|(
name|vp
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_sec
operator|=
operator|(
name|__int32_t
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFS_ICHGTIME_ACC
condition|)
block|{
name|VN_ATIMESET
argument_list|(
name|vp
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_atime
operator|.
name|t_sec
operator|=
operator|(
name|__int32_t
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFS_ICHGTIME_CHG
condition|)
block|{
name|VN_CTIMESET
argument_list|(
name|vp
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_sec
operator|=
operator|(
name|__int32_t
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
block|}
comment|/* 	 * We update the i_update_core field _after_ changing 	 * the timestamps in order to coordinate properly with 	 * xfs_iflush() so that we don't lose timestamp updates. 	 * This keeps us from having to hold the inode lock 	 * while doing this.  We use the SYNCHRONIZE macro to 	 * ensure that the compiler does not reorder the update 	 * of i_update_core above the timestamp updates above. 	 */
name|SYNCHRONIZE
argument_list|()
expr_stmt|;
name|ip
operator|->
name|i_update_core
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|XXXKAN
if|if
condition|(
operator|!
operator|(
name|inode
operator|->
name|i_state
operator|&
name|I_LOCK
operator|)
condition|)
name|mark_inode_dirty_sync
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xfs_ichgtime mark vnode dirty\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_ILOCK_TRACE
end_ifdef

begin_decl_stmt
name|ktrace_t
modifier|*
name|xfs_ilock_trace_buf
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xfs_ilock_trace
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|lock
parameter_list|,
name|unsigned
name|int
name|lockflags
parameter_list|,
name|inst_t
modifier|*
name|ra
parameter_list|)
block|{
name|ktrace_enter
argument_list|(
name|ip
operator|->
name|i_lock_trace
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|lock
argument_list|,
comment|/* 1 = LOCK, 3=UNLOCK, etc */
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|lockflags
argument_list|,
comment|/* XFS_ILOCK_EXCL etc */
operator|(
name|void
operator|*
operator|)
name|ra
argument_list|,
comment|/* caller of ilock */
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|current_cpu
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|current_pid
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

