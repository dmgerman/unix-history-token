begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_function_decl
name|STATIC
name|int
name|xfs_trans_unlock_chunk
parameter_list|(
name|xfs_log_item_chunk_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|xfs_lsn_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is called to add the given log item to the transaction's  * list of log items.  It must find a free log item descriptor  * or allocate a new one and add the item to that descriptor.  * The function returns a pointer to item descriptor used to point  * to the new item.  The log item will now point to its new descriptor  * with its li_desc field.  */
end_comment

begin_function
name|xfs_log_item_desc_t
modifier|*
name|xfs_trans_add_item
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* 	 * If there are no free descriptors, allocate a new chunk 	 * of them and put it at the front of the chunk list. 	 */
if|if
condition|(
name|tp
operator|->
name|t_items_free
operator|==
literal|0
condition|)
block|{
name|licp
operator|=
operator|(
name|xfs_log_item_chunk_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_log_item_chunk_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|licp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize the chunk, and then 		 * claim the first slot in the newly allocated chunk. 		 */
name|XFS_LIC_INIT
argument_list|(
name|licp
argument_list|)
expr_stmt|;
name|XFS_LIC_CLAIM
argument_list|(
name|licp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|licp
operator|->
name|lic_unused
operator|=
literal|1
expr_stmt|;
name|XFS_LIC_INIT_SLOT
argument_list|(
name|licp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lidp
operator|=
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Link in the new chunk and update the free count. 		 */
name|licp
operator|->
name|lic_next
operator|=
name|tp
operator|->
name|t_items
operator|.
name|lic_next
expr_stmt|;
name|tp
operator|->
name|t_items
operator|.
name|lic_next
operator|=
name|licp
expr_stmt|;
name|tp
operator|->
name|t_items_free
operator|=
name|XFS_LIC_NUM_SLOTS
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Initialize the descriptor and the generic portion 		 * of the log item. 		 * 		 * Point the new slot at this item and return it. 		 * Also point the log item at its currently active 		 * descriptor and set the item's mount pointer. 		 */
name|lidp
operator|->
name|lid_item
operator|=
name|lip
expr_stmt|;
name|lidp
operator|->
name|lid_flags
operator|=
literal|0
expr_stmt|;
name|lidp
operator|->
name|lid_size
operator|=
literal|0
expr_stmt|;
name|lip
operator|->
name|li_desc
operator|=
name|lidp
expr_stmt|;
name|lip
operator|->
name|li_mountp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
return|return
operator|(
name|lidp
operator|)
return|;
block|}
comment|/* 	 * Find the free descriptor. It is somewhere in the chunklist 	 * of descriptors. 	 */
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
expr_stmt|;
while|while
condition|(
name|licp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|XFS_LIC_VACANCY
argument_list|(
name|licp
argument_list|)
condition|)
block|{
if|if
condition|(
name|licp
operator|->
name|lic_unused
operator|<=
name|XFS_LIC_MAX_SLOT
condition|)
block|{
name|i
operator|=
name|licp
operator|->
name|lic_unused
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|XFS_LIC_MAX_SLOT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|i
operator|<=
name|XFS_LIC_MAX_SLOT
argument_list|)
expr_stmt|;
break|break;
block|}
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|licp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we find a free descriptor, claim it, 	 * initialize it, and return it. 	 */
name|XFS_LIC_CLAIM
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|licp
operator|->
name|lic_unused
operator|<=
name|i
condition|)
block|{
name|licp
operator|->
name|lic_unused
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|XFS_LIC_INIT_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lidp
operator|=
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_items_free
operator|--
expr_stmt|;
name|lidp
operator|->
name|lid_item
operator|=
name|lip
expr_stmt|;
name|lidp
operator|->
name|lid_flags
operator|=
literal|0
expr_stmt|;
name|lidp
operator|->
name|lid_size
operator|=
literal|0
expr_stmt|;
name|lip
operator|->
name|li_desc
operator|=
name|lidp
expr_stmt|;
name|lip
operator|->
name|li_mountp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
return|return
operator|(
name|lidp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the given descriptor.  *  * This requires setting the bit in the chunk's free mask corresponding  * to the given slot.  */
end_comment

begin_function
name|void
name|xfs_trans_free_item
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_log_item_desc_t
modifier|*
name|lidp
parameter_list|)
block|{
name|uint
name|slot
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
modifier|*
name|licpp
decl_stmt|;
name|slot
operator|=
name|XFS_LIC_DESC_TO_SLOT
argument_list|(
name|lidp
argument_list|)
expr_stmt|;
name|licp
operator|=
name|XFS_LIC_DESC_TO_CHUNK
argument_list|(
name|lidp
argument_list|)
expr_stmt|;
name|XFS_LIC_RELSE
argument_list|(
name|licp
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|lidp
operator|->
name|lid_item
operator|->
name|li_desc
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_items_free
operator|++
expr_stmt|;
comment|/* 	 * If there are no more used items in the chunk and this is not 	 * the chunk embedded in the transaction structure, then free 	 * the chunk. First pull it from the chunk list and then 	 * free it back to the heap.  We didn't bother with a doubly 	 * linked list here because the lists should be very short 	 * and this is not a performance path.  It's better to save 	 * the memory of the extra pointer. 	 * 	 * Also decrement the transaction structure's count of free items 	 * by the number in a chunk since we are freeing an empty chunk. 	 */
if|if
condition|(
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
operator|&&
operator|(
name|licp
operator|!=
operator|&
operator|(
name|tp
operator|->
name|t_items
operator|)
operator|)
condition|)
block|{
name|licpp
operator|=
operator|&
operator|(
name|tp
operator|->
name|t_items
operator|.
name|lic_next
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|licpp
operator|!=
name|licp
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
name|licpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|licpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|licpp
operator|)
operator|->
name|lic_next
operator|)
expr_stmt|;
block|}
operator|*
name|licpp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
name|kmem_free
argument_list|(
name|licp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_log_item_chunk_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_items_free
operator|-=
name|XFS_LIC_NUM_SLOTS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called to find the descriptor corresponding to the given  * log item.  It returns a pointer to the descriptor.  * The log item MUST have a corresponding descriptor in the given  * transaction.  This routine does not return NULL, it panics.  *  * The descriptor pointer is kept in the log item's li_desc field.  * Just return it.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|xfs_log_item_desc_t
modifier|*
name|xfs_trans_find_item
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|lip
operator|->
name|li_desc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|lip
operator|->
name|li_desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the first descriptor in the chunk list.  * This does not return NULL if there are none, it panics.  *  * The first descriptor must be in either the first or second chunk.  * This is because the only chunk allowed to be empty is the first.  * All others are freed when they become empty.  *  * At some point this and xfs_trans_next_item() should be optimized  * to quickly look at the mask to determine if there is anything to  * look at.  */
end_comment

begin_function
name|xfs_log_item_desc_t
modifier|*
name|xfs_trans_first_item
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
expr_stmt|;
comment|/* 	 * If it's not in the first chunk, skip to the second. 	 */
if|if
condition|(
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
block|}
comment|/* 	 * Return the first non-free descriptor in the chunk. 	 */
name|ASSERT
argument_list|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xfs_trans_first_item() -- no first item"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a descriptor, return the next descriptor in the chunk list.  * This returns NULL if there are no more used descriptors in the list.  *  * We do this by first locating the chunk in which the descriptor resides,  * and then scanning forward in the chunk and the list for the next  * used descriptor.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|xfs_log_item_desc_t
modifier|*
name|xfs_trans_next_item
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_log_item_desc_t
modifier|*
name|lidp
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|licp
operator|=
name|XFS_LIC_DESC_TO_CHUNK
argument_list|(
name|lidp
argument_list|)
expr_stmt|;
comment|/* 	 * First search the rest of the chunk. The for loop keeps us 	 * from referencing things beyond the end of the chunk. 	 */
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|XFS_LIC_DESC_TO_SLOT
argument_list|(
name|lidp
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Now search the next chunk.  It must be there, because the 	 * next chunk would have been freed if it were empty. 	 * If there is no next chunk, return NULL. 	 */
if|if
condition|(
name|licp
operator|->
name|lic_next
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
comment|/* keep gcc quite */
block|}
end_function

begin_comment
comment|/*  * This is called to unlock all of the items of a transaction and to free  * all the descriptors of that transaction.  *  * It walks the list of descriptors and unlocks each item.  It frees  * each chunk except that embedded in the transaction as it goes along.  */
end_comment

begin_function
name|void
name|xfs_trans_free_items
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
name|next_licp
decl_stmt|;
name|int
name|abort
decl_stmt|;
name|abort
operator|=
name|flags
operator|&
name|XFS_TRANS_ABORT
expr_stmt|;
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
expr_stmt|;
comment|/* 	 * Special case the embedded chunk so we don't free it below. 	 */
if|if
condition|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|xfs_trans_unlock_chunk
argument_list|(
name|licp
argument_list|,
literal|1
argument_list|,
name|abort
argument_list|,
name|NULLCOMMITLSN
argument_list|)
expr_stmt|;
name|XFS_LIC_ALL_FREE
argument_list|(
name|licp
argument_list|)
expr_stmt|;
name|licp
operator|->
name|lic_unused
operator|=
literal|0
expr_stmt|;
block|}
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
comment|/* 	 * Unlock each item in each chunk and free the chunks. 	 */
while|while
condition|(
name|licp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_trans_unlock_chunk
argument_list|(
name|licp
argument_list|,
literal|1
argument_list|,
name|abort
argument_list|,
name|NULLCOMMITLSN
argument_list|)
expr_stmt|;
name|next_licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
name|kmem_free
argument_list|(
name|licp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_log_item_chunk_t
argument_list|)
argument_list|)
expr_stmt|;
name|licp
operator|=
name|next_licp
expr_stmt|;
block|}
comment|/* 	 * Reset the transaction structure's free item count. 	 */
name|tp
operator|->
name|t_items_free
operator|=
name|XFS_LIC_NUM_SLOTS
expr_stmt|;
name|tp
operator|->
name|t_items
operator|.
name|lic_next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to unlock the items associated with a transaction.  * Items which were not logged should be freed.  * Those which were logged must still be tracked so they can be unpinned  * when the transaction commits.  */
end_comment

begin_function
name|void
name|xfs_trans_unlock_items
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_lsn_t
name|commit_lsn
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
name|next_licp
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
modifier|*
name|licpp
decl_stmt|;
name|int
name|freed
decl_stmt|;
name|freed
operator|=
literal|0
expr_stmt|;
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
expr_stmt|;
comment|/* 	 * Special case the embedded chunk so we don't free. 	 */
if|if
condition|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
name|freed
operator|=
name|xfs_trans_unlock_chunk
argument_list|(
name|licp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|commit_lsn
argument_list|)
expr_stmt|;
block|}
name|licpp
operator|=
operator|&
operator|(
name|tp
operator|->
name|t_items
operator|.
name|lic_next
operator|)
expr_stmt|;
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
comment|/* 	 * Unlock each item in each chunk, free non-dirty descriptors, 	 * and free empty chunks. 	 */
while|while
condition|(
name|licp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
argument_list|)
expr_stmt|;
name|freed
operator|+=
name|xfs_trans_unlock_chunk
argument_list|(
name|licp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|commit_lsn
argument_list|)
expr_stmt|;
name|next_licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
if|if
condition|(
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
operator|*
name|licpp
operator|=
name|next_licp
expr_stmt|;
name|kmem_free
argument_list|(
name|licp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_log_item_chunk_t
argument_list|)
argument_list|)
expr_stmt|;
name|freed
operator|-=
name|XFS_LIC_NUM_SLOTS
expr_stmt|;
block|}
else|else
block|{
name|licpp
operator|=
operator|&
operator|(
name|licp
operator|->
name|lic_next
operator|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|*
name|licpp
operator|==
name|next_licp
argument_list|)
expr_stmt|;
name|licp
operator|=
name|next_licp
expr_stmt|;
block|}
comment|/* 	 * Fix the free descriptor count in the transaction. 	 */
name|tp
operator|->
name|t_items_free
operator|+=
name|freed
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock each item pointed to by a descriptor in the given chunk.  * Stamp the commit lsn into each item if necessary.  * Free descriptors pointing to items which are not dirty if freeing_chunk  * is zero. If freeing_chunk is non-zero, then we need to unlock all  * items in the chunk including those with XFS_LID_SYNC_UNLOCK set.  * Return the number of descriptors freed.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_trans_unlock_chunk
parameter_list|(
name|xfs_log_item_chunk_t
modifier|*
name|licp
parameter_list|,
name|int
name|freeing_chunk
parameter_list|,
name|int
name|abort
parameter_list|,
name|xfs_lsn_t
name|commit_lsn
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|freed
decl_stmt|;
name|freed
operator|=
literal|0
expr_stmt|;
name|lidp
operator|=
name|licp
operator|->
name|lic_descs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
operator|,
name|lidp
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|lip
operator|=
name|lidp
operator|->
name|lid_item
expr_stmt|;
name|lip
operator|->
name|li_desc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|commit_lsn
operator|!=
name|NULLCOMMITLSN
condition|)
name|IOP_COMMITTING
argument_list|(
name|lip
argument_list|,
name|commit_lsn
argument_list|)
expr_stmt|;
comment|/* XXXsup */
if|if
condition|(
name|abort
condition|)
name|lip
operator|->
name|li_flags
operator||=
name|XFS_LI_ABORTED
expr_stmt|;
comment|/* if (abort) { 			IOP_ABORT(lip); 		} else */
if|if
condition|(
operator|!
operator|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_SYNC_UNLOCK
operator|)
operator|||
name|freeing_chunk
operator|||
name|abort
condition|)
block|{
name|IOP_UNLOCK
argument_list|(
name|lip
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Free the descriptor if the item is not dirty 		 * within this transaction and the caller is not 		 * going to just free the entire thing regardless. 		 */
if|if
condition|(
operator|!
operator|(
name|freeing_chunk
operator|)
operator|&&
operator|(
operator|!
operator|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_DIRTY
operator|)
operator|||
name|abort
operator|)
condition|)
block|{
name|XFS_LIC_RELSE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|freed
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|freed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to add the given busy item to the transaction's  * list of busy items.  It must find a free busy item descriptor  * or allocate a new one and add the item to that descriptor.  * The function returns a pointer to busy descriptor used to point  * to the new busy entry.  The log busy entry will now point to its new  * descriptor with its ???? field.  */
end_comment

begin_function
name|xfs_log_busy_slot_t
modifier|*
name|xfs_trans_add_busy
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_agnumber_t
name|ag
parameter_list|,
name|xfs_extlen_t
name|idx
parameter_list|)
block|{
name|xfs_log_busy_chunk_t
modifier|*
name|lbcp
decl_stmt|;
name|xfs_log_busy_slot_t
modifier|*
name|lbsp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* 	 * If there are no free descriptors, allocate a new chunk 	 * of them and put it at the front of the chunk list. 	 */
if|if
condition|(
name|tp
operator|->
name|t_busy_free
operator|==
literal|0
condition|)
block|{
name|lbcp
operator|=
operator|(
name|xfs_log_busy_chunk_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_log_busy_chunk_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lbcp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize the chunk, and then 		 * claim the first slot in the newly allocated chunk. 		 */
name|XFS_LBC_INIT
argument_list|(
name|lbcp
argument_list|)
expr_stmt|;
name|XFS_LBC_CLAIM
argument_list|(
name|lbcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lbcp
operator|->
name|lbc_unused
operator|=
literal|1
expr_stmt|;
name|lbsp
operator|=
name|XFS_LBC_SLOT
argument_list|(
name|lbcp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Link in the new chunk and update the free count. 		 */
name|lbcp
operator|->
name|lbc_next
operator|=
name|tp
operator|->
name|t_busy
operator|.
name|lbc_next
expr_stmt|;
name|tp
operator|->
name|t_busy
operator|.
name|lbc_next
operator|=
name|lbcp
expr_stmt|;
name|tp
operator|->
name|t_busy_free
operator|=
name|XFS_LIC_NUM_SLOTS
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Initialize the descriptor and the generic portion 		 * of the log item. 		 * 		 * Point the new slot at this item and return it. 		 * Also point the log item at its currently active 		 * descriptor and set the item's mount pointer. 		 */
name|lbsp
operator|->
name|lbc_ag
operator|=
name|ag
expr_stmt|;
name|lbsp
operator|->
name|lbc_idx
operator|=
name|idx
expr_stmt|;
return|return
operator|(
name|lbsp
operator|)
return|;
block|}
comment|/* 	 * Find the free descriptor. It is somewhere in the chunklist 	 * of descriptors. 	 */
name|lbcp
operator|=
operator|&
name|tp
operator|->
name|t_busy
expr_stmt|;
while|while
condition|(
name|lbcp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|XFS_LBC_VACANCY
argument_list|(
name|lbcp
argument_list|)
condition|)
block|{
if|if
condition|(
name|lbcp
operator|->
name|lbc_unused
operator|<=
name|XFS_LBC_MAX_SLOT
condition|)
block|{
name|i
operator|=
name|lbcp
operator|->
name|lbc_unused
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* out-of-order vacancy */
name|printk
argument_list|(
literal|"OOO vacancy lbcp 0x%p\n"
argument_list|,
name|lbcp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|lbcp
operator|=
name|lbcp
operator|->
name|lbc_next
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|lbcp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we find a free descriptor, claim it, 	 * initialize it, and return it. 	 */
name|XFS_LBC_CLAIM
argument_list|(
name|lbcp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbcp
operator|->
name|lbc_unused
operator|<=
name|i
condition|)
block|{
name|lbcp
operator|->
name|lbc_unused
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|lbsp
operator|=
name|XFS_LBC_SLOT
argument_list|(
name|lbcp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_busy_free
operator|--
expr_stmt|;
name|lbsp
operator|->
name|lbc_ag
operator|=
name|ag
expr_stmt|;
name|lbsp
operator|->
name|lbc_idx
operator|=
name|idx
expr_stmt|;
return|return
operator|(
name|lbsp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_trans_free_busy  * Free all of the busy lists from a transaction  */
end_comment

begin_function
name|void
name|xfs_trans_free_busy
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_log_busy_chunk_t
modifier|*
name|lbcp
decl_stmt|;
name|xfs_log_busy_chunk_t
modifier|*
name|lbcq
decl_stmt|;
name|lbcp
operator|=
name|tp
operator|->
name|t_busy
operator|.
name|lbc_next
expr_stmt|;
while|while
condition|(
name|lbcp
operator|!=
name|NULL
condition|)
block|{
name|lbcq
operator|=
name|lbcp
operator|->
name|lbc_next
expr_stmt|;
name|kmem_free
argument_list|(
name|lbcp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_log_busy_chunk_t
argument_list|)
argument_list|)
expr_stmt|;
name|lbcp
operator|=
name|lbcq
expr_stmt|;
block|}
name|XFS_LBC_INIT
argument_list|(
operator|&
name|tp
operator|->
name|t_busy
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_busy
operator|.
name|lbc_unused
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

