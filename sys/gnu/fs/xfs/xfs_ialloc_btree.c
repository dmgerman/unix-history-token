begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_function_decl
name|STATIC
name|void
name|xfs_inobt_log_block
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_buf_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_inobt_log_keys
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|xfs_buf_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_inobt_log_ptrs
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|xfs_buf_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_inobt_log_recs
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|xfs_buf_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_inobt_lshift
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_inobt_newroot
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_inobt_rshift
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_inobt_split
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|xfs_agblock_t
modifier|*
parameter_list|,
name|xfs_inobt_key_t
modifier|*
parameter_list|,
name|xfs_btree_cur_t
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_inobt_updkey
parameter_list|(
name|xfs_btree_cur_t
modifier|*
parameter_list|,
name|xfs_inobt_key_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Single level of the xfs_inobt_delete record deletion routine.  * Delete record pointed to by cur/level.  * Remove the record from its block then rebalance the tree.  * Return 0 for error, 1 for done, 2 to go on to the next level.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_delrec
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level removing record from */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* fail/done/go-on */
block|{
name|xfs_buf_t
modifier|*
name|agbp
decl_stmt|;
comment|/* buffer for a.g. inode header */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
comment|/* allocation group inode header */
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block record/key lives in */
name|xfs_agblock_t
name|bno
decl_stmt|;
comment|/* btree block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* loop index */
name|xfs_inobt_key_t
name|key
decl_stmt|;
comment|/* kp points here if block is level 0 */
name|xfs_inobt_key_t
modifier|*
name|kp
init|=
name|NULL
decl_stmt|;
comment|/* pointer to btree keys */
name|xfs_agblock_t
name|lbno
decl_stmt|;
comment|/* left block's block number */
name|xfs_buf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* left block's buffer pointer */
name|xfs_inobt_block_t
modifier|*
name|left
decl_stmt|;
comment|/* left btree block */
name|xfs_inobt_key_t
modifier|*
name|lkp
decl_stmt|;
comment|/* left block key pointer */
name|xfs_inobt_ptr_t
modifier|*
name|lpp
decl_stmt|;
comment|/* left block address pointer */
name|int
name|lrecs
init|=
literal|0
decl_stmt|;
comment|/* number of records in left block */
name|xfs_inobt_rec_t
modifier|*
name|lrp
decl_stmt|;
comment|/* left block record pointer */
name|xfs_inobt_ptr_t
modifier|*
name|pp
init|=
name|NULL
decl_stmt|;
comment|/* pointer to btree addresses */
name|int
name|ptr
decl_stmt|;
comment|/* index in btree block for this rec */
name|xfs_agblock_t
name|rbno
decl_stmt|;
comment|/* right block's block number */
name|xfs_buf_t
modifier|*
name|rbp
decl_stmt|;
comment|/* right block's buffer pointer */
name|xfs_inobt_block_t
modifier|*
name|right
decl_stmt|;
comment|/* right btree block */
name|xfs_inobt_key_t
modifier|*
name|rkp
decl_stmt|;
comment|/* right block key pointer */
name|xfs_inobt_rec_t
modifier|*
name|rp
decl_stmt|;
comment|/* pointer to btree records */
name|xfs_inobt_ptr_t
modifier|*
name|rpp
decl_stmt|;
comment|/* right block address pointer */
name|int
name|rrecs
init|=
literal|0
decl_stmt|;
comment|/* number of records in right block */
name|int
name|numrecs
decl_stmt|;
name|xfs_inobt_rec_t
modifier|*
name|rrp
decl_stmt|;
comment|/* right block record pointer */
name|xfs_btree_cur_t
modifier|*
name|tcur
decl_stmt|;
comment|/* temporary btree cursor */
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
comment|/* 	 * Get the index of the entry being deleted, check for nothing there. 	 */
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Get the buffer& block containing the record or key/ptr. 	 */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * Fail if we're off the end of the block. 	 */
name|numrecs
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|>
name|numrecs
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * It's a nonleaf.  Excise the key and ptr being deleted, by 	 * sliding the entries past them down one. 	 * Log the changed areas of the block. 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|kp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
name|ptr
init|;
name|i
operator|<
name|numrecs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
name|pp
index|[
name|i
index|]
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|<
name|numrecs
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|kp
index|[
name|ptr
operator|-
literal|1
index|]
argument_list|,
operator|&
name|kp
index|[
name|ptr
index|]
argument_list|,
operator|(
name|numrecs
operator|-
name|ptr
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|kp
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|pp
index|[
name|ptr
operator|-
literal|1
index|]
argument_list|,
operator|&
name|pp
index|[
name|ptr
index|]
argument_list|,
operator|(
name|numrecs
operator|-
name|ptr
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|kp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|numrecs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|numrecs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * It's a leaf.  Excise the record being deleted, by sliding the 	 * entries past it down one.  Log the changed areas of the block. 	 */
else|else
block|{
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|numrecs
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|rp
index|[
name|ptr
operator|-
literal|1
index|]
argument_list|,
operator|&
name|rp
index|[
name|ptr
index|]
argument_list|,
operator|(
name|numrecs
operator|-
name|ptr
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|numrecs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If it's the first record in the block, we'll need a key 		 * structure to pass up to the next level (updkey). 		 */
if|if
condition|(
name|ptr
operator|==
literal|1
condition|)
block|{
name|key
operator|.
name|ir_startino
operator|=
name|rp
operator|->
name|ir_startino
expr_stmt|;
name|kp
operator|=
operator|&
name|key
expr_stmt|;
block|}
block|}
comment|/* 	 * Decrement and log the number of entries in the block. 	 */
name|numrecs
operator|--
expr_stmt|;
name|block
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
name|numrecs
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|bp
argument_list|,
name|XFS_BB_NUMRECS
argument_list|)
expr_stmt|;
comment|/* 	 * Is this the root level?  If so, we're almost done. 	 */
if|if
condition|(
name|level
operator|==
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
condition|)
block|{
comment|/* 		 * If this is the root level, 		 * and there's only one entry left, 		 * and it's NOT the leaf level, 		 * then we can get rid of this level. 		 */
if|if
condition|(
name|numrecs
operator|==
literal|1
operator|&&
name|level
operator|>
literal|0
condition|)
block|{
name|agbp
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agbp
expr_stmt|;
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
comment|/* 			 * pp is still set to the first pointer in the block. 			 * Make it the new root of the btree. 			 */
name|bno
operator|=
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_root
argument_list|)
expr_stmt|;
name|agi
operator|->
name|agi_root
operator|=
operator|*
name|pp
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agi
operator|->
name|agi_level
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Free the block. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_free_extent
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|XFS_AGB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|bno
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|xfs_trans_binval
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_ialloc_log_agi
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|agbp
argument_list|,
name|XFS_AGI_ROOT
operator||
name|XFS_AGI_LEVEL
argument_list|)
expr_stmt|;
comment|/* 			 * Update the cursor so there's one fewer level. 			 */
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|cur
operator|->
name|bc_nlevels
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If we deleted the leftmost entry in the block, update the 	 * key values above us in the tree. 	 */
if|if
condition|(
name|ptr
operator|==
literal|1
operator|&&
operator|(
name|error
operator|=
name|xfs_inobt_updkey
argument_list|(
name|cur
argument_list|,
name|kp
argument_list|,
name|level
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * If the number of records remaining in the block is at least 	 * the minimum, we're done. 	 */
if|if
condition|(
name|numrecs
operator|>=
name|XFS_INOBT_BLOCK_MINRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Otherwise, we have to move some records around to keep the 	 * tree balanced.  Look at the left and right sibling blocks to 	 * see if we can re-balance by moving only one record. 	 */
name|rbno
operator|=
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
name|lbno
operator|=
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_leftsib
argument_list|)
expr_stmt|;
name|bno
operator|=
name|NULLAGBLOCK
expr_stmt|;
name|ASSERT
argument_list|(
name|rbno
operator|!=
name|NULLAGBLOCK
operator|||
name|lbno
operator|!=
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
comment|/* 	 * Duplicate the cursor so our btree manipulations here won't 	 * disrupt the next level up. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_dup_cursor
argument_list|(
name|cur
argument_list|,
operator|&
name|tcur
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * If there's a right sibling, see if it's ok to shift an entry 	 * out of it. 	 */
if|if
condition|(
name|rbno
operator|!=
name|NULLAGBLOCK
condition|)
block|{
comment|/* 		 * Move the temp cursor to the last entry in the next block. 		 * Actually any entry but the first would suffice. 		 */
name|i
operator|=
name|xfs_btree_lastrec
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_increment
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|i
operator|=
name|xfs_btree_lastrec
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|i
operator|==
literal|1
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Grab a pointer to the block. 		 */
name|rbp
operator|=
name|tcur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|right
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|right
argument_list|,
name|level
argument_list|,
name|rbp
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
endif|#
directive|endif
comment|/* 		 * Grab the current block number, for future use. 		 */
name|bno
operator|=
name|be32_to_cpu
argument_list|(
name|right
operator|->
name|bb_leftsib
argument_list|)
expr_stmt|;
comment|/* 		 * If right block is full enough so that removing one entry 		 * won't make it too empty, and left-shifting an entry out 		 * of right to us works, we're done. 		 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|-
literal|1
operator|>=
name|XFS_INOBT_BLOCK_MINRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_lshift
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|i
condition|)
block|{
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|>=
name|XFS_INOBT_BLOCK_MINRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|tcur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 		 * Otherwise, grab the number of records in right for 		 * future reference, and fix up the temp cursor to point 		 * to our block again (last record). 		 */
name|rrecs
operator|=
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbno
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_btree_firstrec
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
block|}
comment|/* 	 * If there's a left sibling, see if it's ok to shift an entry 	 * out of it. 	 */
if|if
condition|(
name|lbno
operator|!=
name|NULLAGBLOCK
condition|)
block|{
comment|/* 		 * Move the temp cursor to the first entry in the 		 * previous block. 		 */
name|xfs_btree_firstrec
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|xfs_btree_firstrec
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|)
expr_stmt|;
comment|/* 		 * Grab a pointer to the block. 		 */
name|lbp
operator|=
name|tcur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|left
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
name|level
argument_list|,
name|lbp
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
endif|#
directive|endif
comment|/* 		 * Grab the current block number, for future use. 		 */
name|bno
operator|=
name|be32_to_cpu
argument_list|(
name|left
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
comment|/* 		 * If left block is full enough so that removing one entry 		 * won't make it too empty, and right-shifting an entry out 		 * of left to us works, we're done. 		 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|-
literal|1
operator|>=
name|XFS_INOBT_BLOCK_MINRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_rshift
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|i
condition|)
block|{
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|>=
name|XFS_INOBT_BLOCK_MINRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|tcur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
operator|++
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 		 * Otherwise, grab the number of records in right for 		 * future reference. 		 */
name|lrecs
operator|=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Delete the temp cursor, we're done with it. 	 */
name|xfs_btree_del_cursor
argument_list|(
name|tcur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
comment|/* 	 * If here, we need to do a join to keep the tree balanced. 	 */
name|ASSERT
argument_list|(
name|bno
operator|!=
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
comment|/* 	 * See if we can join with the left neighbor block. 	 */
if|if
condition|(
name|lbno
operator|!=
name|NULLAGBLOCK
operator|&&
name|lrecs
operator|+
name|numrecs
operator|<=
name|XFS_INOBT_BLOCK_MAXRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
comment|/* 		 * Set "right" to be the starting block, 		 * "left" to be the left neighbor. 		 */
name|rbno
operator|=
name|bno
expr_stmt|;
name|right
operator|=
name|block
expr_stmt|;
name|rrecs
operator|=
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
name|rbp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|lbno
argument_list|,
literal|0
argument_list|,
operator|&
name|lbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|left
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
name|lrecs
operator|=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
name|level
argument_list|,
name|lbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * If that won't work, see if we can join with the right neighbor block. 	 */
elseif|else
if|if
condition|(
name|rbno
operator|!=
name|NULLAGBLOCK
operator|&&
name|rrecs
operator|+
name|numrecs
operator|<=
name|XFS_INOBT_BLOCK_MAXRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
comment|/* 		 * Set "left" to be the starting block, 		 * "right" to be the right neighbor. 		 */
name|lbno
operator|=
name|bno
expr_stmt|;
name|left
operator|=
name|block
expr_stmt|;
name|lrecs
operator|=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|rbno
argument_list|,
literal|0
argument_list|,
operator|&
name|rbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|right
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
name|rrecs
operator|=
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|right
argument_list|,
name|level
argument_list|,
name|rbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * Otherwise, we can't fix the imbalance. 	 * Just return.  This is probably a logic error, but it's not fatal. 	 */
else|else
block|{
if|if
condition|(
name|level
operator|>
literal|0
operator|&&
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * We're now going to join "left" and "right" by moving all the stuff 	 * in "right" to "left" and deleting "right". 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
comment|/* 		 * It's a non-leaf.  Move keys and pointers. 		 */
name|lkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|left
argument_list|,
name|lrecs
operator|+
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|lpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|left
argument_list|,
name|lrecs
operator|+
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rrecs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
name|rpp
index|[
name|i
index|]
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|lkp
argument_list|,
name|rkp
argument_list|,
name|rrecs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lkp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lpp
argument_list|,
name|rpp
argument_list|,
name|rrecs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lpp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|lbp
argument_list|,
name|lrecs
operator|+
literal|1
argument_list|,
name|lrecs
operator|+
name|rrecs
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|lbp
argument_list|,
name|lrecs
operator|+
literal|1
argument_list|,
name|lrecs
operator|+
name|rrecs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It's a leaf.  Move records. 		 */
name|lrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|left
argument_list|,
name|lrecs
operator|+
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lrp
argument_list|,
name|rrp
argument_list|,
name|rrecs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lrp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|lbp
argument_list|,
name|lrecs
operator|+
literal|1
argument_list|,
name|lrecs
operator|+
name|rrecs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we joined with the left neighbor, set the buffer in the 	 * cursor to the left block, and fix up the index. 	 */
if|if
condition|(
name|bp
operator|!=
name|lbp
condition|)
block|{
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|+=
name|lrecs
expr_stmt|;
block|}
comment|/* 	 * If we joined with the right neighbor and there's a level above 	 * us, increment the cursor at that level. 	 */
elseif|else
if|if
condition|(
name|level
operator|+
literal|1
operator|<
name|cur
operator|->
name|bc_nlevels
operator|&&
operator|(
name|error
operator|=
name|xfs_alloc_increment
argument_list|(
name|cur
argument_list|,
name|level
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Fix up the number of records in the surviving block. 	 */
name|lrecs
operator|+=
name|rrecs
expr_stmt|;
name|left
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
name|lrecs
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the right block pointer in the surviving block, and log it. 	 */
name|left
operator|->
name|bb_rightsib
operator|=
name|right
operator|->
name|bb_rightsib
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|lbp
argument_list|,
name|XFS_BB_NUMRECS
operator||
name|XFS_BB_RIGHTSIB
argument_list|)
expr_stmt|;
comment|/* 	 * If there is a right sibling now, make it point to the 	 * remaining block. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|left
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_inobt_block_t
modifier|*
name|rrblock
decl_stmt|;
name|xfs_buf_t
modifier|*
name|rrbp
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|left
operator|->
name|bb_rightsib
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|rrbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|rrblock
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rrbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|rrblock
argument_list|,
name|level
argument_list|,
name|rrbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|rrblock
operator|->
name|bb_leftsib
operator|=
name|cpu_to_be32
argument_list|(
name|lbno
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|rrbp
argument_list|,
name|XFS_BB_LEFTSIB
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the deleting block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_free_extent
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|XFS_AGB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|rbno
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|xfs_trans_binval
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|rbp
argument_list|)
expr_stmt|;
comment|/* 	 * Readjust the ptr at this level if it's not a leaf, since it's 	 * still pointing at the deletion point, which makes the cursor 	 * inconsistent.  If this makes the ptr 0, the caller fixes it up. 	 * We can't use decrement because it would change the next level up. 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|--
expr_stmt|;
comment|/* 	 * Return value means the next level up has something to do. 	 */
operator|*
name|stat
operator|=
literal|2
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|xfs_btree_del_cursor
argument_list|(
name|tcur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Insert one record/level.  Return information to the caller  * allowing the next level up to proceed if necessary.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_insrec
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level to insert record at */
name|xfs_agblock_t
modifier|*
name|bnop
parameter_list|,
comment|/* i/o: block number inserted */
name|xfs_inobt_rec_t
modifier|*
name|recp
parameter_list|,
comment|/* i/o: record data inserted */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* output: new cursor replacing cur */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block record/key lives in */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* loop index */
name|xfs_inobt_key_t
name|key
decl_stmt|;
comment|/* key value being inserted */
name|xfs_inobt_key_t
modifier|*
name|kp
init|=
name|NULL
decl_stmt|;
comment|/* pointer to btree keys */
name|xfs_agblock_t
name|nbno
decl_stmt|;
comment|/* block number of allocated block */
name|xfs_btree_cur_t
modifier|*
name|ncur
decl_stmt|;
comment|/* new cursor to be used at next lvl */
name|xfs_inobt_key_t
name|nkey
decl_stmt|;
comment|/* new key value, from split */
name|xfs_inobt_rec_t
name|nrec
decl_stmt|;
comment|/* new record value, for caller */
name|int
name|numrecs
decl_stmt|;
name|int
name|optr
decl_stmt|;
comment|/* old ptr value */
name|xfs_inobt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* pointer to btree addresses */
name|int
name|ptr
decl_stmt|;
comment|/* index in btree block for this rec */
name|xfs_inobt_rec_t
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
comment|/* pointer to btree records */
comment|/* 	 * GCC doesn't understand the (arguably complex) control flow in 	 * this function and complains about uninitialized structure fields 	 * without this. 	 */
name|memset
argument_list|(
operator|&
name|nrec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nrec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we made it to the root level, allocate a new root block 	 * and we're done. 	 */
if|if
condition|(
name|level
operator|>=
name|cur
operator|->
name|bc_nlevels
condition|)
block|{
name|error
operator|=
name|xfs_inobt_newroot
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
operator|*
name|bnop
operator|=
name|NULLAGBLOCK
expr_stmt|;
operator|*
name|stat
operator|=
name|i
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Make a key out of the record data to be inserted, and save it. 	 */
name|key
operator|.
name|ir_startino
operator|=
name|recp
operator|->
name|ir_startino
expr_stmt|;
comment|/* INT_: direct copy */
name|optr
operator|=
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
expr_stmt|;
comment|/* 	 * If we're off the left edge, return failure. 	 */
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Get pointers to the btree buffer and block. 	 */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|numrecs
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Check that the new entry is being inserted in the right place. 	 */
if|if
condition|(
name|ptr
operator|<=
name|numrecs
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
name|ptr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|xfs_btree_check_rec
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|recp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|block
argument_list|,
name|ptr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|xfs_btree_check_key
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
operator|&
name|key
argument_list|,
name|kp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|nbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
name|ncur
operator|=
operator|(
name|xfs_btree_cur_t
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 	 * If the block is full, we can't insert the new entry until we 	 * make the block un-full. 	 */
if|if
condition|(
name|numrecs
operator|==
name|XFS_INOBT_BLOCK_MAXRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
comment|/* 		 * First, try shifting an entry to the right neighbor. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_rshift
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* nothing */
block|}
comment|/* 		 * Next, try shifting an entry to the left neighbor. 		 */
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_lshift
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|i
condition|)
block|{
name|optr
operator|=
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Next, try splitting the current block 				 * in half. If this works we have to 				 * re-set our variables because 				 * we could be in a different block now. 				 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_split
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|nbno
argument_list|,
operator|&
name|nkey
argument_list|,
operator|&
name|ncur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|i
condition|)
block|{
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
expr_stmt|;
name|nrec
operator|.
name|ir_startino
operator|=
name|nkey
operator|.
name|ir_startino
expr_stmt|;
comment|/* INT_: direct copy */
block|}
else|else
block|{
comment|/* 					 * Otherwise the insert fails. 					 */
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
comment|/* 	 * At this point we know there's room for our new entry in the block 	 * we're pointing at. 	 */
name|numrecs
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
comment|/* 		 * It's a non-leaf entry.  Make a hole for the new data 		 * in the key and ptr regions of the block. 		 */
name|kp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
name|numrecs
init|;
name|i
operator|>=
name|ptr
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
name|pp
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
endif|#
directive|endif
name|memmove
argument_list|(
operator|&
name|kp
index|[
name|ptr
index|]
argument_list|,
operator|&
name|kp
index|[
name|ptr
operator|-
literal|1
index|]
argument_list|,
operator|(
name|numrecs
operator|-
name|ptr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|kp
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|pp
index|[
name|ptr
index|]
argument_list|,
operator|&
name|pp
index|[
name|ptr
operator|-
literal|1
index|]
argument_list|,
operator|(
name|numrecs
operator|-
name|ptr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Now stuff the new data in, bump numrecs and log the new data. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
operator|*
name|bnop
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
name|kp
index|[
name|ptr
operator|-
literal|1
index|]
operator|=
name|key
expr_stmt|;
comment|/* INT_: struct copy */
name|pp
index|[
name|ptr
operator|-
literal|1
index|]
operator|=
name|cpu_to_be32
argument_list|(
operator|*
name|bnop
argument_list|)
expr_stmt|;
name|numrecs
operator|++
expr_stmt|;
name|block
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
name|numrecs
argument_list|)
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|numrecs
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|numrecs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It's a leaf entry.  Make a hole for the new record. 		 */
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|rp
index|[
name|ptr
index|]
argument_list|,
operator|&
name|rp
index|[
name|ptr
operator|-
literal|1
index|]
argument_list|,
operator|(
name|numrecs
operator|-
name|ptr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Now stuff the new record in, bump numrecs 		 * and log the new data. 		 */
name|rp
index|[
name|ptr
operator|-
literal|1
index|]
operator|=
operator|*
name|recp
expr_stmt|;
comment|/* INT_: struct copy */
name|numrecs
operator|++
expr_stmt|;
name|block
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
name|numrecs
argument_list|)
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|numrecs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Log the new number of records in the btree header. 	 */
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|bp
argument_list|,
name|XFS_BB_NUMRECS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * Check that the key/record is in the right place, now. 	 */
if|if
condition|(
name|ptr
operator|<
name|numrecs
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|xfs_btree_check_rec
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|rp
operator|+
name|ptr
operator|-
literal|1
argument_list|,
name|rp
operator|+
name|ptr
argument_list|)
expr_stmt|;
else|else
name|xfs_btree_check_key
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|kp
operator|+
name|ptr
operator|-
literal|1
argument_list|,
name|kp
operator|+
name|ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If we inserted at the start of a block, update the parents' keys. 	 */
if|if
condition|(
name|optr
operator|==
literal|1
operator|&&
operator|(
name|error
operator|=
name|xfs_inobt_updkey
argument_list|(
name|cur
argument_list|,
operator|&
name|key
argument_list|,
name|level
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Return the new block number, if any. 	 * If there is one, give back a record value and a cursor too. 	 */
operator|*
name|bnop
operator|=
name|nbno
expr_stmt|;
if|if
condition|(
name|nbno
operator|!=
name|NULLAGBLOCK
condition|)
block|{
operator|*
name|recp
operator|=
name|nrec
expr_stmt|;
comment|/* INT_: struct copy */
operator|*
name|curp
operator|=
name|ncur
expr_stmt|;
block|}
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Log header fields from a btree block.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inobt_log_block
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
comment|/* buffer containing btree block */
name|int
name|fields
parameter_list|)
comment|/* mask of fields: XFS_BB_... */
block|{
name|int
name|first
decl_stmt|;
comment|/* first byte offset logged */
name|int
name|last
decl_stmt|;
comment|/* last byte offset logged */
specifier|static
specifier|const
name|short
name|offsets
index|[]
init|=
block|{
comment|/* table of offsets */
name|offsetof
argument_list|(
name|xfs_inobt_block_t
argument_list|,
name|bb_magic
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_inobt_block_t
argument_list|,
name|bb_level
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_inobt_block_t
argument_list|,
name|bb_numrecs
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_inobt_block_t
argument_list|,
name|bb_leftsib
argument_list|)
block|,
name|offsetof
argument_list|(
name|xfs_inobt_block_t
argument_list|,
name|bb_rightsib
argument_list|)
block|,
expr|sizeof
operator|(
name|xfs_inobt_block_t
operator|)
block|}
decl_stmt|;
name|xfs_btree_offsets
argument_list|(
name|fields
argument_list|,
name|offsets
argument_list|,
name|XFS_BB_NUM_BITS
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log keys from a btree block (nonleaf).  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inobt_log_keys
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
comment|/* buffer containing btree block */
name|int
name|kfirst
parameter_list|,
comment|/* index of first key to log */
name|int
name|klast
parameter_list|)
comment|/* index of last key to log */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block to log from */
name|int
name|first
decl_stmt|;
comment|/* first byte offset logged */
name|xfs_inobt_key_t
modifier|*
name|kp
decl_stmt|;
comment|/* key pointer in btree block */
name|int
name|last
decl_stmt|;
comment|/* last byte offset logged */
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|kp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|first
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|kp
index|[
name|kfirst
operator|-
literal|1
index|]
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|block
argument_list|)
expr_stmt|;
name|last
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|kp
index|[
name|klast
index|]
operator|-
literal|1
operator|)
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|block
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|bp
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log block pointer fields from a btree block (nonleaf).  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inobt_log_ptrs
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
comment|/* buffer containing btree block */
name|int
name|pfirst
parameter_list|,
comment|/* index of first pointer to log */
name|int
name|plast
parameter_list|)
comment|/* index of last pointer to log */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block to log from */
name|int
name|first
decl_stmt|;
comment|/* first byte offset logged */
name|int
name|last
decl_stmt|;
comment|/* last byte offset logged */
name|xfs_inobt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* block-pointer pointer in btree blk */
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|first
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|pp
index|[
name|pfirst
operator|-
literal|1
index|]
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|block
argument_list|)
expr_stmt|;
name|last
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|pp
index|[
name|plast
index|]
operator|-
literal|1
operator|)
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|block
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|bp
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log records from a btree block (leaf).  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inobt_log_recs
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
comment|/* buffer containing btree block */
name|int
name|rfirst
parameter_list|,
comment|/* index of first record to log */
name|int
name|rlast
parameter_list|)
comment|/* index of last record to log */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block to log from */
name|int
name|first
decl_stmt|;
comment|/* first byte offset logged */
name|int
name|last
decl_stmt|;
comment|/* last byte offset logged */
name|xfs_inobt_rec_t
modifier|*
name|rp
decl_stmt|;
comment|/* record pointer for btree block */
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|first
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|rp
index|[
name|rfirst
operator|-
literal|1
index|]
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|block
argument_list|)
expr_stmt|;
name|last
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|rp
index|[
name|rlast
index|]
operator|-
literal|1
operator|)
operator|-
operator|(
name|xfs_caddr_t
operator|)
name|block
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|bp
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup the record.  The cursor is made to point to it, based on dir.  * Return 0 if can't find any such record, 1 for success.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_lookup
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_lookup_t
name|dir
parameter_list|,
comment|/*<=, ==, or>= */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|xfs_agblock_t
name|agbno
decl_stmt|;
comment|/* a.g. relative btree block number */
name|xfs_agnumber_t
name|agno
decl_stmt|;
comment|/* allocation group number */
name|xfs_inobt_block_t
modifier|*
name|block
init|=
name|NULL
decl_stmt|;
comment|/* current btree block */
name|__int64_t
name|diff
decl_stmt|;
comment|/* difference for the current key */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|keyno
init|=
literal|0
decl_stmt|;
comment|/* current key number */
name|int
name|level
decl_stmt|;
comment|/* level in the btree */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount point */
comment|/* 	 * Get the allocation group header, and the root block number. 	 */
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
block|{
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
comment|/* a.g. inode header */
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agbp
argument_list|)
expr_stmt|;
name|agno
operator|=
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_seqno
argument_list|)
expr_stmt|;
name|agbno
operator|=
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_root
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Iterate over each level in the btree, starting at the root. 	 * For each level above the leaves, find the key we need, based 	 * on the lookup record, then follow the corresponding block 	 * pointer down to the next level. 	 */
for|for
control|(
name|level
operator|=
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
operator|,
name|diff
operator|=
literal|1
init|;
name|level
operator|>=
literal|0
condition|;
name|level
operator|--
control|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer pointer for btree block */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* disk address of btree block */
comment|/* 		 * Get the disk address we're looking for. 		 */
name|d
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|)
expr_stmt|;
comment|/* 		 * If the old buffer at this level is for a different block, 		 * throw it away, otherwise just use it. 		 */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|&&
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|!=
name|d
condition|)
name|bp
operator|=
operator|(
name|xfs_buf_t
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/* 			 * Need to get a new buffer.  Read it, then 			 * set it in the cursor, releasing the old one. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Point to the btree block, now that we have the buffer 			 */
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
else|else
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * If we already had a key match at a higher level, we know 		 * we need to use the first entry in this block. 		 */
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
name|keyno
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Otherwise we need to search this block.  Do a binary search. 		 */
else|else
block|{
name|int
name|high
decl_stmt|;
comment|/* high entry number */
name|xfs_inobt_key_t
modifier|*
name|kkbase
init|=
name|NULL
decl_stmt|;
comment|/* base of keys in block */
name|xfs_inobt_rec_t
modifier|*
name|krbase
init|=
name|NULL
decl_stmt|;
comment|/* base of records in block */
name|int
name|low
decl_stmt|;
comment|/* low entry number */
comment|/* 			 * Get a pointer to keys or records. 			 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|kkbase
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
else|else
name|krbase
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
comment|/* 			 * Set low and high entry numbers, 1-based. 			 */
name|low
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|high
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * If the block is empty, the tree must 				 * be an empty leaf. 				 */
name|ASSERT
argument_list|(
name|level
operator|==
literal|0
operator|&&
name|cur
operator|->
name|bc_nlevels
operator|==
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
operator|=
name|dir
operator|!=
name|XFS_LOOKUP_LE
expr_stmt|;
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 			 * Binary search the block. 			 */
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|xfs_agino_t
name|startino
decl_stmt|;
comment|/* key value */
comment|/* 				 * keyno is average of low and high. 				 */
name|keyno
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* 				 * Get startino. 				 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|xfs_inobt_key_t
modifier|*
name|kkp
decl_stmt|;
name|kkp
operator|=
name|kkbase
operator|+
name|keyno
operator|-
literal|1
expr_stmt|;
name|startino
operator|=
name|INT_GET
argument_list|(
name|kkp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_inobt_rec_t
modifier|*
name|krp
decl_stmt|;
name|krp
operator|=
name|krbase
operator|+
name|keyno
operator|-
literal|1
expr_stmt|;
name|startino
operator|=
name|INT_GET
argument_list|(
name|krp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Compute difference to get next direction. 				 */
name|diff
operator|=
operator|(
name|__int64_t
operator|)
name|startino
operator|-
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_startino
expr_stmt|;
comment|/* 				 * Less than, move right. 				 */
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|low
operator|=
name|keyno
operator|+
literal|1
expr_stmt|;
comment|/* 				 * Greater than, move left. 				 */
elseif|else
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
name|high
operator|=
name|keyno
operator|-
literal|1
expr_stmt|;
comment|/* 				 * Equal, we're done. 				 */
else|else
break|break;
block|}
block|}
comment|/* 		 * If there are more levels, set up for the next level 		 * by getting the block number and filling in the cursor. 		 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
comment|/* 			 * If we moved left, need the previous key number, 			 * unless there isn't one. 			 */
if|if
condition|(
name|diff
operator|>
literal|0
operator|&&
operator|--
name|keyno
operator|<
literal|1
condition|)
name|keyno
operator|=
literal|1
expr_stmt|;
name|agbno
operator|=
name|be32_to_cpu
argument_list|(
operator|*
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|block
argument_list|,
name|keyno
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|agbno
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|=
name|keyno
expr_stmt|;
block|}
block|}
comment|/* 	 * Done with the search. 	 * See if we need to adjust the results. 	 */
if|if
condition|(
name|dir
operator|!=
name|XFS_LOOKUP_LE
operator|&&
name|diff
operator|<
literal|0
condition|)
block|{
name|keyno
operator|++
expr_stmt|;
comment|/* 		 * If ge search and we went off the end of the block, but it's 		 * not the last block, we're in the wrong block. 		 */
if|if
condition|(
name|dir
operator|==
name|XFS_LOOKUP_GE
operator|&&
name|keyno
operator|>
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
operator|=
name|keyno
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
name|XFS_LOOKUP_LE
operator|&&
name|diff
operator|>
literal|0
condition|)
name|keyno
operator|--
expr_stmt|;
name|cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
operator|=
name|keyno
expr_stmt|;
comment|/* 	 * Return if we succeeded or not. 	 */
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
name|keyno
operator|>
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
condition|)
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|stat
operator|=
operator|(
operator|(
name|dir
operator|!=
name|XFS_LOOKUP_EQ
operator|)
operator|||
operator|(
name|diff
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Move 1 record left from cur/level if possible.  * Update cur to reflect the new path.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_lshift
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level to shift record on */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|;
comment|/* loop index */
endif|#
directive|endif
name|xfs_inobt_key_t
name|key
decl_stmt|;
comment|/* key value for leaf level upward */
name|xfs_buf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* buffer for left neighbor block */
name|xfs_inobt_block_t
modifier|*
name|left
decl_stmt|;
comment|/* left neighbor btree block */
name|xfs_inobt_key_t
modifier|*
name|lkp
init|=
name|NULL
decl_stmt|;
comment|/* key pointer for left block */
name|xfs_inobt_ptr_t
modifier|*
name|lpp
decl_stmt|;
comment|/* address pointer for left block */
name|xfs_inobt_rec_t
modifier|*
name|lrp
init|=
name|NULL
decl_stmt|;
comment|/* record pointer for left block */
name|int
name|nrec
decl_stmt|;
comment|/* new number of left block entries */
name|xfs_buf_t
modifier|*
name|rbp
decl_stmt|;
comment|/* buffer for right (current) block */
name|xfs_inobt_block_t
modifier|*
name|right
decl_stmt|;
comment|/* right (current) btree block */
name|xfs_inobt_key_t
modifier|*
name|rkp
init|=
name|NULL
decl_stmt|;
comment|/* key pointer for right block */
name|xfs_inobt_ptr_t
modifier|*
name|rpp
init|=
name|NULL
decl_stmt|;
comment|/* address pointer for right block */
name|xfs_inobt_rec_t
modifier|*
name|rrp
init|=
name|NULL
decl_stmt|;
comment|/* record pointer for right block */
comment|/* 	 * Set up variables for this block as "right". 	 */
name|rbp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|right
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|right
argument_list|,
name|level
argument_list|,
name|rbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * If we've got no left sibling then we can't shift an entry left. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|right
operator|->
name|bb_leftsib
argument_list|)
operator|==
name|NULLAGBLOCK
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If the cursor entry is the one that would be moved, don't 	 * do it... it's too complicated. 	 */
if|if
condition|(
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|<=
literal|1
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Set up the left neighbor as "left". 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|right
operator|->
name|bb_leftsib
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|lbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|left
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
name|level
argument_list|,
name|lbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * If it's full, it can't take another entry. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|==
name|XFS_INOBT_BLOCK_MAXRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nrec
operator|=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * If non-leaf, copy a key and a ptr to the left block. 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|lkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|left
argument_list|,
name|nrec
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
operator|*
name|lkp
operator|=
operator|*
name|rkp
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|lbp
argument_list|,
name|nrec
argument_list|,
name|nrec
argument_list|)
expr_stmt|;
name|lpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|left
argument_list|,
name|nrec
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
operator|*
name|rpp
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
operator|*
name|lpp
operator|=
operator|*
name|rpp
expr_stmt|;
comment|/* INT_: no-change copy */
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|lbp
argument_list|,
name|nrec
argument_list|,
name|nrec
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If leaf, copy a record to the left block. 	 */
else|else
block|{
name|lrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|left
argument_list|,
name|nrec
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
operator|*
name|lrp
operator|=
operator|*
name|rrp
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|lbp
argument_list|,
name|nrec
argument_list|,
name|nrec
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Bump and log left's numrecs, decrement and log right's numrecs. 	 */
name|be16_add
argument_list|(
operator|&
name|left
operator|->
name|bb_numrecs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|lbp
argument_list|,
name|XFS_BB_NUMRECS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|xfs_btree_check_key
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|lkp
operator|-
literal|1
argument_list|,
name|lkp
argument_list|)
expr_stmt|;
else|else
name|xfs_btree_check_rec
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|lrp
operator|-
literal|1
argument_list|,
name|lrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|be16_add
argument_list|(
operator|&
name|right
operator|->
name|bb_numrecs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|rbp
argument_list|,
name|XFS_BB_NUMRECS
argument_list|)
expr_stmt|;
comment|/* 	 * Slide the contents of right down one entry. 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
name|rpp
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
endif|#
directive|endif
name|memmove
argument_list|(
name|rkp
argument_list|,
name|rkp
operator|+
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rkp
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rpp
argument_list|,
name|rpp
operator|+
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rpp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|rrp
argument_list|,
name|rrp
operator|+
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rrp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|ir_startino
operator|=
name|rrp
operator|->
name|ir_startino
expr_stmt|;
comment|/* INT_: direct copy */
name|rkp
operator|=
operator|&
name|key
expr_stmt|;
block|}
comment|/* 	 * Update the parent key values of right. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_updkey
argument_list|(
name|cur
argument_list|,
name|rkp
argument_list|,
name|level
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Slide the cursor value left one. 	 */
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|--
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new root block, fill it in.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_newroot
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
comment|/* a.g. inode header */
name|xfs_alloc_arg_t
name|args
decl_stmt|;
comment|/* allocation argument structure */
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* one half of the old root block */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_inobt_key_t
modifier|*
name|kp
decl_stmt|;
comment|/* btree key pointer */
name|xfs_agblock_t
name|lbno
decl_stmt|;
comment|/* left block number */
name|xfs_buf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* left buffer pointer */
name|xfs_inobt_block_t
modifier|*
name|left
decl_stmt|;
comment|/* left btree block */
name|xfs_buf_t
modifier|*
name|nbp
decl_stmt|;
comment|/* new (root) buffer */
name|xfs_inobt_block_t
modifier|*
name|new
decl_stmt|;
comment|/* new (root) btree block */
name|int
name|nptr
decl_stmt|;
comment|/* new value for key index, 1 or 2 */
name|xfs_inobt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* btree address pointer */
name|xfs_agblock_t
name|rbno
decl_stmt|;
comment|/* right block number */
name|xfs_buf_t
modifier|*
name|rbp
decl_stmt|;
comment|/* right buffer pointer */
name|xfs_inobt_block_t
modifier|*
name|right
decl_stmt|;
comment|/* right btree block */
name|xfs_inobt_rec_t
modifier|*
name|rp
decl_stmt|;
comment|/* btree record pointer */
name|ASSERT
argument_list|(
name|cur
operator|->
name|bc_nlevels
operator|<
name|XFS_IN_MAXLEVELS
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get a block& a buffer. 	 */
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agbp
argument_list|)
expr_stmt|;
name|args
operator|.
name|tp
operator|=
name|cur
operator|->
name|bc_tp
expr_stmt|;
name|args
operator|.
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
name|XFS_AGB_TO_FSB
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_root
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|mod
operator|=
name|args
operator|.
name|minleft
operator|=
name|args
operator|.
name|alignment
operator|=
name|args
operator|.
name|total
operator|=
name|args
operator|.
name|wasdel
operator|=
name|args
operator|.
name|isfl
operator|=
name|args
operator|.
name|userdata
operator|=
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|minlen
operator|=
name|args
operator|.
name|maxlen
operator|=
name|args
operator|.
name|prod
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * None available, we fail. 	 */
if|if
condition|(
name|args
operator|.
name|fsbno
operator|==
name|NULLFSBLOCK
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|args
operator|.
name|len
operator|==
literal|1
argument_list|)
expr_stmt|;
name|nbp
operator|=
name|xfs_btree_get_bufs
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|args
operator|.
name|tp
argument_list|,
name|args
operator|.
name|agno
argument_list|,
name|args
operator|.
name|agbno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the root data in the a.g. inode structure. 	 */
name|agi
operator|->
name|agi_root
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|.
name|agbno
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|agi
operator|->
name|agi_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_ialloc_log_agi
argument_list|(
name|args
operator|.
name|tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agbp
argument_list|,
name|XFS_AGI_ROOT
operator||
name|XFS_AGI_LEVEL
argument_list|)
expr_stmt|;
comment|/* 	 * At the previous root level there are now two blocks: the old 	 * root, and the new block generated when it was split. 	 * We don't know which one the cursor is pointing at, so we 	 * set up variables "left" and "right" for each case. 	 */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
comment|/* 		 * Our block is left, pick up the right block. 		 */
name|lbp
operator|=
name|bp
expr_stmt|;
name|lbno
operator|=
name|XFS_DADDR_TO_AGBNO
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|lbp
argument_list|)
argument_list|)
expr_stmt|;
name|left
operator|=
name|block
expr_stmt|;
name|rbno
operator|=
name|be32_to_cpu
argument_list|(
name|left
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|args
operator|.
name|tp
argument_list|,
name|args
operator|.
name|agno
argument_list|,
name|rbno
argument_list|,
literal|0
argument_list|,
operator|&
name|rbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|bp
operator|=
name|rbp
expr_stmt|;
name|right
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|right
argument_list|,
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
argument_list|,
name|rbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nptr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Our block is right, pick up the left block. 		 */
name|rbp
operator|=
name|bp
expr_stmt|;
name|rbno
operator|=
name|XFS_DADDR_TO_AGBNO
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|rbp
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|block
expr_stmt|;
name|lbno
operator|=
name|be32_to_cpu
argument_list|(
name|right
operator|->
name|bb_leftsib
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|args
operator|.
name|tp
argument_list|,
name|args
operator|.
name|agno
argument_list|,
name|lbno
argument_list|,
literal|0
argument_list|,
operator|&
name|lbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|bp
operator|=
name|lbp
expr_stmt|;
name|left
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
argument_list|,
name|lbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nptr
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Fill in the new block's btree header and log it. 	 */
name|new
operator|->
name|bb_magic
operator|=
name|cpu_to_be32
argument_list|(
name|xfs_magics
index|[
name|cur
operator|->
name|bc_btnum
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|bb_level
operator|=
name|cpu_to_be16
argument_list|(
name|cur
operator|->
name|bc_nlevels
argument_list|)
expr_stmt|;
name|new
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|new
operator|->
name|bb_leftsib
operator|=
name|cpu_to_be32
argument_list|(
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
name|new
operator|->
name|bb_rightsib
operator|=
name|cpu_to_be32
argument_list|(
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|args
operator|.
name|tp
argument_list|,
name|nbp
argument_list|,
name|XFS_BB_ALL_BITS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lbno
operator|!=
name|NULLAGBLOCK
operator|&&
name|rbno
operator|!=
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the key data in the new root. 	 */
name|kp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|new
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_level
argument_list|)
operator|>
literal|0
condition|)
block|{
name|kp
index|[
literal|0
index|]
operator|=
operator|*
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|left
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
comment|/* INT_: struct copy */
name|kp
index|[
literal|1
index|]
operator|=
operator|*
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
comment|/* INT_: struct copy */
block|}
else|else
block|{
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|left
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|INT_COPY
argument_list|(
name|kp
index|[
literal|0
index|]
operator|.
name|ir_startino
argument_list|,
name|rp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|INT_COPY
argument_list|(
name|kp
index|[
literal|1
index|]
operator|.
name|ir_startino
argument_list|,
name|rp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|nbp
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the pointer data in the new root. 	 */
name|pp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|new
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|pp
index|[
literal|0
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|lbno
argument_list|)
expr_stmt|;
name|pp
index|[
literal|1
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|rbno
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|nbp
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the cursor. 	 */
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|cur
operator|->
name|bc_nlevels
argument_list|,
name|nbp
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_ptrs
index|[
name|cur
operator|->
name|bc_nlevels
index|]
operator|=
name|nptr
expr_stmt|;
name|cur
operator|->
name|bc_nlevels
operator|++
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Move 1 record right from cur/level if possible.  * Update cur to reflect the new path.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_rshift
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level to shift record on */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* loop index */
name|xfs_inobt_key_t
name|key
decl_stmt|;
comment|/* key value for leaf level upward */
name|xfs_buf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* buffer for left (current) block */
name|xfs_inobt_block_t
modifier|*
name|left
decl_stmt|;
comment|/* left (current) btree block */
name|xfs_inobt_key_t
modifier|*
name|lkp
decl_stmt|;
comment|/* key pointer for left block */
name|xfs_inobt_ptr_t
modifier|*
name|lpp
decl_stmt|;
comment|/* address pointer for left block */
name|xfs_inobt_rec_t
modifier|*
name|lrp
decl_stmt|;
comment|/* record pointer for left block */
name|xfs_buf_t
modifier|*
name|rbp
decl_stmt|;
comment|/* buffer for right neighbor block */
name|xfs_inobt_block_t
modifier|*
name|right
decl_stmt|;
comment|/* right neighbor btree block */
name|xfs_inobt_key_t
modifier|*
name|rkp
decl_stmt|;
comment|/* key pointer for right block */
name|xfs_inobt_ptr_t
modifier|*
name|rpp
decl_stmt|;
comment|/* address pointer for right block */
name|xfs_inobt_rec_t
modifier|*
name|rrp
init|=
name|NULL
decl_stmt|;
comment|/* record pointer for right block */
name|xfs_btree_cur_t
modifier|*
name|tcur
decl_stmt|;
comment|/* temporary cursor */
comment|/* 	 * Set up variables for this block as "left". 	 */
name|lbp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|left
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
name|level
argument_list|,
name|lbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * If we've got no right sibling then we can't shift an entry right. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|left
operator|->
name|bb_rightsib
argument_list|)
operator|==
name|NULLAGBLOCK
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If the cursor entry is the one that would be moved, don't 	 * do it... it's too complicated. 	 */
if|if
condition|(
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|>=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Set up the right neighbor as "right". 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|left
operator|->
name|bb_rightsib
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|rbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|right
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|right
argument_list|,
name|level
argument_list|,
name|rbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * If it's full, it can't take another entry. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|==
name|XFS_INOBT_BLOCK_MAXRECS
argument_list|(
name|level
argument_list|,
name|cur
argument_list|)
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Make a hole at the start of the right neighbor block, then 	 * copy the last left block entry to the hole. 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|lkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|left
argument_list|,
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|lpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|left
argument_list|,
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
name|rpp
index|[
name|i
index|]
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
endif|#
directive|endif
name|memmove
argument_list|(
name|rkp
operator|+
literal|1
argument_list|,
name|rkp
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rkp
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rpp
operator|+
literal|1
argument_list|,
name|rpp
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rpp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
operator|*
name|lpp
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
operator|*
name|rkp
operator|=
operator|*
name|lkp
expr_stmt|;
comment|/* INT_: no change copy */
operator|*
name|rpp
operator|=
operator|*
name|lpp
expr_stmt|;
comment|/* INT_: no change copy */
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|left
argument_list|,
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|rrp
operator|+
literal|1
argument_list|,
name|rrp
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rrp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rrp
operator|=
operator|*
name|lrp
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|key
operator|.
name|ir_startino
operator|=
name|rrp
operator|->
name|ir_startino
expr_stmt|;
comment|/* INT_: direct copy */
name|rkp
operator|=
operator|&
name|key
expr_stmt|;
block|}
comment|/* 	 * Decrement and log left's numrecs, bump and log right's numrecs. 	 */
name|be16_add
argument_list|(
operator|&
name|left
operator|->
name|bb_numrecs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|lbp
argument_list|,
name|XFS_BB_NUMRECS
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|right
operator|->
name|bb_numrecs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|xfs_btree_check_key
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|rkp
argument_list|,
name|rkp
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|xfs_btree_check_rec
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|,
name|rrp
argument_list|,
name|rrp
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfs_inobt_log_block
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|rbp
argument_list|,
name|XFS_BB_NUMRECS
argument_list|)
expr_stmt|;
comment|/* 	 * Using a temporary cursor, update the parent key values of the 	 * block on the right. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_dup_cursor
argument_list|(
name|cur
argument_list|,
operator|&
name|tcur
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|xfs_btree_lastrec
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_increment
argument_list|(
name|tcur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|||
operator|(
name|error
operator|=
name|xfs_inobt_updkey
argument_list|(
name|tcur
argument_list|,
name|rkp
argument_list|,
name|level
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|tcur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_btree_del_cursor
argument_list|(
name|tcur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Split cur/level block in half.  * Return new block number and its first record (to be inserted into parent).  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_split
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level to split */
name|xfs_agblock_t
modifier|*
name|bnop
parameter_list|,
comment|/* output: block number allocated */
name|xfs_inobt_key_t
modifier|*
name|keyp
parameter_list|,
comment|/* output: first key of new block */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* output: new cursor */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|xfs_alloc_arg_t
name|args
decl_stmt|;
comment|/* allocation argument structure */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* loop index/record number */
name|xfs_agblock_t
name|lbno
decl_stmt|;
comment|/* left (current) block number */
name|xfs_buf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* buffer for left block */
name|xfs_inobt_block_t
modifier|*
name|left
decl_stmt|;
comment|/* left (current) btree block */
name|xfs_inobt_key_t
modifier|*
name|lkp
decl_stmt|;
comment|/* left btree key pointer */
name|xfs_inobt_ptr_t
modifier|*
name|lpp
decl_stmt|;
comment|/* left btree address pointer */
name|xfs_inobt_rec_t
modifier|*
name|lrp
decl_stmt|;
comment|/* left btree record pointer */
name|xfs_buf_t
modifier|*
name|rbp
decl_stmt|;
comment|/* buffer for right block */
name|xfs_inobt_block_t
modifier|*
name|right
decl_stmt|;
comment|/* right (new) btree block */
name|xfs_inobt_key_t
modifier|*
name|rkp
decl_stmt|;
comment|/* right btree key pointer */
name|xfs_inobt_ptr_t
modifier|*
name|rpp
decl_stmt|;
comment|/* right btree address pointer */
name|xfs_inobt_rec_t
modifier|*
name|rrp
decl_stmt|;
comment|/* right btree record pointer */
comment|/* 	 * Set up left block (current one). 	 */
name|lbp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|args
operator|.
name|tp
operator|=
name|cur
operator|->
name|bc_tp
expr_stmt|;
name|args
operator|.
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
name|lbno
operator|=
name|XFS_DADDR_TO_AGBNO
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|lbp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the new block. 	 * If we can't do it, we're toast.  Give up. 	 */
name|args
operator|.
name|fsbno
operator|=
name|XFS_AGB_TO_FSB
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|lbno
argument_list|)
expr_stmt|;
name|args
operator|.
name|mod
operator|=
name|args
operator|.
name|minleft
operator|=
name|args
operator|.
name|alignment
operator|=
name|args
operator|.
name|total
operator|=
name|args
operator|.
name|wasdel
operator|=
name|args
operator|.
name|isfl
operator|=
name|args
operator|.
name|userdata
operator|=
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|minlen
operator|=
name|args
operator|.
name|maxlen
operator|=
name|args
operator|.
name|prod
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|args
operator|.
name|fsbno
operator|==
name|NULLFSBLOCK
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|args
operator|.
name|len
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rbp
operator|=
name|xfs_btree_get_bufs
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|args
operator|.
name|tp
argument_list|,
name|args
operator|.
name|agno
argument_list|,
name|args
operator|.
name|agbno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the new block as "right". 	 */
name|right
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
comment|/* 	 * "Left" is the current (according to the cursor) block. 	 */
name|left
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
name|level
argument_list|,
name|lbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * Fill in the btree header for the new block. 	 */
name|right
operator|->
name|bb_magic
operator|=
name|cpu_to_be32
argument_list|(
name|xfs_magics
index|[
name|cur
operator|->
name|bc_btnum
index|]
argument_list|)
expr_stmt|;
name|right
operator|->
name|bb_level
operator|=
name|left
operator|->
name|bb_level
expr_stmt|;
name|right
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that if there's an odd number of entries now, that 	 * each new block will have the same number of entries. 	 */
if|if
condition|(
operator|(
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|<=
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
condition|)
name|be16_add
argument_list|(
operator|&
name|right
operator|->
name|bb_numrecs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|-
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * For non-leaf blocks, copy keys and addresses over to the new block. 	 */
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|lkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|left
argument_list|,
name|i
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|lpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|left
argument_list|,
name|i
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rkp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sptr
argument_list|(
name|cur
argument_list|,
name|be32_to_cpu
argument_list|(
name|lpp
index|[
name|i
index|]
argument_list|)
argument_list|,
name|level
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|rkp
argument_list|,
name|lkp
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rkp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rpp
argument_list|,
name|lpp
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rpp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_ptrs
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|keyp
operator|=
operator|*
name|rkp
expr_stmt|;
block|}
comment|/* 	 * For leaf blocks, copy records over to the new block. 	 */
else|else
block|{
name|lrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|left
argument_list|,
name|i
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|rrp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|right
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rrp
argument_list|,
name|lrp
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rrp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|rbp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
name|keyp
operator|->
name|ir_startino
operator|=
name|rrp
operator|->
name|ir_startino
expr_stmt|;
comment|/* INT_: direct copy */
block|}
comment|/* 	 * Find the left block number by looking in the buffer. 	 * Adjust numrecs, sibling pointers. 	 */
name|be16_add
argument_list|(
operator|&
name|left
operator|->
name|bb_numrecs
argument_list|,
operator|-
operator|(
name|be16_to_cpu
argument_list|(
name|right
operator|->
name|bb_numrecs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|right
operator|->
name|bb_rightsib
operator|=
name|left
operator|->
name|bb_rightsib
expr_stmt|;
name|left
operator|->
name|bb_rightsib
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|.
name|agbno
argument_list|)
expr_stmt|;
name|right
operator|->
name|bb_leftsib
operator|=
name|cpu_to_be32
argument_list|(
name|lbno
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|args
operator|.
name|tp
argument_list|,
name|rbp
argument_list|,
name|XFS_BB_ALL_BITS
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|args
operator|.
name|tp
argument_list|,
name|lbp
argument_list|,
name|XFS_BB_NUMRECS
operator||
name|XFS_BB_RIGHTSIB
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a block to the new block's right, make that block 	 * point back to right instead of to left. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|right
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_inobt_block_t
modifier|*
name|rrblock
decl_stmt|;
comment|/* rr btree block */
name|xfs_buf_t
modifier|*
name|rrbp
decl_stmt|;
comment|/* buffer for rrblock */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|args
operator|.
name|tp
argument_list|,
name|args
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|right
operator|->
name|bb_rightsib
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|rrbp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|rrblock
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|rrbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|rrblock
argument_list|,
name|level
argument_list|,
name|rrbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|rrblock
operator|->
name|bb_leftsib
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|.
name|agbno
argument_list|)
expr_stmt|;
name|xfs_inobt_log_block
argument_list|(
name|args
operator|.
name|tp
argument_list|,
name|rrbp
argument_list|,
name|XFS_BB_LEFTSIB
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the cursor is really in the right block, move it there. 	 * If it's just pointing past the last entry in left, then we'll 	 * insert there, so don't change anything in that case. 	 */
if|if
condition|(
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|>
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
operator|+
literal|1
condition|)
block|{
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
name|rbp
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|-=
name|be16_to_cpu
argument_list|(
name|left
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are more levels, we'll need another cursor which refers 	 * the right block, no matter where this cursor was. 	 */
if|if
condition|(
name|level
operator|+
literal|1
operator|<
name|cur
operator|->
name|bc_nlevels
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_dup_cursor
argument_list|(
name|cur
argument_list|,
name|curp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|(
operator|*
name|curp
operator|)
operator|->
name|bc_ptrs
index|[
name|level
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
operator|*
name|bnop
operator|=
name|args
operator|.
name|agbno
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Update keys at all levels from here to the root along the cursor's path.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_inobt_updkey
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_inobt_key_t
modifier|*
name|keyp
parameter_list|,
comment|/* new key value to update to */
name|int
name|level
parameter_list|)
comment|/* starting level for update */
block|{
name|int
name|ptr
decl_stmt|;
comment|/* index of key in block */
comment|/* 	 * Go up the tree from this level toward the root. 	 * At each level, update the key value to the value input. 	 * Stop when we reach a level where the cursor isn't pointing 	 * at the first entry in the block. 	 */
for|for
control|(
name|ptr
operator|=
literal|1
init|;
name|ptr
operator|==
literal|1
operator|&&
name|level
operator|<
name|cur
operator|->
name|bc_nlevels
condition|;
name|level
operator|++
control|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for block */
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|error
decl_stmt|;
comment|/* error return value */
endif|#
directive|endif
name|xfs_inobt_key_t
modifier|*
name|kp
decl_stmt|;
comment|/* ptr to btree block keys */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
expr_stmt|;
name|kp
operator|=
name|XFS_INOBT_KEY_ADDR
argument_list|(
name|block
argument_list|,
name|ptr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
operator|*
name|kp
operator|=
operator|*
name|keyp
expr_stmt|;
name|xfs_inobt_log_keys
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Externally visible routines.  */
end_comment

begin_comment
comment|/*  * Decrement cursor by one record at the level.  * For nonzero levels the leaf-ward information is untouched.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_decrement
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level in btree, 0 is leaf */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block */
name|int
name|error
decl_stmt|;
name|int
name|lev
decl_stmt|;
comment|/* btree level */
name|ASSERT
argument_list|(
name|level
operator|<
name|cur
operator|->
name|bc_nlevels
argument_list|)
expr_stmt|;
comment|/* 	 * Read-ahead to the left at this level. 	 */
name|xfs_btree_readahead
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
name|XFS_BTCUR_LEFTRA
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the ptr at this level.  If we're still in the block 	 * then we're done. 	 */
if|if
condition|(
operator|--
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|>
literal|0
condition|)
block|{
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Get a pointer to the btree block. 	 */
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * If we just went off the left edge of the tree, return failure. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_leftsib
argument_list|)
operator|==
name|NULLAGBLOCK
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * March up the tree decrementing pointers. 	 * Stop when we don't go off the left edge of a block. 	 */
for|for
control|(
name|lev
operator|=
name|level
operator|+
literal|1
init|;
name|lev
operator|<
name|cur
operator|->
name|bc_nlevels
condition|;
name|lev
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|cur
operator|->
name|bc_ptrs
index|[
name|lev
index|]
operator|>
literal|0
condition|)
break|break;
comment|/* 		 * Read-ahead the left block, we're going to read it 		 * in the next loop. 		 */
name|xfs_btree_readahead
argument_list|(
name|cur
argument_list|,
name|lev
argument_list|,
name|XFS_BTCUR_LEFTRA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we went off the root then we are seriously confused. 	 */
name|ASSERT
argument_list|(
name|lev
operator|<
name|cur
operator|->
name|bc_nlevels
argument_list|)
expr_stmt|;
comment|/* 	 * Now walk back down the tree, fixing up the cursor's buffer 	 * pointers and key numbers. 	 */
for|for
control|(
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
argument_list|)
init|;
name|lev
operator|>
name|level
condition|;
control|)
block|{
name|xfs_agblock_t
name|agbno
decl_stmt|;
comment|/* block number of btree block */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing btree block */
name|agbno
operator|=
name|be32_to_cpu
argument_list|(
operator|*
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|block
argument_list|,
name|cur
operator|->
name|bc_ptrs
index|[
name|lev
index|]
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|agbno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|lev
operator|--
expr_stmt|;
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|lev
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|lev
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|cur
operator|->
name|bc_ptrs
index|[
name|lev
index|]
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
block|}
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the record pointed to by cur.  * The cursor refers to the place where the record was (could be inserted)  * when the operation returns.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_delete
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* result code */
name|int
name|level
decl_stmt|;
comment|/* btree level */
comment|/* 	 * Go up the tree, starting at leaf level. 	 * If 2 is returned then a join was done; go to the next level. 	 * Otherwise we are done. 	 */
for|for
control|(
name|level
operator|=
literal|0
operator|,
name|i
operator|=
literal|2
init|;
name|i
operator|==
literal|2
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_delrec
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|level
operator|=
literal|1
init|;
name|level
operator|<
name|cur
operator|->
name|bc_nlevels
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_decrement
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
break|break;
block|}
block|}
block|}
operator|*
name|stat
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the data from the pointed-to record.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_get_rec
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_agino_t
modifier|*
name|ino
parameter_list|,
comment|/* output: starting inode of chunk */
name|__int32_t
modifier|*
name|fcnt
parameter_list|,
comment|/* output: number of free inodes */
name|xfs_inofree_t
modifier|*
name|free
parameter_list|,
comment|/* output: free inode mask */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* output: success/failure */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing btree block */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|error
decl_stmt|;
comment|/* error return value */
endif|#
directive|endif
name|int
name|ptr
decl_stmt|;
comment|/* record number */
name|xfs_inobt_rec_t
modifier|*
name|rec
decl_stmt|;
comment|/* record data */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
literal|0
index|]
expr_stmt|;
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * Off the right end or left end, return failure. 	 */
if|if
condition|(
name|ptr
operator|>
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|||
name|ptr
operator|<=
literal|0
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Point to the record and extract its data. 	 */
name|rec
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
name|ptr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
operator|*
name|ino
operator|=
name|INT_GET
argument_list|(
name|rec
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
operator|*
name|fcnt
operator|=
name|INT_GET
argument_list|(
name|rec
operator|->
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
operator|*
name|free
operator|=
name|INT_GET
argument_list|(
name|rec
operator|->
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Increment cursor by one record at the level.  * For nonzero levels the leaf-ward information is untouched.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_increment
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level in btree, 0 is leaf */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing btree block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|lev
decl_stmt|;
comment|/* btree level */
name|ASSERT
argument_list|(
name|level
operator|<
name|cur
operator|->
name|bc_nlevels
argument_list|)
expr_stmt|;
comment|/* 	 * Read-ahead to the right at this level. 	 */
name|xfs_btree_readahead
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
name|XFS_BTCUR_RIGHTRA
argument_list|)
expr_stmt|;
comment|/* 	 * Get a pointer to the btree block. 	 */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * Increment the ptr at this level.  If we're still in the block 	 * then we're done. 	 */
if|if
condition|(
operator|++
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|<=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
condition|)
block|{
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If we just went off the right edge of the tree, return failure. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
operator|==
name|NULLAGBLOCK
condition|)
block|{
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * March up the tree incrementing pointers. 	 * Stop when we don't go off the right edge of a block. 	 */
for|for
control|(
name|lev
operator|=
name|level
operator|+
literal|1
init|;
name|lev
operator|<
name|cur
operator|->
name|bc_nlevels
condition|;
name|lev
operator|++
control|)
block|{
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|lev
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|cur
operator|->
name|bc_ptrs
index|[
name|lev
index|]
operator|<=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
condition|)
break|break;
comment|/* 		 * Read-ahead the right block, we're going to read it 		 * in the next loop. 		 */
name|xfs_btree_readahead
argument_list|(
name|cur
argument_list|,
name|lev
argument_list|,
name|XFS_BTCUR_RIGHTRA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we went off the root then we are seriously confused. 	 */
name|ASSERT
argument_list|(
name|lev
operator|<
name|cur
operator|->
name|bc_nlevels
argument_list|)
expr_stmt|;
comment|/* 	 * Now walk back down the tree, fixing up the cursor's buffer 	 * pointers and key numbers. 	 */
for|for
control|(
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
operator|,
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
init|;
name|lev
operator|>
name|level
condition|;
control|)
block|{
name|xfs_agblock_t
name|agbno
decl_stmt|;
comment|/* block number of btree block */
name|agbno
operator|=
name|be32_to_cpu
argument_list|(
operator|*
name|XFS_INOBT_PTR_ADDR
argument_list|(
name|block
argument_list|,
name|cur
operator|->
name|bc_ptrs
index|[
name|lev
index|]
argument_list|,
name|cur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|agbno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_INO_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|lev
operator|--
expr_stmt|;
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|lev
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|lev
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|cur
operator|->
name|bc_ptrs
index|[
name|lev
index|]
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Insert the current record at the point referenced by cur.  * The cursor may be inconsistent on return if splits have been done.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_insert
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* result value, 0 for failure */
name|int
name|level
decl_stmt|;
comment|/* current level number in btree */
name|xfs_agblock_t
name|nbno
decl_stmt|;
comment|/* new block number (split result) */
name|xfs_btree_cur_t
modifier|*
name|ncur
decl_stmt|;
comment|/* new cursor (split result) */
name|xfs_inobt_rec_t
name|nrec
decl_stmt|;
comment|/* record being inserted this level */
name|xfs_btree_cur_t
modifier|*
name|pcur
decl_stmt|;
comment|/* previous level's cursor */
name|level
operator|=
literal|0
expr_stmt|;
name|nbno
operator|=
name|NULLAGBLOCK
expr_stmt|;
name|INT_SET
argument_list|(
name|nrec
operator|.
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_startino
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|nrec
operator|.
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_freecount
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|nrec
operator|.
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_free
argument_list|)
expr_stmt|;
name|ncur
operator|=
operator|(
name|xfs_btree_cur_t
operator|*
operator|)
literal|0
expr_stmt|;
name|pcur
operator|=
name|cur
expr_stmt|;
comment|/* 	 * Loop going up the tree, starting at the leaf level. 	 * Stop when we don't get a split block, that must mean that 	 * the insert is finished with this level. 	 */
do|do
block|{
comment|/* 		 * Insert nrec/nbno into this level of the tree. 		 * Note if we fail, nbno will be null. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_insrec
argument_list|(
name|pcur
argument_list|,
name|level
operator|++
argument_list|,
operator|&
name|nbno
argument_list|,
operator|&
name|nrec
argument_list|,
operator|&
name|ncur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pcur
operator|!=
name|cur
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|pcur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * See if the cursor we just used is trash. 		 * Can't trash the caller's cursor, but otherwise we should 		 * if ncur is a new cursor or we're about to be done. 		 */
if|if
condition|(
name|pcur
operator|!=
name|cur
operator|&&
operator|(
name|ncur
operator|||
name|nbno
operator|==
name|NULLAGBLOCK
operator|)
condition|)
block|{
name|cur
operator|->
name|bc_nlevels
operator|=
name|pcur
operator|->
name|bc_nlevels
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|pcur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we got a new cursor, switch to it. 		 */
if|if
condition|(
name|ncur
condition|)
block|{
name|pcur
operator|=
name|ncur
expr_stmt|;
name|ncur
operator|=
operator|(
name|xfs_btree_cur_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nbno
operator|!=
name|NULLAGBLOCK
condition|)
do|;
operator|*
name|stat
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the record equal to ino in the btree given by cur.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_lookup_eq
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_agino_t
name|ino
parameter_list|,
comment|/* starting inode of chunk */
name|__int32_t
name|fcnt
parameter_list|,
comment|/* free inode count */
name|xfs_inofree_t
name|free
parameter_list|,
comment|/* free inode mask */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_startino
operator|=
name|ino
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_freecount
operator|=
name|fcnt
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_free
operator|=
name|free
expr_stmt|;
return|return
name|xfs_inobt_lookup
argument_list|(
name|cur
argument_list|,
name|XFS_LOOKUP_EQ
argument_list|,
name|stat
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the first record greater than or equal to ino  * in the btree given by cur.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_lookup_ge
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_agino_t
name|ino
parameter_list|,
comment|/* starting inode of chunk */
name|__int32_t
name|fcnt
parameter_list|,
comment|/* free inode count */
name|xfs_inofree_t
name|free
parameter_list|,
comment|/* free inode mask */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_startino
operator|=
name|ino
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_freecount
operator|=
name|fcnt
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_free
operator|=
name|free
expr_stmt|;
return|return
name|xfs_inobt_lookup
argument_list|(
name|cur
argument_list|,
name|XFS_LOOKUP_GE
argument_list|,
name|stat
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the first record less than or equal to ino  * in the btree given by cur.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_lookup_le
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_agino_t
name|ino
parameter_list|,
comment|/* starting inode of chunk */
name|__int32_t
name|fcnt
parameter_list|,
comment|/* free inode count */
name|xfs_inofree_t
name|free
parameter_list|,
comment|/* free inode mask */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* success/failure */
block|{
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_startino
operator|=
name|ino
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_freecount
operator|=
name|fcnt
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|i
operator|.
name|ir_free
operator|=
name|free
expr_stmt|;
return|return
name|xfs_inobt_lookup
argument_list|(
name|cur
argument_list|,
name|XFS_LOOKUP_LE
argument_list|,
name|stat
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the record referred to by cur, to the value given  * by [ino, fcnt, free].  * This either works (return 0) or gets an EFSCORRUPTED error.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_inobt_update
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_agino_t
name|ino
parameter_list|,
comment|/* starting inode of chunk */
name|__int32_t
name|fcnt
parameter_list|,
comment|/* free inode count */
name|xfs_inofree_t
name|free
parameter_list|)
comment|/* free inode mask */
block|{
name|xfs_inobt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree block to update */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing btree block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|ptr
decl_stmt|;
comment|/* current record number (updating) */
name|xfs_inobt_rec_t
modifier|*
name|rp
decl_stmt|;
comment|/* pointer to updated record */
comment|/* 	 * Pick up the current block. 	 */
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
literal|0
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* 	 * Get the address of the rec to be updated. 	 */
name|ptr
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
literal|0
index|]
expr_stmt|;
name|rp
operator|=
name|XFS_INOBT_REC_ADDR
argument_list|(
name|block
argument_list|,
name|ptr
argument_list|,
name|cur
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the new contents and log them. 	 */
name|INT_SET
argument_list|(
name|rp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|rp
operator|->
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|fcnt
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|rp
operator|->
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|xfs_inobt_log_recs
argument_list|(
name|cur
argument_list|,
name|bp
argument_list|,
name|ptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* 	 * Updating first record in leaf. Pass new key value up to our parent. 	 */
if|if
condition|(
name|ptr
operator|==
literal|1
condition|)
block|{
name|xfs_inobt_key_t
name|key
decl_stmt|;
comment|/* key containing [ino] */
name|INT_SET
argument_list|(
name|key
operator|.
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_updkey
argument_list|(
name|cur
argument_list|,
operator|&
name|key
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

