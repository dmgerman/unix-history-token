begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|<linux/posix_acl_xattr.h>
end_include

begin_function_decl
name|STATIC
name|int
name|xfs_acl_setmode
parameter_list|(
name|xfs_vnode_t
modifier|*
parameter_list|,
name|xfs_acl_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_acl_filter_mode
parameter_list|(
name|mode_t
parameter_list|,
name|xfs_acl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_acl_get_endian
parameter_list|(
name|xfs_acl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_acl_access
parameter_list|(
name|uid_t
parameter_list|,
name|gid_t
parameter_list|,
name|xfs_acl_t
modifier|*
parameter_list|,
name|mode_t
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_acl_invalid
parameter_list|(
name|xfs_acl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_acl_sync_mode
parameter_list|(
name|mode_t
parameter_list|,
name|xfs_acl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_acl_get_attr
parameter_list|(
name|xfs_vnode_t
modifier|*
parameter_list|,
name|xfs_acl_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_acl_set_attr
parameter_list|(
name|xfs_vnode_t
modifier|*
parameter_list|,
name|xfs_acl_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_acl_allow_set
parameter_list|(
name|xfs_vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_acl_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Test for existence of access ACL attribute as efficiently as possible.  */
end_comment

begin_function
name|int
name|xfs_acl_vhasacl_access
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_acl_get_attr
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|,
name|ATTR_KERNOVAL
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for existence of default ACL attribute as efficiently as possible.  */
end_comment

begin_function
name|int
name|xfs_acl_vhasacl_default
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
literal|0
return|;
name|xfs_acl_get_attr
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|_ACL_TYPE_DEFAULT
argument_list|,
name|ATTR_KERNOVAL
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from extended attribute representation to in-memory for XFS.  */
end_comment

begin_function
name|STATIC
name|int
name|posix_acl_xattr_to_xfs
parameter_list|(
name|posix_acl_xattr_header
modifier|*
name|src
parameter_list|,
name|size_t
name|size
parameter_list|,
name|xfs_acl_t
modifier|*
name|dest
parameter_list|)
block|{
name|posix_acl_xattr_entry
modifier|*
name|src_entry
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|dest_entry
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|src
operator|||
operator|!
name|dest
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|posix_acl_xattr_header
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|src
operator|->
name|a_version
operator|!=
name|cpu_to_le32
argument_list|(
name|POSIX_ACL_XATTR_VERSION
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|memset
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_acl_t
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|acl_cnt
operator|=
name|posix_acl_xattr_count
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|acl_cnt
operator|<
literal|0
operator|||
name|dest
operator|->
name|acl_cnt
operator|>
name|XFS_ACL_MAX_ENTRIES
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * acl_set_file(3) may request that we set default ACLs with 	 * zero length -- defend (gracefully) against that here. 	 */
if|if
condition|(
operator|!
name|dest
operator|->
name|acl_cnt
condition|)
return|return
literal|0
return|;
name|src_entry
operator|=
operator|(
name|posix_acl_xattr_entry
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|src
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
operator|)
expr_stmt|;
name|dest_entry
operator|=
operator|&
name|dest
operator|->
name|acl_entry
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|dest
operator|->
name|acl_cnt
condition|;
name|n
operator|++
operator|,
name|src_entry
operator|++
operator|,
name|dest_entry
operator|++
control|)
block|{
name|dest_entry
operator|->
name|ae_perm
operator|=
name|le16_to_cpu
argument_list|(
name|src_entry
operator|->
name|e_perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|_ACL_PERM_INVALID
argument_list|(
name|dest_entry
operator|->
name|ae_perm
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|dest_entry
operator|->
name|ae_tag
operator|=
name|le16_to_cpu
argument_list|(
name|src_entry
operator|->
name|e_tag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dest_entry
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER
case|:
case|case
name|ACL_GROUP
case|:
name|dest_entry
operator|->
name|ae_id
operator|=
name|le32_to_cpu
argument_list|(
name|src_entry
operator|->
name|e_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACL_USER_OBJ
case|:
case|case
name|ACL_GROUP_OBJ
case|:
case|case
name|ACL_MASK
case|:
case|case
name|ACL_OTHER
case|:
name|dest_entry
operator|->
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
if|if
condition|(
name|xfs_acl_invalid
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Comparison function called from qsort().  * Primary key is ae_tag, secondary key is ae_id.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_acl_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
name|xfs_acl_entry_t
modifier|*
name|a
init|=
operator|(
name|xfs_acl_entry_t
operator|*
operator|)
name|va
decl_stmt|,
modifier|*
name|b
init|=
operator|(
name|xfs_acl_entry_t
operator|*
operator|)
name|vb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|ae_tag
operator|==
name|b
operator|->
name|ae_tag
condition|)
return|return
operator|(
name|a
operator|->
name|ae_id
operator|-
name|b
operator|->
name|ae_id
operator|)
return|;
return|return
operator|(
name|a
operator|->
name|ae_tag
operator|-
name|b
operator|->
name|ae_tag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from in-memory XFS to extended attribute representation.  */
end_comment

begin_function
name|STATIC
name|int
name|posix_acl_xfs_to_xattr
parameter_list|(
name|xfs_acl_t
modifier|*
name|src
parameter_list|,
name|posix_acl_xattr_header
modifier|*
name|dest
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|size_t
name|new_size
init|=
name|posix_acl_xattr_size
argument_list|(
name|src
operator|->
name|acl_cnt
argument_list|)
decl_stmt|;
name|posix_acl_xattr_entry
modifier|*
name|dest_entry
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|src_entry
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|new_size
condition|)
return|return
operator|-
name|ERANGE
return|;
comment|/* Need to sort src XFS ACL by<ae_tag,ae_id> */
name|qsort
argument_list|(
name|src
operator|->
name|acl_entry
argument_list|,
name|src
operator|->
name|acl_cnt
argument_list|,
sizeof|sizeof
argument_list|(
name|src
operator|->
name|acl_entry
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|xfs_acl_entry_compare
argument_list|)
expr_stmt|;
name|dest
operator|->
name|a_version
operator|=
name|cpu_to_le32
argument_list|(
name|POSIX_ACL_XATTR_VERSION
argument_list|)
expr_stmt|;
name|dest_entry
operator|=
operator|&
name|dest
operator|->
name|a_entries
index|[
literal|0
index|]
expr_stmt|;
name|src_entry
operator|=
operator|&
name|src
operator|->
name|acl_entry
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|src
operator|->
name|acl_cnt
condition|;
name|n
operator|++
operator|,
name|dest_entry
operator|++
operator|,
name|src_entry
operator|++
control|)
block|{
name|dest_entry
operator|->
name|e_perm
operator|=
name|cpu_to_le16
argument_list|(
name|src_entry
operator|->
name|ae_perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|_ACL_PERM_INVALID
argument_list|(
name|src_entry
operator|->
name|ae_perm
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|dest_entry
operator|->
name|e_tag
operator|=
name|cpu_to_le16
argument_list|(
name|src_entry
operator|->
name|ae_tag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_entry
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER
case|:
case|case
name|ACL_GROUP
case|:
name|dest_entry
operator|->
name|e_id
operator|=
name|cpu_to_le32
argument_list|(
name|src_entry
operator|->
name|ae_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACL_USER_OBJ
case|:
case|case
name|ACL_GROUP_OBJ
case|:
case|case
name|ACL_MASK
case|:
case|case
name|ACL_OTHER
case|:
name|dest_entry
operator|->
name|e_id
operator|=
name|cpu_to_le32
argument_list|(
name|ACL_UNDEFINED_ID
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
name|new_size
return|;
block|}
end_function

begin_function
name|int
name|xfs_acl_vget
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|acl
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_acl_t
modifier|*
name|xfs_acl
init|=
name|NULL
decl_stmt|;
name|posix_acl_xattr_header
modifier|*
name|ext_acl
init|=
name|acl
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|_MAC_VACCESS
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|VREAD
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_ACL_ALLOC
argument_list|(
name|xfs_acl
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
name|xfs_acl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_acl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|ATTR_KERNOVAL
expr_stmt|;
name|xfs_acl_get_attr
argument_list|(
name|vp
argument_list|,
name|xfs_acl
argument_list|,
name|kind
argument_list|,
name|flags
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|error
operator|=
operator|-
name|posix_acl_xattr_size
argument_list|(
name|XFS_ACL_MAX_ENTRIES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xfs_acl_invalid
argument_list|(
name|xfs_acl
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|kind
operator|==
name|_ACL_TYPE_ACCESS
condition|)
block|{
name|xfs_vattr_t
name|va
decl_stmt|;
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_MODE
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|sys_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|xfs_acl_sync_mode
argument_list|(
name|va
operator|.
name|va_mode
argument_list|,
name|xfs_acl
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|posix_acl_xfs_to_xattr
argument_list|(
name|xfs_acl
argument_list|,
name|ext_acl
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_acl
condition|)
name|_ACL_FREE
argument_list|(
name|xfs_acl
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|int
name|xfs_acl_vremove
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_acl_allow_set
argument_list|(
name|vp
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|XVOP_ATTR_REMOVE
argument_list|(
name|vp
argument_list|,
name|kind
operator|==
name|_ACL_TYPE_DEFAULT
condition|?
name|SGI_ACL_DEFAULT
else|:
name|SGI_ACL_FILE
argument_list|,
name|ATTR_ROOT
argument_list|,
name|sys_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOATTR
condition|)
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 'scool */
block|}
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|int
name|xfs_acl_vset
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|acl
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|posix_acl_xattr_header
modifier|*
name|ext_acl
init|=
name|acl
decl_stmt|;
name|xfs_acl_t
modifier|*
name|xfs_acl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|basicperms
init|=
literal|0
decl_stmt|;
comment|/* more than std unix perms? */
if|if
condition|(
operator|!
name|acl
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|_ACL_ALLOC
argument_list|(
name|xfs_acl
argument_list|)
operator|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|error
operator|=
name|posix_acl_xattr_to_xfs
argument_list|(
name|ext_acl
argument_list|,
name|size
argument_list|,
name|xfs_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|_ACL_FREE
argument_list|(
name|xfs_acl
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
if|if
condition|(
operator|!
name|xfs_acl
operator|->
name|acl_cnt
condition|)
block|{
name|_ACL_FREE
argument_list|(
name|xfs_acl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_acl_allow_set
argument_list|(
name|vp
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Incoming ACL exists, set file mode based on its value */
if|if
condition|(
name|kind
operator|==
name|_ACL_TYPE_ACCESS
condition|)
name|xfs_acl_setmode
argument_list|(
name|vp
argument_list|,
name|xfs_acl
argument_list|,
operator|&
name|basicperms
argument_list|)
expr_stmt|;
comment|/* 	 * If we have more than std unix permissions, set up the actual attr. 	 * Otherwise, delete any existing attr.  This prevents us from 	 * having actual attrs for permissions that can be stored in the 	 * standard permission bits. 	 */
if|if
condition|(
operator|!
name|basicperms
condition|)
block|{
name|xfs_acl_set_attr
argument_list|(
name|vp
argument_list|,
name|xfs_acl
argument_list|,
name|kind
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_acl_vremove
argument_list|(
name|vp
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|_ACL_FREE
argument_list|(
name|xfs_acl
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|int
name|xfs_acl_iaccess
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|xfs_acl_t
modifier|*
name|acl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_ACL_ALLOC
argument_list|(
name|acl
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If the file has no ACL return -1. */
if|if
condition|(
name|xfs_attr_fetch
argument_list|(
name|ip
argument_list|,
name|SGI_ACL_FILE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acl
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_acl_t
argument_list|)
argument_list|)
condition|)
block|{
name|_ACL_FREE
argument_list|(
name|acl
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xfs_acl_get_endian
argument_list|(
name|acl
argument_list|)
expr_stmt|;
comment|/* If the file has an empty ACL return -1. */
if|if
condition|(
name|acl
operator|->
name|acl_cnt
operator|==
name|XFS_ACL_NOT_PRESENT
condition|)
block|{
name|_ACL_FREE
argument_list|(
name|acl
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Synchronize ACL with mode bits */
name|xfs_acl_sync_mode
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
argument_list|,
name|acl
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_acl_access
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_uid
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_gid
argument_list|,
name|acl
argument_list|,
name|mode
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|_ACL_FREE
argument_list|(
name|acl
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_acl_allow_set
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_inode
operator|.
name|i_flags
operator|&
operator|(
name|S_IMMUTABLE
operator||
name|S_APPEND
operator|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|kind
operator|==
name|_ACL_TYPE_DEFAULT
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
name|ENOTDIR
return|;
if|if
condition|(
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
return|return
name|EROFS
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|_MAC_VACCESS
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|VWRITE
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_UID
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|va
operator|.
name|va_uid
operator|!=
name|current
operator|->
name|fsuid
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_FOWNER
argument_list|)
condition|)
return|return
name|EPERM
return|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Look for any effective exec access, to allow CAP_DAC_OVERRIDE for exec.  * Ignore checking for exec in USER_OBJ when there is no mask, because  * in this "minimal acl" case we don't have any actual acls, and we  * won't even be here.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_acl_find_any_exec
parameter_list|(
name|xfs_acl_t
modifier|*
name|fap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|masked_aces
init|=
literal|0
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fap
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
block|{
if|if
condition|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
operator|&
operator|(
name|ACL_USER_OBJ
operator||
name|ACL_OTHER
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
operator|==
name|ACL_MASK
condition|)
name|mask
operator|=
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
expr_stmt|;
else|else
name|masked_aces
operator||=
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|masked_aces
operator|)
operator|&
name|ACL_EXECUTE
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The access control process to determine the access permission:  *	if uid == file owner id, use the file owner bits.  *	if gid == file owner group id, use the file group bits.  *	scan ACL for a maching user or group, and use matched entry  *	permission. Use total permissions of all matching group entries,  *	until all acl entries are exhausted. The final permission produced  *	by matching acl entry or entries needs to be& with group permission.  *	if not owner, owning group, or matching entry in ACL, use file  *	other bits.  Don't allow CAP_DAC_OVERRIDE on exec access unless  *	there is some effective exec access somewhere.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_acl_capability_check
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|xfs_acl_t
modifier|*
name|fap
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|ACL_READ
operator|)
operator|&&
operator|!
name|capable_cred
argument_list|(
name|cr
argument_list|,
name|CAP_DAC_READ_SEARCH
argument_list|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
operator|(
name|mode
operator|&
name|ACL_WRITE
operator|)
operator|&&
operator|!
name|capable_cred
argument_list|(
name|cr
argument_list|,
name|CAP_DAC_OVERRIDE
argument_list|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
operator|(
name|mode
operator|&
name|ACL_EXECUTE
operator|)
operator|&&
operator|(
operator|!
name|capable_cred
argument_list|(
name|cr
argument_list|,
name|CAP_DAC_OVERRIDE
argument_list|)
operator|||
operator|!
name|xfs_acl_find_any_exec
argument_list|(
name|fap
argument_list|)
operator|)
condition|)
block|{
return|return
name|EACCES
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Note: cr is only used here for the capability check if the ACL test fails.  *       It is not used to find out the credentials uid or groups etc, as was  *       done in IRIX. It is assumed that the uid and groups for the current  *       thread are taken from "current" instead of the cr parameter.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_acl_access
parameter_list|(
name|uid_t
name|fuid
parameter_list|,
name|gid_t
name|fgid
parameter_list|,
name|xfs_acl_t
modifier|*
name|fap
parameter_list|,
name|mode_t
name|md
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|xfs_acl_entry_t
name|matched
decl_stmt|;
name|int
name|i
decl_stmt|,
name|allows
decl_stmt|;
name|int
name|maskallows
init|=
operator|-
literal|1
decl_stmt|;
comment|/* true, but not 1, either */
name|int
name|seen_userobj
init|=
literal|0
decl_stmt|;
name|matched
operator|.
name|ae_tag
operator|=
literal|0
expr_stmt|;
comment|/* Invalid type */
name|md
operator|>>=
literal|6
expr_stmt|;
comment|/* Normalize the bits for comparison */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fap
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Break out if we've got a user_obj entry or 		 * a user entry and the mask (and have processed USER_OBJ) 		 */
if|if
condition|(
name|matched
operator|.
name|ae_tag
operator|==
name|ACL_USER_OBJ
condition|)
break|break;
if|if
condition|(
name|matched
operator|.
name|ae_tag
operator|==
name|ACL_USER
condition|)
block|{
if|if
condition|(
name|maskallows
operator|!=
operator|-
literal|1
operator|&&
name|seen_userobj
condition|)
break|break;
if|if
condition|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
operator|!=
name|ACL_MASK
operator|&&
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
operator|!=
name|ACL_USER_OBJ
condition|)
continue|continue;
block|}
comment|/* True if this entry allows the requested access */
name|allows
operator|=
operator|(
operator|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|md
operator|)
operator|==
name|md
operator|)
expr_stmt|;
switch|switch
condition|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|seen_userobj
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fuid
operator|!=
name|current
operator|->
name|fsuid
condition|)
continue|continue;
name|matched
operator|.
name|ae_tag
operator|=
name|ACL_USER_OBJ
expr_stmt|;
name|matched
operator|.
name|ae_perm
operator|=
name|allows
expr_stmt|;
break|break;
case|case
name|ACL_USER
case|:
if|if
condition|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|current
operator|->
name|fsuid
condition|)
continue|continue;
name|matched
operator|.
name|ae_tag
operator|=
name|ACL_USER
expr_stmt|;
name|matched
operator|.
name|ae_perm
operator|=
name|allows
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
operator|(
name|matched
operator|.
name|ae_tag
operator|==
name|ACL_GROUP_OBJ
operator|||
name|matched
operator|.
name|ae_tag
operator|==
name|ACL_GROUP
operator|)
operator|&&
operator|!
name|allows
condition|)
continue|continue;
if|if
condition|(
operator|!
name|in_group_p
argument_list|(
name|fgid
argument_list|)
condition|)
continue|continue;
name|matched
operator|.
name|ae_tag
operator|=
name|ACL_GROUP_OBJ
expr_stmt|;
name|matched
operator|.
name|ae_perm
operator|=
name|allows
expr_stmt|;
break|break;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
operator|(
name|matched
operator|.
name|ae_tag
operator|==
name|ACL_GROUP_OBJ
operator|||
name|matched
operator|.
name|ae_tag
operator|==
name|ACL_GROUP
operator|)
operator|&&
operator|!
name|allows
condition|)
continue|continue;
if|if
condition|(
operator|!
name|in_group_p
argument_list|(
name|fap
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
argument_list|)
condition|)
continue|continue;
name|matched
operator|.
name|ae_tag
operator|=
name|ACL_GROUP
expr_stmt|;
name|matched
operator|.
name|ae_perm
operator|=
name|allows
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
name|maskallows
operator|=
name|allows
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
if|if
condition|(
name|matched
operator|.
name|ae_tag
operator|!=
literal|0
condition|)
continue|continue;
name|matched
operator|.
name|ae_tag
operator|=
name|ACL_OTHER
expr_stmt|;
name|matched
operator|.
name|ae_perm
operator|=
name|allows
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * First possibility is that no matched entry allows access. 	 * The capability to override DAC may exist, so check for it. 	 */
switch|switch
condition|(
name|matched
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_OTHER
case|:
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|matched
operator|.
name|ae_perm
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|ACL_USER
case|:
case|case
name|ACL_GROUP_OBJ
case|:
case|case
name|ACL_GROUP
case|:
if|if
condition|(
name|maskallows
operator|&&
name|matched
operator|.
name|ae_perm
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|0
case|:
break|break;
block|}
return|return
name|xfs_acl_capability_check
argument_list|(
name|md
argument_list|,
name|cr
argument_list|,
name|fap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ACL validity checker.  *   This acl validation routine checks each ACL entry read in makes sense.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_acl_invalid
parameter_list|(
name|xfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|xfs_acl_entry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|user
init|=
literal|0
decl_stmt|,
name|group
init|=
literal|0
decl_stmt|,
name|other
init|=
literal|0
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|mask_required
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|aclp
condition|)
goto|goto
name|acl_invalid
goto|;
if|if
condition|(
name|aclp
operator|->
name|acl_cnt
operator|>
name|XFS_ACL_MAX_ENTRIES
condition|)
goto|goto
name|acl_invalid
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|user
operator|++
condition|)
goto|goto
name|acl_invalid
goto|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
name|group
operator|++
condition|)
goto|goto
name|acl_invalid
goto|;
break|break;
case|case
name|ACL_OTHER
case|:
if|if
condition|(
name|other
operator|++
condition|)
goto|goto
name|acl_invalid
goto|;
break|break;
case|case
name|ACL_USER
case|:
case|case
name|ACL_GROUP
case|:
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|j
operator|++
control|)
block|{
name|e
operator|=
operator|&
name|aclp
operator|->
name|acl_entry
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|ae_id
operator|==
name|entry
operator|->
name|ae_id
operator|&&
name|e
operator|->
name|ae_tag
operator|==
name|entry
operator|->
name|ae_tag
condition|)
goto|goto
name|acl_invalid
goto|;
block|}
name|mask_required
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
if|if
condition|(
name|mask
operator|++
condition|)
goto|goto
name|acl_invalid
goto|;
break|break;
default|default:
goto|goto
name|acl_invalid
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|user
operator|||
operator|!
name|group
operator|||
operator|!
name|other
operator|||
operator|(
name|mask_required
operator|&&
operator|!
name|mask
operator|)
condition|)
goto|goto
name|acl_invalid
goto|;
else|else
return|return
literal|0
return|;
name|acl_invalid
label|:
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Do ACL endian conversion.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_acl_get_endian
parameter_list|(
name|xfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|xfs_acl_entry_t
modifier|*
name|ace
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|INT_SET
argument_list|(
name|aclp
operator|->
name|acl_cnt
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|aclp
operator|->
name|acl_cnt
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
name|aclp
operator|->
name|acl_entry
index|[
literal|0
index|]
operator|+
name|aclp
operator|->
name|acl_cnt
expr_stmt|;
for|for
control|(
name|ace
operator|=
operator|&
name|aclp
operator|->
name|acl_entry
index|[
literal|0
index|]
init|;
name|ace
operator|<
name|end
condition|;
name|ace
operator|++
control|)
block|{
name|INT_SET
argument_list|(
name|ace
operator|->
name|ae_tag
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ace
operator|->
name|ae_tag
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|ace
operator|->
name|ae_id
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ace
operator|->
name|ae_id
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|ace
operator|->
name|ae_perm
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ace
operator|->
name|ae_perm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the ACL from the EA and do endian conversion.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_acl_get_attr
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|kind
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|xfs_acl_t
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|flags
operator|&
name|ATTR_KERNOVAL
operator|)
condition|?
operator|(
name|aclp
operator|==
name|NULL
operator|)
else|:
literal|1
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ATTR_ROOT
expr_stmt|;
name|XVOP_ATTR_GET
argument_list|(
name|vp
argument_list|,
name|kind
operator|==
name|_ACL_TYPE_ACCESS
condition|?
name|SGI_ACL_FILE
else|:
name|SGI_ACL_DEFAULT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aclp
argument_list|,
operator|&
name|len
argument_list|,
name|flags
argument_list|,
name|sys_cred
argument_list|,
operator|*
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|error
operator|||
operator|(
name|flags
operator|&
name|ATTR_KERNOVAL
operator|)
condition|)
return|return;
name|xfs_acl_get_endian
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the EA with the ACL and do endian conversion.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_acl_set_attr
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|kind
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|xfs_acl_entry_t
modifier|*
name|ace
decl_stmt|,
modifier|*
name|newace
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|xfs_acl_t
modifier|*
name|newacl
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_ACL_ALLOC
argument_list|(
name|newacl
argument_list|)
operator|)
condition|)
block|{
operator|*
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_acl_t
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|xfs_acl_entry_t
argument_list|)
operator|*
operator|(
name|XFS_ACL_MAX_ENTRIES
operator|-
name|aclp
operator|->
name|acl_cnt
operator|)
operator|)
expr_stmt|;
name|end
operator|=
operator|&
name|aclp
operator|->
name|acl_entry
index|[
literal|0
index|]
operator|+
name|aclp
operator|->
name|acl_cnt
expr_stmt|;
for|for
control|(
name|ace
operator|=
operator|&
name|aclp
operator|->
name|acl_entry
index|[
literal|0
index|]
operator|,
name|newace
operator|=
operator|&
name|newacl
operator|->
name|acl_entry
index|[
literal|0
index|]
init|;
name|ace
operator|<
name|end
condition|;
name|ace
operator|++
operator|,
name|newace
operator|++
control|)
block|{
name|INT_SET
argument_list|(
name|newace
operator|->
name|ae_tag
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ace
operator|->
name|ae_tag
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|newace
operator|->
name|ae_id
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ace
operator|->
name|ae_id
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|newace
operator|->
name|ae_perm
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ace
operator|->
name|ae_perm
argument_list|)
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|newacl
operator|->
name|acl_cnt
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|aclp
operator|->
name|acl_cnt
argument_list|)
expr_stmt|;
name|XVOP_ATTR_SET
argument_list|(
name|vp
argument_list|,
name|kind
operator|==
name|_ACL_TYPE_ACCESS
condition|?
name|SGI_ACL_FILE
else|:
name|SGI_ACL_DEFAULT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newacl
argument_list|,
name|len
argument_list|,
name|ATTR_ROOT
argument_list|,
name|sys_cred
argument_list|,
operator|*
name|error
argument_list|)
expr_stmt|;
name|_ACL_FREE
argument_list|(
name|newacl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xfs_acl_vtoacl
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_acl_t
modifier|*
name|access_acl
parameter_list|,
name|xfs_acl_t
modifier|*
name|default_acl
parameter_list|)
block|{
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access_acl
condition|)
block|{
comment|/* 		 * Get the Access ACL and the mode.  If either cannot 		 * be obtained for some reason, invalidate the access ACL. 		 */
name|xfs_acl_get_attr
argument_list|(
name|vp
argument_list|,
name|access_acl
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* Got the ACL, need the mode... */
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_MODE
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|sys_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|access_acl
operator|->
name|acl_cnt
operator|=
name|XFS_ACL_NOT_PRESENT
expr_stmt|;
else|else
comment|/* We have a good ACL and the file mode, synchronize. */
name|xfs_acl_sync_mode
argument_list|(
name|va
operator|.
name|va_mode
argument_list|,
name|access_acl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|default_acl
condition|)
block|{
name|xfs_acl_get_attr
argument_list|(
name|vp
argument_list|,
name|default_acl
argument_list|,
name|_ACL_TYPE_DEFAULT
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|default_acl
operator|->
name|acl_cnt
operator|=
name|XFS_ACL_NOT_PRESENT
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This function retrieves the parent directory's acl, processes it  * and lets the child inherit the acl(s) that it should.  */
end_comment

begin_function
name|int
name|xfs_acl_inherit
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_vattr_t
modifier|*
name|vap
parameter_list|,
name|xfs_acl_t
modifier|*
name|pdaclp
parameter_list|)
block|{
name|xfs_acl_t
modifier|*
name|cacl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|basicperms
init|=
literal|0
decl_stmt|;
comment|/* 	 * If the parent does not have a default ACL, or it's an 	 * invalid ACL, we're done. 	 */
if|if
condition|(
operator|!
name|vp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|pdaclp
operator|||
name|xfs_acl_invalid
argument_list|(
name|pdaclp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Copy the default ACL of the containing directory to 	 * the access ACL of the new file and use the mode that 	 * was passed in to set up the correct initial values for 	 * the u::,g::[m::], and o:: entries.  This is what makes 	 * umask() "work" with ACL's. 	 */
if|if
condition|(
operator|!
operator|(
name|_ACL_ALLOC
argument_list|(
name|cacl
argument_list|)
operator|)
condition|)
return|return
name|ENOMEM
return|;
name|memcpy
argument_list|(
name|cacl
argument_list|,
name|pdaclp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_acl_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_acl_filter_mode
argument_list|(
name|vap
operator|->
name|va_mode
argument_list|,
name|cacl
argument_list|)
expr_stmt|;
name|xfs_acl_setmode
argument_list|(
name|vp
argument_list|,
name|cacl
argument_list|,
operator|&
name|basicperms
argument_list|)
expr_stmt|;
comment|/* 	 * Set the Default and Access ACL on the file.  The mode is already 	 * set on the file, so we don't need to worry about that. 	 * 	 * If the new file is a directory, its default ACL is a copy of 	 * the containing directory's default ACL. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|xfs_acl_set_attr
argument_list|(
name|vp
argument_list|,
name|pdaclp
argument_list|,
name|_ACL_TYPE_DEFAULT
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|basicperms
condition|)
name|xfs_acl_set_attr
argument_list|(
name|vp
argument_list|,
name|cacl
argument_list|,
name|_ACL_TYPE_ACCESS
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|_ACL_FREE
argument_list|(
name|cacl
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the correct mode on the file based on the supplied ACL.  This  * makes sure that the mode on the file reflects the state of the  * u::,g::[m::], and o:: entries in the ACL.  Since the mode is where  * the ACL is going to get the permissions for these entries, we must  * synchronize the mode whenever we set the ACL on a file.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_acl_setmode
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_acl_t
modifier|*
name|acl
parameter_list|,
name|int
modifier|*
name|basicperms
parameter_list|)
block|{
name|xfs_vattr_t
name|va
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|ap
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|gap
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|nomask
init|=
literal|1
decl_stmt|;
operator|*
name|basicperms
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_cnt
operator|==
name|XFS_ACL_NOT_PRESENT
condition|)
return|return
literal|0
return|;
comment|/* 	 * Copy the u::, g::, o::, and m:: bits from the ACL into the 	 * mode.  The m:: bits take precedence over the g:: bits. 	 */
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_MODE
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|sys_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_MODE
expr_stmt|;
name|va
operator|.
name|va_mode
operator|&=
operator|~
operator|(
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
expr_stmt|;
name|ap
operator|=
name|acl
operator|->
name|acl_entry
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|va
operator|.
name|va_mode
operator||=
name|ap
operator|->
name|ae_perm
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|gap
operator|=
name|ap
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
comment|/* more than just standard modes */
name|nomask
operator|=
literal|0
expr_stmt|;
name|va
operator|.
name|va_mode
operator||=
name|ap
operator|->
name|ae_perm
operator|<<
literal|3
expr_stmt|;
operator|*
name|basicperms
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|va
operator|.
name|va_mode
operator||=
name|ap
operator|->
name|ae_perm
expr_stmt|;
break|break;
default|default:
comment|/* more than just standard modes */
operator|*
name|basicperms
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ap
operator|++
expr_stmt|;
block|}
comment|/* Set the group bits from ACL_GROUP_OBJ if there's no ACL_MASK */
if|if
condition|(
name|gap
operator|&&
name|nomask
condition|)
name|va
operator|.
name|va_mode
operator||=
name|gap
operator|->
name|ae_perm
operator|<<
literal|3
expr_stmt|;
name|XVOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|sys_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * The permissions for the special ACL entries (u::, g::[m::], o::) are  * actually stored in the file mode (if there is both a group and a mask,  * the group is stored in the ACL entry and the mask is stored on the file).  * This allows the mode to remain automatically in sync with the ACL without  * the need for a call-back to the ACL system at every point where the mode  * could change.  This function takes the permissions from the specified mode  * and places it in the supplied ACL.  *  * This implementation draws its validity from the fact that, when the ACL  * was assigned, the mode was copied from the ACL.  * If the mode did not change, therefore, the mode remains exactly what was  * taken from the special ACL entries at assignment.  * If a subsequent chmod() was done, the POSIX spec says that the change in  * mode must cause an update to the ACL seen at user level and used for  * access checks.  Before and after a mode change, therefore, the file mode  * most accurately reflects what the special ACL entries should permit/deny.  *  * CAVEAT: If someone sets the SGI_ACL_FILE attribute directly,  *         the existing mode bits will override whatever is in the  *         ACL. Similarly, if there is a pre-existing ACL that was  *         never in sync with its mode (owing to a bug in 6.5 and  *         before), it will now magically (or mystically) be  *         synchronized.  This could cause slight astonishment, but  *         it is better than inconsistent permissions.  *  * The supplied ACL is a template that may contain any combination  * of special entries.  These are treated as place holders when we fill  * out the ACL.  This routine does not add or remove special entries, it  * simply unites each special entry with its associated set of permissions.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_acl_sync_mode
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|xfs_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nomask
init|=
literal|1
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|ap
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|gap
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Set ACL entries. POSIX1003.1eD16 requires that the MASK 	 * be set instead of the GROUP entry, if there is a MASK. 	 */
for|for
control|(
name|ap
operator|=
name|acl
operator|->
name|acl_entry
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|ap
operator|++
operator|,
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|ap
operator|->
name|ae_perm
operator|=
operator|(
name|mode
operator|>>
literal|6
operator|)
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|gap
operator|=
name|ap
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
name|nomask
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|ae_perm
operator|=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|ap
operator|->
name|ae_perm
operator|=
name|mode
operator|&
literal|0x7
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Set the ACL_GROUP_OBJ if there's no ACL_MASK */
if|if
condition|(
name|gap
operator|&&
name|nomask
condition|)
name|gap
operator|->
name|ae_perm
operator|=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When inheriting an Access ACL from a directory Default ACL,  * the ACL bits are set to the intersection of the ACL default  * permission bits and the file permission bits in mode. If there  * are no permission bits on the file then we must not give them  * the ACL. This is what what makes umask() work with ACLs.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_acl_filter_mode
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|xfs_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nomask
init|=
literal|1
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|ap
decl_stmt|;
name|xfs_acl_entry_t
modifier|*
name|gap
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Set ACL entries. POSIX1003.1eD16 requires that the MASK 	 * be merged with GROUP entry, if there is a MASK. 	 */
for|for
control|(
name|ap
operator|=
name|acl
operator|->
name|acl_entry
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|ap
operator|++
operator|,
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|ap
operator|->
name|ae_perm
operator|&=
operator|(
name|mode
operator|>>
literal|6
operator|)
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|gap
operator|=
name|ap
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
name|nomask
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|ae_perm
operator|&=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|ap
operator|->
name|ae_perm
operator|&=
name|mode
operator|&
literal|0x7
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Set the ACL_GROUP_OBJ if there's no ACL_MASK */
if|if
condition|(
name|gap
operator|&&
name|nomask
condition|)
name|gap
operator|->
name|ae_perm
operator|&=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
block|}
end_function

end_unit

