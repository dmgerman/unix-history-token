begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_comment
comment|/*  * This is a subroutine for xfs_write() and other writers (xfs_ioctl)  * which clears the setuid and setgid bits when a file is written.  */
end_comment

begin_function
name|int
name|xfs_write_clear_setuid
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_WRITEID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_WRITEID_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
comment|/* 	 * Note that we don't have to worry about mandatory 	 * file locking being disabled here because we only 	 * clear the S_ISGID bit if the Group execute bit is 	 * on, but if it was on then mandatory locking wouldn't 	 * have been enabled. 	 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IXGRP
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
block|}
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Force a shutdown of the filesystem instantly while keeping  * the filesystem consistent. We don't do an unmount here; just shutdown  * the shop, make sure that absolutely nothing persistent happens to  * this filesystem after this point.  */
end_comment

begin_function
name|void
name|xfs_do_force_shutdown
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|lnnum
parameter_list|)
block|{
name|int
name|logerror
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|logerror
operator|=
name|flags
operator|&
name|XFS_LOG_IO_ERROR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_FORCE_UMOUNT
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"xfs_force_shutdown(%s,0x%x) called from line %d of file %s.  Return address = 0x%p"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|,
name|flags
argument_list|,
name|lnnum
argument_list|,
name|fname
argument_list|,
name|__return_address
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No need to duplicate efforts. 	 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
operator|&&
operator|!
name|logerror
condition|)
return|return;
comment|/* 	 * This flags XFS_MOUNT_FS_SHUTDOWN, makes sure that we don't 	 * queue up anybody new on the log reservations, and wakes up 	 * everybody who's sleeping on log reservations and tells 	 * them the bad news. 	 */
if|if
condition|(
name|xfs_log_force_umount
argument_list|(
name|mp
argument_list|,
name|logerror
argument_list|)
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|XFS_CORRUPT_INCORE
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_SHUTDOWN_CORRUPT
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"Corruption of in-memory data detected.  Shutting down filesystem: %s"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_ERRLEVEL_HIGH
operator|<=
name|xfs_error_level
condition|)
block|{
name|xfs_stack_trace
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_FORCE_UMOUNT
operator|)
condition|)
block|{
if|if
condition|(
name|logerror
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_SHUTDOWN_LOGERROR
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"Log I/O Error Detected.  Shutting down filesystem: %s"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_SHUTDOWN_REMOTE_REQ
operator|)
condition|)
block|{
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_SHUTDOWN_IOERROR
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"I/O Error Detected.  Shutting down filesystem: %s"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_FORCE_UMOUNT
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"Please umount the filesystem, and rectify the problem(s)"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called when we want to stop a buffer from getting written or read.  * We attach the EIO error, muck with its flags, and call biodone  * so that the proper iodone callbacks get called.  */
end_comment

begin_function
name|int
name|xfs_bioerror
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XFSERRORDEBUG
name|ASSERT
argument_list|(
name|XFS_BUF_ISREAD
argument_list|(
name|bp
argument_list|)
operator|||
name|bp
operator|->
name|b_iodone
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * No need to wait until the buffer is unpinned. 	 * We aren't flushing it. 	 */
name|xfs_buftrace
argument_list|(
literal|"XFS IOERROR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_ERROR
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
comment|/* 	 * We're calling biodone, so delete B_DONE flag. Either way 	 * we have to call the iodone callback, and calling biodone 	 * probably is the best way since it takes care of 	 * GRIO as well. 	 */
name|XFS_BUF_UNREAD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as xfs_bioerror, except that we are releasing the buffer  * here ourselves, and avoiding the biodone call.  * This is meant for userdata errors; metadata bufs come with  * iodone functions attached, so that we can track down errors.  */
end_comment

begin_function
name|int
name|xfs_bioerror_relse
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|int64_t
name|fl
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|!=
name|xfs_buf_iodone_callbacks
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
operator|!=
name|xlog_iodone
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"XFS IOERRELSE"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|fl
operator|=
name|XFS_BUF_BFLAGS
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * No need to wait until the buffer is unpinned. 	 * We aren't flushing it. 	 * 	 * chunkhold expects B_DONE to be set, whether 	 * we actually finish the I/O or not. We don't want to 	 * change that interface. 	 */
name|XFS_BUF_UNREAD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fl
operator|&
name|XFS_B_ASYNC
operator|)
condition|)
block|{
comment|/* 		 * Mark b_error and B_ERROR _both_. 		 * Lot's of chunkcache code assumes that. 		 * There's no reason to mark error for 		 * ASYNC buffers. 		 */
name|XFS_BUF_ERROR
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|XFS_BUF_V_IODONESEMA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prints out an ALERT message about I/O error.  */
end_comment

begin_function
name|void
name|xfs_ioerror_alert
parameter_list|(
name|char
modifier|*
name|func
parameter_list|,
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|)
block|{
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"I/O error in filesystem (\"%s\") meta-data dev %s block 0x%llx"
literal|"       (\"%s\") error %d buf count %zd"
argument_list|,
operator|(
operator|!
name|mp
operator|||
operator|!
name|mp
operator|->
name|m_fsname
operator|)
condition|?
literal|"(fs name not set)"
else|:
name|mp
operator|->
name|m_fsname
argument_list|,
name|XFS_BUFTARG_NAME
argument_list|(
name|XFS_BUF_TARGET
argument_list|(
name|bp
argument_list|)
argument_list|)
argument_list|,
operator|(
name|__uint64_t
operator|)
name|blkno
argument_list|,
name|func
argument_list|,
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This isn't an absolute requirement, but it is  * just a good idea to call xfs_read_buf instead of  * directly doing a read_buf call. For one, we shouldn't  * be doing this disk read if we are in SHUTDOWN state anyway,  * so this stops that from happening. Secondly, this does all  * the error checking stuff and the brelse if appropriate for  * the caller, so the code can be a little leaner.  */
end_comment

begin_function
name|int
name|xfs_read_buf
parameter_list|(
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|target
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|,
name|int
name|len
parameter_list|,
name|uint
name|flags
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|flags
condition|)
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|target
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|bp
operator|=
name|xfs_buf_read
argument_list|(
name|target
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|&&
operator|!
name|error
operator|&&
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_read_buf"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
block|{
name|XFS_BUF_UNDONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * brelse clears B_ERROR and b_error 			 */
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper around bwrite() so that we can trap  * write errors, and act accordingly.  */
end_comment

begin_function
name|int
name|xfs_bwrite
parameter_list|(
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|,
name|struct
name|xfs_buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * XXXsup how does this work for quotas. 	 */
name|XFS_BUF_SET_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|,
name|xfs_bdstrat_cb
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE3
argument_list|(
name|bp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_WRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_bwrite
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 		 * Cannot put a buftrace here since if the buffer is not 		 * B_HOLD then we will brelse() the buffer before returning 		 * from bwrite and we could be tracing a buffer that has 		 * been reused. 		 */
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

