begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_refcache.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_comment
comment|/*  * Given an array of up to 4 inode pointers, unlock the pointed to inodes.  * If there are fewer than 4 entries in the array, the empty entries will  * be at the end and will have NULL pointers in them.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_rename_unlock4
parameter_list|(
name|xfs_inode_t
modifier|*
modifier|*
name|i_tab
parameter_list|,
name|uint
name|lock_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xfs_iunlock
argument_list|(
name|i_tab
index|[
literal|0
index|]
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i_tab
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 		 * Watch out for duplicate entries in the table. 		 */
if|if
condition|(
name|i_tab
index|[
name|i
index|]
operator|!=
name|i_tab
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|i_tab
index|[
name|i
index|]
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|xfs_rename_skip
decl_stmt|,
name|xfs_rename_nskip
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following routine will acquire the locks required for a rename  * operation. The code understands the semantics of renames and will  * validate that name1 exists under dp1& that name2 may or may not  * exist under dp2.  *  * We are renaming dp1/name1 to dp2/name2.  *  * Return ENOENT if dp1 does not exist, other lookup errors, or 0 for success.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_lock_for_rename
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp1
parameter_list|,
comment|/* old (source) directory inode */
name|xfs_inode_t
modifier|*
name|dp2
parameter_list|,
comment|/* new (target) directory inode */
name|vname_t
modifier|*
name|vname1
parameter_list|,
comment|/* old entry name */
name|vname_t
modifier|*
name|vname2
parameter_list|,
comment|/* new entry name */
name|xfs_inode_t
modifier|*
modifier|*
name|ipp1
parameter_list|,
comment|/* inode of old entry */
name|xfs_inode_t
modifier|*
modifier|*
name|ipp2
parameter_list|,
comment|/* inode of new entry, if it 				   already exists, NULL otherwise. */
name|xfs_inode_t
modifier|*
modifier|*
name|i_tab
parameter_list|,
comment|/* array of inode returned, sorted */
name|int
modifier|*
name|num_inodes
parameter_list|)
comment|/* number of inodes in array */
block|{
name|xfs_inode_t
modifier|*
name|ip1
decl_stmt|,
modifier|*
name|ip2
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|xfs_ino_t
name|inum1
decl_stmt|,
name|inum2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint
name|lock_mode
decl_stmt|;
name|int
name|diff_dirs
init|=
operator|(
name|dp1
operator|!=
name|dp2
operator|)
decl_stmt|;
name|ip2
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * First, find out the current inums of the entries so that we 	 * can determine the initial locking order.  We'll have to 	 * sanity check stuff after all the locks have been acquired 	 * to see if we still have the right inodes, directories, etc. 	 */
name|lock_mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|dp1
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_get_dir_entry
argument_list|(
name|vname1
argument_list|,
operator|&
name|ip1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock_map_shared
argument_list|(
name|dp1
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|inum1
operator|=
name|ip1
operator|->
name|i_ino
expr_stmt|;
name|ASSERT
argument_list|(
name|ip1
argument_list|)
expr_stmt|;
name|ITRACE
argument_list|(
name|ip1
argument_list|)
expr_stmt|;
comment|/* 	 * Unlock dp1 and lock dp2 if they are different. 	 */
if|if
condition|(
name|diff_dirs
condition|)
block|{
name|xfs_iunlock_map_shared
argument_list|(
name|dp1
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|lock_mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|dp2
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_dir_lookup_int
argument_list|(
name|XFS_ITOBHV
argument_list|(
name|dp2
argument_list|)
argument_list|,
name|lock_mode
argument_list|,
name|vname2
argument_list|,
operator|&
name|inum2
argument_list|,
operator|&
name|ip2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* target does not need to exist. */
name|inum2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If dp2 and dp1 are the same, the next line unlocks dp1. 		 * Got it? 		 */
name|xfs_iunlock_map_shared
argument_list|(
name|dp2
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
block|{
name|ITRACE
argument_list|(
name|ip2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * i_tab contains a list of pointers to inodes.  We initialize 	 * the table here& we'll sort it.  We will then use it to 	 * order the acquisition of the inode locks. 	 * 	 * Note that the table may contain duplicates.  e.g., dp1 == dp2. 	 */
name|i_tab
index|[
literal|0
index|]
operator|=
name|dp1
expr_stmt|;
name|i_tab
index|[
literal|1
index|]
operator|=
name|dp2
expr_stmt|;
name|i_tab
index|[
literal|2
index|]
operator|=
name|ip1
expr_stmt|;
if|if
condition|(
name|inum2
operator|==
literal|0
condition|)
block|{
operator|*
name|num_inodes
operator|=
literal|3
expr_stmt|;
name|i_tab
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|num_inodes
operator|=
literal|4
expr_stmt|;
name|i_tab
index|[
literal|3
index|]
operator|=
name|ip2
expr_stmt|;
block|}
comment|/* 	 * Sort the elements via bubble sort.  (Remember, there are at 	 * most 4 elements to sort, so this is adequate.) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_inodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|*
name|num_inodes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i_tab
index|[
name|j
index|]
operator|->
name|i_ino
operator|<
name|i_tab
index|[
name|j
operator|-
literal|1
index|]
operator|->
name|i_ino
condition|)
block|{
name|temp
operator|=
name|i_tab
index|[
name|j
index|]
expr_stmt|;
name|i_tab
index|[
name|j
index|]
operator|=
name|i_tab
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|i_tab
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * We have dp2 locked. If it isn't first, unlock it. 	 * If it is first, tell xfs_lock_inodes so it can skip it 	 * when locking. if dp1 == dp2, xfs_lock_inodes will skip both 	 * since they are equal. xfs_lock_inodes needs all these inodes 	 * so that it can unlock and retry if there might be a dead-lock 	 * potential with the log. 	 */
if|if
condition|(
name|i_tab
index|[
literal|0
index|]
operator|==
name|dp2
operator|&&
name|lock_mode
operator|==
name|XFS_ILOCK_SHARED
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_rename_skip
operator|++
expr_stmt|;
endif|#
directive|endif
name|xfs_lock_inodes
argument_list|(
name|i_tab
argument_list|,
operator|*
name|num_inodes
argument_list|,
literal|1
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_rename_nskip
operator|++
expr_stmt|;
endif|#
directive|endif
name|xfs_iunlock_map_shared
argument_list|(
name|dp2
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|xfs_lock_inodes
argument_list|(
name|i_tab
argument_list|,
operator|*
name|num_inodes
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the return value. Null out any unused entries in i_tab. 	 */
operator|*
name|ipp1
operator|=
operator|*
name|ipp2
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_inodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i_tab
index|[
name|i
index|]
operator|->
name|i_ino
operator|==
name|inum1
condition|)
block|{
operator|*
name|ipp1
operator|=
name|i_tab
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i_tab
index|[
name|i
index|]
operator|->
name|i_ino
operator|==
name|inum2
condition|)
block|{
operator|*
name|ipp2
operator|=
name|i_tab
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|i_tab
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_rename  */
end_comment

begin_function
name|int
name|xfs_rename
parameter_list|(
name|bhv_desc_t
modifier|*
name|src_dir_bdp
parameter_list|,
name|vname_t
modifier|*
name|src_vname
parameter_list|,
name|xfs_vnode_t
modifier|*
name|target_dir_vp
parameter_list|,
name|vname_t
modifier|*
name|target_vname
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|src_dp
decl_stmt|,
modifier|*
name|target_dp
decl_stmt|,
modifier|*
name|src_ip
decl_stmt|,
modifier|*
name|target_ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|new_parent
decl_stmt|;
comment|/* moving to a new dir */
name|int
name|src_is_directory
decl_stmt|;
comment|/* src_name is a directory */
name|int
name|error
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|int
name|cancel_flags
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_inode_t
modifier|*
name|inodes
index|[
literal|4
index|]
decl_stmt|;
name|int
name|target_ip_dropped
init|=
literal|0
decl_stmt|;
comment|/* dropped target_ip link? */
name|xfs_vnode_t
modifier|*
name|src_dir_vp
decl_stmt|;
name|int
name|spaceres
decl_stmt|;
name|int
name|target_link_zero
init|=
literal|0
decl_stmt|;
name|int
name|num_inodes
decl_stmt|;
name|char
modifier|*
name|src_name
init|=
name|VNAME
argument_list|(
name|src_vname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|target_name
init|=
name|VNAME
argument_list|(
name|target_vname
argument_list|)
decl_stmt|;
name|int
name|src_namelen
init|=
name|VNAMELEN
argument_list|(
name|src_vname
argument_list|)
decl_stmt|;
name|int
name|target_namelen
init|=
name|VNAMELEN
argument_list|(
name|target_vname
argument_list|)
decl_stmt|;
name|src_dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|src_dir_bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|src_dir_vp
argument_list|,
literal|"xfs_rename"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|target_dir_vp
argument_list|,
literal|"xfs_rename"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
comment|/* 	 * Find the XFS behavior descriptor for the target directory 	 * vnode since it was not handed to us. 	 */
name|target_dp
operator|=
name|xfs_vtoi
argument_list|(
name|target_dir_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_dp
operator|==
name|NULL
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|EXDEV
argument_list|)
return|;
block|}
name|src_dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|src_dir_bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|src_dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|src_dir_vp
operator|->
name|v_vfsp
argument_list|,
name|src_dp
argument_list|,
name|DM_EVENT_RENAME
argument_list|)
operator|||
name|DM_EVENT_ENABLED
argument_list|(
name|target_dir_vp
operator|->
name|v_vfsp
argument_list|,
name|target_dp
argument_list|,
name|DM_EVENT_RENAME
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_RENAME
argument_list|,
name|src_dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|target_dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|src_name
argument_list|,
name|target_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|/* Return through std_return after this point. */
comment|/* 	 * Lock all the participating inodes. Depending upon whether 	 * the target_name exists in the target directory, and 	 * whether the target directory is the same as the source 	 * directory, we can lock from 2 to 4 inodes. 	 * xfs_lock_for_rename() will return ENOENT if src_name 	 * does not exist in the source directory. 	 */
name|tp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_lock_for_rename
argument_list|(
name|src_dp
argument_list|,
name|target_dp
argument_list|,
name|src_vname
argument_list|,
name|target_vname
argument_list|,
operator|&
name|src_ip
argument_list|,
operator|&
name|target_ip
argument_list|,
name|inodes
argument_list|,
operator|&
name|num_inodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * We have nothing locked, no inode references, and 		 * no transaction, so just get out. 		 */
goto|goto
name|std_return
goto|;
block|}
name|ASSERT
argument_list|(
name|src_ip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src_ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
comment|/* 		 * Check for link count overflow on target_dp 		 */
if|if
condition|(
name|target_ip
operator|==
name|NULL
operator|&&
operator|(
name|src_dp
operator|!=
name|target_dp
operator|)
operator|&&
name|target_dp
operator|->
name|i_d
operator|.
name|di_nlink
operator|>=
name|XFS_MAXLINK
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EMLINK
argument_list|)
expr_stmt|;
name|xfs_rename_unlock4
argument_list|(
name|inodes
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
goto|goto
name|rele_return
goto|;
block|}
block|}
name|new_parent
operator|=
operator|(
name|src_dp
operator|!=
name|target_dp
operator|)
expr_stmt|;
name|src_is_directory
operator|=
operator|(
operator|(
name|src_ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
comment|/* 	 * Drop the locks on our inodes so that we can start the transaction. 	 */
name|xfs_rename_unlock4
argument_list|(
name|inodes
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_RENAME
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
name|spaceres
operator|=
name|XFS_RENAME_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|target_namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|spaceres
argument_list|,
name|XFS_RENAME_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_RENAME_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|spaceres
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_RENAME_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_RENAME_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|rele_return
goto|;
block|}
comment|/* 	 * Attach the dquots to the inodes 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQVOPRENAME
argument_list|(
name|mp
argument_list|,
name|inodes
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
goto|goto
name|rele_return
goto|;
block|}
comment|/* 	 * Reacquire the inode locks we dropped above. 	 */
name|xfs_lock_inodes
argument_list|(
name|inodes
argument_list|,
name|num_inodes
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Join all the inodes to the transaction. From this point on, 	 * we can rely on either trans_commit or trans_cancel to unlock 	 * them.  Note that we need to add a vnode reference to the 	 * directories since trans_commit& trans_cancel will decrement 	 * them when they unlock the inodes.  Also, we need to be careful 	 * not to add an inode to the transaction more than once. 	 */
name|VN_HOLD
argument_list|(
name|src_dir_vp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|src_dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
condition|)
block|{
name|VN_HOLD
argument_list|(
name|target_dir_vp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|target_dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|src_ip
operator|!=
name|src_dp
operator|)
operator|&&
operator|(
name|src_ip
operator|!=
name|target_dp
operator|)
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|src_ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|target_ip
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|target_ip
operator|!=
name|src_ip
operator|)
operator|&&
operator|(
name|target_ip
operator|!=
name|src_dp
operator|)
operator|&&
operator|(
name|target_ip
operator|!=
name|target_dp
operator|)
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|target_ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up the target. 	 */
if|if
condition|(
name|target_ip
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If there's no space reservation, check the entry will 		 * fit before actually inserting it. 		 */
if|if
condition|(
name|spaceres
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|XFS_DIR_CANENTER
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|target_dp
argument_list|,
name|target_name
argument_list|,
name|target_namelen
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|error_return
goto|;
block|}
comment|/* 		 * If target does not exist and the rename crosses 		 * directories, adjust the target directory link count 		 * to account for the ".." reference from the new entry. 		 */
name|error
operator|=
name|XFS_DIR_CREATENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|target_dp
argument_list|,
name|target_name
argument_list|,
name|target_namelen
argument_list|,
name|src_ip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|spaceres
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|target_dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
operator|&&
name|src_is_directory
condition|)
block|{
name|error
operator|=
name|xfs_bumplink
argument_list|(
name|tp
argument_list|,
name|target_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* target_ip != NULL */
comment|/* 		 * If target exists and it's a directory, check that both 		 * target and source are directories and that target can be 		 * destroyed, or that neither is a directory. 		 */
if|if
condition|(
operator|(
name|target_ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
comment|/* 			 * Make sure target dir is empty. 			 */
if|if
condition|(
operator|!
operator|(
name|XFS_DIR_ISEMPTY
argument_list|(
name|target_ip
operator|->
name|i_mount
argument_list|,
name|target_ip
argument_list|)
operator|)
operator|||
operator|(
name|target_ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|>
literal|2
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* 		 * Link the source inode under the target name. 		 * If the source inode is a directory and we are moving 		 * it across directories, its ".." entry will be 		 * inconsistent until we replace that down below. 		 * 		 * In case there is already an entry with the same 		 * name at the destination directory, remove it first. 		 */
name|error
operator|=
name|XFS_DIR_REPLACE
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|target_dp
argument_list|,
name|target_name
argument_list|,
name|target_namelen
argument_list|,
name|src_ip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|spaceres
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|target_dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
comment|/* 		 * Decrement the link count on the target since the target 		 * dir no longer points to it. 		 */
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|target_ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
name|target_ip_dropped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|src_is_directory
condition|)
block|{
comment|/* 			 * Drop the link from the old "." entry. 			 */
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|target_ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
block|}
comment|/* Do this test while we still hold the locks */
name|target_link_zero
operator|=
operator|(
name|target_ip
operator|)
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
expr_stmt|;
block|}
comment|/* target_ip != NULL */
comment|/* 	 * Remove the source. 	 */
if|if
condition|(
name|new_parent
operator|&&
name|src_is_directory
condition|)
block|{
comment|/* 		 * Rewrite the ".." entry to point to the new 		 * directory. 		 */
name|error
operator|=
name|XFS_DIR_REPLACE
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|src_ip
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|,
name|target_dp
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|spaceres
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
name|EEXIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|src_ip
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We always want to hit the ctime on the source inode. 		 * We do it in the if clause above for the 'new_parent&& 		 * src_is_directory' case, and here we get all the other 		 * cases.  This isn't strictly required by the standards 		 * since the source inode isn't really being changed, 		 * but old unix file systems did it and some incremental 		 * backup programs won't work without it. 		 */
name|xfs_ichgtime
argument_list|(
name|src_ip
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Adjust the link count on src_dp.  This is necessary when 	 * renaming a directory, either within one parent when 	 * the target existed, or across two parent directories. 	 */
if|if
condition|(
name|src_is_directory
operator|&&
operator|(
name|new_parent
operator|||
name|target_ip
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * Decrement link count on src_directory since the 		 * entry that's moved no longer points to it. 		 */
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|src_dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
block|}
name|error
operator|=
name|XFS_DIR_REMOVENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|src_dp
argument_list|,
name|src_name
argument_list|,
name|src_namelen
argument_list|,
name|src_ip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|spaceres
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|src_dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
comment|/* 	 * Update the generation counts on all the directory inodes 	 * that we're modifying. 	 */
name|src_dp
operator|->
name|i_gen
operator|++
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|src_dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
condition|)
block|{
name|target_dp
operator|->
name|i_gen
operator|++
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|target_dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there was a target inode, take an extra reference on 	 * it here so that it doesn't go to xfs_inactive() from 	 * within the commit. 	 */
if|if
condition|(
name|target_ip
operator|!=
name|NULL
condition|)
block|{
name|IHOLD
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * rename transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Take refs. for vop_link_removed calls below.  No need to worry 	 * about directory refs. because the caller holds them. 	 * 	 * Do holds before the xfs_bmap_finish since it might rele them down 	 * to zero. 	 */
if|if
condition|(
name|target_ip_dropped
condition|)
name|IHOLD
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
name|IHOLD
argument_list|(
name|src_ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
operator|(
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_ip
operator|!=
name|NULL
condition|)
block|{
name|IRELE
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_ip_dropped
condition|)
block|{
name|IRELE
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
block|}
name|IRELE
argument_list|(
name|src_ip
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
comment|/* 	 * trans_commit will unlock src_ip, target_ip& decrement 	 * the vnode references. 	 */
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_ip
operator|!=
name|NULL
condition|)
block|{
name|xfs_refcache_purge_ip
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Let interposed file systems know about removed links. 	 */
if|if
condition|(
name|target_ip_dropped
condition|)
block|{
name|XVOP_LINK_REMOVED
argument_list|(
name|XFS_ITOV
argument_list|(
name|target_ip
argument_list|)
argument_list|,
name|target_dir_vp
argument_list|,
name|target_link_zero
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
block|}
name|IRELE
argument_list|(
name|src_ip
argument_list|)
expr_stmt|;
comment|/* Fall through to std_return with error = 0 or errno from 	 * xfs_trans_commit	 */
name|std_return
label|:
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|src_dir_vp
operator|->
name|v_vfsp
argument_list|,
name|src_dp
argument_list|,
name|DM_EVENT_POSTRENAME
argument_list|)
operator|||
name|DM_EVENT_ENABLED
argument_list|(
name|target_dir_vp
operator|->
name|v_vfsp
argument_list|,
name|target_dp
argument_list|,
name|DM_EVENT_POSTRENAME
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTRENAME
argument_list|,
name|src_dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|target_dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|src_name
argument_list|,
name|target_name
argument_list|,
literal|0
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|abort_return
label|:
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* FALLTHROUGH */
name|error_return
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
name|rele_return
label|:
name|IRELE
argument_list|(
name|src_ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_ip
operator|!=
name|NULL
condition|)
block|{
name|IRELE
argument_list|(
name|target_ip
argument_list|)
expr_stmt|;
block|}
goto|goto
name|std_return
goto|;
block|}
end_function

end_unit

