begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_comment
comment|/*  * Initialize the inode hash table for the newly mounted file system.  * Choose an initial table size based on user specified value, else  * use a simple algorithm using the maximum number of inodes as an  * indicator for table size, and clamp it between one and some large  * number of pages.  */
end_comment

begin_function
name|void
name|xfs_ihash_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|__uint64_t
name|icount
decl_stmt|;
name|uint
name|i
decl_stmt|,
name|flags
init|=
name|KM_SLEEP
operator||
name|KM_MAYFAIL
decl_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|m_ihsize
condition|)
block|{
name|icount
operator|=
name|mp
operator|->
name|m_maxicount
condition|?
name|mp
operator|->
name|m_maxicount
else|:
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblog
operator|)
expr_stmt|;
name|mp
operator|->
name|m_ihsize
operator|=
literal|1
operator|<<
name|max_t
argument_list|(
name|uint
argument_list|,
literal|8
argument_list|,
operator|(
name|xfs_highbit64
argument_list|(
name|icount
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ihsize
operator|=
name|min_t
argument_list|(
name|uint
argument_list|,
name|mp
operator|->
name|m_ihsize
argument_list|,
operator|(
literal|64
operator|*
name|NBPP
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|xfs_ihash_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_ihash
operator|=
operator|(
name|xfs_ihash_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|mp
operator|->
name|m_ihsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_ihash_t
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|->
name|m_ihsize
operator|>>=
literal|1
operator|)
operator|<=
name|NBPP
condition|)
name|flags
operator|=
name|KM_SLEEP
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_ihsize
condition|;
name|i
operator|++
control|)
block|{
name|rwlock_init
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ihash
index|[
name|i
index|]
operator|.
name|ih_lock
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up structures allocated by xfs_ihash_init, at unmount time.  */
end_comment

begin_function
name|void
name|xfs_ihash_free
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_ihash
argument_list|,
name|mp
operator|->
name|m_ihsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_ihash_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ihash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the inode cluster hash table for the newly mounted file system.  * Its size is derived from the ihash table size.  */
end_comment

begin_function
name|void
name|xfs_chash_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|uint
name|i
decl_stmt|;
name|mp
operator|->
name|m_chsize
operator|=
name|max_t
argument_list|(
name|uint
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_ihsize
operator|/
operator|(
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|mp
argument_list|)
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_chsize
operator|=
name|min_t
argument_list|(
name|uint
argument_list|,
name|mp
operator|->
name|m_chsize
argument_list|,
name|mp
operator|->
name|m_ihsize
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_chash
operator|=
operator|(
name|xfs_chash_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|mp
operator|->
name|m_chsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_chash_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_chsize
condition|;
name|i
operator|++
control|)
block|{
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_chash
index|[
name|i
index|]
operator|.
name|ch_lock
argument_list|,
literal|"xfshash"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up structures allocated by xfs_chash_init, at unmount time.  */
end_comment

begin_function
name|void
name|xfs_chash_free
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_chsize
condition|;
name|i
operator|++
control|)
block|{
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_chash
index|[
name|i
index|]
operator|.
name|ch_lock
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_chash
argument_list|,
name|mp
operator|->
name|m_chsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_chash_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_chash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to move an inode to the front of its hash list if possible  * (and if its not there already).  Called right after obtaining  * the list version number and then dropping the read_lock on the  * hash list in question (which is done right after looking up the  * inode in question...).  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_ihash_promote
parameter_list|(
name|xfs_ihash_t
modifier|*
name|ih
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|ulong
name|version
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_prevp
operator|!=
operator|&
name|ih
operator|->
name|ih_next
operator|)
operator|&&
name|write_trylock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|likely
argument_list|(
name|version
operator|==
name|ih
operator|->
name|ih_version
argument_list|)
condition|)
block|{
comment|/* remove from list */
if|if
condition|(
operator|(
name|iq
operator|=
name|ip
operator|->
name|i_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
name|ip
operator|->
name|i_prevp
expr_stmt|;
block|}
operator|*
name|ip
operator|->
name|i_prevp
operator|=
name|iq
expr_stmt|;
comment|/* insert at list head */
name|iq
operator|=
name|ih
operator|->
name|ih_next
expr_stmt|;
name|iq
operator|->
name|i_prevp
operator|=
operator|&
name|ip
operator|->
name|i_next
expr_stmt|;
name|ip
operator|->
name|i_next
operator|=
name|iq
expr_stmt|;
name|ip
operator|->
name|i_prevp
operator|=
operator|&
name|ih
operator|->
name|ih_next
expr_stmt|;
name|ih
operator|->
name|ih_next
operator|=
name|ip
expr_stmt|;
block|}
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up an inode by number in the given file system.  * The inode is looked up in the hash table for the file system  * represented by the mount point parameter mp.  Each bucket of  * the hash table is guarded by an individual semaphore.  *  * If the inode is found in the hash table, its corresponding vnode  * is obtained with a call to vn_get().  This call takes care of  * coordination with the reclamation of the inode and vnode.  Note  * that the vmap structure is filled in while holding the hash lock.  * This gives us the state of the inode/vnode when we found it and  * is used for coordination in vn_get().  *  * If it is not in core, read it in from the file system's device and  * add the inode into the hash table.  *  * The inode is locked according to the value of the lock_flags parameter.  * This flag parameter indicates how and if the inode's IO lock and inode lock  * should be taken.  *  * mp -- the mount point structure for the current file system.  It points  *       to the inode hash table.  * tp -- a pointer to the current transaction if there is one.  This is  *       simply passed through to the xfs_iread() call.  * ino -- the number of the inode desired.  This is the unique identifier  *        within the file system for the inode being requested.  * lock_flags -- flags indicating how to lock the inode.  See the comment  *		 for xfs_ilock() for a list of valid values.  * bno -- the block number starting the buffer containing the inode,  *	  if known (as by bulkstat), else 0.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RMC
end_ifdef

begin_function
name|STATIC
name|int
name|xfs_iget_core
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|uint
name|flags
parameter_list|,
name|uint
name|lock_flags
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|,
name|xfs_daddr_t
name|bno
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|inode_vp
decl_stmt|;
name|ulong
name|version
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* REFERENCED */
name|xfs_chash_t
modifier|*
name|ch
decl_stmt|;
name|xfs_chashlist_t
modifier|*
name|chl
decl_stmt|,
modifier|*
name|chlnew
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ih
operator|=
name|XFS_IHASH
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|again
label|:
name|read_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ih
operator|->
name|ih_next
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
comment|/* 			 * If INEW is set this inode is being set up 			 * we need to pause and try again. 			 */
if|if
condition|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_INEW
condition|)
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_frecycle
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|inode_vp
operator|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode_vp
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * If IRECLAIM is set this inode is 				 * on its way out of the system, 				 * we need to pause and try again. 				 */
if|if
condition|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_IRECLAIM
condition|)
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_frecycle
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.alloc"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_found
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|XFS_IRECLAIMABLE
expr_stmt|;
name|version
operator|=
name|ih
operator|->
name|ih_version
expr_stmt|;
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|xfs_ihash_promote
argument_list|(
name|ih
argument_list|,
name|ip
argument_list|,
name|version
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RMC
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|ip
operator|->
name|i_reclaim
argument_list|)
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish_inode
goto|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|!=
name|inode_vp
condition|)
block|{
ifdef|#
directive|ifdef
name|RMC
name|struct
name|inode
modifier|*
name|inode
init|=
name|vn_to_inode
argument_list|(
name|inode_vp
argument_list|)
decl_stmt|;
comment|/* The inode is being torn down, pause and 				 * try again. 				 */
if|if
condition|(
name|inode
operator|->
name|i_state
operator|&
operator|(
name|I_FREEING
operator||
name|I_CLEAR
operator|)
condition|)
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_frecycle
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
endif|#
directive|endif
comment|/* Chances are the other vnode (the one in the inode) is being torn  * down right now, and we landed on top of it. Question is, what do  * we do? Unhook the old inode and hook up the new one?  */
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"xfs_iget_core: ambiguous vns: vp/0x%p, invp/0x%p"
argument_list|,
name|inode_vp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Inode cache hit: if ip is not at the front of 			 * its hash chain, move it there now. 			 * Do this with the lock held for update, but 			 * do statistics after releasing the lock. 			 */
name|version
operator|=
name|ih
operator|->
name|ih_version
expr_stmt|;
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|xfs_ihash_promote
argument_list|(
name|ih
argument_list|,
name|ip
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_found
argument_list|)
expr_stmt|;
name|finish_inode
label|:
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IGET_CREATE
operator|)
condition|)
return|return
name|ENOENT
return|;
name|xfs_iocore_inode_reinit
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|XFS_ISTALE
expr_stmt|;
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.found"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
goto|goto
name|return_ip
goto|;
block|}
block|}
comment|/* 	 * Inode cache miss: save the hash chain version stamp and unlock 	 * the chain, so we don't deadlock in vn_alloc. 	 */
name|XFS_STATS_INC
argument_list|(
name|xs_ig_missed
argument_list|)
expr_stmt|;
name|version
operator|=
name|ih
operator|->
name|ih_version
expr_stmt|;
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Read the disk inode attributes into a new inode structure and get 	 * a new vnode for it. This should also initialize i_ino and i_mount. 	 */
name|error
operator|=
name|xfs_iread
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
operator|&
name|ip
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.alloc"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|xfs_inode_lock_init
argument_list|(
name|ip
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|xfs_iocore_inode_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|IGET_CREATE
operator|)
condition|)
block|{
name|xfs_idestroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
comment|/* 	 * Put ip on its hash chain, unless someone else hashed a duplicate 	 * after we released the hash lock. 	 */
name|write_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_version
operator|!=
name|version
condition|)
block|{
for|for
control|(
name|iq
operator|=
name|ih
operator|->
name|ih_next
init|;
name|iq
operator|!=
name|NULL
condition|;
name|iq
operator|=
name|iq
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|iq
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|xfs_idestroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_dup
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
comment|/* 	 * These values _must_ be set before releasing ihlock! 	 */
name|ip
operator|->
name|i_hash
operator|=
name|ih
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|ih
operator|->
name|ih_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
operator|&
name|ip
operator|->
name|i_next
expr_stmt|;
block|}
name|ip
operator|->
name|i_next
operator|=
name|iq
expr_stmt|;
name|ip
operator|->
name|i_prevp
operator|=
operator|&
name|ih
operator|->
name|ih_next
expr_stmt|;
name|ih
operator|->
name|ih_next
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_udquot
operator|=
name|ip
operator|->
name|i_gdquot
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|ih_version
operator|++
expr_stmt|;
name|ip
operator|->
name|i_flags
operator||=
name|XFS_INEW
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * put ip on its cluster's hash chain 	 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_chash
operator|==
name|NULL
operator|&&
name|ip
operator|->
name|i_cprev
operator|==
name|NULL
operator|&&
name|ip
operator|->
name|i_cnext
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|chlnew
operator|=
name|NULL
expr_stmt|;
name|ch
operator|=
name|XFS_CHASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_blkno
argument_list|)
expr_stmt|;
name|chlredo
label|:
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|chl
operator|=
name|ch
operator|->
name|ch_list
init|;
name|chl
operator|!=
name|NULL
condition|;
name|chl
operator|=
name|chl
operator|->
name|chl_next
control|)
block|{
if|if
condition|(
name|chl
operator|->
name|chl_blkno
operator|==
name|ip
operator|->
name|i_blkno
condition|)
block|{
comment|/* insert this inode into the doubly-linked list 			 * where chl points */
if|if
condition|(
operator|(
name|iq
operator|=
name|chl
operator|->
name|chl_ip
operator|)
condition|)
block|{
name|ip
operator|->
name|i_cprev
operator|=
name|iq
operator|->
name|i_cprev
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cnext
operator|=
name|iq
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
block|}
name|chl
operator|->
name|chl_ip
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_chash
operator|=
name|chl
expr_stmt|;
break|break;
block|}
block|}
comment|/* no hash list found for this block; add a new hash list */
if|if
condition|(
name|chl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|chlnew
operator|==
name|NULL
condition|)
block|{
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_chashlist_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chlnew
operator|=
operator|(
name|xfs_chashlist_t
operator|*
operator|)
name|kmem_zone_alloc
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|chlnew
operator|!=
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|chlredo
goto|;
block|}
else|else
block|{
name|ip
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_chash
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|->
name|chl_ip
operator|=
name|ip
expr_stmt|;
name|chlnew
operator|->
name|chl_blkno
operator|=
name|ip
operator|->
name|i_blkno
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|ch_list
condition|)
name|ch
operator|->
name|ch_list
operator|->
name|chl_prev
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|->
name|chl_next
operator|=
name|ch
operator|->
name|ch_list
expr_stmt|;
name|chlnew
operator|->
name|chl_prev
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|ch_list
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chlnew
operator|!=
name|NULL
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|chlnew
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Link ip to its mount and thread it on the mount's inode list. 	 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|mp
operator|->
name|m_inodes
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|iq
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|==
name|iq
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|=
name|iq
operator|->
name|i_mprev
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|=
name|ip
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_mnext
operator|=
name|iq
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_mnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|=
name|ip
expr_stmt|;
block|}
name|mp
operator|->
name|m_inodes
operator|=
name|ip
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|return_ip
label|:
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
operator|(
name|ip
operator|->
name|i_iocore
operator|.
name|io_flags
operator|&
name|XFS_IOCORE_RT
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
comment|/* 	 * If we have a real type for an on-disk inode, we can set ops(&unlock) 	 * now.	 If it's a new inode being created, xfs_ialloc will handle it. 	 */
name|XVFS_INIT_VNODE
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RMC
end_ifdef

begin_comment
comment|/*  * The 'normal' internal xfs_iget, if needed it will  * 'allocate', or 'get', the vnode.  */
end_comment

begin_function
name|int
name|xfs_iget
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|uint
name|flags
parameter_list|,
name|uint
name|lock_flags
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|,
name|xfs_daddr_t
name|bno
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_attempts
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|(
name|inode
operator|=
name|VFS_GET_INODE
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|vp
operator|=
name|vn_from_inode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|->
name|i_state
operator|&
name|I_NEW
condition|)
block|{
name|vn_initialize
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iget_core
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|lock_flags
argument_list|,
name|ipp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_mark_bad
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|->
name|i_state
operator|&
name|I_NEW
condition|)
name|unlock_new_inode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * If the inode is not fully constructed due to 			 * filehandle mismatches wait for the inode to go 			 * away and try again. 			 * 			 * iget_locked will call __wait_on_freeing_inode 			 * to wait for the inode to go away. 			 */
if|if
condition|(
name|is_bad_inode
argument_list|(
name|inode
argument_list|)
operator|||
operator|(
operator|(
name|ip
operator|=
name|xfs_vtoi
argument_list|(
name|vp
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_found
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* If we got no inode we are out of memory */
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do the setup for the various locks within the incore inode.  */
end_comment

begin_function
name|void
name|xfs_inode_lock_init
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|mrlock_init
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MRLOCK_ALLOW_EQUAL_PRI
operator||
name|MRLOCK_BARRIER
argument_list|,
literal|"xfsino"
argument_list|,
operator|(
name|long
operator|)
name|vp
operator|->
name|v_number
argument_list|)
expr_stmt|;
name|mrlock_init
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MRLOCK_BARRIER
argument_list|,
literal|"xfsio"
argument_list|,
name|vp
operator|->
name|v_number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RMC
name|init_waitqueue_head
argument_list|(
operator|&
name|ip
operator|->
name|i_ipin_wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atomic_set
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_sema
argument_list|(
operator|&
name|ip
operator|->
name|i_flock
argument_list|,
literal|1
argument_list|,
literal|"xfsfino"
argument_list|,
name|vp
operator|->
name|v_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for the inode corresponding to the given ino in the hash table.  * If it is there and its i_transp pointer matches tp, return it.  * Otherwise, return NULL.  */
end_comment

begin_function
name|xfs_inode_t
modifier|*
name|xfs_inode_incore
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|ulong
name|version
decl_stmt|;
name|ih
operator|=
name|XFS_IHASH
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|read_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ih
operator|->
name|ih_next
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
comment|/* 			 * If we find it and tp matches, return it. 			 * Also move it to the front of the hash list 			 * if we find it and it is not already there. 			 * Otherwise break from the loop and return 			 * NULL. 			 */
if|if
condition|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
condition|)
block|{
name|version
operator|=
name|ih
operator|->
name|ih_version
expr_stmt|;
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|xfs_ihash_promote
argument_list|(
name|ih
argument_list|,
name|ip
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
break|break;
block|}
block|}
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decrement reference count of an inode structure and unlock it.  *  * ip -- the inode being released  * lock_flags -- this parameter indicates the inode's locks to be  *       to be released.  See the comment on xfs_iunlock() for a list  *	 of valid values.  */
end_comment

begin_function
name|void
name|xfs_iput
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_iput"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RMC
end_ifdef

begin_comment
comment|/* in xfs_freebsd_iget.c  * Special iput for brand-new inodes that are still locked  */
end_comment

begin_function
name|void
name|xfs_iput_new
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
init|=
name|vn_to_inode
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_iput_new"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_IRECLAIMABLE
operator|)
argument_list|)
expr_stmt|;
name|vn_mark_bad
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inode
operator|->
name|i_state
operator|&
name|I_NEW
condition|)
name|unlock_new_inode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
condition|)
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine embodies the part of the reclaim code that pulls  * the inode from the inode hash table and the mount structure's  * inode list.  * This should only be called from xfs_reclaim().  */
end_comment

begin_function
name|void
name|xfs_ireclaim
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Remove from old hash list and mount list. 	 */
name|XFS_STATS_INC
argument_list|(
name|xs_ig_reclaims
argument_list|)
expr_stmt|;
name|xfs_iextract
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Here we do a spurious inode lock in order to coordinate with 	 * xfs_sync().  This is because xfs_sync() references the inodes 	 * in the mount list without taking references on the corresponding 	 * vnodes.  We make that OK here by ensuring that we wait until 	 * the inode is unlocked in xfs_sync() before we go ahead and 	 * free it.  We get both the regular lock and the io lock because 	 * the xfs_sync() code may need to drop the regular one but will 	 * still hold the io lock. 	 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Release dquots (and their references) if any. An inode may escape 	 * xfs_inactive and get here via vn_alloc->vn_reclaim path. 	 */
name|XFS_QM_DQDETACH
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Pull our behavior descriptor from the vnode chain. 	 */
name|vp
operator|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|vn_bhv_remove
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free all memory associated with the inode. 	 */
name|xfs_idestroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine removes an about-to-be-destroyed inode from  * all of the lists in which it is located with the exception  * of the behavior chain.  */
end_comment

begin_function
name|void
name|xfs_iextract
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_chash_t
modifier|*
name|ch
decl_stmt|;
name|xfs_chashlist_t
modifier|*
name|chl
decl_stmt|,
modifier|*
name|chm
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ih
operator|=
name|ip
operator|->
name|i_hash
expr_stmt|;
name|write_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|ip
operator|->
name|i_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
name|ip
operator|->
name|i_prevp
expr_stmt|;
block|}
operator|*
name|ip
operator|->
name|i_prevp
operator|=
name|iq
expr_stmt|;
name|ih
operator|->
name|ih_version
operator|++
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from cluster hash list 	 *   1) delete the chashlist if this is the last inode on the chashlist 	 *   2) unchain from list of inodes 	 *   3) point chashlist->chl_ip to 'chl_next' if to this inode. 	 */
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ch
operator|=
name|XFS_CHASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_blkno
argument_list|)
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_cnext
operator|==
name|ip
condition|)
block|{
comment|/* Last inode on chashlist */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_cnext
operator|==
name|ip
operator|&&
name|ip
operator|->
name|i_cprev
operator|==
name|ip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_chash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chm
operator|=
name|NULL
expr_stmt|;
name|chl
operator|=
name|ip
operator|->
name|i_chash
expr_stmt|;
if|if
condition|(
name|chl
operator|->
name|chl_prev
condition|)
name|chl
operator|->
name|chl_prev
operator|->
name|chl_next
operator|=
name|chl
operator|->
name|chl_next
expr_stmt|;
else|else
name|ch
operator|->
name|ch_list
operator|=
name|chl
operator|->
name|chl_next
expr_stmt|;
if|if
condition|(
name|chl
operator|->
name|chl_next
condition|)
name|chl
operator|->
name|chl_next
operator|->
name|chl_prev
operator|=
name|chl
operator|->
name|chl_prev
expr_stmt|;
name|kmem_zone_free
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|chl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* delete one inode from a non-empty list */
name|iq
operator|=
name|ip
operator|->
name|i_cnext
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|=
name|ip
operator|->
name|i_cprev
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|->
name|i_cnext
operator|=
name|iq
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_chash
operator|->
name|chl_ip
operator|==
name|ip
condition|)
block|{
name|ip
operator|->
name|i_chash
operator|->
name|chl_ip
operator|=
name|iq
expr_stmt|;
block|}
name|ip
operator|->
name|i_chash
operator|=
name|__return_address
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|__return_address
expr_stmt|;
name|ip
operator|->
name|i_cnext
operator|=
name|__return_address
expr_stmt|;
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from mount's inode list. 	 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_mnext
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_mprev
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|iq
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|=
name|ip
operator|->
name|i_mprev
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|=
name|iq
expr_stmt|;
comment|/* 	 * Fix up the head pointer if it points to the inode being deleted. 	 */
if|if
condition|(
name|mp
operator|->
name|m_inodes
operator|==
name|ip
condition|)
block|{
if|if
condition|(
name|ip
operator|==
name|iq
condition|)
block|{
name|mp
operator|->
name|m_inodes
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_inodes
operator|=
name|iq
expr_stmt|;
block|}
block|}
comment|/* Deal with the deleted inodes list */
ifdef|#
directive|ifdef
name|RMC
name|list_del_init
argument_list|(
operator|&
name|ip
operator|->
name|i_reclaim
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|m_ireclaims
operator|++
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a wrapper routine around the xfs_ilock() routine  * used to centralize some grungy code.  It is used in places  * that wish to lock the inode solely for reading the extents.  * The reason these places can't just call xfs_ilock(SHARED)  * is that the inode lock also guards to bringing in of the  * extents from disk for a file in b-tree format.  If the inode  * is in b-tree format, then we need to lock the inode exclusively  * until the extents are read in.  Locking it exclusively all  * the time would limit our parallelism unnecessarily, though.  * What we do instead is check to see if the extents have been  * read in yet, and only lock the inode exclusively if they  * have not.  *  * The function returns a value which should be given to the  * corresponding xfs_iunlock_map_shared().  This value is  * the mode in which the lock was actually taken.  */
end_comment

begin_function
name|uint
name|xfs_ilock_map_shared
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|uint
name|lock_mode
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_BTREE
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|lock_mode
operator|=
name|XFS_ILOCK_EXCL
expr_stmt|;
block|}
else|else
block|{
name|lock_mode
operator|=
name|XFS_ILOCK_SHARED
expr_stmt|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
return|return
name|lock_mode
return|;
block|}
end_function

begin_comment
comment|/*  * This is simply the unlock routine to go with xfs_ilock_map_shared().  * All it does is call xfs_iunlock() with the given lock_mode.  */
end_comment

begin_function
name|void
name|xfs_iunlock_map_shared
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|unsigned
name|int
name|lock_mode
parameter_list|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The xfs inode contains 2 locks: a multi-reader lock called the  * i_iolock and a multi-reader lock called the i_lock.  This routine  * allows either or both of the locks to be obtained.  *  * The 2 locks should always be ordered so that the IO lock is  * obtained first in order to prevent deadlock.  *  * ip -- the inode being locked  * lock_flags -- this parameter indicates the inode's locks  *       to be locked.  It can be:  *		XFS_IOLOCK_SHARED,  *		XFS_IOLOCK_EXCL,  *		XFS_ILOCK_SHARED,  *		XFS_ILOCK_EXCL,  *		XFS_IOLOCK_SHARED | XFS_ILOCK_SHARED,  *		XFS_IOLOCK_SHARED | XFS_ILOCK_EXCL,  *		XFS_IOLOCK_EXCL | XFS_ILOCK_SHARED,  *		XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL  */
end_comment

begin_function
name|void
name|xfs_ilock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
comment|/* 	 * You can't set both SHARED and EXCL for the same lock, 	 * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED, 	 * and XFS_ILOCK_EXCL are valid values to set in lock_flags. 	 */
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
name|XFS_LOCK_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|mrupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
condition|)
block|{
name|mraccess
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|mrupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_SHARED
condition|)
block|{
name|mraccess
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
block|}
name|xfs_ilock_trace
argument_list|(
name|ip
argument_list|,
literal|1
argument_list|,
name|lock_flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is just like xfs_ilock(), except that the caller  * is guaranteed not to sleep.  It returns 1 if it gets  * the requested locks and 0 otherwise.  If the IO lock is  * obtained but the inode lock cannot be, then the IO lock  * is dropped before returning.  *  * ip -- the inode being locked  * lock_flags -- this parameter indicates the inode's locks to be  *       to be locked.  See the comment for xfs_ilock() for a list  *	 of valid values.  *  */
end_comment

begin_function
name|int
name|xfs_ilock_nowait
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|int
name|iolocked
decl_stmt|;
name|int
name|ilocked
decl_stmt|;
comment|/* 	 * You can't set both SHARED and EXCL for the same lock, 	 * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED, 	 * and XFS_ILOCK_EXCL are valid values to set in lock_flags. 	 */
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
name|XFS_LOCK_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|iolocked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|iolocked
operator|=
name|mrtryupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iolocked
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
condition|)
block|{
name|iolocked
operator|=
name|mrtryaccess
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iolocked
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|ilocked
operator|=
name|mrtryupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ilocked
condition|)
block|{
if|if
condition|(
name|iolocked
condition|)
block|{
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_SHARED
condition|)
block|{
name|ilocked
operator|=
name|mrtryaccess
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ilocked
condition|)
block|{
if|if
condition|(
name|iolocked
condition|)
block|{
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
name|xfs_ilock_trace
argument_list|(
name|ip
argument_list|,
literal|2
argument_list|,
name|lock_flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_iunlock() is used to drop the inode locks acquired with  * xfs_ilock() and xfs_ilock_nowait().  The caller must pass  * in the flags given to xfs_ilock() or xfs_ilock_nowait() so  * that we know which locks to drop.  *  * ip -- the inode being unlocked  * lock_flags -- this parameter indicates the inode's locks to be  *       to be unlocked.  See the comment for xfs_ilock() for a list  *	 of valid values for this parameter.  *  */
end_comment

begin_function
name|void
name|xfs_iunlock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
comment|/* 	 * You can't set both SHARED and EXCL for the same lock, 	 * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED, 	 * and XFS_ILOCK_EXCL are valid values to set in lock_flags. 	 */
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
operator|(
name|XFS_LOCK_MASK
operator||
name|XFS_IUNLOCK_NONOTIFY
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lock_flags
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_ACCESS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_ILOCK_SHARED
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_ACCESS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Let the AIL know that this item has been unlocked in case 		 * it is in the AIL and anyone is waiting on it.  Don't do 		 * this if the caller has asked us not to. 		 */
if|if
condition|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IUNLOCK_NONOTIFY
operator|)
operator|&&
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
condition|)
block|{
name|xfs_trans_unlocked_item
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|(
name|ip
operator|->
name|i_itemp
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_ilock_trace
argument_list|(
name|ip
argument_list|,
literal|3
argument_list|,
name|lock_flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * give up write locks.  the i/o lock cannot be held nested  * if it is being demoted.  */
end_comment

begin_function
name|void
name|xfs_ilock_demote
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
operator|(
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|mrdemote
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|mrdemote
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The following three routines simply manage the i_flock  * semaphore embedded in the inode.  This semaphore synchronizes  * processes attempting to flush the in-core inode back to disk.  */
end_comment

begin_function
name|void
name|xfs_iflock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|psema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|,
name|PINOD
operator||
name|PLTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xfs_iflock_nowait
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
return|return
operator|(
name|cpsema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xfs_ifunlock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|valusema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|vsema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

