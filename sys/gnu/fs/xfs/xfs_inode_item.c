begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_comment
comment|/*  * This file contains the implementation of the xfs_inode_log_item.  * It contains the item operations used to manipulate the inode log  * items as well as utility routines used by the inode specific  * transaction routines.  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_ili_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode log item zone */
end_comment

begin_comment
comment|/*  * This returns the number of iovecs needed to log the given inode item.  *  * We need one iovec for the inode log format structure, one for the  * inode core, and possibly one for the inode data/extents/b-tree root  * and one for the inode attribute data/extents/b-tree root.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_inode_item_size
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|uint
name|nvecs
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
name|nvecs
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Only log the data/extents/b-tree root if there is something 	 * left to log. 	 */
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator||=
name|XFS_ILOG_CORE
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DEXT
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
name|XFS_ILOG_DEXT
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DBROOT
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DBROOT
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
if|if
condition|(
name|iip
operator|->
name|ili_root_size
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_root_size
operator|==
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|memcmp
argument_list|(
name|iip
operator|->
name|ili_orig_root
argument_list|,
name|ip
operator|->
name|i_df
operator|.
name|if_broot
argument_list|,
name|iip
operator|->
name|ili_root_size
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
name|XFS_ILOG_DBROOT
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DDATA
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
name|XFS_ILOG_DDATA
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_DEV
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_UUID
operator|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_UUID
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DEV
operator|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If there are no attributes associated with this file, 	 * then there cannot be anything more to log. 	 * Clear all attribute-related log flags. 	 */
if|if
condition|(
operator|!
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_ADATA
operator||
name|XFS_ILOG_ABROOT
operator||
name|XFS_ILOG_AEXT
operator|)
expr_stmt|;
return|return
name|nvecs
return|;
block|}
comment|/* 	 * Log any necessary attribute data. 	 */
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_ADATA
operator||
name|XFS_ILOG_ABROOT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_AEXT
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
name|XFS_ILOG_AEXT
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_ADATA
operator||
name|XFS_ILOG_AEXT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ABROOT
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_broot_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_broot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
name|XFS_ILOG_ABROOT
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
operator|(
name|XFS_ILOG_AEXT
operator||
name|XFS_ILOG_ABROOT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ADATA
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|>
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&=
operator|~
name|XFS_ILOG_ADATA
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|nvecs
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to fill in the vector of log iovecs for the  * given inode log item.  It fills the first item with an inode  * log format structure, the second with the on-disk inode structure,  * and a possible third and/or fourth with the inode data/extents/b-tree  * root and inode attributes data/extents/b-tree root.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_format
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|,
name|xfs_log_iovec_t
modifier|*
name|log_vector
parameter_list|)
block|{
name|uint
name|nvecs
decl_stmt|;
name|xfs_log_iovec_t
modifier|*
name|vecp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|data_bytes
decl_stmt|;
name|xfs_bmbt_rec_t
modifier|*
name|ext_buffer
decl_stmt|;
name|int
name|nrecs
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
name|vecp
operator|=
name|log_vector
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|iip
operator|->
name|ili_format
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_inode_log_format_t
argument_list|)
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Clear i_update_core if the timestamps (or any other 	 * non-transactional modification) need flushing/logging 	 * and we're about to log them with the rest of the core. 	 * 	 * This is the same logic as xfs_iflush() but this code can't 	 * run at the same time as xfs_iflush because we're in commit 	 * processing here and so we have the inode lock held in 	 * exclusive mode.  Although it doesn't really matter 	 * for the timestamps if both routines were to grab the 	 * timestamps or not.  That would be ok. 	 * 	 * We clear i_update_core before copying out the data. 	 * This is for coordination with our timestamp updates 	 * that don't hold the inode lock. They will always 	 * update the timestamps BEFORE setting i_update_core, 	 * so if we clear i_update_core after they set it we 	 * are guaranteed to see their updates to the timestamps 	 * either here.  Likewise, if they set it after we clear it 	 * here, we'll see it either on the next commit of this 	 * inode or the next time the inode gets flushed via 	 * xfs_iflush().  This depends on strongly ordered memory 	 * semantics, but we have that.  We use the SYNCHRONIZE 	 * macro to make sure that the compiler does not reorder 	 * the i_update_core access below the data copy below. 	 */
if|if
condition|(
name|ip
operator|->
name|i_update_core
condition|)
block|{
name|ip
operator|->
name|i_update_core
operator|=
literal|0
expr_stmt|;
name|SYNCHRONIZE
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * We don't have to worry about re-ordering here because 	 * the update_size field is protected by the inode lock 	 * and we have that held in exclusive mode. 	 */
if|if
condition|(
name|ip
operator|->
name|i_update_size
condition|)
name|ip
operator|->
name|i_update_size
operator|=
literal|0
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|ip
operator|->
name|i_d
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator||=
name|XFS_ILOG_CORE
expr_stmt|;
comment|/* 	 * If this is really an old format inode, then we need to 	 * log it as such.  This means that we have to copy the link 	 * count from the new field to the old.  We don't have to worry 	 * about the new fields, because nothing trusts them as long as 	 * the old inode version number is there.  If the superblock already 	 * has a new version number, then we don't bother converting back. 	 */
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
operator|||
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
condition|)
block|{
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
comment|/* 			 * Convert it back. 			 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|<=
name|XFS_MAXLINK_1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The superblock version has already been bumped, 			 * so just make the conversion to the new inode 			 * format permanent. 			 */
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|=
name|XFS_DINODE_VERSION_2
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DEXT
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_extents_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|nrecs
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nrecs
operator|>
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARCH_CONVERT
operator|==
name|ARCH_NOCONVERT
if|if
condition|(
name|nrecs
operator|==
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
condition|)
block|{
comment|/* 				 * There are no delayed allocation 				 * extents, so just point to the 				 * real extents array. 				 */
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_extents
operator|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 				 * There are delayed allocation extents 				 * in the inode, or we need to convert 				 * the extents to on disk format. 				 * Use xfs_iextents_copy() 				 * to copy only the real extents into 				 * a separate buffer.  We'll free the 				 * buffer in the unlock routine. 				 */
name|ext_buffer
operator|=
name|kmem_alloc
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_extents_buf
operator|=
name|ext_buffer
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|ext_buffer
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|xfs_iextents_copy
argument_list|(
name|ip
argument_list|,
name|ext_buffer
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|vecp
operator|->
name|i_len
operator|<=
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_dsize
operator|=
name|vecp
operator|->
name|i_len
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DBROOT
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|ip
operator|->
name|i_df
operator|.
name|if_broot
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_dsize
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DDATA
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
comment|/* 			 * Round i_bytes up to a word boundary. 			 * The underlying memory is guaranteed to 			 * to be there by xfs_idata_realloc(). 			 */
name|data_bytes
operator|=
name|roundup
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_real_bytes
operator|==
literal|0
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_real_bytes
operator|==
name|data_bytes
operator|)
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
operator|(
name|int
operator|)
name|data_bytes
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_dsize
operator|=
operator|(
name|unsigned
operator|)
name|data_bytes
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_DEV
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_UUID
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DEV
condition|)
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_u
operator|.
name|ilfu_rdev
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_rdev
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_UUID
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_DBROOT
operator||
name|XFS_ILOG_DEXT
operator||
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_DEV
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_UUID
condition|)
block|{
name|iip
operator|->
name|ili_format
operator|.
name|ilf_u
operator|.
name|ilfu_uuid
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_uuid
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If there are no attributes associated with the file, 	 * then we're done. 	 * Assert that no attribute-related log flags are set. 	 */
if|if
condition|(
operator|!
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|nvecs
operator|==
name|iip
operator|->
name|ili_item
operator|.
name|li_desc
operator|->
name|lid_size
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_size
operator|=
name|nvecs
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_ADATA
operator||
name|XFS_ILOG_ABROOT
operator||
name|XFS_ILOG_AEXT
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_ADATA
operator||
name|XFS_ILOG_ABROOT
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_AEXT
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_extents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|nrecs
operator|=
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|nrecs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nrecs
operator|==
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARCH_CONVERT
operator|==
name|ARCH_NOCONVERT
comment|/* 			 * There are not delayed allocation extents 			 * for attributes, so just point at the array. 			 */
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_extents
operator|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
expr_stmt|;
else|#
directive|else
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_aextents_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Need to endian flip before logging 			 */
name|ext_buffer
operator|=
name|kmem_alloc
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_aextents_buf
operator|=
name|ext_buffer
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|ext_buffer
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|xfs_iextents_copy
argument_list|(
name|ip
argument_list|,
name|ext_buffer
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iip
operator|->
name|ili_format
operator|.
name|ilf_asize
operator|=
name|vecp
operator|->
name|i_len
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_ADATA
operator||
name|XFS_ILOG_AEXT
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ABROOT
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_broot_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_broot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|ip
operator|->
name|i_afp
operator|->
name|if_broot
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
name|ip
operator|->
name|i_afp
operator|->
name|if_broot_bytes
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_asize
operator|=
name|ip
operator|->
name|i_afp
operator|->
name|if_broot_bytes
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
name|ASSERT
argument_list|(
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
operator|(
name|XFS_ILOG_ABROOT
operator||
name|XFS_ILOG_AEXT
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ADATA
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|ip
operator|->
name|i_afp
operator|->
name|if_u1
operator|.
name|if_data
expr_stmt|;
comment|/* 			 * Round i_bytes up to a word boundary. 			 * The underlying memory is guaranteed to 			 * to be there by xfs_idata_realloc(). 			 */
name|data_bytes
operator|=
name|roundup
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_real_bytes
operator|==
literal|0
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_real_bytes
operator|==
name|data_bytes
operator|)
argument_list|)
expr_stmt|;
name|vecp
operator|->
name|i_len
operator|=
operator|(
name|int
operator|)
name|data_bytes
expr_stmt|;
name|vecp
operator|++
expr_stmt|;
name|nvecs
operator|++
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_asize
operator|=
operator|(
name|unsigned
operator|)
name|data_bytes
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|nvecs
operator|==
name|iip
operator|->
name|ili_item
operator|.
name|li_desc
operator|->
name|lid_size
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_size
operator|=
name|nvecs
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to pin the inode associated with the inode log  * item in memory so it cannot be written out.  Do this by calling  * xfs_ipin() to bump the pin count in the inode while holding the  * inode pin lock.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_pin
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_lock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_ipin
argument_list|(
name|iip
operator|->
name|ili_inode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to unpin the inode associated with the inode log  * item which was previously pinned with a call to xfs_inode_item_pin().  * Just call xfs_iunpin() on the inode to do this.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_unpin
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|,
name|int
name|stale
parameter_list|)
block|{
name|xfs_iunpin
argument_list|(
name|iip
operator|->
name|ili_inode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_unpin_remove
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_iunpin
argument_list|(
name|iip
operator|->
name|ili_inode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to attempt to lock the inode associated with this  * inode log item, in preparation for the push routine which does the actual  * iflush.  Don't sleep on the inode lock or the flush lock.  *  * If the flush lock is already held, indicating that the inode has  * been or is in the process of being flushed, then (ideally) we'd like to  * see if the inode's buffer is still incore, and if so give it a nudge.  * We delay doing so until the pushbuf routine, though, to avoid holding  * the AIL lock across a call to the blackhole which is the buffercache.  * Also we don't want to sleep in any device strategy routines, which can happen  * if we do the subsequent bawrite in here.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_inode_item_trylock
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
specifier|register
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
if|if
condition|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|XFS_ITEM_PINNED
return|;
block|}
if|if
condition|(
operator|!
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
condition|)
block|{
return|return
name|XFS_ITEM_LOCKED
return|;
block|}
if|if
condition|(
operator|!
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
comment|/* 		 * If someone else isn't already trying to push the inode 		 * buffer, we get to do it. 		 */
if|if
condition|(
name|iip
operator|->
name|ili_pushbuf_flag
operator|==
literal|0
condition|)
block|{
name|iip
operator|->
name|ili_pushbuf_flag
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|iip
operator|->
name|ili_push_owner
operator|=
name|get_thread_id
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Inode is left locked in shared mode. 			 * Pushbuf routine gets to unlock it. 			 */
return|return
name|XFS_ITEM_PUSHBUF
return|;
block|}
else|else
block|{
comment|/* 			 * We hold the AIL_LOCK, so we must specify the 			 * NONOTIFY flag so that we won't double trip. 			 */
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
operator||
name|XFS_IUNLOCK_NONOTIFY
argument_list|)
expr_stmt|;
return|return
name|XFS_ITEM_FLUSHING
return|;
block|}
comment|/* NOTREACHED */
block|}
comment|/* Stale items should force out the iclog */
if|if
condition|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_ISTALE
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
operator||
name|XFS_IUNLOCK_NONOTIFY
argument_list|)
expr_stmt|;
return|return
name|XFS_ITEM_PINNED
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_logged
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|XFS_ITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the inode associated with the inode log item.  * Clear the fields of the inode and inode log item that  * are specific to the current transaction.  If the  * hold flags is set, do not unlock the inode.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_unlock
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|uint
name|hold
decl_stmt|;
name|uint
name|iolocked
decl_stmt|;
name|uint
name|lock_flags
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_itemp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_lock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|!
operator|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_itemp
operator|->
name|ili_flags
operator|&
name|XFS_ILI_IOLOCKED_EXCL
operator|)
operator|)
operator|||
name|ismrlocked
argument_list|(
operator|&
operator|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_iolock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|!
operator|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_itemp
operator|->
name|ili_flags
operator|&
name|XFS_ILI_IOLOCKED_SHARED
operator|)
operator|)
operator|||
name|ismrlocked
argument_list|(
operator|&
operator|(
name|iip
operator|->
name|ili_inode
operator|->
name|i_iolock
operator|)
argument_list|,
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the transaction pointer in the inode. 	 */
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
name|ip
operator|->
name|i_transp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If the inode needed a separate buffer with which to log 	 * its extents, then free it now. 	 */
if|if
condition|(
name|iip
operator|->
name|ili_extents_buf
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_DEXT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|iip
operator|->
name|ili_extents_buf
argument_list|,
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_extents_buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iip
operator|->
name|ili_aextents_buf
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_AEXT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|iip
operator|->
name|ili_aextents_buf
argument_list|,
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_aextents_buf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Figure out if we should unlock the inode or not. 	 */
name|hold
operator|=
name|iip
operator|->
name|ili_flags
operator|&
name|XFS_ILI_HOLD
expr_stmt|;
comment|/* 	 * Before clearing out the flags, remember whether we 	 * are holding the inode's IO lock. 	 */
name|iolocked
operator|=
name|iip
operator|->
name|ili_flags
operator|&
name|XFS_ILI_IOLOCKED_ANY
expr_stmt|;
comment|/* 	 * Clear out the fields of the inode log item particular 	 * to the current transaction. 	 */
name|iip
operator|->
name|ili_ilock_recur
operator|=
literal|0
expr_stmt|;
name|iip
operator|->
name|ili_iolock_recur
operator|=
literal|0
expr_stmt|;
name|iip
operator|->
name|ili_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Unlock the inode if XFS_ILI_HOLD was not set. 	 */
if|if
condition|(
operator|!
name|hold
condition|)
block|{
name|lock_flags
operator|=
name|XFS_ILOCK_EXCL
expr_stmt|;
if|if
condition|(
name|iolocked
operator|&
name|XFS_ILI_IOLOCKED_EXCL
condition|)
block|{
name|lock_flags
operator||=
name|XFS_IOLOCK_EXCL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iolocked
operator|&
name|XFS_ILI_IOLOCKED_SHARED
condition|)
block|{
name|lock_flags
operator||=
name|XFS_IOLOCK_SHARED
expr_stmt|;
block|}
name|xfs_iput
argument_list|(
name|iip
operator|->
name|ili_inode
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called to find out where the oldest active copy of the  * inode log item in the on disk log resides now that the last log  * write of it completed at the given lsn.  Since we always re-log  * all dirty data in an inode, the latest copy in the on disk log  * is the only one that matters.  Therefore, simply return the  * given lsn.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|xfs_lsn_t
name|xfs_inode_item_committed
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
return|return
operator|(
name|lsn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The transaction with the inode locked has aborted.  The inode  * must not be dirty within the transaction (unless we're forcibly  * shutting down).  We simply unlock just as if the transaction  * had been cancelled.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_abort
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|xfs_inode_item_unlock
argument_list|(
name|iip
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This gets called by xfs_trans_push_ail(), when IOP_TRYLOCK  * failed to get the inode flush lock but did get the inode locked SHARED.  * Here we're trying to see if the inode buffer is incore, and if so whether it's  * marked delayed write. If that's the case, we'll initiate a bawrite on that  * buffer to expedite the process.  *  * We aren't holding the AIL_LOCK (or the flush lock) when this gets called,  * so it is inherently race-y.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_pushbuf
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|uint
name|dopush
decl_stmt|;
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_lock
operator|)
argument_list|,
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The ili_pushbuf_flag keeps others from 	 * trying to duplicate our effort. 	 */
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_pushbuf_flag
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_push_owner
operator|==
name|get_thread_id
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * If flushlock isn't locked anymore, chances are that the 	 * inode flush completed and the inode was taken off the AIL. 	 * So, just get out. 	 */
if|if
condition|(
operator|(
name|valusema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
operator|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|iip
operator|->
name|ili_pushbuf_flag
operator|=
literal|0
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return;
block|}
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|bp
operator|=
name|xfs_incore
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|iip
operator|->
name|ili_format
operator|.
name|ilf_blkno
argument_list|,
name|iip
operator|->
name|ili_format
operator|.
name|ilf_len
argument_list|,
name|XFS_INCORE_TRYLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|XFS_BUF_ISDELAYWRITE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* 			 * We were racing with iflush because we don't hold 			 * the AIL_LOCK or the flush lock. However, at this point, 			 * we have the buffer, and we know that it's dirty. 			 * So, it's possible that iflush raced with us, and 			 * this item is already taken off the AIL. 			 * If not, we can flush it async. 			 */
name|dopush
operator|=
operator|(
operator|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
operator|&&
operator|(
name|valusema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|<=
literal|0
operator|)
operator|)
expr_stmt|;
name|iip
operator|->
name|ili_pushbuf_flag
operator|=
literal|0
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|xfs_buftrace
argument_list|(
literal|"INODE ITEM PUSH"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISPINNED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dopush
condition|)
block|{
name|xfs_bawrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iip
operator|->
name|ili_pushbuf_flag
operator|=
literal|0
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * We have to be careful about resetting pushbuf flag too early (above). 	 * Even though in theory we can do it as soon as we have the buflock, 	 * we don't want others to be doing work needlessly. They'll come to 	 * this function thinking that pushing the buffer is their 	 * responsibility only to find that the buffer is still locked by 	 * another doing the same thing 	 */
name|iip
operator|->
name|ili_pushbuf_flag
operator|=
literal|0
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is called to asynchronously write the inode associated with this  * inode log item out to disk. The inode will already have been locked by  * a successful call to xfs_inode_item_trylock().  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_push
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_lock
operator|)
argument_list|,
name|MR_ACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|valusema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Since we were able to lock the inode's flush lock and 	 * we found it on the AIL, the inode must be dirty.  This 	 * is because the inode is removed from the AIL while still 	 * holding the flush lock in xfs_iflush_done().  Thus, if 	 * we found it in the AIL and were able to obtain the flush 	 * lock without sleeping, then there must not have been 	 * anyone in the process of flushing the inode. 	 */
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
operator|||
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write out the inode.  The completion routine ('iflush_done') will 	 * pull it from the AIL, mark it clean, unlock the flush lock. 	 */
operator|(
name|void
operator|)
name|xfs_iflush
argument_list|(
name|ip
argument_list|,
name|XFS_IFLUSH_ASYNC
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * XXX rcc - this one really has to do something.  Probably needs  * to stamp in a new field in the incore inode.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|void
name|xfs_inode_item_committing
parameter_list|(
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
name|iip
operator|->
name|ili_last_lsn
operator|=
name|lsn
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is the ops vector shared by all buf log items.  */
end_comment

begin_decl_stmt
name|struct
name|xfs_item_ops
name|xfs_inode_item_ops
init|=
block|{
operator|.
name|iop_size
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_size
block|,
operator|.
name|iop_format
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_log_iovec_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_format
block|,
operator|.
name|iop_pin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_pin
block|,
operator|.
name|iop_unpin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|xfs_inode_item_unpin
block|,
operator|.
name|iop_unpin_remove
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_unpin_remove
block|,
operator|.
name|iop_trylock
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_trylock
block|,
operator|.
name|iop_unlock
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_unlock
block|,
operator|.
name|iop_committed
operator|=
operator|(
name|xfs_lsn_t
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_inode_item_committed
block|,
operator|.
name|iop_push
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_push
block|,
operator|.
name|iop_abort
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_abort
block|,
operator|.
name|iop_pushbuf
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_inode_item_pushbuf
block|,
operator|.
name|iop_committing
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_inode_item_committing
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the inode log item for a newly allocated (in-core) inode.  */
end_comment

begin_function
name|void
name|xfs_inode_item_init
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_ili_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_item
operator|.
name|li_type
operator|=
name|XFS_LI_INODE
expr_stmt|;
name|iip
operator|->
name|ili_item
operator|.
name|li_ops
operator|=
operator|&
name|xfs_inode_item_ops
expr_stmt|;
name|iip
operator|->
name|ili_item
operator|.
name|li_mountp
operator|=
name|mp
expr_stmt|;
name|iip
operator|->
name|ili_inode
operator|=
name|ip
expr_stmt|;
comment|/* 	   We have zeroed memory. No need ... 	   iip->ili_extents_buf = NULL; 	   iip->ili_pushbuf_flag = 0; 	 */
name|iip
operator|->
name|ili_format
operator|.
name|ilf_type
operator|=
name|XFS_LI_INODE
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_ino
operator|=
name|ip
operator|->
name|i_ino
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_blkno
operator|=
name|ip
operator|->
name|i_blkno
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_len
operator|=
name|ip
operator|->
name|i_len
expr_stmt|;
name|iip
operator|->
name|ili_format
operator|.
name|ilf_boffset
operator|=
name|ip
operator|->
name|i_boffset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the inode log item and any memory hanging off of it.  */
end_comment

begin_function
name|void
name|xfs_inode_item_destroy
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
if|if
condition|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_root_size
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_orig_root
argument_list|,
name|ip
operator|->
name|i_itemp
operator|->
name|ili_root_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|kmem_zone_free
argument_list|(
name|xfs_ili_zone
argument_list|,
name|ip
operator|->
name|i_itemp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the inode flushing I/O completion routine.  It is called  * from interrupt level when the buffer containing the inode is  * flushed to disk.  It is responsible for removing the inode item  * from the AIL if it has not been re-logged, and unlocking the inode's  * flush lock.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|xfs_iflush_done
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ip
operator|=
name|iip
operator|->
name|ili_inode
expr_stmt|;
comment|/* 	 * We only want to pull the item from the AIL if it is 	 * actually there and its location in the log has not 	 * changed since we started the flush.  Thus, we only bother 	 * if the ili_logged flag is set and the inode's lsn has not 	 * changed.  First we check the lsn outside 	 * the lock since it's cheaper, and then we recheck while 	 * holding the lock before removing the inode from the AIL. 	 */
if|if
condition|(
name|iip
operator|->
name|ili_logged
operator|&&
operator|(
name|iip
operator|->
name|ili_item
operator|.
name|li_lsn
operator|==
name|iip
operator|->
name|ili_flush_lsn
operator|)
condition|)
block|{
name|AIL_LOCK
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_item
operator|.
name|li_lsn
operator|==
name|iip
operator|->
name|ili_flush_lsn
condition|)
block|{
comment|/* 			 * xfs_trans_delete_ail() drops the AIL lock. 			 */
name|xfs_trans_delete_ail
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|iip
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_UNLOCK
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|iip
operator|->
name|ili_logged
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Clear the ili_last_fields bits now that we know that the 	 * data corresponding to them is safely on disk. 	 */
name|iip
operator|->
name|ili_last_fields
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Release the inode's flush lock since we're done with it. 	 */
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is the inode flushing abort routine.  It is called  * from xfs_iflush when the filesystem is shutting down to clean  * up the inode state.  * It is responsible for removing the inode item  * from the AIL if it has not been re-logged, and unlocking the inode's  * flush lock.  */
end_comment

begin_function
name|void
name|xfs_iflush_abort
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|iip
condition|)
block|{
if|if
condition|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
condition|)
block|{
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_item
operator|.
name|li_flags
operator|&
name|XFS_LI_IN_AIL
condition|)
block|{
comment|/* 				 * xfs_trans_delete_ail() drops the AIL lock. 				 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|iip
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|iip
operator|->
name|ili_logged
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Clear the ili_last_fields bits now that we know that the 		 * data corresponding to them is safely on disk. 		 */
name|iip
operator|->
name|ili_last_fields
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Clear the inode logging fields so no more flushes are 		 * attempted. 		 */
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Release the inode's flush lock since we're done with it. 	 */
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_istale_done
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_inode_log_item_t
modifier|*
name|iip
parameter_list|)
block|{
name|xfs_iflush_abort
argument_list|(
name|iip
operator|->
name|ili_inode
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

