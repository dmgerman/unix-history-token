begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_comment
comment|/*  * High level interface routines for log manager  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log_recover.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_define
define|#
directive|define
name|xlog_write_adv_cnt
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|,
name|off
parameter_list|,
name|bytes
parameter_list|)
define|\
value|{ (ptr) += (bytes); \ 	  (len) -= (bytes); \ 	  (off) += (bytes);}
end_define

begin_comment
comment|/* Local miscellaneous function prototypes */
end_comment

begin_function_decl
name|STATIC
name|int
name|xlog_bdstrat_cb
parameter_list|(
name|struct
name|xfs_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_commit_record
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|,
name|xlog_in_core_t
modifier|*
modifier|*
parameter_list|,
name|xfs_lsn_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xlog_t
modifier|*
name|xlog_alloc_log
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|log_target
parameter_list|,
name|xfs_daddr_t
name|blk_offset
parameter_list|,
name|int
name|num_bblks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_space_left
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|cycle
parameter_list|,
name|int
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_sync
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_unalloc_log
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_write
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_iovec_t
name|region
index|[]
parameter_list|,
name|int
name|nentries
parameter_list|,
name|xfs_log_ticket_t
name|tic
parameter_list|,
name|xfs_lsn_t
modifier|*
name|start_lsn
parameter_list|,
name|xlog_in_core_t
modifier|*
modifier|*
name|commit_iclog
parameter_list|,
name|uint
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local state machine functions */
end_comment

begin_function_decl
name|STATIC
name|void
name|xlog_state_done_syncing
parameter_list|(
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_state_do_callback
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|aborted
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_state_get_iclog_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|len
parameter_list|,
name|xlog_in_core_t
modifier|*
modifier|*
name|iclog
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|,
name|int
modifier|*
name|continued_write
parameter_list|,
name|int
modifier|*
name|logoffsetp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_state_put_ticket
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|tic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_state_release_iclog
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_state_switch_iclogs
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|eventual_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_state_sync
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|,
name|uint
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_state_sync_all
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|uint
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_state_want_sync
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local functions to manipulate grant head */
end_comment

begin_function_decl
name|STATIC
name|int
name|xlog_grant_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|xtic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_grant_push_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|need_bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_regrant_reserve_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_regrant_write_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_ungrant_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local ticket functions */
end_comment

begin_function_decl
name|STATIC
name|void
name|xlog_state_ticket_alloc
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xlog_ticket_t
modifier|*
name|xlog_ticket_get
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|unit_bytes
parameter_list|,
name|int
name|count
parameter_list|,
name|char
name|clientid
parameter_list|,
name|uint
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_ticket_put
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local debug functions */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
end_if

begin_function_decl
name|STATIC
name|void
name|xlog_verify_dest_ptr
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|__psint_t
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XFSDEBUG
end_ifdef

begin_function_decl
name|STATIC
name|void
name|xlog_verify_disk_cycle_no
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|STATIC
name|void
name|xlog_verify_grant_head
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|equals
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_verify_iclog
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|count
parameter_list|,
name|boolean_t
name|syncing
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_verify_tail_lsn
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|xfs_lsn_t
name|tail_lsn
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xlog_verify_dest_ptr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xlog_verify_disk_cycle_no
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xlog_verify_grant_head
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xlog_verify_iclog
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xlog_verify_tail_lsn
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|xlog_iclogs_empty
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|xlog_do_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlog_req_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xlog_error_mod
init|=
literal|33
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XLOG_FORCED_SHUTDOWN
parameter_list|(
name|log
parameter_list|)
value|(log->l_flags& XLOG_IO_ERROR)
end_define

begin_comment
comment|/*  * 0 => disable log manager  * 1 => enable log manager  * 2 => enable log manager and log debugging  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_decl_stmt
name|int
name|xlog_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xfs_buftarg_t
modifier|*
name|xlog_target
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_LOG_TRACE
argument_list|)
end_if

begin_function
name|void
name|xlog_trace_loggrant
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|tic
parameter_list|,
name|xfs_caddr_t
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|log
operator|->
name|l_grant_trace
condition|)
block|{
name|log
operator|->
name|l_grant_trace
operator|=
name|ktrace_alloc
argument_list|(
literal|1024
argument_list|,
name|KM_NOSLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log
operator|->
name|l_grant_trace
condition|)
return|return;
block|}
name|ktrace_enter
argument_list|(
name|log
operator|->
name|l_grant_trace
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tic
argument_list|,
operator|(
name|void
operator|*
operator|)
name|log
operator|->
name|l_reserve_headq
argument_list|,
operator|(
name|void
operator|*
operator|)
name|log
operator|->
name|l_write_headq
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|log
operator|->
name|l_grant_reserve_cycle
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|log
operator|->
name|l_grant_reserve_bytes
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|log
operator|->
name|l_grant_write_cycle
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|log
operator|->
name|l_grant_write_bytes
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|log
operator|->
name|l_curr_cycle
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|log
operator|->
name|l_curr_block
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|CYCLE_LSN
argument_list|(
name|log
operator|->
name|l_tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|BLOCK_LSN
argument_list|(
name|log
operator|->
name|l_tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|string
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|13
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|14
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|15
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|16
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xlog_trace_iclog
parameter_list|(
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|uint
name|state
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|current_pid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iclog
operator|->
name|ic_trace
condition|)
name|iclog
operator|->
name|ic_trace
operator|=
name|ktrace_alloc
argument_list|(
literal|256
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ktrace_enter
argument_list|(
name|iclog
operator|->
name|ic_trace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|state
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pid
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xlog_trace_loggrant
parameter_list|(
name|log
parameter_list|,
name|tic
parameter_list|,
name|string
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xlog_trace_iclog
parameter_list|(
name|iclog
parameter_list|,
name|state
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_LOG_TRACE */
end_comment

begin_comment
comment|/*  * NOTES:  *  *	1. currblock field gets updated at startup and after in-core logs  *		marked as with WANT_SYNC.  */
end_comment

begin_comment
comment|/*  * This routine is called when a user of a log manager ticket is done with  * the reservation.  If the ticket was ever used, then a commit record for  * the associated transaction is written out as a log operation header with  * no data.  The flag XLOG_TIC_INITED is set when the first write occurs with  * a given ticket.  If the ticket was one with a permanent reservation, then  * a few operations are done differently.  Permanent reservation tickets by  * default don't release the reservation.  They just commit the current  * transaction with the belief that the reservation is still needed.  A flag  * must be passed in before permanent reservations are actually released.  * When these type of tickets are not released, they need to be set into  * the inited state again.  By doing this, a start record will be written  * out when the next write occurs.  */
end_comment

begin_function
name|xfs_lsn_t
name|xfs_log_done
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_ticket_t
name|xtic
parameter_list|,
name|void
modifier|*
modifier|*
name|iclog
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xlog_ticket_t
modifier|*
name|ticket
init|=
operator|(
name|xfs_log_ticket_t
operator|)
name|xtic
decl_stmt|;
name|xfs_lsn_t
name|lsn
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
operator|||
comment|/* 	     * If nothing was ever written, don't write out commit record. 	     * If we get an error, just continue and give back the log ticket. 	     */
operator|(
operator|(
operator|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_INITED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|xlog_commit_record
argument_list|(
name|mp
argument_list|,
name|ticket
argument_list|,
operator|(
name|xlog_in_core_t
operator|*
operator|*
operator|)
name|iclog
argument_list|,
operator|&
name|lsn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|lsn
operator|=
operator|(
name|xfs_lsn_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
condition|)
block|{
name|flags
operator||=
name|XFS_LOG_REL_PERM_RESERV
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
operator|)
operator|==
literal|0
operator|||
operator|(
name|flags
operator|&
name|XFS_LOG_REL_PERM_RESERV
operator|)
condition|)
block|{
comment|/* 		 * Release ticket if not permanent reservation or a specifc 		 * request has been made to release a permanent reservation. 		 */
name|xlog_ungrant_log_space
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
name|xlog_state_put_ticket
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xlog_regrant_reserve_log_space
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
block|}
comment|/* If this ticket was a permanent reservation and we aren't 	 * trying to release it, reset the inited flags; so next time 	 * we write, a start record will be written out. 	 */
if|if
condition|(
operator|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
operator|)
operator|&&
operator|(
name|flags
operator|&
name|XFS_LOG_REL_PERM_RESERV
operator|)
operator|==
literal|0
condition|)
name|ticket
operator|->
name|t_flags
operator||=
name|XLOG_TIC_INITED
expr_stmt|;
return|return
name|lsn
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_done */
end_comment

begin_comment
comment|/*  * Force the in-core log to disk.  If flags == XFS_LOG_SYNC,  *	the force is done synchronously.  *  * Asynchronous forces are implemented by setting the WANT_SYNC  * bit in the appropriate in-core log and then returning.  *  * Synchronous forces are implemented with a semaphore.  All callers  * to force a given lsn to disk will wait on a semaphore attached to the  * specific in-core log.  When given in-core log finally completes its  * write to disk, that thread will wake up all threads waiting on the  * semaphore.  */
end_comment

begin_function
name|int
name|xfs_log_force
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|flags
operator|&
name|XFS_LOG_FORCE
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_log_force
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_IO_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lsn
operator|==
literal|0
condition|)
name|rval
operator|=
name|xlog_state_sync_all
argument_list|(
name|log
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|xlog_state_sync
argument_list|(
name|log
argument_list|,
name|lsn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_force */
end_comment

begin_comment
comment|/*  * This function will take a log sequence number and check to see if that  * lsn has been flushed to disk.  If it has, then the callback function is  * called with the callback argument.  If the relevant in-core log has not  * been synced to disk, we add the callback to the callback list of the  * in-core log.  */
end_comment

begin_function
name|int
name|xfs_log_notify
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount of partition */
name|void
modifier|*
name|iclog_hndl
parameter_list|,
comment|/* iclog to hang callback off */
name|xfs_log_callback_t
modifier|*
name|cb
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|iclog
init|=
operator|(
name|xlog_in_core_t
operator|*
operator|)
name|iclog_hndl
decl_stmt|;
name|int
name|abortflg
decl_stmt|,
name|spl
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|cb
operator|->
name|cb_next
operator|=
literal|0
expr_stmt|;
name|spl
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|abortflg
operator|=
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|abortflg
condition|)
block|{
name|ASSERT_ALWAYS
argument_list|(
operator|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|)
operator|||
operator|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_WANT_SYNC
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|cb_next
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|iclog
operator|->
name|ic_callback_tail
operator|)
operator|=
name|cb
expr_stmt|;
name|iclog
operator|->
name|ic_callback_tail
operator|=
operator|&
operator|(
name|cb
operator|->
name|cb_next
operator|)
expr_stmt|;
block|}
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|spl
argument_list|)
expr_stmt|;
if|if
condition|(
name|abortflg
condition|)
block|{
name|cb
operator|->
name|cb_func
argument_list|(
name|cb
operator|->
name|cb_arg
argument_list|,
name|abortflg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_notify */
end_comment

begin_function
name|int
name|xfs_log_release_iclog
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|iclog_hndl
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|iclog
init|=
operator|(
name|xlog_in_core_t
operator|*
operator|)
name|iclog_hndl
decl_stmt|;
if|if
condition|(
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
condition|)
block|{
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_LOG_IO_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  1. Reserve an amount of on-disk log space and return a ticket corresponding  *	to the reservation.  *  2. Potentially, push buffers at tail of log to disk.  *  * Each reservation is going to reserve extra space for a log record header.  * When writes happen to the on-disk log, we don't subtract the length of the  * log record header from any reservation.  By wasting space in each  * reservation, we prevent over allocation problems.  */
end_comment

begin_function
name|int
name|xfs_log_reserve
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|unit_bytes
parameter_list|,
name|int
name|cnt
parameter_list|,
name|xfs_log_ticket_t
modifier|*
name|ticket
parameter_list|,
name|__uint8_t
name|client
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xlog_ticket_t
modifier|*
name|internal_ticket
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|retval
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|client
operator|==
name|XFS_TRANSACTION
operator|||
name|client
operator|==
name|XFS_LOG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|flags
operator|&
name|XFS_LOG_NOSLEEP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|XFS_STATS_INC
argument_list|(
name|xs_try_logspace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ticket
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|XFS_LOG_PERM_RESERV
argument_list|)
expr_stmt|;
name|internal_ticket
operator|=
operator|(
name|xlog_ticket_t
operator|*
operator|)
operator|*
name|ticket
expr_stmt|;
name|xlog_grant_push_ail
argument_list|(
name|mp
argument_list|,
name|internal_ticket
operator|->
name|t_unit_res
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xlog_regrant_write_log_space
argument_list|(
name|log
argument_list|,
name|internal_ticket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* may sleep if need to allocate more tickets */
name|internal_ticket
operator|=
name|xlog_ticket_get
argument_list|(
name|log
argument_list|,
name|unit_bytes
argument_list|,
name|cnt
argument_list|,
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|ticket
operator|=
name|internal_ticket
expr_stmt|;
name|xlog_grant_push_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|internal_ticket
operator|->
name|t_unit_res
operator|*
name|internal_ticket
operator|->
name|t_cnt
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xlog_grant_log_space
argument_list|(
name|log
argument_list|,
name|internal_ticket
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_reserve */
end_comment

begin_comment
comment|/*  * Mount a log filesystem  *  * mp		- ubiquitous xfs mount point structure  * log_target	- buftarg of on-disk log device  * blk_offset	- Start block # where block size is 512 bytes (BBSIZE)  * num_bblocks	- Number of BBSIZE blocks in on-disk log  *  * Return error or zero.  */
end_comment

begin_function
name|int
name|xfs_log_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|log_target
parameter_list|,
name|xfs_daddr_t
name|blk_offset
parameter_list|,
name|int
name|num_bblks
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NORECOVERY
operator|)
condition|)
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"XFS mounting filesystem %s"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
else|else
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"!Mounting filesystem \"%s\" in no-recovery mode.  Filesystem will be inconsistent."
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_log
operator|=
name|xlog_alloc_log
argument_list|(
name|mp
argument_list|,
name|log_target
argument_list|,
name|blk_offset
argument_list|,
name|num_bblks
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"log dev: %s"
argument_list|,
name|XFS_BUFTARG_NAME
argument_list|(
name|log_target
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* 	 * skip log recovery on a norecovery mount.  pretend it all 	 * just worked. 	 */
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NORECOVERY
operator|)
condition|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_vfs_t
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|int
name|readonly
init|=
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
decl_stmt|;
if|if
condition|(
name|readonly
condition|)
name|vfsp
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
name|error
operator|=
name|xlog_recover
argument_list|(
name|mp
operator|->
name|m_log
argument_list|,
name|readonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|readonly
condition|)
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_RDONLY
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: log mount/recovery failed"
argument_list|)
expr_stmt|;
name|xlog_unalloc_log
argument_list|(
name|mp
operator|->
name|m_log
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Normal transactions can now occur */
name|mp
operator|->
name|m_log
operator|->
name|l_flags
operator|&=
operator|~
name|XLOG_ACTIVE_RECOVERY
expr_stmt|;
comment|/* End mounting message in xfs_log_mount_finish */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_mount */
end_comment

begin_comment
comment|/*  * Finish the recovery of the file system.  This is separate from  * the xfs_log_mount() call, because it depends on the code in  * xfs_mountfs() to read in the root and real-time bitmap inodes  * between calling xfs_log_mount() and here.  *  * mp		- ubiquitous xfs mount point structure  */
end_comment

begin_function
name|int
name|xfs_log_mount_finish
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|mfsi_flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NORECOVERY
operator|)
condition|)
name|error
operator|=
name|xlog_recover_finish
argument_list|(
name|mp
operator|->
name|m_log
argument_list|,
name|mfsi_flags
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount processing for the log.  */
end_comment

begin_function
name|int
name|xfs_log_unmount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xfs_log_unmount_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_log_unmount_dealloc
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Final log writes as part of unmount.  *  * Mark the filesystem clean as unmount happens.  Note that during relocation  * this routine needs to be executed as part of source-bag while the  * deallocation must not be done until source-end.  */
end_comment

begin_comment
comment|/*  * Unmount record used to have a string "Unmount filesystem--" in the  * data section where the "Un" was really a magic number (XLOG_UNMOUNT_TYPE).  * We just write the magic number now since that particular field isn't  * currently architecture converted and "nUmount" is a bit foo.  * As far as I know, there weren't any dependencies on the old behaviour.  */
end_comment

begin_function
name|int
name|xfs_log_unmount_write
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xlog_in_core_t
modifier|*
name|first_iclog
decl_stmt|;
endif|#
directive|endif
name|xfs_log_iovec_t
name|reg
index|[
literal|1
index|]
decl_stmt|;
name|xfs_log_ticket_t
name|tic
init|=
literal|0
decl_stmt|;
name|xfs_lsn_t
name|lsn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* the data section must be 32 bit size aligned */
struct|struct
block|{
name|__uint16_t
name|magic
decl_stmt|;
name|__uint16_t
name|pad1
decl_stmt|;
name|__uint32_t
name|pad2
decl_stmt|;
comment|/* may as well make it 64 bits */
block|}
name|magic
init|=
block|{
name|XLOG_UNMOUNT_TYPE
block|,
literal|0
block|,
literal|0
block|}
struct|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* 	 * Don't write out unmount record on read-only mounts. 	 * Or, if we are doing a forced umount (typically because of IO errors). 	 */
if|if
condition|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
return|return
literal|0
return|;
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|first_iclog
operator|=
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_ACTIVE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|iclog
operator|!=
name|first_iclog
condition|)
do|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
operator|)
condition|)
block|{
name|reg
index|[
literal|0
index|]
operator|.
name|i_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|magic
expr_stmt|;
name|reg
index|[
literal|0
index|]
operator|.
name|i_len
operator|=
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_log_reserve
argument_list|(
name|mp
argument_list|,
literal|600
argument_list|,
literal|1
argument_list|,
operator|&
name|tic
argument_list|,
name|XFS_LOG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* remove inited flag */
operator|(
operator|(
name|xlog_ticket_t
operator|*
operator|)
name|tic
operator|)
operator|->
name|t_flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xlog_write
argument_list|(
name|mp
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|,
name|tic
argument_list|,
operator|&
name|lsn
argument_list|,
name|NULL
argument_list|,
name|XLOG_UNMOUNT_TRANS
argument_list|)
expr_stmt|;
comment|/* 			 * At this point, we're umounting anyway, 			 * so there's no point in transitioning log state 			 * to IOERROR. Just continue... 			 */
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_log_unmount: unmount record failed"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
name|iclog
operator|->
name|ic_refcnt
operator|++
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xlog_state_want_sync
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|sv_wait
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|,
name|PMEM
argument_list|,
operator|&
name|log
operator|->
name|l_icloglock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tic
condition|)
name|xlog_state_put_ticket
argument_list|(
name|log
argument_list|,
name|tic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're already in forced_shutdown mode, couldn't 		 * even attempt to write out the unmount transaction. 		 * 		 * Go through the motions of sync'ing and releasing 		 * the iclog, even though no I/O will actually happen, 		 * we need to wait for other log I/O's that may already 		 * be in progress.  Do this as a separate section of 		 * code so we'll know if we ever get stuck here that 		 * we're in this odd situation of trying to unmount 		 * a file system that went into forced_shutdown as 		 * the result of an unmount.. 		 */
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
name|iclog
operator|->
name|ic_refcnt
operator|++
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xlog_state_want_sync
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_IOERROR
operator|)
condition|)
block|{
name|sv_wait
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|,
name|PMEM
argument_list|,
operator|&
name|log
operator|->
name|l_icloglock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_unmount_write */
end_comment

begin_comment
comment|/*  * Deallocate log structures for unmount/relocation.  */
end_comment

begin_function
name|void
name|xfs_log_unmount_dealloc
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xlog_unalloc_log
argument_list|(
name|mp
operator|->
name|m_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write region vectors to log.  The write happens using the space reservation  * of the ticket (tic).  It is not a requirement that all writes for a given  * transaction occur with one call to xfs_log_write().  */
end_comment

begin_function
name|int
name|xfs_log_write
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_iovec_t
name|reg
index|[]
parameter_list|,
name|int
name|nentries
parameter_list|,
name|xfs_log_ticket_t
name|tic
parameter_list|,
name|xfs_lsn_t
modifier|*
name|start_lsn
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
block|{
operator|*
name|start_lsn
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_write
argument_list|(
name|mp
argument_list|,
name|reg
argument_list|,
name|nentries
argument_list|,
name|tic
argument_list|,
name|start_lsn
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_LOG_IO_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xfs_log_write */
end_comment

begin_function
name|void
name|xfs_log_move_tail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_lsn_t
name|tail_lsn
parameter_list|)
block|{
name|xlog_ticket_t
modifier|*
name|tic
decl_stmt|;
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|int
name|need_bytes
decl_stmt|,
name|free_bytes
decl_stmt|,
name|cycle
decl_stmt|,
name|bytes
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
if|if
condition|(
operator|!
name|xlog_debug
operator|&&
name|xlog_target
operator|==
name|log
operator|->
name|l_targ
condition|)
return|return;
endif|#
directive|endif
comment|/* XXXsup tmp */
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail_lsn
operator|==
literal|0
condition|)
block|{
comment|/* needed since sync_lsn is 64 bits */
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|tail_lsn
operator|=
name|log
operator|->
name|l_last_sync_lsn
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* Also an invalid lsn.  1 implies that we aren't passing in a valid 	 * tail_lsn. 	 */
if|if
condition|(
name|tail_lsn
operator|!=
literal|1
condition|)
block|{
name|log
operator|->
name|l_tail_lsn
operator|=
name|tail_lsn
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tic
operator|=
name|log
operator|->
name|l_write_headq
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_ACTIVE_RECOVERY
condition|)
name|panic
argument_list|(
literal|"Recovery problem"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cycle
operator|=
name|log
operator|->
name|l_grant_write_cycle
expr_stmt|;
name|bytes
operator|=
name|log
operator|->
name|l_grant_write_bytes
expr_stmt|;
name|free_bytes
operator|=
name|xlog_space_left
argument_list|(
name|log
argument_list|,
name|cycle
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_bytes
operator|<
name|tic
operator|->
name|t_unit_res
operator|&&
name|tail_lsn
operator|!=
literal|1
condition|)
break|break;
name|tail_lsn
operator|=
literal|0
expr_stmt|;
name|free_bytes
operator|-=
name|tic
operator|->
name|t_unit_res
expr_stmt|;
name|sv_signal
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|)
expr_stmt|;
name|tic
operator|=
name|tic
operator|->
name|t_next
expr_stmt|;
block|}
do|while
condition|(
name|tic
operator|!=
name|log
operator|->
name|l_write_headq
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|tic
operator|=
name|log
operator|->
name|l_reserve_headq
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_ACTIVE_RECOVERY
condition|)
name|panic
argument_list|(
literal|"Recovery problem"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cycle
operator|=
name|log
operator|->
name|l_grant_reserve_cycle
expr_stmt|;
name|bytes
operator|=
name|log
operator|->
name|l_grant_reserve_bytes
expr_stmt|;
name|free_bytes
operator|=
name|xlog_space_left
argument_list|(
name|log
argument_list|,
name|cycle
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
condition|)
name|need_bytes
operator|=
name|tic
operator|->
name|t_unit_res
operator|*
name|tic
operator|->
name|t_cnt
expr_stmt|;
else|else
name|need_bytes
operator|=
name|tic
operator|->
name|t_unit_res
expr_stmt|;
if|if
condition|(
name|free_bytes
operator|<
name|need_bytes
operator|&&
name|tail_lsn
operator|!=
literal|1
condition|)
break|break;
name|tail_lsn
operator|=
literal|0
expr_stmt|;
name|free_bytes
operator|-=
name|need_bytes
expr_stmt|;
name|sv_signal
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|)
expr_stmt|;
name|tic
operator|=
name|tic
operator|->
name|t_next
expr_stmt|;
block|}
do|while
condition|(
name|tic
operator|!=
name|log
operator|->
name|l_reserve_headq
condition|)
do|;
block|}
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xfs_log_move_tail */
end_comment

begin_comment
comment|/*  * Determine if we have a transaction that has gone to disk  * that needs to be covered. Log activity needs to be idle (no AIL and  * nothing in the iclogs). And, we need to be in the right state indicating  * something has gone out.  */
end_comment

begin_function
name|int
name|xfs_log_need_covered
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|int
name|needed
init|=
literal|0
decl_stmt|,
name|gen
decl_stmt|;
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xfs_vfs_t
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_frozen
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
operator|||
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|log
operator|->
name|l_covered_state
operator|==
name|XLOG_STATE_COVER_NEED
operator|)
operator|||
operator|(
name|log
operator|->
name|l_covered_state
operator|==
name|XLOG_STATE_COVER_NEED2
operator|)
operator|)
operator|&&
operator|!
name|xfs_trans_first_ail
argument_list|(
name|mp
argument_list|,
operator|&
name|gen
argument_list|)
operator|&&
name|xlog_iclogs_empty
argument_list|(
name|log
argument_list|)
condition|)
block|{
if|if
condition|(
name|log
operator|->
name|l_covered_state
operator|==
name|XLOG_STATE_COVER_NEED
condition|)
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_DONE
expr_stmt|;
else|else
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_covered_state
operator|==
name|XLOG_STATE_COVER_NEED2
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_DONE2
expr_stmt|;
block|}
name|needed
operator|=
literal|1
expr_stmt|;
block|}
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|needed
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *	local routines  *  ******************************************************************************  */
end_comment

begin_comment
comment|/* xfs_trans_tail_ail returns 0 when there is nothing in the list.  * The log manager must keep track of the last LR which was committed  * to disk.  The lsn of this LR will become the new tail_lsn whenever  * xfs_trans_tail_ail returns 0.  If we don't do this, we run into  * the situation where stuff could be written into the log but nothing  * was ever in the AIL when asked.  Eventually, we panic since the  * tail hits the head.  *  * We may be holding the log iclog lock upon entering this routine.  */
end_comment

begin_function
name|xfs_lsn_t
name|xlog_assign_tail_lsn
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_lsn_t
name|tail_lsn
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|tail_lsn
operator|=
name|xfs_trans_tail_ail
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail_lsn
operator|!=
literal|0
condition|)
block|{
name|log
operator|->
name|l_tail_lsn
operator|=
name|tail_lsn
expr_stmt|;
block|}
else|else
block|{
name|tail_lsn
operator|=
name|log
operator|->
name|l_tail_lsn
operator|=
name|log
operator|->
name|l_last_sync_lsn
expr_stmt|;
block|}
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|tail_lsn
return|;
block|}
end_function

begin_comment
comment|/* xlog_assign_tail_lsn */
end_comment

begin_comment
comment|/*  * Return the space in the log between the tail and the head.  The head  * is passed in the cycle/bytes formal parms.  In the special case where  * the reserve head has wrapped passed the tail, this calculation is no  * longer valid.  In this case, just return 0 which means there is no space  * in the log.  This works for all places where this function is called  * with the reserve head.  Of course, if the write head were to ever  * wrap the tail, we should blow up.  Rather than catch this case here,  * we depend on other ASSERTions in other parts of the code.   XXXmiken  *  * This code also handles the case where the reservation head is behind  * the tail.  The details of this case are described below, but the end  * result is that we return the size of the log as the amount of space left.  */
end_comment

begin_function
name|int
name|xlog_space_left
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|cycle
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|int
name|free_bytes
decl_stmt|;
name|int
name|tail_bytes
decl_stmt|;
name|int
name|tail_cycle
decl_stmt|;
name|tail_bytes
operator|=
name|BBTOB
argument_list|(
name|BLOCK_LSN
argument_list|(
name|log
operator|->
name|l_tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|tail_cycle
operator|=
name|CYCLE_LSN
argument_list|(
name|log
operator|->
name|l_tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tail_cycle
operator|==
name|cycle
operator|)
operator|&&
operator|(
name|bytes
operator|>=
name|tail_bytes
operator|)
condition|)
block|{
name|free_bytes
operator|=
name|log
operator|->
name|l_logsize
operator|-
operator|(
name|bytes
operator|-
name|tail_bytes
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tail_cycle
operator|+
literal|1
operator|)
operator|<
name|cycle
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|tail_cycle
operator|<
name|cycle
condition|)
block|{
name|ASSERT
argument_list|(
name|tail_cycle
operator|==
operator|(
name|cycle
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|free_bytes
operator|=
name|tail_bytes
operator|-
name|bytes
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The reservation head is behind the tail. 		 * This can only happen when the AIL is empty so the tail 		 * is equal to the head and the l_roundoff value in the 		 * log structure is taking up the difference between the 		 * reservation head and the tail.  The bytes accounted for 		 * by the l_roundoff field are temporarily 'lost' to the 		 * reservation mechanism, but they are cleaned up when the 		 * log buffers that created them are reused.  These lost 		 * bytes are what allow the reservation head to fall behind 		 * the tail in the case that the log is 'empty'. 		 * In this case we just want to return the size of the 		 * log as the amount of space left. 		 */
name|ASSERT
argument_list|(
operator|(
name|tail_cycle
operator|==
operator|(
name|cycle
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|bytes
operator|+
name|log
operator|->
name|l_roundoff
operator|)
operator|>=
name|tail_bytes
operator|)
argument_list|)
expr_stmt|;
name|free_bytes
operator|=
name|log
operator|->
name|l_logsize
expr_stmt|;
block|}
return|return
name|free_bytes
return|;
block|}
end_function

begin_comment
comment|/* xlog_space_left */
end_comment

begin_comment
comment|/*  * Log function which is called when an io completes.  *  * The log manager needs its own routine, in order to control what  * happens with the buffer after the write completes.  */
end_comment

begin_function
name|void
name|xlog_iodone
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|int
name|aborted
decl_stmt|;
name|iclog
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xlog_in_core_t
operator|*
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
argument|bp
argument_list|,
argument|unsigned long
argument_list|)
operator|==
operator|(
name|unsigned
name|long
operator|)
literal|2
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|aborted
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Race to shutdown the filesystem if we see an error. 	 */
if|if
condition|(
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* Some versions of cpp barf on the recursive definition of 		 * ic_log -> hic_fields.ic_log and expand ic_log twice when 		 * it is passed through two macros.  Workaround for broken cpp 		 */
name|struct
name|log
modifier|*
name|l
decl_stmt|;
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_iodone"
argument_list|,
name|iclog
operator|->
name|ic_log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|l
operator|=
name|iclog
operator|->
name|ic_log
expr_stmt|;
name|xfs_force_shutdown
argument_list|(
name|l
operator|->
name|l_mp
argument_list|,
name|XFS_LOG_IO_ERROR
argument_list|)
expr_stmt|;
comment|/* 		 * This flag will be propagated to the trans-committed 		 * callback routines to let them know that the log-commit 		 * didn't succeed. 		 */
name|aborted
operator|=
name|XFS_LI_ABORTED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|aborted
operator|=
name|XFS_LI_ABORTED
expr_stmt|;
block|}
name|xlog_state_done_syncing
argument_list|(
name|iclog
argument_list|,
name|aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XFS_BUF_ISASYNC
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Corresponding psema() will be done in bwrite().  If we don't 		 * vsema() here, panic. 		 */
name|XFS_BUF_V_IODONESEMA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|XFS_BUF_VSEMA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_iodone */
end_comment

begin_comment
comment|/*  * The bdstrat callback function for log bufs. This gives us a central  * place to trap bufs in case we get hit by a log I/O error and need to  * shutdown. Actually, in practice, even when we didn't get a log error,  * we transition the iclogs to IOERROR state *after* flushing all existing  * iclogs to disk. This is because we don't want anymore new transactions to be  * started or completed afterwards.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_bdstrat_cb
parameter_list|(
name|struct
name|xfs_buf
modifier|*
name|bp
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|iclog
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xlog_in_core_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* note for irix bstrat will need  struct bdevsw passed 	   * Fix the following macro if the code ever is merged 	   */
name|XFS_bdstrat
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xfs_buftrace
argument_list|(
literal|"XLOG__BDSTRAT IOERROR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_ERROR
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return size of each in-core log record buffer.  *  * Low memory machines only get 2 16KB buffers.  We don't want to waste  * memory here.  However, all other machines get at least 2 32KB buffers.  * The number is hard coded because we don't care about the minimum  * memory size, just 32MB systems.  *  * If the filesystem blocksize is too large, we may need to choose a  * larger size since the directory code currently logs entire blocks.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_get_iclog_buffer_size
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|xhdrs
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
comment|/* 	 * When logbufs == 0, someone has disabled the log from the FSTAB 	 * file.  This is not a documented feature.  We need to set xlog_debug 	 * to zero (this deactivates the log) and set xlog_target to the 	 * appropriate device.  Only one filesystem may be affected as such 	 * since this is just a performance hack to test what we might be able 	 * to get if the log were not present. 	 */
if|if
condition|(
name|mp
operator|->
name|m_logbufs
operator|==
literal|0
condition|)
block|{
name|xlog_debug
operator|=
literal|0
expr_stmt|;
name|xlog_target
operator|=
name|log
operator|->
name|l_targ
expr_stmt|;
name|log
operator|->
name|l_iclog_bufs
operator|=
name|XLOG_MIN_ICLOGS
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 		 * This is the normal path.  If m_logbufs == -1, then the 		 * admin has chosen to use the system defaults for logbuffers. 		 */
if|if
condition|(
name|mp
operator|->
name|m_logbufs
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|xfs_physmem
operator|<=
name|btoc
argument_list|(
literal|128
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
block|{
name|log
operator|->
name|l_iclog_bufs
operator|=
name|XLOG_MIN_ICLOGS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_physmem
operator|<=
name|btoc
argument_list|(
literal|400
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
block|{
name|log
operator|->
name|l_iclog_bufs
operator|=
name|XLOG_MED_ICLOGS
expr_stmt|;
block|}
else|else
block|{
comment|/* 256K with 32K bufs */
name|log
operator|->
name|l_iclog_bufs
operator|=
name|XLOG_MAX_ICLOGS
expr_stmt|;
block|}
block|}
else|else
name|log
operator|->
name|l_iclog_bufs
operator|=
name|mp
operator|->
name|m_logbufs
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
comment|/* We are reactivating a filesystem after it was inactive */
if|if
condition|(
name|log
operator|->
name|l_targ
operator|==
name|xlog_target
condition|)
block|{
name|xlog_target
operator|=
name|NULL
expr_stmt|;
name|xlog_debug
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Buffer size passed in from mount system call. 	 */
if|if
condition|(
name|mp
operator|->
name|m_logbsize
operator|!=
operator|-
literal|1
condition|)
block|{
name|size
operator|=
name|log
operator|->
name|l_iclog_size
operator|=
name|mp
operator|->
name|m_logbsize
expr_stmt|;
name|log
operator|->
name|l_iclog_size_log
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|1
condition|)
block|{
name|log
operator|->
name|l_iclog_size_log
operator|++
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
comment|/* # headers = size / 32K 			 * one header holds cycles from 32K of data 			 */
name|xhdrs
operator|=
name|mp
operator|->
name|m_logbsize
operator|/
name|XLOG_HEADER_CYCLE_SIZE
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_logbsize
operator|%
name|XLOG_HEADER_CYCLE_SIZE
condition|)
name|xhdrs
operator|++
expr_stmt|;
name|log
operator|->
name|l_iclog_hsize
operator|=
name|xhdrs
operator|<<
name|BBSHIFT
expr_stmt|;
name|log
operator|->
name|l_iclog_heads
operator|=
name|xhdrs
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_logbsize
operator|<=
name|XLOG_BIG_RECORD_BSIZE
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_iclog_hsize
operator|=
name|BBSIZE
expr_stmt|;
name|log
operator|->
name|l_iclog_heads
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Special case machines that have less than 32MB of memory. 	 * All machines with more memory use 32KB buffers. 	 */
if|if
condition|(
name|xfs_physmem
operator|<=
name|btoc
argument_list|(
literal|32
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
block|{
comment|/* Don't change; min configuration */
name|log
operator|->
name|l_iclog_size
operator|=
name|XLOG_RECORD_BSIZE
expr_stmt|;
comment|/* 16k */
name|log
operator|->
name|l_iclog_size_log
operator|=
name|XLOG_RECORD_BSHIFT
expr_stmt|;
block|}
else|else
block|{
name|log
operator|->
name|l_iclog_size
operator|=
name|XLOG_BIG_RECORD_BSIZE
expr_stmt|;
comment|/* 32k */
name|log
operator|->
name|l_iclog_size_log
operator|=
name|XLOG_BIG_RECORD_BSHIFT
expr_stmt|;
block|}
comment|/* the default log size is 16k or 32k which is one header sector */
name|log
operator|->
name|l_iclog_hsize
operator|=
name|BBSIZE
expr_stmt|;
name|log
operator|->
name|l_iclog_heads
operator|=
literal|1
expr_stmt|;
comment|/* 	 * For 16KB, we use 3 32KB buffers.  For 32KB block sizes, we use 	 * 4 32KB buffers.  For 64KB block sizes, we use 8 32KB buffers. 	 */
if|if
condition|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|>=
literal|16
operator|*
literal|1024
condition|)
block|{
name|log
operator|->
name|l_iclog_size
operator|=
name|XLOG_BIG_RECORD_BSIZE
expr_stmt|;
name|log
operator|->
name|l_iclog_size_log
operator|=
name|XLOG_BIG_RECORD_BSHIFT
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_logbufs
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
condition|)
block|{
case|case
literal|16
operator|*
literal|1024
case|:
comment|/* 16 KB */
name|log
operator|->
name|l_iclog_bufs
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|32
operator|*
literal|1024
case|:
comment|/* 32 KB */
name|log
operator|->
name|l_iclog_bufs
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|64
operator|*
literal|1024
case|:
comment|/* 64 KB */
name|log
operator|->
name|l_iclog_bufs
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|xlog_panic
argument_list|(
literal|"XFS: Invalid blocksize"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* xlog_get_iclog_buffer_size */
end_comment

begin_comment
comment|/*  * This routine initializes some of the log structure for a given mount point.  * Its primary purpose is to fill in enough, so recovery can occur.  However,  * some other stuff may be filled in too.  */
end_comment

begin_function
name|STATIC
name|xlog_t
modifier|*
name|xlog_alloc_log
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_buftarg_t
modifier|*
name|log_target
parameter_list|,
name|xfs_daddr_t
name|blk_offset
parameter_list|,
name|int
name|num_bblks
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
decl_stmt|;
name|xlog_rec_header_t
modifier|*
name|head
decl_stmt|;
name|xlog_in_core_t
modifier|*
modifier|*
name|iclogp
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|,
modifier|*
name|prev_iclog
init|=
name|NULL
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|iclogsize
decl_stmt|;
name|log
operator|=
operator|(
name|xlog_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xlog_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_mp
operator|=
name|mp
expr_stmt|;
name|log
operator|->
name|l_targ
operator|=
name|log_target
expr_stmt|;
name|log
operator|->
name|l_logsize
operator|=
name|BBTOB
argument_list|(
name|num_bblks
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_logBBstart
operator|=
name|blk_offset
expr_stmt|;
name|log
operator|->
name|l_logBBsize
operator|=
name|num_bblks
expr_stmt|;
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_IDLE
expr_stmt|;
name|log
operator|->
name|l_flags
operator||=
name|XLOG_ACTIVE_RECOVERY
expr_stmt|;
name|log
operator|->
name|l_prev_block
operator|=
operator|-
literal|1
expr_stmt|;
name|ASSIGN_ANY_LSN
argument_list|(
name|log
operator|->
name|l_tail_lsn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
expr_stmt|;
comment|/* log->l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */
name|log
operator|->
name|l_last_sync_lsn
operator|=
name|log
operator|->
name|l_tail_lsn
expr_stmt|;
name|log
operator|->
name|l_curr_cycle
operator|=
literal|1
expr_stmt|;
comment|/* 0 is bad since this is initial value */
name|log
operator|->
name|l_grant_reserve_cycle
operator|=
literal|1
expr_stmt|;
name|log
operator|->
name|l_grant_write_cycle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|XFS_SB_VERSION_HASSECTOR
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|log
operator|->
name|l_sectbb_log
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_logsectlog
operator|-
name|BBSHIFT
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_sectbb_log
operator|<=
name|mp
operator|->
name|m_sectbb_log
argument_list|)
expr_stmt|;
comment|/* for larger sector sizes, must have v2 or external log */
name|ASSERT
argument_list|(
name|log
operator|->
name|l_sectbb_log
operator|==
literal|0
operator|||
name|log
operator|->
name|l_logBBstart
operator|==
literal|0
operator|||
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_logsectlog
operator|>=
name|BBSHIFT
argument_list|)
expr_stmt|;
block|}
name|log
operator|->
name|l_sectbb_mask
operator|=
operator|(
literal|1
operator|<<
name|log
operator|->
name|l_sectbb_log
operator|)
operator|-
literal|1
expr_stmt|;
name|xlog_get_iclog_buffer_size
argument_list|(
name|mp
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_buf_get_empty
argument_list|(
name|log
operator|->
name|l_iclog_size
argument_list|,
name|mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_iodone
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_bdstrat_cb
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_VSEMA
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_xbuf
operator|=
name|bp
expr_stmt|;
name|spinlock_init
argument_list|(
operator|&
name|log
operator|->
name|l_icloglock
argument_list|,
literal|"iclog"
argument_list|)
expr_stmt|;
name|spinlock_init
argument_list|(
operator|&
name|log
operator|->
name|l_grant_lock
argument_list|,
literal|"grhead_iclog"
argument_list|)
expr_stmt|;
name|initnsema
argument_list|(
operator|&
name|log
operator|->
name|l_flushsema
argument_list|,
literal|0
argument_list|,
literal|"ic-flush"
argument_list|)
expr_stmt|;
name|xlog_state_ticket_alloc
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* wait until after icloglock inited */
comment|/* log record size must be multiple of BBSIZE; see xlog_rec_header_t */
name|ASSERT
argument_list|(
operator|(
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
operator|&
name|BBMASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|iclogp
operator|=
operator|&
name|log
operator|->
name|l_iclog
expr_stmt|;
comment|/* 	 * The amount of memory to allocate for the iclog structure is 	 * rather funky due to the way the structure is defined.  It is 	 * done this way so that we can use different sizes for machines 	 * with different amounts of memory.  See the definition of 	 * xlog_in_core_t in xfs_log_priv.h for details. 	 */
name|iclogsize
operator|=
name|log
operator|->
name|l_iclog_size
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_iclog_size
operator|>=
literal|4096
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|log
operator|->
name|l_iclog_bufs
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|iclogp
operator|=
operator|(
name|xlog_in_core_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xlog_in_core_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|iclog
operator|=
operator|*
name|iclogp
expr_stmt|;
name|iclog
operator|->
name|hic_data
operator|=
operator|(
name|xlog_in_core_2_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|iclogsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|iclog
operator|->
name|ic_prev
operator|=
name|prev_iclog
expr_stmt|;
name|prev_iclog
operator|=
name|iclog
expr_stmt|;
name|log
operator|->
name|l_iclog_bak
index|[
name|i
index|]
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|iclog
operator|->
name|ic_header
operator|)
expr_stmt|;
name|head
operator|=
operator|&
name|iclog
operator|->
name|ic_header
expr_stmt|;
name|memset
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xlog_rec_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|head
operator|->
name|h_magicno
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XLOG_HEADER_MAGIC_NUM
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|head
operator|->
name|h_version
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|head
operator|->
name|h_size
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|log
operator|->
name|l_iclog_size
argument_list|)
expr_stmt|;
comment|/* new fields */
name|INT_SET
argument_list|(
name|head
operator|->
name|h_fmt
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XLOG_FMT
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|head
operator|->
name|h_fs_uuid
argument_list|,
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_buf_get_empty
argument_list|(
name|log
operator|->
name|l_iclog_size
argument_list|,
name|mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_iodone
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_BDSTRAT_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_bdstrat_cb
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|iclog
operator|->
name|ic_bp
operator|=
name|bp
expr_stmt|;
name|iclog
operator|->
name|ic_size
operator|=
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
operator|-
name|log
operator|->
name|l_iclog_hsize
expr_stmt|;
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_ACTIVE
expr_stmt|;
name|iclog
operator|->
name|ic_log
operator|=
name|log
expr_stmt|;
name|iclog
operator|->
name|ic_callback_tail
operator|=
operator|&
operator|(
name|iclog
operator|->
name|ic_callback
operator|)
expr_stmt|;
name|iclog
operator|->
name|ic_datap
operator|=
operator|(
name|char
operator|*
operator|)
name|iclog
operator|->
name|hic_data
operator|+
name|log
operator|->
name|l_iclog_hsize
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|iclog
operator|->
name|ic_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|iclog
operator|->
name|ic_bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_VSEMA
argument_list|(
name|iclog
operator|->
name|ic_bp
argument_list|)
expr_stmt|;
name|sv_init
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|,
name|SV_DEFAULT
argument_list|,
literal|"iclog-force"
argument_list|)
expr_stmt|;
name|sv_init
argument_list|(
operator|&
name|iclog
operator|->
name|ic_writesema
argument_list|,
name|SV_DEFAULT
argument_list|,
literal|"iclog-write"
argument_list|)
expr_stmt|;
name|iclogp
operator|=
operator|&
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
operator|*
name|iclogp
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
comment|/* complete ring */
name|log
operator|->
name|l_iclog
operator|->
name|ic_prev
operator|=
name|prev_iclog
expr_stmt|;
comment|/* re-write 1st prev ptr */
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* xlog_alloc_log */
end_comment

begin_comment
comment|/*  * Write out the commit record of a transaction associated with the given  * ticket.  Return the lsn of the commit record.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_commit_record
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|,
name|xlog_in_core_t
modifier|*
modifier|*
name|iclog
parameter_list|,
name|xfs_lsn_t
modifier|*
name|commitlsnp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_log_iovec_t
name|reg
index|[
literal|1
index|]
decl_stmt|;
name|reg
index|[
literal|0
index|]
operator|.
name|i_addr
operator|=
literal|0
expr_stmt|;
name|reg
index|[
literal|0
index|]
operator|.
name|i_len
operator|=
literal|0
expr_stmt|;
name|ASSERT_ALWAYS
argument_list|(
name|iclog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_write
argument_list|(
name|mp
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|,
name|ticket
argument_list|,
name|commitlsnp
argument_list|,
name|iclog
argument_list|,
name|XLOG_COMMIT_TRANS
argument_list|)
operator|)
condition|)
block|{
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_LOG_IO_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_commit_record */
end_comment

begin_comment
comment|/*  * Push on the buffer cache code if we ever use more than 75% of the on-disk  * log space.  This code pushes on the lsn which would supposedly free up  * the 25% which we want to leave free.  We may need to adopt a policy which  * pushes on an lsn which is further along in the log once we reach the high  * water mark.  In this manner, we would be creating a low water mark.  */
end_comment

begin_function
name|void
name|xlog_grant_push_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|need_bytes
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
comment|/* pointer to the log */
name|xfs_lsn_t
name|tail_lsn
decl_stmt|;
comment|/* lsn of the log tail */
name|xfs_lsn_t
name|threshold_lsn
init|=
literal|0
decl_stmt|;
comment|/* lsn we'd like to be at */
name|int
name|free_blocks
decl_stmt|;
comment|/* free blocks left to write to */
name|int
name|free_bytes
decl_stmt|;
comment|/* free bytes left to write to */
name|int
name|threshold_block
decl_stmt|;
comment|/* block in lsn we'd like to be at */
name|int
name|threshold_cycle
decl_stmt|;
comment|/* lsn cycle we'd like to be at */
name|int
name|free_threshold
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BTOBB
argument_list|(
name|need_bytes
argument_list|)
operator|<
name|log
operator|->
name|l_logBBsize
argument_list|)
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|free_bytes
operator|=
name|xlog_space_left
argument_list|(
name|log
argument_list|,
name|log
operator|->
name|l_grant_reserve_cycle
argument_list|,
name|log
operator|->
name|l_grant_reserve_bytes
argument_list|)
expr_stmt|;
name|tail_lsn
operator|=
name|log
operator|->
name|l_tail_lsn
expr_stmt|;
name|free_blocks
operator|=
name|BTOBBT
argument_list|(
name|free_bytes
argument_list|)
expr_stmt|;
comment|/*      * Set the threshold for the minimum number of free blocks in the      * log to the maximum of what the caller needs, one quarter of the      * log, and 256 blocks.      */
name|free_threshold
operator|=
name|BTOBB
argument_list|(
name|need_bytes
argument_list|)
expr_stmt|;
name|free_threshold
operator|=
name|MAX
argument_list|(
name|free_threshold
argument_list|,
operator|(
name|log
operator|->
name|l_logBBsize
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|free_threshold
operator|=
name|MAX
argument_list|(
name|free_threshold
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_blocks
operator|<
name|free_threshold
condition|)
block|{
name|threshold_block
operator|=
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|+
name|free_threshold
expr_stmt|;
name|threshold_cycle
operator|=
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold_block
operator|>=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
name|threshold_block
operator|-=
name|log
operator|->
name|l_logBBsize
expr_stmt|;
name|threshold_cycle
operator|+=
literal|1
expr_stmt|;
block|}
name|ASSIGN_ANY_LSN
argument_list|(
name|threshold_lsn
argument_list|,
name|threshold_cycle
argument_list|,
name|threshold_block
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
expr_stmt|;
comment|/* Don't pass in an lsn greater than the lsn of the last 	 * log record known to be on disk. 	 */
if|if
condition|(
name|XFS_LSN_CMP_ARCH
argument_list|(
name|threshold_lsn
argument_list|,
name|log
operator|->
name|l_last_sync_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|>
literal|0
condition|)
name|threshold_lsn
operator|=
name|log
operator|->
name|l_last_sync_lsn
expr_stmt|;
block|}
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/*      * Get the transaction layer to kick the dirty buffers out to      * disk asynchronously. No point in trying to do this if      * the filesystem is shutting down.      */
if|if
condition|(
name|threshold_lsn
operator|&&
operator|!
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
name|xfs_trans_push_ail
argument_list|(
name|mp
argument_list|,
name|threshold_lsn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_grant_push_ail */
end_comment

begin_comment
comment|/*  * Flush out the in-core log (iclog) to the on-disk log in a synchronous or  * asynchronous fashion.  Previously, we should have moved the current iclog  * ptr in the log to point to the next available iclog.  This allows further  * write to continue while this code syncs out an iclog ready to go.  * Before an in-core log can be written out, the data section must be scanned  * to save away the 1st word of each BBSIZE block into the header.  We replace  * it with the current cycle count.  Each BBSIZE block is tagged with the  * cycle count because there in an implicit assumption that drives will  * guarantee that entire 512 byte blocks get written at once.  In other words,  * we can't have part of a 512 byte block written and part not written.  By  * tagging each block, we will know which blocks are valid when recovering  * after an unclean shutdown.  *  * This routine is single threaded on the iclog.  No other thread can be in  * this routine with the same iclog.  Changing contents of iclog can there-  * fore be done without grabbing the state machine lock.  Updating the global  * log will require grabbing the lock though.  *  * The entire log manager uses a logical block numbering scheme.  Only  * log_sync (and then only bwrite()) know about the fact that the log may  * not start with block zero on a given device.  The log block start offset  * is added immediately before calling bwrite().  */
end_comment

begin_function
name|int
name|xlog_sync
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
block|{
name|xfs_caddr_t
name|dptr
decl_stmt|;
comment|/* pointer to byte sized element */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ops
decl_stmt|;
name|uint
name|count
decl_stmt|;
comment|/* byte count of bwrite */
name|uint
name|count_init
decl_stmt|;
comment|/* initial count before roundup */
name|int
name|split
init|=
literal|0
decl_stmt|;
comment|/* split write into two regions */
name|int
name|error
decl_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_log_writes
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Add for LR header */
name|count_init
operator|=
name|log
operator|->
name|l_iclog_hsize
operator|+
name|iclog
operator|->
name|ic_offset
expr_stmt|;
comment|/* Round out the log write size */
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
operator|&&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
operator|.
name|sb_logsunit
operator|>
literal|1
condition|)
block|{
comment|/* we have a v2 stripe unit to use */
name|count
operator|=
name|XLOG_LSUNITTOB
argument_list|(
name|log
argument_list|,
name|XLOG_BTOLSUNIT
argument_list|(
name|log
argument_list|,
name|count_init
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|BBTOB
argument_list|(
name|BTOBB
argument_list|(
name|count_init
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iclog
operator|->
name|ic_roundoff
operator|=
name|count
operator|-
name|count_init
expr_stmt|;
name|log
operator|->
name|l_roundoff
operator|+=
name|iclog
operator|->
name|ic_roundoff
expr_stmt|;
name|xlog_pack_data
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
comment|/* put cycle number in every block */
comment|/* real byte length */
name|INT_SET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|iclog
operator|->
name|ic_offset
operator|+
name|iclog
operator|->
name|ic_roundoff
argument_list|)
expr_stmt|;
comment|/* put ops count in correct order */
name|ops
operator|=
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
expr_stmt|;
name|INT_SET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|bp
operator|=
name|iclog
operator|->
name|ic_bp
expr_stmt|;
name|XFS_BUF_PSEMA
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
argument|bp
argument_list|,
argument|unsigned long
argument_list|)
operator|==
operator|(
name|unsigned
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|2
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
name|BLOCK_LSN
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_STATS_ADD
argument_list|(
name|xs_log_blocks
argument_list|,
name|BTOBB
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do we need to split this write into 2 parts? */
if|if
condition|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|+
name|BTOBB
argument_list|(
name|count
argument_list|)
operator|>
name|log
operator|->
name|l_logBBsize
condition|)
block|{
name|split
operator|=
name|count
operator|-
operator|(
name|BBTOB
argument_list|(
name|log
operator|->
name|l_logBBsize
operator|-
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|count
operator|=
name|BBTOB
argument_list|(
name|log
operator|->
name|l_logBBsize
operator|-
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|iclog
operator|->
name|ic_bwritecnt
operator|=
literal|2
expr_stmt|;
comment|/* split into 2 writes */
block|}
else|else
block|{
name|iclog
operator|->
name|ic_bwritecnt
operator|=
literal|1
expr_stmt|;
block|}
name|XFS_BUF_SET_PTR
argument_list|(
name|bp
argument_list|,
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|iclog
operator|->
name|ic_header
operator|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
comment|/* save for later */
name|XFS_BUF_BUSY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_ASYNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_iodone
argument_list|)
expr_stmt|;
comment|/* 	 * Do a disk write cache flush for the log block. 	 * This is a bit of a sledgehammer, it would be better 	 * to use a tag barrier here that just prevents reordering. 	 * It may not be needed to flush the first split block in the log wrap 	 * case, but do it anyways to be safe -AK 	 */
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|l_mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOLOGFLUSH
operator|)
condition|)
name|XFS_BUF_FLUSH
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|<=
name|log
operator|->
name|l_logBBsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|+
name|BTOBB
argument_list|(
name|count
argument_list|)
operator|<=
name|log
operator|->
name|l_logBBsize
argument_list|)
expr_stmt|;
name|xlog_verify_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|count
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* account for log which doesn't start at block #0 */
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|+
name|log
operator|->
name|l_logBBstart
argument_list|)
expr_stmt|;
comment|/* 	 * Don't call xfs_bwrite here. We do log-syncs even when the filesystem 	 * is shutting down. 	 */
name|XFS_BUF_WRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_bwrite
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_sync"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|split
condition|)
block|{
name|bp
operator|=
name|iclog
operator|->
name|ic_log
operator|->
name|l_xbuf
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE2
argument_list|(
argument|bp
argument_list|,
argument|unsigned long
argument_list|)
operator|==
operator|(
name|unsigned
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE2
argument_list|(
name|bp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|2
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* logical 0 */
name|XFS_BUF_SET_PTR
argument_list|(
name|bp
argument_list|,
call|(
name|xfs_caddr_t
call|)
argument_list|(
operator|(
name|__psint_t
operator|)
operator|&
operator|(
name|iclog
operator|->
name|ic_header
operator|)
operator|+
operator|(
name|__psint_t
operator|)
name|count
argument_list|)
argument_list|,
name|split
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
name|XFS_BUF_BUSY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_ASYNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_iodone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|l_mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOLOGFLUSH
operator|)
condition|)
name|XFS_BUF_FLUSH
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dptr
operator|=
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Bump the cycle numbers at the start of each block 		 * since this part of the buffer is at the start of 		 * a new cycle.  Watch out for the header magic number 		 * case, though. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|split
condition|;
name|i
operator|+=
name|BBSIZE
control|)
block|{
name|INT_MOD
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|dptr
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|dptr
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XLOG_HEADER_MAGIC_NUM
condition|)
name|INT_MOD
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|dptr
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dptr
operator|+=
name|BBSIZE
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|<=
name|log
operator|->
name|l_logBBsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|+
name|BTOBB
argument_list|(
name|count
argument_list|)
operator|<=
name|log
operator|->
name|l_logBBsize
argument_list|)
expr_stmt|;
comment|/* account for internal log which does't start at block #0 */
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|+
name|log
operator|->
name|l_logBBstart
argument_list|)
expr_stmt|;
name|XFS_BUF_WRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_bwrite
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_sync (split)"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_sync */
end_comment

begin_comment
comment|/*  * Unallocate a log structure  */
end_comment

begin_function
name|void
name|xlog_unalloc_log
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|,
modifier|*
name|next_iclog
decl_stmt|;
name|xlog_ticket_t
modifier|*
name|tic
decl_stmt|,
modifier|*
name|next_tic
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|log
operator|->
name|l_iclog_bufs
condition|;
name|i
operator|++
control|)
block|{
name|sv_destroy
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|)
expr_stmt|;
name|sv_destroy
argument_list|(
operator|&
name|iclog
operator|->
name|ic_writesema
argument_list|)
expr_stmt|;
name|XFS_BUF_PSEMA
argument_list|(
name|iclog
operator|->
name|ic_bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|xfs_buf_free
argument_list|(
name|iclog
operator|->
name|ic_bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_LOG_TRACE
if|if
condition|(
name|iclog
operator|->
name|ic_trace
operator|!=
name|NULL
condition|)
block|{
name|ktrace_free
argument_list|(
name|iclog
operator|->
name|ic_trace
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|next_iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
name|kmem_free
argument_list|(
name|iclog
operator|->
name|hic_data
argument_list|,
name|log
operator|->
name|l_iclog_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|iclog
argument_list|,
sizeof|sizeof
argument_list|(
name|xlog_in_core_t
argument_list|)
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|next_iclog
expr_stmt|;
block|}
name|freesema
argument_list|(
operator|&
name|log
operator|->
name|l_flushsema
argument_list|)
expr_stmt|;
name|spinlock_destroy
argument_list|(
operator|&
name|log
operator|->
name|l_icloglock
argument_list|)
expr_stmt|;
name|spinlock_destroy
argument_list|(
operator|&
name|log
operator|->
name|l_grant_lock
argument_list|)
expr_stmt|;
comment|/* XXXsup take a look at this again. */
if|if
condition|(
operator|(
name|log
operator|->
name|l_ticket_cnt
operator|!=
name|log
operator|->
name|l_ticket_tcnt
operator|)
operator|&&
operator|!
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
literal|"xlog_unalloc_log: (cnt: %d, total: %d)"
argument_list|,
name|log
operator|->
name|l_ticket_cnt
argument_list|,
name|log
operator|->
name|l_ticket_tcnt
argument_list|)
expr_stmt|;
comment|/* ASSERT(log->l_ticket_cnt == log->l_ticket_tcnt); */
block|}
else|else
block|{
name|tic
operator|=
name|log
operator|->
name|l_unmount_free
expr_stmt|;
while|while
condition|(
name|tic
condition|)
block|{
name|next_tic
operator|=
name|tic
operator|->
name|t_next
expr_stmt|;
name|kmem_free
argument_list|(
name|tic
argument_list|,
name|NBPP
argument_list|)
expr_stmt|;
name|tic
operator|=
name|next_tic
expr_stmt|;
block|}
block|}
name|XFS_BUF_PSEMA
argument_list|(
name|log
operator|->
name|l_xbuf
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|xfs_buf_free
argument_list|(
name|log
operator|->
name|l_xbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_LOG_TRACE
if|if
condition|(
name|log
operator|->
name|l_trace
operator|!=
name|NULL
condition|)
block|{
name|ktrace_free
argument_list|(
name|log
operator|->
name|l_trace
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|->
name|l_grant_trace
operator|!=
name|NULL
condition|)
block|{
name|ktrace_free
argument_list|(
name|log
operator|->
name|l_grant_trace
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|log
operator|->
name|l_mp
operator|->
name|m_log
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|xlog_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_unalloc_log */
end_comment

begin_comment
comment|/*  * Update counters atomically now that memcpy is done.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|xlog_state_finish_copy
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|record_cnt
parameter_list|,
name|int
name|copy_bytes
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
operator|+=
name|record_cnt
expr_stmt|;
name|iclog
operator|->
name|ic_offset
operator|+=
name|copy_bytes
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_state_finish_copy */
end_comment

begin_comment
comment|/*  * Write some region out to in-core log  *  * This will be called when writing externally provided regions or when  * writing out a commit record for a given transaction.  *  * General algorithm:  *	1. Find total length of this write.  This may include adding to the  *		lengths passed in.  *	2. Check whether we violate the tickets reservation.  *	3. While writing to this iclog  *	    A. Reserve as much space in this iclog as can get  *	    B. If this is first write, save away start lsn  *	    C. While writing this region:  *		1. If first write of transaction, write start record  *		2. Write log operation header (header per region)  *		3. Find out if we can fit entire region into this iclog  *		4. Potentially, verify destination memcpy ptr  *		5. Memcpy (partial) region  *		6. If partial copy, release iclog; otherwise, continue  *			copying more regions into current iclog  *	4. Mark want sync bit (in simulation mode)  *	5. Release iclog for potential flush to on-disk log.  *  * ERRORS:  * 1.	Panic if reservation is overrun.  This should never happen since  *	reservation amounts are generated internal to the filesystem.  * NOTES:  * 1. Tickets are single threaded data structures.  * 2. The XLOG_END_TRANS& XLOG_CONTINUE_TRANS flags are passed down to the  *	syncing routine.  When a single log_write region needs to span  *	multiple in-core logs, the XLOG_CONTINUE_TRANS bit should be set  *	on all log operation writes which don't contain the end of the  *	region.  The XLOG_END_TRANS bit is used for the in-core log  *	operation which contains the end of the continued log_write region.  * 3. When xlog_state_get_iclog_space() grabs the rest of the current iclog,  *	we don't really know exactly how much space will be used.  As a result,  *	we don't update ic_offset until the end when we know exactly how many  *	bytes have been written out.  */
end_comment

begin_function
name|int
name|xlog_write
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_iovec_t
name|reg
index|[]
parameter_list|,
name|int
name|nentries
parameter_list|,
name|xfs_log_ticket_t
name|tic
parameter_list|,
name|xfs_lsn_t
modifier|*
name|start_lsn
parameter_list|,
name|xlog_in_core_t
modifier|*
modifier|*
name|commit_iclog
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xlog_ticket_t
modifier|*
name|ticket
init|=
operator|(
name|xlog_ticket_t
operator|*
operator|)
name|tic
decl_stmt|;
name|xlog_op_header_t
modifier|*
name|logop_head
decl_stmt|;
comment|/* ptr to log operation header */
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
comment|/* ptr to current in-core log */
name|__psint_t
name|ptr
decl_stmt|;
comment|/* copy address into data region */
name|int
name|len
decl_stmt|;
comment|/* # xlog_write() bytes 2 still copy */
name|int
name|index
decl_stmt|;
comment|/* region index currently copying */
name|int
name|log_offset
decl_stmt|;
comment|/* offset (from 0) into data region */
name|int
name|start_rec_copy
decl_stmt|;
comment|/* # bytes to copy for start record */
name|int
name|partial_copy
decl_stmt|;
comment|/* did we split a region? */
name|int
name|partial_copy_len
decl_stmt|;
comment|/* # bytes copied if split region */
name|int
name|need_copy
decl_stmt|;
comment|/* # bytes need to memcpy this region */
name|int
name|copy_len
decl_stmt|;
comment|/* # bytes actually memcpy'ing */
name|int
name|copy_off
decl_stmt|;
comment|/* # bytes from entry start */
name|int
name|contwr
decl_stmt|;
comment|/* continued write of in-core log? */
name|int
name|firstwr
init|=
literal|0
decl_stmt|;
comment|/* first write of transaction */
name|int
name|error
decl_stmt|;
name|int
name|record_cnt
init|=
literal|0
decl_stmt|,
name|data_cnt
init|=
literal|0
decl_stmt|;
name|partial_copy_len
operator|=
name|partial_copy
operator|=
literal|0
expr_stmt|;
comment|/* Calculate potential maximum space.  Each region gets its own      * xlog_op_header_t and may need to be double word aligned.      */
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_INITED
condition|)
comment|/* acct for start rec of xact */
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nentries
condition|;
name|index
operator|++
control|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
comment|/* each region gets>= 1 */
name|len
operator|+=
name|reg
index|[
name|index
index|]
operator|.
name|i_len
expr_stmt|;
block|}
name|contwr
operator|=
operator|*
name|start_lsn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ticket
operator|->
name|t_curr_res
operator|<
name|len
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xlog_panic
argument_list|(
literal|"xfs_log_write: reservation ran out. Need to up reservation"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Customer configurable panic */
name|xfs_cmn_err
argument_list|(
name|XFS_PTAG_LOGRES
argument_list|,
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_log_write: reservation ran out. Need to up reservation"
argument_list|)
expr_stmt|;
comment|/* If we did not panic, shutdown the filesystem */
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_CORRUPT_INCORE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ticket
operator|->
name|t_curr_res
operator|-=
name|len
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nentries
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_state_get_iclog_space
argument_list|(
name|log
argument_list|,
name|len
argument_list|,
operator|&
name|iclog
argument_list|,
name|ticket
argument_list|,
operator|&
name|contwr
argument_list|,
operator|&
name|log_offset
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|log_offset
operator|<=
name|iclog
operator|->
name|ic_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
call|(
name|__psint_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iclog
operator|->
name|ic_datap
operator|+
name|log_offset
argument_list|)
expr_stmt|;
comment|/* start_lsn is the first lsn written to. That's all we need. */
if|if
condition|(
operator|!
operator|*
name|start_lsn
condition|)
operator|*
name|start_lsn
operator|=
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* This loop writes out as many regions as can fit in the amount 	 * of space which was allocated by xlog_state_get_iclog_space(). 	 */
while|while
condition|(
name|index
operator|<
name|nentries
condition|)
block|{
name|ASSERT
argument_list|(
name|reg
index|[
name|index
index|]
operator|.
name|i_len
operator|%
sizeof|sizeof
argument_list|(
name|__int32_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|__psint_t
operator|)
name|ptr
operator|%
sizeof|sizeof
argument_list|(
name|__int32_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|start_rec_copy
operator|=
literal|0
expr_stmt|;
comment|/* If first write for transaction, insert start record. 	     * We can't be trying to commit if we are inited.  We can't 	     * have any "partial_copy" if we are inited. 	     */
if|if
condition|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_INITED
condition|)
block|{
name|logop_head
operator|=
operator|(
name|xlog_op_header_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|INT_SET
argument_list|(
name|logop_head
operator|->
name|oh_tid
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ticket
operator|->
name|t_tid
argument_list|)
expr_stmt|;
name|logop_head
operator|->
name|oh_clientid
operator|=
name|ticket
operator|->
name|t_clientid
expr_stmt|;
name|INT_ZERO
argument_list|(
name|logop_head
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|logop_head
operator|->
name|oh_flags
operator|=
name|XLOG_START_TRANS
expr_stmt|;
name|INT_ZERO
argument_list|(
name|logop_head
operator|->
name|oh_res2
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ticket
operator|->
name|t_flags
operator|&=
operator|~
name|XLOG_TIC_INITED
expr_stmt|;
comment|/* clear bit */
name|firstwr
operator|=
literal|1
expr_stmt|;
comment|/* increment log ops below */
name|record_cnt
operator|++
expr_stmt|;
name|start_rec_copy
operator|=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
name|xlog_write_adv_cnt
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
name|log_offset
argument_list|,
name|start_rec_copy
argument_list|)
expr_stmt|;
block|}
comment|/* Copy log operation header directly into data section */
name|logop_head
operator|=
operator|(
name|xlog_op_header_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|INT_SET
argument_list|(
name|logop_head
operator|->
name|oh_tid
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|ticket
operator|->
name|t_tid
argument_list|)
expr_stmt|;
name|logop_head
operator|->
name|oh_clientid
operator|=
name|ticket
operator|->
name|t_clientid
expr_stmt|;
name|INT_ZERO
argument_list|(
name|logop_head
operator|->
name|oh_res2
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* header copied directly */
name|xlog_write_adv_cnt
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
name|log_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* are we copying a commit or unmount record? */
name|logop_head
operator|->
name|oh_flags
operator|=
name|flags
expr_stmt|;
comment|/* 	     * We've seen logs corrupted with bad transaction client 	     * ids.  This makes sure that XFS doesn't generate them on. 	     * Turn this into an EIO and shut down the filesystem. 	     */
switch|switch
condition|(
name|logop_head
operator|->
name|oh_clientid
condition|)
block|{
case|case
name|XFS_TRANSACTION
case|:
case|case
name|XFS_VOLUME
case|:
case|case
name|XFS_LOG
case|:
break|break;
default|default:
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"Bad XFS transaction clientid 0x%x in ticket 0x%p"
argument_list|,
name|logop_head
operator|->
name|oh_clientid
argument_list|,
name|tic
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
comment|/* Partial write last time? => (partial_copy != 0) 	     * need_copy is the amount we'd like to copy if everything could 	     * fit in the current memcpy. 	     */
name|need_copy
operator|=
name|reg
index|[
name|index
index|]
operator|.
name|i_len
operator|-
name|partial_copy_len
expr_stmt|;
name|copy_off
operator|=
name|partial_copy_len
expr_stmt|;
if|if
condition|(
name|need_copy
operator|<=
name|iclog
operator|->
name|ic_size
operator|-
name|log_offset
condition|)
block|{
comment|/*complete write */
name|INT_SET
argument_list|(
name|logop_head
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|copy_len
operator|=
name|need_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial_copy
condition|)
name|logop_head
operator|->
name|oh_flags
operator||=
operator|(
name|XLOG_END_TRANS
operator||
name|XLOG_WAS_CONT_TRANS
operator|)
expr_stmt|;
name|partial_copy_len
operator|=
name|partial_copy
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* partial write */
name|copy_len
operator|=
name|iclog
operator|->
name|ic_size
operator|-
name|log_offset
expr_stmt|;
name|INT_SET
argument_list|(
name|logop_head
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|logop_head
operator|->
name|oh_flags
operator||=
name|XLOG_CONTINUE_TRANS
expr_stmt|;
if|if
condition|(
name|partial_copy
condition|)
name|logop_head
operator|->
name|oh_flags
operator||=
name|XLOG_WAS_CONT_TRANS
expr_stmt|;
name|partial_copy_len
operator|+=
name|copy_len
expr_stmt|;
name|partial_copy
operator|++
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
comment|/* from splitting of region */
comment|/* account for new log op header */
name|ticket
operator|->
name|t_curr_res
operator|-=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
block|}
name|xlog_verify_dest_ptr
argument_list|(
name|log
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* copy region */
name|ASSERT
argument_list|(
name|copy_len
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|ptr
argument_list|,
name|reg
index|[
name|index
index|]
operator|.
name|i_addr
operator|+
name|copy_off
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|xlog_write_adv_cnt
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|,
name|log_offset
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
comment|/* make copy_len total bytes copied, including headers */
name|copy_len
operator|+=
name|start_rec_copy
operator|+
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
name|record_cnt
operator|++
expr_stmt|;
name|data_cnt
operator|+=
name|contwr
condition|?
name|copy_len
else|:
literal|0
expr_stmt|;
name|firstwr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial_copy
condition|)
block|{
comment|/* copied partial region */
comment|/* already marked WANT_SYNC by xlog_state_get_iclog_space */
name|xlog_state_finish_copy
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|record_cnt
argument_list|,
name|data_cnt
argument_list|)
expr_stmt|;
name|record_cnt
operator|=
name|data_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
comment|/* don't increment index */
block|}
else|else
block|{
comment|/* copied entire region */
name|index
operator|++
expr_stmt|;
name|partial_copy_len
operator|=
name|partial_copy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iclog
operator|->
name|ic_size
operator|-
name|log_offset
operator|<=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
condition|)
block|{
name|xlog_state_finish_copy
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|record_cnt
argument_list|,
name|data_cnt
argument_list|)
expr_stmt|;
name|record_cnt
operator|=
name|data_cnt
operator|=
literal|0
expr_stmt|;
name|xlog_state_want_sync
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_iclog
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|XLOG_COMMIT_TRANS
argument_list|)
expr_stmt|;
operator|*
name|commit_iclog
operator|=
name|iclog
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|index
operator|==
name|nentries
condition|)
return|return
literal|0
return|;
comment|/* we are done */
else|else
break|break;
block|}
block|}
comment|/* if (partial_copy) */
block|}
comment|/* while (index< nentries) */
block|}
comment|/* for (index = 0; index< nentries; ) */
name|ASSERT
argument_list|(
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xlog_state_finish_copy
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|record_cnt
argument_list|,
name|data_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_iclog
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|XLOG_COMMIT_TRANS
argument_list|)
expr_stmt|;
operator|*
name|commit_iclog
operator|=
name|iclog
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_write */
end_comment

begin_comment
comment|/*****************************************************************************  *  *		State Machine functions  *  *****************************************************************************  */
end_comment

begin_comment
comment|/* Clean iclogs starting from the head.  This ordering must be  * maintained, so an iclog doesn't become ACTIVE beyond one that  * is SYNCING.  This is also required to maintain the notion that we use  * a counting semaphore to hold off would be writers to the log when every  * iclog is trying to sync to disk.  *  * State Change: DIRTY -> ACTIVE  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_state_clean_log
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
condition|)
block|{
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_ACTIVE
expr_stmt|;
name|iclog
operator|->
name|ic_offset
operator|=
literal|0
expr_stmt|;
name|iclog
operator|->
name|ic_callback
operator|=
literal|0
expr_stmt|;
comment|/* don't need to free */
comment|/* 			 * If the number of ops in this iclog indicate it just 			 * contains the dummy transaction, we can 			 * change state into IDLE (the second time around). 			 * Otherwise we should change the state into 			 * NEED a dummy. 			 * We don't need to cover the dummy. 			 */
if|if
condition|(
operator|!
name|changed
operator|&&
operator|(
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XLOG_COVER_OPS
operator|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We have two dirty iclogs so start over 				 * This could also be num of ops indicates 				 * this is not the dummy going out. 				 */
name|changed
operator|=
literal|2
expr_stmt|;
block|}
name|INT_ZERO
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_cycle_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_cycle_data
argument_list|)
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
condition|)
comment|/* do nothing */
empty_stmt|;
else|else
break|break;
comment|/* stop cleaning */
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|iclog
operator|!=
name|log
operator|->
name|l_iclog
condition|)
do|;
comment|/* log is locked when we are called */
comment|/* 	 * Change state for the dummy log recording. 	 * We usually go to NEED. But we go to NEED2 if the changed indicates 	 * we are done writing the dummy record. 	 * If we are done with the second dummy recored (DONE2), then 	 * we go to IDLE. 	 */
if|if
condition|(
name|changed
condition|)
block|{
switch|switch
condition|(
name|log
operator|->
name|l_covered_state
condition|)
block|{
case|case
name|XLOG_STATE_COVER_IDLE
case|:
case|case
name|XLOG_STATE_COVER_NEED
case|:
case|case
name|XLOG_STATE_COVER_NEED2
case|:
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_NEED
expr_stmt|;
break|break;
case|case
name|XLOG_STATE_COVER_DONE
case|:
if|if
condition|(
name|changed
operator|==
literal|1
condition|)
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_NEED2
expr_stmt|;
else|else
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_NEED
expr_stmt|;
break|break;
case|case
name|XLOG_STATE_COVER_DONE2
case|:
if|if
condition|(
name|changed
operator|==
literal|1
condition|)
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_IDLE
expr_stmt|;
else|else
name|log
operator|->
name|l_covered_state
operator|=
name|XLOG_STATE_COVER_NEED
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* xlog_state_clean_log */
end_comment

begin_function
name|STATIC
name|xfs_lsn_t
name|xlog_get_lowest_lsn
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|lsn_log
decl_stmt|;
name|xfs_lsn_t
name|lowest_lsn
decl_stmt|,
name|lsn
decl_stmt|;
name|lsn_log
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
name|lowest_lsn
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|lsn_log
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_ACTIVE
operator||
name|XLOG_STATE_DIRTY
operator|)
operator|)
condition|)
block|{
name|lsn
operator|=
name|INT_GET
argument_list|(
name|lsn_log
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsn
operator|&&
operator|!
name|lowest_lsn
operator|)
operator|||
operator|(
name|XFS_LSN_CMP_ARCH
argument_list|(
name|lsn
argument_list|,
name|lowest_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|lowest_lsn
operator|=
name|lsn
expr_stmt|;
block|}
block|}
name|lsn_log
operator|=
name|lsn_log
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|lsn_log
operator|!=
name|log
operator|->
name|l_iclog
condition|)
do|;
return|return
operator|(
name|lowest_lsn
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_state_do_callback
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|aborted
parameter_list|,
name|xlog_in_core_t
modifier|*
name|ciclog
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|first_iclog
decl_stmt|;
comment|/* used to know when we've 						 * processed all iclogs once */
name|xfs_log_callback_t
modifier|*
name|cb
decl_stmt|,
modifier|*
name|cb_next
decl_stmt|;
name|int
name|flushcnt
init|=
literal|0
decl_stmt|;
name|xfs_lsn_t
name|lowest_lsn
decl_stmt|;
name|int
name|ioerrors
decl_stmt|;
comment|/* counter: iclogs with errors */
name|int
name|loopdidcallbacks
decl_stmt|;
comment|/* flag: inner loop did callbacks*/
name|int
name|funcdidcallbacks
decl_stmt|;
comment|/* flag: function did callbacks */
name|int
name|repeats
decl_stmt|;
comment|/* for issuing console warnings if 					 * looping too many times */
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|first_iclog
operator|=
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
name|ioerrors
operator|=
literal|0
expr_stmt|;
name|funcdidcallbacks
operator|=
literal|0
expr_stmt|;
name|repeats
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* 		 * Scan all iclogs starting with the one pointed to by the 		 * log.  Reset this starting point each time the log is 		 * unlocked (during callbacks). 		 * 		 * Keep looping through iclogs until one full pass is made 		 * without running any callbacks. 		 */
name|first_iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
name|loopdidcallbacks
operator|=
literal|0
expr_stmt|;
name|repeats
operator|++
expr_stmt|;
do|do
block|{
comment|/* skip all iclogs in the ACTIVE& DIRTY states */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_ACTIVE
operator||
name|XLOG_STATE_DIRTY
operator|)
condition|)
block|{
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Between marking a filesystem SHUTDOWN and stopping 			 * the log, we do flush all iclogs to disk (if there 			 * wasn't a log I/O error). So, we do want things to 			 * go smoothly in case of just a SHUTDOWN  w/o a 			 * LOG_IO_ERROR. 			 */
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
condition|)
block|{
comment|/* 				 * Can only perform callbacks in order.  Since 				 * this iclog is not in the DONE_SYNC/ 				 * DO_CALLBACK state, we skip the rest and 				 * just try to clean up.  If we set our iclog 				 * to DO_CALLBACK, we will not process it when 				 * we retry since a previous iclog is in the 				 * CALLBACK and the state cannot change since 				 * we are holding the LOG_LOCK. 				 */
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_DONE_SYNC
operator||
name|XLOG_STATE_DO_CALLBACK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ciclog
operator|&&
operator|(
name|ciclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DONE_SYNC
operator|)
condition|)
block|{
name|ciclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_DO_CALLBACK
expr_stmt|;
block|}
break|break;
block|}
comment|/* 				 * We now have an iclog that is in either the 				 * DO_CALLBACK or DONE_SYNC states. The other 				 * states (WANT_SYNC, SYNCING, or CALLBACK were 				 * caught by the above if and are going to 				 * clean (i.e. we aren't doing their callbacks) 				 * see the above if. 				 */
comment|/* 				 * We will do one more check here to see if we 				 * have chased our tail around. 				 */
name|lowest_lsn
operator|=
name|xlog_get_lowest_lsn
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_lsn
operator|&&
operator|(
name|XFS_LSN_CMP_ARCH
argument_list|(
name|lowest_lsn
argument_list|,
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
continue|continue;
comment|/* Leave this iclog for 						   * another thread */
block|}
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_CALLBACK
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* l_last_sync_lsn field protected by 				 * GRANT_LOCK. Don't worry about iclog's lsn. 				 * No one else can be here except us. 				 */
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_LSN_CMP_ARCH
argument_list|(
name|log
operator|->
name|l_last_sync_lsn
argument_list|,
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_last_sync_lsn
operator|=
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 				 * Keep processing entries in the callback list 				 * until we come around and it is empty.  We 				 * need to atomically see that the list is 				 * empty and change the state to DIRTY so that 				 * we don't miss any more callbacks being added. 				 */
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ioerrors
operator|++
expr_stmt|;
block|}
name|cb
operator|=
name|iclog
operator|->
name|ic_callback
expr_stmt|;
while|while
condition|(
name|cb
operator|!=
literal|0
condition|)
block|{
name|iclog
operator|->
name|ic_callback_tail
operator|=
operator|&
operator|(
name|iclog
operator|->
name|ic_callback
operator|)
expr_stmt|;
name|iclog
operator|->
name|ic_callback
operator|=
literal|0
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* perform callbacks in the order given */
for|for
control|(
init|;
name|cb
operator|!=
literal|0
condition|;
name|cb
operator|=
name|cb_next
control|)
block|{
name|cb_next
operator|=
name|cb
operator|->
name|cb_next
expr_stmt|;
name|cb
operator|->
name|cb_func
argument_list|(
name|cb
operator|->
name|cb_arg
argument_list|,
name|aborted
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|cb
operator|=
name|iclog
operator|->
name|ic_callback
expr_stmt|;
block|}
name|loopdidcallbacks
operator|++
expr_stmt|;
name|funcdidcallbacks
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_callback
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
condition|)
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_DIRTY
expr_stmt|;
comment|/* 			 * Transition from DIRTY to ACTIVE if applicable. 			 * NOP if STATE_IOERROR. 			 */
name|xlog_state_clean_log
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* wake up threads waiting in xfs_log_force() */
name|sv_broadcast
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|first_iclog
operator|!=
name|iclog
condition|)
do|;
if|if
condition|(
name|repeats
operator|&&
operator|(
name|repeats
operator|%
literal|10
operator|)
operator|==
literal|0
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
literal|"xlog_state_do_callback: looping %d"
argument_list|,
name|repeats
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|ioerrors
operator|&&
name|loopdidcallbacks
condition|)
do|;
comment|/* 	 * make one last gasp attempt to see if iclogs are being left in 	 * limbo.. 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|funcdidcallbacks
condition|)
block|{
name|first_iclog
operator|=
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|!=
name|XLOG_STATE_DO_CALLBACK
argument_list|)
expr_stmt|;
comment|/* 			 * Terminate the loop if iclogs are found in states 			 * which will cause other threads to clean up iclogs. 			 * 			 * SYNCING - i/o completion will go through logs 			 * DONE_SYNC - interrupt thread should be waiting for 			 *              LOG_LOCK 			 * IOERROR - give up hope all ye who enter here 			 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_WANT_SYNC
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_SYNCING
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DONE_SYNC
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_IOERROR
condition|)
break|break;
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|first_iclog
operator|!=
name|iclog
condition|)
do|;
block|}
endif|#
directive|endif
if|if
condition|(
name|log
operator|->
name|l_iclog
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_ACTIVE
operator||
name|XLOG_STATE_IOERROR
operator|)
condition|)
block|{
name|flushcnt
operator|=
name|log
operator|->
name|l_flushcnt
expr_stmt|;
name|log
operator|->
name|l_flushcnt
operator|=
literal|0
expr_stmt|;
block|}
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|flushcnt
operator|--
condition|)
name|vsema
argument_list|(
operator|&
name|log
operator|->
name|l_flushsema
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_state_do_callback */
end_comment

begin_comment
comment|/*  * Finish transitioning this iclog to the dirty state.  *  * Make sure that we completely execute this routine only when this is  * the last call to the iclog.  There is a good chance that iclog flushes,  * when we reach the end of the physical log, get turned into 2 separate  * calls to bwrite.  Hence, one iclog flush could generate two calls to this  * routine.  By using the reference count bwritecnt, we guarantee that only  * the second completion goes through.  *  * Callbacks could take time, so they are done outside the scope of the  * global state machine log lock.  Assume that the calls to cvsema won't  * take a long time.  At least we know it won't sleep.  */
end_comment

begin_function
name|void
name|xlog_state_done_syncing
parameter_list|(
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|aborted
parameter_list|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|iclog
operator|->
name|ic_log
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_SYNCING
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_IOERROR
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_bwritecnt
operator|==
literal|1
operator|||
name|iclog
operator|->
name|ic_bwritecnt
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * If we got an error, either on the first buffer, or in the case of 	 * split log writes, on the second, we mark ALL iclogs STATE_IOERROR, 	 * and none should ever be attempted to be written to disk 	 * again. 	 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|!=
name|XLOG_STATE_IOERROR
condition|)
block|{
if|if
condition|(
operator|--
name|iclog
operator|->
name|ic_bwritecnt
operator|==
literal|1
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_DONE_SYNC
expr_stmt|;
block|}
comment|/* 	 * Someone could be sleeping prior to writing out the next 	 * iclog buffer, we wake them all, one will get to do the 	 * I/O, the others get to wait for the result. 	 */
name|sv_broadcast
argument_list|(
operator|&
name|iclog
operator|->
name|ic_writesema
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xlog_state_do_callback
argument_list|(
name|log
argument_list|,
name|aborted
argument_list|,
name|iclog
argument_list|)
expr_stmt|;
comment|/* also cleans log */
block|}
end_function

begin_comment
comment|/* xlog_state_done_syncing */
end_comment

begin_comment
comment|/*  * If the head of the in-core log ring is not (ACTIVE or DIRTY), then we must  * sleep.  The flush semaphore is set to the number of in-core buffers and  * decremented around disk syncing.  Therefore, if all buffers are syncing,  * this semaphore will cause new writes to sleep until a sync completes.  * Otherwise, this code just does p() followed by v().  This approximates  * a sleep/wakeup except we can't race.  *  * The in-core logs are used in a circular fashion. They are not used  * out-of-order even when an iclog past the head is free.  *  * return:  *	* log_offset where xlog_write() can start writing into the in-core  *		log's data space.  *	* in-core log pointer to which xlog_write() should write.  *	* boolean indicating this is a continued write to an in-core log.  *		If this is the last write, then the in-core log's offset field  *		needs to be incremented, depending on the amount of data which  *		is copied.  */
end_comment

begin_function
name|int
name|xlog_state_get_iclog_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|len
parameter_list|,
name|xlog_in_core_t
modifier|*
modifier|*
name|iclogp
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|,
name|int
modifier|*
name|continued_write
parameter_list|,
name|int
modifier|*
name|logoffsetp
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|int
name|log_offset
decl_stmt|;
name|xlog_rec_header_t
modifier|*
name|head
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|int
name|error
decl_stmt|;
name|restart
label|:
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|)
condition|)
block|{
name|log
operator|->
name|l_flushcnt
operator|++
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xlog_trace_iclog
argument_list|(
name|iclog
argument_list|,
name|XLOG_TRACE_SLEEP_FLUSH
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_log_noiclogs
argument_list|)
expr_stmt|;
comment|/* Ensure that log writes happen */
name|psema
argument_list|(
operator|&
name|log
operator|->
name|l_flushsema
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|iclog
operator|->
name|ic_header
expr_stmt|;
name|iclog
operator|->
name|ic_refcnt
operator|++
expr_stmt|;
comment|/* prevents sync */
name|log_offset
operator|=
name|iclog
operator|->
name|ic_offset
expr_stmt|;
comment|/* On the 1st write to an iclog, figure out lsn.  This works 	 * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are 	 * committing to.  If the offset is set, that's how many blocks 	 * must be written. 	 */
if|if
condition|(
name|log_offset
operator|==
literal|0
condition|)
block|{
name|ticket
operator|->
name|t_curr_res
operator|-=
name|log
operator|->
name|l_iclog_hsize
expr_stmt|;
name|INT_SET
argument_list|(
name|head
operator|->
name|h_cycle
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|log
operator|->
name|l_curr_cycle
argument_list|)
expr_stmt|;
name|ASSIGN_LSN
argument_list|(
name|head
operator|->
name|h_lsn
argument_list|,
name|log
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_curr_block
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* round off error from last write with this iclog */
name|ticket
operator|->
name|t_curr_res
operator|-=
name|iclog
operator|->
name|ic_roundoff
expr_stmt|;
name|log
operator|->
name|l_roundoff
operator|-=
name|iclog
operator|->
name|ic_roundoff
expr_stmt|;
name|iclog
operator|->
name|ic_roundoff
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If there is enough room to write everything, then do it.  Otherwise, 	 * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC 	 * bit is on, so this will get flushed out.  Don't update ic_offset 	 * until you know exactly how many bytes get copied.  Therefore, wait 	 * until later to update ic_offset. 	 * 	 * xlog_write() algorithm assumes that at least 2 xlog_op_header_t's 	 * can fit into remaining data section. 	 */
if|if
condition|(
name|iclog
operator|->
name|ic_size
operator|-
name|iclog
operator|->
name|ic_offset
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
condition|)
block|{
name|xlog_state_switch_iclogs
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|iclog
operator|->
name|ic_size
argument_list|)
expr_stmt|;
comment|/* If I'm the only one writing to this iclog, sync it to disk */
if|if
condition|(
name|iclog
operator|->
name|ic_refcnt
operator|==
literal|1
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|iclog
operator|->
name|ic_refcnt
operator|--
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
comment|/* Do we have enough room to write the full amount in the remainder 	 * of this iclog?  Or must we continue a write on the next iclog and 	 * mark this iclog as completely taken?  In the case where we switch 	 * iclogs (to mark it taken), this particular iclog will release/sync 	 * to disk in xlog_write(). 	 */
if|if
condition|(
name|len
operator|<=
name|iclog
operator|->
name|ic_size
operator|-
name|iclog
operator|->
name|ic_offset
condition|)
block|{
operator|*
name|continued_write
operator|=
literal|0
expr_stmt|;
name|iclog
operator|->
name|ic_offset
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
operator|*
name|continued_write
operator|=
literal|1
expr_stmt|;
name|xlog_state_switch_iclogs
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|iclog
operator|->
name|ic_size
argument_list|)
expr_stmt|;
block|}
operator|*
name|iclogp
operator|=
name|iclog
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_offset
operator|<=
name|iclog
operator|->
name|ic_size
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|logoffsetp
operator|=
name|log_offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xlog_state_get_iclog_space */
end_comment

begin_comment
comment|/*  * Atomically get the log space required for a log ticket.  *  * Once a ticket gets put onto the reserveq, it will only return after  * the needed reservation is satisfied.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_grant_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|tic
parameter_list|)
block|{
name|int
name|free_bytes
decl_stmt|;
name|int
name|need_bytes
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_lsn_t
name|tail_lsn
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_ACTIVE_RECOVERY
condition|)
name|panic
argument_list|(
literal|"grant Recovery problem"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Is there space or do we need to sleep? */
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: enter"
argument_list|)
expr_stmt|;
comment|/* something is already sleeping; insert new transaction at end */
if|if
condition|(
name|log
operator|->
name|l_reserve_headq
condition|)
block|{
name|XLOG_INS_TICKETQ
argument_list|(
name|log
operator|->
name|l_reserve_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: sleep 1"
argument_list|)
expr_stmt|;
comment|/* 		 * Gotta check this before going to sleep, while we're 		 * holding the grant lock. 		 */
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|XFS_STATS_INC
argument_list|(
name|xs_sleep_logspace
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|,
name|PINOD
operator||
name|PLTWAIT
argument_list|,
operator|&
name|log
operator|->
name|l_grant_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * If we got an error, and the filesystem is shutting down, 		 * we'll catch it down below. So just continue... 		 */
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: wake 1"
argument_list|)
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tic
operator|->
name|t_flags
operator|&
name|XFS_LOG_PERM_RESERV
condition|)
name|need_bytes
operator|=
name|tic
operator|->
name|t_unit_res
operator|*
name|tic
operator|->
name|t_ocnt
expr_stmt|;
else|else
name|need_bytes
operator|=
name|tic
operator|->
name|t_unit_res
expr_stmt|;
name|redo
label|:
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|free_bytes
operator|=
name|xlog_space_left
argument_list|(
name|log
argument_list|,
name|log
operator|->
name|l_grant_reserve_cycle
argument_list|,
name|log
operator|->
name|l_grant_reserve_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_bytes
operator|<
name|need_bytes
condition|)
block|{
if|if
condition|(
operator|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
operator|)
operator|==
literal|0
condition|)
name|XLOG_INS_TICKETQ
argument_list|(
name|log
operator|->
name|l_reserve_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: sleep 2"
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_sleep_logspace
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|,
name|PINOD
operator||
name|PLTWAIT
argument_list|,
operator|&
name|log
operator|->
name|l_grant_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: wake 2"
argument_list|)
expr_stmt|;
name|xlog_grant_push_ail
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|need_bytes
argument_list|)
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
elseif|else
if|if
condition|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
condition|)
name|XLOG_DEL_TICKETQ
argument_list|(
name|log
operator|->
name|l_reserve_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
comment|/* we've got enough space */
name|XLOG_GRANT_ADD_SPACE
argument_list|(
name|log
argument_list|,
name|need_bytes
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|XLOG_GRANT_ADD_SPACE
argument_list|(
name|log
argument_list|,
name|need_bytes
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|tail_lsn
operator|=
name|log
operator|->
name|l_tail_lsn
expr_stmt|;
comment|/* 	 * Check to make sure the grant write head didn't just over lap the 	 * tail.  If the cycles are the same, we can't be overlapping. 	 * Otherwise, make sure that the cycles differ by exactly one and 	 * check the byte count. 	 */
if|if
condition|(
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|!=
name|log
operator|->
name|l_grant_write_cycle
condition|)
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_write_cycle
operator|-
literal|1
operator|==
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_write_bytes
operator|<=
name|BBTOB
argument_list|(
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: exit"
argument_list|)
expr_stmt|;
name|xlog_verify_grant_head
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error_return
label|:
if|if
condition|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
condition|)
name|XLOG_DEL_TICKETQ
argument_list|(
name|log
operator|->
name|l_reserve_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_grant_log_space: err_ret"
argument_list|)
expr_stmt|;
comment|/* 	 * If we are failing, make sure the ticket doesn't have any 	 * current reservations. We don't want to add this back when 	 * the ticket/transaction gets cancelled. 	 */
name|tic
operator|->
name|t_curr_res
operator|=
literal|0
expr_stmt|;
name|tic
operator|->
name|t_cnt
operator|=
literal|0
expr_stmt|;
comment|/* ungrant will give back unit_res * t_cnt. */
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_grant_log_space */
end_comment

begin_comment
comment|/*  * Replenish the byte reservation required by moving the grant write head.  *  *  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_regrant_write_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|tic
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|int
name|free_bytes
decl_stmt|,
name|need_bytes
decl_stmt|;
name|xlog_ticket_t
modifier|*
name|ntic
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_lsn_t
name|tail_lsn
decl_stmt|;
endif|#
directive|endif
name|tic
operator|->
name|t_curr_res
operator|=
name|tic
operator|->
name|t_unit_res
expr_stmt|;
if|if
condition|(
name|tic
operator|->
name|t_cnt
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_ACTIVE_RECOVERY
condition|)
name|panic
argument_list|(
literal|"regrant Recovery problem"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_regrant_write_log_space: enter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If there are other waiters on the queue then give them a 	 * chance at logspace before us. Wake up the first waiters, 	 * if we do not wake up all the waiters then go to sleep waiting 	 * for more free space, otherwise try to get some space for 	 * this transaction. 	 */
if|if
condition|(
operator|(
name|ntic
operator|=
name|log
operator|->
name|l_write_headq
operator|)
condition|)
block|{
name|free_bytes
operator|=
name|xlog_space_left
argument_list|(
name|log
argument_list|,
name|log
operator|->
name|l_grant_write_cycle
argument_list|,
name|log
operator|->
name|l_grant_write_bytes
argument_list|)
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|ntic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_bytes
operator|<
name|ntic
operator|->
name|t_unit_res
condition|)
break|break;
name|free_bytes
operator|-=
name|ntic
operator|->
name|t_unit_res
expr_stmt|;
name|sv_signal
argument_list|(
operator|&
name|ntic
operator|->
name|t_sema
argument_list|)
expr_stmt|;
name|ntic
operator|=
name|ntic
operator|->
name|t_next
expr_stmt|;
block|}
do|while
condition|(
name|ntic
operator|!=
name|log
operator|->
name|l_write_headq
condition|)
do|;
if|if
condition|(
name|ntic
operator|!=
name|log
operator|->
name|l_write_headq
condition|)
block|{
if|if
condition|(
operator|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
operator|)
operator|==
literal|0
condition|)
name|XLOG_INS_TICKETQ
argument_list|(
name|log
operator|->
name|l_write_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_regrant_write_log_space: sleep 1"
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_sleep_logspace
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|,
name|PINOD
operator||
name|PLTWAIT
argument_list|,
operator|&
name|log
operator|->
name|l_grant_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* If we're shutting down, this tic is already 			 * off the queue */
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_regrant_write_log_space: wake 1"
argument_list|)
expr_stmt|;
name|xlog_grant_push_ail
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|tic
operator|->
name|t_unit_res
argument_list|)
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
block|}
name|need_bytes
operator|=
name|tic
operator|->
name|t_unit_res
expr_stmt|;
name|redo
label|:
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|free_bytes
operator|=
name|xlog_space_left
argument_list|(
name|log
argument_list|,
name|log
operator|->
name|l_grant_write_cycle
argument_list|,
name|log
operator|->
name|l_grant_write_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_bytes
operator|<
name|need_bytes
condition|)
block|{
if|if
condition|(
operator|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
operator|)
operator|==
literal|0
condition|)
name|XLOG_INS_TICKETQ
argument_list|(
name|log
operator|->
name|l_write_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_sleep_logspace
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|,
name|PINOD
operator||
name|PLTWAIT
argument_list|,
operator|&
name|log
operator|->
name|l_grant_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* If we're shutting down, this tic is already off the queue */
if|if
condition|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
condition|)
block|{
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_regrant_write_log_space: wake 2"
argument_list|)
expr_stmt|;
name|xlog_grant_push_ail
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|need_bytes
argument_list|)
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
elseif|else
if|if
condition|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
condition|)
name|XLOG_DEL_TICKETQ
argument_list|(
name|log
operator|->
name|l_write_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|XLOG_GRANT_ADD_SPACE
argument_list|(
name|log
argument_list|,
name|need_bytes
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
comment|/* we've got enough space */
ifdef|#
directive|ifdef
name|DEBUG
name|tail_lsn
operator|=
name|log
operator|->
name|l_tail_lsn
expr_stmt|;
if|if
condition|(
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|!=
name|log
operator|->
name|l_grant_write_cycle
condition|)
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_write_cycle
operator|-
literal|1
operator|==
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_write_bytes
operator|<=
name|BBTOB
argument_list|(
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_regrant_write_log_space: exit"
argument_list|)
expr_stmt|;
name|xlog_verify_grant_head
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error_return
label|:
if|if
condition|(
name|tic
operator|->
name|t_flags
operator|&
name|XLOG_TIC_IN_Q
condition|)
name|XLOG_DEL_TICKETQ
argument_list|(
name|log
operator|->
name|l_reserve_headq
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|tic
argument_list|,
literal|"xlog_regrant_write_log_space: err_ret"
argument_list|)
expr_stmt|;
comment|/* 	 * If we are failing, make sure the ticket doesn't have any 	 * current reservations. We don't want to add this back when 	 * the ticket/transaction gets cancelled. 	 */
name|tic
operator|->
name|t_curr_res
operator|=
literal|0
expr_stmt|;
name|tic
operator|->
name|t_cnt
operator|=
literal|0
expr_stmt|;
comment|/* ungrant will give back unit_res * t_cnt. */
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_regrant_write_log_space */
end_comment

begin_comment
comment|/* The first cnt-1 times through here we don't need to  * move the grant write head because the permanent  * reservation has reserved cnt times the unit amount.  * Release part of current permanent unit reservation and  * reset current reservation to be one units worth.  Also  * move grant reservation head forward.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_regrant_reserve_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|,
literal|"xlog_regrant_reserve_log_space: enter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticket
operator|->
name|t_cnt
operator|>
literal|0
condition|)
name|ticket
operator|->
name|t_cnt
operator|--
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|XLOG_GRANT_SUB_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_curr_res
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|XLOG_GRANT_SUB_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_curr_res
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
name|ticket
operator|->
name|t_curr_res
operator|=
name|ticket
operator|->
name|t_unit_res
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|,
literal|"xlog_regrant_reserve_log_space: sub current res"
argument_list|)
expr_stmt|;
name|xlog_verify_grant_head
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* just return if we still have some of the pre-reserved space */
if|if
condition|(
name|ticket
operator|->
name|t_cnt
operator|>
literal|0
condition|)
block|{
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|XLOG_GRANT_ADD_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_unit_res
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|,
literal|"xlog_regrant_reserve_log_space: exit"
argument_list|)
expr_stmt|;
name|xlog_verify_grant_head
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ticket
operator|->
name|t_curr_res
operator|=
name|ticket
operator|->
name|t_unit_res
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_regrant_reserve_log_space */
end_comment

begin_comment
comment|/*  * Give back the space left from a reservation.  *  * All the information we need to make a correct determination of space left  * is present.  For non-permanent reservations, things are quite easy.  The  * count should have been decremented to zero.  We only need to deal with the  * space remaining in the current reservation part of the ticket.  If the  * ticket contains a permanent reservation, there may be left over space which  * needs to be released.  A count of N means that N-1 refills of the current  * reservation can be done before we need to ask for more space.  The first  * one goes to fill up the first current reservation.  Once we run out of  * space, the count will stay at zero and the only space remaining will be  * in the current reservation field.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_ungrant_log_space
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticket
operator|->
name|t_cnt
operator|>
literal|0
condition|)
name|ticket
operator|->
name|t_cnt
operator|--
expr_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|,
literal|"xlog_ungrant_log_space: enter"
argument_list|)
expr_stmt|;
name|XLOG_GRANT_SUB_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_curr_res
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|XLOG_GRANT_SUB_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_curr_res
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|,
literal|"xlog_ungrant_log_space: sub current"
argument_list|)
expr_stmt|;
comment|/* If this is a permanent reservation ticket, we may be able to free 	 * up more space based on the remaining count. 	 */
if|if
condition|(
name|ticket
operator|->
name|t_cnt
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ticket
operator|->
name|t_flags
operator|&
name|XLOG_TIC_PERM_RESERV
argument_list|)
expr_stmt|;
name|XLOG_GRANT_SUB_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_unit_res
operator|*
name|ticket
operator|->
name|t_cnt
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|XLOG_GRANT_SUB_SPACE
argument_list|(
name|log
argument_list|,
name|ticket
operator|->
name|t_unit_res
operator|*
name|ticket
operator|->
name|t_cnt
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
block|}
name|xlog_trace_loggrant
argument_list|(
name|log
argument_list|,
name|ticket
argument_list|,
literal|"xlog_ungrant_log_space: exit"
argument_list|)
expr_stmt|;
name|xlog_verify_grant_head
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_log_move_tail
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_ungrant_log_space */
end_comment

begin_comment
comment|/*  * Atomically put back used ticket.  */
end_comment

begin_function
name|void
name|xlog_state_put_ticket
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|tic
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|xlog_ticket_put
argument_list|(
name|log
argument_list|,
name|tic
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_state_put_ticket */
end_comment

begin_comment
comment|/*  * Flush iclog to disk if this is the last reference to the given iclog and  * the WANT_SYNC bit is set.  *  * When this function is entered, the iclog is not necessarily in the  * WANT_SYNC state.  It may be sitting around waiting to get filled.  *  *  */
end_comment

begin_function
name|int
name|xlog_state_release_iclog
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|int
name|sync
init|=
literal|0
decl_stmt|;
comment|/* do we sync? */
name|xlog_assign_tail_lsn
argument_list|(
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_WANT_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|iclog
operator|->
name|ic_refcnt
operator|==
literal|0
operator|&&
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_WANT_SYNC
condition|)
block|{
name|sync
operator|++
expr_stmt|;
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_SYNCING
expr_stmt|;
name|INT_SET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_tail_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|log
operator|->
name|l_tail_lsn
argument_list|)
expr_stmt|;
name|xlog_verify_tail_lsn
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|log
operator|->
name|l_tail_lsn
argument_list|)
expr_stmt|;
comment|/* cycle incremented when incrementing curr_block */
block|}
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * We let the log lock go, so it's possible that we hit a log I/O 	 * error or someother SHUTDOWN condition that marks the iclog 	 * as XLOG_STATE_IOERROR before the bwrite. However, we know that 	 * this iclog has consistent data, so we ignore IOERROR 	 * flags after this point. 	 */
if|if
condition|(
name|sync
condition|)
block|{
return|return
name|xlog_sync
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_state_release_iclog */
end_comment

begin_comment
comment|/*  * This routine will mark the current iclog in the ring as WANT_SYNC  * and move the current iclog pointer to the next iclog in the ring.  * When this routine is called from xlog_state_get_iclog_space(), the  * exact size of the iclog has not yet been determined.  All we know is  * that every data block.  We have run out of space in this log record.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_state_switch_iclogs
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|eventual_size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eventual_size
condition|)
name|eventual_size
operator|=
name|iclog
operator|->
name|ic_offset
expr_stmt|;
name|iclog
operator|->
name|ic_state
operator|=
name|XLOG_STATE_WANT_SYNC
expr_stmt|;
name|INT_SET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_prev_block
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|log
operator|->
name|l_prev_block
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_prev_block
operator|=
name|log
operator|->
name|l_curr_block
expr_stmt|;
name|log
operator|->
name|l_prev_cycle
operator|=
name|log
operator|->
name|l_curr_cycle
expr_stmt|;
comment|/* roll log?: ic_offset changed later */
name|log
operator|->
name|l_curr_block
operator|+=
name|BTOBB
argument_list|(
name|eventual_size
argument_list|)
operator|+
name|BTOBB
argument_list|(
name|log
operator|->
name|l_iclog_hsize
argument_list|)
expr_stmt|;
comment|/* Round up to next log-sunit */
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
operator|&&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
operator|.
name|sb_logsunit
operator|>
literal|1
condition|)
block|{
name|__uint32_t
name|sunit_bb
init|=
name|BTOBB
argument_list|(
name|log
operator|->
name|l_mp
operator|->
name|m_sb
operator|.
name|sb_logsunit
argument_list|)
decl_stmt|;
name|log
operator|->
name|l_curr_block
operator|=
name|roundup
argument_list|(
name|log
operator|->
name|l_curr_block
argument_list|,
name|sunit_bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|->
name|l_curr_block
operator|>=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
name|log
operator|->
name|l_curr_cycle
operator|++
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|l_curr_cycle
operator|==
name|XLOG_HEADER_MAGIC_NUM
condition|)
name|log
operator|->
name|l_curr_cycle
operator|++
expr_stmt|;
name|log
operator|->
name|l_curr_block
operator|-=
name|log
operator|->
name|l_logBBsize
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_curr_block
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|iclog
operator|==
name|log
operator|->
name|l_iclog
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_state_switch_iclogs */
end_comment

begin_comment
comment|/*  * Write out all data in the in-core log as of this exact moment in time.  *  * Data may be written to the in-core log during this call.  However,  * we don't guarantee this data will be written out.  A change from past  * implementation means this routine will *not* write out zero length LRs.  *  * Basically, we try and perform an intelligent scan of the in-core logs.  * If we determine there is no flushable data, we just return.  There is no  * flushable data if:  *  *	1. the current iclog is active and has no data; the previous iclog  *		is in the active or dirty state.  *	2. the current iclog is drity, and the previous iclog is in the  *		active or dirty state.  *  * We may sleep (call psema) if:  *  *	1. the current iclog is not in the active nor dirty state.  *	2. the current iclog dirty, and the previous iclog is not in the  *		active nor dirty state.  *	3. the current iclog is active, and there is another thread writing  *		to this particular iclog.  *	4. a) the current iclog is active and has no other writers  *	   b) when we return from flushing out this iclog, it is still  *		not in the active nor dirty state.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_state_sync_all
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|xfs_lsn_t
name|lsn
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
comment|/* If the head iclog is not active nor dirty, we just attach 	 * ourselves to the head and go to sleep. 	 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
condition|)
block|{
comment|/* 		 * If the head is dirty or (active and empty), then 		 * we need to look at the previous iclog.  If the previous 		 * iclog is active or dirty we are done.  There is nothing 		 * to sync out.  Otherwise, we attach ourselves to the 		 * previous iclog and go to sleep. 		 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
operator|||
operator|(
name|iclog
operator|->
name|ic_refcnt
operator|==
literal|0
operator|&&
name|iclog
operator|->
name|ic_offset
operator|==
literal|0
operator|)
condition|)
block|{
name|iclog
operator|=
name|iclog
operator|->
name|ic_prev
expr_stmt|;
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
operator|||
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
condition|)
goto|goto
name|no_sleep
goto|;
else|else
goto|goto
name|maybe_sleep
goto|;
block|}
else|else
block|{
if|if
condition|(
name|iclog
operator|->
name|ic_refcnt
operator|==
literal|0
condition|)
block|{
comment|/* We are the only one with access to this 				 * iclog.  Flush it out now.  There should 				 * be a roundoff of zero to show that someone 				 * has already taken care of the roundoff from 				 * the previous sync. 				 */
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_roundoff
operator|==
literal|0
argument_list|)
expr_stmt|;
name|iclog
operator|->
name|ic_refcnt
operator|++
expr_stmt|;
name|lsn
operator|=
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xlog_state_switch_iclogs
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|lsn
operator|&&
name|iclog
operator|->
name|ic_state
operator|!=
name|XLOG_STATE_DIRTY
condition|)
goto|goto
name|maybe_sleep
goto|;
else|else
goto|goto
name|no_sleep
goto|;
block|}
else|else
block|{
comment|/* Someone else is writing to this iclog. 				 * Use its call to flush out the data.  However, 				 * the other thread may not force out this LR, 				 * so we mark it WANT_SYNC. 				 */
name|xlog_state_switch_iclogs
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|maybe_sleep
goto|;
block|}
block|}
block|}
comment|/* By the time we come around again, the iclog could've been filled 	 * which would give it another lsn.  If we have a new lsn, just 	 * return because the relevant data has been flushed. 	 */
name|maybe_sleep
label|:
if|if
condition|(
name|flags
operator|&
name|XFS_LOG_SYNC
condition|)
block|{
comment|/* 		 * We must check if we're shutting down here, before 		 * we wait, while we're holding the LOG_LOCK. 		 * Then we check again after waking up, in case our 		 * sleep was disturbed by a bad news. 		 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_log_force_sleep
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|,
name|PINOD
argument_list|,
operator|&
name|log
operator|->
name|l_icloglock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * No need to grab the log lock here since we're 		 * only deciding whether or not to return EIO 		 * and the memory read should be atomic. 		 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
else|else
block|{
name|no_sleep
label|:
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xlog_state_sync_all */
end_comment

begin_comment
comment|/*  * Used by code which implements synchronous log forces.  *  * Find in-core log with lsn.  *	If it is in the DIRTY state, just return.  *	If it is in the ACTIVE state, move the in-core log into the WANT_SYNC  *		state and go to sleep or return.  *	If it is in any other state, go to sleep or return.  *  * If filesystem activity goes to zero, the iclog will get flushed only by  * bdflush().  */
end_comment

begin_function
name|int
name|xlog_state_sync
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|int
name|already_slept
init|=
literal|0
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|try_again
label|:
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
do|do
block|{
if|if
condition|(
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|lsn
condition|)
block|{
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_DIRTY
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
condition|)
block|{
comment|/* 		 * We sleep here if we haven't already slept (e.g. 		 * this is the first time we've looked at the correct 		 * iclog buf) and the buffer before us is going to 		 * be sync'ed. The reason for this is that if we 		 * are doing sync transactions here, by waiting for 		 * the previous I/O to complete, we can allow a few 		 * more transactions into this iclog before we close 		 * it down. 		 * 		 * Otherwise, we mark the buffer WANT_SYNC, and bump 		 * up the refcnt so we can release the log (which drops 		 * the ref count).  The state switch keeps new transaction 		 * commits from using this buffer.  When the current commits 		 * finish writing into the buffer, the refcount will drop to 		 * zero and the buffer will go out then. 		 */
if|if
condition|(
operator|!
name|already_slept
operator|&&
operator|(
name|iclog
operator|->
name|ic_prev
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_WANT_SYNC
operator||
name|XLOG_STATE_SYNCING
operator|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_log_force_sleep
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|iclog
operator|->
name|ic_prev
operator|->
name|ic_writesema
argument_list|,
name|PSWP
argument_list|,
operator|&
name|log
operator|->
name|l_icloglock
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|already_slept
operator|=
literal|1
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
else|else
block|{
name|iclog
operator|->
name|ic_refcnt
operator|++
expr_stmt|;
name|xlog_state_switch_iclogs
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlog_state_release_iclog
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|XFS_LOG_SYNC
operator|)
operator|&&
comment|/* sleep */
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_ACTIVE
operator||
name|XLOG_STATE_DIRTY
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Don't wait on the forcesema if we know that we've 		 * gotten a log write error. 		 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_log_force_sleep
argument_list|)
expr_stmt|;
name|sv_wait
argument_list|(
operator|&
name|iclog
operator|->
name|ic_forcesema
argument_list|,
name|PSWP
argument_list|,
operator|&
name|log
operator|->
name|l_icloglock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * No need to grab the log lock here since we're 		 * only deciding whether or not to return EIO 		 * and the memory read should be atomic. 		 */
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
else|else
block|{
comment|/* just return */
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
do|while
condition|(
name|iclog
operator|!=
name|log
operator|->
name|l_iclog
condition|)
do|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xlog_state_sync */
end_comment

begin_comment
comment|/*  * Called when we want to mark the current iclog as being ready to sync to  * disk.  */
end_comment

begin_function
name|void
name|xlog_state_want_sync
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|iclog
operator|->
name|ic_state
operator|==
name|XLOG_STATE_ACTIVE
condition|)
block|{
name|xlog_state_switch_iclogs
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_state
operator|&
operator|(
name|XLOG_STATE_WANT_SYNC
operator||
name|XLOG_STATE_IOERROR
operator|)
argument_list|)
expr_stmt|;
block|}
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_state_want_sync */
end_comment

begin_comment
comment|/*****************************************************************************  *  *		TICKET functions  *  *****************************************************************************  */
end_comment

begin_comment
comment|/*  *	Algorithm doesn't take into account page size. ;-(  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_state_ticket_alloc
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xlog_ticket_t
modifier|*
name|t_list
decl_stmt|;
name|xlog_ticket_t
modifier|*
name|next
decl_stmt|;
name|xfs_caddr_t
name|buf
decl_stmt|;
name|uint
name|i
init|=
operator|(
name|NBPP
operator|/
sizeof|sizeof
argument_list|(
name|xlog_ticket_t
argument_list|)
operator|)
operator|-
literal|2
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * The kmem_zalloc may sleep, so we shouldn't be holding the 	 * global lock.  XXXmiken: may want to use zone allocator. 	 */
name|buf
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|kmem_zalloc
argument_list|(
name|NBPP
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* Attach 1st ticket to Q, so we can keep track of allocated memory */
name|t_list
operator|=
operator|(
name|xlog_ticket_t
operator|*
operator|)
name|buf
expr_stmt|;
name|t_list
operator|->
name|t_next
operator|=
name|log
operator|->
name|l_unmount_free
expr_stmt|;
name|log
operator|->
name|l_unmount_free
operator|=
name|t_list
operator|++
expr_stmt|;
name|log
operator|->
name|l_ticket_cnt
operator|++
expr_stmt|;
name|log
operator|->
name|l_ticket_tcnt
operator|++
expr_stmt|;
comment|/* Next ticket becomes first ticket attached to ticket free list */
if|if
condition|(
name|log
operator|->
name|l_freelist
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_tail
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_tail
operator|->
name|t_next
operator|=
name|t_list
expr_stmt|;
block|}
else|else
block|{
name|log
operator|->
name|l_freelist
operator|=
name|t_list
expr_stmt|;
block|}
name|log
operator|->
name|l_ticket_cnt
operator|++
expr_stmt|;
name|log
operator|->
name|l_ticket_tcnt
operator|++
expr_stmt|;
comment|/* Cycle through rest of alloc'ed memory, building up free Q */
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|next
operator|=
name|t_list
operator|+
literal|1
expr_stmt|;
name|t_list
operator|->
name|t_next
operator|=
name|next
expr_stmt|;
name|t_list
operator|=
name|next
expr_stmt|;
name|log
operator|->
name|l_ticket_cnt
operator|++
expr_stmt|;
name|log
operator|->
name|l_ticket_tcnt
operator|++
expr_stmt|;
block|}
name|t_list
operator|->
name|t_next
operator|=
literal|0
expr_stmt|;
name|log
operator|->
name|l_tail
operator|=
name|t_list
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_state_ticket_alloc */
end_comment

begin_comment
comment|/*  * Put ticket into free list  *  * Assumption: log lock is held around this call.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_ticket_put
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_ticket_t
modifier|*
name|ticket
parameter_list|)
block|{
name|sv_destroy
argument_list|(
operator|&
name|ticket
operator|->
name|t_sema
argument_list|)
expr_stmt|;
comment|/* 	 * Don't think caching will make that much difference.  It's 	 * more important to make debug easier. 	 */
if|#
directive|if
literal|0
comment|/* real code will want to use LIFO for caching */
block|ticket->t_next = log->l_freelist; 	log->l_freelist = ticket;
comment|/* no need to clear fields */
else|#
directive|else
comment|/* When we debug, it is easier if tickets are cycled */
name|ticket
operator|->
name|t_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|l_tail
operator|!=
literal|0
condition|)
block|{
name|log
operator|->
name|l_tail
operator|->
name|t_next
operator|=
name|ticket
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_freelist
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_freelist
operator|=
name|ticket
expr_stmt|;
block|}
name|log
operator|->
name|l_tail
operator|=
name|ticket
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|log
operator|->
name|l_ticket_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_ticket_put */
end_comment

begin_comment
comment|/*  * Grab ticket off freelist or allocation some more  */
end_comment

begin_function
name|xlog_ticket_t
modifier|*
name|xlog_ticket_get
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|unit_bytes
parameter_list|,
name|int
name|cnt
parameter_list|,
name|char
name|client
parameter_list|,
name|uint
name|xflags
parameter_list|)
block|{
name|xlog_ticket_t
modifier|*
name|tic
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|alloc
label|:
if|if
condition|(
name|log
operator|->
name|l_freelist
operator|==
name|NULL
condition|)
name|xlog_state_ticket_alloc
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* potentially sleep */
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|l_freelist
operator|==
name|NULL
condition|)
block|{
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
goto|goto
name|alloc
goto|;
block|}
name|tic
operator|=
name|log
operator|->
name|l_freelist
expr_stmt|;
name|log
operator|->
name|l_freelist
operator|=
name|tic
operator|->
name|t_next
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|l_freelist
operator|==
name|NULL
condition|)
name|log
operator|->
name|l_tail
operator|=
name|NULL
expr_stmt|;
name|log
operator|->
name|l_ticket_cnt
operator|--
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Permanent reservations have up to 'cnt'-1 active log operations 	 * in the log.  A unit in this case is the amount of space for one 	 * of these log operations.  Normal reservations have a cnt of 1 	 * and their unit amount is the total amount of space required. 	 * The following line of code adds one log record header length 	 * for each part of an operation which may fall on a different 	 * log record. 	 * 	 * One more XLOG_HEADER_SIZE is added to account for possible 	 * round off errors when syncing a LR to disk.  The bytes are 	 * subtracted if the thread using this ticket is the first writer 	 * to a new LR. 	 * 	 * We add an extra log header for the possibility that the commit 	 * record is the first data written to a new log record.  In this 	 * case it is separate from the rest of the transaction data and 	 * will be charged for the log record header. 	 */
name|unit_bytes
operator|+=
name|log
operator|->
name|l_iclog_hsize
operator|*
operator|(
name|XLOG_BTOLRBB
argument_list|(
name|unit_bytes
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|tic
operator|->
name|t_unit_res
operator|=
name|unit_bytes
expr_stmt|;
name|tic
operator|->
name|t_curr_res
operator|=
name|unit_bytes
expr_stmt|;
name|tic
operator|->
name|t_cnt
operator|=
name|cnt
expr_stmt|;
name|tic
operator|->
name|t_ocnt
operator|=
name|cnt
expr_stmt|;
name|tic
operator|->
name|t_tid
operator|=
call|(
name|xlog_tid_t
call|)
argument_list|(
operator|(
name|__psint_t
operator|)
name|tic
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|tic
operator|->
name|t_clientid
operator|=
name|client
expr_stmt|;
name|tic
operator|->
name|t_flags
operator|=
name|XLOG_TIC_INITED
expr_stmt|;
if|if
condition|(
name|xflags
operator|&
name|XFS_LOG_PERM_RESERV
condition|)
name|tic
operator|->
name|t_flags
operator||=
name|XLOG_TIC_PERM_RESERV
expr_stmt|;
name|sv_init
argument_list|(
operator|&
operator|(
name|tic
operator|->
name|t_sema
operator|)
argument_list|,
name|SV_DEFAULT
argument_list|,
literal|"logtick"
argument_list|)
expr_stmt|;
return|return
name|tic
return|;
block|}
end_function

begin_comment
comment|/* xlog_ticket_get */
end_comment

begin_comment
comment|/******************************************************************************  *  *		Log debug routines  *  ******************************************************************************  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XLOG_NOLOG
argument_list|)
end_if

begin_comment
comment|/*  * Make sure that the destination ptr is within the valid data region of  * one of the iclogs.  This uses backup pointers stored in a different  * part of the log in case we trash the log structure.  */
end_comment

begin_function
name|void
name|xlog_verify_dest_ptr
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|__psint_t
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|good_ptr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|log
operator|->
name|l_iclog_bufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|>=
operator|(
name|__psint_t
operator|)
name|log
operator|->
name|l_iclog_bak
index|[
name|i
index|]
operator|&&
name|ptr
operator|<=
operator|(
name|__psint_t
operator|)
name|log
operator|->
name|l_iclog_bak
index|[
name|i
index|]
operator|+
name|log
operator|->
name|l_iclog_size
condition|)
name|good_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|good_ptr
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_dest_ptr: invalid ptr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xlog_verify_dest_ptr */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XFSDEBUG
end_ifdef

begin_comment
comment|/* check split LR write */
end_comment

begin_function
name|STATIC
name|void
name|xlog_verify_disk_cycle_no
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|uint
name|cycle_no
decl_stmt|;
name|xfs_caddr_t
name|ptr
decl_stmt|;
name|xfs_daddr_t
name|i
decl_stmt|;
if|if
condition|(
name|BLOCK_LSN
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
literal|10
condition|)
block|{
name|cycle_no
operator|=
name|CYCLE_LSN
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_LSN
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CYCLE
argument_list|(
name|ptr
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|cycle_no
condition|)
name|xlog_warn
argument_list|(
literal|"XFS: xlog_verify_disk_cycle_no: bad cycle no"
argument_list|)
expr_stmt|;
block|}
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* xlog_verify_disk_cycle_no */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
name|xlog_verify_grant_head
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|equals
parameter_list|)
block|{
if|if
condition|(
name|log
operator|->
name|l_grant_reserve_cycle
operator|==
name|log
operator|->
name|l_grant_write_cycle
condition|)
block|{
if|if
condition|(
name|equals
condition|)
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_reserve_bytes
operator|>=
name|log
operator|->
name|l_grant_write_bytes
argument_list|)
expr_stmt|;
else|else
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_reserve_bytes
operator|>
name|log
operator|->
name|l_grant_write_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_reserve_cycle
operator|-
literal|1
operator|==
name|log
operator|->
name|l_grant_write_cycle
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|log
operator|->
name|l_grant_write_bytes
operator|>=
name|log
operator|->
name|l_grant_reserve_bytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* xlog_verify_grant_head */
end_comment

begin_comment
comment|/* check if it will fit */
end_comment

begin_function
name|STATIC
name|void
name|xlog_verify_tail_lsn
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|xfs_lsn_t
name|tail_lsn
parameter_list|)
block|{
name|int
name|blocks
decl_stmt|;
if|if
condition|(
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|==
name|log
operator|->
name|l_prev_cycle
condition|)
block|{
name|blocks
operator|=
name|log
operator|->
name|l_logBBsize
operator|-
operator|(
name|log
operator|->
name|l_prev_block
operator|-
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|<
name|BTOBB
argument_list|(
name|iclog
operator|->
name|ic_offset
argument_list|)
operator|+
name|BTOBB
argument_list|(
name|log
operator|->
name|l_iclog_hsize
argument_list|)
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_tail_lsn: ran out of log space"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|+
literal|1
operator|==
name|log
operator|->
name|l_prev_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|==
name|log
operator|->
name|l_prev_block
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_tail_lsn: tail wrapped"
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|,
name|ARCH_NOCONVERT
argument_list|)
operator|-
name|log
operator|->
name|l_prev_block
expr_stmt|;
if|if
condition|(
name|blocks
operator|<
name|BTOBB
argument_list|(
name|iclog
operator|->
name|ic_offset
argument_list|)
operator|+
literal|1
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_tail_lsn: ran out of log space"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* xlog_verify_tail_lsn */
end_comment

begin_comment
comment|/*  * Perform a number of checks on the iclog before writing to disk.  *  * 1. Make sure the iclogs are still circular  * 2. Make sure we have a good magic number  * 3. Make sure we don't have magic numbers in the data  * 4. Check fields of each log operation header for:  *	A. Valid client identifier  *	B. tid ptr value falls in valid ptr space (user space code)  *	C. Length in log record header is correct according to the  *		individual operation headers within record.  * 5. When a bwrite will occur within 5 blocks of the front of the physical  *	log, check the preceding blocks of the physical log to make sure all  *	the cycle numbers agree with the current cycle number.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_verify_iclog
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|count
parameter_list|,
name|boolean_t
name|syncing
parameter_list|)
block|{
name|xlog_op_header_t
modifier|*
name|ophead
decl_stmt|;
name|xlog_in_core_t
modifier|*
name|icptr
decl_stmt|;
name|xlog_in_core_2_t
modifier|*
name|xhdr
decl_stmt|;
name|xfs_caddr_t
name|ptr
decl_stmt|;
name|xfs_caddr_t
name|base_ptr
decl_stmt|;
name|__psint_t
name|field_offset
decl_stmt|;
name|__uint8_t
name|clientid
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|op_len
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* check validity of iclog pointers */
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|icptr
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|log
operator|->
name|l_iclog_bufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|icptr
operator|==
literal|0
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_iclog: invalid ptr"
argument_list|)
expr_stmt|;
name|icptr
operator|=
name|icptr
operator|->
name|ic_next
expr_stmt|;
block|}
if|if
condition|(
name|icptr
operator|!=
name|log
operator|->
name|l_iclog
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_iclog: corrupt iclog ring"
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* check log magic numbers */
name|ptr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|iclog
operator|->
name|ic_header
operator|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|ptr
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XLOG_HEADER_MAGIC_NUM
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_iclog: invalid magic num"
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|+=
name|BBSIZE
init|;
name|ptr
operator|<
operator|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|iclog
operator|->
name|ic_header
operator|)
operator|)
operator|+
name|count
condition|;
name|ptr
operator|+=
name|BBSIZE
control|)
block|{
if|if
condition|(
name|INT_GET
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|ptr
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XLOG_HEADER_MAGIC_NUM
condition|)
name|xlog_panic
argument_list|(
literal|"xlog_verify_iclog: unexpected magic num"
argument_list|)
expr_stmt|;
block|}
comment|/* check fields */
name|len
operator|=
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|iclog
operator|->
name|ic_datap
expr_stmt|;
name|base_ptr
operator|=
name|ptr
expr_stmt|;
name|ophead
operator|=
operator|(
name|xlog_op_header_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|xhdr
operator|=
operator|(
name|xlog_in_core_2_t
operator|*
operator|)
operator|&
name|iclog
operator|->
name|ic_header
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ophead
operator|=
operator|(
name|xlog_op_header_t
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* clientid is only 1 byte */
name|field_offset
operator|=
call|(
name|__psint_t
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|ophead
operator|->
name|oh_clientid
operator|)
operator|-
name|base_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|syncing
operator|==
name|B_FALSE
operator|||
operator|(
name|field_offset
operator|&
literal|0x1ff
operator|)
condition|)
block|{
name|clientid
operator|=
name|ophead
operator|->
name|oh_clientid
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|BTOBBT
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|ophead
operator|->
name|oh_clientid
operator|)
operator|-
name|iclog
operator|->
name|ic_datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
condition|)
block|{
name|j
operator|=
name|idx
operator|/
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|k
operator|=
name|idx
operator|%
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|clientid
operator|=
name|GET_CLIENT_ID
argument_list|(
name|xhdr
index|[
name|j
index|]
operator|.
name|hic_xheader
operator|.
name|xh_cycle_data
index|[
name|k
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clientid
operator|=
name|GET_CLIENT_ID
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_cycle_data
index|[
name|idx
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clientid
operator|!=
name|XFS_TRANSACTION
operator|&&
name|clientid
operator|!=
name|XFS_LOG
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"xlog_verify_iclog: invalid clientid %d op 0x%p offset 0x%x"
argument_list|,
name|clientid
argument_list|,
name|ophead
argument_list|,
name|field_offset
argument_list|)
expr_stmt|;
comment|/* check length */
name|field_offset
operator|=
call|(
name|__psint_t
call|)
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|ophead
operator|->
name|oh_len
operator|)
operator|-
name|base_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|syncing
operator|==
name|B_FALSE
operator|||
operator|(
name|field_offset
operator|&
literal|0x1ff
operator|)
condition|)
block|{
name|op_len
operator|=
name|INT_GET
argument_list|(
name|ophead
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|BTOBBT
argument_list|(
operator|(
name|__psint_t
operator|)
operator|&
name|ophead
operator|->
name|oh_len
operator|-
operator|(
name|__psint_t
operator|)
name|iclog
operator|->
name|ic_datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
condition|)
block|{
name|j
operator|=
name|idx
operator|/
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|k
operator|=
name|idx
operator|%
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|op_len
operator|=
name|INT_GET
argument_list|(
name|xhdr
index|[
name|j
index|]
operator|.
name|hic_xheader
operator|.
name|xh_cycle_data
index|[
name|k
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_len
operator|=
name|INT_GET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_cycle_data
index|[
name|idx
index|]
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
block|}
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
operator|+
name|op_len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* xlog_verify_iclog */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG&& !XLOG_NOLOG */
end_comment

begin_comment
comment|/*  * Mark all iclogs IOERROR. LOG_LOCK is held by the caller.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_state_ioerror
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|,
modifier|*
name|ic
decl_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
condition|)
block|{
comment|/* 		 * Mark all the incore logs IOERROR. 		 * From now on, no log flushes will result. 		 */
name|ic
operator|=
name|iclog
expr_stmt|;
do|do
block|{
name|ic
operator|->
name|ic_state
operator|=
name|XLOG_STATE_IOERROR
expr_stmt|;
name|ic
operator|=
name|ic
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|ic
operator|!=
name|iclog
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Return non-zero, if state transition has already happened. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called from xfs_force_shutdown, when we're forcibly  * shutting down the filesystem, typically because of an IO error.  * Our main objectives here are to make sure that:  *	a. the filesystem gets marked 'SHUTDOWN' for all interested  *	   parties to find out, 'atomically'.  *	b. those who're sleeping on log reservations, pinned objects and  *	    other resources get woken up, and be told the bad news.  *	c. nothing new gets queued up after (a) and (b) are done.  *	d. if !logerror, flush the iclogs to disk, then seal them off  *	   for business.  */
end_comment

begin_function
name|int
name|xfs_log_force_umount
parameter_list|(
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|,
name|int
name|logerror
parameter_list|)
block|{
name|xlog_ticket_t
modifier|*
name|tic
decl_stmt|;
name|xlog_t
modifier|*
name|log
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SPLDECL
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|log
operator|=
name|mp
operator|->
name|m_log
expr_stmt|;
comment|/* 	 * If this happens during log recovery, don't worry about 	 * locking; the log isn't open for business yet. 	 */
if|if
condition|(
operator|!
name|log
operator|||
name|log
operator|->
name|l_flags
operator|&
name|XLOG_ACTIVE_RECOVERY
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_FS_SHUTDOWN
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|mp
operator|->
name|m_sb_bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Somebody could've already done the hard work for us. 	 * No need to get locks for this. 	 */
if|if
condition|(
name|logerror
operator|&&
name|log
operator|->
name|l_iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
condition|)
block|{
name|ASSERT
argument_list|(
name|XLOG_FORCED_SHUTDOWN
argument_list|(
name|log
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We must hold both the GRANT lock and the LOG lock, 	 * before we mark the filesystem SHUTDOWN and wake 	 * everybody up to tell the bad news. 	 */
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|s2
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_FS_SHUTDOWN
expr_stmt|;
name|XFS_BUF_DONE
argument_list|(
name|mp
operator|->
name|m_sb_bp
argument_list|)
expr_stmt|;
comment|/* 	 * This flag is sort of redundant because of the mount flag, but 	 * it's good to maintain the separation between the log and the rest 	 * of XFS. 	 */
name|log
operator|->
name|l_flags
operator||=
name|XLOG_IO_ERROR
expr_stmt|;
comment|/* 	 * If we hit a log error, we want to mark all the iclogs IOERROR 	 * while we're still holding the loglock. 	 */
if|if
condition|(
name|logerror
condition|)
name|retval
operator|=
name|xlog_state_ioerror
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s2
argument_list|)
expr_stmt|;
comment|/* 	 * We don't want anybody waiting for log reservations 	 * after this. That means we have to wake up everybody 	 * queued up on reserve_headq as well as write_headq. 	 * In addition, we make sure in xlog_{re}grant_log_space 	 * that we don't enqueue anything once the SHUTDOWN flag 	 * is set, and this action is protected by the GRANTLOCK. 	 */
if|if
condition|(
operator|(
name|tic
operator|=
name|log
operator|->
name|l_reserve_headq
operator|)
condition|)
block|{
do|do
block|{
name|sv_signal
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|)
expr_stmt|;
name|tic
operator|=
name|tic
operator|->
name|t_next
expr_stmt|;
block|}
do|while
condition|(
name|tic
operator|!=
name|log
operator|->
name|l_reserve_headq
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|tic
operator|=
name|log
operator|->
name|l_write_headq
operator|)
condition|)
block|{
do|do
block|{
name|sv_signal
argument_list|(
operator|&
name|tic
operator|->
name|t_sema
argument_list|)
expr_stmt|;
name|tic
operator|=
name|tic
operator|->
name|t_next
expr_stmt|;
block|}
do|while
condition|(
name|tic
operator|!=
name|log
operator|->
name|l_write_headq
condition|)
do|;
block|}
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|l_iclog
operator|->
name|ic_state
operator|&
name|XLOG_STATE_IOERROR
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|logerror
argument_list|)
expr_stmt|;
comment|/* 		 * Force the incore logs to disk before shutting the 		 * log down completely. 		 */
name|xlog_state_sync_all
argument_list|(
name|log
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|)
expr_stmt|;
name|s2
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xlog_state_ioerror
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wake up everybody waiting on xfs_log_force. 	 * Callback all log item committed functions as if the 	 * log writes were completed. 	 */
name|xlog_state_do_callback
argument_list|(
name|log
argument_list|,
name|XFS_LI_ABORTED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFSERRORDEBUG
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|s
operator|=
name|LOG_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|iclog
operator|->
name|ic_callback
operator|==
literal|0
argument_list|)
expr_stmt|;
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|iclog
operator|!=
name|log
operator|->
name|l_iclog
condition|)
do|;
name|LOG_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* return non-zero if log IOERROR transition had already happened */
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xlog_iclogs_empty
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xlog_in_core_t
modifier|*
name|iclog
decl_stmt|;
name|iclog
operator|=
name|log
operator|->
name|l_iclog
expr_stmt|;
do|do
block|{
comment|/* endianness does not matter here, zero is zero in 		 * any language. 		 */
if|if
condition|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_num_logops
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iclog
operator|=
name|iclog
operator|->
name|ic_next
expr_stmt|;
block|}
do|while
condition|(
name|iclog
operator|!=
name|log
operator|->
name|l_iclog
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

