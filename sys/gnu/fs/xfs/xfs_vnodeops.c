begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2006 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_refcache.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_comment
comment|/*  * The maximum pathlen is 1024 bytes. Since the minimum file system  * blocksize is 512 bytes, we can get a max of 2 extents back from  * bmapi.  */
end_comment

begin_define
define|#
directive|define
name|SYMLINK_MAPS
value|2
end_define

begin_comment
comment|/*  * For xfs, we check that the file isn't too big to be opened by this kernel.  * No other open action is required for regular files.  Devices are handled  * through the specfs file system, pipes through fifofs.  Device and  * fifo vnodes are "wrapped" by specfs and fifofs vnodes, respectively,  * when a new vnode is first looked up or created.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_open
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/* 	 * If it's a directory with any blocks, read-ahead block 0 	 * as we're almost certain to have the next operation be a read there. 	 */
if|if
condition|(
name|VN_ISDIR
argument_list|(
name|vp
argument_list|)
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
condition|)
block|{
name|mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|xfs_da_reada_buf
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_getattr  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_getattr
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ATTR_LAZY
operator|)
condition|)
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|==
name|XFS_AT_SIZE
condition|)
goto|goto
name|all_done
goto|;
name|vap
operator|->
name|va_nblocks
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|+
name|ip
operator|->
name|i_delayed_blks
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_nodeid
operator|=
name|ip
operator|->
name|i_ino
expr_stmt|;
if|#
directive|if
name|XFS_BIG_INUMS
name|vap
operator|->
name|va_nodeid
operator|+=
name|mp
operator|->
name|m_inoadd
expr_stmt|;
endif|#
directive|endif
name|vap
operator|->
name|va_nlink
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
expr_stmt|;
comment|/* 	 * Quick exit for non-stat callers 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
operator|~
operator|(
name|XFS_AT_SIZE
operator||
name|XFS_AT_FSID
operator||
name|XFS_AT_NODEID
operator||
name|XFS_AT_NLINK
operator||
name|XFS_AT_BLKSIZE
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|all_done
goto|;
comment|/* 	 * Copy from in-core inode. 	 */
name|vap
operator|->
name|va_mode
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_mode
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gid
expr_stmt|;
name|vap
operator|->
name|va_projid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_projid
expr_stmt|;
comment|/* 	 * Check vnode type block/char vs. everything else. 	 */
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFBLK
case|:
case|case
name|S_IFCHR
case|:
name|vap
operator|->
name|va_rdev
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_rdev
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|BLKDEV_IOSIZE
expr_stmt|;
break|break;
default|default:
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
condition|)
block|{
name|vap
operator|->
name|va_blocksize
operator|=
name|xfs_preferred_iosize
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the file blocks are being allocated from a 			 * realtime partition, then return the inode's 			 * realtime extent size or the realtime volume's 			 * extent size. 			 */
name|vap
operator|->
name|va_blocksize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
condition|?
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
operator|)
else|:
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|vn_atime_to_timespec
argument_list|(
name|vp
argument_list|,
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_sec
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|.
name|tv_nsec
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_nsec
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|.
name|tv_sec
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_sec
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|.
name|tv_nsec
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_nsec
expr_stmt|;
comment|/* 	 * Exit for stat callers.  See if any of the rest of the fields 	 * to be filled in are needed. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
operator|(
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_NEXTENTS
operator||
name|XFS_AT_ANEXTENTS
operator||
name|XFS_AT_GENCOUNT
operator||
name|XFS_AT_VCODE
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|all_done
goto|;
comment|/* 	 * Convert di_flags to xflags. 	 */
name|vap
operator|->
name|va_xflags
operator|=
name|xfs_ip2xflags
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Exit for inode revalidate.  See if any of the rest of 	 * the fields to be filled in are needed. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
operator|(
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_NEXTENTS
operator||
name|XFS_AT_ANEXTENTS
operator||
name|XFS_AT_GENCOUNT
operator||
name|XFS_AT_VCODE
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|all_done
goto|;
name|vap
operator|->
name|va_extsize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
name|vap
operator|->
name|va_nextents
operator|=
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
condition|?
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|/
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
else|:
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_afp
condition|)
name|vap
operator|->
name|va_anextents
operator|=
operator|(
name|ip
operator|->
name|i_afp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
condition|?
name|ip
operator|->
name|i_afp
operator|->
name|if_bytes
operator|/
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
else|:
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
expr_stmt|;
else|else
name|vap
operator|->
name|va_anextents
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gen
expr_stmt|;
name|all_done
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ATTR_LAZY
operator|)
condition|)
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_setattr  */
end_comment

begin_function
name|int
name|xfs_setattr
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|code
decl_stmt|;
name|uint
name|lock_flags
decl_stmt|;
name|uint
name|commit_flags
init|=
literal|0
decl_stmt|;
name|uid_t
name|uid
init|=
literal|0
decl_stmt|,
name|iuid
init|=
literal|0
decl_stmt|;
name|gid_t
name|gid
init|=
literal|0
decl_stmt|,
name|igid
init|=
literal|0
decl_stmt|;
name|int
name|timeflags
init|=
literal|0
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_prid_t
name|projid
init|=
literal|0
decl_stmt|,
name|iprojid
init|=
literal|0
decl_stmt|;
name|int
name|mandlock_before
decl_stmt|,
name|mandlock_after
decl_stmt|;
name|struct
name|xfs_dquot
modifier|*
name|udqp
decl_stmt|,
modifier|*
name|gdqp
decl_stmt|,
modifier|*
name|olddquot1
decl_stmt|,
modifier|*
name|olddquot2
decl_stmt|;
name|int
name|file_owner
decl_stmt|;
name|int
name|need_iolock
init|=
literal|1
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EROFS
argument_list|)
return|;
comment|/* 	 * Cannot set certain attributes. 	 */
name|mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|XFS_AT_NOSET
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/* 	 * Timestamps do not need to be logged and hence do not 	 * need to be done within a transaction. 	 */
if|if
condition|(
name|mask
operator|&
name|XFS_AT_UPDTIMES
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|mask
operator|&
operator|~
name|XFS_AT_UPDTIMES
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|timeflags
operator|=
operator|(
operator|(
name|mask
operator|&
name|XFS_AT_UPDATIME
operator|)
condition|?
name|XFS_ICHGTIME_ACC
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
name|XFS_AT_UPDCTIME
operator|)
condition|?
name|XFS_ICHGTIME_CHG
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
name|XFS_AT_UPDMTIME
operator|)
condition|?
name|XFS_ICHGTIME_MOD
else|:
literal|0
operator|)
expr_stmt|;
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|timeflags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|olddquot1
operator|=
name|olddquot2
operator|=
name|NULL
expr_stmt|;
name|udqp
operator|=
name|gdqp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If disk quotas is on, we make sure that the dquots do exist on disk, 	 * before we start any other transactions. Trying to do this later 	 * is messy. We don't care to take a readlock to look at the ids 	 * in inode here, because we can't hold it across the trans_reserve. 	 * If the IDs do change before we take the ilock, we're covered 	 * because the i_*dquot fields will get updated anyway. 	 */
if|if
condition|(
name|XFS_IS_QUOTA_ON
argument_list|(
name|mp
argument_list|)
operator|&&
operator|(
name|mask
operator|&
operator|(
name|XFS_AT_UID
operator||
name|XFS_AT_GID
operator||
name|XFS_AT_PROJID
operator|)
operator|)
condition|)
block|{
name|uint
name|qflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|XFS_AT_UID
operator|)
operator|&&
name|XFS_IS_UQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
name|qflags
operator||=
name|XFS_QMOPT_UQUOTA
expr_stmt|;
block|}
else|else
block|{
name|uid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_uid
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|XFS_AT_GID
operator|)
operator|&&
name|XFS_IS_GQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
name|qflags
operator||=
name|XFS_QMOPT_GQUOTA
expr_stmt|;
block|}
else|else
block|{
name|gid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gid
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|XFS_AT_PROJID
operator|)
operator|&&
name|XFS_IS_PQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|projid
operator|=
name|vap
operator|->
name|va_projid
expr_stmt|;
name|qflags
operator||=
name|XFS_QMOPT_PQUOTA
expr_stmt|;
block|}
else|else
block|{
name|projid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_projid
expr_stmt|;
block|}
comment|/* 		 * We take a reference when we initialize udqp and gdqp, 		 * so it is important that we never blindly double trip on 		 * the same variable. See xfs_create() for an example. 		 */
name|ASSERT
argument_list|(
name|udqp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|gdqp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|XFS_QM_DQVOPALLOC
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|projid
argument_list|,
name|qflags
argument_list|,
operator|&
name|udqp
argument_list|,
operator|&
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
return|return
name|code
return|;
block|}
comment|/* 	 * For the other attributes, we acquire the inode lock and 	 * first do an error checking pass. 	 */
name|tp
operator|=
name|NULL
expr_stmt|;
name|lock_flags
operator|=
name|XFS_ILOCK_EXCL
expr_stmt|;
name|ASSERT
argument_list|(
name|flags
operator|&
name|ATTR_NOLOCK
condition|?
name|flags
operator|&
name|ATTR_DMI
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ATTR_NOLOCK
condition|)
name|need_iolock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|XFS_AT_SIZE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|!=
operator|(
name|XFS_AT_CTIME
operator||
name|XFS_AT_ATIME
operator||
name|XFS_AT_MTIME
operator|)
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
condition|)
block|{
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SETATTR_NOT_SIZE
argument_list|)
expr_stmt|;
name|commit_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ICHANGE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|lock_flags
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_TRUNCATE
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ATTR_DMI
operator|)
condition|)
block|{
name|int
name|dmflags
init|=
name|AT_DELAY_FLAG
argument_list|(
name|flags
argument_list|)
operator||
name|DM_SEM_FLAG_WR
decl_stmt|;
name|code
operator|=
name|XFS_SEND_DATA
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_TRUNCATE
argument_list|,
name|vp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|,
name|dmflags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|lock_flags
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|need_iolock
condition|)
name|lock_flags
operator||=
name|XFS_IOLOCK_EXCL
expr_stmt|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
comment|/* boolean: are we the file owner? */
if|#
directive|if
literal|0
block|file_owner = (current_fsuid(credp) == ip->i_d.di_uid);
else|#
directive|else
name|file_owner
operator|=
operator|(
name|credp
operator|->
name|cr_uid
operator|==
name|ip
operator|->
name|i_d
operator|.
name|di_uid
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Change various properties of a file. 	 * Only the owner or users with CAP_FOWNER 	 * capability may do these things. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_MODE
operator||
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_UID
operator||
name|XFS_AT_GID
operator||
name|XFS_AT_PROJID
operator|)
condition|)
block|{
comment|/* 		 * CAP_FOWNER overrides the following restrictions: 		 * 		 * The user ID of the calling process must be equal 		 * to the file owner ID, except in cases where the 		 * CAP_FSETID capability is applicable. 		 */
if|if
condition|(
operator|!
name|file_owner
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_FOWNER
argument_list|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 		 * CAP_FSETID overrides the following restrictions: 		 * 		 * The effective user ID of the calling process shall match 		 * the file owner when setting the set-user-ID and 		 * set-group-ID bits on that file. 		 * 		 * The effective group ID or one of the supplementary group 		 * IDs of the calling process shall match the group owner of 		 * the file when setting the set-group-ID bit on that file 		 */
if|if
condition|(
name|mask
operator|&
name|XFS_AT_MODE
condition|)
block|{
name|mode_t
name|m
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|S_ISUID
operator|)
operator|&&
operator|!
name|file_owner
condition|)
name|m
operator||=
name|S_ISUID
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|S_ISGID
operator|)
operator|&&
operator|!
name|groupmember
argument_list|(
operator|(
name|gid_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_gid
argument_list|,
name|credp
argument_list|)
condition|)
name|m
operator||=
name|S_ISGID
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Linux allows this, Irix doesn't. */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|S_ISVTX
operator|)
operator|&&
operator|!
name|VN_ISDIR
argument_list|(
name|vp
argument_list|)
condition|)
name|m
operator||=
name|S_ISVTX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_FSETID
argument_list|)
condition|)
name|vap
operator|->
name|va_mode
operator|&=
operator|~
name|m
expr_stmt|;
block|}
block|}
comment|/* 	 * Change file ownership.  Must be the owner or privileged. 	 * If the system was configured with the "restricted_chown" 	 * option, the owner is not permitted to give away the file, 	 * and can change the group id only to a group of which he 	 * or she is a member. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_UID
operator||
name|XFS_AT_GID
operator||
name|XFS_AT_PROJID
operator|)
condition|)
block|{
comment|/* 		 * These IDs could have changed since we last looked at them. 		 * But, we're assured that if the ownership did change 		 * while we didn't have the inode locked, inode's dquot(s) 		 * would have changed also. 		 */
name|iuid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_uid
expr_stmt|;
name|iprojid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_projid
expr_stmt|;
name|igid
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gid
expr_stmt|;
name|gid
operator|=
operator|(
name|mask
operator|&
name|XFS_AT_GID
operator|)
condition|?
name|vap
operator|->
name|va_gid
else|:
name|igid
expr_stmt|;
name|uid
operator|=
operator|(
name|mask
operator|&
name|XFS_AT_UID
operator|)
condition|?
name|vap
operator|->
name|va_uid
else|:
name|iuid
expr_stmt|;
name|projid
operator|=
operator|(
name|mask
operator|&
name|XFS_AT_PROJID
operator|)
condition|?
operator|(
name|xfs_prid_t
operator|)
name|vap
operator|->
name|va_projid
else|:
name|iprojid
expr_stmt|;
comment|/* 		 * CAP_CHOWN overrides the following restrictions: 		 * 		 * If _POSIX_CHOWN_RESTRICTED is defined, this capability 		 * shall override the restriction that a process cannot 		 * change the user ID of a file it owns and the restriction 		 * that the group ID supplied to the chown() function 		 * shall be equal to either the group ID or one of the 		 * supplementary group IDs of the calling process. 		 */
if|if
condition|(
name|restricted_chown
operator|&&
operator|(
name|iuid
operator|!=
name|uid
operator|||
operator|(
name|igid
operator|!=
name|gid
operator|&&
operator|!
name|groupmember
argument_list|(
operator|(
name|gid_t
operator|)
name|gid
argument_list|,
name|credp
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_CHOWN
argument_list|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 		 * Do a quota reservation only if uid/projid/gid is actually 		 * going to change. 		 */
if|if
condition|(
operator|(
name|XFS_IS_UQUOTA_ON
argument_list|(
name|mp
argument_list|)
operator|&&
name|iuid
operator|!=
name|uid
operator|)
operator|||
operator|(
name|XFS_IS_PQUOTA_ON
argument_list|(
name|mp
argument_list|)
operator|&&
name|iprojid
operator|!=
name|projid
operator|)
operator|||
operator|(
name|XFS_IS_GQUOTA_ON
argument_list|(
name|mp
argument_list|)
operator|&&
name|igid
operator|!=
name|gid
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|code
operator|=
name|XFS_QM_DQVOPCHOWNRESV
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|,
name|capable
argument_list|(
name|CAP_FOWNER
argument_list|)
condition|?
name|XFS_QMOPT_FORCE_RES
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
comment|/* out of quota */
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* 	 * Truncate file.  Must have write permission and not be a directory. 	 */
if|if
condition|(
name|mask
operator|&
name|XFS_AT_SIZE
condition|)
block|{
comment|/* Short circuit the truncate case for zero length files */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_size
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|==
literal|0
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|lock_flags
operator|&=
operator|~
name|XFS_ILOCK_EXCL
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|XFS_AT_CTIME
condition|)
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|VN_ISDIR
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EISDIR
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|VN_ISREG
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 		 * Make sure that the dquots are attached to the inode. 		 */
if|if
condition|(
operator|(
name|code
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|XFS_QMOPT_ILOCKED
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* 	 * Change file access or modified times. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_ATIME
operator||
name|XFS_AT_MTIME
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|file_owner
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|ATTR_UTIME
operator|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_FOWNER
argument_list|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* 	 * Change extent size or realtime flag. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_XFLAGS
operator|)
condition|)
block|{
comment|/* 		 * Can't change extent size if any extents are allocated. 		 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|&&
operator|(
name|mask
operator|&
name|XFS_AT_EXTSIZE
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
operator|)
operator|!=
name|vap
operator|->
name|va_extsize
operator|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* EFBIG? */
goto|goto
name|error_return
goto|;
block|}
comment|/* 		 * Can't change realtime flag if any extents are allocated. 		 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|||
name|ip
operator|->
name|i_delayed_blks
operator|)
operator|&&
operator|(
name|mask
operator|&
name|XFS_AT_XFLAGS
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|!=
operator|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_REALTIME
operator|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* EFBIG? */
goto|goto
name|error_return
goto|;
block|}
comment|/* 		 * Extent size must be a multiple of the appropriate block 		 * size, if set at all. 		 */
if|if
condition|(
operator|(
name|mask
operator|&
name|XFS_AT_EXTSIZE
operator|)
operator|&&
name|vap
operator|->
name|va_extsize
operator|!=
literal|0
condition|)
block|{
name|xfs_extlen_t
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|XFS_AT_XFLAGS
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_REALTIME
operator|)
operator|)
condition|)
block|{
name|size
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_extsize
operator|%
name|size
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* 		 * If realtime flag is set then must have realtime data. 		 */
if|if
condition|(
operator|(
name|mask
operator|&
name|XFS_AT_XFLAGS
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_REALTIME
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
operator|==
literal|0
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|==
literal|0
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|%
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* 		 * Can't modify an immutable/append-only file unless 		 * we have appropriate permission. 		 */
if|if
condition|(
operator|(
name|mask
operator|&
name|XFS_AT_XFLAGS
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
operator|(
name|XFS_DIFLAG_IMMUTABLE
operator||
name|XFS_DIFLAG_APPEND
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_xflags
operator|&
operator|(
name|XFS_XFLAG_IMMUTABLE
operator||
name|XFS_XFLAG_APPEND
operator|)
operator|)
operator|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_LINUX_IMMUTABLE
argument_list|)
condition|)
block|{
name|code
operator|=
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* 	 * Now we can make the changes.  Before we join the inode 	 * to the transaction, if XFS_AT_SIZE is set then take care of 	 * the part of the truncation that must be done without the 	 * inode lock.  This needs to be done before joining the inode 	 * to the transaction, because the inode cannot be unlocked 	 * once it is a part of the transaction. 	 */
if|if
condition|(
name|mask
operator|&
name|XFS_AT_SIZE
condition|)
block|{
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_size
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|)
operator|&&
operator|(
name|flags
operator|&
name|ATTR_NOSIZETOK
operator|)
operator|==
literal|0
condition|)
block|{
name|code
operator|=
name|xfs_igrow_start
argument_list|(
name|ip
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
name|credp
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|vn_iowait
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* wait for the completion of any pending DIOs */
if|if
condition|(
operator|!
name|code
condition|)
name|code
operator|=
name|xfs_itruncate_data
argument_list|(
name|ip
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|ASSERT
argument_list|(
name|tp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lock_flags
operator|&=
operator|~
name|XFS_ILOCK_EXCL
expr_stmt|;
name|ASSERT
argument_list|(
name|lock_flags
operator|==
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SETATTR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_iolock
condition|)
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|commit_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
condition|)
block|{
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* determine whether mandatory locking mode changes */
name|mandlock_before
operator|=
name|MANDLOCK
argument_list|(
name|vp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Truncate file.  Must have write permission and not be a directory. 	 */
if|if
condition|(
name|mask
operator|&
name|XFS_AT_SIZE
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_size
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|xfs_igrow_finish
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|ATTR_DMI
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vap
operator|->
name|va_size
operator|<=
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|)
operator|||
operator|(
operator|(
name|vap
operator|->
name|va_size
operator|==
literal|0
operator|)
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|)
condition|)
block|{
comment|/* 			 * signal a sync transaction unless 			 * we're truncating an already unlinked 			 * file on a wsync filesystem 			 */
name|code
operator|=
name|xfs_itruncate_finish
argument_list|(
operator|&
name|tp
argument_list|,
name|ip
argument_list|,
operator|(
name|xfs_fsize_t
operator|)
name|vap
operator|->
name|va_size
argument_list|,
name|XFS_DATA_FORK
argument_list|,
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|!=
literal|0
operator|||
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
block|}
comment|/* 		 * Have to do this even if the file's size doesn't change. 		 */
name|timeflags
operator||=
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
expr_stmt|;
block|}
comment|/* 	 * Change file access modes. 	 */
if|if
condition|(
name|mask
operator|&
name|XFS_AT_MODE
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
name|S_IFMT
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator||=
name|vap
operator|->
name|va_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|timeflags
operator||=
name|XFS_ICHGTIME_CHG
expr_stmt|;
block|}
comment|/* 	 * Change file ownership.  Must be the owner or privileged. 	 * If the system was configured with the "restricted_chown" 	 * option, the owner is not permitted to give away the file, 	 * and can change the group id only to a group of which he 	 * or she is a member. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_UID
operator||
name|XFS_AT_GID
operator||
name|XFS_AT_PROJID
operator|)
condition|)
block|{
comment|/* 		 * CAP_FSETID overrides the following restrictions: 		 * 		 * The set-user-ID and set-group-ID bits of a file will be 		 * cleared upon successful return from chown() 		 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_FSETID
argument_list|)
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
operator|~
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
expr_stmt|;
block|}
comment|/* 		 * Change the ownerships and register quota modifications 		 * in the transaction. 		 */
if|if
condition|(
name|iuid
operator|!=
name|uid
condition|)
block|{
if|if
condition|(
name|XFS_IS_UQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mask
operator|&
name|XFS_AT_UID
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|udqp
argument_list|)
expr_stmt|;
name|olddquot1
operator|=
name|XFS_QM_DQVOPCHOWN
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|i_udquot
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_uid
operator|=
name|uid
expr_stmt|;
block|}
if|if
condition|(
name|igid
operator|!=
name|gid
condition|)
block|{
if|if
condition|(
name|XFS_IS_GQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|XFS_IS_PQUOTA_ON
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mask
operator|&
name|XFS_AT_GID
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|gdqp
argument_list|)
expr_stmt|;
name|olddquot2
operator|=
name|XFS_QM_DQVOPCHOWN
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|i_gdquot
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_gid
operator|=
name|gid
expr_stmt|;
block|}
if|if
condition|(
name|iprojid
operator|!=
name|projid
condition|)
block|{
if|if
condition|(
name|XFS_IS_PQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|XFS_IS_GQUOTA_ON
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mask
operator|&
name|XFS_AT_PROJID
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|gdqp
argument_list|)
expr_stmt|;
name|olddquot2
operator|=
name|XFS_QM_DQVOPCHOWN
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|i_gdquot
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_projid
operator|=
name|projid
expr_stmt|;
comment|/* 			 * We may have to rev the inode as well as 			 * the superblock version number since projids didn't 			 * exist before DINODE_VERSION_2 and SB_VERSION_NLINK. 			 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
condition|)
name|xfs_bump_ino_vers2
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|timeflags
operator||=
name|XFS_ICHGTIME_CHG
expr_stmt|;
block|}
comment|/* 	 * Change file access or modified times. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_ATIME
operator||
name|XFS_AT_MTIME
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|XFS_AT_ATIME
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_atime
operator|.
name|t_sec
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_atime
operator|.
name|t_nsec
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_nsec
expr_stmt|;
name|ip
operator|->
name|i_update_core
operator|=
literal|1
expr_stmt|;
comment|//timeflags&= ~XFS_ICHGTIME_ACC;
block|}
if|if
condition|(
name|mask
operator|&
name|XFS_AT_MTIME
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_sec
operator|=
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_nsec
operator|=
name|vap
operator|->
name|va_mtime
operator|.
name|tv_nsec
expr_stmt|;
name|timeflags
operator|&=
operator|~
name|XFS_ICHGTIME_MOD
expr_stmt|;
name|timeflags
operator||=
name|XFS_ICHGTIME_CHG
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|&&
operator|(
name|flags
operator|&
name|ATTR_UTIME
operator|)
condition|)
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Change XFS-added attributes. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_XFLAGS
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|XFS_AT_EXTSIZE
condition|)
block|{
comment|/* 			 * Converting bytes to fs blocks. 			 */
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|=
name|vap
operator|->
name|va_extsize
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|XFS_AT_XFLAGS
condition|)
block|{
name|uint
name|di_flags
decl_stmt|;
comment|/* can't set PREALLOC this way, just preserve it */
name|di_flags
operator|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_PREALLOC
operator|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_IMMUTABLE
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_IMMUTABLE
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_APPEND
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_APPEND
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_SYNC
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_SYNC
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_NOATIME
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_NOATIME
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_NODUMP
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_NODUMP
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_PROJINHERIT
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_PROJINHERIT
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_RTINHERIT
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_RTINHERIT
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_NOSYMLINKS
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_NOSYMLINKS
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_EXTSZINHERIT
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_EXTSZINHERIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_REALTIME
condition|)
block|{
name|di_flags
operator||=
name|XFS_DIFLAG_REALTIME
expr_stmt|;
name|ip
operator|->
name|i_iocore
operator|.
name|io_flags
operator||=
name|XFS_IOCORE_RT
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_iocore
operator|.
name|io_flags
operator|&=
operator|~
name|XFS_IOCORE_RT
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_xflags
operator|&
name|XFS_XFLAG_EXTSIZE
condition|)
name|di_flags
operator||=
name|XFS_DIFLAG_EXTSIZE
expr_stmt|;
block|}
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|=
name|di_flags
expr_stmt|;
block|}
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|timeflags
operator||=
name|XFS_ICHGTIME_CHG
expr_stmt|;
block|}
comment|/* 	 * Change file inode change time only if XFS_AT_CTIME set 	 * AND we have been called by a DMI function. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ATTR_DMI
operator|)
operator|&&
operator|(
name|mask
operator|&
name|XFS_AT_CTIME
operator|)
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_sec
operator|=
name|vap
operator|->
name|va_ctime
operator|.
name|tv_sec
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_nsec
operator|=
name|vap
operator|->
name|va_ctime
operator|.
name|tv_nsec
expr_stmt|;
name|ip
operator|->
name|i_update_core
operator|=
literal|1
expr_stmt|;
name|timeflags
operator|&=
operator|~
name|XFS_ICHGTIME_CHG
expr_stmt|;
block|}
comment|/* 	 * Send out timestamp changes that need to be set to the 	 * current time.  Not done when called by a DMI function. 	 */
if|if
condition|(
name|timeflags
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ATTR_DMI
operator|)
condition|)
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|timeflags
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_attrchg
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * transaction goes to disk before returning to the user. 	 * This is slightly sub-optimal in that truncates require 	 * two sync transactions instead of one for wsync filesystems. 	 * One for the truncate and one for the timestamps since we 	 * don't want to change the timestamps unless we're sure the 	 * truncate worked.  Truncates are less than 1% of the laddis 	 * mix so this probably isn't worth the trouble to optimize. 	 */
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|code
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|commit_flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the (regular) file's mandatory locking mode changed, then 	 * notify the vnode.  We do this under the inode lock to prevent 	 * racing calls to vop_vnode_change. 	 */
name|mandlock_after
operator|=
name|MANDLOCK
argument_list|(
name|vp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mandlock_before
operator|!=
name|mandlock_after
condition|)
block|{
name|XVOP_VNODE_CHANGE
argument_list|(
name|vp
argument_list|,
name|VCHANGE_FLAGS_ENF_LOCKING
argument_list|,
name|mandlock_after
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Release any dquot(s) the inode had kept before chown. 	 */
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|olddquot1
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|olddquot2
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
return|return
name|code
return|;
block|}
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_ATTRIBUTE
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ATTR_DMI
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_ATTRIBUTE
argument_list|,
name|vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AT_DELAY_FLAG
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|abort_return
label|:
name|commit_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* FALLTHROUGH */
name|error_return
label|:
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|commit_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_access  * Null conversion from vnode mode bits to inode mode bits, as in efs.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_access
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|mode
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iaccess
argument_list|(
name|ip
argument_list|,
name|mode
argument_list|,
name|credp
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_readlink  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_readlink
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|count
decl_stmt|;
name|xfs_off_t
name|offset
decl_stmt|;
name|int
name|pathlen
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|nmaps
decl_stmt|;
name|xfs_bmbt_irec_t
name|mval
index|[
name|SYMLINK_MAPS
index|]
decl_stmt|;
name|xfs_daddr_t
name|d
decl_stmt|;
name|int
name|byte_cnt
decl_stmt|;
name|int
name|n
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
argument_list|)
expr_stmt|;
name|offset
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
name|count
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 	 * See if the symlink is stored inline. 	 */
name|pathlen
operator|=
operator|(
name|int
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFINLINE
condition|)
block|{
name|error
operator|=
name|uio_read
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
argument_list|,
name|pathlen
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Symlink not inline.  Call bmap to get it in. 		 */
name|nmaps
operator|=
name|SYMLINK_MAPS
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|pathlen
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mval
argument_list|,
operator|&
name|nmaps
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmaps
condition|;
name|n
operator|++
control|)
block|{
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|mval
index|[
name|n
index|]
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|byte_cnt
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|mval
index|[
name|n
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_buf_read
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|BTOBB
argument_list|(
name|byte_cnt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_readlink"
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|pathlen
operator|<
name|byte_cnt
condition|)
name|byte_cnt
operator|=
name|pathlen
expr_stmt|;
name|pathlen
operator|-=
name|byte_cnt
expr_stmt|;
name|error
operator|=
name|uio_read
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|byte_cnt
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_fsync  *  * This is called to sync the inode and its data out to disk.  * We need to hold the I/O lock while flushing the data, and  * the inode lock while flushing the inode.  The inode lock CANNOT  * be held while flushing the data, so acquire after we're done  * with that.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_fsync
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|,
name|xfs_off_t
name|start
parameter_list|,
name|xfs_off_t
name|stop
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|log_flushed
init|=
literal|0
decl_stmt|,
name|changed
init|=
literal|1
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|start
operator|>=
literal|0
operator|&&
name|stop
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/* 	 * We always need to make sure that the required inode state 	 * is safe on disk.  The vnode might be clean but because 	 * of committed transactions that haven't hit the disk yet. 	 * Likewise, there could be unflushed non-transactional 	 * changes to the inode core that have to go to disk. 	 * 	 * The following code depends on one assumption:  that 	 * any transaction that changes an inode logs the core 	 * because it has to change some field in the inode core 	 * (typically nextents or nblocks).  That assumption 	 * implies that any transactions against an inode will 	 * catch any non-transactional updates.  If inode-altering 	 * transactions exist that violate this assumption, the 	 * code breaks.  Right now, it figures that if the involved 	 * update_* field is clear and the inode is unpinned, the 	 * inode is clean.  Either it's been flushed or it's been 	 * committed and the commit has hit the disk unpinning the inode. 	 * (Note that xfs_inode_item_format() called at commit clears 	 * the update_* fields.) 	 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
comment|/* If we are flushing data then we care about update_size 	 * being set, otherwise we care about update_core 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|FSYNC_DATA
operator|)
condition|?
operator|(
name|ip
operator|->
name|i_update_size
operator|==
literal|0
operator|)
else|:
operator|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Timestamps/size haven't changed since last inode 		 * flush or inode transaction commit.  That means 		 * either nothing got written or a transaction 		 * committed which caught the updates.	If the 		 * latter happened and the transaction hasn't 		 * hit the disk yet, the inode will be still 		 * be pinned.  If it is, force the log. 		 */
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|_xfs_log_force
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
operator||
operator|(
operator|(
name|flag
operator|&
name|FSYNC_WAIT
operator|)
condition|?
name|XFS_LOG_SYNC
else|:
literal|0
operator|)
argument_list|,
operator|&
name|log_flushed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the inode is not pinned and nothing 			 * has changed we don't need to flush the 			 * cache. 			 */
name|changed
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Kick off a transaction to log the inode 		 * core to get the updates.  Make it 		 * sync if FSYNC_WAIT is passed in (which 		 * is done by everybody but specfs).  The 		 * sync transaction will also force the log. 		 */
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|XFS_TRANS_FSYNC_TS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_FSYNC_TS_LOG_RES
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 		 * Note - it's possible that we might have pushed 		 * ourselves out of the way during trans_reserve 		 * which would flush the inode.	 But there's no 		 * guarantee that the inode buffer has actually 		 * gone out yet (it's delwri).	Plus the buffer 		 * could be pinned anyway if it's part of an 		 * inode in another recent transaction.	 So we 		 * play it safe and fire off the transaction anyway. 		 */
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FSYNC_WAIT
condition|)
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|_xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|log_flushed
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|->
name|i_mount
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_BARRIER
operator|)
operator|&&
name|changed
condition|)
block|{
comment|/* 		 * If the log write didn't issue an ordered tag we need 		 * to flush the disk cache for the data device now. 		 */
if|if
condition|(
operator|!
name|log_flushed
condition|)
name|xfs_blkdev_issue_flush
argument_list|(
name|ip
operator|->
name|i_mount
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
comment|/* 		 * If this inode is on the RT dev we need to flush that 		 * cache as well. 		 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
condition|)
name|xfs_blkdev_issue_flush
argument_list|(
name|ip
operator|->
name|i_mount
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This is called by xfs_inactive to free any blocks beyond eof,  * when the link count isn't zero.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_inactive_free_eofblocks
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_fileoff_t
name|end_fsb
decl_stmt|;
name|xfs_fileoff_t
name|last_fsb
decl_stmt|;
name|xfs_filblks_t
name|map_len
decl_stmt|;
name|int
name|nimaps
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
decl_stmt|;
comment|/* 	 * Figure out if there are any blocks beyond the end 	 * of the file.  If not, then there is nothing to do. 	 */
name|end_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
operator|(
name|xfs_ufsize_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|)
argument_list|)
expr_stmt|;
name|last_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|map_len
operator|=
name|last_fsb
operator|-
name|end_fsb
expr_stmt|;
if|if
condition|(
name|map_len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|nimaps
operator|=
literal|1
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BMAPI
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|end_fsb
argument_list|,
name|map_len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|nimaps
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|imap
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|||
name|ip
operator|->
name|i_delayed_blks
operator|)
condition|)
block|{
comment|/* 		 * Attach the dquots to the inode up front. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 		 * There are blocks after the end of file. 		 * Free them up now by truncating the file to 		 * its current size. 		 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_INACTIVE
argument_list|)
expr_stmt|;
comment|/* 		 * Do the xfs_itruncate_start() call before 		 * reserving any log space because 		 * itruncate_start will call into the buffer 		 * cache and we can't 		 * do that within a transaction. 		 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_itruncate_start
argument_list|(
name|ip
argument_list|,
name|XFS_ITRUNC_DEFINITE
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_itruncate_finish
argument_list|(
operator|&
name|tp
argument_list|,
name|ip
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|,
name|XFS_DATA_FORK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If we get an error at this point we 		 * simply don't bother truncating the file. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
operator|(
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Free a symlink that has blocks associated with it.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_inactive_symlink_rmt
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_trans_t
modifier|*
modifier|*
name|tpp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_bmbt_irec_t
name|mval
index|[
name|SYMLINK_MAPS
index|]
decl_stmt|;
name|int
name|nmaps
decl_stmt|;
name|xfs_trans_t
modifier|*
name|ntp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|*
name|tpp
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We're freeing a symlink that has some 	 * blocks allocated to it.  Free the 	 * blocks here.  We know that we've got 	 * either 1 or 2 extents and that we can 	 * free them all in one bunmapi call. 	 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|<=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Lock the inode, fix the size, and join it to the transaction. 	 * Hold it so in the normal path, we still have it locked for 	 * the second transaction.  In the error paths we need it 	 * held so the cancel won't rele it, see below. 	 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|int
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
literal|0
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
comment|/* 	 * Find the block(s) so we can inval and unmap them. 	 */
name|done
operator|=
literal|0
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|nmaps
operator|=
sizeof|sizeof
argument_list|(
name|mval
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|size
argument_list|)
argument_list|,
name|XFS_BMAPI_METADATA
argument_list|,
operator|&
name|first_block
argument_list|,
literal|0
argument_list|,
name|mval
argument_list|,
operator|&
name|nmaps
argument_list|,
operator|&
name|free_list
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
comment|/* 	 * Invalidate the block(s). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmaps
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|mval
index|[
name|i
index|]
operator|.
name|br_startblock
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mval
index|[
name|i
index|]
operator|.
name|br_blockcount
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_trans_binval
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unmap the dead block(s) to the free_list. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bunmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|XFS_BMAPI_METADATA
argument_list|,
name|nmaps
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|NULL
argument_list|,
operator|&
name|done
argument_list|)
operator|)
condition|)
goto|goto
name|error1
goto|;
name|ASSERT
argument_list|(
name|done
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the first transaction.  This logs the EFI and the inode. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
operator|)
condition|)
goto|goto
name|error1
goto|;
comment|/* 	 * The transaction must have been committed, since there were 	 * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish. 	 * The new tp has the extent freeing and EFDs. 	 */
name|ASSERT
argument_list|(
name|committed
argument_list|)
expr_stmt|;
comment|/* 	 * The first xact was committed, so add the inode to the new one. 	 * Mark it dirty so it will be logged and moved forward in the log as 	 * part of every commit. 	 */
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
comment|/* 	 * Get a new, empty transaction to return to our caller. 	 */
name|ntp
operator|=
name|xfs_trans_dup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the transaction containing extent freeing and EFDs. 	 * If we get an error on the commit here or on the reserve below, 	 * we need to unlock the inode since the new transaction doesn't 	 * have the inode attached. 	 */
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|ntp
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * Remove the memory for extent descriptions (just bookkeeping). 	 */
if|if
condition|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
condition|)
name|xfs_idata_realloc
argument_list|(
name|ip
argument_list|,
operator|-
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Put an itruncate log reservation in the new transaction 	 * for our caller. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * Return with the inode locked but not joined to the transaction. 	 */
operator|*
name|tpp
operator|=
name|tp
expr_stmt|;
return|return
literal|0
return|;
name|error1
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|error0
label|:
comment|/* 	 * Have to come here with the inode locked and either 	 * (held and in the transaction) or (not in the transaction). 	 * If the inode isn't held then cancel would iput it, but 	 * that's wrong since this is inactive and the vnode ref 	 * count is 0 already. 	 * Cancel won't do anything to the inode if held, but it still 	 * needs to be locked until the cancel is done, if it was 	 * joined to the transaction. 	 */
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_inactive_symlink_local
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_trans_t
modifier|*
modifier|*
name|tpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We're freeing a symlink which fit into 	 * the inode.  Just free the memory used 	 * to hold the old symlink. 	 */
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
operator|*
name|tpp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
operator|*
name|tpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Zero length symlinks _can_ exist. 	 */
if|if
condition|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|>
literal|0
condition|)
block|{
name|xfs_idata_realloc
argument_list|(
name|ip
argument_list|,
operator|-
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|)
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_inactive_attrs
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_trans_t
modifier|*
modifier|*
name|tpp
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|*
name|tpp
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_attr_inactive
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
comment|/* goto out */
block|}
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_INACTIVE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_IFREE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_INACTIVE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_idestroy_fork
argument_list|(
name|ip
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|tp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_release
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VN_ISREG
argument_list|(
name|vp
argument_list|)
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If this is a read-only mount, don't do this (would generate I/O) */
if|if
condition|(
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_REFCACHE
comment|/* If we are in the NFS reference cache then don't do this now */
if|if
condition|(
name|ip
operator|->
name|i_refcache
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>
literal|0
operator|)
operator|||
operator|(
name|VN_CACHED
argument_list|(
name|vp
argument_list|)
operator|>
literal|0
operator|||
name|ip
operator|->
name|i_delayed_blks
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
operator|(
name|XFS_DIFLAG_PREALLOC
operator||
name|XFS_DIFLAG_APPEND
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inactive_free_eofblocks
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|RMC
comment|/* Update linux inode block count after free above */
name|vn_to_inode
argument_list|(
name|vp
argument_list|)
operator|->
name|i_blocks
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|+
name|ip
operator|->
name|i_delayed_blks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_inactive  *  * This is called when the vnode reference count for the vnode  * goes to zero.  If the file has been unlinked, then it must  * now be truncated.  Also, we clear all of the read-ahead state  * kept for the inode here since the file is now closed.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_inactive
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|truncate
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
comment|/* 	 * If the inode is already free, then there can be nothing 	 * to clean up here. 	 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|||
name|VN_BAD
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_real_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
comment|/* 	 * Only do a truncate if it's a regular file with 	 * some actual space in it.  It's OK to look at the 	 * inode's fields without the lock because we're the 	 * only one with a reference to the inode. 	 */
name|truncate
operator|=
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
literal|0
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_delayed_blks
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
operator|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_DESTROY
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_DESTROY
argument_list|(
name|mp
argument_list|,
name|vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* If this is a read-only mount, don't do this (would generate I/O) */
if|if
condition|(
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>
literal|0
operator|)
operator|||
operator|(
name|VN_CACHED
argument_list|(
name|vp
argument_list|)
operator|>
literal|0
operator|||
name|ip
operator|->
name|i_delayed_blks
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
operator|(
name|XFS_DIFLAG_PREALLOC
operator||
name|XFS_DIFLAG_APPEND
operator|)
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_delayed_blks
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inactive_free_eofblocks
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
operator|)
condition|)
return|return
name|VN_INACTIVE_CACHE
return|;
ifdef|#
directive|ifdef
name|RMC
comment|/* Update linux inode block count after free above */
name|vn_to_inode
argument_list|(
name|vp
argument_list|)
operator|->
name|i_blocks
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|+
name|ip
operator|->
name|i_delayed_blks
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|VN_INACTIVE_CACHE
return|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_INACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|truncate
condition|)
block|{
comment|/* 		 * Do the xfs_itruncate_start() call before 		 * reserving any log space because itruncate_start 		 * will call into the buffer cache and we can't 		 * do that within a transaction. 		 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_itruncate_start
argument_list|(
name|ip
argument_list|,
name|XFS_ITRUNC_DEFINITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Don't call itruncate_cleanup */
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * normally, we have to run xfs_itruncate_finish sync. 		 * But if filesystem is wsync and we're in the inactive 		 * path, then we know that nlink == 0, and that the 		 * xaction that made nlink == 0 is permanently committed 		 * since xfs_remove runs as a synchronous transaction. 		 */
name|error
operator|=
name|xfs_itruncate_finish
argument_list|(
operator|&
name|tp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|XFS_DATA_FORK
argument_list|,
operator|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
comment|/* 		 * If we get an error while cleaning up a 		 * symlink we bail out. 		 */
name|error
operator|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|)
condition|?
name|xfs_inactive_symlink_rmt
argument_list|(
name|ip
argument_list|,
operator|&
name|tp
argument_list|)
else|:
name|xfs_inactive_symlink_local
argument_list|(
name|ip
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|tp
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_IFREE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_INACTIVE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are attributes associated with the file 	 * then blow them away now.  The code calls a routine 	 * that recursively deconstructs the attribute fork. 	 * We need to just commit the current transaction 	 * because we can't use it for xfs_attr_inactive(). 	 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_inactive_attrs
argument_list|(
name|ip
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * If we got an error, the transaction is already 		 * cancelled, and the inode is unlocked. Just get out. 		 */
if|if
condition|(
name|error
condition|)
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|i_afp
condition|)
block|{
name|xfs_idestroy_fork
argument_list|(
name|ip
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the inode. 	 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_ifree
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If we fail to free the inode, shut down.  The cancel 		 * might do that, we need to make sure.  Otherwise the 		 * inode might be lost for a long time or forever. 		 */
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"xfs_inactive:	xfs_ifree() returned an error = %d on %s"
argument_list|,
name|error
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
block|}
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Credit the quota account(s). The inode is gone. 		 */
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_TRANS_DQ_ICOUNT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Just ignore errors at this point.  There is 		 * nothing we can do except to try to keep going. 		 */
operator|(
name|void
operator|)
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release the dquots held by inode, if any. 	 */
name|XFS_QM_DQDETACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|VN_INACTIVE_CACHE
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_lookup  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_lookup
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|flags
parameter_list|,
name|xfs_vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|xfs_ino_t
name|e_inum
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint
name|lock_mode
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|lock_mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_dir_lookup_int
argument_list|(
name|dir_bdp
argument_list|,
name|lock_mode
argument_list|,
name|dentry
argument_list|,
operator|&
name|e_inum
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|vpp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ITRACE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock_map_shared
argument_list|(
name|dp
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_create (create a new file).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_create
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_vattr_t
modifier|*
name|vap
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|VNAME
argument_list|(
name|dentry
argument_list|)
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_dev_t
name|rdev
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|boolean_t
name|dp_joined_to_trans
decl_stmt|;
name|int
name|dm_event_sent
init|=
literal|0
decl_stmt|;
name|uint
name|cancel_flags
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_prid_t
name|prid
decl_stmt|;
name|struct
name|xfs_dquot
modifier|*
name|udqp
decl_stmt|,
modifier|*
name|gdqp
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
name|int
name|dm_di_mode
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|dm_di_mode
operator|=
name|vap
operator|->
name|va_mode
expr_stmt|;
name|namelen
operator|=
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_CREATE
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_CREATE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dm_di_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|dm_event_sent
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/* Return through std_return after this point. */
name|udqp
operator|=
name|gdqp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_PROJINHERIT
condition|)
name|prid
operator|=
name|dp
operator|->
name|i_d
operator|.
name|di_projid
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|XFS_AT_PROJID
condition|)
name|prid
operator|=
operator|(
name|xfs_prid_t
operator|)
name|vap
operator|->
name|va_projid
expr_stmt|;
else|else
name|prid
operator|=
operator|(
name|xfs_prid_t
operator|)
name|dfltprid
expr_stmt|;
comment|/* 	 * Make sure that we have allocated dquot(s) on disk. 	 */
name|error
operator|=
name|XFS_QM_DQVOPALLOC
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
name|current_fsuid
argument_list|(
name|credp
argument_list|)
argument_list|,
name|current_fsgid
argument_list|(
name|credp
argument_list|)
argument_list|,
name|prid
argument_list|,
name|XFS_QMOPT_QUOTALL
operator||
name|XFS_QMOPT_INHERIT
argument_list|,
operator|&
name|udqp
argument_list|,
operator|&
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|std_return
goto|;
name|ip
operator|=
name|NULL
expr_stmt|;
name|dp_joined_to_trans
operator|=
name|B_FALSE
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_CREATE
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
name|resblks
operator|=
name|XFS_CREATE_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* 	 * Initially assume that the file does not exist and 	 * reserve the resources for that case.  If that is not 	 * the case we'll drop the one we have and get a more 	 * appropriate transaction later. 	 */
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_CREATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_CREATE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|resblks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_CREATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_CREATE_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|cancel_flags
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve disk quota and the inode. 	 */
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|,
name|resblks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|resblks
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|XFS_DIR_CANENTER
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|rdev
operator|=
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|XFS_AT_RDEV
operator|)
condition|?
name|vap
operator|->
name|va_rdev
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_dir_ialloc
argument_list|(
operator|&
name|tp
argument_list|,
name|dp
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|,
literal|1
argument_list|,
name|rdev
argument_list|,
name|credp
argument_list|,
name|prid
argument_list|,
name|resblks
operator|>
literal|0
argument_list|,
operator|&
name|ip
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
goto|goto
name|error_return
goto|;
goto|goto
name|abort_return
goto|;
block|}
name|ITRACE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, we've gotten a newly allocated inode. 	 * It is locked (and joined to the transaction). 	 */
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now we join the directory inode to the transaction. 	 * We do not do it earlier because xfs_dir_ialloc 	 * might commit the previous transaction (and release 	 * all the locks). 	 */
name|VN_HOLD
argument_list|(
name|dir_vp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|dp_joined_to_trans
operator|=
name|B_TRUE
expr_stmt|;
name|error
operator|=
name|XFS_DIR_CREATENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|resblks
condition|?
name|resblks
operator|-
name|XFS_IALLOC_SPACE_RES
argument_list|(
name|mp
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|abort_return
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * create transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|i_gen
operator|++
expr_stmt|;
comment|/* 	 * Attach the dquot(s) to the inodes and modify them incore. 	 * These ids of the inode couldn't have changed since the new 	 * inode has been locked ever since it was created. 	 */
name|XFS_QM_DQVOPCREATE
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
comment|/* 	 * xfs_trans_commit normally decrements the vnode ref count 	 * when it unlocks the inode. Since we want to return the 	 * vnode to the caller, we bump the vnode ref count now. 	 */
name|IHOLD
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
goto|goto
name|abort_rele
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|tp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
comment|/* 	 * Propagate the fact that the vnode changed after the 	 * xfs_inode locks have been released. 	 */
name|XVOP_VNODE_CHANGE
argument_list|(
name|vp
argument_list|,
name|VCHANGE_FLAGS_TRUNCATED
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
comment|/* Fallthrough to std_return with error = 0  */
name|std_return
label|:
if|if
condition|(
operator|(
operator|*
name|vpp
operator|||
operator|(
name|error
operator|!=
literal|0
operator|&&
name|dm_event_sent
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
argument_list|,
name|DM_EVENT_POSTCREATE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTCREATE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
operator|*
name|vpp
condition|?
name|vp
else|:
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dm_di_mode
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|abort_return
label|:
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* FALLTHROUGH */
name|error_return
label|:
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp_joined_to_trans
operator|&&
operator|(
name|dp
operator|!=
name|NULL
operator|)
condition|)
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
name|abort_rele
label|:
comment|/* 	 * Wait until after the current transaction is aborted to 	 * release the inode.  This prevents recursive transactions 	 * and deadlocks from xfs_inactive. 	 */
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Some counters to see if (and how often) we are hitting some deadlock  * prevention code paths.  */
end_comment

begin_decl_stmt
name|int
name|xfs_rm_locks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_rm_lock_delays
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_rm_attempts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following routine will lock the inodes associated with the  * directory and the named entry in the directory. The locks are  * acquired in increasing inode number.  *  * If the entry is "..", then only the directory is locked. The  * vnode ref count will still include that from the .. entry in  * this case.  *  * There is a deadlock we need to worry about. If the locked directory is  * in the AIL, it might be blocking up the log. The next inode we lock  * could be already locked by another thread waiting for log space (e.g  * a permanent log reservation with a long running transaction (see  * xfs_itruncate_finish)). To solve this, we must check if the directory  * is in the ail and use lock_nowait. If we can't lock, we need to  * drop the inode lock on the directory and try again. xfs_iunlock will  * potentially push the tail if we were holding up the log.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_lock_dir_and_entry
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
comment|/* inode of entry 'name' */
block|{
name|int
name|attempts
decl_stmt|;
name|xfs_ino_t
name|e_inum
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ips
index|[
literal|2
index|]
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_rm_locks
operator|++
expr_stmt|;
endif|#
directive|endif
name|attempts
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|e_inum
operator|=
name|ip
operator|->
name|i_ino
expr_stmt|;
name|ITRACE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * We want to lock in increasing inum. Since we've already 	 * acquired the lock on the directory, we may need to release 	 * if if the inum of the entry turns out to be less. 	 */
if|if
condition|(
name|e_inum
operator|>
name|dp
operator|->
name|i_ino
condition|)
block|{
comment|/* 		 * We are already in the right order, so just 		 * lock on the inode of the entry. 		 * We need to use nowait if dp is in the AIL. 		 */
name|lp
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|dp
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
name|lp
operator|&&
operator|(
name|lp
operator|->
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
condition|)
block|{
name|attempts
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_rm_attempts
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Unlock dp and try again. 				 * xfs_iunlock will try to push the tail 				 * if the inode is in the AIL. 				 */
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attempts
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't just spin the CPU */
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_rm_lock_delays
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|again
goto|;
block|}
block|}
else|else
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e_inum
operator|<
name|dp
operator|->
name|i_ino
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|ips
index|[
literal|0
index|]
operator|=
name|ip
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|dp
expr_stmt|;
name|xfs_lock_inodes
argument_list|(
name|ips
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
comment|/* else	 e_inum == dp->i_ino */
comment|/*     This can happen if we're asked to lock /x/.. 	 *     the entry is "..", which is also the parent directory. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|xfs_locked_n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_small_retries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_middle_retries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_lots_retries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xfs_lock_delays
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following routine will lock n inodes in exclusive mode.  * We assume the caller calls us with the inodes in i_ino order.  *  * We need to detect deadlock where an inode that we lock  * is in the AIL and we start waiting for another inode that is locked  * by a thread in a long running transaction (such as truncate). This can  * result in deadlock since the long running trans might need to wait  * for the inode we just locked in order to push the tail and free space  * in the log.  */
end_comment

begin_function
name|void
name|xfs_lock_inodes
parameter_list|(
name|xfs_inode_t
modifier|*
modifier|*
name|ips
parameter_list|,
name|int
name|inodes
parameter_list|,
name|int
name|first_locked
parameter_list|,
name|uint
name|lock_mode
parameter_list|)
block|{
name|int
name|attempts
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|try_lock
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lp
decl_stmt|;
name|ASSERT
argument_list|(
name|ips
operator|&&
operator|(
name|inodes
operator|>=
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* we need at least two */
if|if
condition|(
name|first_locked
condition|)
block|{
name|try_lock
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|try_lock
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|again
label|:
for|for
control|(
init|;
name|i
operator|<
name|inodes
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|ips
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|(
name|ips
index|[
name|i
index|]
operator|==
name|ips
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
comment|/* Already locked */
continue|continue;
comment|/* 		 * If try_lock is not set yet, make sure all locked inodes 		 * are not in the AIL. 		 * If any are, set try_lock to be used later. 		 */
if|if
condition|(
operator|!
name|try_lock
condition|)
block|{
for|for
control|(
name|j
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
init|;
name|j
operator|>=
literal|0
operator|&&
operator|!
name|try_lock
condition|;
name|j
operator|--
control|)
block|{
name|lp
operator|=
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|ips
index|[
name|j
index|]
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
name|lp
operator|&&
operator|(
name|lp
operator|->
name|li_flags
operator|&
name|XFS_LI_IN_AIL
operator|)
condition|)
block|{
name|try_lock
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * If any of the previous locks we have locked is in the AIL, 		 * we must TRY to get the second and subsequent locks. If 		 * we can't get any, we must release all we have 		 * and try again. 		 */
if|if
condition|(
name|try_lock
condition|)
block|{
comment|/* try_lock must be 0 if i is 0. */
comment|/* 			 * try_lock means we have an inode locked 			 * that is in the AIL. 			 */
name|ASSERT
argument_list|(
name|i
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_ilock_nowait
argument_list|(
name|ips
index|[
name|i
index|]
argument_list|,
name|lock_mode
argument_list|)
condition|)
block|{
name|attempts
operator|++
expr_stmt|;
comment|/* 				 * Unlock all previous guys and try again. 				 * xfs_iunlock will try to push the tail 				 * if the inode is in the AIL. 				 */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
comment|/* 					 * Check to see if we've already 					 * unlocked this one. 					 * Not the first one going back, 					 * and the inode ptr is the same. 					 */
if|if
condition|(
operator|(
name|j
operator|!=
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|&&
name|ips
index|[
name|j
index|]
operator|==
name|ips
index|[
name|j
operator|+
literal|1
index|]
condition|)
continue|continue;
name|xfs_iunlock
argument_list|(
name|ips
index|[
name|j
index|]
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|attempts
operator|%
literal|5
operator|)
operator|==
literal|0
condition|)
block|{
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't just spin the CPU */
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_lock_delays
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|try_lock
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
else|else
block|{
name|xfs_ilock
argument_list|(
name|ips
index|[
name|i
index|]
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|attempts
condition|)
block|{
if|if
condition|(
name|attempts
operator|<
literal|5
condition|)
name|xfs_small_retries
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|attempts
operator|<
literal|100
condition|)
name|xfs_middle_retries
operator|++
expr_stmt|;
else|else
name|xfs_lots_retries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xfs_locked_n
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|REMOVE_DEBUG_TRACE
parameter_list|(
name|x
parameter_list|)
value|{remove_which_error_return = (x);}
end_define

begin_decl_stmt
name|int
name|remove_which_error_return
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! DEBUG */
end_comment

begin_define
define|#
directive|define
name|REMOVE_DEBUG_TRACE
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! DEBUG */
end_comment

begin_function_decl
specifier|extern
name|int
name|xfs_remove
parameter_list|(
name|bhv_desc_t
modifier|*
parameter_list|,
name|bhv_desc_t
modifier|*
parameter_list|,
name|vname_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * xfs_remove  *  */
end_comment

begin_function
name|int
name|xfs_remove
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|bhv_desc_t
modifier|*
name|vp_bdp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|VNAME
argument_list|(
name|dentry
argument_list|)
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|int
name|cancel_flags
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|int
name|dm_di_mode
init|=
literal|0
decl_stmt|;
name|int
name|link_zero
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|xvp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|vp_bdp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xfs_remove: dvp %p vp %p\n"
argument_list|,
name|dir_vp
argument_list|,
name|xvp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|namelen
operator|=
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_REMOVE
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_REMOVE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* From this point on, return through std_return */
name|ip
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We need to get a reference to ip before we get our log 	 * reservation. The reason for this is that we cannot call 	 * xfs_iget for an inode for which we do not have a reference 	 * once we've acquired a log reservation. This is because the 	 * inode we are trying to get might be in xfs_inactive going 	 * for a log reservation. Since we'll have to wait for the 	 * inactive code to complete before returning from xfs_iget, 	 * we need to make sure that we don't have log space reserved 	 * when we call xfs_iget.  Instead we get an unlocked reference 	 * to the inode before getting our log reservation. 	 */
ifdef|#
directive|ifdef
name|RMC
name|error
operator|=
name|xfs_get_dir_entry
argument_list|(
name|dentry
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FreeBSD has already done the lookup */
name|ip
operator|=
name|xvp
operator|->
name|v_inode
expr_stmt|;
name|VN_HOLD
argument_list|(
name|xvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
name|dm_di_mode
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_mode
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ITRACE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|dp
operator|!=
name|ip
condition|)
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_REMOVE
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
comment|/* 	 * We try to get the real space reservation first, 	 * allowing for directory btree deletion(s) implying 	 * possible bmap insert(s).  If we can't get the space 	 * reservation then we use 0 instead, and avoid the bmap 	 * btree insert(s) in the directory code by, if the bmap 	 * insert tries to happen, instead trimming the LAST 	 * block from the directory. 	 */
name|resblks
operator|=
name|XFS_REMOVE_SPACE_RES
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_REMOVE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_REMOVE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|resblks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_REMOVE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_REMOVE_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|xfs_lock_dir_and_entry
argument_list|(
name|dp
argument_list|,
name|dentry
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
comment|/* 	 * At this point, we've gotten both the directory and the entry 	 * inodes locked. 	 */
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|ip
condition|)
block|{
comment|/* 		 * Increment vnode ref count only in this case since 		 * there's an extra vnode reference in the case where 		 * dp == ip. 		 */
name|IHOLD
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Entry must exist since we did a lookup in xfs_lock_dir_and_entry. 	 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_DIR_REMOVENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOENT
argument_list|)
expr_stmt|;
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|dp
operator|->
name|i_gen
operator|++
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* Determine if this is the last link while 	 * we are in the transaction. 	 */
name|link_zero
operator|=
operator|(
name|ip
operator|)
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
expr_stmt|;
comment|/* 	 * Take an extra ref on the inode so that it doesn't 	 * go to xfs_inactive() from within the commit. 	 */
name|IHOLD
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * remove transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|error_rele
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
comment|/* 	 * Before we drop our extra reference to the inode, purge it 	 * from the refcache if it is there.  By waiting until afterwards 	 * to do the IRELE, we ensure that we won't go inactive in the 	 * xfs_refcache_purge_ip routine (although that would be OK). 	 */
name|xfs_refcache_purge_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vn_trace_exit
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
comment|/* 	 * Let interposed file systems know about removed links. 	 */
name|XVOP_LINK_REMOVED
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|dir_vp
argument_list|,
name|link_zero
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/*	Fall through to std_return with error = 0 */
name|std_return
label|:
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_POSTREMOVE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTREMOVE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dm_di_mode
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|error1
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
name|error_rele
label|:
comment|/* 	 * In this case make sure to not release the inode until after 	 * the current transaction is aborted.  Releasing it beforehand 	 * can cause us to go to xfs_inactive and start a recursive 	 * transaction which can easily deadlock with the current one. 	 */
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Before we drop our extra reference to the inode, purge it 	 * from the refcache if it is there.  By waiting until afterwards 	 * to do the IRELE, we ensure that we won't go inactive in the 	 * xfs_refcache_purge_ip routine (although that would be OK). 	 */
name|xfs_refcache_purge_ip
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
end_function

begin_comment
comment|/*  * xfs_link  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_link
parameter_list|(
name|bhv_desc_t
modifier|*
name|target_dir_bdp
parameter_list|,
name|xfs_vnode_t
modifier|*
name|src_vp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|tdp
decl_stmt|,
modifier|*
name|sip
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ips
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|int
name|cancel_flags
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|target_dir_vp
decl_stmt|;
name|int
name|resblks
decl_stmt|;
name|char
modifier|*
name|target_name
init|=
name|VNAME
argument_list|(
name|dentry
argument_list|)
decl_stmt|;
name|int
name|target_namelen
decl_stmt|;
name|target_dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|target_dir_bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|target_dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|src_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|target_namelen
operator|=
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|VN_ISDIR
argument_list|(
name|src_vp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
name|sip
operator|=
name|xfs_vtoi
argument_list|(
name|src_vp
argument_list|)
expr_stmt|;
name|tdp
operator|=
name|XFS_BHVTOI
argument_list|(
name|target_dir_bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tdp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|src_vp
operator|->
name|v_vfsp
argument_list|,
name|tdp
argument_list|,
name|DM_EVENT_LINK
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_LINK
argument_list|,
name|target_dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|src_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|target_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* Return through std_return after this point. */
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|sip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|sip
operator|!=
name|tdp
condition|)
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|tdp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|std_return
goto|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_LINK
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
name|resblks
operator|=
name|XFS_LINK_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|target_namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_LINK_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_LINK_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|resblks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_LINK_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_LINK_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|cancel_flags
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|sip
operator|->
name|i_ino
operator|<
name|tdp
operator|->
name|i_ino
condition|)
block|{
name|ips
index|[
literal|0
index|]
operator|=
name|sip
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|tdp
expr_stmt|;
block|}
else|else
block|{
name|ips
index|[
literal|0
index|]
operator|=
name|tdp
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|sip
expr_stmt|;
block|}
name|xfs_lock_inodes
argument_list|(
name|ips
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Increment vnode ref counts since xfs_trans_commit& 	 * xfs_trans_cancel will both unlock the inodes and 	 * decrement the associated ref counts. 	 */
name|VN_HOLD
argument_list|(
name|src_vp
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|target_dir_vp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|sip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|tdp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * If the source has too many links, we can't make any more to it. 	 */
if|if
condition|(
name|sip
operator|->
name|i_d
operator|.
name|di_nlink
operator|>=
name|XFS_MAXLINK
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EMLINK
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 	 * If we are using project inheritance, we only allow hard link 	 * creation in our tree when the project IDs are the same; else 	 * the tree quota mechanism could be circumvented. 	 */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|tdp
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_PROJINHERIT
operator|)
operator|&&
operator|(
name|tdp
operator|->
name|i_d
operator|.
name|di_projid
operator|!=
name|sip
operator|->
name|i_d
operator|.
name|di_projid
operator|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|resblks
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|XFS_DIR_CANENTER
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|tdp
argument_list|,
name|target_name
argument_list|,
name|target_namelen
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_DIR_CREATENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|tdp
argument_list|,
name|target_name
argument_list|,
name|target_namelen
argument_list|,
name|sip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|resblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|abort_return
goto|;
name|xfs_ichgtime
argument_list|(
name|tdp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|tdp
operator|->
name|i_gen
operator|++
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|tdp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bumplink
argument_list|(
name|tp
argument_list|,
name|sip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|abort_return
goto|;
block|}
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * link transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
goto|goto
name|abort_return
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|std_return
goto|;
block|}
comment|/* Fall through to std_return with error = 0. */
name|std_return
label|:
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|src_vp
operator|->
name|v_vfsp
argument_list|,
name|sip
argument_list|,
name|DM_EVENT_POSTLINK
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTLINK
argument_list|,
name|target_dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|src_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|target_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|abort_return
label|:
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* FALLTHROUGH */
name|error_return
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
end_function

begin_comment
comment|/*  * xfs_mkdir  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_mkdir
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_vattr_t
modifier|*
name|vap
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|char
modifier|*
name|dir_name
init|=
name|VNAME
argument_list|(
name|dentry
argument_list|)
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|cdp
decl_stmt|;
comment|/* inode of created dir */
name|xfs_vnode_t
modifier|*
name|cvp
decl_stmt|;
comment|/* vnode of created dir */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|cancel_flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|boolean_t
name|dp_joined_to_trans
decl_stmt|;
name|boolean_t
name|created
init|=
name|B_FALSE
decl_stmt|;
name|int
name|dm_event_sent
init|=
literal|0
decl_stmt|;
name|xfs_prid_t
name|prid
decl_stmt|;
name|struct
name|xfs_dquot
modifier|*
name|udqp
decl_stmt|,
modifier|*
name|gdqp
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
name|int
name|dm_di_mode
decl_stmt|;
name|int
name|dir_namelen
decl_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|dir_namelen
operator|=
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
name|tp
operator|=
name|NULL
expr_stmt|;
name|dp_joined_to_trans
operator|=
name|B_FALSE
expr_stmt|;
name|dm_di_mode
operator|=
name|vap
operator|->
name|va_mode
expr_stmt|;
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_CREATE
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_CREATE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|dir_name
argument_list|,
name|NULL
argument_list|,
name|dm_di_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|dm_event_sent
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return through std_return after this point. */
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|udqp
operator|=
name|gdqp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_PROJINHERIT
condition|)
name|prid
operator|=
name|dp
operator|->
name|i_d
operator|.
name|di_projid
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|XFS_AT_PROJID
condition|)
name|prid
operator|=
operator|(
name|xfs_prid_t
operator|)
name|vap
operator|->
name|va_projid
expr_stmt|;
else|else
name|prid
operator|=
operator|(
name|xfs_prid_t
operator|)
name|dfltprid
expr_stmt|;
comment|/* 	 * Make sure that we have allocated dquot(s) on disk. 	 */
name|error
operator|=
name|XFS_QM_DQVOPALLOC
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
name|current_fsuid
argument_list|(
name|credp
argument_list|)
argument_list|,
name|current_fsgid
argument_list|(
name|credp
argument_list|)
argument_list|,
name|prid
argument_list|,
name|XFS_QMOPT_QUOTALL
operator||
name|XFS_QMOPT_INHERIT
argument_list|,
operator|&
name|udqp
argument_list|,
operator|&
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|std_return
goto|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_MKDIR
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
name|resblks
operator|=
name|XFS_MKDIR_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|dir_namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_MKDIR_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_MKDIR_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|resblks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_MKDIR_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_MKDIR_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|cancel_flags
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Check for directory link count overflow. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_nlink
operator|>=
name|XFS_MAXLINK
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EMLINK
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 	 * Reserve disk quota and the inode. 	 */
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|,
name|resblks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|resblks
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|XFS_DIR_CANENTER
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|dir_name
argument_list|,
name|dir_namelen
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* 	 * create the directory inode. 	 */
name|error
operator|=
name|xfs_dir_ialloc
argument_list|(
operator|&
name|tp
argument_list|,
name|dp
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|credp
argument_list|,
name|prid
argument_list|,
name|resblks
operator|>
literal|0
argument_list|,
operator|&
name|cdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
goto|goto
name|error_return
goto|;
goto|goto
name|abort_return
goto|;
block|}
name|ITRACE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
comment|/* 	 * Now we add the directory inode to the transaction. 	 * We waited until now since xfs_dir_ialloc might start 	 * a new transaction.  Had we joined the transaction 	 * earlier, the locks might have gotten released. 	 */
name|VN_HOLD
argument_list|(
name|dir_vp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|dp_joined_to_trans
operator|=
name|B_TRUE
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_DIR_CREATENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|dir_name
argument_list|,
name|dir_namelen
argument_list|,
name|cdp
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|resblks
condition|?
name|resblks
operator|-
name|XFS_IALLOC_SPACE_RES
argument_list|(
name|mp
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
comment|/* 	 * Bump the in memory version number of the parent directory 	 * so that other processes accessing it will recognize that 	 * the directory has changed. 	 */
name|dp
operator|->
name|i_gen
operator|++
expr_stmt|;
name|error
operator|=
name|XFS_DIR_INIT
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|cdp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error2
goto|;
block|}
name|cdp
operator|->
name|i_gen
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_bumplink
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error2
goto|;
block|}
name|cvp
operator|=
name|XFS_ITOV
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
name|created
operator|=
name|B_TRUE
expr_stmt|;
operator|*
name|vpp
operator|=
name|cvp
expr_stmt|;
name|IHOLD
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
comment|/* 	 * Attach the dquots to the new inode and modify the icount incore. 	 */
name|XFS_QM_DQVOPCREATE
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|cdp
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * mkdir transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through to std_return with error = 0 or errno from 	 * xfs_trans_commit. */
name|std_return
label|:
if|if
condition|(
operator|(
name|created
operator|||
operator|(
name|error
operator|!=
literal|0
operator|&&
name|dm_event_sent
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
argument_list|,
name|DM_EVENT_POSTCREATE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTCREATE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|created
condition|?
name|XFS_ITOV
argument_list|(
name|cdp
argument_list|)
else|:
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|dir_name
argument_list|,
name|NULL
argument_list|,
name|dm_di_mode
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|error2
label|:
name|error1
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|abort_return
label|:
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
name|error_return
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp_joined_to_trans
operator|&&
operator|(
name|dp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
goto|goto
name|std_return
goto|;
block|}
end_function

begin_comment
comment|/*  * xfs_rmdir  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_rmdir
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|VNAME
argument_list|(
name|dentry
argument_list|)
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|cdp
decl_stmt|;
comment|/* child directory */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|int
name|cancel_flags
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|int
name|dm_di_mode
init|=
literal|0
decl_stmt|;
name|int
name|last_cdp_link
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
operator|->
name|i_mount
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|namelen
operator|=
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_REMOVE
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_REMOVE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
comment|/* Return through std_return after this point. */
name|cdp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We need to get a reference to cdp before we get our log 	 * reservation.  The reason for this is that we cannot call 	 * xfs_iget for an inode for which we do not have a reference 	 * once we've acquired a log reservation.  This is because the 	 * inode we are trying to get might be in xfs_inactive going 	 * for a log reservation.  Since we'll have to wait for the 	 * inactive code to complete before returning from xfs_iget, 	 * we need to make sure that we don't have log space reserved 	 * when we call xfs_iget.  Instead we get an unlocked reference 	 * to the inode before getting our log reservation. 	 */
name|error
operator|=
name|xfs_get_dir_entry
argument_list|(
name|dentry
argument_list|,
operator|&
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|dm_di_mode
operator|=
name|cdp
operator|->
name|i_d
operator|.
name|di_mode
expr_stmt|;
comment|/* 	 * Get the dquots for the inodes. 	 */
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|dp
operator|!=
name|cdp
condition|)
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|cdp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
name|REMOVE_DEBUG_TRACE
argument_list|(
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_RMDIR
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
comment|/* 	 * We try to get the real space reservation first, 	 * allowing for directory btree deletion(s) implying 	 * possible bmap insert(s).  If we can't get the space 	 * reservation then we use 0 instead, and avoid the bmap 	 * btree insert(s) in the directory code by, if the bmap 	 * insert tries to happen, instead trimming the LAST 	 * block from the directory. 	 */
name|resblks
operator|=
name|XFS_REMOVE_SPACE_RES
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_REMOVE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_DEFAULT_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|resblks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_REMOVE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_DEFAULT_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
literal|0
expr_stmt|;
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
comment|/* 	 * Now lock the child directory inode and the parent directory 	 * inode in the proper order.  This will take care of validating 	 * that the directory entry for the child directory inode has 	 * not changed while we were obtaining a log reservation. 	 */
name|error
operator|=
name|xfs_lock_dir_and_entry
argument_list|(
name|dp
argument_list|,
name|dentry
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|cdp
condition|)
block|{
comment|/* 		 * Only increment the parent directory vnode count if 		 * we didn't bump it in looking up cdp.  The only time 		 * we don't bump it is when we're looking up ".". 		 */
name|VN_HOLD
argument_list|(
name|dir_vp
argument_list|)
expr_stmt|;
block|}
name|ITRACE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|cdp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cdp
operator|->
name|i_d
operator|.
name|di_nlink
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|i_d
operator|.
name|di_nlink
operator|!=
literal|2
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOTEMPTY
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|!
name|XFS_DIR_ISEMPTY
argument_list|(
name|mp
argument_list|,
name|cdp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOTEMPTY
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|error
operator|=
name|XFS_DIR_REMOVENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|cdp
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|resblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error1
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
comment|/* 	 * Bump the in memory generation count on the parent 	 * directory so that other can know that it has changed. 	 */
name|dp
operator|->
name|i_gen
operator|++
expr_stmt|;
comment|/* 	 * Drop the link from cdp's "..". 	 */
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error1
goto|;
block|}
comment|/* 	 * Drop the link from dp to cdp. 	 */
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error1
goto|;
block|}
comment|/* 	 * Drop the "." link from cdp to self. 	 */
name|error
operator|=
name|xfs_droplink
argument_list|(
name|tp
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error1
goto|;
block|}
comment|/* Determine these before committing transaction */
name|last_cdp_link
operator|=
operator|(
name|cdp
operator|)
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
expr_stmt|;
comment|/* 	 * Take an extra ref on the child vnode so that it 	 * does not go to xfs_inactive() from within the commit. 	 */
name|IHOLD
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * rmdir transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
operator|(
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
operator|)
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
comment|/* 	 * Let interposed file systems know about removed links. 	 */
name|XVOP_LINK_REMOVED
argument_list|(
name|XFS_ITOV
argument_list|(
name|cdp
argument_list|)
argument_list|,
name|dir_vp
argument_list|,
name|last_cdp_link
argument_list|)
expr_stmt|;
name|IRELE
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
comment|/* Fall through to std_return with error = 0 or the errno 	 * from xfs_trans_commit. */
name|std_return
label|:
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_POSTREMOVE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTREMOVE
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dm_di_mode
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|error1
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* FALLTHROUGH */
name|error_return
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
goto|goto
name|std_return
goto|;
block|}
end_function

begin_comment
comment|/*  * xfs_readdir  *  * Read dp's entries starting at uiop->uio_offset and translate them into  * bufsize bytes worth of struct dirents starting at bufbase.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_readdir
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint
name|lock_mode
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|)
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|lock_mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_DIR_GETDENTS
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|uiop
argument_list|,
name|eofp
argument_list|)
expr_stmt|;
name|xfs_iunlock_map_shared
argument_list|(
name|dp
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_symlink  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_symlink
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_vattr_t
modifier|*
name|vap
parameter_list|,
name|char
modifier|*
name|target_path
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|pathlen
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|boolean_t
name|dp_joined_to_trans
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|uint
name|cancel_flags
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|xfs_fileoff_t
name|first_fsb
decl_stmt|;
name|xfs_filblks_t
name|fs_blocks
decl_stmt|;
name|int
name|nmaps
decl_stmt|;
name|xfs_bmbt_irec_t
name|mval
index|[
name|SYMLINK_MAPS
index|]
decl_stmt|;
name|xfs_daddr_t
name|d
decl_stmt|;
name|char
modifier|*
name|cur_chunk
decl_stmt|;
name|int
name|byte_cnt
decl_stmt|;
name|int
name|n
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_prid_t
name|prid
decl_stmt|;
name|struct
name|xfs_dquot
modifier|*
name|udqp
decl_stmt|,
modifier|*
name|gdqp
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
name|char
modifier|*
name|link_name
init|=
name|VNAME
argument_list|(
name|dentry
argument_list|)
decl_stmt|;
name|int
name|link_namelen
decl_stmt|;
name|struct
name|thread
modifier|*
name|current
init|=
name|curthread
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|dp_joined_to_trans
operator|=
name|B_FALSE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|NULL
expr_stmt|;
name|tp
operator|=
name|NULL
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|link_namelen
operator|=
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
comment|/* 	 * Check component lengths of the target path name. 	 */
name|pathlen
operator|=
name|strlen
argument_list|(
name|target_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathlen
operator|>=
name|MAXPATHLEN
condition|)
comment|/* total string too long */
return|return
name|XFS_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
return|;
if|if
condition|(
name|pathlen
operator|>=
name|MAXNAMELEN
condition|)
block|{
comment|/* is any component too long? */
name|int
name|len
decl_stmt|,
name|total
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
for|for
control|(
name|total
operator|=
literal|0
operator|,
name|path
operator|=
name|target_path
init|;
name|total
operator|<
name|pathlen
condition|;
control|)
block|{
comment|/* 			 * Skip any slashes. 			 */
while|while
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
comment|/* 			 * Count up to the next slash or end of path. 			 * Error out if the component is bigger than MAXNAMELEN. 			 */
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|*
name|path
operator|!=
literal|'/'
operator|&&
name|total
operator|<
name|pathlen
condition|;
name|total
operator|++
operator|,
name|path
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|len
operator|>=
name|MAXNAMELEN
condition|)
block|{
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|dp
argument_list|,
name|DM_EVENT_SYMLINK
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_SYMLINK
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|link_name
argument_list|,
name|target_path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* Return through std_return after this point. */
name|udqp
operator|=
name|gdqp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|XXXKAN
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_PROJINHERIT
condition|)
name|prid
operator|=
name|dp
operator|->
name|i_d
operator|.
name|di_projid
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|XFS_AT_PROJID
condition|)
name|prid
operator|=
operator|(
name|xfs_prid_t
operator|)
name|vap
operator|->
name|va_projid
expr_stmt|;
else|else
endif|#
directive|endif
name|prid
operator|=
operator|(
name|xfs_prid_t
operator|)
name|dfltprid
expr_stmt|;
comment|/* 	 * Make sure that we have allocated dquot(s) on disk. 	 */
name|error
operator|=
name|XFS_QM_DQVOPALLOC
argument_list|(
name|mp
argument_list|,
name|dp
argument_list|,
name|current
operator|->
name|td_ucred
operator|->
name|cr_uid
argument_list|,
name|current
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|,
name|prid
argument_list|,
name|XFS_QMOPT_QUOTALL
operator||
name|XFS_QMOPT_INHERIT
argument_list|,
operator|&
name|udqp
argument_list|,
operator|&
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|std_return
goto|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SYMLINK
argument_list|)
expr_stmt|;
name|cancel_flags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
comment|/* 	 * The symlink will fit into the inode data fork? 	 * There can't be any attributes so we get the whole variable part. 	 */
if|if
condition|(
name|pathlen
operator|<=
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
condition|)
name|fs_blocks
operator|=
literal|0
expr_stmt|;
else|else
name|fs_blocks
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|resblks
operator|=
name|XFS_SYMLINK_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|link_namelen
argument_list|,
name|fs_blocks
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_SYMLINK_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_SYMLINK_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|&&
name|fs_blocks
operator|==
literal|0
condition|)
block|{
name|resblks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_SYMLINK_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_SYMLINK_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|cancel_flags
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Check whether the directory allows new symlinks or not. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_NOSYMLINKS
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* 	 * Reserve disk quota : blocks and inode. 	 */
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|,
name|resblks
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_return
goto|;
comment|/* 	 * Check for ability to enter directory entry, if no space reserved. 	 */
if|if
condition|(
name|resblks
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|XFS_DIR_CANENTER
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|link_name
argument_list|,
name|link_namelen
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* 	 * Initialize the bmap freelist prior to calling either 	 * bmapi or the directory create code. 	 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate an inode for the symlink. 	 */
name|error
operator|=
name|xfs_dir_ialloc
argument_list|(
operator|&
name|tp
argument_list|,
name|dp
argument_list|,
name|S_IFLNK
operator||
operator|(
name|vap
operator|->
name|va_mode
operator|&
operator|~
name|S_IFMT
operator|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|credp
argument_list|,
name|prid
argument_list|,
name|resblks
operator|>
literal|0
argument_list|,
operator|&
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
goto|goto
name|error_return
goto|;
goto|goto
name|error1
goto|;
block|}
name|ITRACE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|dir_vp
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|dp_joined_to_trans
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Also attach the dquot(s) to it, if applicable. 	 */
name|XFS_QM_DQVOPCREATE
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|udqp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|resblks
condition|)
name|resblks
operator|-=
name|XFS_IALLOC_SPACE_RES
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * If the symlink will fit into the inode, write it inline. 	 */
if|if
condition|(
name|pathlen
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|xfs_idata_realloc
argument_list|(
name|ip
argument_list|,
name|pathlen
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
argument_list|,
name|target_path
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|pathlen
expr_stmt|;
comment|/* 		 * The inode was initially created in extent format. 		 */
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|XFS_IFEXTENTS
operator||
name|XFS_IFBROOT
operator|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator||=
name|XFS_IFINLINE
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|XFS_DINODE_FMT_LOCAL
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_DDATA
operator||
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_fsb
operator|=
literal|0
expr_stmt|;
name|nmaps
operator|=
name|SYMLINK_MAPS
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|first_fsb
argument_list|,
name|fs_blocks
argument_list|,
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_METADATA
argument_list|,
operator|&
name|first_block
argument_list|,
name|resblks
argument_list|,
name|mval
argument_list|,
operator|&
name|nmaps
argument_list|,
operator|&
name|free_list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error1
goto|;
block|}
if|if
condition|(
name|resblks
condition|)
name|resblks
operator|-=
name|fs_blocks
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|pathlen
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|cur_chunk
operator|=
name|target_path
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nmaps
condition|;
name|n
operator|++
control|)
block|{
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|mval
index|[
name|n
index|]
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|byte_cnt
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|mval
index|[
name|n
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|BTOBB
argument_list|(
name|byte_cnt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|&&
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathlen
operator|<
name|byte_cnt
condition|)
block|{
name|byte_cnt
operator|=
name|pathlen
expr_stmt|;
block|}
name|pathlen
operator|-=
name|byte_cnt
expr_stmt|;
name|memcpy
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|cur_chunk
argument_list|,
name|byte_cnt
argument_list|)
expr_stmt|;
name|cur_chunk
operator|+=
name|byte_cnt
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|byte_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Create the directory entry for the symlink. 	 */
name|error
operator|=
name|XFS_DIR_CREATENAME
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|dp
argument_list|,
name|link_name
argument_list|,
name|link_namelen
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|,
operator|&
name|first_block
argument_list|,
operator|&
name|free_list
argument_list|,
name|resblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error1
goto|;
block|}
name|xfs_ichgtime
argument_list|(
name|dp
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
comment|/* 	 * Bump the in memory version number of the parent directory 	 * so that other processes accessing it will recognize that 	 * the directory has changed. 	 */
name|dp
operator|->
name|i_gen
operator|++
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * symlink transaction goes to disk before returning to 	 * the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
operator|(
name|XFS_MOUNT_WSYNC
operator||
name|XFS_MOUNT_DIRSYNC
operator|)
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * xfs_trans_commit normally decrements the vnode ref count 	 * when it unlocks the inode. Since we want to return the 	 * vnode to the caller, we bump the vnode ref count now. 	 */
name|IHOLD
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error2
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
comment|/* Fall through to std_return with error = 0 or errno from 	 * xfs_trans_commit	*/
name|std_return
label|:
if|if
condition|(
name|DM_EVENT_ENABLED
argument_list|(
name|dir_vp
operator|->
name|v_vfsp
argument_list|,
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
argument_list|,
name|DM_EVENT_POSTSYMLINK
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_POSTSYMLINK
argument_list|,
name|dir_vp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|error
condition|?
name|NULL
else|:
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|link_name
argument_list|,
name|target_path
argument_list|,
literal|0
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
return|return
name|error
return|;
name|error2
label|:
name|IRELE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error1
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|cancel_flags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
name|error_return
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancel_flags
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|udqp
argument_list|)
expr_stmt|;
name|XFS_QM_DQRELE
argument_list|(
name|mp
argument_list|,
name|gdqp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp_joined_to_trans
operator|&&
operator|(
name|dp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
goto|goto
name|std_return
goto|;
block|}
end_function

begin_comment
comment|/*  * xfs_fid2  *  * A fid routine that takes a pointer to a previously allocated  * fid structure (like xfs_fast_fid) but uses a 64 bit inode number.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_fid2
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_fid2_t
modifier|*
name|xfid
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_fid_t
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|xfs_fid2_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfid
operator|=
operator|(
name|xfs_fid2_t
operator|*
operator|)
name|fidp
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|xfid
operator|->
name|fid_len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_fid2_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfid
operator|->
name|fid_len
argument_list|)
expr_stmt|;
name|xfid
operator|->
name|fid_pad
operator|=
literal|0
expr_stmt|;
comment|/* 	 * use memcpy because the inode is a long long and there's no 	 * assurance that xfid->fid_ino is properly aligned. 	 */
name|memcpy
argument_list|(
operator|&
name|xfid
operator|->
name|fid_ino
argument_list|,
operator|&
name|ip
operator|->
name|i_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|xfid
operator|->
name|fid_ino
argument_list|)
argument_list|)
expr_stmt|;
name|xfid
operator|->
name|fid_gen
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gen
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_rwlock  */
end_comment

begin_function
name|int
name|xfs_rwlock
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|vrwlock_t
name|locktype
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VN_ISDIR
argument_list|(
name|vp
argument_list|)
condition|)
return|return
literal|1
return|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|locktype
operator|==
name|VRWLOCK_WRITE
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locktype
operator|==
name|VRWLOCK_TRY_READ
condition|)
block|{
return|return
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_SHARED
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|locktype
operator|==
name|VRWLOCK_TRY_WRITE
condition|)
block|{
return|return
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
return|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|(
name|locktype
operator|==
name|VRWLOCK_READ
operator|)
operator|||
operator|(
name|locktype
operator|==
name|VRWLOCK_WRITE_DIRECT
operator|)
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_SHARED
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_rwunlock  */
end_comment

begin_function
name|void
name|xfs_rwunlock
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|vrwlock_t
name|locktype
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VN_ISDIR
argument_list|(
name|vp
argument_list|)
condition|)
return|return;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|locktype
operator|==
name|VRWLOCK_WRITE
condition|)
block|{
comment|/* 		 * In the write case, we may have added a new entry to 		 * the reference cache.  This might store a pointer to 		 * an inode to be released in this inode.  If it is there, 		 * clear the pointer and release the inode after unlocking 		 * this one. 		 */
name|xfs_refcache_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|(
name|locktype
operator|==
name|VRWLOCK_READ
operator|)
operator|||
operator|(
name|locktype
operator|==
name|VRWLOCK_WRITE_DIRECT
operator|)
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_SHARED
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_inode_flush
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/* 	 * Bypass inodes which have already been cleaned by 	 * the inode flush clustering code inside xfs_iflush 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|iip
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|iip
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|FLUSH_LOG
condition|)
block|{
if|if
condition|(
name|iip
operator|&&
name|iip
operator|->
name|ili_last_lsn
condition|)
block|{
name|xlog_t
modifier|*
name|log
init|=
name|mp
operator|->
name|m_log
decl_stmt|;
name|xfs_lsn_t
name|sync_lsn
decl_stmt|;
name|int
name|s
decl_stmt|,
name|log_flags
init|=
name|XFS_LOG_FORCE
decl_stmt|;
name|s
operator|=
name|GRANT_LOCK
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|sync_lsn
operator|=
name|log
operator|->
name|l_last_sync_lsn
expr_stmt|;
name|GRANT_UNLOCK
argument_list|(
name|log
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XFS_LSN_CMP
argument_list|(
name|iip
operator|->
name|ili_last_lsn
argument_list|,
name|sync_lsn
argument_list|)
operator|<=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|FLUSH_SYNC
condition|)
name|log_flags
operator||=
name|XFS_LOG_SYNC
expr_stmt|;
return|return
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
name|iip
operator|->
name|ili_last_lsn
argument_list|,
name|log_flags
argument_list|)
return|;
block|}
block|}
comment|/* 	 * We make this non-blocking if the inode is contended, 	 * return EAGAIN to indicate to the caller that they 	 * did not succeed. This prevents the flush path from 	 * blocking on inodes inside another operation right 	 * now, they get caught later by xfs_sync. 	 */
if|if
condition|(
name|flags
operator|&
name|FLUSH_INODE
condition|)
block|{
name|int
name|flush_flags
decl_stmt|;
if|if
condition|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
condition|)
return|return
name|EAGAIN
return|;
if|if
condition|(
name|flags
operator|&
name|FLUSH_SYNC
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|xfs_iflock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
condition|)
block|{
if|if
condition|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
operator|||
operator|!
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
block|}
block|}
else|else
block|{
return|return
name|EAGAIN
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FLUSH_SYNC
condition|)
name|flush_flags
operator|=
name|XFS_IFLUSH_SYNC
expr_stmt|;
else|else
name|flush_flags
operator|=
name|XFS_IFLUSH_ASYNC
expr_stmt|;
name|error
operator|=
name|xfs_iflush
argument_list|(
name|ip
argument_list|,
name|flush_flags
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|xfs_set_dmattrs
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|u_int
name|evmask
parameter_list|,
name|u_int16_t
name|state
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SET_DMATTRS
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ICHANGE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_iocore
operator|.
name|io_dmevmask
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_dmevmask
operator|=
name|evmask
expr_stmt|;
name|ip
operator|->
name|i_iocore
operator|.
name|io_dmstate
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_dmstate
operator|=
name|state
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|IHOLD
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_reclaim  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_reclaim
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|VN_MAPPED
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bad inode, get out here ASAP */
if|if
condition|(
name|VN_BAD
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|xfs_ireclaim
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vn_iowait
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
operator|||
name|ip
operator|->
name|i_delayed_blks
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the atime in the XFS inode is correct before freeing the 	 * Linux inode. 	 */
name|xfs_synchronize_atime
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vnode_destroy_vobject
argument_list|(
name|vp
operator|->
name|v_vnode
argument_list|)
expr_stmt|;
comment|/* If we have nothing to flush with this inode then complete the 	 * teardown now, otherwise break the link between the xfs inode 	 * and the linux inode and clean up the xfs inode later. This 	 * avoids flushing the inode to disk during the delete operation 	 * itself. 	 */
if|if
condition|(
operator|!
name|ip
operator|->
name|i_update_core
operator|&&
operator|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
operator|)
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iflock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|xfs_finish_reclaim
argument_list|(
name|ip
argument_list|,
literal|1
argument_list|,
name|XFS_IFLUSH_DELWRI_ELSE_SYNC
argument_list|)
return|;
block|}
else|else
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
comment|/* Protect sync from us */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_bhv_remove
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mp
operator|->
name|m_del_inodes
argument_list|,
name|ip
argument_list|,
name|i_reclaim
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flags
operator||=
name|XFS_IRECLAIMABLE
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xfs_finish_reclaim
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|locked
parameter_list|,
name|int
name|sync_mode
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
init|=
name|ip
operator|->
name|i_hash
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|&&
name|VN_BAD
argument_list|(
name|vp
argument_list|)
condition|)
goto|goto
name|reclaim
goto|;
comment|/* The hash lock here protects a thread in xfs_iget_core from 	 * racing with us on linking the inode back with a vnode. 	 * Once we have the XFS_IRECLAIM flag set it will not touch 	 * us. 	 */
name|write_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_IRECLAIM
operator|)
operator|||
operator|(
operator|!
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_IRECLAIMABLE
operator|)
operator|&&
name|vp
operator|==
name|NULL
operator|)
condition|)
block|{
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|ip
operator|->
name|i_flags
operator||=
name|XFS_IRECLAIM
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the inode is still dirty, then flush it out.  If the inode 	 * is not in the AIL, then it will be OK to flush it delwri as 	 * long as xfs_iflush() does not keep any references to the inode. 	 * We leave that decision up to xfs_iflush() since it has the 	 * knowledge of whether it's OK to simply do a delwri flush of 	 * the inode or whether we need to wait until the inode is 	 * pulled from the AIL. 	 * We get the flush lock regardless, though, just to make sure 	 * we don't free it while it is being flushed. 	 */
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|locked
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iflock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_update_core
operator|||
operator|(
operator|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_iflush
argument_list|(
name|ip
argument_list|,
name|sync_mode
argument_list|)
expr_stmt|;
comment|/* 			 * If we hit an error, typically because of filesystem 			 * shutdown, we don't need to let vn_reclaim to know 			 * because we're gonna reclaim the inode anyway. 			 */
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
name|xfs_iflock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* synchronize with xfs_iflush_done */
block|}
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
operator|||
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked
condition|)
block|{
comment|/* 		 * We are not interested in doing an iflush if we're 		 * in the process of shutting down the filesystem forcibly. 		 * So, just reclaim the inode. 		 */
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
name|reclaim
label|:
name|xfs_ireclaim
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xfs_finish_reclaim_all
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|noblock
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RMC
name|int
name|purged
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|purged
operator|=
literal|0
expr_stmt|;
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|curr
argument_list|,
argument|&mp->m_del_inodes
argument_list|,
argument|i_reclaim
argument_list|,
argument|next
argument_list|)
block|{
name|ip
operator|=
name|curr
expr_stmt|;
if|if
condition|(
name|noblock
condition|)
block|{
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
operator|||
operator|!
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_finish_reclaim
argument_list|(
name|ip
argument_list|,
name|noblock
argument_list|,
name|XFS_IFLUSH_DELWRI_ELSE_ASYNC
argument_list|)
condition|)
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|purged
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|done
operator|=
operator|!
name|purged
expr_stmt|;
block|}
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_alloc_file_space()  *      This routine allocates disk space for the given file.  *  *	If alloc_type == 0, this request is for an ALLOCSP type  *	request which will change the file size.  In this case, no  *	DMAPI event will be generated by the call.  A TRUNCATE event  *	will be generated later by xfs_setattr.  *  *	If alloc_type != 0, this request is for a RESVSP type  *	request, and a DMAPI DM_EVENT_WRITE will be generated if the  *	lower block boundary byte address is less than the file's  *	length.  *  * RETURNS:  *       0 on success  *      errno on error  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_alloc_file_space
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|xfs_off_t
name|len
parameter_list|,
name|int
name|alloc_type
parameter_list|,
name|int
name|attr_flags
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
name|xfs_off_t
name|count
decl_stmt|;
name|xfs_filblks_t
name|allocated_fsb
decl_stmt|;
name|xfs_filblks_t
name|allocatesize_fsb
decl_stmt|;
name|xfs_extlen_t
name|extsz
decl_stmt|,
name|temp
decl_stmt|;
name|xfs_fileoff_t
name|startoffset_fsb
decl_stmt|;
name|xfs_fsblock_t
name|firstfsb
decl_stmt|;
name|int
name|nimaps
decl_stmt|;
name|int
name|bmapi_flag
decl_stmt|;
name|int
name|quota_flag
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_bmbt_irec_t
name|imaps
index|[
literal|1
index|]
decl_stmt|,
modifier|*
name|imapp
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|uint
name|qblocks
decl_stmt|,
name|resblks
decl_stmt|,
name|resrtextents
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|rt
operator|=
name|XFS_IS_REALTIME_INODE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rt
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|extsz
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|)
condition|)
name|extsz
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
block|}
else|else
block|{
name|extsz
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|count
operator|=
name|len
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|imapp
operator|=
operator|&
name|imaps
index|[
literal|0
index|]
expr_stmt|;
name|nimaps
operator|=
literal|1
expr_stmt|;
name|bmapi_flag
operator|=
name|XFS_BMAPI_WRITE
operator||
operator|(
name|alloc_type
condition|?
name|XFS_BMAPI_PREALLOC
else|:
literal|0
operator|)
expr_stmt|;
name|startoffset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|allocatesize_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/*	Generate a DMAPI event if needed.	*/
if|if
condition|(
name|alloc_type
operator|!=
literal|0
operator|&&
name|offset
operator|<
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|&&
operator|(
name|attr_flags
operator|&
name|ATTR_DMI
operator|)
operator|==
literal|0
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_WRITE
argument_list|)
condition|)
block|{
name|xfs_off_t
name|end_dmi_offset
decl_stmt|;
name|end_dmi_offset
operator|=
name|offset
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|end_dmi_offset
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
condition|)
name|end_dmi_offset
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
name|error
operator|=
name|XFS_SEND_DATA
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_WRITE
argument_list|,
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|offset
argument_list|,
name|end_dmi_offset
operator|-
name|offset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * Allocate file space until done or until there is an error 	 */
name|retry
label|:
while|while
condition|(
name|allocatesize_fsb
operator|&&
operator|!
name|error
condition|)
block|{
name|xfs_fileoff_t
name|s
decl_stmt|,
name|e
decl_stmt|;
comment|/* 		 * Determine space reservations for data/realtime. 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|extsz
argument_list|)
condition|)
block|{
name|s
operator|=
name|startoffset_fsb
expr_stmt|;
name|do_div
argument_list|(
name|s
argument_list|,
name|extsz
argument_list|)
expr_stmt|;
name|s
operator|*=
name|extsz
expr_stmt|;
name|e
operator|=
name|startoffset_fsb
operator|+
name|allocatesize_fsb
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|do_mod
argument_list|(
name|startoffset_fsb
argument_list|,
name|extsz
argument_list|)
operator|)
condition|)
name|e
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|do_mod
argument_list|(
name|e
argument_list|,
name|extsz
argument_list|)
operator|)
condition|)
name|e
operator|+=
name|extsz
operator|-
name|temp
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|allocatesize_fsb
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|rt
argument_list|)
condition|)
block|{
name|resrtextents
operator|=
name|qblocks
operator|=
call|(
name|uint
call|)
argument_list|(
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
name|resrtextents
operator|/=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|resblks
operator|=
name|XFS_DIOSTRAT_SPACE_RES
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quota_flag
operator|=
name|XFS_QMOPT_RES_RTBLKS
expr_stmt|;
block|}
else|else
block|{
name|resrtextents
operator|=
literal|0
expr_stmt|;
name|resblks
operator|=
name|qblocks
operator|=
expr|\
name|XFS_DIOSTRAT_SPACE_RES
argument_list|(
name|mp
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|e
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|quota_flag
operator|=
name|XFS_QMOPT_RES_REGBLKS
expr_stmt|;
block|}
comment|/* 		 * Allocate and setup the transaction. 		 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_DIOSTRAT
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
name|resrtextents
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_WRITE_LOG_COUNT
argument_list|)
expr_stmt|;
comment|/* 		 * Check for running out of space 		 */
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Free the transaction structure. 			 */
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOSPC
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|qblocks
argument_list|,
literal|0
argument_list|,
name|quota_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error1
goto|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * Issue the xfs_bmapi() call to allocate the blocks 		 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|firstfsb
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BMAPI
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|startoffset_fsb
argument_list|,
name|allocatesize_fsb
argument_list|,
name|bmapi_flag
argument_list|,
operator|&
name|firstfsb
argument_list|,
literal|0
argument_list|,
name|imapp
argument_list|,
operator|&
name|nimaps
argument_list|,
operator|&
name|free_list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
comment|/* 		 * Complete the transaction 		 */
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|firstfsb
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
break|break;
block|}
name|allocated_fsb
operator|=
name|imapp
operator|->
name|br_blockcount
expr_stmt|;
if|if
condition|(
name|nimaps
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
break|break;
block|}
name|startoffset_fsb
operator|+=
name|allocated_fsb
expr_stmt|;
name|allocatesize_fsb
operator|-=
name|allocated_fsb
expr_stmt|;
block|}
name|dmapi_enospc_check
label|:
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|&&
operator|(
name|attr_flags
operator|&
name|ATTR_DMI
operator|)
operator|==
literal|0
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_NOSPACE
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_SEND_NAMESP
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_NOSPACE
argument_list|,
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Delay flag intentionally unused */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* Maybe DMAPI app. has made space */
comment|/* else fall through with error from XFS_SEND_DATA */
block|}
return|return
name|error
return|;
name|error0
label|:
comment|/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|XFS_TRANS_UNRESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|qblocks
argument_list|,
literal|0
argument_list|,
name|quota_flag
argument_list|)
expr_stmt|;
name|error1
label|:
comment|/* Just cancel transaction */
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
goto|goto
name|dmapi_enospc_check
goto|;
block|}
end_function

begin_comment
comment|/*  * Zero file bytes between startoff and endoff inclusive.  * The iolock is held exclusive and no blocks are buffered.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_zero_remaining_bytes
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_off_t
name|startoff
parameter_list|,
name|xfs_off_t
name|endoff
parameter_list|)
block|{
name|xfs_bmbt_irec_t
name|imap
decl_stmt|;
name|xfs_fileoff_t
name|offset_fsb
decl_stmt|;
name|xfs_off_t
name|lastoffset
decl_stmt|;
name|xfs_off_t
name|offset
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
name|int
name|nimap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|xfs_buf_get_noaddr
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
condition|?
name|mp
operator|->
name|m_rtdev_targp
else|:
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
name|startoff
init|;
name|offset
operator|<=
name|endoff
condition|;
name|offset
operator|=
name|lastoffset
operator|+
literal|1
control|)
block|{
name|offset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|nimap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|XFS_BMAPI
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|offset_fsb
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|nimap
operator|<
literal|1
condition|)
break|break;
name|ASSERT
argument_list|(
name|imap
operator|.
name|br_blockcount
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|imap
operator|.
name|br_startoff
operator|==
name|offset_fsb
argument_list|)
expr_stmt|;
name|lastoffset
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|imap
operator|.
name|br_startoff
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lastoffset
operator|>
name|endoff
condition|)
name|lastoffset
operator|=
name|endoff
expr_stmt|;
if|if
condition|(
name|imap
operator|.
name|br_startblock
operator|==
name|HOLESTARTBLOCK
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|imap
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|imap
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
condition|)
continue|continue;
name|XFS_BUF_UNDONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_READ
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
name|XFS_FSB_TO_DB
argument_list|(
name|ip
argument_list|,
name|imap
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_iowait
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_zero_remaining_bytes(read)"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
operator|+
operator|(
name|offset
operator|-
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|imap
operator|.
name|br_startoff
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|lastoffset
operator|-
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNREAD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_WRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_iowait
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_zero_remaining_bytes(write)"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|xfs_buf_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_free_file_space()  *      This routine frees disk space for the given file.  *  *	This routine is only called by xfs_change_file_space  *	for an UNRESVSP type call.  *  * RETURNS:  *       0 on success  *      errno on error  *  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_free_file_space
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|xfs_off_t
name|len
parameter_list|,
name|int
name|attr_flags
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|int
name|done
decl_stmt|;
name|xfs_off_t
name|end_dmi_offset
decl_stmt|;
name|xfs_fileoff_t
name|endoffset_fsb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_fsblock_t
name|firstfsb
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_off_t
name|ilen
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
decl_stmt|;
name|xfs_off_t
name|ioffset
decl_stmt|;
name|xfs_extlen_t
name|mod
init|=
literal|0
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|nimap
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
name|int
name|rounding
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|xfs_fileoff_t
name|startoffset_fsb
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|need_iolock
init|=
literal|1
decl_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
comment|/* if nothing being freed */
return|return
name|error
return|;
name|rt
operator|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
expr_stmt|;
name|startoffset_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|end_dmi_offset
operator|=
name|offset
operator|+
name|len
expr_stmt|;
name|endoffset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|end_dmi_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|&&
operator|(
name|attr_flags
operator|&
name|ATTR_DMI
operator|)
operator|==
literal|0
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_WRITE
argument_list|)
condition|)
block|{
if|if
condition|(
name|end_dmi_offset
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
condition|)
name|end_dmi_offset
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
name|error
operator|=
name|XFS_SEND_DATA
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_WRITE
argument_list|,
name|vp
argument_list|,
name|offset
argument_list|,
name|end_dmi_offset
operator|-
name|offset
argument_list|,
name|AT_DELAY_FLAG
argument_list|(
name|attr_flags
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|attr_flags
operator|&
name|ATTR_NOLOCK
condition|?
name|attr_flags
operator|&
name|ATTR_DMI
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_flags
operator|&
name|ATTR_NOLOCK
condition|)
name|need_iolock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_iolock
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|vn_iowait
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* wait for the completion of any pending DIOs */
block|}
name|rounding
operator|=
name|MAX
argument_list|(
call|(
name|__uint8_t
call|)
argument_list|(
literal|1
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
argument_list|)
argument_list|,
operator|(
name|__uint8_t
operator|)
name|NBPP
argument_list|)
expr_stmt|;
name|ilen
operator|=
name|len
operator|+
operator|(
name|offset
operator|&
operator|(
name|rounding
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ioffset
operator|=
name|offset
operator|&
operator|~
operator|(
name|rounding
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ilen
operator|&
operator|(
name|rounding
operator|-
literal|1
operator|)
condition|)
name|ilen
operator|=
operator|(
name|ilen
operator|+
name|rounding
operator|)
operator|&
operator|~
operator|(
name|rounding
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|VN_CACHED
argument_list|(
name|vp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfs_inval_cached_trace
argument_list|(
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|ioffset
argument_list|,
operator|-
literal|1
argument_list|,
name|ctooff
argument_list|(
name|offtoct
argument_list|(
name|ioffset
argument_list|)
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|XVOP_FLUSHINVAL_PAGES
argument_list|(
name|vp
argument_list|,
name|ctooff
argument_list|(
name|offtoct
argument_list|(
name|ioffset
argument_list|)
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF_LOCKED
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Need to zero the stuff we're not freeing, on disk. 	 * If its a realtime file& can't use unwritten extents then we 	 * actually need to zero the extent edges.  Otherwise xfs_bunmapi 	 * will take care of it for us. 	 */
if|if
condition|(
name|rt
operator|&&
operator|!
name|XFS_SB_VERSION_HASEXTFLGBIT
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|nimap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|XFS_BMAPI
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|startoffset_fsb
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_unlock_iolock
goto|;
name|ASSERT
argument_list|(
name|nimap
operator|==
literal|0
operator|||
name|nimap
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nimap
operator|&&
name|imap
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
condition|)
block|{
name|xfs_daddr_t
name|block
decl_stmt|;
name|ASSERT
argument_list|(
name|imap
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
argument_list|)
expr_stmt|;
name|block
operator|=
name|imap
operator|.
name|br_startblock
expr_stmt|;
name|mod
operator|=
name|do_div
argument_list|(
name|block
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
condition|)
name|startoffset_fsb
operator|+=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|-
name|mod
expr_stmt|;
block|}
name|nimap
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|XFS_BMAPI
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|endoffset_fsb
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_unlock_iolock
goto|;
name|ASSERT
argument_list|(
name|nimap
operator|==
literal|0
operator|||
name|nimap
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nimap
operator|&&
name|imap
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
condition|)
block|{
name|ASSERT
argument_list|(
name|imap
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
argument_list|)
expr_stmt|;
name|mod
operator|++
expr_stmt|;
if|if
condition|(
name|mod
operator|&&
operator|(
name|mod
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|)
condition|)
name|endoffset_fsb
operator|-=
name|mod
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|done
operator|=
operator|(
name|endoffset_fsb
operator|<=
name|startoffset_fsb
operator|)
operator|)
condition|)
comment|/* 		 * One contiguous piece to clear 		 */
name|error
operator|=
name|xfs_zero_remaining_bytes
argument_list|(
name|ip
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Some full blocks, possibly two pieces to clear 		 */
if|if
condition|(
name|offset
operator|<
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|startoffset_fsb
argument_list|)
condition|)
name|error
operator|=
name|xfs_zero_remaining_bytes
argument_list|(
name|ip
argument_list|,
name|offset
argument_list|,
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|startoffset_fsb
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|endoffset_fsb
argument_list|)
operator|<
name|offset
operator|+
name|len
condition|)
name|error
operator|=
name|xfs_zero_remaining_bytes
argument_list|(
name|ip
argument_list|,
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|endoffset_fsb
argument_list|)
argument_list|,
name|offset
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * free file space until done or until there is an error 	 */
name|resblks
operator|=
name|XFS_DIOSTRAT_SPACE_RES
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|error
operator|&&
operator|!
name|done
condition|)
block|{
comment|/* 		 * allocate and setup the transaction 		 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_DIOSTRAT
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_WRITE_LOG_COUNT
argument_list|)
expr_stmt|;
comment|/* 		 * check for running out of space 		 */
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Free the transaction structure. 			 */
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOSPC
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
operator|->
name|i_udquot
argument_list|,
name|ip
operator|->
name|i_gdquot
argument_list|,
name|resblks
argument_list|,
literal|0
argument_list|,
name|XFS_QMOPT_RES_REGBLKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error1
goto|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * issue the bunmapi() call to free the blocks 		 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|firstfsb
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUNMAPI
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|startoffset_fsb
argument_list|,
name|endoffset_fsb
operator|-
name|startoffset_fsb
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
operator|&
name|firstfsb
argument_list|,
operator|&
name|free_list
argument_list|,
name|NULL
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
comment|/* 		 * complete the transaction 		 */
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|firstfsb
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
name|out_unlock_iolock
label|:
if|if
condition|(
name|need_iolock
condition|)
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|error0
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|error1
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|need_iolock
condition|?
operator|(
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
operator|)
else|:
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_change_file_space()  *      This routine allocates or frees disk space for the given file.  *      The user specified parameters are checked for alignment and size  *      limitations.  *  * RETURNS:  *       0 on success  *      errno on error  *  */
end_comment

begin_function
name|int
name|xfs_change_file_space
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|xfs_flock64_t
modifier|*
name|bf
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|,
name|int
name|attr_flags
parameter_list|)
block|{
name|int
name|clrprealloc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_fsize_t
name|fsize
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|setprealloc
decl_stmt|;
name|xfs_off_t
name|startoffset
decl_stmt|;
name|xfs_off_t
name|llen
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * must be a regular file and have write permission 	 */
if|if
condition|(
operator|!
name|VN_ISREG
argument_list|(
name|vp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_iaccess
argument_list|(
name|ip
argument_list|,
name|S_IWUSR
argument_list|,
name|credp
argument_list|)
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bf
operator|->
name|l_whence
condition|)
block|{
case|case
literal|0
case|:
comment|/*SEEK_SET*/
break|break;
case|case
literal|1
case|:
comment|/*SEEK_CUR*/
name|bf
operator|->
name|l_start
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*SEEK_END*/
name|bf
operator|->
name|l_start
operator|+=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
break|break;
default|default:
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|llen
operator|=
name|bf
operator|->
name|l_len
operator|>
literal|0
condition|?
name|bf
operator|->
name|l_len
operator|-
literal|1
else|:
name|bf
operator|->
name|l_len
expr_stmt|;
if|if
condition|(
operator|(
name|bf
operator|->
name|l_start
operator|<
literal|0
operator|)
operator|||
operator|(
name|bf
operator|->
name|l_start
operator|>
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
operator|)
operator|||
operator|(
name|bf
operator|->
name|l_start
operator|+
name|llen
operator|<
literal|0
operator|)
operator|||
operator|(
name|bf
operator|->
name|l_start
operator|+
name|llen
operator|>
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|bf
operator|->
name|l_whence
operator|=
literal|0
expr_stmt|;
name|startoffset
operator|=
name|bf
operator|->
name|l_start
expr_stmt|;
name|fsize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
comment|/* 	 * XFS_IOC_RESVSP and XFS_IOC_UNRESVSP will reserve or unreserve 	 * file space. 	 * These calls do NOT zero the data space allocated to the file, 	 * nor do they change the file size. 	 * 	 * XFS_IOC_ALLOCSP and XFS_IOC_FREESP will allocate and free file 	 * space. 	 * These calls cause the new file data to be zeroed and the file 	 * size to be changed. 	 */
name|setprealloc
operator|=
name|clrprealloc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|XFS_IOC_RESVSP
case|:
case|case
name|XFS_IOC_RESVSP64
case|:
name|error
operator|=
name|xfs_alloc_file_space
argument_list|(
name|ip
argument_list|,
name|startoffset
argument_list|,
name|bf
operator|->
name|l_len
argument_list|,
literal|1
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|setprealloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XFS_IOC_UNRESVSP
case|:
case|case
name|XFS_IOC_UNRESVSP64
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_free_file_space
argument_list|(
name|ip
argument_list|,
name|startoffset
argument_list|,
name|bf
operator|->
name|l_len
argument_list|,
name|attr_flags
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
break|break;
case|case
name|XFS_IOC_ALLOCSP
case|:
case|case
name|XFS_IOC_ALLOCSP64
case|:
case|case
name|XFS_IOC_FREESP
case|:
case|case
name|XFS_IOC_FREESP64
case|:
if|if
condition|(
name|startoffset
operator|>
name|fsize
condition|)
block|{
name|error
operator|=
name|xfs_alloc_file_space
argument_list|(
name|ip
argument_list|,
name|fsize
argument_list|,
name|startoffset
operator|-
name|fsize
argument_list|,
literal|0
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_SIZE
expr_stmt|;
name|va
operator|.
name|va_size
operator|=
name|startoffset
expr_stmt|;
name|error
operator|=
name|xfs_setattr
argument_list|(
name|bdp
argument_list|,
operator|&
name|va
argument_list|,
name|attr_flags
argument_list|,
name|credp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|clrprealloc
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * update the inode timestamp, mode, and prealloc flag bits 	 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_WRITEID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_WRITEID_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* ASSERT(0); */
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attr_flags
operator|&
name|ATTR_DMI
operator|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
comment|/* 		 * Note that we don't have to worry about mandatory 		 * file locking being disabled here because we only 		 * clear the S_ISGID bit if the Group execute bit is 		 * on, but if it was on then mandatory locking wouldn't 		 * have been enabled. 		 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IXGRP
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setprealloc
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator||=
name|XFS_DIFLAG_PREALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|clrprealloc
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&=
operator|~
name|XFS_DIFLAG_PREALLOC
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
name|xfs_vnodeops_t
name|xfs_vnodeops
init|=
block|{
name|BHV_IDENTITY_INIT
argument_list|(
name|VN_BHV_XFS
argument_list|,
name|VNODE_POSITION_XFS
argument_list|)
block|,
operator|.
name|vop_open
operator|=
name|xfs_open
block|,
operator|.
name|vop_read
operator|=
name|xfs_read
block|,
ifdef|#
directive|ifdef
name|HAVE_SENDFILE
operator|.
name|vop_sendfile
operator|=
name|xfs_sendfile
block|,
endif|#
directive|endif
operator|.
name|vop_write
operator|=
name|xfs_write
block|,
operator|.
name|vop_ioctl
operator|=
name|xfs_ioctl
block|,
operator|.
name|vop_getattr
operator|=
name|xfs_getattr
block|,
operator|.
name|vop_setattr
operator|=
name|xfs_setattr
block|,
operator|.
name|vop_access
operator|=
name|xfs_access
block|,
operator|.
name|vop_lookup
operator|=
name|xfs_lookup
block|,
operator|.
name|vop_create
operator|=
name|xfs_create
block|,
operator|.
name|vop_remove
operator|=
name|xfs_remove
block|,
operator|.
name|vop_link
operator|=
name|xfs_link
block|,
operator|.
name|vop_rename
operator|=
name|xfs_rename
block|,
operator|.
name|vop_mkdir
operator|=
name|xfs_mkdir
block|,
operator|.
name|vop_rmdir
operator|=
name|xfs_rmdir
block|,
operator|.
name|vop_readdir
operator|=
name|xfs_readdir
block|,
operator|.
name|vop_symlink
operator|=
name|xfs_symlink
block|,
operator|.
name|vop_readlink
operator|=
name|xfs_readlink
block|,
operator|.
name|vop_fsync
operator|=
name|xfs_fsync
block|,
operator|.
name|vop_inactive
operator|=
name|xfs_inactive
block|,
operator|.
name|vop_fid2
operator|=
name|xfs_fid2
block|,
operator|.
name|vop_rwlock
operator|=
name|xfs_rwlock
block|,
operator|.
name|vop_rwunlock
operator|=
name|xfs_rwunlock
block|,
operator|.
name|vop_bmap
operator|=
name|xfs_bmap
block|,
operator|.
name|vop_reclaim
operator|=
name|xfs_reclaim
block|,
operator|.
name|vop_attr_get
operator|=
name|xfs_attr_get
block|,
operator|.
name|vop_attr_set
operator|=
name|xfs_attr_set
block|,
operator|.
name|vop_attr_remove
operator|=
name|xfs_attr_remove
block|,
operator|.
name|vop_attr_list
operator|=
name|xfs_attr_list
block|,
operator|.
name|vop_link_removed
operator|=
operator|(
name|xfs_vop_link_removed_t
operator|)
name|fs_noval
block|,
operator|.
name|vop_vnode_change
operator|=
operator|(
name|xfs_vop_vnode_change_t
operator|)
name|fs_noval
block|,
operator|.
name|vop_tosspages
operator|=
name|fs_tosspages
block|,
operator|.
name|vop_flushinval_pages
operator|=
name|fs_flushinval_pages
block|,
operator|.
name|vop_flush_pages
operator|=
name|fs_flush_pages
block|,
operator|.
name|vop_release
operator|=
name|xfs_release
block|,
operator|.
name|vop_iflush
operator|=
name|xfs_inode_flush
block|, }
decl_stmt|;
end_decl_stmt

end_unit

