begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_comment
comment|/*  * This file contains the implementation of the xfs_efi_log_item  * and xfs_efd_log_item items.  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_extfree_item.h"
end_include

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_efi_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_efd_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STATIC
name|void
name|xfs_efi_item_unlock
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_efi_item_abort
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_efd_item_abort
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This returns the number of iovecs needed to log the given efi item.  * We only need 1 iovec for an efi item.  It just logs the efi_log_format  * structure.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|uint
name|xfs_efi_item_size
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to fill in the vector of log iovecs for the  * given efi log item. We use only 1 iovec, and we point that  * at the efi_log_format structure embedded in the efi item.  * It is at this point that we assert that all of the extent  * slots in the efi item have been filled.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_format
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|xfs_log_iovec_t
modifier|*
name|log_vector
parameter_list|)
block|{
name|uint
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|efip
operator|->
name|efi_next_extent
operator|==
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
argument_list|)
expr_stmt|;
name|efip
operator|->
name|efi_format
operator|.
name|efi_type
operator|=
name|XFS_LI_EFI
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_format_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|efip
operator|->
name|efi_format
operator|.
name|efi_size
operator|=
literal|1
expr_stmt|;
name|log_vector
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|efip
operator|->
name|efi_format
operator|)
expr_stmt|;
name|log_vector
operator|->
name|i_len
operator|=
name|size
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_format_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pinning has no meaning for an efi item, so just return.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_pin
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * While EFIs cannot really be pinned, the unpin operation is the  * last place at which the EFI is manipulated during a transaction.  * Here we coordinate with xfs_efi_cancel() to determine who gets to  * free the EFI.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_unpin
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|int
name|stale
parameter_list|)
block|{
name|int
name|nexts
decl_stmt|;
name|int
name|size
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|efip
operator|->
name|efi_item
operator|.
name|li_mountp
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|efip
operator|->
name|efi_flags
operator|&
name|XFS_EFI_CANCELED
condition|)
block|{
comment|/* 		 * xfs_trans_delete_ail() drops the AIL lock. 		 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|efip
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|nexts
operator|=
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFI_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efip
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efi_zone
argument_list|,
name|efip
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|efip
operator|->
name|efi_flags
operator||=
name|XFS_EFI_COMMITTED
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * like unpin only we have to also clear the xaction descriptor  * pointing the log item if we free the item.  This routine duplicates  * unpin because efi_flags is protected by the AIL lock.  Freeing  * the descriptor and then calling unpin would force us to drop the AIL  * lock which would open up a race condition.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_unpin_remove
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|nexts
decl_stmt|;
name|int
name|size
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|efip
operator|->
name|efi_item
operator|.
name|li_mountp
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|efip
operator|->
name|efi_flags
operator|&
name|XFS_EFI_CANCELED
condition|)
block|{
comment|/* 		 * free the xaction descriptor pointing to this item 		 */
name|lidp
operator|=
name|xfs_trans_find_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|efip
argument_list|)
expr_stmt|;
name|xfs_trans_free_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
comment|/* 		 * pull the item off the AIL. 		 * xfs_trans_delete_ail() drops the AIL lock. 		 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|efip
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * now free the item itself 		 */
name|nexts
operator|=
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFI_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efip
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efi_zone
argument_list|,
name|efip
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|efip
operator|->
name|efi_flags
operator||=
name|XFS_EFI_COMMITTED
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Efi items have no locking or pushing.  However, since EFIs are  * pulled from the AIL when their corresponding EFDs are committed  * to disk, their situation is very similar to being pinned.  Return  * XFS_ITEM_PINNED so that the caller will eventually flush the log.  * This should help in getting the EFI out of the AIL.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|uint
name|xfs_efi_item_trylock
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
return|return
name|XFS_ITEM_PINNED
return|;
block|}
end_function

begin_comment
comment|/*  * Efi items have no locking, so just return.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_unlock
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
if|if
condition|(
name|efip
operator|->
name|efi_item
operator|.
name|li_flags
operator|&
name|XFS_LI_ABORTED
condition|)
name|xfs_efi_item_abort
argument_list|(
name|efip
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The EFI is logged only once and cannot be moved in the log, so  * simply return the lsn at which it's been logged.  The canceled  * flag is not paid any attention here.  Checking for that is delayed  * until the EFI is unpinned.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|xfs_lsn_t
name|xfs_efi_item_committed
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
return|return
name|lsn
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the transaction logging the EFI is aborted.  * Free up the EFI and return.  No need to clean up the slot for  * the item in the transaction.  That was done by the unpin code  * which is called prior to this routine in the abort/fs-shutdown path.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_abort
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
name|int
name|nexts
decl_stmt|;
name|int
name|size
decl_stmt|;
name|nexts
operator|=
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFI_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efip
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efi_zone
argument_list|,
name|efip
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * There isn't much you can do to push on an efi item.  It is simply  * stuck waiting for all of its corresponding efd items to be  * committed to disk.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_push
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * The EFI dependency tracking op doesn't do squat.  It can't because  * it doesn't know where the free extent is coming from.  The dependency  * tracking has to be handled by the "enclosing" metadata object.  For  * example, for inodes, the inode is locked throughout the extent freeing  * so the dependency should be recorded there.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_item_committing
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * This is the ops vector shared by all efi log items.  */
end_comment

begin_decl_stmt
name|struct
name|xfs_item_ops
name|xfs_efi_item_ops
init|=
block|{
operator|.
name|iop_size
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_size
block|,
operator|.
name|iop_format
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_log_iovec_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_format
block|,
operator|.
name|iop_pin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_pin
block|,
operator|.
name|iop_unpin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|xfs_efi_item_unpin
block|,
operator|.
name|iop_unpin_remove
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_unpin_remove
block|,
operator|.
name|iop_trylock
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_trylock
block|,
operator|.
name|iop_unlock
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_unlock
block|,
operator|.
name|iop_committed
operator|=
operator|(
name|xfs_lsn_t
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_efi_item_committed
block|,
operator|.
name|iop_push
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_push
block|,
operator|.
name|iop_abort
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efi_item_abort
block|,
operator|.
name|iop_pushbuf
operator|=
name|NULL
block|,
operator|.
name|iop_committing
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_efi_item_committing
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate and initialize an efi item with the given number of extents.  */
end_comment

begin_function
name|xfs_efi_log_item_t
modifier|*
name|xfs_efi_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|uint
name|nextents
parameter_list|)
block|{
name|xfs_efi_log_item_t
modifier|*
name|efip
decl_stmt|;
name|uint
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|nextents
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextents
operator|>
name|XFS_EFI_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
operator|+
operator|(
operator|(
name|nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|efip
operator|=
operator|(
name|xfs_efi_log_item_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|efip
operator|=
operator|(
name|xfs_efi_log_item_t
operator|*
operator|)
name|kmem_zone_zalloc
argument_list|(
name|xfs_efi_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|efip
operator|->
name|efi_item
operator|.
name|li_type
operator|=
name|XFS_LI_EFI
expr_stmt|;
name|efip
operator|->
name|efi_item
operator|.
name|li_ops
operator|=
operator|&
name|xfs_efi_item_ops
expr_stmt|;
name|efip
operator|->
name|efi_item
operator|.
name|li_mountp
operator|=
name|mp
expr_stmt|;
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
operator|=
name|nextents
expr_stmt|;
name|efip
operator|->
name|efi_format
operator|.
name|efi_id
operator|=
operator|(
name|__psint_t
operator|)
operator|(
name|void
operator|*
operator|)
name|efip
expr_stmt|;
return|return
operator|(
name|efip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called by the efd item code below to release references to  * the given efi item.  Each efd calls this with the number of  * extents that it has logged, and when the sum of these reaches  * the total number of extents logged by this efi item we can free  * the efi item.  *  * Freeing the efi item requires that we remove it from the AIL.  * We'll use the AIL lock to protect our counters as well as  * the removal from the AIL.  */
end_comment

begin_function
name|void
name|xfs_efi_release
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|uint
name|nextents
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|extents_left
decl_stmt|;
name|uint
name|size
decl_stmt|;
name|int
name|nexts
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|efip
operator|->
name|efi_item
operator|.
name|li_mountp
expr_stmt|;
name|ASSERT
argument_list|(
name|efip
operator|->
name|efi_next_extent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|efip
operator|->
name|efi_flags
operator|&
name|XFS_EFI_COMMITTED
argument_list|)
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|efip
operator|->
name|efi_next_extent
operator|>=
name|nextents
argument_list|)
expr_stmt|;
name|efip
operator|->
name|efi_next_extent
operator|-=
name|nextents
expr_stmt|;
name|extents_left
operator|=
name|efip
operator|->
name|efi_next_extent
expr_stmt|;
if|if
condition|(
name|extents_left
operator|==
literal|0
condition|)
block|{
comment|/* 		 * xfs_trans_delete_ail() drops the AIL lock. 		 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|efip
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extents_left
operator|==
literal|0
condition|)
block|{
name|nexts
operator|=
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFI_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efip
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efi_zone
argument_list|,
name|efip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This is called when the transaction that should be committing the  * EFD corresponding to the given EFI is aborted.  The committed and  * canceled flags are used to coordinate the freeing of the EFI and  * the references by the transaction that committed it.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_efi_cancel
parameter_list|(
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
name|int
name|nexts
decl_stmt|;
name|int
name|size
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|efip
operator|->
name|efi_item
operator|.
name|li_mountp
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|efip
operator|->
name|efi_flags
operator|&
name|XFS_EFI_COMMITTED
condition|)
block|{
comment|/* 		 * xfs_trans_delete_ail() drops the AIL lock. 		 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|efip
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|nexts
operator|=
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFI_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efip
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efi_zone
argument_list|,
name|efip
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|efip
operator|->
name|efi_flags
operator||=
name|XFS_EFI_CANCELED
expr_stmt|;
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * This returns the number of iovecs needed to log the given efd item.  * We only need 1 iovec for an efd item.  It just logs the efd_log_format  * structure.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|uint
name|xfs_efd_item_size
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to fill in the vector of log iovecs for the  * given efd log item. We use only 1 iovec, and we point that  * at the efd_log_format structure embedded in the efd item.  * It is at this point that we assert that all of the extent  * slots in the efd item have been filled.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_format
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|,
name|xfs_log_iovec_t
modifier|*
name|log_vector
parameter_list|)
block|{
name|uint
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|efdp
operator|->
name|efd_next_extent
operator|==
name|efdp
operator|->
name|efd_format
operator|.
name|efd_nextents
argument_list|)
expr_stmt|;
name|efdp
operator|->
name|efd_format
operator|.
name|efd_type
operator|=
name|XFS_LI_EFD
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efd_log_format_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|efdp
operator|->
name|efd_format
operator|.
name|efd_nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|efdp
operator|->
name|efd_format
operator|.
name|efd_size
operator|=
literal|1
expr_stmt|;
name|log_vector
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
operator|(
name|efdp
operator|->
name|efd_format
operator|)
expr_stmt|;
name|log_vector
operator|->
name|i_len
operator|=
name|size
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|xfs_efd_log_format_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pinning has no meaning for an efd item, so just return.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_pin
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * Since pinning has no meaning for an efd item, unpinning does  * not either.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_unpin
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|,
name|int
name|stale
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_unpin_remove
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * Efd items have no locking, so just return success.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|uint
name|xfs_efd_item_trylock
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|)
block|{
return|return
name|XFS_ITEM_LOCKED
return|;
block|}
end_function

begin_comment
comment|/*  * Efd items have no locking or pushing, so return failure  * so that the caller doesn't bother with us.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_unlock
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|)
block|{
if|if
condition|(
name|efdp
operator|->
name|efd_item
operator|.
name|li_flags
operator|&
name|XFS_LI_ABORTED
condition|)
name|xfs_efd_item_abort
argument_list|(
name|efdp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * When the efd item is committed to disk, all we need to do  * is delete our reference to our partner efi item and then  * free ourselves.  Since we're freeing ourselves we must  * return -1 to keep the transaction code from further referencing  * this item.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|xfs_lsn_t
name|xfs_efd_item_committed
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
name|uint
name|size
decl_stmt|;
name|int
name|nexts
decl_stmt|;
comment|/* 	 * If we got a log I/O error, it's always the case that the LR with the 	 * EFI got unpinned and freed before the EFD got aborted. 	 */
if|if
condition|(
operator|(
name|efdp
operator|->
name|efd_item
operator|.
name|li_flags
operator|&
name|XFS_LI_ABORTED
operator|)
operator|==
literal|0
condition|)
name|xfs_efi_release
argument_list|(
name|efdp
operator|->
name|efd_efip
argument_list|,
name|efdp
operator|->
name|efd_format
operator|.
name|efd_nextents
argument_list|)
expr_stmt|;
name|nexts
operator|=
name|efdp
operator|->
name|efd_format
operator|.
name|efd_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFD_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efd_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efdp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efd_zone
argument_list|,
name|efdp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|xfs_lsn_t
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The transaction of which this EFD is a part has been aborted.  * Inform its companion EFI of this fact and then clean up after  * ourselves.  No need to clean up the slot for the item in the  * transaction.  That was done by the unpin code which is called  * prior to this routine in the abort/fs-shutdown path.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_abort
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|)
block|{
name|int
name|nexts
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* 	 * If we got a log I/O error, it's always the case that the LR with the 	 * EFI got unpinned and freed before the EFD got aborted. So don't 	 * reference the EFI at all in that case. 	 */
if|if
condition|(
operator|(
name|efdp
operator|->
name|efd_item
operator|.
name|li_flags
operator|&
name|XFS_LI_ABORTED
operator|)
operator|==
literal|0
condition|)
name|xfs_efi_cancel
argument_list|(
name|efdp
operator|->
name|efd_efip
argument_list|)
expr_stmt|;
name|nexts
operator|=
name|efdp
operator|->
name|efd_format
operator|.
name|efd_nextents
expr_stmt|;
if|if
condition|(
name|nexts
operator|>
name|XFS_EFD_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|xfs_efd_log_item_t
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
name|nexts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|efdp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_zone_free
argument_list|(
name|xfs_efd_zone
argument_list|,
name|efdp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * There isn't much you can do to push on an efd item.  It is simply  * stuck waiting for the log to be flushed to disk.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_push
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efdp
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * The EFD dependency tracking op doesn't do squat.  It can't because  * it doesn't know where the free extent is coming from.  The dependency  * tracking has to be handled by the "enclosing" metadata object.  For  * example, for inodes, the inode is locked throughout the extent freeing  * so the dependency should be recorded there.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xfs_efd_item_committing
parameter_list|(
name|xfs_efd_log_item_t
modifier|*
name|efip
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * This is the ops vector shared by all efd log items.  */
end_comment

begin_decl_stmt
name|struct
name|xfs_item_ops
name|xfs_efd_item_ops
init|=
block|{
operator|.
name|iop_size
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_size
block|,
operator|.
name|iop_format
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_log_iovec_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_format
block|,
operator|.
name|iop_pin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_pin
block|,
operator|.
name|iop_unpin
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|xfs_efd_item_unpin
block|,
operator|.
name|iop_unpin_remove
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_trans_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_unpin_remove
block|,
operator|.
name|iop_trylock
operator|=
operator|(
name|uint
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_trylock
block|,
operator|.
name|iop_unlock
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_unlock
block|,
operator|.
name|iop_committed
operator|=
operator|(
name|xfs_lsn_t
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_efd_item_committed
block|,
operator|.
name|iop_push
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_push
block|,
operator|.
name|iop_abort
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|)
operator|)
name|xfs_efd_item_abort
block|,
operator|.
name|iop_pushbuf
operator|=
name|NULL
block|,
operator|.
name|iop_committing
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|xfs_log_item_t
operator|*
argument_list|,
name|xfs_lsn_t
argument_list|)
operator|)
name|xfs_efd_item_committing
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate and initialize an efd item with the given number of extents.  */
end_comment

begin_function
name|xfs_efd_log_item_t
modifier|*
name|xfs_efd_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|,
name|uint
name|nextents
parameter_list|)
block|{
name|xfs_efd_log_item_t
modifier|*
name|efdp
decl_stmt|;
name|uint
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|nextents
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextents
operator|>
name|XFS_EFD_MAX_FAST_EXTENTS
condition|)
block|{
name|size
operator|=
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_efd_log_item_t
argument_list|)
operator|+
operator|(
operator|(
name|nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|efdp
operator|=
operator|(
name|xfs_efd_log_item_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|efdp
operator|=
operator|(
name|xfs_efd_log_item_t
operator|*
operator|)
name|kmem_zone_zalloc
argument_list|(
name|xfs_efd_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|efdp
operator|->
name|efd_item
operator|.
name|li_type
operator|=
name|XFS_LI_EFD
expr_stmt|;
name|efdp
operator|->
name|efd_item
operator|.
name|li_ops
operator|=
operator|&
name|xfs_efd_item_ops
expr_stmt|;
name|efdp
operator|->
name|efd_item
operator|.
name|li_mountp
operator|=
name|mp
expr_stmt|;
name|efdp
operator|->
name|efd_efip
operator|=
name|efip
expr_stmt|;
name|efdp
operator|->
name|efd_format
operator|.
name|efd_nextents
operator|=
name|nextents
expr_stmt|;
name|efdp
operator|->
name|efd_format
operator|.
name|efd_efi_id
operator|=
name|efip
operator|->
name|efi_format
operator|.
name|efi_id
expr_stmt|;
return|return
operator|(
name|efdp
operator|)
return|;
block|}
end_function

end_unit

