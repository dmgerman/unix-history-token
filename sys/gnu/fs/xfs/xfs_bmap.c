begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2006 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_extfree_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_check_leaf_extents
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_bmap_free_item_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for internal bmap routines.  */
end_comment

begin_comment
comment|/*  * Called from xfs_bmap_add_attrfork to handle extents format files.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_attrfork_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks to free at commit */
name|int
modifier|*
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* inode logging flags */
end_comment

begin_comment
comment|/*  * Called from xfs_bmap_add_attrfork to handle local format files.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_attrfork_local
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks to free at commit */
name|int
modifier|*
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* inode logging flags */
end_comment

begin_comment
comment|/*  * Called by xfs_bmapi to update file extent records and the btree  * after allocating space (or doing a delayed allocation).  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* if *curp is null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* pointer to firstblock variable */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents to be freed */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
name|rsvd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* OK to allocate reserved blocks */
end_comment

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting a delayed  * allocation to a real allocation.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_delay_real
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* if *curp is null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|xfs_filblks_t
modifier|*
name|dnew
parameter_list|,
comment|/* new delayed-alloc indirect blocks */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* pointer to firstblock variable */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents to be freed */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|rsvd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* OK to allocate reserved blocks */
end_comment

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting a hole  * to a delayed allocation.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_hole_delay
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* if null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|rsvd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* OK to allocate reserved blocks */
end_comment

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting a hole  * to a real allocation.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_hole_real
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* if null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting an unwritten  * allocation to a real allocation or vice versa.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_unwritten_real
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* if *curp is null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Change made to incore extents */
end_comment

begin_comment
comment|/*  * xfs_bmap_alloc is called by xfs_bmapi to allocate an extent for a file.  * It figures out where to ask the underlying allocator to put the new extent.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_alloc
parameter_list|(
name|xfs_bmalloca_t
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* bmap alloc argument struct */
end_comment

begin_comment
comment|/*  * Transform a btree format file with only one leaf node, where the  * extents list will fit in the inode, into an extents format file.  * Since the file extents are already in-core, all we have to do is  * give up the space for the btree root and pitch the leaf block.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_btree_to_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Check that the extents list for the inode ip is in the right order.  */
end_comment

begin_comment
unit|STATIC void xfs_bmap_check_extents( 	xfs_inode_t		*ip,
comment|/* incore inode pointer */
end_comment

begin_comment
unit|int			whichfork);
comment|/* data or attr fork */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called by xfs_bmapi to update file extent records and the btree  * after removing space (or undoing a delayed allocation).  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_del_extent
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* current trans pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents to be freed */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* if null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
name|rsvd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* OK to allocate reserved blocks */
end_comment

begin_comment
comment|/*  * Remove the entry "free" from the free item list.  Prev points to the  * previous entry, unless "free" is the head of the list.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_del_free
parameter_list|(
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* free item list header */
name|xfs_bmap_free_item_t
modifier|*
name|prev
parameter_list|,
comment|/* previous item on list, if any */
name|xfs_bmap_free_item_t
modifier|*
name|free
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* list item to be freed */
end_comment

begin_comment
comment|/*  * Convert an extents-format file into a btree-format file.  * The new file will have a root block (in the inode) and a single child block.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_extents_to_btree
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first-block-allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks freed in xaction */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* cursor returned to caller */
name|int
name|wasdel
parameter_list|,
comment|/* converting a delayed alloc */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Convert a local file to an extents file.  * This code is sort of bogus, since the file data needs to get  * logged so it won't be lost.  The bmap-level manipulations are ok, though.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_local_to_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated in xaction */
name|xfs_extlen_t
name|total
parameter_list|,
comment|/* total blocks needed by transaction */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Search the extents list for the inode, for the extent containing bno.  * If bno lies in a hole, point to the next entry.  If bno lies past eof,  * *eofp will be set, and *prevp will contain the last entry (null if none).  * Else, *lastxp will be set to the index of the found  * entry; *gotp will contain the entry.  */
end_comment

begin_function_decl
name|STATIC
name|xfs_bmbt_rec_t
modifier|*
comment|/* pointer to found extent entry */
name|xfs_bmap_search_extents
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fileoff_t
name|bno
parameter_list|,
comment|/* block number searched for */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
modifier|*
name|eofp
parameter_list|,
comment|/* out: end of file found */
name|xfs_extnum_t
modifier|*
name|lastxp
parameter_list|,
comment|/* out: last extent index */
name|xfs_bmbt_irec_t
modifier|*
name|gotp
parameter_list|,
comment|/* out: extent entry found */
name|xfs_bmbt_irec_t
modifier|*
name|prevp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* out: previous extent entry found */
end_comment

begin_comment
comment|/*  * Check the last inode extent to determine whether this allocation will result  * in blocks being allocated at the end of the file. When we allocate new data  * blocks at the end of the file which do not start at the previous data block,  * we will try to align the new blocks at stripe unit boundaries.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_isaeof
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fileoff_t
name|off
parameter_list|,
comment|/* file offset in fsblocks */
name|int
name|whichfork
parameter_list|,
comment|/* data or attribute fork */
name|char
modifier|*
name|aeof
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* return value */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
end_ifdef

begin_comment
comment|/*  * Add a bmap trace buffer entry.  Base routine for the others.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_trace_addentry
parameter_list|(
name|int
name|opcode
parameter_list|,
comment|/* operation */
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry(ies) */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries, 1 or 2 */
name|xfs_bmbt_rec_t
modifier|*
name|r1
parameter_list|,
comment|/* first record */
name|xfs_bmbt_rec_t
modifier|*
name|r2
parameter_list|,
comment|/* second record or null */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Add bmap trace entry prior to a call to xfs_iext_remove.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_trace_delete
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry(entries) deleted */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries deleted, 1 or 2 */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Add bmap trace entry prior to a call to xfs_iext_insert, or  * reading in the extents list from the disk (in the btree).  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_trace_insert
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry(entries) inserted */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries inserted, 1 or 2 */
name|xfs_bmbt_irec_t
modifier|*
name|r1
parameter_list|,
comment|/* inserted record 1 */
name|xfs_bmbt_irec_t
modifier|*
name|r2
parameter_list|,
comment|/* inserted record 2 or null */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Add bmap trace entry after updating an extent record in place.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_trace_post_update
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry updated */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_comment
comment|/*  * Add bmap trace entry prior to updating an extent record in place.  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_trace_pre_update
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry to be updated */
name|int
name|whichfork
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* data or attr fork */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_bmap_trace_delete
parameter_list|(
name|f
parameter_list|,
name|d
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|c
parameter_list|,
name|w
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xfs_bmap_trace_insert
parameter_list|(
name|f
parameter_list|,
name|d
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|c
parameter_list|,
name|r1
parameter_list|,
name|r2
parameter_list|,
name|w
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xfs_bmap_trace_post_update
parameter_list|(
name|f
parameter_list|,
name|d
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|w
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xfs_bmap_trace_pre_update
parameter_list|(
name|f
parameter_list|,
name|d
parameter_list|,
name|ip
parameter_list|,
name|i
parameter_list|,
name|w
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_BMAP_TRACE */
end_comment

begin_comment
comment|/*  * Compute the worst-case number of indirect blocks that will be used  * for ip's delayed extent of length "len".  */
end_comment

begin_function_decl
name|STATIC
name|xfs_filblks_t
name|xfs_bmap_worst_indlen
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_filblks_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* delayed extent length */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Perform various validation checks on the values being returned  * from xfs_bmapi().  */
end_comment

begin_function_decl
name|STATIC
name|void
name|xfs_bmap_validate_ret
parameter_list|(
name|xfs_fileoff_t
name|bno
parameter_list|,
name|xfs_filblks_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|mval
parameter_list|,
name|int
name|nmap
parameter_list|,
name|int
name|ret_nmap
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_bmap_validate_ret
parameter_list|(
name|bno
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|,
name|mval
parameter_list|,
name|onmap
parameter_list|,
name|nmap
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_RW_TRACE
argument_list|)
end_if

begin_function_decl
name|STATIC
name|void
name|xfs_bunmap_trace
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_fileoff_t
name|bno
parameter_list|,
name|xfs_filblks_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|inst_t
modifier|*
name|ra
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_bunmap_trace
parameter_list|(
name|ip
parameter_list|,
name|bno
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|,
name|ra
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_RW_TRACE */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_bmap_count_tree
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
name|xfs_fsblock_t
name|blockno
parameter_list|,
name|int
name|levelin
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_bmap_count_leaves
parameter_list|(
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
name|xfs_extnum_t
name|idx
parameter_list|,
name|int
name|numrecs
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_bmap_disk_count_leaves
parameter_list|(
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_extnum_t
name|idx
parameter_list|,
name|xfs_bmbt_block_t
modifier|*
name|block
parameter_list|,
name|int
name|numrecs
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Bmap internal routines.  */
end_comment

begin_comment
comment|/*  * Called from xfs_bmap_add_attrfork to handle btree format files.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_attrfork_btree
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks to free at commit */
name|int
modifier|*
name|flags
parameter_list|)
comment|/* inode logging flags */
block|{
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* btree cursor */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount struct */
name|int
name|stat
decl_stmt|;
comment|/* newroot status */
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
condition|)
operator|*
name|flags
operator||=
name|XFS_ILOG_DBROOT
expr_stmt|;
else|else
block|{
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|XFS_BTNUM_BMAP
argument_list|,
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_ge
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|stat
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|ASSERT
argument_list|(
name|stat
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* must be at least one entry */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_newroot
argument_list|(
name|cur
argument_list|,
name|flags
argument_list|,
operator|&
name|stat
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
operator|*
name|firstblock
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error0
label|:
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Called from xfs_bmap_add_attrfork to handle extents format files.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_attrfork_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks to free at commit */
name|int
modifier|*
name|flags
parameter_list|)
comment|/* inode logging flags */
block|{
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* bmap btree cursor */
name|int
name|error
decl_stmt|;
comment|/* error return value */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|*
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
condition|)
return|return
literal|0
return|;
name|cur
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_bmap_extents_to_btree
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|cur
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|error
condition|?
name|XFS_BTREE_ERROR
else|:
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Called from xfs_bmap_add_attrfork to handle local format files.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_attrfork_local
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks to free at commit */
name|int
modifier|*
name|flags
parameter_list|)
comment|/* inode logging flags */
block|{
name|xfs_da_args_t
name|dargs
decl_stmt|;
comment|/* args for dir/attr code */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure pointer */
if|if
condition|(
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dargs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dargs
argument_list|)
argument_list|)
expr_stmt|;
name|dargs
operator|.
name|dp
operator|=
name|ip
expr_stmt|;
name|dargs
operator|.
name|firstblock
operator|=
name|firstblock
expr_stmt|;
name|dargs
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|dargs
operator|.
name|total
operator|=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
name|dargs
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|dargs
operator|.
name|trans
operator|=
name|tp
expr_stmt|;
name|error
operator|=
name|XFS_DIR_SHORTFORM_TO_SINGLE
argument_list|(
name|mp
argument_list|,
operator|&
name|dargs
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|xfs_bmap_local_to_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|firstblock
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Called by xfs_bmapi to update file extent records and the btree  * after allocating space (or doing a delayed allocation).  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* if *curp is null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* pointer to firstblock variable */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents to be freed */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
name|rsvd
parameter_list|)
comment|/* OK to use reserved data blocks */
block|{
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* btree cursor or null */
name|xfs_filblks_t
name|da_new
decl_stmt|;
comment|/* new count del alloc blocks used */
name|xfs_filblks_t
name|da_old
decl_stmt|;
comment|/* old count del alloc blocks used */
name|int
name|error
decl_stmt|;
comment|/* error return value */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_add_extent"
decl_stmt|;
endif|#
directive|endif
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork ptr */
name|int
name|logflags
decl_stmt|;
comment|/* returned value */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of extents in file now */
name|XFS_STATS_INC
argument_list|(
name|xs_add_exlist
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|*
name|curp
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|idx
operator|<=
name|nextents
argument_list|)
expr_stmt|;
name|da_old
operator|=
name|da_new
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This is the first extent added to a new/empty file. 	 * Special case this one, so other routines get to assume there are 	 * already extents in the list. 	 */
if|if
condition|(
name|nextents
operator|==
literal|0
condition|)
block|{
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"insert empty"
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cur
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
condition|)
block|{
name|XFS_IFORK_NEXT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|logflags
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
block|}
else|else
name|logflags
operator|=
literal|0
expr_stmt|;
comment|/* DELTA: single new extent */
if|if
condition|(
name|delta
condition|)
block|{
if|if
condition|(
name|delta
operator|->
name|xed_startoff
operator|>
name|new
operator|->
name|br_startoff
condition|)
name|delta
operator|->
name|xed_startoff
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_blockcount
operator|<
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
condition|)
name|delta
operator|->
name|xed_blockcount
operator|=
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
expr_stmt|;
block|}
block|}
comment|/* 	 * Any kind of new delayed allocation goes here. 	 */
elseif|else
if|if
condition|(
name|ISNULLSTARTBLOCK
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur
condition|)
name|ASSERT
argument_list|(
operator|(
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|&
name|XFS_BTCUR_BPRV_WASDEL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_extent_hole_delay
argument_list|(
name|ip
argument_list|,
name|idx
argument_list|,
name|cur
argument_list|,
name|new
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Real allocation off the end of the file. 	 */
elseif|else
if|if
condition|(
name|idx
operator|==
name|nextents
condition|)
block|{
if|if
condition|(
name|cur
condition|)
name|ASSERT
argument_list|(
operator|(
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|&
name|XFS_BTCUR_BPRV_WASDEL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_extent_hole_real
argument_list|(
name|ip
argument_list|,
name|idx
argument_list|,
name|cur
argument_list|,
name|new
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|xfs_bmbt_irec_t
name|prev
decl_stmt|;
comment|/* old extent at offset idx */
comment|/* 		 * Get the record referred to by idx. 		 */
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
comment|/* 		 * If it's a real allocation record, and the new allocation ends 		 * after the start of the referred to record, then we're filling 		 * in a delayed or unwritten allocation with a real one, or 		 * converting real back to unwritten. 		 */
if|if
condition|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
operator|&&
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
operator|>
name|prev
operator|.
name|br_startoff
condition|)
block|{
if|if
condition|(
name|prev
operator|.
name|br_state
operator|!=
name|XFS_EXT_UNWRITTEN
operator|&&
name|ISNULLSTARTBLOCK
argument_list|(
name|prev
operator|.
name|br_startblock
argument_list|)
condition|)
block|{
name|da_old
operator|=
name|STARTBLOCKVAL
argument_list|(
name|prev
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|ASSERT
argument_list|(
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|&
name|XFS_BTCUR_BPRV_WASDEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_extent_delay_real
argument_list|(
name|ip
argument_list|,
name|idx
argument_list|,
operator|&
name|cur
argument_list|,
name|new
argument_list|,
operator|&
name|da_new
argument_list|,
name|first
argument_list|,
name|flist
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|new
operator|->
name|br_state
operator|==
name|XFS_EXT_NORM
condition|)
block|{
name|ASSERT
argument_list|(
name|new
operator|->
name|br_state
operator|==
name|XFS_EXT_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_extent_unwritten_real
argument_list|(
name|ip
argument_list|,
name|idx
argument_list|,
operator|&
name|cur
argument_list|,
name|new
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|new
operator|->
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_extent_unwritten_real
argument_list|(
name|ip
argument_list|,
name|idx
argument_list|,
operator|&
name|cur
argument_list|,
name|new
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
name|ASSERT
argument_list|(
operator|*
name|curp
operator|==
name|cur
operator|||
operator|*
name|curp
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Otherwise we're filling in a hole with an allocation. 		 */
else|else
block|{
if|if
condition|(
name|cur
condition|)
name|ASSERT
argument_list|(
operator|(
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|&
name|XFS_BTCUR_BPRV_WASDEL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_add_extent_hole_real
argument_list|(
name|ip
argument_list|,
name|idx
argument_list|,
name|cur
argument_list|,
name|new
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
block|}
name|ASSERT
argument_list|(
operator|*
name|curp
operator|==
name|cur
operator|||
operator|*
name|curp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Convert to a btree if necessary. 	 */
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|>
name|ifp
operator|->
name|if_ext_max
condition|)
block|{
name|int
name|tmp_logflags
decl_stmt|;
comment|/* partial log flag return val */
name|ASSERT
argument_list|(
name|cur
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_extents_to_btree
argument_list|(
name|ip
operator|->
name|i_transp
argument_list|,
name|ip
argument_list|,
name|first
argument_list|,
name|flist
argument_list|,
operator|&
name|cur
argument_list|,
name|da_old
operator|>
literal|0
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Adjust for changes in reserved delayed indirect blocks. 	 * Nothing to do for disk quotas here. 	 */
if|if
condition|(
name|da_old
operator|||
name|da_new
condition|)
block|{
name|xfs_filblks_t
name|nblks
decl_stmt|;
name|nblks
operator|=
name|da_new
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|nblks
operator|+=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
expr_stmt|;
name|ASSERT
argument_list|(
name|nblks
operator|<=
name|da_old
argument_list|)
expr_stmt|;
if|if
condition|(
name|nblks
operator|<
name|da_old
condition|)
name|xfs_mod_incore_sb
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
call|(
name|int
call|)
argument_list|(
name|da_old
operator|-
name|nblks
argument_list|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear out the allocated field, done with it now in any case. 	 */
if|if
condition|(
name|cur
condition|)
block|{
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
operator|*
name|curp
operator|=
name|cur
expr_stmt|;
block|}
name|done
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|error
condition|)
name|xfs_bmap_check_leaf_extents
argument_list|(
operator|*
name|curp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|logflagsp
operator|=
name|logflags
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting a delayed  * allocation to a real allocation.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_delay_real
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* if *curp is null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|xfs_filblks_t
modifier|*
name|dnew
parameter_list|,
comment|/* new delayed-alloc indirect blocks */
name|xfs_fsblock_t
modifier|*
name|first
parameter_list|,
comment|/* pointer to firstblock variable */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents to be freed */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|rsvd
parameter_list|)
comment|/* OK to use reserved data block allocation */
block|{
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* btree cursor */
name|int
name|diff
decl_stmt|;
comment|/* temp value */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent entry for idx */
name|int
name|error
decl_stmt|;
comment|/* error return value */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_add_extent_delay_real"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/* temp state */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_fileoff_t
name|new_endoff
decl_stmt|;
comment|/* end offset of new entry */
name|xfs_bmbt_irec_t
name|r
index|[
literal|3
index|]
decl_stmt|;
comment|/* neighbor extent entries */
comment|/* left is 0, right is 1, prev is 2 */
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* return value (logging flags) */
name|int
name|state
init|=
literal|0
decl_stmt|;
comment|/* state bits, accessed thru macros */
name|xfs_filblks_t
name|temp
init|=
literal|0
decl_stmt|;
comment|/* value for dnew calculations */
name|xfs_filblks_t
name|temp2
init|=
literal|0
decl_stmt|;
comment|/* value for dnew calculations */
name|int
name|tmp_rval
decl_stmt|;
comment|/* partial logging flags */
enum|enum
block|{
comment|/* bit number definitions for state */
name|LEFT_CONTIG
block|,
name|RIGHT_CONTIG
block|,
name|LEFT_FILLING
block|,
name|RIGHT_FILLING
block|,
name|LEFT_DELAY
block|,
name|RIGHT_DELAY
block|,
name|LEFT_VALID
block|,
name|RIGHT_VALID
block|}
enum|;
define|#
directive|define
name|LEFT
value|r[0]
define|#
directive|define
name|RIGHT
value|r[1]
define|#
directive|define
name|PREV
value|r[2]
define|#
directive|define
name|MASK
parameter_list|(
name|b
parameter_list|)
value|(1<< (b))
define|#
directive|define
name|MASK2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(MASK(a) | MASK(b))
define|#
directive|define
name|MASK3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(MASK2(a,b) | MASK(c))
define|#
directive|define
name|MASK4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(MASK3(a,b,c) | MASK(d))
define|#
directive|define
name|STATE_SET
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? (state |= MASK(b)) : (state&= ~MASK(b)))
define|#
directive|define
name|STATE_TEST
parameter_list|(
name|b
parameter_list|)
value|(state& MASK(b))
define|#
directive|define
name|STATE_SET_TEST
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? ((state |= MASK(b)), 1) : \ 				       ((state&= ~MASK(b)), 0))
define|#
directive|define
name|SWITCH_STATE
define|\
value|(state& MASK4(LEFT_FILLING, RIGHT_FILLING, LEFT_CONTIG, RIGHT_CONTIG))
comment|/* 	 * Set up a bunch of variables to make the tests simpler. 	 */
name|cur
operator|=
operator|*
name|curp
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|PREV
argument_list|)
expr_stmt|;
name|new_endoff
operator|=
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|ASSERT
argument_list|(
name|PREV
operator|.
name|br_startoff
operator|<=
name|new
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|PREV
operator|.
name|br_startoff
operator|+
name|PREV
operator|.
name|br_blockcount
operator|>=
name|new_endoff
argument_list|)
expr_stmt|;
comment|/* 	 * Set flags determining what part of the previous delayed allocation 	 * extent is being replaced by a real allocation. 	 */
name|STATE_SET
argument_list|(
name|LEFT_FILLING
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|==
name|new
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|+
name|PREV
operator|.
name|br_blockcount
operator|==
name|new_endoff
argument_list|)
expr_stmt|;
comment|/* 	 * Check and set flags if this segment has a left neighbor. 	 * Don't set contiguous if the combined extent would be too large. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|LEFT_VALID
argument_list|,
name|idx
operator|>
literal|0
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
operator|&
name|LEFT
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|LEFT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|LEFT
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STATE_SET
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|LEFT_VALID
argument_list|)
operator|&&
operator|!
name|STATE_TEST
argument_list|(
name|LEFT_DELAY
argument_list|)
operator|&&
name|LEFT
operator|.
name|br_startoff
operator|+
name|LEFT
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startoff
operator|&&
name|LEFT
operator|.
name|br_startblock
operator|+
name|LEFT
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startblock
operator|&&
name|LEFT
operator|.
name|br_state
operator|==
name|new
operator|->
name|br_state
operator|&&
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|<=
name|MAXEXTLEN
argument_list|)
expr_stmt|;
comment|/* 	 * Check and set flags if this segment has a right neighbor. 	 * Don't set contiguous if the combined extent would be too large. 	 * Also check for all-three-contiguous being too large. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|RIGHT_VALID
argument_list|,
name|idx
operator|<
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|RIGHT
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|RIGHT
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STATE_SET
argument_list|(
name|RIGHT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|RIGHT_VALID
argument_list|)
operator|&&
operator|!
name|STATE_TEST
argument_list|(
name|RIGHT_DELAY
argument_list|)
operator|&&
name|new_endoff
operator|==
name|RIGHT
operator|.
name|br_startoff
operator|&&
name|new
operator|->
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
operator|==
name|RIGHT
operator|.
name|br_startblock
operator|&&
name|new
operator|->
name|br_state
operator|==
name|RIGHT
operator|.
name|br_state
operator|&&
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|&&
operator|(
operator|(
name|state
operator|&
name|MASK3
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|)
operator|)
operator|!=
name|MASK3
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|)
operator|||
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Switch out based on the FILLING and CONTIG state bits. 	 */
switch|switch
condition|(
name|SWITCH_STATE
condition|)
block|{
case|case
name|MASK4
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * Filling in all of a previously delayed allocation extent. 		 * The left and right neighbors are both contiguous with new. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|2
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|--
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|RIGHT
operator|.
name|br_startoff
argument_list|,
name|RIGHT
operator|.
name|br_startblock
argument_list|,
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|LEFT
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
operator|*
name|dnew
operator|=
literal|0
expr_stmt|;
comment|/* DELTA: Three in-core extents are replaced by one. */
name|temp
operator|=
name|LEFT
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK3
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|)
case|:
comment|/* 		 * Filling in all of a previously delayed allocation extent. 		 * The left neighbor is contiguous, the right is not. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
argument_list|,
name|LEFT
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
operator|*
name|dnew
operator|=
literal|0
expr_stmt|;
comment|/* DELTA: Two in-core extents are replaced by one. */
name|temp
operator|=
name|LEFT
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK3
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * Filling in all of a previously delayed allocation extent. 		 * The right neighbor is contiguous, the left is not. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|RIGHT
operator|.
name|br_startoff
argument_list|,
name|RIGHT
operator|.
name|br_startblock
argument_list|,
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|PREV
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
operator|*
name|dnew
operator|=
literal|0
expr_stmt|;
comment|/* DELTA: Two in-core extents are replaced by one. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK2
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|)
case|:
comment|/* 		 * Filling in all of a previously delayed allocation extent. 		 * Neither the left nor right neighbors are contiguous with 		 * the new one. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|.
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|dnew
operator|=
literal|0
expr_stmt|;
comment|/* DELTA: The in-core extent described by new changed type. */
name|temp
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|new
operator|->
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK2
argument_list|(
name|LEFT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|)
case|:
comment|/* 		 * Filling in the first part of a previous delayed allocation. 		 * The left neighbor is contiguous. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startoff
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|temp
operator|=
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|LEFT
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
name|temp
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
argument_list|,
name|STARTBLOCKVAL
argument_list|(
name|PREV
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
operator|*
name|dnew
operator|=
name|temp
expr_stmt|;
comment|/* DELTA: The boundary between two in-core extents moved. */
name|temp
operator|=
name|LEFT
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|LEFT_FILLING
argument_list|)
case|:
comment|/* 		 * Filling in the first part of a previous delayed allocation. 		 * The left neighbor is not contiguous. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startoff
argument_list|(
name|ep
argument_list|,
name|new_endoff
argument_list|)
expr_stmt|;
name|temp
operator|=
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"LF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|.
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
condition|)
block|{
name|error
operator|=
name|xfs_bmap_extents_to_btree
argument_list|(
name|ip
operator|->
name|i_transp
argument_list|,
name|ip
argument_list|,
name|first
argument_list|,
name|flist
argument_list|,
operator|&
name|cur
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp_rval
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|rval
operator||=
name|tmp_rval
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|temp
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
argument_list|,
name|STARTBLOCKVAL
argument_list|(
name|PREV
operator|.
name|br_startblock
argument_list|)
operator|-
operator|(
name|cur
condition|?
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
operator|*
name|dnew
operator|=
name|temp
expr_stmt|;
comment|/* DELTA: One in-core extent is split in two. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK2
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * Filling in the last part of a previous delayed allocation. 		 * The right neighbor is contiguous with the new allocation. 		 */
name|temp
operator|=
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_allf
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|RIGHT
operator|.
name|br_state
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|RIGHT
operator|.
name|br_startoff
argument_list|,
name|RIGHT
operator|.
name|br_startblock
argument_list|,
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|RIGHT
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
name|temp
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
argument_list|,
name|STARTBLOCKVAL
argument_list|(
name|PREV
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
operator|*
name|dnew
operator|=
name|temp
expr_stmt|;
comment|/* DELTA: The boundary between two in-core extents moved. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|RIGHT_FILLING
argument_list|)
case|:
comment|/* 		 * Filling in the last part of a previous delayed allocation. 		 * The right neighbor is not contiguous. 		 */
name|temp
operator|=
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"RF"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|.
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
condition|)
block|{
name|error
operator|=
name|xfs_bmap_extents_to_btree
argument_list|(
name|ip
operator|->
name|i_transp
argument_list|,
name|ip
argument_list|,
name|first
argument_list|,
name|flist
argument_list|,
operator|&
name|cur
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp_rval
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|rval
operator||=
name|tmp_rval
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|temp
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
argument_list|,
name|STARTBLOCKVAL
argument_list|(
name|PREV
operator|.
name|br_startblock
argument_list|)
operator|-
operator|(
name|cur
condition|?
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
operator|*
name|dnew
operator|=
name|temp
expr_stmt|;
comment|/* DELTA: One in-core extent is split in two. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * Filling in the middle part of a previous delayed allocation. 		 * Contiguity is impossible here. 		 * This case is avoided almost all the time. 		 */
name|temp
operator|=
name|new
operator|->
name|br_startoff
operator|-
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
operator|*
name|new
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|.
name|br_startoff
operator|=
name|new_endoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_startoff
operator|+
name|PREV
operator|.
name|br_blockcount
operator|-
name|new_endoff
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|.
name|br_blockcount
operator|=
name|temp2
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|r
index|[
literal|0
index|]
argument_list|,
operator|&
name|r
index|[
literal|1
index|]
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|r
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|.
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|>
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
condition|)
block|{
name|error
operator|=
name|xfs_bmap_extents_to_btree
argument_list|(
name|ip
operator|->
name|i_transp
argument_list|,
name|ip
argument_list|,
name|first
argument_list|,
name|flist
argument_list|,
operator|&
name|cur
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp_rval
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|rval
operator||=
name|tmp_rval
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|temp
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|diff
operator|=
call|(
name|int
call|)
argument_list|(
name|temp
operator|+
name|temp2
operator|-
name|STARTBLOCKVAL
argument_list|(
name|PREV
operator|.
name|br_startblock
argument_list|)
operator|-
operator|(
name|cur
condition|?
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
operator|&&
name|xfs_mod_incore_sb
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|-
name|diff
argument_list|,
name|rsvd
argument_list|)
condition|)
block|{
comment|/* 			 * Ick gross gag me with a spoon. 			 */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* want to see if this ever happens! */
while|while
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|temp
condition|)
block|{
name|temp
operator|--
expr_stmt|;
name|diff
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|diff
operator|||
operator|!
name|xfs_mod_incore_sb
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|-
name|diff
argument_list|,
name|rsvd
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|temp2
condition|)
block|{
name|temp2
operator|--
expr_stmt|;
name|diff
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|diff
operator|||
operator|!
name|xfs_mod_incore_sb
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|-
name|diff
argument_list|,
name|rsvd
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|2
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|2
argument_list|)
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp2
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|2
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
operator|*
name|dnew
operator|=
name|temp
operator|+
name|temp2
expr_stmt|;
comment|/* DELTA: One in-core extent is split in three. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK3
argument_list|(
name|LEFT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK3
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK2
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK2
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|)
case|:
case|case
name|MASK2
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK
argument_list|(
name|LEFT_CONTIG
argument_list|)
case|:
case|case
name|MASK
argument_list|(
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * These cases are all impossible. 		 */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|curp
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|temp2
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_startoff
operator|>
name|temp
condition|)
name|delta
operator|->
name|xed_startoff
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_blockcount
operator|<
name|temp2
condition|)
name|delta
operator|->
name|xed_blockcount
operator|=
name|temp2
expr_stmt|;
block|}
name|done
label|:
operator|*
name|logflagsp
operator|=
name|rval
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|LEFT
undef|#
directive|undef
name|RIGHT
undef|#
directive|undef
name|PREV
undef|#
directive|undef
name|MASK
undef|#
directive|undef
name|MASK2
undef|#
directive|undef
name|MASK3
undef|#
directive|undef
name|MASK4
undef|#
directive|undef
name|STATE_SET
undef|#
directive|undef
name|STATE_TEST
undef|#
directive|undef
name|STATE_SET_TEST
undef|#
directive|undef
name|SWITCH_STATE
block|}
end_function

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting an unwritten  * allocation to a real allocation or vice versa.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_unwritten_real
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* if *curp is null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|)
comment|/* Change made to incore extents */
block|{
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* btree cursor */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent entry for idx */
name|int
name|error
decl_stmt|;
comment|/* error return value */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_add_extent_unwritten_real"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/* temp state */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_fileoff_t
name|new_endoff
decl_stmt|;
comment|/* end offset of new entry */
name|xfs_exntst_t
name|newext
decl_stmt|;
comment|/* new extent state */
name|xfs_exntst_t
name|oldext
decl_stmt|;
comment|/* old extent state */
name|xfs_bmbt_irec_t
name|r
index|[
literal|3
index|]
decl_stmt|;
comment|/* neighbor extent entries */
comment|/* left is 0, right is 1, prev is 2 */
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* return value (logging flags) */
name|int
name|state
init|=
literal|0
decl_stmt|;
comment|/* state bits, accessed thru macros */
name|xfs_filblks_t
name|temp
init|=
literal|0
decl_stmt|;
name|xfs_filblks_t
name|temp2
init|=
literal|0
decl_stmt|;
enum|enum
block|{
comment|/* bit number definitions for state */
name|LEFT_CONTIG
block|,
name|RIGHT_CONTIG
block|,
name|LEFT_FILLING
block|,
name|RIGHT_FILLING
block|,
name|LEFT_DELAY
block|,
name|RIGHT_DELAY
block|,
name|LEFT_VALID
block|,
name|RIGHT_VALID
block|}
enum|;
define|#
directive|define
name|LEFT
value|r[0]
define|#
directive|define
name|RIGHT
value|r[1]
define|#
directive|define
name|PREV
value|r[2]
define|#
directive|define
name|MASK
parameter_list|(
name|b
parameter_list|)
value|(1<< (b))
define|#
directive|define
name|MASK2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(MASK(a) | MASK(b))
define|#
directive|define
name|MASK3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(MASK2(a,b) | MASK(c))
define|#
directive|define
name|MASK4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(MASK3(a,b,c) | MASK(d))
define|#
directive|define
name|STATE_SET
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? (state |= MASK(b)) : (state&= ~MASK(b)))
define|#
directive|define
name|STATE_TEST
parameter_list|(
name|b
parameter_list|)
value|(state& MASK(b))
define|#
directive|define
name|STATE_SET_TEST
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? ((state |= MASK(b)), 1) : \ 				       ((state&= ~MASK(b)), 0))
define|#
directive|define
name|SWITCH_STATE
define|\
value|(state& MASK4(LEFT_FILLING, RIGHT_FILLING, LEFT_CONTIG, RIGHT_CONTIG))
comment|/* 	 * Set up a bunch of variables to make the tests simpler. 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
operator|*
name|curp
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|PREV
argument_list|)
expr_stmt|;
name|newext
operator|=
name|new
operator|->
name|br_state
expr_stmt|;
name|oldext
operator|=
operator|(
name|newext
operator|==
name|XFS_EXT_UNWRITTEN
operator|)
condition|?
name|XFS_EXT_NORM
else|:
name|XFS_EXT_UNWRITTEN
expr_stmt|;
name|ASSERT
argument_list|(
name|PREV
operator|.
name|br_state
operator|==
name|oldext
argument_list|)
expr_stmt|;
name|new_endoff
operator|=
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|ASSERT
argument_list|(
name|PREV
operator|.
name|br_startoff
operator|<=
name|new
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|PREV
operator|.
name|br_startoff
operator|+
name|PREV
operator|.
name|br_blockcount
operator|>=
name|new_endoff
argument_list|)
expr_stmt|;
comment|/* 	 * Set flags determining what part of the previous oldext allocation 	 * extent is being replaced by a newext allocation. 	 */
name|STATE_SET
argument_list|(
name|LEFT_FILLING
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|==
name|new
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|+
name|PREV
operator|.
name|br_blockcount
operator|==
name|new_endoff
argument_list|)
expr_stmt|;
comment|/* 	 * Check and set flags if this segment has a left neighbor. 	 * Don't set contiguous if the combined extent would be too large. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|LEFT_VALID
argument_list|,
name|idx
operator|>
literal|0
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
operator|&
name|LEFT
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|LEFT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|LEFT
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STATE_SET
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|LEFT_VALID
argument_list|)
operator|&&
operator|!
name|STATE_TEST
argument_list|(
name|LEFT_DELAY
argument_list|)
operator|&&
name|LEFT
operator|.
name|br_startoff
operator|+
name|LEFT
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startoff
operator|&&
name|LEFT
operator|.
name|br_startblock
operator|+
name|LEFT
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startblock
operator|&&
name|LEFT
operator|.
name|br_state
operator|==
name|newext
operator|&&
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|<=
name|MAXEXTLEN
argument_list|)
expr_stmt|;
comment|/* 	 * Check and set flags if this segment has a right neighbor. 	 * Don't set contiguous if the combined extent would be too large. 	 * Also check for all-three-contiguous being too large. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|RIGHT_VALID
argument_list|,
name|idx
operator|<
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|RIGHT
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|RIGHT
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|STATE_SET
argument_list|(
name|RIGHT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|RIGHT_VALID
argument_list|)
operator|&&
operator|!
name|STATE_TEST
argument_list|(
name|RIGHT_DELAY
argument_list|)
operator|&&
name|new_endoff
operator|==
name|RIGHT
operator|.
name|br_startoff
operator|&&
name|new
operator|->
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
operator|==
name|RIGHT
operator|.
name|br_startblock
operator|&&
name|newext
operator|==
name|RIGHT
operator|.
name|br_state
operator|&&
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|&&
operator|(
operator|(
name|state
operator|&
name|MASK3
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|)
operator|)
operator|!=
name|MASK3
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|)
operator|||
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Switch out based on the FILLING and CONTIG state bits. 	 */
switch|switch
condition|(
name|SWITCH_STATE
condition|)
block|{
case|case
name|MASK4
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * Setting all of a previous oldext extent to newext. 		 * The left and right neighbors are both contiguous with new. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|2
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|RIGHT
operator|.
name|br_startoff
argument_list|,
name|RIGHT
operator|.
name|br_startblock
argument_list|,
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|LEFT
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: Three in-core extents are replaced by one. */
name|temp
operator|=
name|LEFT
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK3
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|)
case|:
comment|/* 		 * Setting all of a previous oldext extent to newext. 		 * The left neighbor is contiguous, the right is not. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|--
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
argument_list|,
name|LEFT
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: Two in-core extents are replaced by one. */
name|temp
operator|=
name|LEFT
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK3
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * Setting all of a previous oldext extent to newext. 		 * The right neighbor is contiguous, the left is not. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_state
argument_list|(
name|ep
argument_list|,
name|newext
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LF|RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|--
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|RIGHT
operator|.
name|br_startoff
argument_list|,
name|RIGHT
operator|.
name|br_startblock
argument_list|,
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|newext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: Two in-core extents are replaced by one. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK2
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_FILLING
argument_list|)
case|:
comment|/* 		 * Setting all of a previous oldext extent to newext. 		 * Neither the left nor right neighbors are contiguous with 		 * the new one. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_state
argument_list|(
name|ep
argument_list|,
name|newext
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
name|newext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: The in-core extent described by new changed type. */
name|temp
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|new
operator|->
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK2
argument_list|(
name|LEFT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|)
case|:
comment|/* 		 * Setting the first part of a previous oldext extent to newext. 		 * The left neighbor is contiguous. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startoff
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF|LC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|PREV
operator|.
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|,
name|oldext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|LEFT
operator|.
name|br_startoff
argument_list|,
name|LEFT
operator|.
name|br_startblock
argument_list|,
name|LEFT
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|LEFT
operator|.
name|br_state
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: The boundary between two in-core extents moved. */
name|temp
operator|=
name|LEFT
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|LEFT
operator|.
name|br_blockcount
operator|+
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|LEFT_FILLING
argument_list|)
case|:
comment|/* 		 * Setting the first part of a previous oldext extent to newext. 		 * The left neighbor is not contiguous. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ep
operator|&&
name|xfs_bmbt_get_state
argument_list|(
name|ep
argument_list|)
operator|==
name|oldext
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startoff
argument_list|(
name|ep
argument_list|,
name|new_endoff
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"LF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|PREV
operator|.
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|,
name|oldext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|=
operator|*
name|new
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* DELTA: One in-core extent is split in two. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK2
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * Setting the last part of a previous oldext extent to newext. 		 * The right neighbor is contiguous with the new allocation. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_allf
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|newext
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RF|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|,
name|oldext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
argument_list|,
name|newext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: The boundary between two in-core extents moved. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
operator|+
name|RIGHT
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|RIGHT_FILLING
argument_list|)
case|:
comment|/* 		 * Setting the last part of a previous oldext extent to newext. 		 * The right neighbor is not contiguous. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RF"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"RF"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
operator|-
name|new
operator|->
name|br_blockcount
argument_list|,
name|oldext
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|.
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* DELTA: One in-core extent is split in two. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * Setting the middle part of a previous oldext extent to 		 * newext.  Contiguity is impossible here. 		 * One extent becomes three extents. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startoff
operator|-
name|PREV
operator|.
name|br_startoff
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
operator|*
name|new
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|.
name|br_startoff
operator|=
name|new_endoff
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|.
name|br_blockcount
operator|=
name|PREV
operator|.
name|br_startoff
operator|+
name|PREV
operator|.
name|br_blockcount
operator|-
name|new_endoff
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|.
name|br_startblock
operator|=
name|new
operator|->
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|r
index|[
literal|1
index|]
operator|.
name|br_state
operator|=
name|oldext
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|r
index|[
literal|0
index|]
argument_list|,
operator|&
name|r
index|[
literal|1
index|]
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
operator|&
name|r
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_DEXT
expr_stmt|;
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|PREV
operator|.
name|br_startoff
argument_list|,
name|PREV
operator|.
name|br_startblock
argument_list|,
name|PREV
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* new right extent - oldext */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|r
index|[
literal|1
index|]
operator|.
name|br_startoff
argument_list|,
name|r
index|[
literal|1
index|]
operator|.
name|br_startblock
argument_list|,
name|r
index|[
literal|1
index|]
operator|.
name|br_blockcount
argument_list|,
name|r
index|[
literal|1
index|]
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* new left extent - oldext */
name|PREV
operator|.
name|br_blockcount
operator|=
name|new
operator|->
name|br_startoff
operator|-
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|=
name|PREV
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* new middle extent - newext */
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|=
operator|*
name|new
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* DELTA: One in-core extent is split in three. */
name|temp
operator|=
name|PREV
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|PREV
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK3
argument_list|(
name|LEFT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK3
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK2
argument_list|(
name|LEFT_FILLING
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK2
argument_list|(
name|RIGHT_FILLING
argument_list|,
name|LEFT_CONTIG
argument_list|)
case|:
case|case
name|MASK2
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
case|case
name|MASK
argument_list|(
name|LEFT_CONTIG
argument_list|)
case|:
case|case
name|MASK
argument_list|(
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * These cases are all impossible. 		 */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|curp
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|temp2
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_startoff
operator|>
name|temp
condition|)
name|delta
operator|->
name|xed_startoff
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_blockcount
operator|<
name|temp2
condition|)
name|delta
operator|->
name|xed_blockcount
operator|=
name|temp2
expr_stmt|;
block|}
name|done
label|:
operator|*
name|logflagsp
operator|=
name|rval
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|LEFT
undef|#
directive|undef
name|RIGHT
undef|#
directive|undef
name|PREV
undef|#
directive|undef
name|MASK
undef|#
directive|undef
name|MASK2
undef|#
directive|undef
name|MASK3
undef|#
directive|undef
name|MASK4
undef|#
directive|undef
name|STATE_SET
undef|#
directive|undef
name|STATE_TEST
undef|#
directive|undef
name|STATE_SET_TEST
undef|#
directive|undef
name|SWITCH_STATE
block|}
end_function

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting a hole  * to a delayed allocation.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_hole_delay
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* if null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|rsvd
parameter_list|)
comment|/* OK to allocate reserved blocks */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record for idx */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_add_extent_hole_delay"
decl_stmt|;
endif|#
directive|endif
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_irec_t
name|left
decl_stmt|;
comment|/* left neighbor extent entry */
name|xfs_filblks_t
name|newlen
init|=
literal|0
decl_stmt|;
comment|/* new indirect size */
name|xfs_filblks_t
name|oldlen
init|=
literal|0
decl_stmt|;
comment|/* old indirect size */
name|xfs_bmbt_irec_t
name|right
decl_stmt|;
comment|/* right neighbor extent entry */
name|int
name|state
decl_stmt|;
comment|/* state bits, accessed thru macros */
name|xfs_filblks_t
name|temp
init|=
literal|0
decl_stmt|;
comment|/* temp for indirect calculations */
name|xfs_filblks_t
name|temp2
init|=
literal|0
decl_stmt|;
enum|enum
block|{
comment|/* bit number definitions for state */
name|LEFT_CONTIG
block|,
name|RIGHT_CONTIG
block|,
name|LEFT_DELAY
block|,
name|RIGHT_DELAY
block|,
name|LEFT_VALID
block|,
name|RIGHT_VALID
block|}
enum|;
define|#
directive|define
name|MASK
parameter_list|(
name|b
parameter_list|)
value|(1<< (b))
define|#
directive|define
name|MASK2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(MASK(a) | MASK(b))
define|#
directive|define
name|STATE_SET
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? (state |= MASK(b)) : (state&= ~MASK(b)))
define|#
directive|define
name|STATE_TEST
parameter_list|(
name|b
parameter_list|)
value|(state& MASK(b))
define|#
directive|define
name|STATE_SET_TEST
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? ((state |= MASK(b)), 1) : \ 				       ((state&= ~MASK(b)), 0))
define|#
directive|define
name|SWITCH_STATE
value|(state& MASK2(LEFT_CONTIG, RIGHT_CONTIG))
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|ISNULLSTARTBLOCK
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check and set flags if this segment has a left neighbor 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|LEFT_VALID
argument_list|,
name|idx
operator|>
literal|0
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|LEFT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|left
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check and set flags if the current (right) segment exists. 	 * If it doesn't exist, we're converting the hole at end-of-file. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|RIGHT_VALID
argument_list|,
name|idx
operator|<
name|ip
operator|->
name|i_df
operator|.
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|right
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set contiguity flags on the left and right neighbors. 	 * Don't let extents get too large, even if the pieces are contiguous. 	 */
name|STATE_SET
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|LEFT_VALID
argument_list|)
operator|&&
name|STATE_TEST
argument_list|(
name|LEFT_DELAY
argument_list|)
operator|&&
name|left
operator|.
name|br_startoff
operator|+
name|left
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startoff
operator|&&
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|<=
name|MAXEXTLEN
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|RIGHT_VALID
argument_list|)
operator|&&
name|STATE_TEST
argument_list|(
name|RIGHT_DELAY
argument_list|)
operator|&&
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
operator|==
name|right
operator|.
name|br_startoff
operator|&&
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|&&
operator|(
operator|!
name|STATE_TEST
argument_list|(
name|LEFT_CONTIG
argument_list|)
operator|||
operator|(
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Switch out based on the contiguity flags. 	 */
switch|switch
condition|(
name|SWITCH_STATE
condition|)
block|{
case|case
name|MASK2
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * New allocation is contiguous with delayed allocations 		 * on the left and on the right. 		 * Merge all three into a single extent record. 		 */
name|temp
operator|=
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|oldlen
operator|=
name|STARTBLOCKVAL
argument_list|(
name|left
operator|.
name|br_startblock
argument_list|)
operator|+
name|STARTBLOCKVAL
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
operator|+
name|STARTBLOCKVAL
argument_list|(
name|right
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|newlen
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
comment|/* DELTA: Two in-core extents were replaced by one. */
name|temp2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|left
operator|.
name|br_startoff
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|LEFT_CONTIG
argument_list|)
case|:
comment|/* 		 * New allocation is contiguous with a delayed allocation 		 * on the left. 		 * Merge the new allocation with the left neighbor. 		 */
name|temp
operator|=
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|oldlen
operator|=
name|STARTBLOCKVAL
argument_list|(
name|left
operator|.
name|br_startblock
argument_list|)
operator|+
name|STARTBLOCKVAL
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|newlen
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
comment|/* DELTA: One in-core extent grew into a hole. */
name|temp2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|left
operator|.
name|br_startoff
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * New allocation is contiguous with a delayed allocation 		 * on the right. 		 * Merge the new allocation with the right neighbor. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|temp
operator|=
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
expr_stmt|;
name|oldlen
operator|=
name|STARTBLOCKVAL
argument_list|(
name|new
operator|->
name|br_startblock
argument_list|)
operator|+
name|STARTBLOCKVAL
argument_list|(
name|right
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_allf
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|newlen
argument_list|)
argument_list|,
name|temp
argument_list|,
name|right
operator|.
name|br_state
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
comment|/* DELTA: One in-core extent grew into a hole. */
name|temp2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * New allocation is not contiguous with another 		 * delayed allocation. 		 * Insert a new entry. 		 */
name|oldlen
operator|=
name|newlen
operator|=
literal|0
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_lastex
operator|=
name|idx
expr_stmt|;
comment|/* DELTA: A new in-core extent was added in a hole. */
name|temp2
operator|=
name|new
operator|->
name|br_blockcount
expr_stmt|;
name|temp
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldlen
operator|!=
name|newlen
condition|)
block|{
name|ASSERT
argument_list|(
name|oldlen
operator|>
name|newlen
argument_list|)
expr_stmt|;
name|xfs_mod_incore_sb
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
call|(
name|int
call|)
argument_list|(
name|oldlen
operator|-
name|newlen
argument_list|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
comment|/* 		 * Nothing to do for disk quota accounting here. 		 */
block|}
if|if
condition|(
name|delta
condition|)
block|{
name|temp2
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_startoff
operator|>
name|temp
condition|)
name|delta
operator|->
name|xed_startoff
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_blockcount
operator|<
name|temp2
condition|)
name|delta
operator|->
name|xed_blockcount
operator|=
name|temp2
expr_stmt|;
block|}
operator|*
name|logflagsp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|MASK
undef|#
directive|undef
name|MASK2
undef|#
directive|undef
name|STATE_SET
undef|#
directive|undef
name|STATE_TEST
undef|#
directive|undef
name|STATE_SET_TEST
undef|#
directive|undef
name|SWITCH_STATE
block|}
end_function

begin_comment
comment|/*  * Called by xfs_bmap_add_extent to handle cases converting a hole  * to a real allocation.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_add_extent_hole_real
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/insert */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* if null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|new
parameter_list|,
comment|/* new data to add to file extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* pointer to extent entry ins. point */
name|int
name|error
decl_stmt|;
comment|/* error return value */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_add_extent_hole_real"
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/* temp state */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_irec_t
name|left
decl_stmt|;
comment|/* left neighbor extent entry */
name|xfs_bmbt_irec_t
name|right
decl_stmt|;
comment|/* right neighbor extent entry */
name|int
name|rval
init|=
literal|0
decl_stmt|;
comment|/* return value (logging flags) */
name|int
name|state
decl_stmt|;
comment|/* state bits, accessed thru macros */
name|xfs_filblks_t
name|temp
init|=
literal|0
decl_stmt|;
name|xfs_filblks_t
name|temp2
init|=
literal|0
decl_stmt|;
enum|enum
block|{
comment|/* bit number definitions for state */
name|LEFT_CONTIG
block|,
name|RIGHT_CONTIG
block|,
name|LEFT_DELAY
block|,
name|RIGHT_DELAY
block|,
name|LEFT_VALID
block|,
name|RIGHT_VALID
block|}
enum|;
define|#
directive|define
name|MASK
parameter_list|(
name|b
parameter_list|)
value|(1<< (b))
define|#
directive|define
name|MASK2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(MASK(a) | MASK(b))
define|#
directive|define
name|STATE_SET
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? (state |= MASK(b)) : (state&= ~MASK(b)))
define|#
directive|define
name|STATE_TEST
parameter_list|(
name|b
parameter_list|)
value|(state& MASK(b))
define|#
directive|define
name|STATE_SET_TEST
parameter_list|(
name|b
parameter_list|,
name|v
parameter_list|)
value|((v) ? ((state |= MASK(b)), 1) : \ 				       ((state&= ~MASK(b)), 0))
define|#
directive|define
name|SWITCH_STATE
value|(state& MASK2(LEFT_CONTIG, RIGHT_CONTIG))
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|idx
operator|<=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check and set flags if this segment has a left neighbor. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|LEFT_VALID
argument_list|,
name|idx
operator|>
literal|0
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|LEFT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|left
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check and set flags if this segment has a current value. 	 * Not true if we're inserting into the "hole" at eof. 	 */
if|if
condition|(
name|STATE_SET_TEST
argument_list|(
name|RIGHT_VALID
argument_list|,
name|idx
operator|<
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_DELAY
argument_list|,
name|ISNULLSTARTBLOCK
argument_list|(
name|right
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're inserting a real allocation between "left" and "right". 	 * Set the contiguity flags.  Don't let extents get too large. 	 */
name|STATE_SET
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|LEFT_VALID
argument_list|)
operator|&&
operator|!
name|STATE_TEST
argument_list|(
name|LEFT_DELAY
argument_list|)
operator|&&
name|left
operator|.
name|br_startoff
operator|+
name|left
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startoff
operator|&&
name|left
operator|.
name|br_startblock
operator|+
name|left
operator|.
name|br_blockcount
operator|==
name|new
operator|->
name|br_startblock
operator|&&
name|left
operator|.
name|br_state
operator|==
name|new
operator|->
name|br_state
operator|&&
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|<=
name|MAXEXTLEN
argument_list|)
expr_stmt|;
name|STATE_SET
argument_list|(
name|RIGHT_CONTIG
argument_list|,
name|STATE_TEST
argument_list|(
name|RIGHT_VALID
argument_list|)
operator|&&
operator|!
name|STATE_TEST
argument_list|(
name|RIGHT_DELAY
argument_list|)
operator|&&
name|new
operator|->
name|br_startoff
operator|+
name|new
operator|->
name|br_blockcount
operator|==
name|right
operator|.
name|br_startoff
operator|&&
name|new
operator|->
name|br_startblock
operator|+
name|new
operator|->
name|br_blockcount
operator|==
name|right
operator|.
name|br_startblock
operator|&&
name|new
operator|->
name|br_state
operator|==
name|right
operator|.
name|br_state
operator|&&
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|&&
operator|(
operator|!
name|STATE_TEST
argument_list|(
name|LEFT_CONTIG
argument_list|)
operator|||
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
operator|<=
name|MAXEXTLEN
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Select which case we're in here, and implement it. 	 */
switch|switch
condition|(
name|SWITCH_STATE
condition|)
block|{
case|case
name|MASK2
argument_list|(
name|LEFT_CONTIG
argument_list|,
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * New allocation is contiguous with real allocations on the 		 * left and on the right. 		 * Merge all three into a single extent record. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"LC|RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
name|XFS_IFORK_NEXT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|right
operator|.
name|br_startoff
argument_list|,
name|right
operator|.
name|br_startblock
argument_list|,
name|right
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_decrement
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|left
operator|.
name|br_startoff
argument_list|,
name|left
operator|.
name|br_startblock
argument_list|,
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
argument_list|,
name|left
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: Two in-core extents were replaced by one. */
name|temp
operator|=
name|left
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|LEFT_CONTIG
argument_list|)
case|:
comment|/* 		 * New allocation is contiguous with a real allocation 		 * on the left. 		 * Merge the new allocation with the left neighbor. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|-
literal|1
argument_list|)
argument_list|,
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"LC"
argument_list|,
name|ip
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|left
operator|.
name|br_startoff
argument_list|,
name|left
operator|.
name|br_startblock
argument_list|,
name|left
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|left
operator|.
name|br_startoff
argument_list|,
name|left
operator|.
name|br_startblock
argument_list|,
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
argument_list|,
name|left
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: One in-core extent grew. */
name|temp
operator|=
name|left
operator|.
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|left
operator|.
name|br_blockcount
operator|+
name|new
operator|->
name|br_blockcount
expr_stmt|;
break|break;
case|case
name|MASK
argument_list|(
name|RIGHT_CONTIG
argument_list|)
case|:
comment|/* 		 * New allocation is contiguous with a real allocation 		 * on the right. 		 * Merge the new allocation with the right neighbor. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_allf
argument_list|(
name|ep
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
argument_list|,
name|right
operator|.
name|br_state
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"RC"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|right
operator|.
name|br_startoff
argument_list|,
name|right
operator|.
name|br_startblock
argument_list|,
name|right
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
argument_list|,
name|right
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* DELTA: One in-core extent grew. */
name|temp
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|new
operator|->
name|br_blockcount
operator|+
name|right
operator|.
name|br_blockcount
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * New allocation is not contiguous with another 		 * real allocation. 		 * Insert a new entry. 		 */
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
expr_stmt|;
name|XFS_IFORK_NEXT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|new
operator|->
name|br_startoff
argument_list|,
name|new
operator|->
name|br_startblock
argument_list|,
name|new
operator|->
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|.
name|br_state
operator|=
name|new
operator|->
name|br_state
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* DELTA: A new extent was added in a hole. */
name|temp
operator|=
name|new
operator|->
name|br_startoff
expr_stmt|;
name|temp2
operator|=
name|new
operator|->
name|br_blockcount
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|delta
condition|)
block|{
name|temp2
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_startoff
operator|>
name|temp
condition|)
name|delta
operator|->
name|xed_startoff
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_blockcount
operator|<
name|temp2
condition|)
name|delta
operator|->
name|xed_blockcount
operator|=
name|temp2
expr_stmt|;
block|}
name|done
label|:
operator|*
name|logflagsp
operator|=
name|rval
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|MASK
undef|#
directive|undef
name|MASK2
undef|#
directive|undef
name|STATE_SET
undef|#
directive|undef
name|STATE_TEST
undef|#
directive|undef
name|STATE_SET_TEST
undef|#
directive|undef
name|SWITCH_STATE
block|}
end_function

begin_comment
comment|/*  * Adjust the size of the new extent based on di_extsize and rt extsize.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_bmap_extsize_align
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|gotp
parameter_list|,
comment|/* next extent pointer */
name|xfs_bmbt_irec_t
modifier|*
name|prevp
parameter_list|,
comment|/* previous extent pointer */
name|xfs_extlen_t
name|extsz
parameter_list|,
comment|/* align to this extent size */
name|int
name|rt
parameter_list|,
comment|/* is this a realtime inode? */
name|int
name|eof
parameter_list|,
comment|/* is extent at end-of-file? */
name|int
name|delay
parameter_list|,
comment|/* creating delalloc extent? */
name|int
name|convert
parameter_list|,
comment|/* overwriting unwritten extent? */
name|xfs_fileoff_t
modifier|*
name|offp
parameter_list|,
comment|/* in/out: aligned offset */
name|xfs_extlen_t
modifier|*
name|lenp
parameter_list|)
comment|/* in/out: aligned length */
block|{
name|xfs_fileoff_t
name|orig_off
decl_stmt|;
comment|/* original offset */
name|xfs_extlen_t
name|orig_alen
decl_stmt|;
comment|/* original length */
name|xfs_fileoff_t
name|orig_end
decl_stmt|;
comment|/* original off+len */
name|xfs_fileoff_t
name|nexto
decl_stmt|;
comment|/* next file offset */
name|xfs_fileoff_t
name|prevo
decl_stmt|;
comment|/* previous file offset */
name|xfs_fileoff_t
name|align_off
decl_stmt|;
comment|/* temp for offset */
name|xfs_extlen_t
name|align_alen
decl_stmt|;
comment|/* temp for length */
name|xfs_extlen_t
name|temp
decl_stmt|;
comment|/* temp for calculations */
if|if
condition|(
name|convert
condition|)
return|return
literal|0
return|;
name|orig_off
operator|=
name|align_off
operator|=
operator|*
name|offp
expr_stmt|;
name|orig_alen
operator|=
name|align_alen
operator|=
operator|*
name|lenp
expr_stmt|;
name|orig_end
operator|=
name|orig_off
operator|+
name|orig_alen
expr_stmt|;
comment|/* 	 * If this request overlaps an existing extent, then don't 	 * attempt to perform any additional alignment. 	 */
if|if
condition|(
operator|!
name|delay
operator|&&
operator|!
name|eof
operator|&&
operator|(
name|orig_off
operator|>=
name|gotp
operator|->
name|br_startoff
operator|)
operator|&&
operator|(
name|orig_end
operator|<=
name|gotp
operator|->
name|br_startoff
operator|+
name|gotp
operator|->
name|br_blockcount
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* 	 * If the file offset is unaligned vs. the extent size 	 * we need to align it.  This will be possible unless 	 * the file was previously written with a kernel that didn't 	 * perform this alignment, or if a truncate shot us in the 	 * foot. 	 */
name|temp
operator|=
name|do_mod
argument_list|(
name|orig_off
argument_list|,
name|extsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|align_alen
operator|+=
name|temp
expr_stmt|;
name|align_off
operator|-=
name|temp
expr_stmt|;
block|}
comment|/* 	 * Same adjustment for the end of the requested area. 	 */
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|align_alen
operator|%
name|extsz
operator|)
operator|)
condition|)
block|{
name|align_alen
operator|+=
name|extsz
operator|-
name|temp
expr_stmt|;
block|}
comment|/* 	 * If the previous block overlaps with this proposed allocation 	 * then move the start forward without adjusting the length. 	 */
if|if
condition|(
name|prevp
operator|->
name|br_startoff
operator|!=
name|NULLFILEOFF
condition|)
block|{
if|if
condition|(
name|prevp
operator|->
name|br_startblock
operator|==
name|HOLESTARTBLOCK
condition|)
name|prevo
operator|=
name|prevp
operator|->
name|br_startoff
expr_stmt|;
else|else
name|prevo
operator|=
name|prevp
operator|->
name|br_startoff
operator|+
name|prevp
operator|->
name|br_blockcount
expr_stmt|;
block|}
else|else
name|prevo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|align_off
operator|!=
name|orig_off
operator|&&
name|align_off
operator|<
name|prevo
condition|)
name|align_off
operator|=
name|prevo
expr_stmt|;
comment|/* 	 * If the next block overlaps with this proposed allocation 	 * then move the start back without adjusting the length, 	 * but not before offset 0. 	 * This may of course make the start overlap previous block, 	 * and if we hit the offset 0 limit then the next block 	 * can still overlap too. 	 */
if|if
condition|(
operator|!
name|eof
operator|&&
name|gotp
operator|->
name|br_startoff
operator|!=
name|NULLFILEOFF
condition|)
block|{
if|if
condition|(
operator|(
name|delay
operator|&&
name|gotp
operator|->
name|br_startblock
operator|==
name|HOLESTARTBLOCK
operator|)
operator|||
operator|(
operator|!
name|delay
operator|&&
name|gotp
operator|->
name|br_startblock
operator|==
name|DELAYSTARTBLOCK
operator|)
condition|)
name|nexto
operator|=
name|gotp
operator|->
name|br_startoff
operator|+
name|gotp
operator|->
name|br_blockcount
expr_stmt|;
else|else
name|nexto
operator|=
name|gotp
operator|->
name|br_startoff
expr_stmt|;
block|}
else|else
name|nexto
operator|=
name|NULLFILEOFF
expr_stmt|;
if|if
condition|(
operator|!
name|eof
operator|&&
name|align_off
operator|+
name|align_alen
operator|!=
name|orig_end
operator|&&
name|align_off
operator|+
name|align_alen
operator|>
name|nexto
condition|)
name|align_off
operator|=
name|nexto
operator|>
name|align_alen
condition|?
name|nexto
operator|-
name|align_alen
else|:
literal|0
expr_stmt|;
comment|/* 	 * If we're now overlapping the next or previous extent that 	 * means we can't fit an extsz piece in this hole.  Just move 	 * the start forward to the first valid spot and set 	 * the length so we hit the end. 	 */
if|if
condition|(
name|align_off
operator|!=
name|orig_off
operator|&&
name|align_off
operator|<
name|prevo
condition|)
name|align_off
operator|=
name|prevo
expr_stmt|;
if|if
condition|(
name|align_off
operator|+
name|align_alen
operator|!=
name|orig_end
operator|&&
name|align_off
operator|+
name|align_alen
operator|>
name|nexto
operator|&&
name|nexto
operator|!=
name|NULLFILEOFF
condition|)
block|{
name|ASSERT
argument_list|(
name|nexto
operator|>
name|prevo
argument_list|)
expr_stmt|;
name|align_alen
operator|=
name|nexto
operator|-
name|align_off
expr_stmt|;
block|}
comment|/* 	 * If realtime, and the result isn't a multiple of the realtime 	 * extent size we need to remove blocks until it is. 	 */
if|if
condition|(
name|rt
operator|&&
operator|(
name|temp
operator|=
operator|(
name|align_alen
operator|%
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|)
operator|)
condition|)
block|{
comment|/* 		 * We're not covering the original request, or 		 * we won't be able to once we fix the length. 		 */
if|if
condition|(
name|orig_off
operator|<
name|align_off
operator|||
name|orig_end
operator|>
name|align_off
operator|+
name|align_alen
operator|||
name|align_alen
operator|-
name|temp
operator|<
name|orig_alen
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 		 * Try to fix it by moving the start up. 		 */
if|if
condition|(
name|align_off
operator|+
name|temp
operator|<=
name|orig_off
condition|)
block|{
name|align_alen
operator|-=
name|temp
expr_stmt|;
name|align_off
operator|+=
name|temp
expr_stmt|;
block|}
comment|/* 		 * Try to fix it by moving the end in. 		 */
elseif|else
if|if
condition|(
name|align_off
operator|+
name|align_alen
operator|-
name|temp
operator|>=
name|orig_end
condition|)
name|align_alen
operator|-=
name|temp
expr_stmt|;
comment|/* 		 * Set the start to the minimum then trim the length. 		 */
else|else
block|{
name|align_alen
operator|-=
name|orig_off
operator|-
name|align_off
expr_stmt|;
name|align_off
operator|=
name|orig_off
expr_stmt|;
name|align_alen
operator|-=
name|align_alen
operator|%
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
block|}
comment|/* 		 * Result doesn't cover the request, fail it. 		 */
if|if
condition|(
name|orig_off
operator|<
name|align_off
operator|||
name|orig_end
operator|>
name|align_off
operator|+
name|align_alen
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|orig_off
operator|>=
name|align_off
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|orig_end
operator|<=
name|align_off
operator|+
name|align_alen
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|eof
operator|&&
name|gotp
operator|->
name|br_startoff
operator|!=
name|NULLFILEOFF
condition|)
name|ASSERT
argument_list|(
name|align_off
operator|+
name|align_alen
operator|<=
name|gotp
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevp
operator|->
name|br_startoff
operator|!=
name|NULLFILEOFF
condition|)
name|ASSERT
argument_list|(
name|align_off
operator|>=
name|prevp
operator|->
name|br_startoff
operator|+
name|prevp
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|lenp
operator|=
name|align_alen
expr_stmt|;
operator|*
name|offp
operator|=
name|align_off
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|XFS_ALLOC_GAP_UNITS
value|4
end_define

begin_function
name|STATIC
name|int
name|xfs_bmap_adjacent
parameter_list|(
name|xfs_bmalloca_t
modifier|*
name|ap
parameter_list|)
comment|/* bmap alloc argument struct */
block|{
name|xfs_fsblock_t
name|adjust
decl_stmt|;
comment|/* adjustment to block numbers */
name|xfs_agnumber_t
name|fb_agno
decl_stmt|;
comment|/* ag number of ap->firstblock */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount point structure */
name|int
name|nullfb
decl_stmt|;
comment|/* true if ap->firstblock isn't set */
name|int
name|rt
decl_stmt|;
comment|/* true if inode is realtime */
define|#
directive|define
name|ISVALID
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(rt ? \ 		(x)< mp->m_sb.sb_rblocks : \ 		XFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y)&& \ 		XFS_FSB_TO_AGNO(mp, x)< mp->m_sb.sb_agcount&& \ 		XFS_FSB_TO_AGBNO(mp, x)< mp->m_sb.sb_agblocks)
name|mp
operator|=
name|ap
operator|->
name|ip
operator|->
name|i_mount
expr_stmt|;
name|nullfb
operator|=
name|ap
operator|->
name|firstblock
operator|==
name|NULLFSBLOCK
expr_stmt|;
name|rt
operator|=
name|XFS_IS_REALTIME_INODE
argument_list|(
name|ap
operator|->
name|ip
argument_list|)
operator|&&
name|ap
operator|->
name|userdata
expr_stmt|;
name|fb_agno
operator|=
name|nullfb
condition|?
name|NULLAGNUMBER
else|:
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|firstblock
argument_list|)
expr_stmt|;
comment|/* 	 * If allocating at eof, and there's a previous real block, 	 * try to use it's last block as our starting point. 	 */
if|if
condition|(
name|ap
operator|->
name|eof
operator|&&
name|ap
operator|->
name|prevp
operator|->
name|br_startoff
operator|!=
name|NULLFILEOFF
operator|&&
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
argument_list|)
operator|&&
name|ISVALID
argument_list|(
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
operator|+
name|ap
operator|->
name|prevp
operator|->
name|br_blockcount
argument_list|,
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
argument_list|)
condition|)
block|{
name|ap
operator|->
name|rval
operator|=
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
operator|+
name|ap
operator|->
name|prevp
operator|->
name|br_blockcount
expr_stmt|;
comment|/* 		 * Adjust for the gap between prevp and us. 		 */
name|adjust
operator|=
name|ap
operator|->
name|off
operator|-
operator|(
name|ap
operator|->
name|prevp
operator|->
name|br_startoff
operator|+
name|ap
operator|->
name|prevp
operator|->
name|br_blockcount
operator|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|&&
name|ISVALID
argument_list|(
name|ap
operator|->
name|rval
operator|+
name|adjust
argument_list|,
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
argument_list|)
condition|)
name|ap
operator|->
name|rval
operator|+=
name|adjust
expr_stmt|;
block|}
comment|/* 	 * If not at eof, then compare the two neighbor blocks. 	 * Figure out whether either one gives us a good starting point, 	 * and pick the better one. 	 */
elseif|else
if|if
condition|(
operator|!
name|ap
operator|->
name|eof
condition|)
block|{
name|xfs_fsblock_t
name|gotbno
decl_stmt|;
comment|/* right side block number */
name|xfs_fsblock_t
name|gotdiff
init|=
literal|0
decl_stmt|;
comment|/* right side difference */
name|xfs_fsblock_t
name|prevbno
decl_stmt|;
comment|/* left side block number */
name|xfs_fsblock_t
name|prevdiff
init|=
literal|0
decl_stmt|;
comment|/* left side difference */
comment|/* 		 * If there's a previous (left) block, select a requested 		 * start block based on it. 		 */
if|if
condition|(
name|ap
operator|->
name|prevp
operator|->
name|br_startoff
operator|!=
name|NULLFILEOFF
operator|&&
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
argument_list|)
operator|&&
operator|(
name|prevbno
operator|=
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
operator|+
name|ap
operator|->
name|prevp
operator|->
name|br_blockcount
operator|)
operator|&&
name|ISVALID
argument_list|(
name|prevbno
argument_list|,
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
argument_list|)
condition|)
block|{
comment|/* 			 * Calculate gap to end of previous block. 			 */
name|adjust
operator|=
name|prevdiff
operator|=
name|ap
operator|->
name|off
operator|-
operator|(
name|ap
operator|->
name|prevp
operator|->
name|br_startoff
operator|+
name|ap
operator|->
name|prevp
operator|->
name|br_blockcount
operator|)
expr_stmt|;
comment|/* 			 * Figure the startblock based on the previous block's 			 * end and the gap size. 			 * Heuristic! 			 * If the gap is large relative to the piece we're 			 * allocating, or using it gives us an invalid block 			 * number, then just use the end of the previous block. 			 */
if|if
condition|(
name|prevdiff
operator|<=
name|XFS_ALLOC_GAP_UNITS
operator|*
name|ap
operator|->
name|alen
operator|&&
name|ISVALID
argument_list|(
name|prevbno
operator|+
name|prevdiff
argument_list|,
name|ap
operator|->
name|prevp
operator|->
name|br_startblock
argument_list|)
condition|)
name|prevbno
operator|+=
name|adjust
expr_stmt|;
else|else
name|prevdiff
operator|+=
name|adjust
expr_stmt|;
comment|/* 			 * If the firstblock forbids it, can't use it, 			 * must use default. 			 */
if|if
condition|(
operator|!
name|rt
operator|&&
operator|!
name|nullfb
operator|&&
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|prevbno
argument_list|)
operator|!=
name|fb_agno
condition|)
name|prevbno
operator|=
name|NULLFSBLOCK
expr_stmt|;
block|}
comment|/* 		 * No previous block or can't follow it, just default. 		 */
else|else
name|prevbno
operator|=
name|NULLFSBLOCK
expr_stmt|;
comment|/* 		 * If there's a following (right) block, select a requested 		 * start block based on it. 		 */
if|if
condition|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|ap
operator|->
name|gotp
operator|->
name|br_startblock
argument_list|)
condition|)
block|{
comment|/* 			 * Calculate gap to start of next block. 			 */
name|adjust
operator|=
name|gotdiff
operator|=
name|ap
operator|->
name|gotp
operator|->
name|br_startoff
operator|-
name|ap
operator|->
name|off
expr_stmt|;
comment|/* 			 * Figure the startblock based on the next block's 			 * start and the gap size. 			 */
name|gotbno
operator|=
name|ap
operator|->
name|gotp
operator|->
name|br_startblock
expr_stmt|;
comment|/* 			 * Heuristic! 			 * If the gap is large relative to the piece we're 			 * allocating, or using it gives us an invalid block 			 * number, then just use the start of the next block 			 * offset by our length. 			 */
if|if
condition|(
name|gotdiff
operator|<=
name|XFS_ALLOC_GAP_UNITS
operator|*
name|ap
operator|->
name|alen
operator|&&
name|ISVALID
argument_list|(
name|gotbno
operator|-
name|gotdiff
argument_list|,
name|gotbno
argument_list|)
condition|)
name|gotbno
operator|-=
name|adjust
expr_stmt|;
elseif|else
if|if
condition|(
name|ISVALID
argument_list|(
name|gotbno
operator|-
name|ap
operator|->
name|alen
argument_list|,
name|gotbno
argument_list|)
condition|)
block|{
name|gotbno
operator|-=
name|ap
operator|->
name|alen
expr_stmt|;
name|gotdiff
operator|+=
name|adjust
operator|-
name|ap
operator|->
name|alen
expr_stmt|;
block|}
else|else
name|gotdiff
operator|+=
name|adjust
expr_stmt|;
comment|/* 			 * If the firstblock forbids it, can't use it, 			 * must use default. 			 */
if|if
condition|(
operator|!
name|rt
operator|&&
operator|!
name|nullfb
operator|&&
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|gotbno
argument_list|)
operator|!=
name|fb_agno
condition|)
name|gotbno
operator|=
name|NULLFSBLOCK
expr_stmt|;
block|}
comment|/* 		 * No next block, just default. 		 */
else|else
name|gotbno
operator|=
name|NULLFSBLOCK
expr_stmt|;
comment|/* 		 * If both valid, pick the better one, else the only good 		 * one, else ap->rval is already set (to 0 or the inode block). 		 */
if|if
condition|(
name|prevbno
operator|!=
name|NULLFSBLOCK
operator|&&
name|gotbno
operator|!=
name|NULLFSBLOCK
condition|)
name|ap
operator|->
name|rval
operator|=
name|prevdiff
operator|<=
name|gotdiff
condition|?
name|prevbno
else|:
name|gotbno
expr_stmt|;
elseif|else
if|if
condition|(
name|prevbno
operator|!=
name|NULLFSBLOCK
condition|)
name|ap
operator|->
name|rval
operator|=
name|prevbno
expr_stmt|;
elseif|else
if|if
condition|(
name|gotbno
operator|!=
name|NULLFSBLOCK
condition|)
name|ap
operator|->
name|rval
operator|=
name|gotbno
expr_stmt|;
block|}
undef|#
directive|undef
name|ISVALID
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_bmap_rtalloc
parameter_list|(
name|xfs_bmalloca_t
modifier|*
name|ap
parameter_list|)
comment|/* bmap alloc argument struct */
block|{
name|xfs_alloctype_t
name|atype
init|=
literal|0
decl_stmt|;
comment|/* type for allocation routines */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount point structure */
name|xfs_extlen_t
name|prod
init|=
literal|0
decl_stmt|;
comment|/* product factor for allocators */
name|xfs_extlen_t
name|ralen
init|=
literal|0
decl_stmt|;
comment|/* realtime allocation length */
name|xfs_extlen_t
name|align
decl_stmt|;
comment|/* minimum allocation alignment */
name|xfs_rtblock_t
name|rtx
decl_stmt|;
comment|/* realtime extent number */
name|xfs_rtblock_t
name|rtb
decl_stmt|;
name|mp
operator|=
name|ap
operator|->
name|ip
operator|->
name|i_mount
expr_stmt|;
name|align
operator|=
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
condition|?
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
else|:
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|prod
operator|=
name|align
operator|/
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|error
operator|=
name|xfs_bmap_extsize_align
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|gotp
argument_list|,
name|ap
operator|->
name|prevp
argument_list|,
name|align
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|eof
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|conv
argument_list|,
operator|&
name|ap
operator|->
name|off
argument_list|,
operator|&
name|ap
operator|->
name|alen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|alen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|alen
operator|%
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the offset& length are not perfectly aligned 	 * then kill prod, it will just get us in trouble. 	 */
if|if
condition|(
name|do_mod
argument_list|(
name|ap
operator|->
name|off
argument_list|,
name|align
argument_list|)
operator|||
name|ap
operator|->
name|alen
operator|%
name|align
condition|)
name|prod
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Set ralen to be the actual requested length in rtextents. 	 */
name|ralen
operator|=
name|ap
operator|->
name|alen
operator|/
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
comment|/* 	 * If the old value was close enough to MAXEXTLEN that 	 * we rounded up to it, cut it back so it's valid again. 	 * Note that if it's a really large request (bigger than 	 * MAXEXTLEN), we don't hear about that number, and can't 	 * adjust the starting point to match it. 	 */
if|if
condition|(
name|ralen
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|>=
name|MAXEXTLEN
condition|)
name|ralen
operator|=
name|MAXEXTLEN
operator|/
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
comment|/* 	 * If it's an allocation to an empty file at offset 0, 	 * pick an extent that will space things out in the rt area. 	 */
if|if
condition|(
name|ap
operator|->
name|eof
operator|&&
name|ap
operator|->
name|off
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_rtpick_extent
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|tp
argument_list|,
name|ralen
argument_list|,
operator|&
name|rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ap
operator|->
name|rval
operator|=
name|rtx
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|rval
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_bmap_adjacent
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * Realtime allocation, done through xfs_rtallocate_extent. 	 */
name|atype
operator|=
name|ap
operator|->
name|rval
operator|==
literal|0
condition|?
name|XFS_ALLOCTYPE_ANY_AG
else|:
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
name|do_div
argument_list|(
name|ap
operator|->
name|rval
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
expr_stmt|;
name|rtb
operator|=
name|ap
operator|->
name|rval
expr_stmt|;
name|ap
operator|->
name|alen
operator|=
name|ralen
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_rtallocate_extent
argument_list|(
name|ap
operator|->
name|tp
argument_list|,
name|ap
operator|->
name|rval
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|alen
argument_list|,
operator|&
name|ralen
argument_list|,
name|atype
argument_list|,
name|ap
operator|->
name|wasdel
argument_list|,
name|prod
argument_list|,
operator|&
name|rtb
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|rtb
operator|==
name|NULLFSBLOCK
operator|&&
name|prod
operator|>
literal|1
operator|&&
operator|(
name|error
operator|=
name|xfs_rtallocate_extent
argument_list|(
name|ap
operator|->
name|tp
argument_list|,
name|ap
operator|->
name|rval
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|alen
argument_list|,
operator|&
name|ralen
argument_list|,
name|atype
argument_list|,
name|ap
operator|->
name|wasdel
argument_list|,
literal|1
argument_list|,
operator|&
name|rtb
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|ap
operator|->
name|rval
operator|=
name|rtb
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|rval
operator|!=
name|NULLFSBLOCK
condition|)
block|{
name|ap
operator|->
name|rval
operator|*=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|ralen
operator|*=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|ap
operator|->
name|alen
operator|=
name|ralen
expr_stmt|;
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|+=
name|ralen
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|ap
operator|->
name|tp
argument_list|,
name|ap
operator|->
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|wasdel
condition|)
name|ap
operator|->
name|ip
operator|->
name|i_delayed_blks
operator|-=
name|ralen
expr_stmt|;
comment|/* 		 * Adjust the disk quota also. This was reserved 		 * earlier. 		 */
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|tp
argument_list|,
name|ap
operator|->
name|ip
argument_list|,
name|ap
operator|->
name|wasdel
condition|?
name|XFS_TRANS_DQ_DELRTBCOUNT
else|:
name|XFS_TRANS_DQ_RTBCOUNT
argument_list|,
operator|(
name|long
operator|)
name|ralen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|alen
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_bmap_btalloc
parameter_list|(
name|xfs_bmalloca_t
modifier|*
name|ap
parameter_list|)
comment|/* bmap alloc argument struct */
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount point structure */
name|xfs_alloctype_t
name|atype
init|=
literal|0
decl_stmt|;
comment|/* type for allocation routines */
name|xfs_extlen_t
name|align
decl_stmt|;
comment|/* minimum allocation alignment */
name|xfs_agnumber_t
name|ag
decl_stmt|;
name|xfs_agnumber_t
name|fb_agno
decl_stmt|;
comment|/* ag number of ap->firstblock */
name|xfs_agnumber_t
name|startag
decl_stmt|;
name|xfs_alloc_arg_t
name|args
decl_stmt|;
name|xfs_extlen_t
name|blen
decl_stmt|;
name|xfs_extlen_t
name|delta
decl_stmt|;
name|xfs_extlen_t
name|longest
decl_stmt|;
name|xfs_extlen_t
name|need
decl_stmt|;
name|xfs_extlen_t
name|nextminlen
init|=
literal|0
decl_stmt|;
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
name|int
name|nullfb
decl_stmt|;
comment|/* true if ap->firstblock isn't set */
name|int
name|isaligned
decl_stmt|;
name|int
name|notinit
decl_stmt|;
name|int
name|tryagain
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mp
operator|=
name|ap
operator|->
name|ip
operator|->
name|i_mount
expr_stmt|;
name|align
operator|=
operator|(
name|ap
operator|->
name|userdata
operator|&&
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|&&
operator|(
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_EXTSIZE
operator|)
operator|)
condition|?
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|align
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_bmap_extsize_align
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|gotp
argument_list|,
name|ap
operator|->
name|prevp
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|eof
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|conv
argument_list|,
operator|&
name|ap
operator|->
name|off
argument_list|,
operator|&
name|ap
operator|->
name|alen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|alen
argument_list|)
expr_stmt|;
block|}
name|nullfb
operator|=
name|ap
operator|->
name|firstblock
operator|==
name|NULLFSBLOCK
expr_stmt|;
name|fb_agno
operator|=
name|nullfb
condition|?
name|NULLAGNUMBER
else|:
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|firstblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullfb
condition|)
name|ap
operator|->
name|rval
operator|=
name|XFS_INO_TO_FSB
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
else|else
name|ap
operator|->
name|rval
operator|=
name|ap
operator|->
name|firstblock
expr_stmt|;
name|xfs_bmap_adjacent
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * If allowed, use ap->rval; otherwise must use firstblock since 	 * it's in the right allocation group. 	 */
if|if
condition|(
name|nullfb
operator|||
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|rval
argument_list|)
operator|==
name|fb_agno
condition|)
empty_stmt|;
else|else
name|ap
operator|->
name|rval
operator|=
name|ap
operator|->
name|firstblock
expr_stmt|;
comment|/* 	 * Normal allocation, done through xfs_alloc_vextent. 	 */
name|tryagain
operator|=
name|isaligned
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|tp
operator|=
name|ap
operator|->
name|tp
expr_stmt|;
name|args
operator|.
name|mp
operator|=
name|mp
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
name|ap
operator|->
name|rval
expr_stmt|;
name|args
operator|.
name|maxlen
operator|=
name|MIN
argument_list|(
name|ap
operator|->
name|alen
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
name|blen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nullfb
condition|)
block|{
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_START_BNO
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|ap
operator|->
name|total
expr_stmt|;
comment|/* 		 * Find the longest available space. 		 * We're going to try for the whole allocation at once. 		 */
name|startag
operator|=
name|ag
operator|=
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|args
operator|.
name|fsbno
argument_list|)
expr_stmt|;
name|notinit
operator|=
literal|0
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
while|while
condition|(
name|blen
operator|<
name|ap
operator|->
name|alen
condition|)
block|{
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|ag
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pag
operator|->
name|pagf_init
operator|&&
operator|(
name|error
operator|=
name|xfs_alloc_pagf_init
argument_list|(
name|mp
argument_list|,
name|args
operator|.
name|tp
argument_list|,
name|ag
argument_list|,
name|XFS_ALLOC_FLAG_TRYLOCK
argument_list|)
operator|)
condition|)
block|{
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 			 * See xfs_alloc_fix_freelist... 			 */
if|if
condition|(
name|pag
operator|->
name|pagf_init
condition|)
block|{
name|need
operator|=
name|XFS_MIN_FREELIST_PAG
argument_list|(
name|pag
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|delta
operator|=
name|need
operator|>
name|pag
operator|->
name|pagf_flcount
condition|?
name|need
operator|-
name|pag
operator|->
name|pagf_flcount
else|:
literal|0
expr_stmt|;
name|longest
operator|=
operator|(
name|pag
operator|->
name|pagf_longest
operator|>
name|delta
operator|)
condition|?
operator|(
name|pag
operator|->
name|pagf_longest
operator|-
name|delta
operator|)
else|:
operator|(
name|pag
operator|->
name|pagf_flcount
operator|>
literal|0
operator|||
name|pag
operator|->
name|pagf_longest
operator|>
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|blen
operator|<
name|longest
condition|)
name|blen
operator|=
name|longest
expr_stmt|;
block|}
else|else
name|notinit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|ag
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|)
name|ag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ag
operator|==
name|startag
condition|)
break|break;
block|}
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
comment|/* 		 * Since the above loop did a BUF_TRYLOCK, it is 		 * possible that there is space for this request. 		 */
if|if
condition|(
name|notinit
operator|||
name|blen
operator|<
name|ap
operator|->
name|minlen
condition|)
name|args
operator|.
name|minlen
operator|=
name|ap
operator|->
name|minlen
expr_stmt|;
comment|/* 		 * If the best seen length is less than the request 		 * length, use the best as the minimum. 		 */
elseif|else
if|if
condition|(
name|blen
operator|<
name|ap
operator|->
name|alen
condition|)
name|args
operator|.
name|minlen
operator|=
name|blen
expr_stmt|;
comment|/* 		 * Otherwise we've seen an extent as big as alen, 		 * use that as the minimum. 		 */
else|else
name|args
operator|.
name|minlen
operator|=
name|ap
operator|->
name|alen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|low
condition|)
block|{
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_FIRST_AG
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|args
operator|.
name|minlen
operator|=
name|ap
operator|->
name|minlen
expr_stmt|;
block|}
else|else
block|{
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|ap
operator|->
name|total
expr_stmt|;
name|args
operator|.
name|minlen
operator|=
name|ap
operator|->
name|minlen
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ap
operator|->
name|userdata
operator|&&
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|&&
operator|(
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_EXTSIZE
operator|)
argument_list|)
condition|)
block|{
name|args
operator|.
name|prod
operator|=
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
expr_stmt|;
if|if
condition|(
operator|(
name|args
operator|.
name|mod
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|do_mod
argument_list|(
name|ap
operator|->
name|off
argument_list|,
name|args
operator|.
name|prod
argument_list|)
operator|)
condition|)
name|args
operator|.
name|mod
operator|=
call|(
name|xfs_extlen_t
call|)
argument_list|(
name|args
operator|.
name|prod
operator|-
name|args
operator|.
name|mod
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|>=
name|NBPP
argument_list|)
condition|)
block|{
name|args
operator|.
name|prod
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|mod
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|args
operator|.
name|prod
operator|=
name|NBPP
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
if|if
condition|(
operator|(
name|args
operator|.
name|mod
operator|=
call|(
name|xfs_extlen_t
call|)
argument_list|(
name|do_mod
argument_list|(
name|ap
operator|->
name|off
argument_list|,
name|args
operator|.
name|prod
argument_list|)
argument_list|)
operator|)
condition|)
name|args
operator|.
name|mod
operator|=
call|(
name|xfs_extlen_t
call|)
argument_list|(
name|args
operator|.
name|prod
operator|-
name|args
operator|.
name|mod
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are not low on available data blocks, and the 	 * underlying logical volume manager is a stripe, and 	 * the file offset is zero then try to allocate data 	 * blocks on stripe unit boundary. 	 * NOTE: ap->aeof is only set if the allocation length 	 * is>= the stripe unit and the allocation offset is 	 * at the end of file. 	 */
if|if
condition|(
operator|!
name|ap
operator|->
name|low
operator|&&
name|ap
operator|->
name|aeof
condition|)
block|{
if|if
condition|(
operator|!
name|ap
operator|->
name|off
condition|)
block|{
name|args
operator|.
name|alignment
operator|=
name|mp
operator|->
name|m_dalign
expr_stmt|;
name|atype
operator|=
name|args
operator|.
name|type
expr_stmt|;
name|isaligned
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Adjust for alignment 			 */
if|if
condition|(
name|blen
operator|>
name|args
operator|.
name|alignment
operator|&&
name|blen
operator|<=
name|ap
operator|->
name|alen
condition|)
name|args
operator|.
name|minlen
operator|=
name|blen
operator|-
name|args
operator|.
name|alignment
expr_stmt|;
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * First try an exact bno allocation. 			 * If it fails then do a near or start bno 			 * allocation with alignment turned on. 			 */
name|atype
operator|=
name|args
operator|.
name|type
expr_stmt|;
name|tryagain
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_THIS_BNO
expr_stmt|;
name|args
operator|.
name|alignment
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Compute the minlen+alignment for the 			 * next case.  Set slop so that the value 			 * of minlen+alignment+slop doesn't go up 			 * between the calls. 			 */
if|if
condition|(
name|blen
operator|>
name|mp
operator|->
name|m_dalign
operator|&&
name|blen
operator|<=
name|ap
operator|->
name|alen
condition|)
name|nextminlen
operator|=
name|blen
operator|-
name|mp
operator|->
name|m_dalign
expr_stmt|;
else|else
name|nextminlen
operator|=
name|args
operator|.
name|minlen
expr_stmt|;
if|if
condition|(
name|nextminlen
operator|+
name|mp
operator|->
name|m_dalign
operator|>
name|args
operator|.
name|minlen
operator|+
literal|1
condition|)
name|args
operator|.
name|minalignslop
operator|=
name|nextminlen
operator|+
name|mp
operator|->
name|m_dalign
operator|-
name|args
operator|.
name|minlen
operator|-
literal|1
expr_stmt|;
else|else
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|args
operator|.
name|alignment
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
block|}
name|args
operator|.
name|minleft
operator|=
name|ap
operator|->
name|minleft
expr_stmt|;
name|args
operator|.
name|wasdel
operator|=
name|ap
operator|->
name|wasdel
expr_stmt|;
name|args
operator|.
name|isfl
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|userdata
operator|=
name|ap
operator|->
name|userdata
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|tryagain
operator|&&
name|args
operator|.
name|fsbno
operator|==
name|NULLFSBLOCK
condition|)
block|{
comment|/* 		 * Exact allocation failed. Now try with alignment 		 * turned on. 		 */
name|args
operator|.
name|type
operator|=
name|atype
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
name|ap
operator|->
name|rval
expr_stmt|;
name|args
operator|.
name|alignment
operator|=
name|mp
operator|->
name|m_dalign
expr_stmt|;
name|args
operator|.
name|minlen
operator|=
name|nextminlen
expr_stmt|;
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|isaligned
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|isaligned
operator|&&
name|args
operator|.
name|fsbno
operator|==
name|NULLFSBLOCK
condition|)
block|{
comment|/* 		 * allocation failed, so turn off alignment and 		 * try again. 		 */
name|args
operator|.
name|type
operator|=
name|atype
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
name|ap
operator|->
name|rval
expr_stmt|;
name|args
operator|.
name|alignment
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|args
operator|.
name|fsbno
operator|==
name|NULLFSBLOCK
operator|&&
name|nullfb
operator|&&
name|args
operator|.
name|minlen
operator|>
name|ap
operator|->
name|minlen
condition|)
block|{
name|args
operator|.
name|minlen
operator|=
name|ap
operator|->
name|minlen
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_START_BNO
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
name|ap
operator|->
name|rval
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|args
operator|.
name|fsbno
operator|==
name|NULLFSBLOCK
operator|&&
name|nullfb
condition|)
block|{
name|args
operator|.
name|fsbno
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_FIRST_AG
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|ap
operator|->
name|minlen
expr_stmt|;
name|args
operator|.
name|minleft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|ap
operator|->
name|low
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|.
name|fsbno
operator|!=
name|NULLFSBLOCK
condition|)
block|{
name|ap
operator|->
name|firstblock
operator|=
name|ap
operator|->
name|rval
operator|=
name|args
operator|.
name|fsbno
expr_stmt|;
name|ASSERT
argument_list|(
name|nullfb
operator|||
name|fb_agno
operator|==
name|args
operator|.
name|agno
operator|||
operator|(
name|ap
operator|->
name|low
operator|&&
name|fb_agno
operator|<
name|args
operator|.
name|agno
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|alen
operator|=
name|args
operator|.
name|len
expr_stmt|;
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|+=
name|args
operator|.
name|len
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|ap
operator|->
name|tp
argument_list|,
name|ap
operator|->
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|wasdel
condition|)
name|ap
operator|->
name|ip
operator|->
name|i_delayed_blks
operator|-=
name|args
operator|.
name|len
expr_stmt|;
comment|/* 		 * Adjust the disk quota also. This was reserved 		 * earlier. 		 */
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|mp
argument_list|,
name|ap
operator|->
name|tp
argument_list|,
name|ap
operator|->
name|ip
argument_list|,
name|ap
operator|->
name|wasdel
condition|?
name|XFS_TRANS_DQ_DELBCOUNT
else|:
name|XFS_TRANS_DQ_BCOUNT
argument_list|,
operator|(
name|long
operator|)
name|args
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|rval
operator|=
name|NULLFSBLOCK
expr_stmt|;
name|ap
operator|->
name|alen
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_bmap_alloc is called by xfs_bmapi to allocate an extent for a file.  * It figures out where to ask the underlying allocator to put the new extent.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_bmap_alloc
parameter_list|(
name|xfs_bmalloca_t
modifier|*
name|ap
parameter_list|)
comment|/* bmap alloc argument struct */
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|&&
name|ap
operator|->
name|userdata
condition|)
return|return
name|xfs_bmap_rtalloc
argument_list|(
name|ap
argument_list|)
return|;
return|return
name|xfs_bmap_btalloc
argument_list|(
name|ap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transform a btree format file with only one leaf node, where the  * extents list will fit in the inode, into an extents format file.  * Since the file extents are already in-core, all we have to do is  * give up the space for the btree root and pitch the leaf block.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_btree_to_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
comment|/* REFERENCED */
name|xfs_bmbt_block_t
modifier|*
name|cblock
decl_stmt|;
comment|/* child btree block */
name|xfs_fsblock_t
name|cbno
decl_stmt|;
comment|/* child block number */
name|xfs_buf_t
modifier|*
name|cbp
decl_stmt|;
comment|/* child block's buffer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork data */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount point structure */
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* ptr to block address */
name|xfs_bmbt_block_t
modifier|*
name|rblock
decl_stmt|;
comment|/* root btree block */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_BTREE
argument_list|)
expr_stmt|;
name|rblock
operator|=
name|ifp
operator|->
name|if_broot
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|rblock
operator|->
name|bb_level
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|rblock
operator|->
name|bb_numrecs
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BMAP_BROOT_MAXRECS
argument_list|(
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|pp
operator|=
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|rblock
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
operator|*
name|logflagsp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_lptr
argument_list|(
name|cur
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
endif|#
directive|endif
name|cbno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|cbno
argument_list|,
literal|0
argument_list|,
operator|&
name|cbp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|cblock
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_check_lblock
argument_list|(
name|cur
argument_list|,
name|cblock
argument_list|,
literal|0
argument_list|,
name|cbp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|xfs_bmap_add_free
argument_list|(
name|cbno
argument_list|,
literal|1
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|--
expr_stmt|;
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_TRANS_DQ_BCOUNT
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|xfs_trans_binval
argument_list|(
name|tp
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|bc_bufs
index|[
literal|0
index|]
operator|==
name|cbp
condition|)
name|cur
operator|->
name|bc_bufs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|xfs_iroot_realloc
argument_list|(
name|ip
argument_list|,
operator|-
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_broot
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFBROOT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|XFS_IFORK_FMT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
expr_stmt|;
operator|*
name|logflagsp
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Called by xfs_bmapi to update file extent records and the btree  * after removing space (or undoing a delayed allocation).  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_del_extent
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* current transaction pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* extent number to update/delete */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents to be freed */
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* if null, not a btree */
name|xfs_bmbt_irec_t
modifier|*
name|del
parameter_list|,
comment|/* data to remove from extents */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* Change made to incore extents */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
name|rsvd
parameter_list|)
comment|/* OK to allocate reserved blocks */
block|{
name|xfs_filblks_t
name|da_new
decl_stmt|;
comment|/* new delay-alloc indirect blocks */
name|xfs_filblks_t
name|da_old
decl_stmt|;
comment|/* old delay-alloc indirect blocks */
name|xfs_fsblock_t
name|del_endblock
init|=
literal|0
decl_stmt|;
comment|/* first block past del */
name|xfs_fileoff_t
name|del_endoff
decl_stmt|;
comment|/* first offset past del */
name|int
name|delay
decl_stmt|;
comment|/* current block is delayed allocated */
name|int
name|do_fx
decl_stmt|;
comment|/* free extent at end of routine */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* current extent entry pointer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|flags
decl_stmt|;
comment|/* inode logging flags */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_del_extent"
decl_stmt|;
endif|#
directive|endif
name|xfs_bmbt_irec_t
name|got
decl_stmt|;
comment|/* current extent entry */
name|xfs_fileoff_t
name|got_endoff
decl_stmt|;
comment|/* first offset past got */
name|int
name|i
decl_stmt|;
comment|/* temp state */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_filblks_t
name|nblks
decl_stmt|;
comment|/* quota/sb block count */
name|xfs_bmbt_irec_t
name|new
decl_stmt|;
comment|/* new record to be inserted */
comment|/* REFERENCED */
name|uint
name|qfield
decl_stmt|;
comment|/* quota field to update */
name|xfs_filblks_t
name|temp
decl_stmt|;
comment|/* for indirect length calculations */
name|xfs_filblks_t
name|temp2
decl_stmt|;
comment|/* for indirect length calculations */
name|XFS_STATS_INC
argument_list|(
name|xs_del_exlist
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|idx
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|idx
operator|<
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|del
operator|->
name|br_blockcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|got
operator|.
name|br_startoff
operator|<=
name|del
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|del_endoff
operator|=
name|del
operator|->
name|br_startoff
operator|+
name|del
operator|->
name|br_blockcount
expr_stmt|;
name|got_endoff
operator|=
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
expr_stmt|;
name|ASSERT
argument_list|(
name|got_endoff
operator|>=
name|del_endoff
argument_list|)
expr_stmt|;
name|delay
operator|=
name|ISNULLSTARTBLOCK
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ISNULLSTARTBLOCK
argument_list|(
name|del
operator|->
name|br_startblock
argument_list|)
operator|==
name|delay
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|qfield
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If deleting a real allocation, must free up the disk space. 	 */
if|if
condition|(
operator|!
name|delay
condition|)
block|{
name|flags
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
comment|/* 		 * Realtime allocation.  Free it and record di_nblocks update. 		 */
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
condition|)
block|{
name|xfs_fsblock_t
name|bno
decl_stmt|;
name|xfs_filblks_t
name|len
decl_stmt|;
name|ASSERT
argument_list|(
name|do_mod
argument_list|(
name|del
operator|->
name|br_blockcount
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|do_mod
argument_list|(
name|del
operator|->
name|br_startblock
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bno
operator|=
name|del
operator|->
name|br_startblock
expr_stmt|;
name|len
operator|=
name|del
operator|->
name|br_blockcount
expr_stmt|;
name|do_div
argument_list|(
name|bno
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
expr_stmt|;
name|do_div
argument_list|(
name|len
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_rtfree_extent
argument_list|(
name|ip
operator|->
name|i_transp
argument_list|,
name|bno
argument_list|,
operator|(
name|xfs_extlen_t
operator|)
name|len
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|do_fx
operator|=
literal|0
expr_stmt|;
name|nblks
operator|=
name|len
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|qfield
operator|=
name|XFS_TRANS_DQ_RTBCOUNT
expr_stmt|;
block|}
comment|/* 		 * Ordinary allocation. 		 */
else|else
block|{
name|do_fx
operator|=
literal|1
expr_stmt|;
name|nblks
operator|=
name|del
operator|->
name|br_blockcount
expr_stmt|;
name|qfield
operator|=
name|XFS_TRANS_DQ_BCOUNT
expr_stmt|;
block|}
comment|/* 		 * Set up del_endblock and cur for later. 		 */
name|del_endblock
operator|=
name|del
operator|->
name|br_startblock
operator|+
name|del
operator|->
name|br_blockcount
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|got
operator|.
name|br_startoff
argument_list|,
name|got
operator|.
name|br_startblock
argument_list|,
name|got
operator|.
name|br_blockcount
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|da_old
operator|=
name|da_new
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|da_old
operator|=
name|STARTBLOCKVAL
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|da_new
operator|=
literal|0
expr_stmt|;
name|nblks
operator|=
literal|0
expr_stmt|;
name|do_fx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Set flag value to use in switch statement. 	 * Left-contig is 2, right-contig is 1. 	 */
switch|switch
condition|(
operator|(
operator|(
name|got
operator|.
name|br_startoff
operator|==
name|del
operator|->
name|br_startoff
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|got_endoff
operator|==
name|del_endoff
operator|)
condition|)
block|{
case|case
literal|3
case|:
comment|/* 		 * Matches the whole extent.  Delete the entry. 		 */
name|xfs_bmap_trace_delete
argument_list|(
name|fname
argument_list|,
literal|"3"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_iext_remove
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|delay
condition|)
break|break;
name|XFS_IFORK_NEXT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|flags
operator||=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
operator|!
name|cur
condition|)
block|{
name|flags
operator||=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_delete
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 		 * Deleting the first part of the extent. 		 */
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"2"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startoff
argument_list|(
name|ep
argument_list|,
name|del_endoff
argument_list|)
expr_stmt|;
name|temp
operator|=
name|got
operator|.
name|br_blockcount
operator|-
name|del
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
name|temp
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
argument_list|,
name|da_old
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"2"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|da_new
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|del_endblock
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"2"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur
condition|)
block|{
name|flags
operator||=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|del_endoff
argument_list|,
name|del_endblock
argument_list|,
name|got
operator|.
name|br_blockcount
operator|-
name|del
operator|->
name|br_blockcount
argument_list|,
name|got
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|1
case|:
comment|/* 		 * Deleting the last part of the extent. 		 */
name|temp
operator|=
name|got
operator|.
name|br_blockcount
operator|-
name|del
operator|->
name|br_blockcount
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"1"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
name|temp
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
argument_list|,
name|da_old
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"1"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|da_new
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"1"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur
condition|)
block|{
name|flags
operator||=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|got
operator|.
name|br_startoff
argument_list|,
name|got
operator|.
name|br_startblock
argument_list|,
name|got
operator|.
name|br_blockcount
operator|-
name|del
operator|->
name|br_blockcount
argument_list|,
name|got
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * Deleting the middle of the extent. 		 */
name|temp
operator|=
name|del
operator|->
name|br_startoff
operator|-
name|got
operator|.
name|br_startoff
expr_stmt|;
name|xfs_bmap_trace_pre_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|new
operator|.
name|br_startoff
operator|=
name|del_endoff
expr_stmt|;
name|temp2
operator|=
name|got_endoff
operator|-
name|del_endoff
expr_stmt|;
name|new
operator|.
name|br_blockcount
operator|=
name|temp2
expr_stmt|;
name|new
operator|.
name|br_state
operator|=
name|got
operator|.
name|br_state
expr_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
block|{
name|new
operator|.
name|br_startblock
operator|=
name|del_endblock
expr_stmt|;
name|flags
operator||=
name|XFS_ILOG_CORE
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|got
operator|.
name|br_startoff
argument_list|,
name|got
operator|.
name|br_startblock
argument_list|,
name|temp
argument_list|,
name|got
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|cur
operator|->
name|bc_rec
operator|.
name|b
operator|=
name|new
expr_stmt|;
name|error
operator|=
name|xfs_bmbt_insert
argument_list|(
name|cur
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOSPC
condition|)
goto|goto
name|done
goto|;
comment|/* 				 * If get no-space back from btree insert, 				 * it tried a split, and we have a zero 				 * block reservation. 				 * Fix up our state and return the error. 				 */
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
comment|/* 					 * Reset the cursor, don't trust 					 * it after any insert operation. 					 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_lookup_eq
argument_list|(
name|cur
argument_list|,
name|got
operator|.
name|br_startoff
argument_list|,
name|got
operator|.
name|br_startblock
argument_list|,
name|temp
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* 					 * Update the btree record back 					 * to the original value. 					 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmbt_update
argument_list|(
name|cur
argument_list|,
name|got
operator|.
name|br_startoff
argument_list|,
name|got
operator|.
name|br_startblock
argument_list|,
name|got
operator|.
name|br_blockcount
argument_list|,
name|got
operator|.
name|br_state
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* 					 * Reset the extent record back 					 * to the original value. 					 */
name|xfs_bmbt_set_blockcount
argument_list|(
name|ep
argument_list|,
name|got
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ASSERT
argument_list|(
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
name|XFS_IFORK_NEXT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|new
operator|.
name|br_startblock
operator|=
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp2
argument_list|)
expr_stmt|;
name|da_new
operator|=
name|temp
operator|+
name|temp2
expr_stmt|;
while|while
condition|(
name|da_new
operator|>
name|da_old
condition|)
block|{
if|if
condition|(
name|temp
condition|)
block|{
name|temp
operator|--
expr_stmt|;
name|da_new
operator|--
expr_stmt|;
name|xfs_bmbt_set_startblock
argument_list|(
name|ep
argument_list|,
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|da_new
operator|==
name|da_old
condition|)
break|break;
if|if
condition|(
name|temp2
condition|)
block|{
name|temp2
operator|--
expr_stmt|;
name|da_new
operator|--
expr_stmt|;
name|new
operator|.
name|br_startblock
operator|=
name|NULLSTARTBLOCK
argument_list|(
operator|(
name|int
operator|)
name|temp2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"0"
argument_list|,
name|ip
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|new
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_iext_insert
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we need to, add to list of extents to delete. 	 */
if|if
condition|(
name|do_fx
condition|)
name|xfs_bmap_add_free
argument_list|(
name|del
operator|->
name|br_startblock
argument_list|,
name|del
operator|->
name|br_blockcount
argument_list|,
name|flist
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust inode # blocks in the file. 	 */
if|if
condition|(
name|nblks
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|-=
name|nblks
expr_stmt|;
comment|/* 	 * Adjust quota data. 	 */
if|if
condition|(
name|qfield
condition|)
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|qfield
argument_list|,
operator|(
name|long
operator|)
operator|-
name|nblks
argument_list|)
expr_stmt|;
comment|/* 	 * Account for change in delayed indirect blocks. 	 * Nothing to do for disk quota accounting here. 	 */
name|ASSERT
argument_list|(
name|da_old
operator|>=
name|da_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_old
operator|>
name|da_new
condition|)
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
call|(
name|int
call|)
argument_list|(
name|da_old
operator|-
name|da_new
argument_list|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
comment|/* DELTA: report the original extent. */
if|if
condition|(
name|delta
operator|->
name|xed_startoff
operator|>
name|got
operator|.
name|br_startoff
condition|)
name|delta
operator|->
name|xed_startoff
operator|=
name|got
operator|.
name|br_startoff
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|xed_blockcount
operator|<
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
condition|)
name|delta
operator|->
name|xed_blockcount
operator|=
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
expr_stmt|;
block|}
name|done
label|:
operator|*
name|logflagsp
operator|=
name|flags
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the entry "free" from the free item list.  Prev points to the  * previous entry, unless "free" is the head of the list.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_del_free
parameter_list|(
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* free item list header */
name|xfs_bmap_free_item_t
modifier|*
name|prev
parameter_list|,
comment|/* previous item on list, if any */
name|xfs_bmap_free_item_t
modifier|*
name|free
parameter_list|)
comment|/* list item to be freed */
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|xbfi_next
operator|=
name|free
operator|->
name|xbfi_next
expr_stmt|;
else|else
name|flist
operator|->
name|xbf_first
operator|=
name|free
operator|->
name|xbfi_next
expr_stmt|;
name|flist
operator|->
name|xbf_count
operator|--
expr_stmt|;
name|kmem_zone_free
argument_list|(
name|xfs_bmap_free_item_zone
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert an extents-format file into a btree-format file.  * The new file will have a root block (in the inode) and a single child block.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_extents_to_btree
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first-block-allocated */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* blocks freed in xaction */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|curp
parameter_list|,
comment|/* cursor returned to caller */
name|int
name|wasdel
parameter_list|,
comment|/* converting a delayed alloc */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_block_t
modifier|*
name|ablock
decl_stmt|;
comment|/* allocated (child) bt block */
name|xfs_buf_t
modifier|*
name|abp
decl_stmt|;
comment|/* buffer for ablock */
name|xfs_alloc_arg_t
name|args
decl_stmt|;
comment|/* allocation arguments */
name|xfs_bmbt_rec_t
modifier|*
name|arp
decl_stmt|;
comment|/* child record pointer */
name|xfs_bmbt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* btree root block */
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* bmap btree cursor */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record pointer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_extnum_t
name|i
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* extent record index */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_key_t
modifier|*
name|kp
decl_stmt|;
comment|/* root block key pointer */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of file extents */
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* root block address pointer */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_ext_max
operator|==
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make space in the inode incore. 	 */
name|xfs_iroot_realloc
argument_list|(
name|ip
argument_list|,
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFBROOT
expr_stmt|;
comment|/* 	 * Fill in the root. 	 */
name|block
operator|=
name|ifp
operator|->
name|if_broot
expr_stmt|;
name|block
operator|->
name|bb_magic
operator|=
name|cpu_to_be32
argument_list|(
name|XFS_BMAP_MAGIC
argument_list|)
expr_stmt|;
name|block
operator|->
name|bb_level
operator|=
name|cpu_to_be16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|block
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|block
operator|->
name|bb_leftsib
operator|=
name|cpu_to_be64
argument_list|(
name|NULLDFSBNO
argument_list|)
expr_stmt|;
name|block
operator|->
name|bb_rightsib
operator|=
name|cpu_to_be64
argument_list|(
name|NULLDFSBNO
argument_list|)
expr_stmt|;
comment|/* 	 * Need a cursor.  Can't allocate until bb_level is filled in. 	 */
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|XFS_BTNUM_BMAP
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|=
name|wasdel
condition|?
name|XFS_BTCUR_BPRV_WASDEL
else|:
literal|0
expr_stmt|;
comment|/* 	 * Convert to a btree with two levels, one record in root. 	 */
name|XFS_IFORK_FMT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_DINODE_FMT_BTREE
argument_list|)
expr_stmt|;
name|args
operator|.
name|tp
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|mp
operator|=
name|mp
expr_stmt|;
if|if
condition|(
operator|*
name|firstblock
operator|==
name|NULLFSBLOCK
condition|)
block|{
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_START_BNO
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
name|XFS_INO_TO_FSB
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flist
operator|->
name|xbf_low
condition|)
block|{
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_START_BNO
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
operator|*
name|firstblock
expr_stmt|;
block|}
else|else
block|{
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
name|args
operator|.
name|fsbno
operator|=
operator|*
name|firstblock
expr_stmt|;
block|}
name|args
operator|.
name|minlen
operator|=
name|args
operator|.
name|maxlen
operator|=
name|args
operator|.
name|prod
operator|=
literal|1
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|args
operator|.
name|minleft
operator|=
name|args
operator|.
name|alignment
operator|=
name|args
operator|.
name|mod
operator|=
name|args
operator|.
name|isfl
operator|=
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|wasdel
operator|=
name|wasdel
expr_stmt|;
operator|*
name|logflagsp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
block|{
name|xfs_iroot_realloc
argument_list|(
name|ip
argument_list|,
operator|-
literal|1
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Allocation can't fail, the space was reserved. 	 */
name|ASSERT
argument_list|(
name|args
operator|.
name|fsbno
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|firstblock
operator|==
name|NULLFSBLOCK
operator|||
name|args
operator|.
name|agno
operator|==
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
operator|*
name|firstblock
argument_list|)
operator|||
operator|(
name|flist
operator|->
name|xbf_low
operator|&&
name|args
operator|.
name|agno
operator|>
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
operator|*
name|firstblock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|firstblock
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
name|args
operator|.
name|fsbno
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|++
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|++
expr_stmt|;
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_TRANS_DQ_BCOUNT
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|abp
operator|=
name|xfs_btree_get_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|args
operator|.
name|fsbno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the child block. 	 */
name|ablock
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|abp
argument_list|)
expr_stmt|;
name|ablock
operator|->
name|bb_magic
operator|=
name|cpu_to_be32
argument_list|(
name|XFS_BMAP_MAGIC
argument_list|)
expr_stmt|;
name|ablock
operator|->
name|bb_level
operator|=
literal|0
expr_stmt|;
name|ablock
operator|->
name|bb_leftsib
operator|=
name|cpu_to_be64
argument_list|(
name|NULLDFSBNO
argument_list|)
expr_stmt|;
name|ablock
operator|->
name|bb_rightsib
operator|=
name|cpu_to_be64
argument_list|(
name|NULLDFSBNO
argument_list|)
expr_stmt|;
name|arp
operator|=
name|XFS_BMAP_REC_IADDR
argument_list|(
name|ablock
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nextents
condition|;
name|i
operator|++
control|)
block|{
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|xfs_bmbt_get_startblock
argument_list|(
name|ep
argument_list|)
argument_list|)
condition|)
block|{
name|arp
operator|->
name|l0
operator|=
name|INT_GET
argument_list|(
name|ep
operator|->
name|l0
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|arp
operator|->
name|l1
operator|=
name|INT_GET
argument_list|(
name|ep
operator|->
name|l1
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|arp
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|cnt
operator|==
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
argument_list|)
expr_stmt|;
name|ablock
operator|->
name|bb_numrecs
operator|=
name|cpu_to_be16
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the root key and pointer. 	 */
name|kp
operator|=
name|XFS_BMAP_KEY_IADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|arp
operator|=
name|XFS_BMAP_REC_IADDR
argument_list|(
name|ablock
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|kp
operator|->
name|br_startoff
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|xfs_bmbt_disk_get_startoff
argument_list|(
name|arp
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_BMAP_PTR_IADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|.
name|fsbno
argument_list|)
expr_stmt|;
comment|/* 	 * Do all this logging at the end so that 	 * the root is at the right level. 	 */
name|xfs_bmbt_log_block
argument_list|(
name|cur
argument_list|,
name|abp
argument_list|,
name|XFS_BB_ALL_BITS
argument_list|)
expr_stmt|;
name|xfs_bmbt_log_recs
argument_list|(
name|cur
argument_list|,
name|abp
argument_list|,
literal|1
argument_list|,
name|be16_to_cpu
argument_list|(
name|ablock
operator|->
name|bb_numrecs
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|curp
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|curp
operator|=
name|cur
expr_stmt|;
operator|*
name|logflagsp
operator|=
name|XFS_ILOG_CORE
operator||
name|XFS_ILOG_FBROOT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Helper routine to reset inode di_forkoff field when switching  * attribute fork from local to extent format - we reset it where  * possible to make space available for inline data fork extents.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_forkoff_reset
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
if|if
condition|(
name|whichfork
operator|==
name|XFS_ATTR_FORK
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_DEV
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_UUID
operator|)
operator|&&
operator|(
operator|(
name|mp
operator|->
name|m_attroffset
operator|>>
literal|3
operator|)
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|)
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|mp
operator|->
name|m_attroffset
operator|>>
literal|3
expr_stmt|;
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|->
name|if_ext_max
operator|=
name|XFS_IFORK_ASIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert a local file to an extents file.  * This code is out of bounds for data forks of regular files,  * since the file data needs to get logged so things will stay consistent.  * (The bmap-level manipulations are ok, though).  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_local_to_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first block allocated in xaction */
name|xfs_extlen_t
name|total
parameter_list|,
comment|/* total blocks needed by transaction */
name|int
modifier|*
name|logflagsp
parameter_list|,
comment|/* inode logging flags */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|flags
decl_stmt|;
comment|/* logging flags returned */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_local_to_extents"
decl_stmt|;
endif|#
directive|endif
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
comment|/* 	 * We don't want to deal with the case of keeping inode data inline yet. 	 * So sending the data fork of a regular inode is invalid. 	 */
name|ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|&&
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bytes
condition|)
block|{
name|xfs_alloc_arg_t
name|args
decl_stmt|;
comment|/* allocation arguments */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for extent block */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record pointer */
name|args
operator|.
name|tp
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|XFS_IFINLINE
operator||
name|XFS_IFEXTENTS
operator||
name|XFS_IFEXTIREC
operator|)
operator|)
operator|==
name|XFS_IFINLINE
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate a block.  We know we need only one, since the 		 * file currently fits in an inode. 		 */
if|if
condition|(
operator|*
name|firstblock
operator|==
name|NULLFSBLOCK
condition|)
block|{
name|args
operator|.
name|fsbno
operator|=
name|XFS_INO_TO_FSB
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_START_BNO
expr_stmt|;
block|}
else|else
block|{
name|args
operator|.
name|fsbno
operator|=
operator|*
name|firstblock
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|XFS_ALLOCTYPE_NEAR_BNO
expr_stmt|;
block|}
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|mod
operator|=
name|args
operator|.
name|minleft
operator|=
name|args
operator|.
name|alignment
operator|=
name|args
operator|.
name|wasdel
operator|=
name|args
operator|.
name|isfl
operator|=
name|args
operator|.
name|minalignslop
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|minlen
operator|=
name|args
operator|.
name|maxlen
operator|=
name|args
operator|.
name|prod
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_alloc_vextent
argument_list|(
operator|&
name|args
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* 		 * Can't fail, the space was reserved. 		 */
name|ASSERT
argument_list|(
name|args
operator|.
name|fsbno
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|.
name|len
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|*
name|firstblock
operator|=
name|args
operator|.
name|fsbno
expr_stmt|;
name|bp
operator|=
name|xfs_btree_get_bufl
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|tp
argument_list|,
name|args
operator|.
name|fsbno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_u1
operator|.
name|if_data
argument_list|,
name|ifp
operator|->
name|if_bytes
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|ifp
operator|->
name|if_bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_bmap_forkoff_reset
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_idata_realloc
argument_list|(
name|ip
argument_list|,
operator|-
name|ifp
operator|->
name|if_bytes
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_iext_add
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_allf
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
name|args
operator|.
name|fsbno
argument_list|,
literal|1
argument_list|,
name|XFS_EXT_NORM
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_post_update
argument_list|(
name|fname
argument_list|,
literal|"new"
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|XFS_IFORK_NEXT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|=
literal|1
expr_stmt|;
name|XFS_TRANS_MOD_DQUOT_BYINO
argument_list|(
name|args
operator|.
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_TRANS_DQ_BCOUNT
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|flags
operator||=
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xfs_bmap_forkoff_reset
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|XFS_IFINLINE
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|XFS_IFEXTENTS
expr_stmt|;
name|XFS_IFORK_FMT_SET
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|,
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
expr_stmt|;
name|flags
operator||=
name|XFS_ILOG_CORE
expr_stmt|;
name|done
label|:
operator|*
name|logflagsp
operator|=
name|flags
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Search the extent records for the entry containing block bno.  * If bno lies in a hole, point to the next entry.  If bno lies  * past eof, *eofp will be set, and *prevp will contain the last  * entry (null if none).  Else, *lastxp will be set to the index  * of the found entry; *gotp will contain the entry.  */
end_comment

begin_function
name|xfs_bmbt_rec_t
modifier|*
comment|/* pointer to found extent entry */
name|xfs_bmap_search_multi_extents
parameter_list|(
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
comment|/* inode fork pointer */
name|xfs_fileoff_t
name|bno
parameter_list|,
comment|/* block number searched for */
name|int
modifier|*
name|eofp
parameter_list|,
comment|/* out: end of file found */
name|xfs_extnum_t
modifier|*
name|lastxp
parameter_list|,
comment|/* out: last extent index */
name|xfs_bmbt_irec_t
modifier|*
name|gotp
parameter_list|,
comment|/* out: extent entry found */
name|xfs_bmbt_irec_t
modifier|*
name|prevp
parameter_list|)
comment|/* out: previous extent entry found */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record pointer */
name|xfs_extnum_t
name|lastx
decl_stmt|;
comment|/* last extent index */
comment|/* 	 * Initialize the extent entry structure to catch access to 	 * uninitialized br_startblock field. 	 */
name|gotp
operator|->
name|br_startoff
operator|=
literal|0xffa5a5a5a5a5a5a5LL
expr_stmt|;
name|gotp
operator|->
name|br_blockcount
operator|=
literal|0xa55a5a5a5a5a5a5aLL
expr_stmt|;
name|gotp
operator|->
name|br_state
operator|=
name|XFS_EXT_INVALID
expr_stmt|;
if|#
directive|if
name|XFS_BIG_BLKNOS
name|gotp
operator|->
name|br_startblock
operator|=
literal|0xffffa5a5a5a5a5a5LL
expr_stmt|;
else|#
directive|else
name|gotp
operator|->
name|br_startblock
operator|=
literal|0xffffa5a5
expr_stmt|;
endif|#
directive|endif
name|prevp
operator|->
name|br_startoff
operator|=
name|NULLFILEOFF
expr_stmt|;
name|ep
operator|=
name|xfs_iext_bno_to_ext
argument_list|(
name|ifp
argument_list|,
name|bno
argument_list|,
operator|&
name|lastx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastx
operator|>
literal|0
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
operator|-
literal|1
argument_list|)
argument_list|,
name|prevp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastx
operator|<
operator|(
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|)
condition|)
block|{
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
name|gotp
argument_list|)
expr_stmt|;
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lastx
operator|>
literal|0
condition|)
block|{
operator|*
name|gotp
operator|=
operator|*
name|prevp
expr_stmt|;
block|}
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|lastxp
operator|=
name|lastx
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_comment
comment|/*  * Search the extents list for the inode, for the extent containing bno.  * If bno lies in a hole, point to the next entry.  If bno lies past eof,  * *eofp will be set, and *prevp will contain the last entry (null if none).  * Else, *lastxp will be set to the index of the found  * entry; *gotp will contain the entry.  */
end_comment

begin_function
name|STATIC
name|xfs_bmbt_rec_t
modifier|*
comment|/* pointer to found extent entry */
name|xfs_bmap_search_extents
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fileoff_t
name|bno
parameter_list|,
comment|/* block number searched for */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
modifier|*
name|eofp
parameter_list|,
comment|/* out: end of file found */
name|xfs_extnum_t
modifier|*
name|lastxp
parameter_list|,
comment|/* out: last extent index */
name|xfs_bmbt_irec_t
modifier|*
name|gotp
parameter_list|,
comment|/* out: extent entry found */
name|xfs_bmbt_irec_t
modifier|*
name|prevp
parameter_list|)
comment|/* out: previous extent entry found */
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record pointer */
name|int
name|rt
decl_stmt|;
comment|/* realtime flag    */
name|XFS_STATS_INC
argument_list|(
name|xs_look_exlist
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_bmap_search_multi_extents
argument_list|(
name|ifp
argument_list|,
name|bno
argument_list|,
name|eofp
argument_list|,
name|lastxp
argument_list|,
name|gotp
argument_list|,
name|prevp
argument_list|)
expr_stmt|;
name|rt
operator|=
operator|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|)
operator|&&
name|XFS_IS_REALTIME_INODE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rt
operator|&&
operator|!
name|gotp
operator|->
name|br_startblock
operator|&&
operator|(
operator|*
name|lastxp
operator|!=
name|NULLEXTNUM
operator|)
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"Access to block zero: fs:<%s> inode: %lld "
literal|"start_block : %llx start_off : %llx blkcnt : %llx "
literal|"extent-state : %x \n"
argument_list|,
operator|(
name|ip
operator|->
name|i_mount
operator|)
operator|->
name|m_fsname
argument_list|,
operator|(
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|gotp
operator|->
name|br_startblock
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|gotp
operator|->
name|br_startoff
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|gotp
operator|->
name|br_blockcount
argument_list|,
name|gotp
operator|->
name|br_state
argument_list|)
expr_stmt|;
block|}
return|return
name|ep
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
end_ifdef

begin_decl_stmt
name|ktrace_t
modifier|*
name|xfs_bmap_trace_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add a bmap trace buffer entry.  Base routine for the others.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_trace_addentry
parameter_list|(
name|int
name|opcode
parameter_list|,
comment|/* operation */
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry(ies) */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries, 1 or 2 */
name|xfs_bmbt_rec_t
modifier|*
name|r1
parameter_list|,
comment|/* first record */
name|xfs_bmbt_rec_t
modifier|*
name|r2
parameter_list|,
comment|/* second record or null */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
name|tr2
decl_stmt|;
name|ASSERT
argument_list|(
name|cnt
operator|==
literal|1
operator|||
name|cnt
operator|==
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|r1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|r2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|r2
operator|=
operator|&
name|tr2
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tr2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ASSERT
argument_list|(
name|r2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ktrace_enter
argument_list|(
name|xfs_bmap_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|opcode
operator||
operator|(
name|whichfork
operator|<<
literal|16
operator|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fname
argument_list|,
operator|(
name|void
operator|*
operator|)
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|idx
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|cnt
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|ip
operator|->
name|i_ino
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
operator|(
name|unsigned
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r1
operator|->
name|l0
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r1
operator|->
name|l0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r1
operator|->
name|l1
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r1
operator|->
name|l1
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r2
operator|->
name|l0
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r2
operator|->
name|l0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r2
operator|->
name|l1
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r2
operator|->
name|l1
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_xtrace
argument_list|)
expr_stmt|;
name|ktrace_enter
argument_list|(
name|ip
operator|->
name|i_xtrace
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|opcode
operator||
operator|(
name|whichfork
operator|<<
literal|16
operator|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fname
argument_list|,
operator|(
name|void
operator|*
operator|)
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|idx
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|cnt
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|ip
operator|->
name|i_ino
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psunsigned_t
operator|)
operator|(
name|unsigned
operator|)
name|ip
operator|->
name|i_ino
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r1
operator|->
name|l0
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r1
operator|->
name|l0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r1
operator|->
name|l1
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r1
operator|->
name|l1
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r2
operator|->
name|l0
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r2
operator|->
name|l0
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|r2
operator|->
name|l1
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psunsigned_t
call|)
argument_list|(
name|unsigned
argument_list|)
argument_list|(
name|r2
operator|->
name|l1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add bmap trace entry prior to a call to xfs_iext_remove.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_trace_delete
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry(entries) deleted */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries deleted, 1 or 2 */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_addentry
argument_list|(
name|XFS_BMAP_KTRACE_DELETE
argument_list|,
name|fname
argument_list|,
name|desc
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|cnt
argument_list|,
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
argument_list|,
name|cnt
operator|==
literal|2
condition|?
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
literal|1
argument_list|)
else|:
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add bmap trace entry prior to a call to xfs_iext_insert, or  * reading in the extents list from the disk (in the btree).  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_trace_insert
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry(entries) inserted */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries inserted, 1 or 2 */
name|xfs_bmbt_irec_t
modifier|*
name|r1
parameter_list|,
comment|/* inserted record 1 */
name|xfs_bmbt_irec_t
modifier|*
name|r2
parameter_list|,
comment|/* inserted record 2 or null */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
name|tr1
decl_stmt|;
comment|/* compressed record 1 */
name|xfs_bmbt_rec_t
name|tr2
decl_stmt|;
comment|/* compressed record 2 if needed */
name|xfs_bmbt_set_all
argument_list|(
operator|&
name|tr1
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|2
condition|)
block|{
name|ASSERT
argument_list|(
name|r2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xfs_bmbt_set_all
argument_list|(
operator|&
name|tr2
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|cnt
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|r2
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|xfs_bmap_trace_addentry
argument_list|(
name|XFS_BMAP_KTRACE_INSERT
argument_list|,
name|fname
argument_list|,
name|desc
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
name|cnt
argument_list|,
operator|&
name|tr1
argument_list|,
name|cnt
operator|==
literal|2
condition|?
operator|&
name|tr2
else|:
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add bmap trace entry after updating an extent record in place.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_trace_post_update
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry updated */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_addentry
argument_list|(
name|XFS_BMAP_KTRACE_POST_UP
argument_list|,
name|fname
argument_list|,
name|desc
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add bmap trace entry prior to updating an extent record in place.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_trace_pre_update
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|char
modifier|*
name|desc
parameter_list|,
comment|/* operation description */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|idx
parameter_list|,
comment|/* index of entry to be updated */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_addentry
argument_list|(
name|XFS_BMAP_KTRACE_PRE_UP
argument_list|,
name|fname
argument_list|,
name|desc
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_BMAP_TRACE */
end_comment

begin_comment
comment|/*  * Compute the worst-case number of indirect blocks that will be used  * for ip's delayed extent of length "len".  */
end_comment

begin_function
name|STATIC
name|xfs_filblks_t
name|xfs_bmap_worst_indlen
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_filblks_t
name|len
parameter_list|)
comment|/* delayed extent length */
block|{
name|int
name|level
decl_stmt|;
comment|/* btree level number */
name|int
name|maxrecs
decl_stmt|;
comment|/* maximum record count at this level */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_filblks_t
name|rval
decl_stmt|;
comment|/* return value */
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|maxrecs
operator|=
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|0
operator|,
name|rval
operator|=
literal|0
init|;
name|level
operator|<
name|XFS_BM_MAXLEVELS
argument_list|(
name|mp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|;
name|level
operator|++
control|)
block|{
name|len
operator|+=
name|maxrecs
operator|-
literal|1
expr_stmt|;
name|do_div
argument_list|(
name|len
argument_list|,
name|maxrecs
argument_list|)
expr_stmt|;
name|rval
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
name|rval
operator|+
name|XFS_BM_MAXLEVELS
argument_list|(
name|mp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|-
name|level
operator|-
literal|1
return|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|maxrecs
operator|=
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_RW_TRACE
argument_list|)
end_if

begin_function
name|STATIC
name|void
name|xfs_bunmap_trace
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_fileoff_t
name|bno
parameter_list|,
name|xfs_filblks_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|inst_t
modifier|*
name|ra
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_rwtrace
operator|==
name|NULL
condition|)
return|return;
name|ktrace_enter
argument_list|(
name|ip
operator|->
name|i_rwtrace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|XFS_BUNMAP
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
operator|(
operator|(
name|xfs_dfiloff_t
operator|)
name|bno
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
operator|(
name|xfs_dfiloff_t
operator|)
name|bno
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|__psint_t
operator|)
name|flags
argument_list|,
operator|(
name|void
operator|*
operator|)
name|current_cpu
argument_list|()
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ra
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert inode from non-attributed to attributed.  * Must not be in a transaction, ip must not be locked.  */
end_comment

begin_function
name|int
comment|/* error code */
name|xfs_bmap_add_attrfork
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|int
name|size
parameter_list|,
comment|/* space new attribute needs */
name|int
name|rsvd
parameter_list|)
comment|/* xact may use reserved blks */
block|{
name|xfs_fsblock_t
name|firstblock
decl_stmt|;
comment|/* 1st block/ag allocated */
name|xfs_bmap_free_t
name|flist
decl_stmt|;
comment|/* freed extent records */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|unsigned
name|long
name|s
decl_stmt|;
comment|/* spinlock spl value */
name|int
name|blks
decl_stmt|;
comment|/* space reservation */
name|int
name|version
init|=
literal|1
decl_stmt|;
comment|/* superblock attr version */
name|int
name|committed
decl_stmt|;
comment|/* xaction was committed */
name|int
name|logflags
decl_stmt|;
comment|/* logging flags */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|ASSERT
argument_list|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_NOT_DQATTACHED
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_ADDAFORK
argument_list|)
expr_stmt|;
name|blks
operator|=
name|XFS_ADDAFORK_SPACE_RES
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsvd
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|XFS_TRANS_RESERVE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|blks
argument_list|,
name|XFS_ADDAFORK_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ADDAFORK_LOG_COUNT
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|blks
argument_list|,
literal|0
argument_list|,
name|rsvd
condition|?
name|XFS_QMOPT_RES_REGBLKS
operator||
name|XFS_QMOPT_FORCE_RES
else|:
name|XFS_QMOPT_RES_REGBLKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
condition|)
goto|goto
name|error1
goto|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_EXTENTS
condition|)
block|{
comment|/* 		 * For inodes coming from pre-6.2 filesystems. 		 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|=
name|XFS_DINODE_FMT_EXTENTS
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_DEV
case|:
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_dev_t
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_UUID
case|:
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|xfs_attr_shortform_bytesfit
argument_list|(
name|ip
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_forkoff
operator|=
name|mp
operator|->
name|m_attroffset
operator|>>
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
condition|)
name|version
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|=
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_afp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_ifork_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|->
name|if_ext_max
operator|=
name|XFS_IFORK_ASIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_afp
operator|->
name|if_flags
operator|=
name|XFS_IFEXTENTS
expr_stmt|;
name|logflags
operator|=
literal|0
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|flist
argument_list|,
operator|&
name|firstblock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
name|error
operator|=
name|xfs_bmap_add_attrfork_local
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|firstblock
argument_list|,
operator|&
name|flist
argument_list|,
operator|&
name|logflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
name|error
operator|=
name|xfs_bmap_add_attrfork_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|firstblock
argument_list|,
operator|&
name|flist
argument_list|,
operator|&
name|logflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|error
operator|=
name|xfs_bmap_add_attrfork_btree
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|firstblock
argument_list|,
operator|&
name|flist
argument_list|,
operator|&
name|logflags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|logflags
condition|)
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|logflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error2
goto|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASATTR
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|||
operator|(
operator|!
name|XFS_SB_VERSION_HASATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
name|version
operator|==
literal|2
operator|)
condition|)
block|{
name|__int64_t
name|sbfields
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASATTR
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|XFS_SB_VERSION_ADDATTR
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
expr_stmt|;
name|sbfields
operator||=
name|XFS_SB_VERSIONNUM
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
name|version
operator|==
literal|2
condition|)
block|{
name|XFS_SB_VERSION_ADDATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
expr_stmt|;
name|sbfields
operator||=
operator|(
name|XFS_SB_VERSIONNUM
operator||
name|XFS_SB_FEATURES2
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sbfields
condition|)
block|{
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_mod_sb
argument_list|(
name|tp
argument_list|,
name|sbfields
argument_list|)
expr_stmt|;
block|}
else|else
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|flist
argument_list|,
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
operator|)
condition|)
goto|goto
name|error2
goto|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|error2
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|flist
argument_list|)
expr_stmt|;
name|error1
label|:
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error0
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Add the extent to the list of extents to be free at transaction end.  * The list is maintained sorted (by block number).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_bmap_add_free
parameter_list|(
name|xfs_fsblock_t
name|bno
parameter_list|,
comment|/* fs block number of extent */
name|xfs_filblks_t
name|len
parameter_list|,
comment|/* length of extent */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* list of extents */
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
comment|/* mount point structure */
block|{
name|xfs_bmap_free_item_t
modifier|*
name|cur
decl_stmt|;
comment|/* current (next) element */
name|xfs_bmap_free_item_t
modifier|*
name|new
decl_stmt|;
comment|/* new element */
name|xfs_bmap_free_item_t
modifier|*
name|prev
decl_stmt|;
comment|/* previous element */
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|xfs_agblock_t
name|agbno
decl_stmt|;
name|ASSERT
argument_list|(
name|bno
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|<=
name|MAXEXTLEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|bno
argument_list|)
argument_list|)
expr_stmt|;
name|agno
operator|=
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|agbno
operator|=
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agbno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agbno
operator|+
name|len
operator|<=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|xfs_bmap_free_item_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|=
name|kmem_zone_alloc
argument_list|(
name|xfs_bmap_free_item_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new
operator|->
name|xbfi_startblock
operator|=
name|bno
expr_stmt|;
name|new
operator|->
name|xbfi_blockcount
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|len
expr_stmt|;
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|cur
operator|=
name|flist
operator|->
name|xbf_first
init|;
name|cur
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|cur
operator|,
name|cur
operator|=
name|cur
operator|->
name|xbfi_next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|xbfi_startblock
operator|>=
name|bno
condition|)
break|break;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|xbfi_next
operator|=
name|new
expr_stmt|;
else|else
name|flist
operator|->
name|xbf_first
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|xbfi_next
operator|=
name|cur
expr_stmt|;
name|flist
operator|->
name|xbf_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute and fill in the value of the maximum depth of a bmap btree  * in this filesystem.  Done once, during mount.  */
end_comment

begin_function
name|void
name|xfs_bmap_compute_maxlevels
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|int
name|level
decl_stmt|;
comment|/* btree level */
name|uint
name|maxblocks
decl_stmt|;
comment|/* max blocks at this level */
name|uint
name|maxleafents
decl_stmt|;
comment|/* max leaf entries possible */
name|int
name|maxrootrecs
decl_stmt|;
comment|/* max records in root block */
name|int
name|minleafrecs
decl_stmt|;
comment|/* min records in leaf block */
name|int
name|minnoderecs
decl_stmt|;
comment|/* min records in node block */
name|int
name|sz
decl_stmt|;
comment|/* root block size */
comment|/* 	 * The maximum number of extents in a file, hence the maximum 	 * number of leaf entries, is controlled by the type of di_nextents 	 * (a signed 32-bit number, xfs_extnum_t), or by di_anextents 	 * (a signed 16-bit number, xfs_aextnum_t). 	 */
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
condition|)
block|{
name|maxleafents
operator|=
name|MAXEXTNUM
expr_stmt|;
name|sz
operator|=
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
condition|?
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|MINDBTPTRS
argument_list|)
else|:
name|mp
operator|->
name|m_attroffset
expr_stmt|;
block|}
else|else
block|{
name|maxleafents
operator|=
name|MAXAEXTNUM
expr_stmt|;
name|sz
operator|=
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
condition|?
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|MINABTPTRS
argument_list|)
else|:
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodesize
operator|-
name|mp
operator|->
name|m_attroffset
expr_stmt|;
block|}
name|maxrootrecs
operator|=
operator|(
name|int
operator|)
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sz
argument_list|,
name|xfs_bmdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minleafrecs
operator|=
name|mp
operator|->
name|m_bmap_dmnr
index|[
literal|0
index|]
expr_stmt|;
name|minnoderecs
operator|=
name|mp
operator|->
name|m_bmap_dmnr
index|[
literal|1
index|]
expr_stmt|;
name|maxblocks
operator|=
operator|(
name|maxleafents
operator|+
name|minleafrecs
operator|-
literal|1
operator|)
operator|/
name|minleafrecs
expr_stmt|;
for|for
control|(
name|level
operator|=
literal|1
init|;
name|maxblocks
operator|>
literal|1
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|maxblocks
operator|<=
name|maxrootrecs
condition|)
name|maxblocks
operator|=
literal|1
expr_stmt|;
else|else
name|maxblocks
operator|=
operator|(
name|maxblocks
operator|+
name|minnoderecs
operator|-
literal|1
operator|)
operator|/
name|minnoderecs
expr_stmt|;
block|}
name|mp
operator|->
name|m_bm_maxlevels
index|[
name|whichfork
index|]
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to be called at transaction's end by xfs_bmapi, xfs_bunmapi  * caller.  Frees all the extents that need freeing, which must be done  * last due to locking considerations.  We never free any extents in  * the first transaction.  This is to allow the caller to make the first  * transaction a synchronous one so that the pointers to the data being  * broken in this transaction will be permanent before the data is actually  * freed.  This is necessary to prevent blocks from being reallocated  * and written to before the free and reallocation are actually permanent.  * We do not just make the first transaction synchronous here, because  * there are more efficient ways to gain the same protection in some cases  * (see the file truncation code).  *  * Return 1 if the given transaction was committed and a new one  * started, and 0 otherwise in the committed parameter.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_finish
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer addr */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* i/o: list extents to free */
name|xfs_fsblock_t
name|firstblock
parameter_list|,
comment|/* controlled ag for allocs */
name|int
modifier|*
name|committed
parameter_list|)
comment|/* xact committed or not */
block|{
name|xfs_efd_log_item_t
modifier|*
name|efd
decl_stmt|;
comment|/* extent free data */
name|xfs_efi_log_item_t
modifier|*
name|efi
decl_stmt|;
comment|/* extent free intention */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_bmap_free_item_t
modifier|*
name|free
decl_stmt|;
comment|/* free extent item */
name|unsigned
name|int
name|logres
decl_stmt|;
comment|/* new log reservation */
name|unsigned
name|int
name|logcount
decl_stmt|;
comment|/* new log count */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount structure */
name|xfs_bmap_free_item_t
modifier|*
name|next
decl_stmt|;
comment|/* next item on free list */
name|xfs_trans_t
modifier|*
name|ntp
decl_stmt|;
comment|/* new transaction pointer */
name|ASSERT
argument_list|(
operator|(
operator|*
name|tp
operator|)
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
argument_list|)
expr_stmt|;
if|if
condition|(
name|flist
operator|->
name|xbf_count
operator|==
literal|0
condition|)
block|{
operator|*
name|committed
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ntp
operator|=
operator|*
name|tp
expr_stmt|;
name|efi
operator|=
name|xfs_trans_get_efi
argument_list|(
name|ntp
argument_list|,
name|flist
operator|->
name|xbf_count
argument_list|)
expr_stmt|;
for|for
control|(
name|free
operator|=
name|flist
operator|->
name|xbf_first
init|;
name|free
condition|;
name|free
operator|=
name|free
operator|->
name|xbfi_next
control|)
name|xfs_trans_log_efi_extent
argument_list|(
name|ntp
argument_list|,
name|efi
argument_list|,
name|free
operator|->
name|xbfi_startblock
argument_list|,
name|free
operator|->
name|xbfi_blockcount
argument_list|)
expr_stmt|;
name|logres
operator|=
name|ntp
operator|->
name|t_log_res
expr_stmt|;
name|logcount
operator|=
name|ntp
operator|->
name|t_log_count
expr_stmt|;
name|ntp
operator|=
name|xfs_trans_dup
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|ntp
expr_stmt|;
operator|*
name|committed
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We have a new transaction, so we should return committed=1, 	 * even though we're returning an error. 	 */
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|ntp
argument_list|,
literal|0
argument_list|,
name|logres
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|logcount
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|efd
operator|=
name|xfs_trans_get_efd
argument_list|(
name|ntp
argument_list|,
name|efi
argument_list|,
name|flist
operator|->
name|xbf_count
argument_list|)
expr_stmt|;
for|for
control|(
name|free
operator|=
name|flist
operator|->
name|xbf_first
init|;
name|free
operator|!=
name|NULL
condition|;
name|free
operator|=
name|next
control|)
block|{
name|next
operator|=
name|free
operator|->
name|xbfi_next
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_free_extent
argument_list|(
name|ntp
argument_list|,
name|free
operator|->
name|xbfi_startblock
argument_list|,
name|free
operator|->
name|xbfi_blockcount
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * The bmap free list will be cleaned up at a 			 * higher level.  The EFI will be canceled when 			 * this transaction is aborted. 			 * Need to force shutdown here to make sure it 			 * happens, since this transaction may not be 			 * dirty yet. 			 */
name|mp
operator|=
name|ntp
operator|->
name|t_mountp
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
operator|(
name|error
operator|==
name|EFSCORRUPTED
operator|)
condition|?
name|XFS_CORRUPT_INCORE
else|:
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_trans_log_efd_extent
argument_list|(
name|ntp
argument_list|,
name|efd
argument_list|,
name|free
operator|->
name|xbfi_startblock
argument_list|,
name|free
operator|->
name|xbfi_blockcount
argument_list|)
expr_stmt|;
name|xfs_bmap_del_free
argument_list|(
name|flist
argument_list|,
name|NULL
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Free up any items left in the list.  */
end_comment

begin_function
name|void
name|xfs_bmap_cancel
parameter_list|(
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|)
comment|/* list of bmap_free_items */
block|{
name|xfs_bmap_free_item_t
modifier|*
name|free
decl_stmt|;
comment|/* free list item */
name|xfs_bmap_free_item_t
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|flist
operator|->
name|xbf_count
operator|==
literal|0
condition|)
return|return;
name|ASSERT
argument_list|(
name|flist
operator|->
name|xbf_first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|free
operator|=
name|flist
operator|->
name|xbf_first
init|;
name|free
condition|;
name|free
operator|=
name|next
control|)
block|{
name|next
operator|=
name|free
operator|->
name|xbfi_next
expr_stmt|;
name|xfs_bmap_del_free
argument_list|(
name|flist
argument_list|,
name|NULL
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|flist
operator|->
name|xbf_count
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the file-relative block number of the first unused block(s)  * in the file with at least "len" logically contiguous blocks free.  * This is the lowest-address hole if the file has holes, else the first block  * past the end of file.  * Return 0 if the file is currently local (in-inode).  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_first_unused
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* size of hole to find */
name|xfs_fileoff_t
modifier|*
name|first_unused
parameter_list|,
comment|/* unused block */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* pointer to an extent entry */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|idx
decl_stmt|;
comment|/* extent record index */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_fileoff_t
name|lastaddr
decl_stmt|;
comment|/* last block number seen */
name|xfs_fileoff_t
name|lowest
decl_stmt|;
comment|/* lowest useful block */
name|xfs_fileoff_t
name|max
decl_stmt|;
comment|/* starting useful block */
name|xfs_fileoff_t
name|off
decl_stmt|;
comment|/* offset for this block */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of extent entries */
name|ASSERT
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_BTREE
operator|||
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|||
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
operator|*
name|first_unused
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|lowest
operator|=
operator|*
name|first_unused
expr_stmt|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|lastaddr
operator|=
literal|0
operator|,
name|max
operator|=
name|lowest
init|;
name|idx
operator|<
name|nextents
condition|;
name|idx
operator|++
control|)
block|{
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|off
operator|=
name|xfs_bmbt_get_startoff
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* 		 * See if the hole before this extent will work. 		 */
if|if
condition|(
name|off
operator|>=
name|lowest
operator|+
name|len
operator|&&
name|off
operator|-
name|max
operator|>=
name|len
condition|)
block|{
operator|*
name|first_unused
operator|=
name|max
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lastaddr
operator|=
name|off
operator|+
name|xfs_bmbt_get_blockcount
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|max
operator|=
name|XFS_FILEOFF_MAX
argument_list|(
name|lastaddr
argument_list|,
name|lowest
argument_list|)
expr_stmt|;
block|}
operator|*
name|first_unused
operator|=
name|max
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the file-relative block number of the last block + 1 before  * last_block (input value) in the file.  * This is not based on i_size, it is based on the extent records.  * Returns 0 for local files, as they do not have extent records.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_last_before
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|xfs_fileoff_t
modifier|*
name|last_block
parameter_list|,
comment|/* last block */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_fileoff_t
name|bno
decl_stmt|;
comment|/* input file offset */
name|int
name|eof
decl_stmt|;
comment|/* hit end of file */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* pointer to last extent */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_bmbt_irec_t
name|got
decl_stmt|;
comment|/* current extent value */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_extnum_t
name|lastx
decl_stmt|;
comment|/* last extent used */
name|xfs_bmbt_irec_t
name|prev
decl_stmt|;
comment|/* previous extent value */
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_LOCAL
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
operator|*
name|last_block
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|bno
operator|=
operator|*
name|last_block
operator|-
literal|1
expr_stmt|;
name|ep
operator|=
name|xfs_bmap_search_extents
argument_list|(
name|ip
argument_list|,
name|bno
argument_list|,
name|whichfork
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|lastx
argument_list|,
operator|&
name|got
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
operator|||
name|xfs_bmbt_get_startoff
argument_list|(
name|ep
argument_list|)
operator|>
name|bno
condition|)
block|{
if|if
condition|(
name|prev
operator|.
name|br_startoff
operator|==
name|NULLFILEOFF
condition|)
operator|*
name|last_block
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|last_block
operator|=
name|prev
operator|.
name|br_startoff
operator|+
name|prev
operator|.
name|br_blockcount
expr_stmt|;
block|}
comment|/* 	 * Otherwise *last_block is already the right answer. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the file-relative block number of the first block past eof in  * the file.  This is not based on i_size, it is based on the extent records.  * Returns 0 for local files, as they do not have extent records.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_last_offset
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|xfs_fileoff_t
modifier|*
name|last_block
parameter_list|,
comment|/* last block */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* pointer to last extent */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of extent entries */
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_LOCAL
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
operator|*
name|last_block
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextents
condition|)
block|{
operator|*
name|last_block
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|nextents
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|last_block
operator|=
name|xfs_bmbt_get_startoff
argument_list|(
name|ep
argument_list|)
operator|+
name|xfs_bmbt_get_blockcount
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether the selected fork of the inode has exactly one  * block or not.  For the data fork we check this matches di_size,  * implying the file's range is 0..bsize-1.  */
end_comment

begin_function
name|int
comment|/* 1=>1 block, 0=>otherwise */
name|xfs_bmap_one_block
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* ptr to fork's extent */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|xfs_bmbt_irec_t
name|s
decl_stmt|;
comment|/* internal version of extent */
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
condition|)
return|return
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|==
name|ip
operator|->
name|i_mount
operator|->
name|m_sb
operator|.
name|sb_blocksize
return|;
endif|#
directive|endif
comment|/* !DEBUG */
if|if
condition|(
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
condition|)
return|return
literal|0
return|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|rval
operator|=
name|s
operator|.
name|br_startoff
operator|==
literal|0
operator|&&
name|s
operator|.
name|br_blockcount
operator|==
literal|1
expr_stmt|;
if|if
condition|(
name|rval
operator|&&
name|whichfork
operator|==
name|XFS_DATA_FORK
condition|)
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|==
name|ip
operator|->
name|i_mount
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Read in the extents to if_extents.  * All inode fields are set up by caller, we just traverse the btree  * and copy the records in. If the file system cannot contain unwritten  * extents, the records are checked for no "state" flags.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_read_extents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* current btree block */
name|xfs_fsblock_t
name|bno
decl_stmt|;
comment|/* block # of "block" */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for "block" */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_exntfmt_t
name|exntf
decl_stmt|;
comment|/* XFS_EXTFMT_NOSTATE, if checking */
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
specifier|static
name|char
name|fname
index|[]
init|=
literal|"xfs_bmap_read_extents"
decl_stmt|;
endif|#
directive|endif
name|xfs_extnum_t
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* index into the extents list */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* fork structure */
name|int
name|level
decl_stmt|;
comment|/* btree level, for checking */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount structure */
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* pointer to block address */
comment|/* REFERENCED */
name|xfs_extnum_t
name|room
decl_stmt|;
comment|/* number of entries there's room for */
name|bno
operator|=
name|NULLFSBLOCK
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|exntf
operator|=
operator|(
name|whichfork
operator|!=
name|XFS_DATA_FORK
operator|)
condition|?
name|XFS_EXTFMT_NOSTATE
else|:
name|XFS_EXTFMT_INODE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|block
operator|=
name|ifp
operator|->
name|if_broot
expr_stmt|;
comment|/* 	 * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out. 	 */
name|level
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_level
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|level
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLDFSBNO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
name|bno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 	 * Go down the tree until leaf level is reached, following the first 	 * pointer (leftmost) at each level. 	 */
while|while
condition|(
name|level
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|block
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|XFS_BMAP_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|block
argument_list|,
name|level
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
break|break;
name|pp
operator|=
name|XFS_BTREE_PTR_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|XFS_FSB_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|bno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here with bp and block set to the leftmost leaf node in the tree. 	 */
name|room
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop over all leaf nodes.  Copy information to the extent records. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|xfs_bmbt_rec_t
modifier|*
name|frp
decl_stmt|,
modifier|*
name|trp
decl_stmt|;
name|xfs_fsblock_t
name|nextbno
decl_stmt|;
name|xfs_extnum_t
name|num_recs
decl_stmt|;
name|xfs_extnum_t
name|start
decl_stmt|;
name|num_recs
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|+
name|num_recs
operator|>
name|room
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|i
operator|+
name|num_recs
operator|<=
name|room
argument_list|)
expr_stmt|;
name|xfs_fs_repair_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|,
literal|"corrupt dinode %Lu, (btree extents)."
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmap_read_extents(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|XFS_BMAP_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
comment|/* 		 * Read-ahead the next leaf block, if any. 		 */
name|nextbno
operator|=
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextbno
operator|!=
name|NULLFSBLOCK
condition|)
name|xfs_btree_reada_bufl
argument_list|(
name|mp
argument_list|,
name|nextbno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Copy records into the extent records. 		 */
name|frp
operator|=
name|XFS_BTREE_REC_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_recs
condition|;
name|j
operator|++
operator|,
name|i
operator|++
operator|,
name|frp
operator|++
control|)
block|{
name|trp
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|trp
operator|->
name|l0
operator|=
name|INT_GET
argument_list|(
name|frp
operator|->
name|l0
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|trp
operator|->
name|l1
operator|=
name|INT_GET
argument_list|(
name|frp
operator|->
name|l1
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exntf
operator|==
name|XFS_EXTFMT_NOSTATE
condition|)
block|{
comment|/* 			 * Check all attribute bmap btree records and 			 * any "older" data bmap btree records for a 			 * set bit in the "extent flag" position. 			 */
if|if
condition|(
name|unlikely
argument_list|(
name|xfs_check_nostate_extents
argument_list|(
name|ifp
argument_list|,
name|start
argument_list|,
name|num_recs
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmap_read_extents(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
block|}
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bno
operator|=
name|nextbno
expr_stmt|;
comment|/* 		 * If we've reached the end, stop. 		 */
if|if
condition|(
name|bno
operator|==
name|NULLFSBLOCK
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|block
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|i
operator|==
operator|(
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_exlist
argument_list|(
name|fname
argument_list|,
name|ip
argument_list|,
name|i
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
end_ifdef

begin_comment
comment|/*  * Add bmap trace insert entries for all the contents of the extent records.  */
end_comment

begin_function
name|void
name|xfs_bmap_trace_exlist
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
comment|/* function name */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_extnum_t
name|cnt
parameter_list|,
comment|/* count of entries in the list */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* current extent record */
name|xfs_extnum_t
name|idx
decl_stmt|;
comment|/* extent record index */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_irec_t
name|s
decl_stmt|;
comment|/* file extent record */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cnt
operator|==
operator|(
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|cnt
condition|;
name|idx
operator|++
control|)
block|{
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|xfs_bmap_trace_insert
argument_list|(
name|fname
argument_list|,
literal|"exlist"
argument_list|,
name|ip
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Validate that the bmbt_irecs being returned from bmapi are valid  * given the callers original parameters.  Specifically check the  * ranges of the returned irecs to ensure that they only extent beyond  * the given parameters if the XFS_BMAPI_ENTIRE flag was set.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_validate_ret
parameter_list|(
name|xfs_fileoff_t
name|bno
parameter_list|,
name|xfs_filblks_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|mval
parameter_list|,
name|int
name|nmap
parameter_list|,
name|int
name|ret_nmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* index to map values */
name|ASSERT
argument_list|(
name|ret_nmap
operator|<=
name|nmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ret_nmap
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_blockcount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_ENTIRE
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_startoff
operator|>=
name|bno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_blockcount
operator|<=
name|len
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_startoff
operator|+
name|mval
index|[
name|i
index|]
operator|.
name|br_blockcount
operator|<=
name|bno
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_startoff
operator|<
name|bno
operator|+
name|len
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_startoff
operator|+
name|mval
index|[
name|i
index|]
operator|.
name|br_blockcount
operator|>
name|bno
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|mval
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mval
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|==
name|mval
index|[
name|i
index|]
operator|.
name|br_startoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFS_BMAPI_WRITE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
operator|)
condition|)
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|&&
name|mval
index|[
name|i
index|]
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
index|[
name|i
index|]
operator|.
name|br_state
operator|==
name|XFS_EXT_NORM
operator|||
name|mval
index|[
name|i
index|]
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Map file blocks to filesystem blocks.  * File range is given by the bno/len pair.  * Adds blocks to file if a write ("flags& XFS_BMAPI_WRITE" set)  * into a hole or past eof.  * Only allocates blocks from a single allocation group,  * to avoid locking problems.  * The returned value in "firstblock" from the first call in a transaction  * must be remembered and presented to subsequent calls in "firstblock".  * An upper bound for the number of blocks to be allocated is supplied to  * the first call in "total"; if no allocation group has that many free  * blocks then the call will fail (return NULLFSBLOCK in "firstblock").  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmapi
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|xfs_fileoff_t
name|bno
parameter_list|,
comment|/* starting file offs. mapped */
name|xfs_filblks_t
name|len
parameter_list|,
comment|/* length to map in file */
name|int
name|flags
parameter_list|,
comment|/* XFS_BMAPI_... */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first allocated block 					   controls a.g. for allocs */
name|xfs_extlen_t
name|total
parameter_list|,
comment|/* total blocks needed */
name|xfs_bmbt_irec_t
modifier|*
name|mval
parameter_list|,
comment|/* output: map values */
name|int
modifier|*
name|nmap
parameter_list|,
comment|/* i/o: mval size/count */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* i/o: list extents to free */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|)
comment|/* o: change made to incore extents */
block|{
name|xfs_fsblock_t
name|abno
decl_stmt|;
comment|/* allocated block number */
name|xfs_extlen_t
name|alen
decl_stmt|;
comment|/* allocated extent length */
name|xfs_fileoff_t
name|aoff
decl_stmt|;
comment|/* allocated file offset */
name|xfs_bmalloca_t
name|bma
decl_stmt|;
comment|/* args for xfs_bmap_alloc */
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* bmap btree cursor */
name|xfs_fileoff_t
name|end
decl_stmt|;
comment|/* end of mapped file region */
name|int
name|eof
decl_stmt|;
comment|/* we've hit the end of extents */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record pointer */
name|int
name|error
decl_stmt|;
comment|/* error return */
name|xfs_bmbt_irec_t
name|got
decl_stmt|;
comment|/* current file extent record */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_extlen_t
name|indlen
decl_stmt|;
comment|/* indirect blocks length */
name|xfs_extnum_t
name|lastx
decl_stmt|;
comment|/* last useful extent number */
name|int
name|logflags
decl_stmt|;
comment|/* flags for transaction logging */
name|xfs_extlen_t
name|minleft
decl_stmt|;
comment|/* min blocks left after allocation */
name|xfs_extlen_t
name|minlen
decl_stmt|;
comment|/* min allocation size */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* xfs mount structure */
name|int
name|n
decl_stmt|;
comment|/* current extent index */
name|int
name|nallocs
decl_stmt|;
comment|/* number of extents alloc\'d */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of extents in file */
name|xfs_fileoff_t
name|obno
decl_stmt|;
comment|/* old block number (offset) */
name|xfs_bmbt_irec_t
name|prev
decl_stmt|;
comment|/* previous file extent record */
name|int
name|tmp_logflags
decl_stmt|;
comment|/* temp flags holder */
name|int
name|whichfork
decl_stmt|;
comment|/* data or attr fork */
name|char
name|inhole
decl_stmt|;
comment|/* current location is hole in file */
name|char
name|wasdelay
decl_stmt|;
comment|/* old extent was delayed */
name|char
name|wr
decl_stmt|;
comment|/* this is a write request */
name|char
name|rt
decl_stmt|;
comment|/* this is a realtime file */
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_fileoff_t
name|orig_bno
decl_stmt|;
comment|/* original block number value */
name|int
name|orig_flags
decl_stmt|;
comment|/* original flags arg value */
name|xfs_filblks_t
name|orig_len
decl_stmt|;
comment|/* original value of len arg */
name|xfs_bmbt_irec_t
modifier|*
name|orig_mval
decl_stmt|;
comment|/* original value of mval */
name|int
name|orig_nmap
decl_stmt|;
comment|/* original value of *nmap */
name|orig_bno
operator|=
name|bno
expr_stmt|;
name|orig_len
operator|=
name|len
expr_stmt|;
name|orig_flags
operator|=
name|flags
expr_stmt|;
name|orig_mval
operator|=
name|mval
expr_stmt|;
name|orig_nmap
operator|=
operator|*
name|nmap
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
operator|*
name|nmap
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|nmap
operator|<=
name|XFS_BMAP_MAX_NMAP
operator|||
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_WRITE
operator|)
argument_list|)
expr_stmt|;
name|whichfork
operator|=
operator|(
name|flags
operator|&
name|XFS_BMAPI_ATTRFORK
operator|)
condition|?
name|XFS_ATTR_FORK
else|:
name|XFS_DATA_FORK
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_BMAPIFORMAT
argument_list|,
name|XFS_RANDOM_BMAPIFORMAT
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmapi"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|rt
operator|=
operator|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|)
operator|&&
name|XFS_IS_REALTIME_INODE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_ext_max
operator|==
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wr
operator|=
operator|(
name|flags
operator|&
name|XFS_BMAPI_WRITE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|XFS_STATS_INC
argument_list|(
name|xs_blk_mapw
argument_list|)
expr_stmt|;
else|else
name|XFS_STATS_INC
argument_list|(
name|xs_blk_mapr
argument_list|)
expr_stmt|;
comment|/* 	 * IGSTATE flag is used to combine extents which 	 * differ only due to the state of the extents. 	 * This technique is used from xfs_getbmap() 	 * when the caller does not wish to see the 	 * separation (which is the default). 	 * 	 * This technique is also used when writing a 	 * buffer which has been partially written, 	 * (usually by being flushed during a chunkread), 	 * to ensure one write takes place. This also 	 * prevents a change in the xfs inode extents at 	 * this time, intentionally. This change occurs 	 * on completion of the write operation, in 	 * xfs_strat_comp(), where the xfs_bmapi() call 	 * is transactioned, and the extents combined. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|XFS_BMAPI_IGSTATE
operator|)
operator|&&
name|wr
condition|)
comment|/* if writing unwritten space */
name|wr
operator|=
literal|0
expr_stmt|;
comment|/* no allocations are allowed */
name|ASSERT
argument_list|(
name|wr
operator|||
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
operator|)
argument_list|)
expr_stmt|;
name|logflags
operator|=
literal|0
expr_stmt|;
name|nallocs
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|ASSERT
argument_list|(
name|wr
operator|&&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_local_to_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|firstblock
argument_list|,
name|total
argument_list|,
operator|&
name|logflags
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
name|wr
operator|&&
operator|*
name|firstblock
operator|==
name|NULLFSBLOCK
condition|)
block|{
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_BTREE
condition|)
name|minleft
operator|=
name|be16_to_cpu
argument_list|(
name|ifp
operator|->
name|if_broot
operator|->
name|bb_level
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|minleft
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|minleft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
name|ep
operator|=
name|xfs_bmap_search_extents
argument_list|(
name|ip
argument_list|,
name|bno
argument_list|,
name|whichfork
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|lastx
argument_list|,
operator|&
name|got
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|bno
operator|+
name|len
expr_stmt|;
name|obno
operator|=
name|bno
expr_stmt|;
name|bma
operator|.
name|ip
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|delta
operator|->
name|xed_startoff
operator|=
name|NULLFILEOFF
expr_stmt|;
name|delta
operator|->
name|xed_blockcount
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|bno
operator|<
name|end
operator|&&
name|n
operator|<
operator|*
name|nmap
condition|)
block|{
comment|/* 		 * Reading past eof, act as though there's a hole 		 * up to end. 		 */
if|if
condition|(
name|eof
operator|&&
operator|!
name|wr
condition|)
name|got
operator|.
name|br_startoff
operator|=
name|end
expr_stmt|;
name|inhole
operator|=
name|eof
operator|||
name|got
operator|.
name|br_startoff
operator|>
name|bno
expr_stmt|;
name|wasdelay
operator|=
name|wr
operator|&&
operator|!
name|inhole
operator|&&
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
operator|)
operator|&&
name|ISNULLSTARTBLOCK
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
comment|/* 		 * First, deal with the hole before the allocated space 		 * that we found, if any. 		 */
if|if
condition|(
name|wr
operator|&&
operator|(
name|inhole
operator|||
name|wasdelay
operator|)
condition|)
block|{
comment|/* 			 * For the wasdelay case, we could also just 			 * allocate the stuff asked for in this bmap call 			 * but that wouldn't be as good. 			 */
if|if
condition|(
name|wasdelay
operator|&&
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_EXACT
operator|)
condition|)
block|{
name|alen
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|got
operator|.
name|br_blockcount
expr_stmt|;
name|aoff
operator|=
name|got
operator|.
name|br_startoff
expr_stmt|;
if|if
condition|(
name|lastx
operator|!=
name|NULLEXTNUM
operator|&&
name|lastx
condition|)
block|{
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wasdelay
condition|)
block|{
name|alen
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|XFS_FILBLKS_MIN
argument_list|(
name|len
argument_list|,
operator|(
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
operator|)
operator|-
name|bno
argument_list|)
expr_stmt|;
name|aoff
operator|=
name|bno
expr_stmt|;
block|}
else|else
block|{
name|alen
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|XFS_FILBLKS_MIN
argument_list|(
name|len
argument_list|,
name|MAXEXTLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
name|alen
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|XFS_FILBLKS_MIN
argument_list|(
name|alen
argument_list|,
name|got
operator|.
name|br_startoff
operator|-
name|bno
argument_list|)
expr_stmt|;
name|aoff
operator|=
name|bno
expr_stmt|;
block|}
name|minlen
operator|=
operator|(
name|flags
operator|&
name|XFS_BMAPI_CONTIG
operator|)
condition|?
name|alen
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
condition|)
block|{
name|xfs_extlen_t
name|extsz
decl_stmt|;
comment|/* Figure out the extent size, adjust alen */
if|if
condition|(
name|rt
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|extsz
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|)
condition|)
name|extsz
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
block|}
else|else
block|{
name|extsz
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
expr_stmt|;
block|}
if|if
condition|(
name|extsz
condition|)
block|{
name|error
operator|=
name|xfs_bmap_extsize_align
argument_list|(
name|mp
argument_list|,
operator|&
name|got
argument_list|,
operator|&
name|prev
argument_list|,
name|extsz
argument_list|,
name|rt
argument_list|,
name|eof
argument_list|,
name|flags
operator|&
name|XFS_BMAPI_DELAY
argument_list|,
name|flags
operator|&
name|XFS_BMAPI_CONVERT
argument_list|,
operator|&
name|aoff
argument_list|,
operator|&
name|alen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
condition|)
name|extsz
operator|=
name|alen
operator|/
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
comment|/* 				 * Make a transaction-less quota reservation for 				 * delayed allocation blocks. This number gets 				 * adjusted later.  We return if we haven't 				 * allocated blocks already inside this loop. 				 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_TRANS_RESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|(
name|long
operator|)
name|alen
argument_list|,
literal|0
argument_list|,
name|rt
condition|?
name|XFS_QMOPT_RES_RTBLKS
else|:
name|XFS_QMOPT_RES_REGBLKS
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|nmap
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|cur
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
break|break;
block|}
comment|/* 				 * Split changing sb for alen and indlen since 				 * they could be coming from different places. 				 */
name|indlen
operator|=
operator|(
name|xfs_extlen_t
operator|)
name|xfs_bmap_worst_indlen
argument_list|(
name|ip
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|indlen
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
condition|)
block|{
name|error
operator|=
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FREXTENTS
argument_list|,
operator|-
operator|(
name|extsz
operator|)
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|-
operator|(
name|alen
operator|)
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|-
operator|(
name|indlen
operator|)
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|rt
condition|)
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FREXTENTS
argument_list|,
name|extsz
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
name|alen
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|XFS_IS_QUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
comment|/* unreserve the blocks now */
operator|(
name|void
operator|)
name|XFS_TRANS_UNRESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|(
name|long
operator|)
name|alen
argument_list|,
literal|0
argument_list|,
name|rt
condition|?
name|XFS_QMOPT_RES_RTBLKS
else|:
name|XFS_QMOPT_RES_REGBLKS
argument_list|)
expr_stmt|;
break|break;
block|}
name|ip
operator|->
name|i_delayed_blks
operator|+=
name|alen
expr_stmt|;
name|abno
operator|=
name|NULLSTARTBLOCK
argument_list|(
name|indlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If first time, allocate and fill in 				 * once-only bma fields. 				 */
if|if
condition|(
name|bma
operator|.
name|ip
operator|==
name|NULL
condition|)
block|{
name|bma
operator|.
name|tp
operator|=
name|tp
expr_stmt|;
name|bma
operator|.
name|ip
operator|=
name|ip
expr_stmt|;
name|bma
operator|.
name|prevp
operator|=
operator|&
name|prev
expr_stmt|;
name|bma
operator|.
name|gotp
operator|=
operator|&
name|got
expr_stmt|;
name|bma
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|bma
operator|.
name|userdata
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Indicate if this is the first user data 				 * in the file, or just any user data. 				 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_METADATA
operator|)
condition|)
block|{
name|bma
operator|.
name|userdata
operator|=
operator|(
name|aoff
operator|==
literal|0
operator|)
condition|?
name|XFS_ALLOC_INITIAL_USER_DATA
else|:
name|XFS_ALLOC_USERDATA
expr_stmt|;
block|}
comment|/* 				 * Fill in changeable bma fields. 				 */
name|bma
operator|.
name|eof
operator|=
name|eof
expr_stmt|;
name|bma
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
name|bma
operator|.
name|alen
operator|=
name|alen
expr_stmt|;
name|bma
operator|.
name|off
operator|=
name|aoff
expr_stmt|;
name|bma
operator|.
name|conv
operator|=
operator|(
name|flags
operator|&
name|XFS_BMAPI_CONVERT
operator|)
expr_stmt|;
name|bma
operator|.
name|wasdel
operator|=
name|wasdelay
expr_stmt|;
name|bma
operator|.
name|minlen
operator|=
name|minlen
expr_stmt|;
name|bma
operator|.
name|low
operator|=
name|flist
operator|->
name|xbf_low
expr_stmt|;
name|bma
operator|.
name|minleft
operator|=
name|minleft
expr_stmt|;
comment|/* 				 * Only want to do the alignment at the 				 * eof if it is userdata and allocation length 				 * is larger than a stripe unit. 				 */
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
name|alen
operator|>=
name|mp
operator|->
name|m_dalign
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_METADATA
operator|)
operator|)
operator|&&
operator|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_isaeof
argument_list|(
name|ip
argument_list|,
name|aoff
argument_list|,
name|whichfork
argument_list|,
operator|&
name|bma
operator|.
name|aeof
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
block|}
else|else
name|bma
operator|.
name|aeof
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Call allocator. 				 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_alloc
argument_list|(
operator|&
name|bma
argument_list|)
operator|)
condition|)
goto|goto
name|error0
goto|;
comment|/* 				 * Copy out result fields. 				 */
name|abno
operator|=
name|bma
operator|.
name|rval
expr_stmt|;
if|if
condition|(
operator|(
name|flist
operator|->
name|xbf_low
operator|=
name|bma
operator|.
name|low
operator|)
condition|)
name|minleft
operator|=
literal|0
expr_stmt|;
name|alen
operator|=
name|bma
operator|.
name|alen
expr_stmt|;
name|aoff
operator|=
name|bma
operator|.
name|off
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|firstblock
operator|==
name|NULLFSBLOCK
operator|||
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
operator|*
name|firstblock
argument_list|)
operator|==
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|bma
operator|.
name|firstblock
argument_list|)
operator|||
operator|(
name|flist
operator|->
name|xbf_low
operator|&&
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
operator|*
name|firstblock
argument_list|)
operator|<
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|bma
operator|.
name|firstblock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|firstblock
operator|=
name|bma
operator|.
name|firstblock
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
if|if
condition|(
name|abno
operator|==
name|NULLFSBLOCK
condition|)
break|break;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFBROOT
operator|)
operator|&&
operator|!
name|cur
condition|)
block|{
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|XFS_BTNUM_BMAP
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
block|}
comment|/* 				 * Bump the number of extents we've allocated 				 * in this call. 				 */
name|nallocs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|=
name|wasdelay
condition|?
name|XFS_BTCUR_BPRV_WASDEL
else|:
literal|0
expr_stmt|;
name|got
operator|.
name|br_startoff
operator|=
name|aoff
expr_stmt|;
name|got
operator|.
name|br_startblock
operator|=
name|abno
expr_stmt|;
name|got
operator|.
name|br_blockcount
operator|=
name|alen
expr_stmt|;
name|got
operator|.
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
comment|/* assume normal */
comment|/* 			 * Determine state of extent, and the filesystem. 			 * A wasdelay extent has been initialized, so 			 * shouldn't be flagged as unwritten. 			 */
if|if
condition|(
name|wr
operator|&&
name|XFS_SB_VERSION_HASEXTFLGBIT
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|wasdelay
operator|&&
operator|(
name|flags
operator|&
name|XFS_BMAPI_PREALLOC
operator|)
condition|)
name|got
operator|.
name|br_state
operator|=
name|XFS_EXT_UNWRITTEN
expr_stmt|;
block|}
name|error
operator|=
name|xfs_bmap_add_extent
argument_list|(
name|ip
argument_list|,
name|lastx
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|got
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|delta
argument_list|,
name|whichfork
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
name|lastx
operator|=
name|ifp
operator|->
name|if_lastex
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|got
operator|.
name|br_startoff
operator|<=
name|aoff
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
operator|>=
name|aoff
operator|+
name|alen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
condition|)
block|{
name|ASSERT
argument_list|(
name|ISNULLSTARTBLOCK
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|STARTBLOCKVAL
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|got
operator|.
name|br_state
operator|==
name|XFS_EXT_NORM
operator|||
name|got
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Fall down into the found allocated space case. 			 */
block|}
elseif|else
if|if
condition|(
name|inhole
condition|)
block|{
comment|/* 			 * Reading in a hole. 			 */
name|mval
operator|->
name|br_startoff
operator|=
name|bno
expr_stmt|;
name|mval
operator|->
name|br_startblock
operator|=
name|HOLESTARTBLOCK
expr_stmt|;
name|mval
operator|->
name|br_blockcount
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|len
argument_list|,
name|got
operator|.
name|br_startoff
operator|-
name|bno
argument_list|)
expr_stmt|;
name|mval
operator|->
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
name|bno
operator|+=
name|mval
operator|->
name|br_blockcount
expr_stmt|;
name|len
operator|-=
name|mval
operator|->
name|br_blockcount
expr_stmt|;
name|mval
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Then deal with the allocated space we found. 		 */
name|ASSERT
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BMAPI_ENTIRE
operator|)
operator|&&
operator|(
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
operator|>
name|obno
operator|)
condition|)
block|{
if|if
condition|(
name|obno
operator|>
name|bno
condition|)
name|bno
operator|=
name|obno
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bno
operator|>=
name|obno
operator|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bno
operator|<
name|end
argument_list|)
expr_stmt|;
name|mval
operator|->
name|br_startoff
operator|=
name|bno
expr_stmt|;
if|if
condition|(
name|ISNULLSTARTBLOCK
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|wr
operator|||
operator|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
operator|)
argument_list|)
expr_stmt|;
name|mval
operator|->
name|br_startblock
operator|=
name|DELAYSTARTBLOCK
expr_stmt|;
block|}
else|else
name|mval
operator|->
name|br_startblock
operator|=
name|got
operator|.
name|br_startblock
operator|+
operator|(
name|bno
operator|-
name|got
operator|.
name|br_startoff
operator|)
expr_stmt|;
comment|/* 			 * Return the minimum of what we got and what we 			 * asked for for the length.  We can use the len 			 * variable here because it is modified below 			 * and we could have been there before coming 			 * here if the first part of the allocation 			 * didn't overlap what was asked for. 			 */
name|mval
operator|->
name|br_blockcount
operator|=
name|XFS_FILBLKS_MIN
argument_list|(
name|end
operator|-
name|bno
argument_list|,
name|got
operator|.
name|br_blockcount
operator|-
operator|(
name|bno
operator|-
name|got
operator|.
name|br_startoff
operator|)
argument_list|)
expr_stmt|;
name|mval
operator|->
name|br_state
operator|=
name|got
operator|.
name|br_state
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
operator|->
name|br_blockcount
operator|<=
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|mval
operator|=
name|got
expr_stmt|;
if|if
condition|(
name|ISNULLSTARTBLOCK
argument_list|(
name|mval
operator|->
name|br_startblock
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|wr
operator|||
operator|(
name|flags
operator|&
name|XFS_BMAPI_DELAY
operator|)
argument_list|)
expr_stmt|;
name|mval
operator|->
name|br_startblock
operator|=
name|DELAYSTARTBLOCK
expr_stmt|;
block|}
block|}
comment|/* 		 * Check if writing previously allocated but 		 * unwritten extents. 		 */
if|if
condition|(
name|wr
operator|&&
name|mval
operator|->
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|XFS_BMAPI_PREALLOC
operator||
name|XFS_BMAPI_DELAY
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Modify (by adding) the state flag, if writing. 			 */
name|ASSERT
argument_list|(
name|mval
operator|->
name|br_blockcount
operator|<=
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFBROOT
operator|)
operator|&&
operator|!
name|cur
condition|)
block|{
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|XFS_BTNUM_BMAP
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
block|}
name|mval
operator|->
name|br_state
operator|=
name|XFS_EXT_NORM
expr_stmt|;
name|error
operator|=
name|xfs_bmap_add_extent
argument_list|(
name|ip
argument_list|,
name|lastx
argument_list|,
operator|&
name|cur
argument_list|,
name|mval
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|delta
argument_list|,
name|whichfork
argument_list|,
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
name|lastx
operator|=
name|ifp
operator|->
name|if_lastex
expr_stmt|;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
comment|/* 			 * We may have combined previously unwritten 			 * space with written space, so generate 			 * another request. 			 */
if|if
condition|(
name|mval
operator|->
name|br_blockcount
operator|<
name|len
condition|)
continue|continue;
block|}
name|ASSERT
argument_list|(
operator|(
name|flags
operator|&
name|XFS_BMAPI_ENTIRE
operator|)
operator|||
operator|(
operator|(
name|mval
operator|->
name|br_startoff
operator|+
name|mval
operator|->
name|br_blockcount
operator|)
operator|<=
name|end
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|flags
operator|&
name|XFS_BMAPI_ENTIRE
operator|)
operator|||
operator|(
name|mval
operator|->
name|br_blockcount
operator|<=
name|len
operator|)
operator|||
operator|(
name|mval
operator|->
name|br_startoff
operator|<
name|obno
operator|)
argument_list|)
expr_stmt|;
name|bno
operator|=
name|mval
operator|->
name|br_startoff
operator|+
name|mval
operator|->
name|br_blockcount
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|bno
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|mval
operator|->
name|br_startoff
operator|==
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startoff
condition|)
block|{
name|ASSERT
argument_list|(
name|mval
operator|->
name|br_startblock
operator|==
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
operator|->
name|br_blockcount
operator|>
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mval
operator|->
name|br_state
operator|==
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_state
argument_list|)
expr_stmt|;
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|=
name|mval
operator|->
name|br_blockcount
expr_stmt|;
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_state
operator|=
name|mval
operator|->
name|br_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|mval
operator|->
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|&&
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
operator|&&
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|&&
name|mval
operator|->
name|br_startblock
operator|==
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startblock
operator|+
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|&&
operator|(
operator|(
name|flags
operator|&
name|XFS_BMAPI_IGSTATE
operator|)
operator|||
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_state
operator|==
name|mval
operator|->
name|br_state
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mval
operator|->
name|br_startoff
operator|==
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|+=
name|mval
operator|->
name|br_blockcount
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|mval
operator|->
name|br_startblock
operator|==
name|DELAYSTARTBLOCK
operator|&&
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startblock
operator|==
name|DELAYSTARTBLOCK
operator|&&
name|mval
operator|->
name|br_startoff
operator|==
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
condition|)
block|{
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|+=
name|mval
operator|->
name|br_blockcount
expr_stmt|;
name|mval
index|[
operator|-
literal|1
index|]
operator|.
name|br_state
operator|=
name|mval
operator|->
name|br_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|mval
operator|->
name|br_startoff
operator|+
name|mval
operator|->
name|br_blockcount
operator|)
operator|<=
name|obno
operator|)
operator|)
condition|)
block|{
name|mval
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* 		 * If we're done, stop now.  Stop when we've allocated 		 * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise 		 * the transaction may get too big. 		 */
if|if
condition|(
name|bno
operator|>=
name|end
operator|||
name|n
operator|>=
operator|*
name|nmap
operator|||
name|nallocs
operator|>=
operator|*
name|nmap
condition|)
break|break;
comment|/* 		 * Else go on to the next record. 		 */
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
operator|++
name|lastx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastx
operator|>=
name|nextents
condition|)
block|{
name|eof
operator|=
literal|1
expr_stmt|;
name|prev
operator|=
name|got
expr_stmt|;
block|}
else|else
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_lastex
operator|=
name|lastx
expr_stmt|;
operator|*
name|nmap
operator|=
name|n
expr_stmt|;
comment|/* 	 * Transform from btree to extents, give it cur. 	 */
if|if
condition|(
name|tp
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_BTREE
operator|&&
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|<=
name|ifp
operator|->
name|if_ext_max
condition|)
block|{
name|ASSERT
argument_list|(
name|wr
operator|&&
name|cur
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_btree_to_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|cur
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
block|}
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_ext_max
operator|==
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|||
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|>
name|ifp
operator|->
name|if_ext_max
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delta
operator|&&
name|delta
operator|->
name|xed_startoff
operator|!=
name|NULLFILEOFF
condition|)
block|{
comment|/* A change was actually made. 		 * Note that delta->xed_blockount is an offset at this 		 * point and needs to be converted to a block count. 		 */
name|ASSERT
argument_list|(
name|delta
operator|->
name|xed_blockcount
operator|>
name|delta
operator|->
name|xed_startoff
argument_list|)
expr_stmt|;
name|delta
operator|->
name|xed_blockcount
operator|-=
name|delta
operator|->
name|xed_startoff
expr_stmt|;
block|}
name|error0
label|:
comment|/* 	 * Log everything.  Do this after conversion, there's no point in 	 * logging the extent records if we've converted to btree format. 	 */
if|if
condition|(
operator|(
name|logflags
operator|&
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
operator|)
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
condition|)
name|logflags
operator|&=
operator|~
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|logflags
operator|&
name|XFS_ILOG_FBROOT
argument_list|(
name|whichfork
argument_list|)
operator|)
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
condition|)
name|logflags
operator|&=
operator|~
name|XFS_ILOG_FBROOT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
comment|/* 	 * Log whatever the flags say, even if error.  Otherwise we might miss 	 * detecting a case where the data is changed, there's an error, 	 * and it's not logged so we don't shutdown when we should. 	 */
if|if
condition|(
name|logflags
condition|)
block|{
name|ASSERT
argument_list|(
name|tp
operator|&&
name|wr
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|logflags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
name|firstblock
operator|==
name|NULLFSBLOCK
operator|||
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
operator|*
name|firstblock
argument_list|)
operator|==
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
argument_list|)
operator|||
operator|(
name|flist
operator|->
name|xbf_low
operator|&&
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
operator|*
name|firstblock
argument_list|)
operator|<
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|firstblock
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
expr_stmt|;
block|}
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|error
condition|?
name|XFS_BTREE_ERROR
else|:
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|xfs_bmap_validate_ret
argument_list|(
name|orig_bno
argument_list|,
name|orig_len
argument_list|,
name|orig_flags
argument_list|,
name|orig_mval
argument_list|,
name|orig_nmap
argument_list|,
operator|*
name|nmap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Map file blocks to filesystem blocks, simple version.  * One block (extent) only, read-only.  * For flags, only the XFS_BMAPI_ATTRFORK flag is examined.  * For the other flag values, the effect is as if XFS_BMAPI_METADATA  * was set and all the others were clear.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmapi_single
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|xfs_fsblock_t
modifier|*
name|fsb
parameter_list|,
comment|/* output: mapped block */
name|xfs_fileoff_t
name|bno
parameter_list|)
comment|/* starting file offs. mapped */
block|{
name|int
name|eof
decl_stmt|;
comment|/* we've hit the end of extents */
name|int
name|error
decl_stmt|;
comment|/* error return */
name|xfs_bmbt_irec_t
name|got
decl_stmt|;
comment|/* current file extent record */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_extnum_t
name|lastx
decl_stmt|;
comment|/* last useful extent number */
name|xfs_bmbt_irec_t
name|prev
decl_stmt|;
comment|/* previous file extent record */
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmapi_single"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|XFS_STATS_INC
argument_list|(
name|xs_blk_mapr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|xfs_bmap_search_extents
argument_list|(
name|ip
argument_list|,
name|bno
argument_list|,
name|whichfork
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|lastx
argument_list|,
operator|&
name|got
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
comment|/* 	 * Reading past eof, act as though there's a hole 	 * up to end. 	 */
if|if
condition|(
name|eof
operator|||
name|got
operator|.
name|br_startoff
operator|>
name|bno
condition|)
block|{
operator|*
name|fsb
operator|=
name|NULLFSBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|got
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bno
operator|<
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
operator|*
name|fsb
operator|=
name|got
operator|.
name|br_startblock
operator|+
operator|(
name|bno
operator|-
name|got
operator|.
name|br_startoff
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_lastex
operator|=
name|lastx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Unmap (remove) blocks from a file.  * If nexts is nonzero then the number of extents to remove is limited to  * that value.  If not all extents in the block range can be removed then  * *done is set.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bunmapi
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|struct
name|xfs_inode
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|xfs_fileoff_t
name|bno
parameter_list|,
comment|/* starting offset to unmap */
name|xfs_filblks_t
name|len
parameter_list|,
comment|/* length to unmap in file */
name|int
name|flags
parameter_list|,
comment|/* misc flags */
name|xfs_extnum_t
name|nexts
parameter_list|,
comment|/* number of extents max */
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
comment|/* first allocated block 						   controls a.g. for allocs */
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
comment|/* i/o: list extents to free */
name|xfs_extdelta_t
modifier|*
name|delta
parameter_list|,
comment|/* o: change made to incore 						   extents */
name|int
modifier|*
name|done
parameter_list|)
comment|/* set if not done yet */
block|{
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* bmap btree cursor */
name|xfs_bmbt_irec_t
name|del
decl_stmt|;
comment|/* extent being deleted */
name|int
name|eof
decl_stmt|;
comment|/* is deleting at eof */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* extent record pointer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_extnum_t
name|extno
decl_stmt|;
comment|/* extent number in list */
name|xfs_bmbt_irec_t
name|got
decl_stmt|;
comment|/* current extent record */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|int
name|isrt
decl_stmt|;
comment|/* freeing in rt area */
name|xfs_extnum_t
name|lastx
decl_stmt|;
comment|/* last extent index used */
name|int
name|logflags
decl_stmt|;
comment|/* transaction logging flags */
name|xfs_extlen_t
name|mod
decl_stmt|;
comment|/* rt extent offset */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of file extents */
name|xfs_bmbt_irec_t
name|prev
decl_stmt|;
comment|/* previous extent record */
name|xfs_fileoff_t
name|start
decl_stmt|;
comment|/* first file offset deleted */
name|int
name|tmp_logflags
decl_stmt|;
comment|/* partial logging flags */
name|int
name|wasdel
decl_stmt|;
comment|/* was a delayed alloc extent */
name|int
name|whichfork
decl_stmt|;
comment|/* data or attribute fork */
name|int
name|rsvd
decl_stmt|;
comment|/* OK to allocate reserved blocks */
name|xfs_fsblock_t
name|sum
decl_stmt|;
name|xfs_bunmap_trace
argument_list|(
name|ip
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
name|flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|whichfork
operator|=
operator|(
name|flags
operator|&
name|XFS_BMAPI_ATTRFORK
operator|)
condition|?
name|XFS_ATTR_FORK
else|:
name|XFS_DATA_FORK
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bunmapi"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|rsvd
operator|=
operator|(
name|flags
operator|&
name|XFS_BMAPI_RSVBLOCKS
operator|)
operator|!=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nexts
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_ext_max
operator|==
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextents
operator|==
literal|0
condition|)
block|{
operator|*
name|done
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_blk_unmap
argument_list|)
expr_stmt|;
name|isrt
operator|=
operator|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|)
operator|&&
name|XFS_IS_REALTIME_INODE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|start
operator|=
name|bno
expr_stmt|;
name|bno
operator|=
name|start
operator|+
name|len
operator|-
literal|1
expr_stmt|;
name|ep
operator|=
name|xfs_bmap_search_extents
argument_list|(
name|ip
argument_list|,
name|bno
argument_list|,
name|whichfork
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|lastx
argument_list|,
operator|&
name|got
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|delta
operator|->
name|xed_startoff
operator|=
name|NULLFILEOFF
expr_stmt|;
name|delta
operator|->
name|xed_blockcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Check to see if the given block number is past the end of the 	 * file, back up to the last block if so... 	 */
if|if
condition|(
name|eof
condition|)
block|{
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
operator|--
name|lastx
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
name|bno
operator|=
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
operator|-
literal|1
expr_stmt|;
block|}
name|logflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFBROOT
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_BTREE
argument_list|)
expr_stmt|;
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|XFS_BTNUM_BMAP
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
operator|*
name|firstblock
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cur
operator|=
name|NULL
expr_stmt|;
name|extno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bno
operator|!=
operator|(
name|xfs_fileoff_t
operator|)
operator|-
literal|1
operator|&&
name|bno
operator|>=
name|start
operator|&&
name|lastx
operator|>=
literal|0
operator|&&
operator|(
name|nexts
operator|==
literal|0
operator|||
name|extno
operator|<
name|nexts
operator|)
condition|)
block|{
comment|/* 		 * Is the found extent after a hole in which bno lives? 		 * Just back up to the previous extent, if so. 		 */
if|if
condition|(
name|got
operator|.
name|br_startoff
operator|>
name|bno
condition|)
block|{
if|if
condition|(
operator|--
name|lastx
operator|<
literal|0
condition|)
break|break;
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Is the last block of this extent before the range 		 * we're supposed to delete?  If so, we're done. 		 */
name|bno
operator|=
name|XFS_FILEOFF_MIN
argument_list|(
name|bno
argument_list|,
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno
operator|<
name|start
condition|)
break|break;
comment|/* 		 * Then deal with the (possibly delayed) allocated space 		 * we found. 		 */
name|ASSERT
argument_list|(
name|ep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|del
operator|=
name|got
expr_stmt|;
name|wasdel
operator|=
name|ISNULLSTARTBLOCK
argument_list|(
name|del
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|.
name|br_startoff
operator|<
name|start
condition|)
block|{
name|del
operator|.
name|br_startoff
operator|=
name|start
expr_stmt|;
name|del
operator|.
name|br_blockcount
operator|-=
name|start
operator|-
name|got
operator|.
name|br_startoff
expr_stmt|;
if|if
condition|(
operator|!
name|wasdel
condition|)
name|del
operator|.
name|br_startblock
operator|+=
name|start
operator|-
name|got
operator|.
name|br_startoff
expr_stmt|;
block|}
if|if
condition|(
name|del
operator|.
name|br_startoff
operator|+
name|del
operator|.
name|br_blockcount
operator|>
name|bno
operator|+
literal|1
condition|)
name|del
operator|.
name|br_blockcount
operator|=
name|bno
operator|+
literal|1
operator|-
name|del
operator|.
name|br_startoff
expr_stmt|;
name|sum
operator|=
name|del
operator|.
name|br_startblock
operator|+
name|del
operator|.
name|br_blockcount
expr_stmt|;
if|if
condition|(
name|isrt
operator|&&
operator|(
name|mod
operator|=
name|do_mod
argument_list|(
name|sum
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Realtime extent not lined up at the end. 			 * The extent could have been split into written 			 * and unwritten pieces, or we could just be 			 * unmapping part of it.  But we can't really 			 * get rid of part of a realtime extent. 			 */
if|if
condition|(
name|del
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
operator|||
operator|!
name|XFS_SB_VERSION_HASEXTFLGBIT
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
comment|/* 				 * This piece is unwritten, or we're not 				 * using unwritten extents.  Skip over it. 				 */
name|ASSERT
argument_list|(
name|bno
operator|>=
name|mod
argument_list|)
expr_stmt|;
name|bno
operator|-=
name|mod
operator|>
name|del
operator|.
name|br_blockcount
condition|?
name|del
operator|.
name|br_blockcount
else|:
name|mod
expr_stmt|;
if|if
condition|(
name|bno
operator|<
name|got
operator|.
name|br_startoff
condition|)
block|{
if|if
condition|(
operator|--
name|lastx
operator|>=
literal|0
condition|)
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
argument_list|)
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 			 * It's written, turn it unwritten. 			 * This is better than zeroing it. 			 */
name|ASSERT
argument_list|(
name|del
operator|.
name|br_state
operator|==
name|XFS_EXT_NORM
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_trans_get_block_res
argument_list|(
name|tp
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * If this spans a realtime extent boundary, 			 * chop it back to the start of the one we end at. 			 */
if|if
condition|(
name|del
operator|.
name|br_blockcount
operator|>
name|mod
condition|)
block|{
name|del
operator|.
name|br_startoff
operator|+=
name|del
operator|.
name|br_blockcount
operator|-
name|mod
expr_stmt|;
name|del
operator|.
name|br_startblock
operator|+=
name|del
operator|.
name|br_blockcount
operator|-
name|mod
expr_stmt|;
name|del
operator|.
name|br_blockcount
operator|=
name|mod
expr_stmt|;
block|}
name|del
operator|.
name|br_state
operator|=
name|XFS_EXT_UNWRITTEN
expr_stmt|;
name|error
operator|=
name|xfs_bmap_add_extent
argument_list|(
name|ip
argument_list|,
name|lastx
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|del
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|XFS_DATA_FORK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
goto|goto
name|nodelete
goto|;
block|}
if|if
condition|(
name|isrt
operator|&&
operator|(
name|mod
operator|=
name|do_mod
argument_list|(
name|del
operator|.
name|br_startblock
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Realtime extent is lined up at the end but not 			 * at the front.  We'll get rid of full extents if 			 * we can. 			 */
name|mod
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|-
name|mod
expr_stmt|;
if|if
condition|(
name|del
operator|.
name|br_blockcount
operator|>
name|mod
condition|)
block|{
name|del
operator|.
name|br_blockcount
operator|-=
name|mod
expr_stmt|;
name|del
operator|.
name|br_startoff
operator|+=
name|mod
expr_stmt|;
name|del
operator|.
name|br_startblock
operator|+=
name|mod
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|del
operator|.
name|br_startoff
operator|==
name|start
operator|&&
operator|(
name|del
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
operator|||
name|xfs_trans_get_block_res
argument_list|(
name|tp
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|!
name|XFS_SB_VERSION_HASEXTFLGBIT
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
comment|/* 				 * Can't make it unwritten.  There isn't 				 * a full extent here so just skip it. 				 */
name|ASSERT
argument_list|(
name|bno
operator|>=
name|del
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|bno
operator|-=
name|del
operator|.
name|br_blockcount
expr_stmt|;
if|if
condition|(
name|bno
operator|<
name|got
operator|.
name|br_startoff
condition|)
block|{
if|if
condition|(
operator|--
name|lastx
operator|>=
literal|0
condition|)
name|xfs_bmbt_get_all
argument_list|(
operator|--
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|del
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
condition|)
block|{
comment|/* 				 * This one is already unwritten. 				 * It must have a written left neighbor. 				 * Unwrite the killed part of that one and 				 * try again. 				 */
name|ASSERT
argument_list|(
name|lastx
operator|>
literal|0
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
operator|-
literal|1
argument_list|)
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|prev
operator|.
name|br_state
operator|==
name|XFS_EXT_NORM
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|prev
operator|.
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|del
operator|.
name|br_startblock
operator|==
name|prev
operator|.
name|br_startblock
operator|+
name|prev
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|.
name|br_startoff
operator|<
name|start
condition|)
block|{
name|mod
operator|=
name|start
operator|-
name|prev
operator|.
name|br_startoff
expr_stmt|;
name|prev
operator|.
name|br_blockcount
operator|-=
name|mod
expr_stmt|;
name|prev
operator|.
name|br_startblock
operator|+=
name|mod
expr_stmt|;
name|prev
operator|.
name|br_startoff
operator|=
name|start
expr_stmt|;
block|}
name|prev
operator|.
name|br_state
operator|=
name|XFS_EXT_UNWRITTEN
expr_stmt|;
name|error
operator|=
name|xfs_bmap_add_extent
argument_list|(
name|ip
argument_list|,
name|lastx
operator|-
literal|1
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|prev
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|XFS_DATA_FORK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
goto|goto
name|nodelete
goto|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|del
operator|.
name|br_state
operator|==
name|XFS_EXT_NORM
argument_list|)
expr_stmt|;
name|del
operator|.
name|br_state
operator|=
name|XFS_EXT_UNWRITTEN
expr_stmt|;
name|error
operator|=
name|xfs_bmap_add_extent
argument_list|(
name|ip
argument_list|,
name|lastx
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|del
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|logflags
argument_list|,
name|delta
argument_list|,
name|XFS_DATA_FORK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
goto|goto
name|nodelete
goto|;
block|}
block|}
if|if
condition|(
name|wasdel
condition|)
block|{
name|ASSERT
argument_list|(
name|STARTBLOCKVAL
argument_list|(
name|del
operator|.
name|br_startblock
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Update realtime/data freespace, unreserve quota */
if|if
condition|(
name|isrt
condition|)
block|{
name|xfs_filblks_t
name|rtexts
decl_stmt|;
name|rtexts
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|del
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|do_div
argument_list|(
name|rtexts
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
argument_list|)
expr_stmt|;
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FREXTENTS
argument_list|,
operator|(
name|int
operator|)
name|rtexts
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|XFS_TRANS_RESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|-
operator|(
operator|(
name|long
operator|)
name|del
operator|.
name|br_blockcount
operator|)
argument_list|,
literal|0
argument_list|,
name|XFS_QMOPT_RES_RTBLKS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_mod_incore_sb
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|(
name|int
operator|)
name|del
operator|.
name|br_blockcount
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|XFS_TRANS_RESERVE_QUOTA_NBLKS
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|-
operator|(
operator|(
name|long
operator|)
name|del
operator|.
name|br_blockcount
operator|)
argument_list|,
literal|0
argument_list|,
name|XFS_QMOPT_RES_REGBLKS
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_delayed_blks
operator|-=
name|del
operator|.
name|br_blockcount
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator||=
name|XFS_BTCUR_BPRV_WASDEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|&=
operator|~
name|XFS_BTCUR_BPRV_WASDEL
expr_stmt|;
comment|/* 		 * If it's the case where the directory code is running 		 * with no block reservation, and the deleted block is in 		 * the middle of its extent, and the resulting insert 		 * of an extent would cause transformation to btree format, 		 * then reject it.  The calling code will then swap 		 * blocks around instead. 		 * We have to do this now, rather than waiting for the 		 * conversion to btree format, since the transaction 		 * will be dirty. 		 */
if|if
condition|(
operator|!
name|wasdel
operator|&&
name|xfs_trans_get_block_res
argument_list|(
name|tp
argument_list|)
operator|==
literal|0
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|>=
name|ifp
operator|->
name|if_ext_max
operator|&&
name|del
operator|.
name|br_startoff
operator|>
name|got
operator|.
name|br_startoff
operator|&&
name|del
operator|.
name|br_startoff
operator|+
name|del
operator|.
name|br_blockcount
operator|<
name|got
operator|.
name|br_startoff
operator|+
name|got
operator|.
name|br_blockcount
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|error
operator|=
name|xfs_bmap_del_extent
argument_list|(
name|ip
argument_list|,
name|tp
argument_list|,
name|lastx
argument_list|,
name|flist
argument_list|,
name|cur
argument_list|,
operator|&
name|del
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|delta
argument_list|,
name|whichfork
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
name|bno
operator|=
name|del
operator|.
name|br_startoff
operator|-
literal|1
expr_stmt|;
name|nodelete
label|:
name|lastx
operator|=
name|ifp
operator|->
name|if_lastex
expr_stmt|;
comment|/* 		 * If not done go on to the next (previous) record. 		 * Reset ep in case the extents array was re-alloced. 		 */
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno
operator|!=
operator|(
name|xfs_fileoff_t
operator|)
operator|-
literal|1
operator|&&
name|bno
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|lastx
operator|>=
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|||
name|xfs_bmbt_get_startoff
argument_list|(
name|ep
argument_list|)
operator|>
name|bno
condition|)
block|{
if|if
condition|(
operator|--
name|lastx
operator|>=
literal|0
condition|)
name|ep
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|lastx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastx
operator|>=
literal|0
condition|)
name|xfs_bmbt_get_all
argument_list|(
name|ep
argument_list|,
operator|&
name|got
argument_list|)
expr_stmt|;
name|extno
operator|++
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_lastex
operator|=
name|lastx
expr_stmt|;
operator|*
name|done
operator|=
name|bno
operator|==
operator|(
name|xfs_fileoff_t
operator|)
operator|-
literal|1
operator|||
name|bno
operator|<
name|start
operator|||
name|lastx
operator|<
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_ext_max
operator|==
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert to a btree if necessary. 	 */
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|>
name|ifp
operator|->
name|if_ext_max
condition|)
block|{
name|ASSERT
argument_list|(
name|cur
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_extents_to_btree
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|firstblock
argument_list|,
name|flist
argument_list|,
operator|&
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * transform from btree to extents, give it cur 	 */
elseif|else
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_BTREE
operator|&&
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|<=
name|ifp
operator|->
name|if_ext_max
condition|)
block|{
name|ASSERT
argument_list|(
name|cur
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_btree_to_extents
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|cur
argument_list|,
operator|&
name|tmp_logflags
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|logflags
operator||=
name|tmp_logflags
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * transform from extents to local? 	 */
name|ASSERT
argument_list|(
name|ifp
operator|->
name|if_ext_max
operator|==
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delta
operator|&&
name|delta
operator|->
name|xed_startoff
operator|!=
name|NULLFILEOFF
condition|)
block|{
comment|/* A change was actually made. 		 * Note that delta->xed_blockount is an offset at this 		 * point and needs to be converted to a block count. 		 */
name|ASSERT
argument_list|(
name|delta
operator|->
name|xed_blockcount
operator|>
name|delta
operator|->
name|xed_startoff
argument_list|)
expr_stmt|;
name|delta
operator|->
name|xed_blockcount
operator|-=
name|delta
operator|->
name|xed_startoff
expr_stmt|;
block|}
name|error0
label|:
comment|/* 	 * Log everything.  Do this after conversion, there's no point in 	 * logging the extent records if we've converted to btree format. 	 */
if|if
condition|(
operator|(
name|logflags
operator|&
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
operator|)
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_EXTENTS
condition|)
name|logflags
operator|&=
operator|~
name|XFS_ILOG_FEXT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|logflags
operator|&
name|XFS_ILOG_FBROOT
argument_list|(
name|whichfork
argument_list|)
operator|)
operator|&&
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
condition|)
name|logflags
operator|&=
operator|~
name|XFS_ILOG_FBROOT
argument_list|(
name|whichfork
argument_list|)
expr_stmt|;
comment|/* 	 * Log inode even in the error case, if the transaction 	 * is dirty we'll need to shut down the filesystem. 	 */
if|if
condition|(
name|logflags
condition|)
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|logflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|firstblock
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|error
condition|?
name|XFS_BTREE_ERROR
else|:
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|copy_to_user
end_undef

begin_function
specifier|static
name|__inline__
name|int
name|copy_to_user
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|copy_from_user
end_undef

begin_function
specifier|static
name|__inline__
name|int
name|copy_from_user
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Fcntl interface to xfs_bmapi.  */
end_comment

begin_function
name|int
comment|/* error code */
name|xfs_getbmap
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
comment|/* XFS behavior descriptor*/
name|struct
name|getbmap
modifier|*
name|bmv
parameter_list|,
comment|/* user bmap structure */
name|void
name|__user
modifier|*
name|ap
parameter_list|,
comment|/* pointer to user's array */
name|int
name|interface
parameter_list|)
comment|/* interface flags */
block|{
name|__int64_t
name|bmvend
decl_stmt|;
comment|/* last block requested */
name|int
name|error
decl_stmt|;
comment|/* return value */
name|__int64_t
name|fixlen
decl_stmt|;
comment|/* length for -1 case */
name|int
name|i
decl_stmt|;
comment|/* extent number */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* xfs incore inode pointer */
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
comment|/* corresponding vnode */
name|int
name|lock
decl_stmt|;
comment|/* lock state */
name|xfs_bmbt_irec_t
modifier|*
name|map
decl_stmt|;
comment|/* buffer for user's data */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount point */
name|int
name|nex
decl_stmt|;
comment|/* # of user extents can do */
name|int
name|nexleft
decl_stmt|;
comment|/* # of user extents left */
name|int
name|subnex
decl_stmt|;
comment|/* # of bmapi's can do */
name|int
name|nmap
decl_stmt|;
comment|/* number of map entries */
name|struct
name|getbmap
name|out
decl_stmt|;
comment|/* output structure */
name|int
name|whichfork
decl_stmt|;
comment|/* data or attr fork */
name|int
name|prealloced
decl_stmt|;
comment|/* this is a file with 						 * preallocated data space */
name|int
name|sh_unwritten
decl_stmt|;
comment|/* true, if unwritten */
comment|/* extents listed separately */
name|int
name|bmapi_flags
decl_stmt|;
comment|/* flags for xfs_bmapi */
name|__int32_t
name|oflags
decl_stmt|;
comment|/* getbmapx bmv_oflags field */
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|whichfork
operator|=
name|interface
operator|&
name|BMV_IF_ATTRFORK
condition|?
name|XFS_ATTR_FORK
else|:
name|XFS_DATA_FORK
expr_stmt|;
name|sh_unwritten
operator|=
operator|(
name|interface
operator|&
name|BMV_IF_PREALLOC
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/*	If the BMV_IF_NO_DMAPI_READ interface bit specified, do not 	 *	generate a DMAPI read event.  Otherwise, if the DM_EVENT_READ 	 *	bit is set for the file, generate a read event in order 	 *	that the DMAPI application may do its thing before we return 	 *	the extents.  Usually this means restoring user file data to 	 *	regions of the file that look like holes. 	 * 	 *	The "old behavior" (from XFS_IOC_GETBMAP) is to not specify 	 *	BMV_IF_NO_DMAPI_READ so that read events are generated. 	 *	If this were not true, callers of ioctl( XFS_IOC_GETBMAP ) 	 *	could misinterpret holes in a DMAPI file as true holes, 	 *	when in fact they may represent offline user data. 	 */
if|if
condition|(
operator|(
name|interface
operator|&
name|BMV_IF_NO_DMAPI_READ
operator|)
operator|==
literal|0
operator|&&
name|DM_EVENT_ENABLED
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|ip
argument_list|,
name|DM_EVENT_READ
argument_list|)
operator|&&
name|whichfork
operator|==
name|XFS_DATA_FORK
condition|)
block|{
name|error
operator|=
name|XFS_SEND_DATA
argument_list|(
name|mp
argument_list|,
name|DM_EVENT_READ
argument_list|,
name|vp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
if|if
condition|(
name|whichfork
operator|==
name|XFS_ATTR_FORK
condition|)
block|{
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_LOCAL
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
literal|0
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_EXTENTS
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_getbmap"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|&&
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|!=
name|XFS_DINODE_FMT_LOCAL
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
operator|(
name|XFS_DIFLAG_REALTIME
operator||
name|XFS_DIFLAG_EXTSIZE
operator|)
operator|)
operator|)
operator|||
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
operator|(
name|XFS_DIFLAG_PREALLOC
operator||
name|XFS_DIFLAG_APPEND
operator|)
condition|)
block|{
name|prealloced
operator|=
literal|1
expr_stmt|;
name|fixlen
operator|=
name|XFS_MAXIOFFSET
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prealloced
operator|=
literal|0
expr_stmt|;
name|fixlen
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|prealloced
operator|=
literal|0
expr_stmt|;
name|fixlen
operator|=
literal|1LL
operator|<<
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|bmv
operator|->
name|bmv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|fixlen
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|fixlen
argument_list|)
argument_list|)
expr_stmt|;
name|bmv
operator|->
name|bmv_length
operator|=
name|MAX
argument_list|(
call|(
name|__int64_t
call|)
argument_list|(
name|fixlen
operator|-
name|bmv
operator|->
name|bmv_offset
argument_list|)
argument_list|,
operator|(
name|__int64_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bmv
operator|->
name|bmv_length
operator|<
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|bmv
operator|->
name|bmv_length
operator|==
literal|0
condition|)
block|{
name|bmv
operator|->
name|bmv_entries
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nex
operator|=
name|bmv
operator|->
name|bmv_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nex
operator|<=
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|bmvend
operator|=
name|bmv
operator|->
name|bmv_offset
operator|+
name|bmv
operator|->
name|bmv_length
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|&&
name|ip
operator|->
name|i_delayed_blks
condition|)
block|{
comment|/* xfs_fsize_t last_byte = xfs_file_last_byte(ip); */
name|XVOP_FLUSH_PAGES
argument_list|(
name|vp
argument_list|,
operator|(
name|xfs_off_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|FI_REMAPF
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_ATTR_FORK
operator|||
name|ip
operator|->
name|i_delayed_blks
operator|==
literal|0
argument_list|)
expr_stmt|;
name|lock
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Don't let nex be bigger than the number of extents 	 * we can have assuming alternating holes and real extents. 	 */
if|if
condition|(
name|nex
operator|>
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|*
literal|2
operator|+
literal|1
condition|)
name|nex
operator|=
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|bmapi_flags
operator|=
name|XFS_BMAPI_AFLAG
argument_list|(
name|whichfork
argument_list|)
operator||
operator|(
operator|(
name|sh_unwritten
operator|)
condition|?
literal|0
else|:
name|XFS_BMAPI_IGSTATE
operator|)
expr_stmt|;
comment|/* 	 * Allocate enough space to handle "subnex" maps at a time. 	 */
name|subnex
operator|=
literal|16
expr_stmt|;
name|map
operator|=
name|kmem_alloc
argument_list|(
name|subnex
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bmv
operator|->
name|bmv_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XFS_IFORK_NEXTENTS
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|unlock_and_return
goto|;
block|}
name|nexleft
operator|=
name|nex
expr_stmt|;
do|do
block|{
name|nmap
operator|=
operator|(
name|nexleft
operator|>
name|subnex
operator|)
condition|?
name|subnex
else|:
name|nexleft
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
name|XFS_BB_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|bmv
operator|->
name|bmv_offset
argument_list|)
argument_list|,
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|bmv
operator|->
name|bmv_length
argument_list|)
argument_list|,
name|bmapi_flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unlock_and_return
goto|;
name|ASSERT
argument_list|(
name|nmap
operator|<=
name|subnex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmap
operator|&&
name|nexleft
operator|&&
name|bmv
operator|->
name|bmv_length
condition|;
name|i
operator|++
control|)
block|{
name|nexleft
operator|--
expr_stmt|;
name|oflags
operator|=
operator|(
name|map
index|[
name|i
index|]
operator|.
name|br_state
operator|==
name|XFS_EXT_UNWRITTEN
operator|)
condition|?
name|BMV_OF_PREALLOC
else|:
literal|0
expr_stmt|;
name|out
operator|.
name|bmv_offset
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|br_startoff
argument_list|)
expr_stmt|;
name|out
operator|.
name|bmv_length
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
operator|!=
name|DELAYSTARTBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
operator|==
name|HOLESTARTBLOCK
operator|&&
operator|(
operator|(
name|prealloced
operator|&&
name|out
operator|.
name|bmv_offset
operator|+
name|out
operator|.
name|bmv_length
operator|==
name|bmvend
operator|)
operator|||
name|whichfork
operator|==
name|XFS_ATTR_FORK
operator|)
condition|)
block|{
comment|/*                                  * came to hole at end of file or the end of                                    attribute fork                                  */
goto|goto
name|unlock_and_return
goto|;
block|}
else|else
block|{
name|out
operator|.
name|bmv_block
operator|=
operator|(
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
operator|==
name|HOLESTARTBLOCK
operator|)
condition|?
operator|-
literal|1
else|:
name|XFS_FSB_TO_DB
argument_list|(
name|ip
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
comment|/* return either getbmap/getbmapx structure. */
if|if
condition|(
name|interface
operator|&
name|BMV_IF_EXTENDED
condition|)
block|{
name|struct
name|getbmapx
name|outx
decl_stmt|;
name|GETBMAP_CONVERT
argument_list|(
name|out
argument_list|,
name|outx
argument_list|)
expr_stmt|;
name|outx
operator|.
name|bmv_oflags
operator|=
name|oflags
expr_stmt|;
name|outx
operator|.
name|bmv_unused1
operator|=
name|outx
operator|.
name|bmv_unused2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|ap
argument_list|,
operator|&
name|outx
argument_list|,
sizeof|sizeof
argument_list|(
name|outx
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
goto|goto
name|unlock_and_return
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
name|ap
argument_list|,
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
goto|goto
name|unlock_and_return
goto|;
block|}
block|}
name|bmv
operator|->
name|bmv_offset
operator|=
name|out
operator|.
name|bmv_offset
operator|+
name|out
operator|.
name|bmv_length
expr_stmt|;
name|bmv
operator|->
name|bmv_length
operator|=
name|MAX
argument_list|(
operator|(
name|__int64_t
operator|)
literal|0
argument_list|,
call|(
name|__int64_t
call|)
argument_list|(
name|bmvend
operator|-
name|bmv
operator|->
name|bmv_offset
argument_list|)
argument_list|)
expr_stmt|;
name|bmv
operator|->
name|bmv_entries
operator|++
expr_stmt|;
name|ap
operator|=
operator|(
name|interface
operator|&
name|BMV_IF_EXTENDED
operator|)
condition|?
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
operator|(
expr|struct
name|getbmapx
name|__user
operator|*
operator|)
name|ap
operator|+
literal|1
operator|)
else|:
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
operator|(
expr|struct
name|getbmap
name|__user
operator|*
operator|)
name|ap
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|nmap
operator|&&
name|nexleft
operator|&&
name|bmv
operator|->
name|bmv_length
condition|)
do|;
name|unlock_and_return
label|:
name|xfs_iunlock_map_shared
argument_list|(
name|ip
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_SHARED
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|map
argument_list|,
name|subnex
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Check the last inode extent to determine whether this allocation will result  * in blocks being allocated at the end of the file. When we allocate new data  * blocks at the end of the file which do not start at the previous data block,  * we will try to align the new blocks at stripe unit boundaries.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_bmap_isaeof
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fileoff_t
name|off
parameter_list|,
comment|/* file offset in fsblocks */
name|int
name|whichfork
parameter_list|,
comment|/* data or attribute fork */
name|char
modifier|*
name|aeof
parameter_list|)
comment|/* return value */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_rec_t
modifier|*
name|lastrec
decl_stmt|;
comment|/* extent record pointer */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of file extents */
name|xfs_bmbt_irec_t
name|s
decl_stmt|;
comment|/* expanded extent record */
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextents
operator|==
literal|0
condition|)
block|{
operator|*
name|aeof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Go to the last extent 	 */
name|lastrec
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|nextents
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_bmbt_get_all
argument_list|(
name|lastrec
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Check we are allocating in the last extent (for delayed allocations) 	 * or past the last extent for non-delayed allocations. 	 */
operator|*
name|aeof
operator|=
operator|(
name|off
operator|>=
name|s
operator|.
name|br_startoff
operator|&&
name|off
operator|<
name|s
operator|.
name|br_startoff
operator|+
name|s
operator|.
name|br_blockcount
operator|&&
name|ISNULLSTARTBLOCK
argument_list|(
name|s
operator|.
name|br_startblock
argument_list|)
operator|)
operator|||
name|off
operator|>=
name|s
operator|.
name|br_startoff
operator|+
name|s
operator|.
name|br_blockcount
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the endoff is outside the last extent. If so the caller will grow  * the allocation to a stripe unit boundary.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_eof
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|xfs_fileoff_t
name|endoff
parameter_list|,
comment|/* file offset in fsblocks */
name|int
name|whichfork
parameter_list|,
comment|/* data or attribute fork */
name|int
modifier|*
name|eof
parameter_list|)
comment|/* result value */
block|{
name|xfs_fsblock_t
name|blockcount
decl_stmt|;
comment|/* extent block count */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|xfs_bmbt_rec_t
modifier|*
name|lastrec
decl_stmt|;
comment|/* extent record pointer */
name|xfs_extnum_t
name|nextents
decl_stmt|;
comment|/* number of file extents */
name|xfs_fileoff_t
name|startoff
decl_stmt|;
comment|/* extent starting file offset */
name|ASSERT
argument_list|(
name|whichfork
operator|==
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iread_extents
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nextents
operator|=
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextents
operator|==
literal|0
condition|)
block|{
operator|*
name|eof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Go to the last extent 	 */
name|lastrec
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|nextents
operator|-
literal|1
argument_list|)
expr_stmt|;
name|startoff
operator|=
name|xfs_bmbt_get_startoff
argument_list|(
name|lastrec
argument_list|)
expr_stmt|;
name|blockcount
operator|=
name|xfs_bmbt_get_blockcount
argument_list|(
name|lastrec
argument_list|)
expr_stmt|;
operator|*
name|eof
operator|=
name|endoff
operator|>=
name|startoff
operator|+
name|blockcount
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Check that the extents list for the inode ip is in the right order.  */
end_comment

begin_comment
unit|STATIC void xfs_bmap_check_extents( 	xfs_inode_t		*ip,
comment|/* incore inode pointer */
end_comment

begin_comment
unit|int			whichfork)
comment|/* data or attr fork */
end_comment

begin_comment
unit|{ 	xfs_bmbt_rec_t		*ep;
comment|/* current extent entry */
end_comment

begin_comment
unit|xfs_extnum_t		idx;
comment|/* extent record index */
end_comment

begin_comment
unit|xfs_ifork_t		*ifp;
comment|/* inode fork pointer */
end_comment

begin_comment
unit|xfs_extnum_t		nextents;
comment|/* number of extents in list */
end_comment

begin_comment
unit|xfs_bmbt_rec_t		*nextp;
comment|/* next extent entry */
end_comment

begin_endif
unit|ifp = XFS_IFORK_PTR(ip, whichfork); 	ASSERT(ifp->if_flags& XFS_IFEXTENTS); 	nextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t); 	ep = xfs_iext_get_ext(ifp, 0); 	for (idx = 0; idx< nextents - 1; idx++) { 		nextp = xfs_iext_get_ext(ifp, idx + 1); 		xfs_btree_check_rec(XFS_BTNUM_BMAP, (void *)ep, 			(void *)(nextp)); 		ep = nextp; 	} }
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|xfs_buf_t
modifier|*
name|xfs_bmap_get_bp
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
name|xfs_fsblock_t
name|bno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|!
name|cur
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XFS_BTREE_MAXLEVELS
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
break|break;
if|if
condition|(
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
operator|==
name|bno
condition|)
break|break;
comment|/* Found it */
block|}
if|if
condition|(
name|i
operator|==
name|XFS_BTREE_MAXLEVELS
condition|)
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/* Chase down all the log items to see if the bp is there */
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|cur
operator|->
name|bc_tp
expr_stmt|;
name|licp
operator|=
operator|&
name|tp
operator|->
name|t_items
expr_stmt|;
while|while
condition|(
operator|!
name|bp
operator|&&
name|licp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
condition|)
block|{
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
control|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|lbp
decl_stmt|;
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|lidp
operator|=
name|XFS_LIC_SLOT
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lip
operator|=
name|lidp
operator|->
name|lid_item
expr_stmt|;
if|if
condition|(
name|lip
operator|->
name|li_type
operator|!=
name|XFS_LI_BUF
condition|)
continue|continue;
name|bip
operator|=
operator|(
name|xfs_buf_log_item_t
operator|*
operator|)
name|lip
expr_stmt|;
name|lbp
operator|=
name|bip
operator|->
name|bli_buf
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ADDR
argument_list|(
name|lbp
argument_list|)
operator|==
name|bno
condition|)
block|{
name|bp
operator|=
name|lbp
expr_stmt|;
break|break;
comment|/* Found it */
block|}
block|}
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xfs_check_block
parameter_list|(
name|xfs_bmbt_block_t
modifier|*
name|block
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|root
parameter_list|,
name|short
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|dmxr
decl_stmt|;
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|,
modifier|*
name|thispa
decl_stmt|;
comment|/* pointer to block address */
name|xfs_bmbt_key_t
modifier|*
name|prevp
decl_stmt|,
modifier|*
name|keyp
decl_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_level
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|prevp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dmxr
operator|=
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|root
condition|)
block|{
name|keyp
operator|=
name|XFS_BMAP_BROOT_KEY_ADDR
argument_list|(
name|block
argument_list|,
name|i
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keyp
operator|=
name|XFS_BTREE_KEY_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
name|i
argument_list|,
name|dmxr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevp
condition|)
block|{
name|xfs_btree_check_key
argument_list|(
name|XFS_BTNUM_BMAP
argument_list|,
name|prevp
argument_list|,
name|keyp
argument_list|)
expr_stmt|;
block|}
name|prevp
operator|=
name|keyp
expr_stmt|;
comment|/* 		 * Compare the block numbers to see if there are dups. 		 */
if|if
condition|(
name|root
condition|)
block|{
name|pp
operator|=
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|block
argument_list|,
name|i
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|=
name|XFS_BTREE_PTR_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
name|i
argument_list|,
name|dmxr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|root
condition|)
block|{
name|thispa
operator|=
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|block
argument_list|,
name|j
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thispa
operator|=
name|XFS_BTREE_PTR_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
name|j
argument_list|,
name|dmxr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INT_GET
argument_list|(
operator|*
name|thispa
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"%s: thispa(%d) == pp(%d) %Ld"
argument_list|,
name|__FUNCTION__
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|thispa
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: ptrs are equal in node\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check that the extents for the inode ip are in the right order in all  * btree leaves.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_bmap_check_leaf_extents
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor or null */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode pointer */
name|int
name|whichfork
parameter_list|)
comment|/* data or attr fork */
block|{
name|xfs_bmbt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* current btree block */
name|xfs_fsblock_t
name|bno
decl_stmt|;
comment|/* block # of "block" */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for "block" */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_extnum_t
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
comment|/* index into the extents list */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* fork structure */
name|int
name|level
decl_stmt|;
comment|/* btree level, for checking */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount structure */
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* pointer to block address */
name|xfs_bmbt_rec_t
modifier|*
name|ep
decl_stmt|;
comment|/* pointer to current extent */
name|xfs_bmbt_rec_t
modifier|*
name|lastp
decl_stmt|;
comment|/* pointer to previous extent */
name|xfs_bmbt_rec_t
modifier|*
name|nextp
decl_stmt|;
comment|/* pointer to next extent */
name|int
name|bp_release
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|!=
name|XFS_DINODE_FMT_BTREE
condition|)
block|{
return|return;
block|}
name|bno
operator|=
name|NULLFSBLOCK
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|block
operator|=
name|ifp
operator|->
name|if_broot
expr_stmt|;
comment|/* 	 * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out. 	 */
name|level
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_level
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|level
operator|>
literal|0
argument_list|)
expr_stmt|;
name|xfs_check_block
argument_list|(
name|block
argument_list|,
name|mp
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLDFSBNO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
name|bno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 	 * Go down the tree until leaf level is reached, following the first 	 * pointer (leftmost) at each level. 	 */
while|while
condition|(
name|level
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* See if buf is in cur first */
name|bp
operator|=
name|xfs_bmap_get_bp
argument_list|(
name|cur
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|bp_release
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp_release
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bp
operator|&&
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
goto|goto
name|error_norelse
goto|;
name|block
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|XFS_BMAP_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|block
argument_list|,
name|level
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Check this block for basic sanity (increasing keys and 		 * no duplicate blocks). 		 */
name|xfs_check_block
argument_list|(
name|block
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_BTREE_PTR_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_GOTO
argument_list|(
name|XFS_FSB_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|,
name|error0
argument_list|)
expr_stmt|;
name|bno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp_release
condition|)
block|{
name|bp_release
operator|=
literal|0
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Here with bp and block set to the leftmost leaf node in the tree. 	 */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop over all leaf nodes checking that all extents are in the right order. 	 */
name|lastp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|xfs_fsblock_t
name|nextbno
decl_stmt|;
name|xfs_extnum_t
name|num_recs
decl_stmt|;
name|num_recs
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
comment|/* 		 * Read-ahead the next leaf block, if any. 		 */
name|nextbno
operator|=
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
comment|/* 		 * Check all the extents to make sure they are OK. 		 * If we had a previous block, the last entry should 		 * conform with the first entry in this one. 		 */
name|ep
operator|=
name|XFS_BTREE_REC_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|num_recs
condition|;
name|j
operator|++
control|)
block|{
name|nextp
operator|=
name|XFS_BTREE_REC_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastp
condition|)
block|{
name|xfs_btree_check_rec
argument_list|(
name|XFS_BTNUM_BMAP
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lastp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ep
argument_list|)
expr_stmt|;
block|}
name|xfs_btree_check_rec
argument_list|(
name|XFS_BTNUM_BMAP
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ep
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|nextp
operator|)
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|ep
expr_stmt|;
name|ep
operator|=
name|nextp
expr_stmt|;
block|}
name|i
operator|+=
name|num_recs
expr_stmt|;
if|if
condition|(
name|bp_release
condition|)
block|{
name|bp_release
operator|=
literal|0
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|bno
operator|=
name|nextbno
expr_stmt|;
comment|/* 		 * If we've reached the end, stop. 		 */
if|if
condition|(
name|bno
operator|==
name|NULLFSBLOCK
condition|)
break|break;
name|bp
operator|=
name|xfs_bmap_get_bp
argument_list|(
name|cur
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|bp_release
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp_release
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bp
operator|&&
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
goto|goto
name|error_norelse
goto|;
name|block
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp_release
condition|)
block|{
name|bp_release
operator|=
literal|0
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return;
name|error0
label|:
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"%s: at error0"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp_release
condition|)
name|xfs_trans_brelse
argument_list|(
name|NULL
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error_norelse
label|:
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"%s: BAD after btree leaves for %d extents"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: CORRUPTED BTREE OR SOMETHING"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Count fsblocks of the given fork.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_count_blocks
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* incore inode */
name|int
name|whichfork
parameter_list|,
comment|/* data or attr fork */
name|int
modifier|*
name|count
parameter_list|)
comment|/* out: count of blocks */
block|{
name|xfs_bmbt_block_t
modifier|*
name|block
decl_stmt|;
comment|/* current btree block */
name|xfs_fsblock_t
name|bno
decl_stmt|;
comment|/* block # of "block" */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* fork structure */
name|int
name|level
decl_stmt|;
comment|/* btree level, for checking */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount structure */
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|;
comment|/* pointer to block address */
name|bno
operator|=
name|NULLFSBLOCK
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_IFORK_FORMAT
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
operator|==
name|XFS_DINODE_FMT_EXTENTS
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|xfs_bmap_count_leaves
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|ifp
operator|->
name|if_bytes
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|,
name|count
argument_list|)
operator|<
literal|0
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmap_count_blocks(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* 	 * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out. 	 */
name|block
operator|=
name|ifp
operator|->
name|if_broot
expr_stmt|;
name|level
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_level
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|level
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
name|XFS_BMAP_BROOT_PTR_ADDR
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|ifp
operator|->
name|if_broot_bytes
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|NULLDFSBNO
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_FSB_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
argument_list|)
expr_stmt|;
name|bno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|xfs_bmap_count_tree
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ifp
argument_list|,
name|bno
argument_list|,
name|level
argument_list|,
name|count
argument_list|)
operator|<
literal|0
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmap_count_blocks(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Recursively walks each level of a btree  * to count total fsblocks is use.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_bmap_count_tree
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
comment|/* inode fork pointer */
name|xfs_fsblock_t
name|blockno
parameter_list|,
comment|/* file system block number */
name|int
name|levelin
parameter_list|,
comment|/* level in btree */
name|int
modifier|*
name|count
parameter_list|)
comment|/* Count of blocks */
block|{
name|int
name|error
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|int
name|level
init|=
name|levelin
decl_stmt|;
name|xfs_bmbt_ptr_t
modifier|*
name|pp
decl_stmt|;
name|xfs_fsblock_t
name|bno
init|=
name|blockno
decl_stmt|;
name|xfs_fsblock_t
name|nextbno
decl_stmt|;
name|xfs_bmbt_block_t
modifier|*
name|block
decl_stmt|,
modifier|*
name|nextblock
decl_stmt|;
name|int
name|numrecs
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|level
condition|)
block|{
comment|/* Not at node above leafs, count this level of nodes */
name|nextbno
operator|=
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextbno
operator|!=
name|NULLFSBLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|nextbno
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
name|nextblock
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
name|nextbno
operator|=
name|be64_to_cpu
argument_list|(
name|nextblock
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|nbp
argument_list|)
expr_stmt|;
block|}
comment|/* Dive to the next level */
name|pp
operator|=
name|XFS_BTREE_PTR_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bno
operator|=
name|INT_GET
argument_list|(
operator|*
name|pp
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|error
operator|=
name|xfs_bmap_count_tree
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ifp
argument_list|,
name|bno
argument_list|,
name|level
argument_list|,
name|count
argument_list|)
operator|)
operator|<
literal|0
argument_list|)
condition|)
block|{
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmap_count_tree(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* count all level 1 nodes and their leaves */
for|for
control|(
init|;
condition|;
control|)
block|{
name|nextbno
operator|=
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
expr_stmt|;
name|numrecs
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|xfs_bmap_disk_count_leaves
argument_list|(
name|ifp
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|,
name|block
argument_list|,
name|numrecs
argument_list|,
name|count
argument_list|)
operator|<
literal|0
argument_list|)
condition|)
block|{
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_bmap_count_tree(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextbno
operator|==
name|NULLFSBLOCK
condition|)
break|break;
name|bno
operator|=
name|nextbno
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_btree_read_bufl
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_BMAP_BTREE_REF
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Count leaf blocks given a range of extent records.  */
end_comment

begin_function
name|int
name|xfs_bmap_count_leaves
parameter_list|(
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
name|xfs_extnum_t
name|idx
parameter_list|,
name|int
name|numrecs
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|int
name|b
decl_stmt|;
name|xfs_bmbt_rec_t
modifier|*
name|frp
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|numrecs
condition|;
name|b
operator|++
control|)
block|{
name|frp
operator|=
name|xfs_iext_get_ext
argument_list|(
name|ifp
argument_list|,
name|idx
operator|+
name|b
argument_list|)
expr_stmt|;
operator|*
name|count
operator|+=
name|xfs_bmbt_get_blockcount
argument_list|(
name|frp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Count leaf blocks given a range of extent records originally  * in btree format.  */
end_comment

begin_function
name|int
name|xfs_bmap_disk_count_leaves
parameter_list|(
name|xfs_ifork_t
modifier|*
name|ifp
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_extnum_t
name|idx
parameter_list|,
name|xfs_bmbt_block_t
modifier|*
name|block
parameter_list|,
name|int
name|numrecs
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|int
name|b
decl_stmt|;
name|xfs_bmbt_rec_t
modifier|*
name|frp
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<=
name|numrecs
condition|;
name|b
operator|++
control|)
block|{
name|frp
operator|=
name|XFS_BTREE_REC_ADDR
argument_list|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|block
argument_list|,
name|idx
operator|+
name|b
argument_list|,
name|mp
operator|->
name|m_bmap_dmxr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|count
operator|+=
name|xfs_bmbt_disk_get_blockcount
argument_list|(
name|frp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

