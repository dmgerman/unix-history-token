begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_cap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dfrag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fsops.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/*  * ioctl commands that are used by Linux filesystems  */
end_comment

begin_define
define|#
directive|define
name|XFS_IOC_GETXFLAGS
value|_IOR('f', 1, long)
end_define

begin_define
define|#
directive|define
name|XFS_IOC_SETXFLAGS
value|_IOW('f', 2, long)
end_define

begin_define
define|#
directive|define
name|XFS_IOC_GETVERSION
value|_IOR('v', 1, long)
end_define

begin_undef
undef|#
directive|undef
name|copy_to_user
end_undef

begin_function
specifier|static
name|__inline__
name|int
name|copy_to_user
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|copy_from_user
end_undef

begin_function
specifier|static
name|__inline__
name|int
name|copy_from_user
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_find_handle maps from userspace xfs_fsop_handlereq structure to  * a file or fs handle.  *  * XFS_IOC_PATH_TO_FSHANDLE  *    returns fs handle for a mount point or path within that mount point  * XFS_IOC_FD_TO_HANDLE  *    returns full handle for a FD opened in user space  * XFS_IOC_PATH_TO_HANDLE  *    returns full handle for a path  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_find_handle
parameter_list|(
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RMC
name|int
name|hsize
decl_stmt|;
endif|#
directive|endif
name|xfs_handle_t
name|handle
decl_stmt|;
name|xfs_fsop_handlereq_t
name|hreq
decl_stmt|;
ifdef|#
directive|ifdef
name|RMC
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|hreq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|hreq
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|handle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
if|#
directive|if
literal|0
block|case XFS_IOC_PATH_TO_FSHANDLE: 	case XFS_IOC_PATH_TO_HANDLE: { 		struct nameidata	nd; 		int			error;  		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, 		    UIO_USERSPACE, hreq.path, td); 		error = namei(&nd); 		if (error) 			return error; 		NDFREE(&nd, NDF_ONLY_PNBUF); 		break; 	}  	case XFS_IOC_FD_TO_HANDLE: { 		struct file	*file; 		int		error;  		error = getvnode(td->td_proc->p_fd, hreq.fd,&file); 		if (error) 		    return error;  		error = vget(vp, LK_EXCLUSIVE, td); 		if (error) { 		    fdrop(file); 		    return error; 		} 		fdrop(file); 		break; 	}
endif|#
directive|endif
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|RMC
if|if
condition|(
name|inode
operator|->
name|i_sb
operator|->
name|s_magic
operator|!=
name|XFS_SB_MAGIC
condition|)
block|{
comment|/* we're not in XFS anymore, Toto */
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
switch|switch
condition|(
name|inode
operator|->
name|i_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
case|case
name|S_IFDIR
case|:
case|case
name|S_IFLNK
case|:
break|break;
default|default:
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
return|;
block|}
comment|/* we need the vnode */
name|vp
operator|=
name|vn_from_inode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
comment|/* now we can grab the fsid */
name|memcpy
argument_list|(
operator|&
name|handle
operator|.
name|ha_fsid
argument_list|,
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_altfsid
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsid_t
argument_list|)
argument_list|)
expr_stmt|;
name|hsize
operator|=
sizeof|sizeof
argument_list|(
name|xfs_fsid_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|XFS_IOC_PATH_TO_FSHANDLE
condition|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|lock_mode
decl_stmt|;
comment|/* need to get access to the xfs_inode to read the generation */
name|ip
operator|=
name|xfs_vtoi
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|lock_mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* fill in fid section of handle from inode */
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_fid_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_len
argument_list|)
expr_stmt|;
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_pad
operator|=
literal|0
expr_stmt|;
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_gen
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gen
expr_stmt|;
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_ino
operator|=
name|ip
operator|->
name|i_ino
expr_stmt|;
name|xfs_iunlock_map_shared
argument_list|(
name|ip
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|hsize
operator|=
name|XFS_HSIZE
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
comment|/* now copy our handle into the user buffer& write out the size */
if|if
condition|(
name|copy_to_user
argument_list|(
name|hreq
operator|.
name|ohandle
argument_list|,
operator|&
name|handle
argument_list|,
name|hsize
argument_list|)
operator|||
name|copy_to_user
argument_list|(
name|hreq
operator|.
name|ohandlen
argument_list|,
operator|&
name|hsize
argument_list|,
sizeof|sizeof
argument_list|(
name|__s32
argument_list|)
argument_list|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Convert userspace handle data into vnode (and inode).  * We [ab]use the fact that all the fsop_handlereq ioctl calls  * have a data structure argument whose first component is always  * a xfs_fsop_handlereq_t, so we can cast to and from this type.  * This allows us to optimise the copy_from_user calls and gives  * a handy, shared routine.  *  * If no error, caller must always VN_RELE the returned vp.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_vget_fsop_handlereq
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|,
comment|/* parent inode pointer    */
name|xfs_fsop_handlereq_t
modifier|*
name|hreq
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vp
parameter_list|,
name|struct
name|inode
modifier|*
modifier|*
name|inode
parameter_list|)
block|{
if|#
directive|if
literal|0
block|void			__user *hanp; 	size_t			hlen; 	xfs_fid_t		*xfid; 	xfs_handle_t		*handlep; 	xfs_handle_t		handle; 	xfs_inode_t		*ip; 	struct inode		*inodep; 	xfs_vnode_t		*vpp; 	xfs_ino_t		ino; 	__u32			igen; 	int			error;
comment|/* 	 * Only allow handle opens under a directory. 	 */
block|if (!S_ISDIR(parinode->i_mode)) 		return XFS_ERROR(ENOTDIR);  	hanp = hreq->ihandle; 	hlen = hreq->ihandlen; 	handlep =&handle;  	if (hlen< sizeof(handlep->ha_fsid) || hlen> sizeof(*handlep)) 		return XFS_ERROR(EINVAL); 	if (copy_from_user(handlep, hanp, hlen)) 		return XFS_ERROR(EFAULT); 	if (hlen< sizeof(*handlep)) 		memset(((char *)handlep) + hlen, 0, sizeof(*handlep) - hlen); 	if (hlen> sizeof(handlep->ha_fsid)) { 		if (handlep->ha_fid.xfs_fid_len != 				(hlen - sizeof(handlep->ha_fsid) 					- sizeof(handlep->ha_fid.xfs_fid_len)) 		    || handlep->ha_fid.xfs_fid_pad) 			return XFS_ERROR(EINVAL); 	}
comment|/* 	 * Crack the handle, obtain the inode #& generation # 	 */
block|xfid = (struct xfs_fid *)&handlep->ha_fid; 	if (xfid->xfs_fid_len == sizeof(*xfid) - sizeof(xfid->xfs_fid_len)) { 		ino  = xfid->xfs_fid_ino; 		igen = xfid->xfs_fid_gen; 	} else { 		return XFS_ERROR(EINVAL); 	}
comment|/* 	 * Get the XFS inode, building a vnode to go with it. 	 */
block|error = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_SHARED,&ip, 0); 	if (error) 		return error; 	if (ip == NULL) 		return XFS_ERROR(EIO); 	if (ip->i_d.di_mode == 0 || ip->i_d.di_gen != igen) { 		xfs_iput_new(ip, XFS_ILOCK_SHARED); 		return XFS_ERROR(ENOENT); 	}  	vpp = XFS_ITOV(ip); 	inodep = vn_to_inode(vpp); 	xfs_iunlock(ip, XFS_ILOCK_SHARED);  	*vp = vpp; 	*inode = inodep;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_open_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|new_fd
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|int			error; 	int			permflag; 	struct file		*filp; 	struct inode		*inode; 	struct dentry		*dentry; 	xfs_vnode_t		*vp; 	xfs_fsop_handlereq_t	hreq;  	if (!capable(CAP_SYS_ADMIN)) 		return -XFS_ERROR(EPERM); 	if (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t))) 		return XFS_ERROR(EFAULT);  	error = xfs_vget_fsop_handlereq(mp, parinode,&hreq,&vp,&inode); 	if (error) 		return error;
comment|/* Restrict xfs_open_by_handle to directories& regular files. */
block|if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) { 		iput(inode); 		return XFS_ERROR(EINVAL); 	}
if|#
directive|if
name|BITS_PER_LONG
operator|!=
literal|32
block|hreq.oflags |= O_LARGEFILE;
endif|#
directive|endif
comment|/* Put open permission in namei format. */
block|permflag = hreq.oflags; 	if ((permflag+1)& O_ACCMODE) 		permflag++; 	if (permflag& O_TRUNC) 		permflag |= 2;  	if ((!(permflag& O_APPEND) || (permflag& O_TRUNC))&& 	    (permflag& FMODE_WRITE)&& IS_APPEND(inode)) { 		iput(inode); 		return XFS_ERROR(EPERM); 	}  	if ((permflag& FMODE_WRITE)&& IS_IMMUTABLE(inode)) { 		iput(inode); 		return XFS_ERROR(EACCES); 	}
comment|/* Can't write directories. */
block|if ( S_ISDIR(inode->i_mode)&& (permflag& FMODE_WRITE)) { 		iput(inode); 		return XFS_ERROR(EISDIR); 	}  	if ((new_fd = get_unused_fd())< 0) { 		iput(inode); 		return new_fd; 	}  	dentry = d_alloc_anon(inode); 	if (dentry == NULL) { 		iput(inode); 		put_unused_fd(new_fd); 		return XFS_ERROR(ENOMEM); 	}
comment|/* Ensure umount returns EBUSY on umounts while this file is open. */
block|mntget(parfilp->f_vfsmnt);
comment|/* Create file pointer. */
block|filp = dentry_open(dentry, parfilp->f_vfsmnt, hreq.oflags); 	if (IS_ERR(filp)) { 		put_unused_fd(new_fd); 		return -XFS_ERROR(-PTR_ERR(filp)); 	} 	if (inode->i_mode& S_IFREG) 		filp->f_op =&xfs_invis_file_operations;  	fd_install(new_fd, filp);
endif|#
directive|endif
return|return
name|new_fd
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_readlink_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|xfs_fsop_handlereq_t
name|hreq
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|__u32
name|olen
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|hreq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_handlereq_t
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_vget_fsop_handlereq
argument_list|(
name|mp
argument_list|,
name|parinode
argument_list|,
operator|&
name|hreq
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|#
directive|if
literal|0
comment|/* Restrict this handle operation to symlinks only. */
block|if (vp->v_type != VLNK) { 		VN_RELE(vp); 		return -XFS_ERROR(EINVAL); 	}
endif|#
directive|endif
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|olen
argument_list|,
name|hreq
operator|.
name|ohandlen
argument_list|,
sizeof|sizeof
argument_list|(
name|__u32
argument_list|)
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|aiov
operator|.
name|iov_len
operator|=
name|olen
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|hreq
operator|.
name|ohandle
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|olen
expr_stmt|;
name|XVOP_READLINK
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|IO_INVIS
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|olen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_fssetdm_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|struct fsdmidata	fsd; 	xfs_fsop_setdm_handlereq_t dmhreq; 	struct inode		*inode; 	bhv_desc_t		*bdp; 	xfs_vnode_t		*vp;  	if (!capable(CAP_MKNOD)) 		return XFS_ERROR(EPERM); 	if (copy_from_user(&dmhreq, arg, sizeof(xfs_fsop_setdm_handlereq_t))) 		return XFS_ERROR(EFAULT);  	error = xfs_vget_fsop_handlereq(mp, parinode,&dmhreq.hreq,&vp,&inode); 	if (error) 		return error;  	if (IS_IMMUTABLE(inode) || IS_APPEND(inode)) { 		VN_RELE(vp); 		return XFS_ERROR(EPERM); 	}  	if (copy_from_user(&fsd, dmhreq.data, sizeof(fsd))) { 		VN_RELE(vp); 		return XFS_ERROR(EFAULT); 	}  	bdp = bhv_base_unlocked(VN_BHV_HEAD(vp)); 	error = xfs_set_dmattrs(bdp, fsd.fsd_dmevmask, fsd.fsd_dmstate, NULL);  	VN_RELE(vp); 	if (error) 		return error;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_attrlist_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|attrlist_cursor_kern_t	*cursor; 	xfs_fsop_attrlist_handlereq_t al_hreq; 	struct inode		*inode; 	xfs_vnode_t		*vp; 	char			*kbuf;  	if (!capable(CAP_SYS_ADMIN)) 		return -XFS_ERROR(EPERM); 	if (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t))) 		return -XFS_ERROR(EFAULT); 	if (al_hreq.buflen> XATTR_LIST_MAX) 		return -XFS_ERROR(EINVAL);  	error = xfs_vget_fsop_handlereq(mp, parinode,&al_hreq.hreq,&vp,&inode); 	if (error) 		goto out;  	kbuf = kmalloc(al_hreq.buflen, GFP_KERNEL); 	if (!kbuf) 		goto out_vn_rele;  	cursor = (attrlist_cursor_kern_t *)&al_hreq.pos; 	XVOP_ATTR_LIST(vp, kbuf, al_hreq.buflen, al_hreq.flags, 			cursor, NULL, error); 	if (error) 		goto out_kfree;  	if (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen)) 		error = -EFAULT;   out_kfree: 	kfree(kbuf);  out_vn_rele: 	VN_RELE(vp);  out:
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|STATIC int xfs_attrmulti_attr_get( 	xfs_vnode_t		*vp, 	char			*name, 	char			__user *ubuf, 	__uint32_t		*len, 	__uint32_t		flags) { 	int			error = EFAULT; 	char			*kbuf;  	if (*len> XATTR_SIZE_MAX) 		return EINVAL; 	kbuf = kmalloc(*len, GFP_KERNEL); 	if (!kbuf) 		return ENOMEM;  	XVOP_ATTR_GET(vp, name, kbuf, len, flags, NULL, error); 	if (error) 		goto out_kfree;  	if (copy_to_user(ubuf, kbuf, *len)) 		error = EFAULT;   out_kfree: 	kfree(kbuf); 	return error; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|STATIC int xfs_attrmulti_attr_set( 	xfs_vnode_t		*vp, 	char			*name, 	const char		__user *ubuf, 	__uint32_t		len, 	__uint32_t		flags) { 	int			error = EFAULT; 	char			*kbuf;  	if (IS_RDONLY(&vp->v_inode)) 		return -EROFS; 	if (IS_IMMUTABLE(&vp->v_inode) || IS_APPEND(&vp->v_inode)) 		return EPERM; 	if (len> XATTR_SIZE_MAX) 		return EINVAL;  	kbuf = kmalloc(len, GFP_KERNEL); 	if (!kbuf) 		return ENOMEM;  	if (copy_from_user(kbuf, ubuf, len)) 		goto out_kfree;  	XVOP_ATTR_SET(vp, name, kbuf, len, flags, NULL, error);   out_kfree: 	kfree(kbuf); 	return error; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|STATIC int xfs_attrmulti_attr_remove( 	xfs_vnode_t		*vp, 	char			*name, 	__uint32_t		flags) { 	int			error;  	if (IS_RDONLY(&vp->v_inode)) 		return -EROFS; 	if (IS_IMMUTABLE(&vp->v_inode) || IS_APPEND(&vp->v_inode)) 		return EPERM;  	XVOP_ATTR_REMOVE(vp, name, flags, NULL, error); 	return error; }
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|int
name|xfs_attrmulti_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|xfs_attr_multiop_t	*ops; 	xfs_fsop_attrmulti_handlereq_t am_hreq; 	struct inode		*inode; 	xfs_vnode_t		*vp; 	unsigned int		i, size; 	char			*attr_name;  	if (!capable(CAP_SYS_ADMIN)) 		return -XFS_ERROR(EPERM); 	if (copy_from_user(&am_hreq, arg, sizeof(xfs_fsop_attrmulti_handlereq_t))) 		return -XFS_ERROR(EFAULT);  	error = xfs_vget_fsop_handlereq(mp, parinode,&am_hreq.hreq,&vp,&inode); 	if (error) 		goto out;  	error = E2BIG; 	size = am_hreq.opcount * sizeof(attr_multiop_t); 	if (!size || size> 16 * PAGE_SIZE) 		goto out_vn_rele;  	error = ENOMEM; 	ops = kmalloc(size, GFP_KERNEL); 	if (!ops) 		goto out_vn_rele;  	error = EFAULT; 	if (copy_from_user(ops, am_hreq.ops, size)) 		goto out_kfree_ops;  	attr_name = kmalloc(MAXNAMELEN, GFP_KERNEL); 	if (!attr_name) 		goto out_kfree_ops;   	error = 0; 	for (i = 0; i< am_hreq.opcount; i++) { 		ops[i].am_error = strncpy_from_user(attr_name, 				ops[i].am_attrname, MAXNAMELEN); 		if (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN) 			error = -ERANGE; 		if (ops[i].am_error< 0) 			break;  		switch (ops[i].am_opcode) { 		case ATTR_OP_GET: 			ops[i].am_error = xfs_attrmulti_attr_get(vp, 					attr_name, ops[i].am_attrvalue,&ops[i].am_length, ops[i].am_flags); 			break; 		case ATTR_OP_SET: 			ops[i].am_error = xfs_attrmulti_attr_set(vp, 					attr_name, ops[i].am_attrvalue, 					ops[i].am_length, ops[i].am_flags); 			break; 		case ATTR_OP_REMOVE: 			ops[i].am_error = xfs_attrmulti_attr_remove(vp, 					attr_name, ops[i].am_flags); 			break; 		default: 			ops[i].am_error = EINVAL; 		} 	}  	if (copy_to_user(am_hreq.ops, ops, size)) 		error = XFS_ERROR(EFAULT);  	kfree(attr_name);  out_kfree_ops: 	kfree(ops);  out_vn_rele: 	VN_RELE(vp);  out:
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* prototypes for a few of the stack-hungry cases that have  * their own functions.  Functions are defined after their use  * so gcc doesn't get fancy and inline them with -03 */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_space
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_bulkstat
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_fsgeometry_v1
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_fsgeometry
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_xattr
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_getbmap
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_getbmapx
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|xfs_ioctl
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|//	vp = vn_from_inode(inode);
name|vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xfs_ioctl: bdp %p flags 0x%x cmd 0x%x basecmd 0x%x arg %p\n"
argument_list|,
name|bdp
argument_list|,
name|ioflags
argument_list|,
name|cmd
argument_list|,
name|IOCBASECMD
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_ioctl"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|#
directive|if
literal|0
block|if ((cmd<< 24>> 24) ==  (XFS_IOC_GETBMAPX<< 24>> 24)) { 		cmd = XFS_IOC_GETBMAPX; 	}
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|XFS_IOC_ALLOCSP
case|:
case|case
name|XFS_IOC_FREESP
case|:
case|case
name|XFS_IOC_RESVSP
case|:
case|case
name|XFS_IOC_UNRESVSP
case|:
case|case
name|XFS_IOC_ALLOCSP64
case|:
case|case
name|XFS_IOC_FREESP64
case|:
case|case
name|XFS_IOC_RESVSP64
case|:
case|case
name|XFS_IOC_UNRESVSP64
case|:
comment|/* 		 * Only allow the sys admin to reserve space unless 		 * unwritten extents are enabled. 		 */
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASEXTFLGBIT
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
name|xfs_ioc_space
argument_list|(
name|bdp
argument_list|,
name|vp
argument_list|,
name|filp
argument_list|,
name|ioflags
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_DIOINFO
case|:
block|{
name|struct
name|dioattr
name|da
decl_stmt|;
name|xfs_buftarg_t
modifier|*
name|target
init|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
condition|?
name|mp
operator|->
name|m_rtdev_targp
else|:
name|mp
operator|->
name|m_ddev_targp
decl_stmt|;
name|da
operator|.
name|d_mem
operator|=
name|da
operator|.
name|d_miniosz
operator|=
literal|1
operator|<<
name|target
operator|->
name|bt_sshift
expr_stmt|;
name|da
operator|.
name|d_maxiosz
operator|=
name|INT_MAX
operator|&
operator|~
operator|(
name|da
operator|.
name|d_miniosz
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|da
argument_list|,
sizeof|sizeof
argument_list|(
name|da
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_FSBULKSTAT_SINGLE
case|:
case|case
name|XFS_IOC_FSBULKSTAT
case|:
case|case
name|XFS_IOC_FSINUMBERS
case|:
return|return
name|xfs_ioc_bulkstat
argument_list|(
name|mp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FSGEOMETRY_V1
case|:
return|return
name|xfs_ioc_fsgeometry_v1
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FSGEOMETRY
case|:
return|return
name|xfs_ioc_fsgeometry
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_GETVERSION
case|:
case|case
name|XFS_IOC_GETXFLAGS
case|:
case|case
name|XFS_IOC_SETXFLAGS
case|:
case|case
name|XFS_IOC_FSGETXATTR
case|:
case|case
name|XFS_IOC_FSSETXATTR
case|:
case|case
name|XFS_IOC_FSGETXATTRA
case|:
return|return
name|xfs_ioc_xattr
argument_list|(
name|vp
argument_list|,
name|ip
argument_list|,
name|filp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FSSETDM
case|:
block|{
name|struct
name|fsdmidata
name|dmi
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|dmi
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dmi
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_set_dmattrs
argument_list|(
name|bdp
argument_list|,
name|dmi
operator|.
name|fsd_dmevmask
argument_list|,
name|dmi
operator|.
name|fsd_dmstate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|XFS_IOC_GETBMAP
case|:
case|case
name|XFS_IOC_GETBMAPA
case|:
return|return
name|xfs_ioc_getbmap
argument_list|(
name|bdp
argument_list|,
name|filp
argument_list|,
name|ioflags
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_GETBMAPX
case|:
return|return
name|xfs_ioc_getbmapx
argument_list|(
name|bdp
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FD_TO_HANDLE
case|:
case|case
name|XFS_IOC_PATH_TO_HANDLE
case|:
case|case
name|XFS_IOC_PATH_TO_FSHANDLE
case|:
return|return
name|xfs_find_handle
argument_list|(
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_OPEN_BY_HANDLE
case|:
return|return
name|xfs_open_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_FSSETDM_BY_HANDLE
case|:
return|return
name|xfs_fssetdm_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_READLINK_BY_HANDLE
case|:
return|return
name|xfs_readlink_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_ATTRLIST_BY_HANDLE
case|:
return|return
name|xfs_attrlist_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_ATTRMULTI_BY_HANDLE
case|:
return|return
name|xfs_attrmulti_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_SWAPEXT
case|:
block|{
name|error
operator|=
name|xfs_swapext
argument_list|(
operator|(
expr|struct
name|xfs_swapext
name|__user
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|XFS_IOC_FSCOUNTS
case|:
block|{
name|xfs_fsop_counts_t
name|out
decl_stmt|;
name|error
operator|=
name|xfs_fs_counts
argument_list|(
name|mp
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_SET_RESBLKS
case|:
block|{
name|xfs_fsop_resblks_t
name|inout
decl_stmt|;
name|__uint64_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|inout
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|inout
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* input parameter is passed in resblks field of structure */
name|in
operator|=
name|inout
operator|.
name|resblks
expr_stmt|;
name|error
operator|=
name|xfs_reserve_blocks
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|inout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|inout
argument_list|,
sizeof|sizeof
argument_list|(
name|inout
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_GET_RESBLKS
case|:
block|{
name|xfs_fsop_resblks_t
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
name|error
operator|=
name|xfs_reserve_blocks
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_FSGROWFSDATA
case|:
block|{
name|xfs_growfs_data_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_growfs_data
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|XFS_IOC_FSGROWFSLOG
case|:
block|{
name|xfs_growfs_log_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_growfs_log
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|XFS_IOC_FSGROWFSRT
case|:
block|{
name|xfs_growfs_rt_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_growfs_rt
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|#
directive|if
literal|0
block|case XFS_IOC_FREEZE: 		if (!capable(CAP_SYS_ADMIN)) 			return -EPERM; 		xfs_fs_freeze(mp); 		return 0;  	case XFS_IOC_THAW: 		if (!capable(CAP_SYS_ADMIN)) 			return -EPERM; 		xfs_fs_thaw(mp); 		return 0;
endif|#
directive|endif
case|case
name|XFS_IOC_GOINGDOWN
case|:
block|{
name|__uint32_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|__uint32_t
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_fs_goingdown
argument_list|(
name|mp
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|XFS_IOC_ERROR_INJECTION
case|:
block|{
name|xfs_error_injection_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_errortag_add
argument_list|(
name|in
operator|.
name|errtag
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|XFS_IOC_ERROR_CLEARALL
case|:
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
name|EPERM
return|;
name|error
operator|=
name|xfs_errortag_clearall
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
default|default:
return|return
name|ENOTTY
return|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_space
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|xfs_flock64_t
name|bf
decl_stmt|;
name|int
name|attr_flags
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
literal|0
block|if (vp->v_inode.i_flags& (S_IMMUTABLE|S_APPEND)) 		return -XFS_ERROR(EPERM);  	if (!(filp->f_mode& FMODE_WRITE)) 		return -XFS_ERROR(EBADF);
endif|#
directive|endif
if|if
condition|(
operator|!
name|VN_ISREG
argument_list|(
name|vp
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bf
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|#
directive|if
literal|0
block|if (filp->f_flags& (O_NDELAY|O_NONBLOCK)) 		attr_flags |= ATTR_NONBLOCK;
endif|#
directive|endif
if|if
condition|(
name|ioflags
operator|&
name|IO_INVIS
condition|)
name|attr_flags
operator||=
name|ATTR_DMI
expr_stmt|;
name|error
operator|=
name|xfs_change_file_space
argument_list|(
name|bdp
argument_list|,
name|cmd
argument_list|,
operator|&
name|bf
argument_list|,
name|filp
operator|->
name|f_offset
argument_list|,
name|NULL
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_bulkstat
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|xfs_fsop_bulkreq_t
name|bulkreq
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* # of records returned */
name|xfs_ino_t
name|inlast
decl_stmt|;
comment|/* last inode number */
name|int
name|done
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* done = 1 if there are more stats to get and if bulkstat */
comment|/* should be called again (unused here, but used in dmapi) */
if|#
directive|if
literal|0
block|if (!capable(CAP_SYS_ADMIN)) 		return -EPERM;
endif|#
directive|endif
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bulkreq
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_bulkreq_t
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|inlast
argument_list|,
name|bulkreq
operator|.
name|lastip
argument_list|,
sizeof|sizeof
argument_list|(
name|__s64
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
operator|(
name|count
operator|=
name|bulkreq
operator|.
name|icount
operator|)
operator|<=
literal|0
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|cmd
operator|==
name|XFS_IOC_FSINUMBERS
condition|)
name|error
operator|=
name|xfs_inumbers
argument_list|(
name|mp
argument_list|,
operator|&
name|inlast
argument_list|,
operator|&
name|count
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|XFS_IOC_FSBULKSTAT_SINGLE
condition|)
name|error
operator|=
name|xfs_bulkstat_single
argument_list|(
name|mp
argument_list|,
operator|&
name|inlast
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XFS_IOC_FSBULKSTAT */
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|inlast
operator|!=
literal|0
condition|)
block|{
name|inlast
operator|++
expr_stmt|;
name|error
operator|=
name|xfs_bulkstat_single
argument_list|(
name|mp
argument_list|,
operator|&
name|inlast
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_bulkstat
argument_list|(
name|mp
argument_list|,
operator|&
name|inlast
argument_list|,
operator|&
name|count
argument_list|,
operator|(
name|bulkstat_one_pf
operator|)
name|xfs_bulkstat_one
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_bstat_t
argument_list|)
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|,
name|BULKSTAT_FG_QUICK
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|bulkreq
operator|.
name|ocount
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
name|bulkreq
operator|.
name|lastip
argument_list|,
operator|&
name|inlast
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_ino_t
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|bulkreq
operator|.
name|ocount
argument_list|,
operator|&
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_fsgeometry_v1
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|xfs_fsop_geom_v1_t
name|fsgeo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xfs_fs_geometry
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_fsop_geom_t
operator|*
operator|)
operator|&
name|fsgeo
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|fsgeo
argument_list|,
sizeof|sizeof
argument_list|(
name|fsgeo
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_fsgeometry
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|xfs_fsop_geom_t
name|fsgeo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xfs_fs_geometry
argument_list|(
name|mp
argument_list|,
operator|&
name|fsgeo
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|printf
argument_list|(
literal|"xfs_ioc_fsgeometry: error? %d arg %p\n"
argument_list|,
name|error
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (copy_to_user(arg,&fsgeo, sizeof(fsgeo))) 		return XFS_ERROR(EFAULT);
endif|#
directive|endif
name|memcpy
argument_list|(
name|arg
argument_list|,
operator|&
name|fsgeo
argument_list|,
sizeof|sizeof
argument_list|(
name|fsgeo
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xfs_ioc_fsgeometry: error? %d arg %p\n"
argument_list|,
name|error
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Linux extended inode flags interface.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_SYNC
value|0x00000008
end_define

begin_comment
comment|/* Synchronous updates */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_IMMUTABLE
value|0x00000010
end_define

begin_comment
comment|/* Immutable file */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_APPEND
value|0x00000020
end_define

begin_comment
comment|/* writes to file may only append */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_NODUMP
value|0x00000040
end_define

begin_comment
comment|/* do not dump file */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_NOATIME
value|0x00000080
end_define

begin_comment
comment|/* do not update atime */
end_comment

begin_function
name|STATIC
name|unsigned
name|int
name|xfs_merge_ioc_xflags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|)
block|{
name|unsigned
name|int
name|xflags
init|=
name|start
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_IMMUTABLE
condition|)
name|xflags
operator||=
name|XFS_XFLAG_IMMUTABLE
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_IMMUTABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_APPEND
condition|)
name|xflags
operator||=
name|XFS_XFLAG_APPEND
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_APPEND
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_SYNC
condition|)
name|xflags
operator||=
name|XFS_XFLAG_SYNC
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_SYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_NOATIME
condition|)
name|xflags
operator||=
name|XFS_XFLAG_NOATIME
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_NOATIME
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_NODUMP
condition|)
name|xflags
operator||=
name|XFS_XFLAG_NODUMP
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_NODUMP
expr_stmt|;
return|return
name|xflags
return|;
block|}
end_function

begin_function
name|STATIC
name|unsigned
name|int
name|xfs_di2lxflags
parameter_list|(
name|__uint16_t
name|di_flags
parameter_list|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|di_flags
operator|&
name|XFS_DIFLAG_IMMUTABLE
condition|)
name|flags
operator||=
name|LINUX_XFLAG_IMMUTABLE
expr_stmt|;
if|if
condition|(
name|di_flags
operator|&
name|XFS_DIFLAG_APPEND
condition|)
name|flags
operator||=
name|LINUX_XFLAG_APPEND
expr_stmt|;
if|if
condition|(
name|di_flags
operator|&
name|XFS_DIFLAG_SYNC
condition|)
name|flags
operator||=
name|LINUX_XFLAG_SYNC
expr_stmt|;
if|if
condition|(
name|di_flags
operator|&
name|XFS_DIFLAG_NOATIME
condition|)
name|flags
operator||=
name|LINUX_XFLAG_NOATIME
expr_stmt|;
if|if
condition|(
name|di_flags
operator|&
name|XFS_DIFLAG_NODUMP
condition|)
name|flags
operator||=
name|LINUX_XFLAG_NODUMP
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_xattr
parameter_list|(
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fsxattr
name|fa
decl_stmt|;
name|struct
name|xfs_vattr
modifier|*
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|attr_flags
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|attr_flags
operator|=
literal|0
expr_stmt|;
name|vattr
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xfs_vattr
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|vattr
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|XFS_IOC_FSGETXATTR
case|:
block|{
name|vattr
operator|->
name|va_mask
operator|=
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
expr|\
name|XFS_AT_NEXTENTS
operator||
name|XFS_AT_PROJID
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vattr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|error
operator|=
name|error
expr_stmt|;
break|break;
block|}
name|fa
operator|.
name|fsx_xflags
operator|=
name|vattr
operator|->
name|va_xflags
expr_stmt|;
name|fa
operator|.
name|fsx_extsize
operator|=
name|vattr
operator|->
name|va_extsize
expr_stmt|;
name|fa
operator|.
name|fsx_nextents
operator|=
name|vattr
operator|->
name|va_nextents
expr_stmt|;
name|fa
operator|.
name|fsx_projid
operator|=
name|vattr
operator|->
name|va_projid
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|fa
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|XFS_IOC_FSSETXATTR
case|:
block|{
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|fa
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|attr_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (filp->f_flags& (O_NDELAY|O_NONBLOCK)) 			attr_flags |= ATTR_NONBLOCK;
endif|#
directive|endif
name|vattr
operator|->
name|va_mask
operator|=
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_PROJID
expr_stmt|;
name|vattr
operator|->
name|va_xflags
operator|=
name|fa
operator|.
name|fsx_xflags
expr_stmt|;
name|vattr
operator|->
name|va_extsize
operator|=
name|fa
operator|.
name|fsx_extsize
expr_stmt|;
name|vattr
operator|->
name|va_projid
operator|=
name|fa
operator|.
name|fsx_projid
expr_stmt|;
name|XVOP_SETATTR
argument_list|(
name|vp
argument_list|,
name|vattr
argument_list|,
name|attr_flags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (likely(!error)) 			__vn_revalidate(vp, vattr);
comment|/* update flags */
endif|#
directive|endif
name|error
operator|=
name|error
expr_stmt|;
break|break;
block|}
case|case
name|XFS_IOC_FSGETXATTRA
case|:
block|{
name|vattr
operator|->
name|va_mask
operator|=
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
expr|\
name|XFS_AT_ANEXTENTS
operator||
name|XFS_AT_PROJID
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vattr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|error
operator|=
name|error
expr_stmt|;
break|break;
block|}
name|fa
operator|.
name|fsx_xflags
operator|=
name|vattr
operator|->
name|va_xflags
expr_stmt|;
name|fa
operator|.
name|fsx_extsize
operator|=
name|vattr
operator|->
name|va_extsize
expr_stmt|;
name|fa
operator|.
name|fsx_nextents
operator|=
name|vattr
operator|->
name|va_anextents
expr_stmt|;
name|fa
operator|.
name|fsx_projid
operator|=
name|vattr
operator|->
name|va_projid
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|fa
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|XFS_IOC_GETXFLAGS
case|:
block|{
name|flags
operator|=
name|xfs_di2lxflags
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
case|case
name|XFS_IOC_SETXFLAGS
case|:
block|{
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|flags
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|LINUX_XFLAG_IMMUTABLE
operator||
name|LINUX_XFLAG_APPEND
operator||
expr|\
name|LINUX_XFLAG_NOATIME
operator||
name|LINUX_XFLAG_NODUMP
operator||
expr|\
name|LINUX_XFLAG_SYNC
operator|)
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|attr_flags = 0; 		if (filp->f_flags& (O_NDELAY|O_NONBLOCK)) 			attr_flags |= ATTR_NONBLOCK;
endif|#
directive|endif
name|vattr
operator|->
name|va_mask
operator|=
name|XFS_AT_XFLAGS
expr_stmt|;
name|vattr
operator|->
name|va_xflags
operator|=
name|xfs_merge_ioc_xflags
argument_list|(
name|flags
argument_list|,
name|xfs_ip2xflags
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|XVOP_SETATTR
argument_list|(
name|vp
argument_list|,
name|vattr
argument_list|,
name|attr_flags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (likely(!error)) 			__vn_revalidate(vp, vattr);
comment|/* update flags */
endif|#
directive|endif
name|error
operator|=
name|error
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|case XFS_IOC_GETVERSION: { 		flags = vn_to_inode(vp)->i_generation; 		if (copy_to_user(arg,&flags, sizeof(flags))) 			error = EFAULT; 		break; 	}
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|kmem_free
argument_list|(
name|vattr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xfs_vattr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_getbmap
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|getbmap
name|bm
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bm
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bm
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|bm
operator|.
name|bmv_count
operator|<
literal|2
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|iflags
operator|=
operator|(
name|cmd
operator|==
name|XFS_IOC_GETBMAPA
condition|?
name|BMV_IF_ATTRFORK
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ioflags
operator|&
name|IO_INVIS
condition|)
name|iflags
operator||=
name|BMV_IF_NO_DMAPI_READ
expr_stmt|;
name|error
operator|=
name|xfs_getbmap
argument_list|(
name|bdp
argument_list|,
operator|&
name|bm
argument_list|,
operator|(
expr|struct
name|getbmap
name|__user
operator|*
operator|)
name|arg
operator|+
literal|1
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|bm
argument_list|,
sizeof|sizeof
argument_list|(
name|bm
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_getbmapx
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|void
name|__user
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|getbmapx
name|bmx
decl_stmt|;
name|struct
name|getbmap
name|bm
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bmx
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bmx
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmx
operator|.
name|bmv_count
operator|<
literal|2
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 	 * Map input getbmapx structure to a getbmap 	 * structure for xfs_getbmap. 	 */
name|GETBMAP_CONVERT
argument_list|(
name|bmx
argument_list|,
name|bm
argument_list|)
expr_stmt|;
name|iflags
operator|=
name|bmx
operator|.
name|bmv_iflags
expr_stmt|;
if|if
condition|(
name|iflags
operator|&
operator|(
operator|~
name|BMV_IF_VALID
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|iflags
operator||=
name|BMV_IF_EXTENDED
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d arg+1 %p arg %p\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
expr|struct
name|getbmapx
name|__user
operator|*
operator|)
name|arg
operator|+
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_getbmap
argument_list|(
name|bdp
argument_list|,
operator|&
name|bm
argument_list|,
operator|(
expr|struct
name|getbmapx
name|__user
operator|*
operator|)
name|arg
operator|+
literal|1
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|GETBMAP_CONVERT
argument_list|(
name|bm
argument_list|,
name|bmx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|arg
argument_list|,
operator|&
name|bmx
argument_list|,
sizeof|sizeof
argument_list|(
name|bmx
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|xfs_ioctl
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

