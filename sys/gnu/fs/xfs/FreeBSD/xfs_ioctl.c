begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_cap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dfrag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fsops.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XXXKAN
end_ifdef

begin_comment
comment|/*  * ioctl commands that are used by Linux filesystems  */
end_comment

begin_define
define|#
directive|define
name|XFS_IOC_GETXFLAGS
value|_IOR('f', 1, long)
end_define

begin_define
define|#
directive|define
name|XFS_IOC_SETXFLAGS
value|_IOW('f', 2, long)
end_define

begin_define
define|#
directive|define
name|XFS_IOC_GETVERSION
value|_IOR('v', 1, long)
end_define

begin_comment
comment|/*  * xfs_find_handle maps from userspace xfs_fsop_handlereq structure to  * a file or fs handle.  *  * XFS_IOC_PATH_TO_FSHANDLE  *    returns fs handle for a mount point or path within that mount point  * XFS_IOC_FD_TO_HANDLE  *    returns full handle for a FD opened in user space  * XFS_IOC_PATH_TO_HANDLE  *    returns full handle for a path  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_find_handle
parameter_list|(
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|int
name|hsize
decl_stmt|;
name|xfs_handle_t
name|handle
decl_stmt|;
name|xfs_fsop_handlereq_t
name|hreq
decl_stmt|;
name|struct
name|xfs_vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|hreq
argument_list|,
operator|(
name|xfs_fsop_handlereq_t
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|hreq
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|handle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|XFS_IOC_PATH_TO_FSHANDLE
case|:
case|case
name|XFS_IOC_PATH_TO_HANDLE
case|:
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
operator||
name|NOOBJ
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|hreq
operator|.
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_IOC_FD_TO_HANDLE
case|:
block|{
name|struct
name|file
modifier|*
name|file
decl_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|hreq
operator|.
name|fd
argument_list|,
operator|&
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fdrop
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fdrop
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|inode
operator|->
name|i_sb
operator|->
name|s_magic
operator|!=
name|XFS_SB_MAGIC
condition|)
block|{
comment|/* we're not in XFS anymore, Toto */
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* we need the vnode */
name|vp
operator|=
name|LINVFS_GET_VP
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
return|;
block|}
comment|/* now we can grab the fsid */
name|memcpy
argument_list|(
operator|&
name|handle
operator|.
name|ha_fsid
argument_list|,
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_altfsid
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsid_t
argument_list|)
argument_list|)
expr_stmt|;
name|hsize
operator|=
sizeof|sizeof
argument_list|(
name|xfs_fsid_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|XFS_IOC_PATH_TO_FSHANDLE
condition|)
block|{
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|bhv_desc_t
modifier|*
name|bhv
decl_stmt|;
name|int
name|lock_mode
decl_stmt|;
comment|/* need to get access to the xfs_inode to read the generation */
name|bhv
operator|=
name|vn_bhv_lookup_unlocked
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|xfs_vnodeops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bhv
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bhv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|lock_mode
operator|=
name|xfs_ilock_map_shared
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* fill in fid section of handle from inode */
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_fid_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_len
argument_list|)
expr_stmt|;
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_pad
operator|=
literal|0
expr_stmt|;
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_gen
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_gen
expr_stmt|;
name|handle
operator|.
name|ha_fid
operator|.
name|xfs_fid_ino
operator|=
name|ip
operator|->
name|i_ino
expr_stmt|;
name|xfs_iunlock_map_shared
argument_list|(
name|ip
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|hsize
operator|=
name|XFS_HSIZE
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
comment|/* now copy our handle into the user buffer& write out the size */
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|xfs_handle_t
operator|*
operator|)
name|hreq
operator|.
name|ohandle
argument_list|,
operator|&
name|handle
argument_list|,
name|hsize
argument_list|)
operator|||
name|copy_to_user
argument_list|(
name|hreq
operator|.
name|ohandlen
argument_list|,
operator|&
name|hsize
argument_list|,
sizeof|sizeof
argument_list|(
name|__s32
argument_list|)
argument_list|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Convert userspace handle data into vnode (and inode).  * We [ab]use the fact that all the fsop_handlereq ioctl calls  * have a data structure argument whose first component is always  * a xfs_fsop_handlereq_t, so we can cast to and from this type.  * This allows us to optimise the copy_from_user calls and gives  * a handy, shared routine.  *  * If no error, caller must always VN_RELE the returned vp.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_vget_fsop_handlereq
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|,
comment|/* parent inode pointer    */
name|int
name|cap
parameter_list|,
comment|/* capability level for op */
name|unsigned
name|long
name|arg
parameter_list|,
comment|/* userspace data pointer  */
name|unsigned
name|long
name|size
parameter_list|,
comment|/* size of expected struct */
comment|/* output arguments */
name|xfs_fsop_handlereq_t
modifier|*
name|hreq
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vp
parameter_list|,
name|struct
name|inode
modifier|*
modifier|*
name|inode
parameter_list|)
block|{
name|void
modifier|*
name|hanp
decl_stmt|;
name|size_t
name|hlen
decl_stmt|;
name|xfs_fid_t
modifier|*
name|xfid
decl_stmt|;
name|xfs_handle_t
modifier|*
name|handlep
decl_stmt|;
name|xfs_handle_t
name|handle
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|struct
name|inode
modifier|*
name|inodep
decl_stmt|;
name|vnode_t
modifier|*
name|vpp
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|__u32
name|igen
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|cap
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
comment|/* 	 * Only allow handle opens under a directory. 	 */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|parinode
operator|->
name|i_mode
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
return|;
comment|/* 	 * Copy the handle down from the user and validate 	 * that it looks to be in the correct format. 	 */
if|if
condition|(
name|copy_from_user
argument_list|(
name|hreq
argument_list|,
operator|(
expr|struct
name|xfs_fsop_handlereq
operator|*
operator|)
name|arg
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|hanp
operator|=
name|hreq
operator|->
name|ihandle
expr_stmt|;
name|hlen
operator|=
name|hreq
operator|->
name|ihandlen
expr_stmt|;
name|handlep
operator|=
operator|&
name|handle
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
name|handlep
operator|->
name|ha_fsid
argument_list|)
operator|||
name|hlen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|handlep
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
name|handlep
argument_list|,
name|hanp
argument_list|,
name|hlen
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|handlep
argument_list|)
condition|)
name|memset
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|handlep
operator|)
operator|+
name|hlen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|handlep
argument_list|)
operator|-
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
name|handlep
operator|->
name|ha_fsid
argument_list|)
condition|)
block|{
if|if
condition|(
name|handlep
operator|->
name|ha_fid
operator|.
name|xfs_fid_len
operator|!=
operator|(
name|hlen
operator|-
sizeof|sizeof
argument_list|(
name|handlep
operator|->
name|ha_fsid
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|handlep
operator|->
name|ha_fid
operator|.
name|xfs_fid_len
argument_list|)
operator|)
operator|||
name|handlep
operator|->
name|ha_fid
operator|.
name|xfs_fid_pad
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * Crack the handle, obtain the inode #& generation # 	 */
name|xfid
operator|=
operator|(
expr|struct
name|xfs_fid
operator|*
operator|)
operator|&
name|handlep
operator|->
name|ha_fid
expr_stmt|;
if|if
condition|(
name|xfid
operator|->
name|xfs_fid_len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|xfid
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfid
operator|->
name|xfs_fid_len
argument_list|)
condition|)
block|{
name|ino
operator|=
name|xfid
operator|->
name|xfs_fid_ino
expr_stmt|;
name|igen
operator|=
name|xfid
operator|->
name|xfs_fid_gen
expr_stmt|;
block|}
else|else
block|{
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * Get the XFS inode, building a vnode to go with it. 	 */
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ino
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|,
operator|&
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|||
name|ip
operator|->
name|i_d
operator|.
name|di_gen
operator|!=
name|igen
condition|)
block|{
name|xfs_iput_new
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
name|vpp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|inodep
operator|=
name|LINVFS_GET_IP
argument_list|(
name|vpp
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|vpp
expr_stmt|;
operator|*
name|inode
operator|=
name|inodep
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_open_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|new_fd
decl_stmt|;
name|int
name|permflag
decl_stmt|;
name|struct
name|file
modifier|*
name|filp
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|struct
name|dentry
modifier|*
name|dentry
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_fsop_handlereq_t
name|hreq
decl_stmt|;
name|error
operator|=
name|xfs_vget_fsop_handlereq
argument_list|(
name|mp
argument_list|,
name|parinode
argument_list|,
name|CAP_SYS_ADMIN
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_handlereq_t
argument_list|)
argument_list|,
operator|&
name|hreq
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
comment|/* Restrict xfs_open_by_handle to directories& regular files. */
if|if
condition|(
operator|!
operator|(
name|S_ISREG
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
operator|||
name|S_ISDIR
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
operator|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|#
directive|if
name|BITS_PER_LONG
operator|!=
literal|32
name|hreq
operator|.
name|oflags
operator||=
name|O_LARGEFILE
expr_stmt|;
endif|#
directive|endif
comment|/* Put open permission in namei format. */
name|permflag
operator|=
name|hreq
operator|.
name|oflags
expr_stmt|;
if|if
condition|(
operator|(
name|permflag
operator|+
literal|1
operator|)
operator|&
name|O_ACCMODE
condition|)
name|permflag
operator|++
expr_stmt|;
if|if
condition|(
name|permflag
operator|&
name|O_TRUNC
condition|)
name|permflag
operator||=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|permflag
operator|&
name|O_APPEND
operator|)
operator|||
operator|(
name|permflag
operator|&
name|O_TRUNC
operator|)
operator|)
operator|&&
operator|(
name|permflag
operator|&
name|FMODE_WRITE
operator|)
operator|&&
name|IS_APPEND
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|permflag
operator|&
name|FMODE_WRITE
operator|)
operator|&&
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EACCES
argument_list|)
return|;
block|}
comment|/* Can't write directories. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
operator|&&
operator|(
name|permflag
operator|&
name|FMODE_WRITE
operator|)
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EISDIR
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|new_fd
operator|=
name|get_unused_fd
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|new_fd
return|;
block|}
name|dentry
operator|=
name|d_alloc_anon
argument_list|(
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dentry
operator|==
name|NULL
condition|)
block|{
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|put_unused_fd
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
comment|/* Ensure umount returns EBUSY on umounts while this file is open. */
name|mntget
argument_list|(
name|parfilp
operator|->
name|f_vfsmnt
argument_list|)
expr_stmt|;
comment|/* Create file pointer. */
name|filp
operator|=
name|dentry_open
argument_list|(
name|dentry
argument_list|,
name|parfilp
operator|->
name|f_vfsmnt
argument_list|,
name|hreq
operator|.
name|oflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|filp
argument_list|)
condition|)
block|{
name|put_unused_fd
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
operator|-
name|PTR_ERR
argument_list|(
name|filp
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|inode
operator|->
name|i_mode
operator|&
name|S_IFREG
condition|)
name|filp
operator|->
name|f_op
operator|=
operator|&
name|linvfs_invis_file_operations
expr_stmt|;
name|fd_install
argument_list|(
name|new_fd
argument_list|,
name|filp
argument_list|)
expr_stmt|;
return|return
name|new_fd
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_readlink_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|xfs_fsop_handlereq_t
name|hreq
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|__u32
name|olen
decl_stmt|;
name|error
operator|=
name|xfs_vget_fsop_handlereq
argument_list|(
name|mp
argument_list|,
name|parinode
argument_list|,
name|CAP_SYS_ADMIN
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_handlereq_t
argument_list|)
argument_list|,
operator|&
name|hreq
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
comment|/* Restrict this handle operation to symlinks only. */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|olen
argument_list|,
name|hreq
operator|.
name|ohandlen
argument_list|,
sizeof|sizeof
argument_list|(
name|__u32
argument_list|)
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|aiov
operator|.
name|iov_len
operator|=
name|olen
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|hreq
operator|.
name|ohandle
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|olen
expr_stmt|;
name|VOP_READLINK
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|IO_INVIS
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|olen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_fssetdm_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|fsdmidata
name|fsd
decl_stmt|;
name|xfs_fsop_setdm_handlereq_t
name|dmhreq
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|bhv_desc_t
modifier|*
name|bdp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|error
operator|=
name|xfs_vget_fsop_handlereq
argument_list|(
name|mp
argument_list|,
name|parinode
argument_list|,
name|CAP_MKNOD
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_setdm_handlereq_t
argument_list|)
argument_list|,
operator|(
name|xfs_fsop_handlereq_t
operator|*
operator|)
operator|&
name|dmhreq
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
operator|||
name|IS_APPEND
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
block|}
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|fsd
argument_list|,
name|dmhreq
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|fsd
argument_list|)
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
name|bdp
operator|=
name|bhv_base_unlocked
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_set_dmattrs
argument_list|(
name|bdp
argument_list|,
name|fsd
operator|.
name|fsd_dmevmask
argument_list|,
name|fsd
operator|.
name|fsd_dmstate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_attrlist_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|attrlist_cursor_kern_t
modifier|*
name|cursor
decl_stmt|;
name|xfs_fsop_attrlist_handlereq_t
name|al_hreq
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|error
operator|=
name|xfs_vget_fsop_handlereq
argument_list|(
name|mp
argument_list|,
name|parinode
argument_list|,
name|CAP_SYS_ADMIN
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_attrlist_handlereq_t
argument_list|)
argument_list|,
operator|(
name|xfs_fsop_handlereq_t
operator|*
operator|)
operator|&
name|al_hreq
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|cursor
operator|=
operator|(
name|attrlist_cursor_kern_t
operator|*
operator|)
operator|&
name|al_hreq
operator|.
name|pos
expr_stmt|;
name|VOP_ATTR_LIST
argument_list|(
name|vp
argument_list|,
name|al_hreq
operator|.
name|buffer
argument_list|,
name|al_hreq
operator|.
name|buflen
argument_list|,
name|al_hreq
operator|.
name|flags
argument_list|,
name|cursor
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_attrmulti_by_handle
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|struct
name|file
modifier|*
name|parfilp
parameter_list|,
name|struct
name|inode
modifier|*
name|parinode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_attr_multiop_t
modifier|*
name|ops
decl_stmt|;
name|xfs_fsop_attrmulti_handlereq_t
name|am_hreq
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|error
operator|=
name|xfs_vget_fsop_handlereq
argument_list|(
name|mp
argument_list|,
name|parinode
argument_list|,
name|CAP_SYS_ADMIN
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_attrmulti_handlereq_t
argument_list|)
argument_list|,
operator|(
name|xfs_fsop_handlereq_t
operator|*
operator|)
operator|&
name|am_hreq
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|size
operator|=
name|am_hreq
operator|.
name|opcount
operator|*
sizeof|sizeof
argument_list|(
name|attr_multiop_t
argument_list|)
expr_stmt|;
name|ops
operator|=
operator|(
name|xfs_attr_multiop_t
operator|*
operator|)
name|kmalloc
argument_list|(
name|size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
if|if
condition|(
name|copy_from_user
argument_list|(
name|ops
argument_list|,
name|am_hreq
operator|.
name|ops
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|ops
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|am_hreq
operator|.
name|opcount
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ops
index|[
name|i
index|]
operator|.
name|am_opcode
condition|)
block|{
case|case
name|ATTR_OP_GET
case|:
name|VOP_ATTR_GET
argument_list|(
name|vp
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_attrname
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_attrvalue
argument_list|,
operator|&
name|ops
index|[
name|i
index|]
operator|.
name|am_length
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_flags
argument_list|,
name|NULL
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_error
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATTR_OP_SET
case|:
if|if
condition|(
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
operator|||
name|IS_APPEND
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|am_error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
name|VOP_ATTR_SET
argument_list|(
name|vp
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_attrname
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_attrvalue
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_length
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_flags
argument_list|,
name|NULL
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_error
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATTR_OP_REMOVE
case|:
if|if
condition|(
name|IS_IMMUTABLE
argument_list|(
name|inode
argument_list|)
operator|||
name|IS_APPEND
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|ops
index|[
name|i
index|]
operator|.
name|am_error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
name|VOP_ATTR_REMOVE
argument_list|(
name|vp
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_attrname
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_flags
argument_list|,
name|NULL
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|am_error
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ops
index|[
name|i
index|]
operator|.
name|am_error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|copy_to_user
argument_list|(
name|am_hreq
operator|.
name|ops
argument_list|,
name|ops
argument_list|,
name|size
argument_list|)
condition|)
name|error
operator|=
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ops
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* prototypes for a few of the stack-hungry cases that have  * their own functions.  Functions are defined after their use  * so gcc doesn't get fancy and inline them with -03 */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_space
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_bulkstat
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_fsgeometry_v1
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_fsgeometry
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_xattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_getbmap
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_ioc_getbmapx
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|xfs_ioctl
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|vp
operator|=
name|LINVFS_GET_VP
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_ioctl"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|XFS_IOC_ALLOCSP
case|:
case|case
name|XFS_IOC_FREESP
case|:
case|case
name|XFS_IOC_RESVSP
case|:
case|case
name|XFS_IOC_UNRESVSP
case|:
case|case
name|XFS_IOC_ALLOCSP64
case|:
case|case
name|XFS_IOC_FREESP64
case|:
case|case
name|XFS_IOC_RESVSP64
case|:
case|case
name|XFS_IOC_UNRESVSP64
case|:
comment|/* 		 * Only allow the sys admin to reserve space unless 		 * unwritten extents are enabled. 		 */
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASEXTFLGBIT
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
return|return
name|xfs_ioc_space
argument_list|(
name|bdp
argument_list|,
name|vp
argument_list|,
name|filp
argument_list|,
name|ioflags
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_DIOINFO
case|:
block|{
name|struct
name|dioattr
name|da
decl_stmt|;
name|da
operator|.
name|d_miniosz
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|da
operator|.
name|d_mem
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
comment|/* 		 * this only really needs to be BBSIZE. 		 * it is set to the file system block size to 		 * avoid having to do block zeroing on short writes. 		 */
name|da
operator|.
name|d_maxiosz
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|KIO_MAX_ATOMIC_IO
operator|<<
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
expr|struct
name|dioattr
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|da
argument_list|,
sizeof|sizeof
argument_list|(
name|da
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_FSBULKSTAT_SINGLE
case|:
case|case
name|XFS_IOC_FSBULKSTAT
case|:
case|case
name|XFS_IOC_FSINUMBERS
case|:
return|return
name|xfs_ioc_bulkstat
argument_list|(
name|mp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FSGEOMETRY_V1
case|:
return|return
name|xfs_ioc_fsgeometry_v1
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FSGEOMETRY
case|:
return|return
name|xfs_ioc_fsgeometry
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_GETVERSION
case|:
case|case
name|XFS_IOC_GETXFLAGS
case|:
case|case
name|XFS_IOC_SETXFLAGS
case|:
case|case
name|XFS_IOC_FSGETXATTR
case|:
case|case
name|XFS_IOC_FSSETXATTR
case|:
case|case
name|XFS_IOC_FSGETXATTRA
case|:
return|return
name|xfs_ioc_xattr
argument_list|(
name|vp
argument_list|,
name|ip
argument_list|,
name|filp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FSSETDM
case|:
block|{
name|struct
name|fsdmidata
name|dmi
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|dmi
argument_list|,
operator|(
expr|struct
name|fsdmidata
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dmi
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_set_dmattrs
argument_list|(
name|bdp
argument_list|,
name|dmi
operator|.
name|fsd_dmevmask
argument_list|,
name|dmi
operator|.
name|fsd_dmstate
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_GETBMAP
case|:
case|case
name|XFS_IOC_GETBMAPA
case|:
return|return
name|xfs_ioc_getbmap
argument_list|(
name|bdp
argument_list|,
name|filp
argument_list|,
name|ioflags
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_GETBMAPX
case|:
return|return
name|xfs_ioc_getbmapx
argument_list|(
name|bdp
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_FD_TO_HANDLE
case|:
case|case
name|XFS_IOC_PATH_TO_HANDLE
case|:
case|case
name|XFS_IOC_PATH_TO_FSHANDLE
case|:
return|return
name|xfs_find_handle
argument_list|(
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|XFS_IOC_OPEN_BY_HANDLE
case|:
return|return
name|xfs_open_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_FSSETDM_BY_HANDLE
case|:
return|return
name|xfs_fssetdm_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_READLINK_BY_HANDLE
case|:
return|return
name|xfs_readlink_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_ATTRLIST_BY_HANDLE
case|:
return|return
name|xfs_attrlist_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_ATTRMULTI_BY_HANDLE
case|:
return|return
name|xfs_attrmulti_by_handle
argument_list|(
name|mp
argument_list|,
name|arg
argument_list|,
name|filp
argument_list|,
name|inode
argument_list|)
return|;
case|case
name|XFS_IOC_SWAPEXT
case|:
block|{
name|error
operator|=
name|xfs_swapext
argument_list|(
operator|(
expr|struct
name|xfs_swapext
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_FSCOUNTS
case|:
block|{
name|xfs_fsop_counts_t
name|out
decl_stmt|;
name|error
operator|=
name|xfs_fs_counts
argument_list|(
name|mp
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_SET_RESBLKS
case|:
block|{
name|xfs_fsop_resblks_t
name|inout
decl_stmt|;
name|__uint64_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|inout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|inout
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* input parameter is passed in resblks field of structure */
name|in
operator|=
name|inout
operator|.
name|resblks
expr_stmt|;
name|error
operator|=
name|xfs_reserve_blocks
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|inout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|inout
argument_list|,
sizeof|sizeof
argument_list|(
name|inout
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_GET_RESBLKS
case|:
block|{
name|xfs_fsop_resblks_t
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|error
operator|=
name|xfs_reserve_blocks
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_FSGROWFSDATA
case|:
block|{
name|xfs_growfs_data_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_growfs_data
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_FSGROWFSLOG
case|:
block|{
name|xfs_growfs_log_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_growfs_log
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_FSGROWFSRT
case|:
block|{
name|xfs_growfs_rt_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_growfs_rt
argument_list|(
name|mp
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_FREEZE
case|:
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|xfs_fs_freeze
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_IOC_THAW
case|:
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
name|xfs_fs_thaw
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_IOC_GOINGDOWN
case|:
block|{
name|__uint32_t
name|in
decl_stmt|;
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|get_user
argument_list|(
name|in
argument_list|,
operator|(
name|__uint32_t
operator|*
operator|)
name|arg
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_fs_goingdown
argument_list|(
name|mp
argument_list|,
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_ERROR_INJECTION
case|:
block|{
name|xfs_error_injection_t
name|in
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|error
operator|=
name|xfs_errortag_add
argument_list|(
name|in
operator|.
name|errtag
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_ERROR_CLEARALL
case|:
name|error
operator|=
name|xfs_errortag_clearall
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
default|default:
return|return
operator|-
name|ENOTTY
return|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_space
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|xfs_flock64_t
name|bf
decl_stmt|;
name|int
name|attr_flags
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_inode
operator|.
name|i_flags
operator|&
operator|(
name|S_IMMUTABLE
operator||
name|S_APPEND
operator|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EPERM
argument_list|)
return|;
if|if
condition|(
name|filp
operator|->
name|f_flags
operator|&
name|O_RDONLY
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
return|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bf
argument_list|,
operator|(
name|xfs_flock64_t
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|filp
operator|->
name|f_flags
operator|&
operator|(
name|O_NDELAY
operator||
name|O_NONBLOCK
operator|)
condition|)
name|attr_flags
operator||=
name|ATTR_NONBLOCK
expr_stmt|;
if|if
condition|(
name|ioflags
operator|&
name|IO_INVIS
condition|)
name|attr_flags
operator||=
name|ATTR_DMI
expr_stmt|;
name|error
operator|=
name|xfs_change_file_space
argument_list|(
name|bdp
argument_list|,
name|cmd
argument_list|,
operator|&
name|bf
argument_list|,
name|filp
operator|->
name|f_pos
argument_list|,
name|NULL
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_bulkstat
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|xfs_fsop_bulkreq_t
name|bulkreq
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* # of records returned */
name|xfs_ino_t
name|inlast
decl_stmt|;
comment|/* last inode number */
name|int
name|done
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* done = 1 if there are more stats to get and if bulkstat */
comment|/* should be called again (unused here, but used in dmapi) */
if|if
condition|(
operator|!
name|capable
argument_list|(
name|CAP_SYS_ADMIN
argument_list|)
condition|)
return|return
operator|-
name|EPERM
return|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bulkreq
argument_list|,
operator|(
name|xfs_fsop_bulkreq_t
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_fsop_bulkreq_t
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|inlast
argument_list|,
operator|(
name|__s64
operator|*
operator|)
name|bulkreq
operator|.
name|lastip
argument_list|,
sizeof|sizeof
argument_list|(
name|__s64
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
operator|(
name|count
operator|=
name|bulkreq
operator|.
name|icount
operator|)
operator|<=
literal|0
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|cmd
operator|==
name|XFS_IOC_FSINUMBERS
condition|)
name|error
operator|=
name|xfs_inumbers
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|inlast
argument_list|,
operator|&
name|count
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|XFS_IOC_FSBULKSTAT_SINGLE
condition|)
name|error
operator|=
name|xfs_bulkstat_single
argument_list|(
name|mp
argument_list|,
operator|&
name|inlast
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XFS_IOC_FSBULKSTAT */
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|inlast
operator|!=
literal|0
condition|)
block|{
name|inlast
operator|++
expr_stmt|;
name|error
operator|=
name|xfs_bulkstat_single
argument_list|(
name|mp
argument_list|,
operator|&
name|inlast
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|xfs_bulkstat
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|inlast
argument_list|,
operator|&
name|count
argument_list|,
operator|(
name|bulkstat_one_pf
operator|)
name|xfs_bulkstat_one
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_bstat_t
argument_list|)
argument_list|,
name|bulkreq
operator|.
name|ubuffer
argument_list|,
name|BULKSTAT_FG_QUICK
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|bulkreq
operator|.
name|ocount
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|xfs_ino_t
operator|*
operator|)
name|bulkreq
operator|.
name|lastip
argument_list|,
operator|&
name|inlast
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_ino_t
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|__s32
operator|*
operator|)
name|bulkreq
operator|.
name|ocount
argument_list|,
operator|&
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_fsgeometry_v1
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|xfs_fsop_geom_v1_t
name|fsgeo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xfs_fs_geometry
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_fsop_geom_t
operator|*
operator|)
operator|&
name|fsgeo
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|xfs_fsop_geom_t
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|fsgeo
argument_list|,
sizeof|sizeof
argument_list|(
name|fsgeo
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_fsgeometry
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|xfs_fsop_geom_t
name|fsgeo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xfs_fs_geometry
argument_list|(
name|mp
argument_list|,
operator|&
name|fsgeo
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|xfs_fsop_geom_t
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|fsgeo
argument_list|,
sizeof|sizeof
argument_list|(
name|fsgeo
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Linux extended inode flags interface.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_SYNC
value|0x00000008
end_define

begin_comment
comment|/* Synchronous updates */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_IMMUTABLE
value|0x00000010
end_define

begin_comment
comment|/* Immutable file */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_APPEND
value|0x00000020
end_define

begin_comment
comment|/* writes to file may only append */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_NODUMP
value|0x00000040
end_define

begin_comment
comment|/* do not dump file */
end_comment

begin_define
define|#
directive|define
name|LINUX_XFLAG_NOATIME
value|0x00000080
end_define

begin_comment
comment|/* do not update atime */
end_comment

begin_function
name|STATIC
name|unsigned
name|int
name|xfs_merge_ioc_xflags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|)
block|{
name|unsigned
name|int
name|xflags
init|=
name|start
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_IMMUTABLE
condition|)
name|xflags
operator||=
name|XFS_XFLAG_IMMUTABLE
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_IMMUTABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_APPEND
condition|)
name|xflags
operator||=
name|XFS_XFLAG_APPEND
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_APPEND
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_SYNC
condition|)
name|xflags
operator||=
name|XFS_XFLAG_SYNC
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_SYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_NOATIME
condition|)
name|xflags
operator||=
name|XFS_XFLAG_NOATIME
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_NOATIME
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINUX_XFLAG_NODUMP
condition|)
name|xflags
operator||=
name|XFS_XFLAG_NODUMP
expr_stmt|;
else|else
name|xflags
operator|&=
operator|~
name|XFS_XFLAG_NODUMP
expr_stmt|;
return|return
name|xflags
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_xattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|fsxattr
name|fa
decl_stmt|;
name|vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|attr_flags
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|XFS_IOC_FSGETXATTR
case|:
block|{
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_NEXTENTS
expr_stmt|;
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|fa
operator|.
name|fsx_xflags
operator|=
name|va
operator|.
name|va_xflags
expr_stmt|;
name|fa
operator|.
name|fsx_extsize
operator|=
name|va
operator|.
name|va_extsize
expr_stmt|;
name|fa
operator|.
name|fsx_nextents
operator|=
name|va
operator|.
name|va_nextents
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
expr|struct
name|fsxattr
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|fa
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_FSSETXATTR
case|:
block|{
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|fa
argument_list|,
operator|(
expr|struct
name|fsxattr
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
name|attr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filp
operator|->
name|f_flags
operator|&
operator|(
name|O_NDELAY
operator||
name|O_NONBLOCK
operator|)
condition|)
name|attr_flags
operator||=
name|ATTR_NONBLOCK
expr_stmt|;
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
expr_stmt|;
name|va
operator|.
name|va_xflags
operator|=
name|fa
operator|.
name|fsx_xflags
expr_stmt|;
name|va
operator|.
name|va_extsize
operator|=
name|fa
operator|.
name|fsx_extsize
expr_stmt|;
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|attr_flags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|vn_revalidate
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* update Linux inode flags */
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_FSGETXATTRA
case|:
block|{
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_XFLAGS
operator||
name|XFS_AT_EXTSIZE
operator||
name|XFS_AT_ANEXTENTS
expr_stmt|;
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|fa
operator|.
name|fsx_xflags
operator|=
name|va
operator|.
name|va_xflags
expr_stmt|;
name|fa
operator|.
name|fsx_extsize
operator|=
name|va
operator|.
name|va_extsize
expr_stmt|;
name|fa
operator|.
name|fsx_nextents
operator|=
name|va
operator|.
name|va_anextents
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
expr|struct
name|fsxattr
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|fa
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_GETXFLAGS
case|:
block|{
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_XFLAG_IMMUTABLE
condition|)
name|flags
operator||=
name|LINUX_XFLAG_IMMUTABLE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_XFLAG_APPEND
condition|)
name|flags
operator||=
name|LINUX_XFLAG_APPEND
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_XFLAG_SYNC
condition|)
name|flags
operator||=
name|LINUX_XFLAG_SYNC
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_XFLAG_NOATIME
condition|)
name|flags
operator||=
name|LINUX_XFLAG_NOATIME
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_XFLAG_NODUMP
condition|)
name|flags
operator||=
name|LINUX_XFLAG_NODUMP
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|XFS_IOC_SETXFLAGS
case|:
block|{
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|flags
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|LINUX_XFLAG_IMMUTABLE
operator||
name|LINUX_XFLAG_APPEND
operator||
expr|\
name|LINUX_XFLAG_NOATIME
operator||
name|LINUX_XFLAG_NODUMP
operator||
expr|\
name|LINUX_XFLAG_SYNC
operator|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EOPNOTSUPP
argument_list|)
return|;
name|attr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filp
operator|->
name|f_flags
operator|&
operator|(
name|O_NDELAY
operator||
name|O_NONBLOCK
operator|)
condition|)
name|attr_flags
operator||=
name|ATTR_NONBLOCK
expr_stmt|;
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_XFLAGS
expr_stmt|;
name|va
operator|.
name|va_xflags
operator|=
name|xfs_merge_ioc_xflags
argument_list|(
name|flags
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_flags
argument_list|)
expr_stmt|;
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|attr_flags
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|vn_revalidate
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* update Linux inode flags */
return|return
operator|-
name|error
return|;
block|}
case|case
name|XFS_IOC_GETVERSION
case|:
block|{
name|flags
operator|=
name|LINVFS_GET_IP
argument_list|(
name|vp
argument_list|)
operator|->
name|i_generation
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
default|default:
return|return
operator|-
name|ENOTTY
return|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_getbmap
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|getbmap
name|bm
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bm
argument_list|,
operator|(
expr|struct
name|getbmap
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bm
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|bm
operator|.
name|bmv_count
operator|<
literal|2
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|iflags
operator|=
operator|(
name|cmd
operator|==
name|XFS_IOC_GETBMAPA
condition|?
name|BMV_IF_ATTRFORK
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ioflags
operator|&
name|IO_INVIS
condition|)
name|iflags
operator||=
name|BMV_IF_NO_DMAPI_READ
expr_stmt|;
name|error
operator|=
name|xfs_getbmap
argument_list|(
name|bdp
argument_list|,
operator|&
name|bm
argument_list|,
operator|(
expr|struct
name|getbmap
operator|*
operator|)
name|arg
operator|+
literal|1
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
expr|struct
name|getbmap
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|bm
argument_list|,
sizeof|sizeof
argument_list|(
name|bm
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_ioc_getbmapx
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|getbmapx
name|bmx
decl_stmt|;
name|struct
name|getbmap
name|bm
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|bmx
argument_list|,
operator|(
expr|struct
name|getbmapx
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|bmx
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
if|if
condition|(
name|bmx
operator|.
name|bmv_count
operator|<
literal|2
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 	 * Map input getbmapx structure to a getbmap 	 * structure for xfs_getbmap. 	 */
name|GETBMAP_CONVERT
argument_list|(
name|bmx
argument_list|,
name|bm
argument_list|)
expr_stmt|;
name|iflags
operator|=
name|bmx
operator|.
name|bmv_iflags
expr_stmt|;
if|if
condition|(
name|iflags
operator|&
operator|(
operator|~
name|BMV_IF_VALID
operator|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|iflags
operator||=
name|BMV_IF_EXTENDED
expr_stmt|;
name|error
operator|=
name|xfs_getbmap
argument_list|(
name|bdp
argument_list|,
operator|&
name|bm
argument_list|,
operator|(
expr|struct
name|getbmapx
operator|*
operator|)
name|arg
operator|+
literal|1
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
name|error
return|;
name|GETBMAP_CONVERT
argument_list|(
name|bm
argument_list|,
name|bmx
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
expr|struct
name|getbmapx
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|bmx
argument_list|,
sizeof|sizeof
argument_list|(
name|bmx
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|xfs_ioctl
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|ioflags
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

end_unit

