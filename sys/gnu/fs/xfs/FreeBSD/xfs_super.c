begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_clnt.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_cap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_version.h"
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|vop_vector
name|xfs_fifoops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buf_ops
name|xfs_ops
decl_stmt|;
end_decl_stmt

begin_function
name|__uint64_t
name|xfs_max_file_offset
parameter_list|(
name|unsigned
name|int
name|blockshift
parameter_list|)
block|{
return|return
operator|(
name|OFF_MAX
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xfs_initialize_vnode
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|,
name|bhv_desc_t
modifier|*
name|inode_bhv
parameter_list|,
name|int
name|unlock
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
init|=
name|XFS_BHVTOI
argument_list|(
name|inode_bhv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inode_bhv
operator|->
name|bd_vobj
condition|)
block|{
name|vp
operator|->
name|v_vfsp
operator|=
name|bhvtovfs
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|bhv_desc_init
argument_list|(
name|inode_bhv
argument_list|,
name|ip
argument_list|,
name|vp
argument_list|,
operator|&
name|xfs_vnodeops
argument_list|)
expr_stmt|;
name|bhv_insert
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|,
name|inode_bhv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX: Use VNON as an indication of freshly allocated vnode 	 * which need to be initialized and unlocked. 	 * This is _not_ like the same place in Linux version of 	 * routine. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VNON
condition|)
return|return;
name|vp
operator|->
name|v_type
operator|=
name|IFTOVT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vnode
operator|->
name|v_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VFIFO
condition|)
name|vp
operator|->
name|v_vnode
operator|->
name|v_op
operator|=
operator|&
name|xfs_fifoops
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
operator|->
name|v_vnode
argument_list|,
literal|"xfs_initialize_vnode"
argument_list|)
expr_stmt|;
comment|/* For new inodes we need to set the ops vectors, 	 * and unlock the inode. 	 */
if|if
condition|(
name|unlock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
operator|->
name|v_vnode
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|vnode
modifier|*
name|xfs_get_inode
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|xfs_flush_inode
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|printf
argument_list|(
literal|"xfs_flush_inode NI\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_flush_device
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|printf
argument_list|(
literal|"xfs_flush_device NI\n"
argument_list|)
expr_stmt|;
name|xfs_log_force
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|xfs_blkdev_get
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|bdevp
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|nameidata
modifier|*
name|ndp
init|=
operator|&
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ronly
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|mode_t
name|accessmode
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|name
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ronly
operator|=
operator|(
operator|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|accessmode
operator|=
name|VREAD
expr_stmt|;
if|if
condition|(
operator|!
name|ronly
condition|)
name|accessmode
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|devvp
argument_list|,
name|accessmode
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
comment|/* 	 * XXX: Do not allow more than one consumer to open a device 	 *      associated with a particular GEOM provider. 	 *      This disables multiple read-only mounts of a device, 	 *      but it gets rid of panics in bmemfree() when you try to 	 *      mount the same device more than once. 	 *      During mounting, XFS does a bread() of the superblock, but does 	 *      not brelse() it.  A subsequent mount of the same device 	 *      will try to bread() the superblock, resulting in a panic in  	 *      bremfree(), "buffer not on queue". 	 */
name|pp
operator|=
name|g_dev_getprovider
argument_list|(
name|devvp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|pp
operator|->
name|acr
operator||
name|pp
operator|->
name|acw
operator||
name|pp
operator|->
name|ace
operator|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
else|else
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"xfs"
argument_list|,
name|ronly
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|devvp
operator|->
name|v_bufobj
operator|.
name|bo_private
operator|=
name|cp
expr_stmt|;
name|devvp
operator|->
name|v_bufobj
operator|.
name|bo_ops
operator|=
operator|&
name|xfs_ops
expr_stmt|;
operator|*
name|bdevp
operator|=
name|devvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xfs_blkdev_put
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|devvp
operator|==
name|NULL
condition|)
return|return;
name|vinvalbuf
argument_list|(
name|devvp
argument_list|,
name|V_SAVE
argument_list|,
name|curthread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|devvp
operator|->
name|v_bufobj
operator|.
name|bo_private
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_wither_geom_close
argument_list|(
name|cp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_flush_buftarg
parameter_list|(
name|xfs_buftarg_t
modifier|*
name|btp
parameter_list|)
block|{
name|printf
argument_list|(
literal|"xfs_flush_buftarg NI %p\n"
argument_list|,
name|btp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_free_buftarg
parameter_list|(
name|xfs_buftarg_t
modifier|*
name|btp
parameter_list|)
block|{
name|xfs_flush_buftarg
argument_list|(
name|btp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|btp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|btp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xfs_readonly_buftarg
parameter_list|(
name|xfs_buftarg_t
modifier|*
name|btp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|KASSERT
argument_list|(
name|btp
operator|->
name|specvp
operator|->
name|v_bufobj
operator|.
name|bo_ops
operator|==
operator|&
name|xfs_ops
argument_list|,
operator|(
literal|"Bogus xfs_buftarg_t pointer"
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|btp
operator|->
name|specvp
operator|->
name|v_bufobj
operator|.
name|bo_private
expr_stmt|;
return|return
operator|(
name|cp
operator|->
name|acw
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xfs_relse_buftarg
parameter_list|(
name|xfs_buftarg_t
modifier|*
name|btp
parameter_list|)
block|{
name|printf
argument_list|(
literal|"xfs_readonly_buftarg NI %p\n"
argument_list|,
name|btp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|xfs_getsize_buftarg
parameter_list|(
name|xfs_buftarg_t
modifier|*
name|btp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|btp
operator|->
name|specvp
operator|->
name|v_bufobj
operator|.
name|bo_private
expr_stmt|;
return|return
operator|(
name|cp
operator|->
name|provider
operator|->
name|sectorsize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xfs_setsize_buftarg
parameter_list|(
name|xfs_buftarg_t
modifier|*
name|btp
parameter_list|,
name|unsigned
name|int
name|blocksize
parameter_list|,
name|unsigned
name|int
name|sectorsize
parameter_list|)
block|{
name|printf
argument_list|(
literal|"xfs_setsize_buftarg NI %p\n"
argument_list|,
name|btp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|xfs_buftarg_t
modifier|*
name|xfs_alloc_buftarg
parameter_list|(
name|struct
name|vnode
modifier|*
name|bdev
parameter_list|)
block|{
name|xfs_buftarg_t
modifier|*
name|btp
decl_stmt|;
name|btp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|btp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|btp
operator|->
name|dev
operator|=
name|bdev
operator|->
name|v_rdev
expr_stmt|;
name|btp
operator|->
name|specvp
operator|=
name|bdev
expr_stmt|;
return|return
name|btp
return|;
block|}
end_function

begin_function
name|int
name|init_xfs_fs
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|message
index|[]
init|=
name|XFS_VERSION_STRING
literal|" with "
name|XFS_BUILD_OPTIONS
literal|" enabled\n"
decl_stmt|;
name|printf
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|vn_init
argument_list|()
expr_stmt|;
name|xfs_init
argument_list|()
expr_stmt|;
name|uuid_init
argument_list|()
expr_stmt|;
name|vfs_initdmapi
argument_list|()
expr_stmt|;
name|vfs_initquota
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|exit_xfs_fs
parameter_list|(
name|void
parameter_list|)
block|{
name|xfs_cleanup
argument_list|()
expr_stmt|;
name|vfs_exitquota
argument_list|()
expr_stmt|;
name|vfs_exitdmapi
argument_list|()
expr_stmt|;
name|uuid_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

