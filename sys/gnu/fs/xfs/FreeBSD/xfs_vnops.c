begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001, Alexander Kabaev  * Copyright (c) 2006, Russell Cattelan Digital Elves Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/extattr.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<fs/fifofs/fifo.h>
end_include

begin_define
define|#
directive|define
name|NO_VFS_MACROS
end_define

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_imap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_cap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_iomap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_clnt.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mountops.h"
end_include

begin_comment
comment|/*  * Prototypes for XFS vnode operations.  */
end_comment

begin_decl_stmt
specifier|static
name|vop_access_t
name|_xfs_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_advlock_t
name|_xfs_advlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_bmap_t
name|_xfs_bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_cachedlookup_t
name|_xfs_cachedlookup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_close_t
name|_xfs_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_create_t
name|_xfs_create
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_deleteextattr_t
name|_xfs_deleteextattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_fsync_t
name|_xfs_fsync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getattr_t
name|_xfs_getattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getextattr_t
name|_xfs_getextattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_inactive_t
name|_xfs_inactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_ioctl_t
name|_xfs_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_link_t
name|_xfs_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_listextattr_t
name|_xfs_listextattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mkdir_t
name|_xfs_mkdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mknod_t
name|_xfs_mknod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_open_t
name|_xfs_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_read_t
name|_xfs_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readdir_t
name|_xfs_readdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readlink_t
name|_xfs_readlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_reclaim_t
name|_xfs_reclaim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_remove_t
name|_xfs_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rename_t
name|_xfs_rename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rmdir_t
name|_xfs_rmdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_setattr_t
name|_xfs_setattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_setextattr_t
name|_xfs_setextattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_strategy_t
name|_xfs_strategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_symlink_t
name|_xfs_symlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_write_t
name|_xfs_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_vptofh_t
name|_xfs_vptofh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|xfs_vnops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|_xfs_access
block|,
operator|.
name|vop_advlock
operator|=
name|_xfs_advlock
block|,
operator|.
name|vop_bmap
operator|=
name|_xfs_bmap
block|,
operator|.
name|vop_cachedlookup
operator|=
name|_xfs_cachedlookup
block|,
operator|.
name|vop_close
operator|=
name|_xfs_close
block|,
operator|.
name|vop_create
operator|=
name|_xfs_create
block|,
operator|.
name|vop_deleteextattr
operator|=
name|_xfs_deleteextattr
block|,
operator|.
name|vop_fsync
operator|=
name|_xfs_fsync
block|,
operator|.
name|vop_getattr
operator|=
name|_xfs_getattr
block|,
operator|.
name|vop_getextattr
operator|=
name|_xfs_getextattr
block|,
operator|.
name|vop_inactive
operator|=
name|_xfs_inactive
block|,
operator|.
name|vop_ioctl
operator|=
name|_xfs_ioctl
block|,
operator|.
name|vop_link
operator|=
name|_xfs_link
block|,
operator|.
name|vop_listextattr
operator|=
name|_xfs_listextattr
block|,
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_mkdir
operator|=
name|_xfs_mkdir
block|,
operator|.
name|vop_mknod
operator|=
name|_xfs_mknod
block|,
operator|.
name|vop_open
operator|=
name|_xfs_open
block|,
operator|.
name|vop_read
operator|=
name|_xfs_read
block|,
operator|.
name|vop_readdir
operator|=
name|_xfs_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|_xfs_readlink
block|,
operator|.
name|vop_reclaim
operator|=
name|_xfs_reclaim
block|,
operator|.
name|vop_remove
operator|=
name|_xfs_remove
block|,
operator|.
name|vop_rename
operator|=
name|_xfs_rename
block|,
operator|.
name|vop_rmdir
operator|=
name|_xfs_rmdir
block|,
operator|.
name|vop_setattr
operator|=
name|_xfs_setattr
block|,
operator|.
name|vop_setextattr
operator|=
name|_xfs_setextattr
block|,
operator|.
name|vop_strategy
operator|=
name|_xfs_strategy
block|,
operator|.
name|vop_symlink
operator|=
name|_xfs_symlink
block|,
operator|.
name|vop_write
operator|=
name|_xfs_write
block|,
operator|.
name|vop_vptofh
operator|=
name|_xfs_vptofh
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  FIFO's specific operations.  */
end_comment

begin_decl_stmt
specifier|static
name|vop_close_t
name|_xfsfifo_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_read_t
name|_xfsfifo_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_kqfilter_t
name|_xfsfifo_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_write_t
name|_xfsfifo_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|xfs_fifoops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|fifo_specops
block|,
operator|.
name|vop_access
operator|=
name|_xfs_access
block|,
operator|.
name|vop_close
operator|=
name|_xfsfifo_close
block|,
operator|.
name|vop_fsync
operator|=
name|_xfs_fsync
block|,
operator|.
name|vop_getattr
operator|=
name|_xfs_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|_xfs_inactive
block|,
operator|.
name|vop_kqfilter
operator|=
name|_xfsfifo_kqfilter
block|,
operator|.
name|vop_read
operator|=
name|_xfsfifo_read
block|,
operator|.
name|vop_reclaim
operator|=
name|_xfs_reclaim
block|,
operator|.
name|vop_setattr
operator|=
name|_xfs_setattr
block|,
operator|.
name|vop_write
operator|=
name|_xfsfifo_write
block|,
operator|.
name|vop_vptofh
operator|=
name|_xfs_vptofh
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|_xfs_access
parameter_list|(
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|XVOP_ACCESS
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_open
parameter_list|(
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 		int  a_fdidx; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|XVOP_OPEN
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vnode_create_vobject
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_close
parameter_list|(
name|struct
name|vop_close_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* XVOP_CLOSE(VPTOXFSVP(ap->a_vp), NULL, error); */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* extract the xfs vnode from the private data */
comment|//xfs_vnode_t	*xvp = (xfs_vnode_t *)vp->v_data;
name|VATTR_NULL
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|va
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_vattr_t
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_mask
operator|=
name|XFS_AT_STAT
operator||
name|XFS_AT_GENCOUNT
operator||
name|XFS_AT_XFLAGS
expr_stmt|;
name|XVOP_GETATTR
argument_list|(
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|IFTOVT
argument_list|(
operator|(
operator|(
name|xfs_vnode_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|v_inode
operator|->
name|i_d
operator|.
name|di_mode
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|va
operator|.
name|va_mode
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|va
operator|.
name|va_nlink
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|va
operator|.
name|va_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|va
operator|.
name|va_gid
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
name|va
operator|.
name|va_nodeid
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|va
operator|.
name|va_size
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|va
operator|.
name|va_blocksize
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|va
operator|.
name|va_atime
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|va
operator|.
name|va_mtime
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|va
operator|.
name|va_ctime
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
name|va
operator|.
name|va_gen
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|va
operator|.
name|va_rdev
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
operator|(
name|va
operator|.
name|va_nblocks
operator|<<
name|BBSHIFT
operator|)
expr_stmt|;
comment|/* XFS now supports devices that have block sizes 	 * other than 512 so BBSHIFT will work for now 	 * but need to get this value from the super block 	 */
comment|/* 	 * Fields with no direct equivalent in XFS 	 * leave initialized by VATTR_NULL 	 */
if|#
directive|if
literal|0
block|vap->va_filerev = 0; 	vap->va_birthtime = va.va_ctime; 	vap->va_vaflags = 0; 	vap->va_flags = 0; 	vap->va_spare = 0;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Check for unsettable attributes. 	 */
ifdef|#
directive|ifdef
name|RMC
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|va
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_UID
expr_stmt|;
name|va
operator|.
name|va_uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_GID
expr_stmt|;
name|va
operator|.
name|va_gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_SIZE
expr_stmt|;
name|va
operator|.
name|va_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_ATIME
expr_stmt|;
name|va
operator|.
name|va_atime
operator|=
name|vap
operator|->
name|va_atime
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_MTIME
expr_stmt|;
name|va
operator|.
name|va_mtime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_ctime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_CTIME
expr_stmt|;
name|va
operator|.
name|va_ctime
operator|=
name|vap
operator|->
name|va_ctime
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_MODE
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|vap
operator|->
name|va_mode
expr_stmt|;
block|}
name|XVOP_SETATTR
argument_list|(
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_inactive
parameter_list|(
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|int
name|error
decl_stmt|;
name|XVOP_INACTIVE
argument_list|(
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_read
parameter_list|(
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
break|break;
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
default|default:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
empty_stmt|;
name|XVOP_READ
argument_list|(
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|xfs_read_file
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|xfs_fileoff_t
name|lbn
decl_stmt|,
name|nextlbn
decl_stmt|;
name|xfs_fsize_t
name|bytesinfile
decl_stmt|;
name|long
name|size
decl_stmt|,
name|xfersize
decl_stmt|,
name|blkoffset
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|orig_resid
decl_stmt|;
name|int
name|seqcount
decl_stmt|;
name|seqcount
operator|=
name|ioflag
operator|>>
name|IO_SEQSHIFT
expr_stmt|;
name|orig_resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|orig_resid
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_vnode
expr_stmt|;
comment|/* 	 * Ok so we couldn't do it all in one vm trick... 	 * so cycle around trying smaller bites.. 	 */
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|bp
operator|=
name|NULL
init|;
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|;
name|bp
operator|=
name|NULL
control|)
block|{
if|if
condition|(
operator|(
name|bytesinfile
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|-
name|uio
operator|->
name|uio_offset
operator|)
operator|<=
literal|0
condition|)
break|break;
name|lbn
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|nextlbn
operator|=
name|lbn
operator|+
literal|1
expr_stmt|;
comment|/* 		 * size of buffer.  The buffer representing the 		 * end of the file is rounded up to the size of 		 * the block type ( fragment or full block, 		 * depending ). 		 */
name|size
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|blkoffset
operator|=
name|XFS_B_FSB_OFFSET
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
comment|/* 		 * The amount we want to transfer in this iteration is 		 * one FS block less the amount of the data before 		 * our startpoint (duh!) 		 */
name|xfersize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|-
name|blkoffset
expr_stmt|;
comment|/* 		 * But if we actually want less than the block, 		 * or the file doesn't have a whole block more of data, 		 * then use the lesser number. 		 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|xfersize
condition|)
name|xfersize
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|bytesinfile
operator|<
name|xfersize
condition|)
name|xfersize
operator|=
name|bytesinfile
expr_stmt|;
if|if
condition|(
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|nextlbn
argument_list|)
operator|>=
name|ip
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
comment|/* 			 * Don't do readahead if this is the end of the file. 			 */
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOCLUSTERR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Otherwise if we are allowed to cluster, 			 * grab as much as we can. 			 * 			 * XXX  This may not be a win if we are not 			 * doing sequential access. 			 */
name|error
operator|=
name|cluster_read
argument_list|(
name|vp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
name|NOCRED
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|seqcount
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seqcount
operator|>
literal|1
condition|)
block|{
comment|/* 			 * If we are NOT allowed to cluster, then 			 * if we appear to be acting sequentially, 			 * fire off a request for a readahead 			 * as well as a read. Note that the 4th and 5th 			 * arguments point to arrays of the size specified in 			 * the 6th argument. 			 */
name|int
name|nextsize
init|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
decl_stmt|;
name|error
operator|=
name|breadn
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
operator|&
name|nextlbn
argument_list|,
operator|&
name|nextsize
argument_list|,
literal|1
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Failing all of the above, just read what the 			 * user asked for. Interestingly, the same as 			 * the first option above. 			 */
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * If IO_DIRECT then set B_DIRECT for the buffer.  This 		 * will cause us to attempt to release the buffer later on 		 * and will cause the buffer cache to attempt to free the 		 * underlying pages. 		 */
if|if
condition|(
name|ioflag
operator|&
name|IO_DIRECT
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_DIRECT
expr_stmt|;
comment|/* 		 * We should only get non-zero b_resid when an I/O error 		 * has occurred, which should cause us to break above. 		 * However, if the short read did not cause an error, 		 * then we want to ensure that we do not uiomove bad 		 * or uninitialized data. 		 */
name|size
operator|-=
name|bp
operator|->
name|b_resid
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|xfersize
condition|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
break|break;
name|xfersize
operator|=
name|size
expr_stmt|;
block|}
comment|/* 		 * otherwise use the general form 		 */
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|blkoffset
argument_list|,
operator|(
name|int
operator|)
name|xfersize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ioflag
operator|&
operator|(
name|IO_VMIO
operator||
name|IO_DIRECT
operator|)
condition|)
block|{
comment|/* 			 * If there are no dependencies, and it's VMIO, 			 * then we don't need the buf, mark it available 			 * for freeing. The VM has the data. 			 */
name|bp
operator|->
name|b_flags
operator||=
name|B_RELBUF
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Otherwise let whoever 			 * made the request take care of 			 * freeing it. We just queue 			 * it onto another list. 			 */
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * This can only happen in the case of an error 	 * because the loop above resets bp to NULL on each iteration 	 * and on normal completion has not set a new value into it. 	 * so it must have come from a 'break' statement 	 */
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
operator|(
name|IO_VMIO
operator||
name|IO_DIRECT
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_RELBUF
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_write
parameter_list|(
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|ioflag
init|=
name|ap
operator|->
name|a_ioflag
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
init|=
operator|(
name|xfs_vnode_t
operator|*
operator|)
name|vp
operator|->
name|v_data
decl_stmt|;
name|error
operator|=
name|xfs_write
argument_list|(
name|xvp
operator|->
name|v_bh
operator|.
name|bh_first
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Xfs_write got error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xfs_write_file
parameter_list|(
name|xfs_inode_t
modifier|*
name|xip
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|//struct thread	*td;
name|daddr_t
name|lbn
decl_stmt|;
name|off_t
name|osize
init|=
literal|0
decl_stmt|;
name|off_t
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|blkoffset
decl_stmt|,
name|error
decl_stmt|,
name|resid
decl_stmt|,
name|xfersize
decl_stmt|;
name|int
name|fsblocksize
decl_stmt|;
name|int
name|seqcount
decl_stmt|;
name|xfs_iomap_t
name|iomap
decl_stmt|;
name|int
name|maps
init|=
literal|1
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
init|=
name|XFS_ITOV
argument_list|(
name|xip
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|xvp
operator|->
name|v_vnode
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
init|=
operator|(
operator|&
name|xip
operator|->
name|i_iocore
operator|)
operator|->
name|io_mount
decl_stmt|;
name|seqcount
operator|=
name|ioflag
operator|>>
name|IO_SEQSHIFT
expr_stmt|;
name|memset
argument_list|(
operator|&
name|iomap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_iomap_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Maybe this should be above the vnode op call, but so long as 	 * file servers have no limits, I don't think it matters. 	 */
if|#
directive|if
literal|0
block|td = uio->uio_td; 	if (vp->v_type == VREG&& td != NULL) { 		PROC_LOCK(td->td_proc); 		if (uio->uio_offset + uio->uio_resid> 		    lim_cur(td->td_proc, RLIMIT_FSIZE)) { 			psignal(td->td_proc, SIGXFSZ); 			PROC_UNLOCK(td->td_proc); 			return (EFBIG); 		} 		PROC_UNLOCK(td->td_proc); 	}
endif|#
directive|endif
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|osize
operator|=
name|xip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
comment|/* xfs bmap wants bytes for both offset and size */
name|XVOP_BMAP
argument_list|(
name|xvp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|BMAPI_WRITE
operator||
name|BMAPI_DIRECT
argument_list|,
operator|&
name|iomap
argument_list|,
operator|&
name|maps
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"XVOP_BMAP failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|error
operator|=
literal|0
init|;
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|;
control|)
block|{
name|lbn
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|blkoffset
operator|=
name|XFS_B_FSB_OFFSET
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|xfersize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|-
name|blkoffset
expr_stmt|;
name|fsblocksize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|xfersize
condition|)
name|xfersize
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* 		 * getblk sets buf by  blkno *  bo->bo_bsize 		 * bo_bsize is set from the mnt point fsize 		 * so we call getblk in the case using fsblocks 		 * not basic blocks 		 */
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|fsblocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|printf
argument_list|(
literal|"getblk failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|&&
name|fsblocksize
operator|>
name|xfersize
condition|)
name|vfs_bio_clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|xfersize
operator|>
name|xip
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|xip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|offset
operator|+
name|xfersize
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|offset
operator|+
name|fsblocksize
argument_list|)
expr_stmt|;
block|}
comment|/* move the offset for the next itteration of the loop */
name|offset
operator|+=
name|xfersize
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|blkoffset
argument_list|,
name|xfersize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ioflag
operator|&
name|IO_VMIO
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|==
name|NULL
operator|)
condition|)
comment|/* in ext2fs? */
name|bp
operator|->
name|b_flags
operator||=
name|B_RELBUF
expr_stmt|;
comment|/* force to full direct for now */
name|bp
operator|->
name|b_flags
operator||=
name|B_DIRECT
expr_stmt|;
comment|/* and sync ... the delay path is not pushing data out */
name|ioflag
operator||=
name|IO_SYNC
expr_stmt|;
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
block|{
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
comment|/* RMC xfersize + blkoffset == fs->s_frag_size */
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOCLUSTERW
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_CLUSTEROK
expr_stmt|;
name|cluster_write
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|,
name|osize
argument_list|,
name|seqcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_CLUSTEROK
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
name|xfersize
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If we successfully wrote any data, and we are not the superuser 	 * we clear the setuid and setgid bits as a precaution against 	 * tampering. 	 */
if|#
directive|if
literal|0
block|if (resid> uio->uio_resid&& ap->a_cred&& ap->a_cred->cr_uid != 0) 		ip->i_mode&= ~(ISUID | ISGID);
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_UNIT
condition|)
block|{
if|#
directive|if
literal|0
block|(void)ext2_truncate(vp, osize, 			    ioflag& IO_SYNC, ap->a_cred, uio->uio_td);
endif|#
directive|endif
name|uio
operator|->
name|uio_offset
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|resid
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|resid
operator|>
name|uio
operator|->
name|uio_resid
operator|&&
operator|(
name|ioflag
operator|&
name|IO_SYNC
operator|)
condition|)
block|{
comment|/* Update the vnode here? */
block|}
name|error
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_create
parameter_list|(
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credp
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|va
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_MODE
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|vap
operator|->
name|va_mode
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_TYPE
expr_stmt|;
name|va
operator|.
name|va_mode
operator||=
name|VTTOIF
argument_list|(
name|vap
operator|->
name|va_type
argument_list|)
expr_stmt|;
name|xvp
operator|=
name|NULL
expr_stmt|;
name|XVOP_CREATE
argument_list|(
name|VPTOXFSVP
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|cnp
argument_list|,
operator|&
name|va
argument_list|,
operator|&
name|xvp
argument_list|,
name|credp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|xvp
operator|->
name|v_vnode
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|xvp
operator|->
name|v_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|xfs_remove
parameter_list|(
name|bhv_desc_t
modifier|*
parameter_list|,
name|bhv_desc_t
modifier|*
parameter_list|,
name|vname_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|_xfs_remove
parameter_list|(
name|struct
name|vop_remove_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode * a_dvp; 		struct vnode * a_vp; 		struct componentname * a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credp
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
comment|/* 	struct vnode *dvp = ap->a_dvp;   	struct componentname *cnp = ap->a_cnp; 	*/
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|||
name|vp
operator|->
name|v_usecount
operator|!=
literal|1
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|xfs_remove
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
operator|->
name|v_bh
operator|.
name|bh_first
argument_list|,
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|v_bh
operator|.
name|bh_first
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|credp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_rename
parameter_list|(
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
comment|/* 	struct componentname *tcnp = ap->a_tcnp; */
comment|/*	struct componentname *fcnp = ap->a_fcnp;*/
name|int
name|error
init|=
name|EPERM
decl_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Check for cross-device rename */
if|if
condition|(
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tvp
operator|&&
name|tvp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|tvp
operator|!=
name|NULL
operator|&&
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vgone
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_link
parameter_list|(
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|tdvp
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tdvp
operator|=
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|XVOP_LINK
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_symlink
parameter_list|(
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credp
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|va
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_MODE
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
operator||
name|S_IFLNK
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_TYPE
expr_stmt|;
name|XVOP_SYMLINK
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_target
argument_list|,
operator|&
name|xvp
argument_list|,
name|credp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|xvp
operator|->
name|v_vnode
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|xvp
operator|->
name|v_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_mknod
parameter_list|(
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credp
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|va
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_MODE
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|vap
operator|->
name|va_mode
operator||
name|S_IFIFO
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_TYPE
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_RDEV
expr_stmt|;
name|va
operator|.
name|va_rdev
operator|=
name|vap
operator|->
name|va_rdev
expr_stmt|;
name|xvp
operator|=
name|NULL
expr_stmt|;
name|XVOP_CREATE
argument_list|(
name|VPTOXFSVP
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|cnp
argument_list|,
operator|&
name|va
argument_list|,
operator|&
name|xvp
argument_list|,
name|credp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|xvp
operator|->
name|v_vnode
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|xvp
operator|->
name|v_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
comment|/* { 		 struct vnode *a_dvp; 		 struct vnode **a_vpp; 		 struct componentname *a_cnp; 		 struct vattr *a_vap; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credp
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
decl_stmt|;
name|xfs_vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|va
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_MODE
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|vap
operator|->
name|va_mode
operator||
name|S_IFDIR
expr_stmt|;
name|va
operator|.
name|va_mask
operator||=
name|XFS_AT_TYPE
expr_stmt|;
name|xvp
operator|=
name|NULL
expr_stmt|;
name|XVOP_MKDIR
argument_list|(
name|VPTOXFSVP
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|cnp
argument_list|,
operator|&
name|va
argument_list|,
operator|&
name|xvp
argument_list|,
name|credp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|xvp
operator|->
name|v_vnode
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|xvp
operator|->
name|v_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
comment|/* 	struct componentname *cnp = ap->a_cnp; */
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dvp
operator|==
name|vp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|eof
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|off
operator|=
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|XVOP_READDIR
argument_list|(
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|uio
argument_list|,
name|NULL
argument_list|,
operator|&
name|eof
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_offset
operator|==
name|off
operator|)
operator|||
name|error
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ap
operator|->
name|a_eofflag
condition|)
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
operator|(
name|eof
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|int
name|error
decl_stmt|;
name|XVOP_READLINK
argument_list|(
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_fsync
parameter_list|(
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode * a_vp; 		int  a_waitfor; 		struct thread * a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|FSYNC_DATA
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_waitfor
operator|==
name|MNT_WAIT
condition|)
name|flags
operator||=
name|FSYNC_WAIT
expr_stmt|;
name|XVOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
operator|(
name|xfs_off_t
operator|)
literal|0
argument_list|,
operator|(
name|xfs_off_t
operator|)
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_bmap
parameter_list|(
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct bufobj **a_bop; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|xfs_iomap_t
name|iomap
decl_stmt|;
name|xfs_off_t
name|offset
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|xfs_mount
modifier|*
name|xmp
decl_stmt|;
name|struct
name|xfs_vnode
modifier|*
name|xvp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|maxrun
decl_stmt|,
name|retbm
decl_stmt|;
name|mp
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
expr_stmt|;
name|xmp
operator|=
name|XFS_VFSTOM
argument_list|(
name|MNTTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bop
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_bop
operator|=
operator|&
name|xmp
operator|->
name|m_ddev_targp
operator|->
name|specvp
operator|->
name|v_bufobj
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bnp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|xvp
operator|=
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|retbm
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|xmp
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|)
expr_stmt|;
name|size
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|xmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XVOP_BMAP
argument_list|(
name|xvp
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|BMAPI_READ
argument_list|,
operator|&
name|iomap
argument_list|,
operator|&
name|retbm
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|retbm
operator|==
literal|0
operator|||
name|iomap
operator|.
name|iomap_bn
operator|==
name|IOMAP_DADDR_NULL
condition|)
block|{
operator|*
name|ap
operator|->
name|a_bnp
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runb
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runp
condition|)
operator|*
name|ap
operator|->
name|a_runp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ap
operator|->
name|a_bnp
operator|=
name|iomap
operator|.
name|iomap_bn
operator|+
name|btodb
argument_list|(
name|iomap
operator|.
name|iomap_delta
argument_list|)
expr_stmt|;
name|maxrun
operator|=
name|mp
operator|->
name|mnt_iosize_max
operator|/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runb
condition|)
block|{
operator|*
name|ap
operator|->
name|a_runb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|xmp
argument_list|,
name|iomap
operator|.
name|iomap_delta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|->
name|a_runb
operator|>
name|maxrun
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
name|maxrun
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_runp
condition|)
block|{
operator|*
name|ap
operator|->
name|a_runp
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|xmp
argument_list|,
name|iomap
operator|.
name|iomap_bsize
operator|-
name|iomap
operator|.
name|iomap_delta
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|->
name|a_runp
operator|>
name|maxrun
condition|)
operator|*
name|ap
operator|->
name|a_runp
operator|=
name|maxrun
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_strategy
parameter_list|(
name|struct
name|vop_strategy_args
comment|/* { 		struct vnode *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|daddr_t
name|blkno
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
empty_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|xfs_mount
modifier|*
name|xmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
name|ap
operator|->
name|a_bp
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|->
name|a_vp
operator|==
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
argument_list|,
operator|(
literal|"%s(%p != %p)"
operator|,
name|__func__
operator|,
name|ap
operator|->
name|a_vp
operator|,
name|ap
operator|->
name|a_bp
operator|->
name|b_vp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|error
operator|=
name|VOP_BMAP
argument_list|(
name|vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|NULL
argument_list|,
operator|&
name|blkno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blkno
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
operator|(
name|blkno
operator|<<
name|BBSHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
name|vfs_bio_clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xmp
operator|=
name|XFS_VFSTOM
argument_list|(
name|MNTTOVFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
argument_list|)
expr_stmt|;
name|bo
operator|=
operator|&
name|xmp
operator|->
name|m_ddev_targp
operator|->
name|specvp
operator|->
name|v_bufobj
expr_stmt|;
name|bo
operator|->
name|bo_ops
operator|->
name|bop_strategy
argument_list|(
name|bo
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_xfs_ioctl
parameter_list|(
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long a_command; 		caddr_t a_data; 		int fflag; 		struct ucred *cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
comment|/* 	struct vnode *vp = ap->a_vp; */
comment|/* 	struct thread *p = ap->a_td; */
comment|/* 	struct file *fp; */
name|int
name|error
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|xvp
init|=
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"_xfs_ioctl cmd 0x%lx data %p\n"
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|)
expr_stmt|;
comment|//	XVOP_IOCTL(xvp,(void *)NULL,(void *)NULL,ap->a_fflag,ap->a_command,ap->a_data,error);
name|error
operator|=
name|xfs_ioctl
argument_list|(
name|xvp
operator|->
name|v_bh
operator|.
name|bh_first
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|_xfs_advlock
parameter_list|(
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
parameter_list|)
block|{
comment|/* 	struct vnode *vp = ap->a_vp;*/
name|struct
name|flock
modifier|*
name|fl
init|=
name|ap
operator|->
name|a_fl
decl_stmt|;
comment|/* 	caddr_t id = (caddr_t)1 */
comment|/* ap->a_id */
empty_stmt|;
comment|/* 	int flags = ap->a_flags; */
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|size
decl_stmt|;
name|int
name|error
comment|/* , lkop */
decl_stmt|;
comment|/*KAN: temp */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|size
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
case|case
name|SEEK_CUR
case|:
name|start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|start
operator|=
name|fl
operator|->
name|l_start
operator|+
name|size
expr_stmt|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|==
literal|0
condition|)
name|end
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|end
operator|=
name|start
operator|+
name|fl
operator|->
name|l_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|notyet
switch|switch
condition|(
name|ap
operator|->
name|a_op
condition|)
block|{
case|case
name|F_SETLK
case|:
name|error
operator|=
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_UNLCK
case|:
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_GETLK
case|:
name|error
operator|=
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_cachedlookup
parameter_list|(
name|struct
name|vop_cachedlookup_args
comment|/* { 		struct vnode * a_dvp; 		struct vnode ** a_vpp; 		struct componentname * a_cnp; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|struct
name|xfs_vnode
modifier|*
name|cvp
decl_stmt|;
name|int
name|islastcn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|int
name|nameiop
init|=
name|cnp
operator|->
name|cn_nameiop
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|char
modifier|*
name|pname
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|namelen
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|dvp
operator|=
name|ap
operator|->
name|a_dvp
expr_stmt|;
name|islastcn
operator|=
name|flags
operator|&
name|ISLASTCN
expr_stmt|;
name|XVOP_LOOKUP
argument_list|(
name|VPTOXFSVP
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|cnp
argument_list|,
operator|&
name|cvp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|(
name|nameiop
operator|==
name|CREATE
operator|||
name|nameiop
operator|==
name|RENAME
operator|||
name|nameiop
operator|==
name|DELETE
operator|)
operator|&&
name|islastcn
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|nameiop
operator|!=
name|CREATE
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tvp
operator|=
name|cvp
operator|->
name|v_vnode
expr_stmt|;
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|&&
name|islastcn
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
operator|*
name|vpp
operator|=
name|tvp
expr_stmt|;
comment|/* Directory should be writable for deletes. */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_out
goto|;
comment|/* XXXKAN: Permission checks for sticky dirs? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nameiop
operator|==
name|RENAME
operator|&&
name|islastcn
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
operator|*
name|vpp
operator|=
name|tvp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|err_out
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
operator|*
name|vpp
operator|=
name|tvp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|namelen
operator|==
literal|1
operator|&&
name|pname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
operator|*
name|vpp
operator|=
name|tvp
expr_stmt|;
name|KASSERT
argument_list|(
name|tvp
operator|==
name|dvp
argument_list|,
operator|(
literal|"not same directory"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
operator|*
name|vpp
operator|=
name|tvp
expr_stmt|;
block|}
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_out
label|:
if|if
condition|(
operator|*
name|vpp
operator|!=
literal|0
condition|)
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 		struct thread  *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|xfs_vnode
modifier|*
name|xfs_vp
init|=
name|VPTOXFSVP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|XVOP_RECLAIM
argument_list|(
name|xfs_vp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|xfs_vp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xfs_vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_kqfilter
parameter_list|(
name|struct
name|vop_kqfilter_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		struct knote *a_kn; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|xfs_inode
modifier|*
name|xfs_vtoi
parameter_list|(
name|struct
name|xfs_vnode
modifier|*
name|xvp
parameter_list|)
block|{
return|return
operator|(
name|XFS_BHVTOI
argument_list|(
name|xvp
operator|->
name|v_fbhv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read wrapper for fifos.  */
end_comment

begin_function
specifier|static
name|int
name|_xfsfifo_read
parameter_list|(
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|xfs_inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|uio
operator|=
name|ap
operator|->
name|a_uio
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|fifo_specops
operator|.
name|vop_read
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ip
operator|=
name|xfs_vtoi
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOATIME
operator|)
operator|==
literal|0
operator|&&
name|ip
operator|!=
name|NULL
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|!=
name|resid
operator|||
operator|(
name|error
operator|==
literal|0
operator|&&
name|resid
operator|!=
literal|0
operator|)
operator|)
condition|)
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_ACC
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write wrapper for fifos.  */
end_comment

begin_function
specifier|static
name|int
name|_xfsfifo_write
parameter_list|(
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|xfs_inode
modifier|*
name|ip
decl_stmt|;
name|uio
operator|=
name|ap
operator|->
name|a_uio
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|fifo_specops
operator|.
name|vop_write
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ip
operator|=
name|xfs_vtoi
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|!=
name|resid
operator|||
operator|(
name|error
operator|==
literal|0
operator|&&
name|resid
operator|!=
literal|0
operator|)
operator|)
condition|)
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close wrapper for fifos.  *  * Update the times on the inode then do device close.  */
end_comment

begin_function
specifier|static
name|int
name|_xfsfifo_close
parameter_list|(
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|fifo_specops
operator|.
name|vop_close
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kqfilter wrapper for fifos.  *  * Fall through to ufs kqfilter routines if needed  */
end_comment

begin_function
specifier|static
name|int
name|_xfsfifo_kqfilter
parameter_list|(
name|struct
name|vop_kqfilter_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		struct knote *a_kn; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fifo_specops
operator|.
name|vop_kqfilter
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|_xfs_kqfilter
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
comment|/* { 		struct vnode *a_vp; 		int a_attrnamespace; 		const char *a_name; 		struct uio *a_uio; 		size_t *a_size; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|size
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|size
operator|=
name|ATTR_MAX_VALUELEN
expr_stmt|;
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|XVOP_ATTR_GET
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|value
argument_list|,
operator|&
name|size
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<
name|size
condition|)
name|error
operator|=
name|ERANGE
expr_stmt|;
else|else
name|uiomove
argument_list|(
name|value
argument_list|,
name|size
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_size
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_size
operator|=
name|size
expr_stmt|;
name|kmem_free
argument_list|(
name|value
argument_list|,
name|ATTR_MAX_VALUELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_listextattr
parameter_list|(
name|struct
name|vop_listextattr_args
comment|/* { 		struct vnode *a_vp; 		int a_attrnamespace; 		struct uio *a_uio; 		size_t *a_size; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|buf_len
init|=
literal|0
decl_stmt|;
name|attrlist_cursor_kern_t
name|cursor
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|name_len
decl_stmt|;
name|int
name|attrnames_len
init|=
literal|0
decl_stmt|;
name|int
name|xfs_flags
init|=
name|ATTR_KERNAMELS
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_attrnamespace
operator|&
name|EXTATTR_NAMESPACE_USER
condition|)
name|xfs_flags
operator||=
name|ATTR_KERNORMALS
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_attrnamespace
operator|&
name|EXTATTR_NAMESPACE_SYSTEM
condition|)
name|xfs_flags
operator||=
name|ATTR_KERNROOTLS
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|==
name|NULL
operator|||
name|ap
operator|->
name|a_uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|NULL
condition|)
block|{
name|xfs_flags
operator||=
name|ATTR_KERNOVAL
expr_stmt|;
name|buf_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
name|buf_len
operator|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|XVOP_ATTR_LIST
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|xfs_flags
argument_list|,
operator|&
name|cursor
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|attrnames_len
operator|=
operator|-
name|error
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * extattr_list expects a list of names.  Each list 	 * entry consists of one byte for the name length, followed 	 * by the name (not null terminated) 	 */
name|name_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|attrnames_len
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
condition|)
operator|++
name|name_len
expr_stmt|;
else|else
block|{
name|buf
index|[
name|i
index|]
operator|=
name|name_len
expr_stmt|;
name|name_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|name_len
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|a_uio
operator|->
name|uio_resid
operator|-=
name|attrnames_len
expr_stmt|;
name|done
label|:
if|if
condition|(
name|ap
operator|->
name|a_size
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_size
operator|=
name|attrnames_len
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_setextattr
parameter_list|(
name|struct
name|vop_setextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_setextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	INOUT struct uio *a_uio; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|size_t
name|vallen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|xfs_flags
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vallen
operator|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|vallen
operator|>
name|ATTR_MAX_VALUELEN
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xfs_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_attrnamespace
operator|&
name|EXTATTR_NAMESPACE_USER
condition|)
name|xfs_flags
operator||=
name|ATTR_KERNORMALS
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_attrnamespace
operator|&
name|EXTATTR_NAMESPACE_SYSTEM
condition|)
name|xfs_flags
operator||=
name|ATTR_KERNROOTLS
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|vallen
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|uiomove
argument_list|(
name|val
argument_list|,
operator|(
name|int
operator|)
name|vallen
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err_out
goto|;
name|XVOP_ATTR_SET
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|val
argument_list|,
name|vallen
argument_list|,
name|xfs_flags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|err_out
label|:
name|kmem_free
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_deleteextattr
parameter_list|(
name|struct
name|vop_deleteextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_deleteextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|int
name|error
decl_stmt|,
name|xfs_flags
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xfs_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_attrnamespace
operator|&
name|EXTATTR_NAMESPACE_USER
condition|)
name|xfs_flags
operator||=
name|ATTR_KERNORMALS
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_attrnamespace
operator|&
name|EXTATTR_NAMESPACE_SYSTEM
condition|)
name|xfs_flags
operator||=
name|ATTR_KERNROOTLS
expr_stmt|;
name|XVOP_ATTR_REMOVE
argument_list|(
name|VPTOXFSVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|xfs_flags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_xfs_vptofh
parameter_list|(
name|struct
name|vop_vptofh_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_vptofh { 	IN struct vnode *a_vp; 	IN struct fid *a_fhp; }; */
block|{
name|printf
argument_list|(
literal|"xfs_vptofh"
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
block|}
end_function

end_unit

