begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_vnode.h"
end_include

begin_function_decl
specifier|static
name|int
name|xfs_vn_allocate
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_inode_t
modifier|*
parameter_list|,
name|struct
name|xfs_vnode
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize the inode hash table for the newly mounted file system.  *  * mp -- this is the mount point structure for the file system being  *       initialized  */
end_comment

begin_function
name|void
name|xfs_ihash_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mp
operator|->
name|m_ihsize
operator|=
name|XFS_BUCKETS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ihash
operator|=
operator|(
name|xfs_ihash_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|mp
operator|->
name|m_ihsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_ihash_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_ihash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_ihsize
condition|;
name|i
operator|++
control|)
block|{
name|rwlock_init
argument_list|(
operator|&
operator|(
name|mp
operator|->
name|m_ihash
index|[
name|i
index|]
operator|.
name|ih_lock
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up structures allocated by xfs_ihash_init, at unmount time.  */
end_comment

begin_function
name|void
name|xfs_ihash_free
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_ihsize
condition|;
name|i
operator|++
control|)
name|rwlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_ihash
index|[
name|i
index|]
operator|.
name|ih_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_ihash
argument_list|,
name|mp
operator|->
name|m_ihsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_ihash_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ihash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the inode cluster hash table for the newly mounted file system.  *  * mp -- this is the mount point structure for the file system being  *       initialized  */
end_comment

begin_function
name|void
name|xfs_chash_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * m_chash size is based on m_ihash 	 * with a minimum of 37 entries 	 */
name|mp
operator|->
name|m_chsize
operator|=
operator|(
name|XFS_BUCKETS
argument_list|(
name|mp
argument_list|)
operator|)
operator|/
operator|(
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|mp
argument_list|)
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
operator|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_chsize
operator|<
literal|37
condition|)
block|{
name|mp
operator|->
name|m_chsize
operator|=
literal|37
expr_stmt|;
block|}
name|mp
operator|->
name|m_chash
operator|=
operator|(
name|xfs_chash_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|mp
operator|->
name|m_chsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_chash_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_chash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_chsize
condition|;
name|i
operator|++
control|)
block|{
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_chash
index|[
name|i
index|]
operator|.
name|ch_lock
argument_list|,
literal|"xfshash"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up structures allocated by xfs_chash_init, at unmount time.  */
end_comment

begin_function
name|void
name|xfs_chash_free
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_chsize
condition|;
name|i
operator|++
control|)
block|{
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_chash
index|[
name|i
index|]
operator|.
name|ch_lock
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_chash
argument_list|,
name|mp
operator|->
name|m_chsize
operator|*
sizeof|sizeof
argument_list|(
name|xfs_chash_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_chash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up an inode by number in the given file system.  * The inode is looked up in the hash table for the file system  * represented by the mount point parameter mp.  Each bucket of  * the hash table is guarded by an individual semaphore.  *  * If the inode is found in the hash table, its corresponding vnode  * is obtained with a call to vn_get().  This call takes care of  * coordination with the reclamation of the inode and vnode.  Note  * that the vmap structure is filled in while holding the hash lock.  * This gives us the state of the inode/vnode when we found it and  * is used for coordination in vn_get().  *  * If it is not in core, read it in from the file system's device and  * add the inode into the hash table.  *  * The inode is locked according to the value of the lock_flags parameter.  * This flag parameter indicates how and if the inode's IO lock and inode lock  * should be taken.  *  * mp -- the mount point structure for the current file system.  It points  *       to the inode hash table.  * tp -- a pointer to the current transaction if there is one.  This is  *       simply passed through to the xfs_iread() call.  * ino -- the number of the inode desired.  This is the unique identifier  *        within the file system for the inode being requested.  * lock_flags -- flags indicating how to lock the inode.  See the comment  *		 for xfs_ilock() for a list of valid values.  * bno -- the block number starting the buffer containing the inode,  *	  if known (as by bulkstat), else 0.  */
end_comment

begin_function
name|int
name|xfs_iget
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|uint
name|lock_flags
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|,
name|xfs_daddr_t
name|bno
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|ulong
name|version
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* REFERENCED */
name|int
name|newnode
decl_stmt|;
name|xfs_chash_t
modifier|*
name|ch
decl_stmt|;
name|xfs_chashlist_t
modifier|*
name|chl
decl_stmt|,
modifier|*
name|chlnew
decl_stmt|;
name|vmap_t
name|vmap
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_attempts
argument_list|)
expr_stmt|;
name|ih
operator|=
name|XFS_IHASH
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|again
label|:
name|read_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ih
operator|->
name|ih_next
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|VMAP
argument_list|(
name|vp
argument_list|,
name|vmap
argument_list|)
expr_stmt|;
comment|/* 			 * Inode cache hit: if ip is not at the front of 			 * its hash chain, move it there now. 			 * Do this with the lock held for update, but 			 * do statistics after releasing the lock. 			 */
if|if
condition|(
name|ip
operator|->
name|i_prevp
operator|!=
operator|&
name|ih
operator|->
name|ih_next
operator|&&
name|rwlock_trypromote
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|iq
operator|=
name|ip
operator|->
name|i_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
name|ip
operator|->
name|i_prevp
expr_stmt|;
block|}
operator|*
name|ip
operator|->
name|i_prevp
operator|=
name|iq
expr_stmt|;
name|iq
operator|=
name|ih
operator|->
name|ih_next
expr_stmt|;
name|iq
operator|->
name|i_prevp
operator|=
operator|&
name|ip
operator|->
name|i_next
expr_stmt|;
name|ip
operator|->
name|i_next
operator|=
name|iq
expr_stmt|;
name|ip
operator|->
name|i_prevp
operator|=
operator|&
name|ih
operator|->
name|ih_next
expr_stmt|;
name|ih
operator|->
name|ih_next
operator|=
name|ip
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_ig_found
argument_list|)
expr_stmt|;
comment|/* 			 * Get a reference to the vnode/inode. 			 * vn_get() takes care of coordination with 			 * the file system inode release and reclaim 			 * functions.  If it returns NULL, the inode 			 * has been reclaimed so just start the search 			 * over again.  We probably won't find it, 			 * but we could be racing with another cpu 			 * looking for the same inode so we have to at 			 * least look. 			 */
if|if
condition|(
operator|!
operator|(
name|vp
operator|=
name|vn_get
argument_list|(
name|vp
argument_list|,
operator|&
name|vmap
argument_list|)
operator|)
condition|)
block|{
name|XFS_STATS_INC
argument_list|(
name|xs_ig_frecycle
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|XFS_IRECLAIM
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
name|newnode
operator|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|newnode
condition|)
block|{
name|xfs_iocore_inode_reinit
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|XFS_ISTALE
expr_stmt|;
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.found"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
goto|goto
name|return_ip
goto|;
block|}
block|}
comment|/* 	 * Inode cache miss: save the hash chain version stamp and unlock 	 * the chain, so we don't deadlock in vn_alloc. 	 */
name|XFS_STATS_INC
argument_list|(
name|xs_ig_missed
argument_list|)
expr_stmt|;
name|version
operator|=
name|ih
operator|->
name|ih_version
expr_stmt|;
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Read the disk inode attributes into a new inode structure and get 	 * a new vnode for it. This should also initialize i_ino and i_mount. 	 */
name|error
operator|=
name|xfs_iread
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
operator|&
name|ip
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|xfs_vn_allocate
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.alloc"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|xfs_inode_lock_init
argument_list|(
name|ip
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|xfs_iocore_inode_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put ip on its hash chain, unless someone else hashed a duplicate 	 * after we released the hash lock. 	 */
name|write_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_version
operator|!=
name|version
condition|)
block|{
for|for
control|(
name|iq
operator|=
name|ih
operator|->
name|ih_next
init|;
name|iq
operator|!=
name|NULL
condition|;
name|iq
operator|=
name|iq
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|iq
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|xfs_idestroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_dup
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
comment|/* 	 * These values _must_ be set before releasing ihlock! 	 */
name|ip
operator|->
name|i_hash
operator|=
name|ih
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|ih
operator|->
name|ih_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
operator|&
name|ip
operator|->
name|i_next
expr_stmt|;
block|}
name|ip
operator|->
name|i_next
operator|=
name|iq
expr_stmt|;
name|ip
operator|->
name|i_prevp
operator|=
operator|&
name|ih
operator|->
name|ih_next
expr_stmt|;
name|ih
operator|->
name|ih_next
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_udquot
operator|=
name|ip
operator|->
name|i_gdquot
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|ih_version
operator|++
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * put ip on its cluster's hash chain 	 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_chash
operator|==
name|NULL
operator|&&
name|ip
operator|->
name|i_cprev
operator|==
name|NULL
operator|&&
name|ip
operator|->
name|i_cnext
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|chlnew
operator|=
name|NULL
expr_stmt|;
name|ch
operator|=
name|XFS_CHASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_blkno
argument_list|)
expr_stmt|;
name|chlredo
label|:
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|chl
operator|=
name|ch
operator|->
name|ch_list
init|;
name|chl
operator|!=
name|NULL
condition|;
name|chl
operator|=
name|chl
operator|->
name|chl_next
control|)
block|{
if|if
condition|(
name|chl
operator|->
name|chl_blkno
operator|==
name|ip
operator|->
name|i_blkno
condition|)
block|{
comment|/* insert this inode into the doubly-linked list 			 * where chl points */
if|if
condition|(
operator|(
name|iq
operator|=
name|chl
operator|->
name|chl_ip
operator|)
condition|)
block|{
name|ip
operator|->
name|i_cprev
operator|=
name|iq
operator|->
name|i_cprev
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cnext
operator|=
name|iq
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
block|}
name|chl
operator|->
name|chl_ip
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_chash
operator|=
name|chl
expr_stmt|;
break|break;
block|}
block|}
comment|/* no hash list found for this block; add a new hash list */
if|if
condition|(
name|chl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|chlnew
operator|==
name|NULL
condition|)
block|{
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_chashlist_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chlnew
operator|=
operator|(
name|xfs_chashlist_t
operator|*
operator|)
name|kmem_zone_alloc
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|chlnew
operator|!=
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|chlredo
goto|;
block|}
else|else
block|{
name|ip
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_chash
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|->
name|chl_ip
operator|=
name|ip
expr_stmt|;
name|chlnew
operator|->
name|chl_blkno
operator|=
name|ip
operator|->
name|i_blkno
expr_stmt|;
name|chlnew
operator|->
name|chl_next
operator|=
name|ch
operator|->
name|ch_list
expr_stmt|;
name|ch
operator|->
name|ch_list
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chlnew
operator|!=
name|NULL
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|chlnew
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Link ip to its mount and thread it on the mount's inode list. 	 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|mp
operator|->
name|m_inodes
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|iq
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|==
name|iq
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|=
name|iq
operator|->
name|i_mprev
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|=
name|ip
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_mnext
operator|=
name|iq
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_mnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|=
name|ip
expr_stmt|;
block|}
name|mp
operator|->
name|m_inodes
operator|=
name|ip
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|newnode
operator|=
literal|1
expr_stmt|;
name|return_ip
label|:
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
operator|(
name|ip
operator|->
name|i_iocore
operator|.
name|io_flags
operator|&
name|XFS_IOCORE_RT
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
comment|/* 	 * If we have a real type for an on-disk inode, we can set ops(&unlock) 	 * now.	 If it's a new inode being created, xfs_ialloc will handle it. 	 */
name|XVFS_INIT_VNODE
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Do the setup for the various locks within the incore inode.  */
end_comment

begin_function
name|void
name|xfs_inode_lock_init
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|mrlock_init
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MRLOCK_ALLOW_EQUAL_PRI
operator||
name|MRLOCK_BARRIER
argument_list|,
literal|"xfsino"
argument_list|,
operator|(
name|long
operator|)
name|vp
operator|->
name|v_number
argument_list|)
expr_stmt|;
name|mrlock_init
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MRLOCK_BARRIER
argument_list|,
literal|"xfsio"
argument_list|,
name|vp
operator|->
name|v_number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XXXKAN
name|init_waitqueue_head
argument_list|(
operator|&
name|ip
operator|->
name|i_ipin_wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atomic_set
argument_list|(
operator|&
name|ip
operator|->
name|i_pincount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_sema
argument_list|(
operator|&
name|ip
operator|->
name|i_flock
argument_list|,
literal|1
argument_list|,
literal|"xfsfino"
argument_list|,
name|vp
operator|->
name|v_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for the inode corresponding to the given ino in the hash table.  * If it is there and its i_transp pointer matches tp, return it.  * Otherwise, return NULL.  */
end_comment

begin_function
name|xfs_inode_t
modifier|*
name|xfs_inode_incore
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|ih
operator|=
name|XFS_IHASH
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|read_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ih
operator|->
name|ih_next
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
comment|/* 			 * If we find it and tp matches, return it. 			 * Otherwise break from the loop and return 			 * NULL. 			 */
if|if
condition|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
condition|)
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
break|break;
block|}
block|}
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decrement reference count of an inode structure and unlock it.  *  * ip -- the inode being released  * lock_flags -- this parameter indicates the inode's locks to be  *       to be released.  See the comment on xfs_iunlock() for a list  *	 of valid values.  */
end_comment

begin_function
name|void
name|xfs_iput
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_iput"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Special iput for brand-new inodes that are still locked  */
end_comment

begin_function
name|void
name|xfs_iput_new
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_iput_new"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
condition|)
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine embodies the part of the reclaim code that pulls  * the inode from the inode hash table and the mount structure's  * inode list.  * This should only be called from xfs_reclaim().  */
end_comment

begin_function
name|void
name|xfs_ireclaim
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Remove from old hash list and mount list. 	 */
name|XFS_STATS_INC
argument_list|(
name|xs_ig_reclaims
argument_list|)
expr_stmt|;
name|xfs_iextract
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Here we do a spurious inode lock in order to coordinate with 	 * xfs_sync().  This is because xfs_sync() references the inodes 	 * in the mount list without taking references on the corresponding 	 * vnodes.  We make that OK here by ensuring that we wait until 	 * the inode is unlocked in xfs_sync() before we go ahead and 	 * free it.  We get both the regular lock and the io lock because 	 * the xfs_sync() code may need to drop the regular one but will 	 * still hold the io lock. 	 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Release dquots (and their references) if any. An inode may escape 	 * xfs_inactive and get here via vn_alloc->vn_reclaim path. 	 */
name|XFS_QM_DQDETACH
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Pull our behavior descriptor from the vnode chain. 	 */
name|vp
operator|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|vn_bhv_remove
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free all memory associated with the inode. 	 */
name|xfs_idestroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine removes an about-to-be-destroyed inode from  * all of the lists in which it is located with the exception  * of the behavior chain.  */
end_comment

begin_function
name|void
name|xfs_iextract
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_chash_t
modifier|*
name|ch
decl_stmt|;
name|xfs_chashlist_t
modifier|*
name|chl
decl_stmt|,
modifier|*
name|chm
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ih
operator|=
name|ip
operator|->
name|i_hash
expr_stmt|;
name|write_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|ip
operator|->
name|i_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
name|ip
operator|->
name|i_prevp
expr_stmt|;
block|}
operator|*
name|ip
operator|->
name|i_prevp
operator|=
name|iq
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from cluster hash list 	 *   1) delete the chashlist if this is the last inode on the chashlist 	 *   2) unchain from list of inodes 	 *   3) point chashlist->chl_ip to 'chl_next' if to this inode. 	 */
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|ch
operator|=
name|XFS_CHASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_blkno
argument_list|)
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_cnext
operator|==
name|ip
condition|)
block|{
comment|/* Last inode on chashlist */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_cnext
operator|==
name|ip
operator|&&
name|ip
operator|->
name|i_cprev
operator|==
name|ip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_chash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chm
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|chl
operator|=
name|ch
operator|->
name|ch_list
init|;
name|chl
operator|!=
name|NULL
condition|;
name|chl
operator|=
name|chl
operator|->
name|chl_next
control|)
block|{
if|if
condition|(
name|chl
operator|->
name|chl_blkno
operator|==
name|ip
operator|->
name|i_blkno
condition|)
block|{
if|if
condition|(
name|chm
operator|==
name|NULL
condition|)
block|{
comment|/* first item on the list */
name|ch
operator|->
name|ch_list
operator|=
name|chl
operator|->
name|chl_next
expr_stmt|;
block|}
else|else
block|{
name|chm
operator|->
name|chl_next
operator|=
name|chl
operator|->
name|chl_next
expr_stmt|;
block|}
name|kmem_zone_free
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|chl
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|chl
operator|->
name|chl_ip
operator|!=
name|ip
argument_list|)
expr_stmt|;
name|chm
operator|=
name|chl
expr_stmt|;
block|}
block|}
name|ASSERT_ALWAYS
argument_list|(
name|chl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* delete one inode from a non-empty list */
name|iq
operator|=
name|ip
operator|->
name|i_cnext
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|=
name|ip
operator|->
name|i_cprev
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|->
name|i_cnext
operator|=
name|iq
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_chash
operator|->
name|chl_ip
operator|==
name|ip
condition|)
block|{
name|ip
operator|->
name|i_chash
operator|->
name|chl_ip
operator|=
name|iq
expr_stmt|;
block|}
name|ip
operator|->
name|i_chash
operator|=
name|__return_address
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|__return_address
expr_stmt|;
name|ip
operator|->
name|i_cnext
operator|=
name|__return_address
expr_stmt|;
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from mount's inode list. 	 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_mnext
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_mprev
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|iq
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|=
name|ip
operator|->
name|i_mprev
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|=
name|iq
expr_stmt|;
comment|/* 	 * Fix up the head pointer if it points to the inode being deleted. 	 */
if|if
condition|(
name|mp
operator|->
name|m_inodes
operator|==
name|ip
condition|)
block|{
if|if
condition|(
name|ip
operator|==
name|iq
condition|)
block|{
name|mp
operator|->
name|m_inodes
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_inodes
operator|=
name|iq
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|XXXKAN
comment|/* 	 * Not sure if while i_reclaim crap is needed on 	 * FreeBSD, will revisit this later. 	 */
comment|/* Deal with the deleted inodes list */
name|list_del_init
argument_list|(
operator|&
name|ip
operator|->
name|i_reclaim
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|m_ireclaims
operator|++
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a wrapper routine around the xfs_ilock() routine  * used to centralize some grungy code.  It is used in places  * that wish to lock the inode solely for reading the extents.  * The reason these places can't just call xfs_ilock(SHARED)  * is that the inode lock also guards to bringing in of the  * extents from disk for a file in b-tree format.  If the inode  * is in b-tree format, then we need to lock the inode exclusively  * until the extents are read in.  Locking it exclusively all  * the time would limit our parallelism unnecessarily, though.  * What we do instead is check to see if the extents have been  * read in yet, and only lock the inode exclusively if they  * have not.  *  * The function returns a value which should be given to the  * corresponding xfs_iunlock_map_shared().  This value is  * the mode in which the lock was actually taken.  */
end_comment

begin_function
name|uint
name|xfs_ilock_map_shared
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|uint
name|lock_mode
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_BTREE
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_flags
operator|&
name|XFS_IFEXTENTS
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|lock_mode
operator|=
name|XFS_ILOCK_EXCL
expr_stmt|;
block|}
else|else
block|{
name|lock_mode
operator|=
name|XFS_ILOCK_SHARED
expr_stmt|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
return|return
name|lock_mode
return|;
block|}
end_function

begin_comment
comment|/*  * This is simply the unlock routine to go with xfs_ilock_map_shared().  * All it does is call xfs_iunlock() with the given lock_mode.  */
end_comment

begin_function
name|void
name|xfs_iunlock_map_shared
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|unsigned
name|int
name|lock_mode
parameter_list|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The xfs inode contains 2 locks: a multi-reader lock called the  * i_iolock and a multi-reader lock called the i_lock.  This routine  * allows either or both of the locks to be obtained.  *  * The 2 locks should always be ordered so that the IO lock is  * obtained first in order to prevent deadlock.  *  * ip -- the inode being locked  * lock_flags -- this parameter indicates the inode's locks  *       to be locked.  It can be:  *		XFS_IOLOCK_SHARED,  *		XFS_IOLOCK_EXCL,  *		XFS_ILOCK_SHARED,  *		XFS_ILOCK_EXCL,  *		XFS_IOLOCK_SHARED | XFS_ILOCK_SHARED,  *		XFS_IOLOCK_SHARED | XFS_ILOCK_EXCL,  *		XFS_IOLOCK_EXCL | XFS_ILOCK_SHARED,  *		XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL  */
end_comment

begin_function
name|void
name|xfs_ilock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
comment|/* 	 * You can't set both SHARED and EXCL for the same lock, 	 * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED, 	 * and XFS_ILOCK_EXCL are valid values to set in lock_flags. 	 */
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
name|XFS_LOCK_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|mrupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
condition|)
block|{
name|mraccess
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|mrupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_SHARED
condition|)
block|{
name|mraccess
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
block|}
name|xfs_ilock_trace
argument_list|(
name|ip
argument_list|,
literal|1
argument_list|,
name|lock_flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is just like xfs_ilock(), except that the caller  * is guaranteed not to sleep.  It returns 1 if it gets  * the requested locks and 0 otherwise.  If the IO lock is  * obtained but the inode lock cannot be, then the IO lock  * is dropped before returning.  *  * ip -- the inode being locked  * lock_flags -- this parameter indicates the inode's locks to be  *       to be locked.  See the comment for xfs_ilock() for a list  *	 of valid values.  *  */
end_comment

begin_function
name|int
name|xfs_ilock_nowait
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|int
name|iolocked
decl_stmt|;
name|int
name|ilocked
decl_stmt|;
comment|/* 	 * You can't set both SHARED and EXCL for the same lock, 	 * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED, 	 * and XFS_ILOCK_EXCL are valid values to set in lock_flags. 	 */
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
name|XFS_LOCK_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|iolocked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|iolocked
operator|=
name|mrtryupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iolocked
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
condition|)
block|{
name|iolocked
operator|=
name|mrtryaccess
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iolocked
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|ilocked
operator|=
name|mrtryupdate
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ilocked
condition|)
block|{
if|if
condition|(
name|iolocked
condition|)
block|{
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_SHARED
condition|)
block|{
name|ilocked
operator|=
name|mrtryaccess
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ilocked
condition|)
block|{
if|if
condition|(
name|iolocked
condition|)
block|{
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
name|xfs_ilock_trace
argument_list|(
name|ip
argument_list|,
literal|2
argument_list|,
name|lock_flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_iunlock() is used to drop the inode locks acquired with  * xfs_ilock() and xfs_ilock_nowait().  The caller must pass  * in the flags given to xfs_ilock() or xfs_ilock_nowait() so  * that we know which locks to drop.  *  * ip -- the inode being unlocked  * lock_flags -- this parameter indicates the inode's locks to be  *       to be unlocked.  See the comment for xfs_ilock() for a list  *	 of valid values for this parameter.  *  */
end_comment

begin_function
name|void
name|xfs_iunlock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
comment|/* 	 * You can't set both SHARED and EXCL for the same lock, 	 * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED, 	 * and XFS_ILOCK_EXCL are valid values to set in lock_flags. 	 */
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|!=
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
operator|(
name|XFS_LOCK_MASK
operator||
name|XFS_IUNLOCK_NONOTIFY
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lock_flags
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_ACCESS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
operator|(
name|XFS_ILOCK_SHARED
operator||
name|XFS_ILOCK_EXCL
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_ILOCK_SHARED
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_ACCESS
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
operator|)
operator|||
operator|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mrunlock
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Let the AIL know that this item has been unlocked in case 		 * it is in the AIL and anyone is waiting on it.  Don't do 		 * this if the caller has asked us not to. 		 */
if|if
condition|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IUNLOCK_NONOTIFY
operator|)
operator|&&
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
condition|)
block|{
name|xfs_trans_unlocked_item
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|(
name|ip
operator|->
name|i_itemp
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_ilock_trace
argument_list|(
name|ip
argument_list|,
literal|3
argument_list|,
name|lock_flags
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * give up write locks.  the i/o lock cannot be held nested  * if it is being demoted.  */
end_comment

begin_function
name|void
name|xfs_ilock_demote
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|lock_flags
operator|&
operator|~
operator|(
name|XFS_IOLOCK_EXCL
operator||
name|XFS_ILOCK_EXCL
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|mrdemote
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|mrdemote
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The following three routines simply manage the i_flock  * semaphore embedded in the inode.  This semaphore synchronizes  * processes attempting to flush the in-core inode back to disk.  */
end_comment

begin_function
name|void
name|xfs_iflock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|psema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|,
name|PINOD
operator||
name|PLTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xfs_iflock_nowait
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
return|return
operator|(
name|cpsema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xfs_ifunlock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|valusema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|vsema
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_flock
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|vop_vector
name|xfs_vnops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xfs_vn_allocate
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|xfs_vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|xfs_vnode
modifier|*
name|vdata
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Use zone allocator here? */
name|vdata
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vdata
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"xfs"
argument_list|,
name|XVFSTOMNT
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
operator|&
name|xfs_vnops
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|vdata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vdata
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|->
name|v_vnlock
operator|->
name|lk_flags
operator||=
name|LK_CANRECURSE
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
operator|(
name|void
operator|*
operator|)
name|vdata
expr_stmt|;
name|vdata
operator|->
name|v_number
operator|=
literal|0
expr_stmt|;
name|vdata
operator|->
name|v_inode
operator|=
name|ip
expr_stmt|;
name|vdata
operator|->
name|v_vfsp
operator|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vdata
operator|->
name|v_vnode
operator|=
name|vp
expr_stmt|;
name|vdata
operator|->
name|v_type
operator|=
name|vp
operator|->
name|v_type
operator|=
name|VNON
expr_stmt|;
name|vn_bhv_head_init
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vdata
argument_list|)
argument_list|,
literal|"vnode"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_XFS_VNODE_TRACING
name|vp
operator|->
name|v_trace
operator|=
name|ktrace_alloc
argument_list|(
name|VNODE_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_XFS_VNODE_TRACING */
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"vn_initialize"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|vdata
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

