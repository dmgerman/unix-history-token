begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|<xfs.h>
end_include

begin_decl_stmt
specifier|static
name|kmem_zone_t
modifier|*
name|ktrace_hdr_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmem_zone_t
modifier|*
name|ktrace_ent_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ktrace_zentries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|wrap_lock
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ktrace_init
parameter_list|(
name|int
name|zentries
parameter_list|)
block|{
name|ktrace_zentries
operator|=
name|zentries
expr_stmt|;
name|ktrace_hdr_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|ktrace_t
argument_list|)
argument_list|,
literal|"ktrace_hdr"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ktrace_hdr_zone
argument_list|)
expr_stmt|;
name|ktrace_ent_zone
operator|=
name|kmem_zone_init
argument_list|(
name|ktrace_zentries
operator|*
sizeof|sizeof
argument_list|(
name|ktrace_entry_t
argument_list|)
argument_list|,
literal|"ktrace_ent"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ktrace_ent_zone
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|wrap_lock
argument_list|,
literal|"xfsktr"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ktrace_uninit
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_zone_destroy
argument_list|(
name|ktrace_hdr_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|ktrace_ent_zone
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|wrap_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ktrace_alloc()  *  * Allocate a ktrace header and enough buffering for the given  * number of entries.  */
end_comment

begin_function
name|ktrace_t
modifier|*
name|ktrace_alloc
parameter_list|(
name|int
name|nentries
parameter_list|,
name|int
name|sleep
parameter_list|)
block|{
name|ktrace_t
modifier|*
name|ktp
decl_stmt|;
name|ktrace_entry_t
modifier|*
name|ktep
decl_stmt|;
name|ktp
operator|=
operator|(
name|ktrace_t
operator|*
operator|)
name|kmem_zone_alloc
argument_list|(
name|ktrace_hdr_zone
argument_list|,
name|sleep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ktp
operator|==
operator|(
name|ktrace_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 		 * KM_SLEEP callers don't expect failure. 		 */
if|if
condition|(
name|sleep
operator|&
name|KM_SLEEP
condition|)
name|panic
argument_list|(
literal|"ktrace_alloc: NULL memory on KM_SLEEP request!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Special treatment for buffers with the ktrace_zentries entries 	 */
if|if
condition|(
name|nentries
operator|==
name|ktrace_zentries
condition|)
block|{
name|ktep
operator|=
operator|(
name|ktrace_entry_t
operator|*
operator|)
name|kmem_zone_zalloc
argument_list|(
name|ktrace_ent_zone
argument_list|,
name|sleep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ktep
operator|=
operator|(
name|ktrace_entry_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
operator|(
name|nentries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ktep
argument_list|)
operator|)
argument_list|,
name|sleep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ktep
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * KM_SLEEP callers don't expect failure. 		 */
if|if
condition|(
name|sleep
operator|&
name|KM_SLEEP
condition|)
name|panic
argument_list|(
literal|"ktrace_alloc: NULL memory on KM_SLEEP request!"
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ktp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ktp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|spinlock_init
argument_list|(
operator|&
operator|(
name|ktp
operator|->
name|kt_lock
operator|)
argument_list|,
literal|"kt_lock"
argument_list|)
expr_stmt|;
name|ktp
operator|->
name|kt_entries
operator|=
name|ktep
expr_stmt|;
name|ktp
operator|->
name|kt_nentries
operator|=
name|nentries
expr_stmt|;
name|ktp
operator|->
name|kt_index
operator|=
literal|0
expr_stmt|;
name|ktp
operator|->
name|kt_rollover
operator|=
literal|0
expr_stmt|;
return|return
name|ktp
return|;
block|}
end_function

begin_comment
comment|/*  * ktrace_free()  *  * Free up the ktrace header and buffer.  It is up to the caller  * to ensure that no-one is referencing it.  */
end_comment

begin_function
name|void
name|ktrace_free
parameter_list|(
name|ktrace_t
modifier|*
name|ktp
parameter_list|)
block|{
name|int
name|entries_size
decl_stmt|;
if|if
condition|(
name|ktp
operator|==
operator|(
name|ktrace_t
operator|*
operator|)
name|NULL
condition|)
return|return;
name|spinlock_destroy
argument_list|(
operator|&
name|ktp
operator|->
name|kt_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Special treatment for the Vnode trace buffer. 	 */
if|if
condition|(
name|ktp
operator|->
name|kt_nentries
operator|==
name|ktrace_zentries
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|ktrace_ent_zone
argument_list|,
name|ktp
operator|->
name|kt_entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entries_size
operator|=
call|(
name|int
call|)
argument_list|(
name|ktp
operator|->
name|kt_nentries
operator|*
sizeof|sizeof
argument_list|(
name|ktrace_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ktp
operator|->
name|kt_entries
argument_list|,
name|entries_size
argument_list|)
expr_stmt|;
block|}
name|kmem_zone_free
argument_list|(
name|ktrace_hdr_zone
argument_list|,
name|ktp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter the given values into the "next" entry in the trace buffer.  * kt_index is always the index of the next entry to be filled.  */
end_comment

begin_function
name|void
name|ktrace_enter
parameter_list|(
name|ktrace_t
modifier|*
name|ktp
parameter_list|,
name|void
modifier|*
name|val0
parameter_list|,
name|void
modifier|*
name|val1
parameter_list|,
name|void
modifier|*
name|val2
parameter_list|,
name|void
modifier|*
name|val3
parameter_list|,
name|void
modifier|*
name|val4
parameter_list|,
name|void
modifier|*
name|val5
parameter_list|,
name|void
modifier|*
name|val6
parameter_list|,
name|void
modifier|*
name|val7
parameter_list|,
name|void
modifier|*
name|val8
parameter_list|,
name|void
modifier|*
name|val9
parameter_list|,
name|void
modifier|*
name|val10
parameter_list|,
name|void
modifier|*
name|val11
parameter_list|,
name|void
modifier|*
name|val12
parameter_list|,
name|void
modifier|*
name|val13
parameter_list|,
name|void
modifier|*
name|val14
parameter_list|,
name|void
modifier|*
name|val15
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|ktrace_entry_t
modifier|*
name|ktep
decl_stmt|;
name|ASSERT
argument_list|(
name|ktp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Grab an entry by pushing the index up to the next one. 	 */
name|mtx_lock
argument_list|(
operator|&
name|wrap_lock
argument_list|)
expr_stmt|;
name|index
operator|=
name|ktp
operator|->
name|kt_index
expr_stmt|;
if|if
condition|(
operator|++
name|ktp
operator|->
name|kt_index
operator|==
name|ktp
operator|->
name|kt_nentries
condition|)
name|ktp
operator|->
name|kt_index
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|wrap_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ktp
operator|->
name|kt_rollover
operator|&&
name|index
operator|==
name|ktp
operator|->
name|kt_nentries
operator|-
literal|1
condition|)
name|ktp
operator|->
name|kt_rollover
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|ktp
operator|->
name|kt_nentries
operator|)
argument_list|)
expr_stmt|;
name|ktep
operator|=
operator|&
operator|(
name|ktp
operator|->
name|kt_entries
index|[
name|index
index|]
operator|)
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|0
index|]
operator|=
name|val0
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|1
index|]
operator|=
name|val1
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|2
index|]
operator|=
name|val2
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|3
index|]
operator|=
name|val3
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|4
index|]
operator|=
name|val4
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|5
index|]
operator|=
name|val5
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|6
index|]
operator|=
name|val6
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|7
index|]
operator|=
name|val7
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|8
index|]
operator|=
name|val8
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|9
index|]
operator|=
name|val9
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|10
index|]
operator|=
name|val10
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|11
index|]
operator|=
name|val11
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|12
index|]
operator|=
name|val12
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|13
index|]
operator|=
name|val13
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|14
index|]
operator|=
name|val14
expr_stmt|;
name|ktep
operator|->
name|val
index|[
literal|15
index|]
operator|=
name|val15
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of entries in the trace buffer.  */
end_comment

begin_function
name|int
name|ktrace_nentries
parameter_list|(
name|ktrace_t
modifier|*
name|ktp
parameter_list|)
block|{
if|if
condition|(
name|ktp
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
name|ktp
operator|->
name|kt_rollover
condition|?
name|ktp
operator|->
name|kt_nentries
else|:
name|ktp
operator|->
name|kt_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ktrace_first()  *  * This is used to find the start of the trace buffer.  * In conjunction with ktrace_next() it can be used to  * iterate through the entire trace buffer.  This code does  * not do any locking because it is assumed that it is called  * from the debugger.  *  * The caller must pass in a pointer to a ktrace_snap  * structure in which we will keep some state used to  * iterate through the buffer.  This state must not touched  * by any code outside of this module.  */
end_comment

begin_function
name|ktrace_entry_t
modifier|*
name|ktrace_first
parameter_list|(
name|ktrace_t
modifier|*
name|ktp
parameter_list|,
name|ktrace_snap_t
modifier|*
name|ktsp
parameter_list|)
block|{
name|ktrace_entry_t
modifier|*
name|ktep
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|nentries
decl_stmt|;
if|if
condition|(
name|ktp
operator|->
name|kt_rollover
condition|)
name|index
operator|=
name|ktp
operator|->
name|kt_index
expr_stmt|;
else|else
name|index
operator|=
literal|0
expr_stmt|;
name|ktsp
operator|->
name|ks_start
operator|=
name|index
expr_stmt|;
name|ktep
operator|=
operator|&
operator|(
name|ktp
operator|->
name|kt_entries
index|[
name|index
index|]
operator|)
expr_stmt|;
name|nentries
operator|=
name|ktrace_nentries
argument_list|(
name|ktp
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|nentries
condition|)
block|{
name|ktsp
operator|->
name|ks_index
operator|=
name|index
expr_stmt|;
block|}
else|else
block|{
name|ktsp
operator|->
name|ks_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|nentries
condition|)
name|ktep
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ktep
return|;
block|}
end_function

begin_comment
comment|/*  * ktrace_next()  *  * This is used to iterate through the entries of the given  * trace buffer.  The caller must pass in the ktrace_snap_t  * structure initialized by ktrace_first().  The return value  * will be either a pointer to the next ktrace_entry or NULL  * if all of the entries have been traversed.  */
end_comment

begin_function
name|ktrace_entry_t
modifier|*
name|ktrace_next
parameter_list|(
name|ktrace_t
modifier|*
name|ktp
parameter_list|,
name|ktrace_snap_t
modifier|*
name|ktsp
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|ktrace_entry_t
modifier|*
name|ktep
decl_stmt|;
name|index
operator|=
name|ktsp
operator|->
name|ks_index
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|ktsp
operator|->
name|ks_start
condition|)
block|{
name|ktep
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ktep
operator|=
operator|&
name|ktp
operator|->
name|kt_entries
index|[
name|index
index|]
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|ktrace_nentries
argument_list|(
name|ktp
argument_list|)
condition|)
block|{
name|ktsp
operator|->
name|ks_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ktsp
operator|->
name|ks_index
operator|=
name|index
expr_stmt|;
block|}
return|return
name|ktep
return|;
block|}
end_function

begin_comment
comment|/*  * ktrace_skip()  *  * Skip the next "count" entries and return the entry after that.  * Return NULL if this causes us to iterate past the beginning again.  */
end_comment

begin_function
name|ktrace_entry_t
modifier|*
name|ktrace_skip
parameter_list|(
name|ktrace_t
modifier|*
name|ktp
parameter_list|,
name|int
name|count
parameter_list|,
name|ktrace_snap_t
modifier|*
name|ktsp
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|new_index
decl_stmt|;
name|ktrace_entry_t
modifier|*
name|ktep
decl_stmt|;
name|int
name|nentries
init|=
name|ktrace_nentries
argument_list|(
name|ktp
argument_list|)
decl_stmt|;
name|index
operator|=
name|ktsp
operator|->
name|ks_index
expr_stmt|;
name|new_index
operator|=
name|index
operator|+
name|count
expr_stmt|;
while|while
condition|(
name|new_index
operator|>=
name|nentries
condition|)
block|{
name|new_index
operator|-=
name|nentries
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
name|ktsp
operator|->
name|ks_start
condition|)
block|{
comment|/* 		 * We've iterated around to the start, so we're done. 		 */
name|ktep
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_index
operator|<
name|index
operator|)
operator|&&
operator|(
name|index
operator|<
name|ktsp
operator|->
name|ks_index
operator|)
condition|)
block|{
comment|/* 		 * We've skipped past the start again, so we're done. 		 */
name|ktep
operator|=
name|NULL
expr_stmt|;
name|ktsp
operator|->
name|ks_index
operator|=
name|ktsp
operator|->
name|ks_start
expr_stmt|;
block|}
else|else
block|{
name|ktep
operator|=
operator|&
operator|(
name|ktp
operator|->
name|kt_entries
index|[
name|new_index
index|]
operator|)
expr_stmt|;
name|new_index
operator|++
expr_stmt|;
if|if
condition|(
name|new_index
operator|==
name|nentries
condition|)
block|{
name|ktsp
operator|->
name|ks_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ktsp
operator|->
name|ks_index
operator|=
name|new_index
expr_stmt|;
block|}
block|}
return|return
name|ktep
return|;
block|}
end_function

end_unit

