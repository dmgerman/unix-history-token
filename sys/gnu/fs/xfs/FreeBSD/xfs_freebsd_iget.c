begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  * Copyright (c) 2006 Russell Cattelan Digital Elves, Inc. All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_vnode.h"
end_include

begin_function_decl
specifier|static
name|int
name|xfs_vn_allocate
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_inode_t
modifier|*
parameter_list|,
name|struct
name|xfs_vnode
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Look up an inode by number in the given file system.  * The inode is looked up in the hash table for the file system  * represented by the mount point parameter mp.  Each bucket of  * the hash table is guarded by an individual semaphore.  *  * If the inode is found in the hash table, its corresponding vnode  * is obtained with a call to vn_get().  This call takes care of  * coordination with the reclamation of the inode and vnode.  Note  * that the vmap structure is filled in while holding the hash lock.  * This gives us the state of the inode/vnode when we found it and  * is used for coordination in vn_get().  *  * If it is not in core, read it in from the file system's device and  * add the inode into the hash table.  *  * The inode is locked according to the value of the lock_flags parameter.  * This flag parameter indicates how and if the inode's IO lock and inode lock  * should be taken.  *  * mp -- the mount point structure for the current file system.  It points  *       to the inode hash table.  * tp -- a pointer to the current transaction if there is one.  This is  *       simply passed through to the xfs_iread() call.  * ino -- the number of the inode desired.  This is the unique identifier  *        within the file system for the inode being requested.  * lock_flags -- flags indicating how to lock the inode.  See the comment  *		 for xfs_ilock() for a list of valid values.  * bno -- the block number starting the buffer containing the inode,  *	  if known (as by bulkstat), else 0.  */
end_comment

begin_function
name|int
name|xfs_iget
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|uint
name|flags
parameter_list|,
name|uint
name|lock_flags
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|,
name|xfs_daddr_t
name|bno
parameter_list|)
block|{
name|xfs_ihash_t
modifier|*
name|ih
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|iq
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|ulong
name|version
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* REFERENCED */
name|int
name|newnode
decl_stmt|;
name|xfs_chash_t
modifier|*
name|ch
decl_stmt|;
name|xfs_chashlist_t
modifier|*
name|chl
decl_stmt|,
modifier|*
name|chlnew
decl_stmt|;
name|vmap_t
name|vmap
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_attempts
argument_list|)
expr_stmt|;
name|ih
operator|=
name|XFS_IHASH
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|again
label|:
name|read_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ih
operator|->
name|ih_next
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|VMAP
argument_list|(
name|vp
argument_list|,
name|vmap
argument_list|)
expr_stmt|;
comment|/* 			 * Inode cache hit: if ip is not at the front of 			 * its hash chain, move it there now. 			 * Do this with the lock held for update, but 			 * do statistics after releasing the lock. 			 */
if|if
condition|(
name|ip
operator|->
name|i_prevp
operator|!=
operator|&
name|ih
operator|->
name|ih_next
operator|&&
name|rwlock_trypromote
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|iq
operator|=
name|ip
operator|->
name|i_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
name|ip
operator|->
name|i_prevp
expr_stmt|;
block|}
operator|*
name|ip
operator|->
name|i_prevp
operator|=
name|iq
expr_stmt|;
name|iq
operator|=
name|ih
operator|->
name|ih_next
expr_stmt|;
name|iq
operator|->
name|i_prevp
operator|=
operator|&
name|ip
operator|->
name|i_next
expr_stmt|;
name|ip
operator|->
name|i_next
operator|=
name|iq
expr_stmt|;
name|ip
operator|->
name|i_prevp
operator|=
operator|&
name|ih
operator|->
name|ih_next
expr_stmt|;
name|ih
operator|->
name|ih_next
operator|=
name|ip
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_ig_found
argument_list|)
expr_stmt|;
comment|/* 			 * Get a reference to the vnode/inode. 			 * vn_get() takes care of coordination with 			 * the file system inode release and reclaim 			 * functions.  If it returns NULL, the inode 			 * has been reclaimed so just start the search 			 * over again.  We probably won't find it, 			 * but we could be racing with another cpu 			 * looking for the same inode so we have to at 			 * least look. 			 */
if|if
condition|(
operator|!
operator|(
name|vp
operator|=
name|vn_get
argument_list|(
name|vp
argument_list|,
operator|&
name|vmap
argument_list|)
operator|)
condition|)
block|{
name|XFS_STATS_INC
argument_list|(
name|xs_ig_frecycle
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|XFS_IRECLAIM
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
name|newnode
operator|=
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|newnode
condition|)
block|{
name|xfs_iocore_inode_reinit
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|i_flags
operator|&=
operator|~
name|XFS_ISTALE
expr_stmt|;
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.found"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
goto|goto
name|return_ip
goto|;
block|}
block|}
comment|/* 	 * Inode cache miss: save the hash chain version stamp and unlock 	 * the chain, so we don't deadlock in vn_alloc. 	 */
name|XFS_STATS_INC
argument_list|(
name|xs_ig_missed
argument_list|)
expr_stmt|;
name|version
operator|=
name|ih
operator|->
name|ih_version
expr_stmt|;
name|read_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Read the disk inode attributes into a new inode structure and get 	 * a new vnode for it. This should also initialize i_ino and i_mount. 	 */
name|error
operator|=
name|xfs_iread
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
operator|&
name|ip
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|xfs_vn_allocate
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"xfs_iget.alloc"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|xfs_inode_lock_init
argument_list|(
name|ip
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|xfs_iocore_inode_init
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put ip on its hash chain, unless someone else hashed a duplicate 	 * after we released the hash lock. 	 */
name|write_lock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_version
operator|!=
name|version
condition|)
block|{
for|for
control|(
name|iq
operator|=
name|ih
operator|->
name|ih_next
init|;
name|iq
operator|!=
name|NULL
condition|;
name|iq
operator|=
name|iq
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|iq
operator|->
name|i_ino
operator|==
name|ino
condition|)
block|{
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
name|xfs_idestroy
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_ig_dup
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
comment|/* 	 * These values _must_ be set before releasing ihlock! 	 */
name|ip
operator|->
name|i_hash
operator|=
name|ih
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|ih
operator|->
name|ih_next
operator|)
condition|)
block|{
name|iq
operator|->
name|i_prevp
operator|=
operator|&
name|ip
operator|->
name|i_next
expr_stmt|;
block|}
name|ip
operator|->
name|i_next
operator|=
name|iq
expr_stmt|;
name|ip
operator|->
name|i_prevp
operator|=
operator|&
name|ih
operator|->
name|ih_next
expr_stmt|;
name|ih
operator|->
name|ih_next
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_udquot
operator|=
name|ip
operator|->
name|i_gdquot
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|ih_version
operator|++
expr_stmt|;
name|write_unlock
argument_list|(
operator|&
name|ih
operator|->
name|ih_lock
argument_list|)
expr_stmt|;
comment|/* 	 * put ip on its cluster's hash chain 	 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_chash
operator|==
name|NULL
operator|&&
name|ip
operator|->
name|i_cprev
operator|==
name|NULL
operator|&&
name|ip
operator|->
name|i_cnext
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|chlnew
operator|=
name|NULL
expr_stmt|;
name|ch
operator|=
name|XFS_CHASH
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_blkno
argument_list|)
expr_stmt|;
name|chlredo
label|:
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|chl
operator|=
name|ch
operator|->
name|ch_list
init|;
name|chl
operator|!=
name|NULL
condition|;
name|chl
operator|=
name|chl
operator|->
name|chl_next
control|)
block|{
if|if
condition|(
name|chl
operator|->
name|chl_blkno
operator|==
name|ip
operator|->
name|i_blkno
condition|)
block|{
comment|/* insert this inode into the doubly-linked list 			 * where chl points */
if|if
condition|(
operator|(
name|iq
operator|=
name|chl
operator|->
name|chl_ip
operator|)
condition|)
block|{
name|ip
operator|->
name|i_cprev
operator|=
name|iq
operator|->
name|i_cprev
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|iq
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cnext
operator|=
name|iq
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
block|}
name|chl
operator|->
name|chl_ip
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_chash
operator|=
name|chl
expr_stmt|;
break|break;
block|}
block|}
comment|/* no hash list found for this block; add a new hash list */
if|if
condition|(
name|chl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|chlnew
operator|==
name|NULL
condition|)
block|{
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_chashlist_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chlnew
operator|=
operator|(
name|xfs_chashlist_t
operator|*
operator|)
name|kmem_zone_alloc
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|chlnew
operator|!=
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|chlredo
goto|;
block|}
else|else
block|{
name|ip
operator|->
name|i_cnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_cprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_chash
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|->
name|chl_ip
operator|=
name|ip
expr_stmt|;
name|chlnew
operator|->
name|chl_blkno
operator|=
name|ip
operator|->
name|i_blkno
expr_stmt|;
name|chlnew
operator|->
name|chl_next
operator|=
name|ch
operator|->
name|ch_list
expr_stmt|;
name|ch
operator|->
name|ch_list
operator|=
name|chlnew
expr_stmt|;
name|chlnew
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chlnew
operator|!=
name|NULL
condition|)
block|{
name|kmem_zone_free
argument_list|(
name|xfs_chashlist_zone
argument_list|,
name|chlnew
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|ch
operator|->
name|ch_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Link ip to its mount and thread it on the mount's inode list. 	 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
name|mp
operator|->
name|m_inodes
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|iq
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|==
name|iq
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|=
name|iq
operator|->
name|i_mprev
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|->
name|i_mnext
operator|=
name|ip
expr_stmt|;
name|iq
operator|->
name|i_mprev
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_mnext
operator|=
name|iq
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_mnext
operator|=
name|ip
expr_stmt|;
name|ip
operator|->
name|i_mprev
operator|=
name|ip
expr_stmt|;
block|}
name|mp
operator|->
name|m_inodes
operator|=
name|ip
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|newnode
operator|=
literal|1
expr_stmt|;
name|return_ip
label|:
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_df
operator|.
name|if_ext_max
operator|==
name|XFS_IFORK_DSIZE
argument_list|(
name|ip
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xfs_bmbt_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
operator|(
name|ip
operator|->
name|i_iocore
operator|.
name|io_flags
operator|&
name|XFS_IOCORE_RT
operator|)
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
comment|/* 	 * If we have a real type for an on-disk inode, we can set ops(&unlock) 	 * now.	 If it's a new inode being created, xfs_ialloc will handle it. 	 */
name|XVFS_INIT_VNODE
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|XFS_ITOBHV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Special iput for brand-new inodes that are still locked  */
end_comment

begin_function
name|void
name|xfs_iput_new
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|vn_trace_entry
argument_list|(
name|vp
argument_list|,
literal|"xfs_iput_new"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xfs_iput_new: ip %p\n"
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_IRECLAIMABLE
operator|)
argument_list|)
expr_stmt|;
comment|//vn_mark_bad(vp);
name|printf
argument_list|(
literal|"xfs_iput_new: ip %p di_mode == 0\n"
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* mabe call vgone here? RMC */
block|}
if|if
condition|(
name|lock_flags
condition|)
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
operator|->
name|v_vnode
argument_list|,
literal|"xfs_iput_new"
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
operator|->
name|v_vnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|vop_vector
name|xfs_vnops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xfs_vn_allocate
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|struct
name|xfs_vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|xfs_vnode
modifier|*
name|vdata
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Use zone allocator here? */
name|vdata
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vdata
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"xfs"
argument_list|,
name|XVFSTOMNT
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
operator|&
name|xfs_vnops
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|vdata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vdata
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|->
name|v_vnlock
operator|->
name|lk_flags
operator||=
name|LK_CANRECURSE
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|XVFSTOMNT
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|vdata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vdata
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|->
name|v_data
operator|=
operator|(
name|void
operator|*
operator|)
name|vdata
expr_stmt|;
name|vdata
operator|->
name|v_number
operator|=
literal|0
expr_stmt|;
name|vdata
operator|->
name|v_inode
operator|=
name|ip
expr_stmt|;
name|vdata
operator|->
name|v_vfsp
operator|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vdata
operator|->
name|v_vnode
operator|=
name|vp
expr_stmt|;
name|vn_bhv_head_init
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vdata
argument_list|)
argument_list|,
literal|"vnode"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_XFS_VNODE_TRACING
name|vp
operator|->
name|v_trace
operator|=
name|ktrace_alloc
argument_list|(
name|VNODE_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_XFS_VNODE_TRACING */
name|vn_trace_exit
argument_list|(
name|vp
argument_list|,
literal|"vn_initialize"
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|vdata
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

