begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_comment
comment|/*  * xfs_get_dir_entry is used to get a reference to an inode given  * its parent directory inode and the name of the file.	 It does  * not lock the child inode, and it unlocks the directory before  * returning.  The directory's generation number is returned for  * use by a later call to xfs_lock_dir_and_entry.  */
end_comment

begin_function
name|int
name|xfs_get_dir_entry
parameter_list|(
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|bhv_desc_t
modifier|*
name|bdp
decl_stmt|;
name|vp
operator|=
name|VNAME_TO_VNODE
argument_list|(
name|dentry
argument_list|)
expr_stmt|;
name|bdp
operator|=
name|vn_bhv_lookup_unlocked
argument_list|(
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|xfs_vnodeops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bdp
condition|)
block|{
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xfs_dir_lookup_int
parameter_list|(
name|bhv_desc_t
modifier|*
name|dir_bdp
parameter_list|,
name|uint
name|lock_mode
parameter_list|,
name|vname_t
modifier|*
name|dentry
parameter_list|,
name|xfs_ino_t
modifier|*
name|inum
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|dir_vp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dir_vp
operator|=
name|BHV_TO_VNODE
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|vn_trace_entry
argument_list|(
name|dir_vp
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
expr_stmt|;
name|dp
operator|=
name|XFS_BHVTOI
argument_list|(
name|dir_bdp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_DIR_LOOKUP
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
name|VNAME
argument_list|(
name|dentry
argument_list|)
argument_list|,
name|VNAMELEN
argument_list|(
name|dentry
argument_list|)
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Unlock the directory. We do this because we can't 		 * hold the directory lock while doing the vn_get() 		 * in xfs_iget().  Doing so could cause us to hold 		 * a lock while waiting for the inode to finish 		 * being inactive while it's waiting for a log 		 * reservation in the inactive routine. 		 */
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|NULL
argument_list|,
operator|*
name|inum
argument_list|,
literal|0
argument_list|,
name|ipp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|ipp
operator|)
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The inode has been freed.  Something is 			 * wrong so just get out of here. 			 */
name|xfs_iunlock
argument_list|(
name|dp
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|xfs_iput_new
argument_list|(
operator|*
name|ipp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
name|xfs_ilock
argument_list|(
name|dp
argument_list|,
name|lock_mode
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates a new inode from disk and return a pointer to the  * incore copy. This routine will internally commit the current  * transaction and allocate a new one if the Space Manager needed  * to do an allocation to replenish the inode free-list.  *  * This routine is designed to be called from xfs_create and  * xfs_create_dir.  *  */
end_comment

begin_function
name|int
name|xfs_dir_ialloc
parameter_list|(
name|xfs_trans_t
modifier|*
modifier|*
name|tpp
parameter_list|,
comment|/* input: current transaction; 					   output: may be a new transaction. */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* directory within whose allocate 					   the inode. */
name|mode_t
name|mode
parameter_list|,
name|nlink_t
name|nlink
parameter_list|,
name|xfs_dev_t
name|rdev
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|,
name|prid_t
name|prid
parameter_list|,
comment|/* project id */
name|int
name|okalloc
parameter_list|,
comment|/* ok to allocate new space */
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|,
comment|/* pointer to inode; it will be 					   locked. */
name|int
modifier|*
name|committed
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|ntp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|ialloc_context
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|call_again
init|=
name|B_FALSE
decl_stmt|;
name|int
name|code
decl_stmt|;
name|uint
name|log_res
decl_stmt|;
name|uint
name|log_count
decl_stmt|;
name|void
modifier|*
name|dqinfo
decl_stmt|;
name|uint
name|tflags
decl_stmt|;
name|tp
operator|=
operator|*
name|tpp
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
argument_list|)
expr_stmt|;
comment|/* 	 * xfs_ialloc will return a pointer to an incore inode if 	 * the Space Manager has an available inode on the free 	 * list. Otherwise, it will do an allocation and replenish 	 * the freelist.  Since we can only do one allocation per 	 * transaction without deadlocks, we will need to commit the 	 * current transaction and start a new one.  We will then 	 * need to call xfs_ialloc again to get the inode. 	 * 	 * If xfs_ialloc did an allocation to replenish the freelist, 	 * it returns the bp containing the head of the freelist as 	 * ialloc_context. We will hold a lock on it across the 	 * transaction commit so that no other process can steal 	 * the inode(s) that we've just allocated. 	 */
name|code
operator|=
name|xfs_ialloc
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|mode
argument_list|,
name|nlink
argument_list|,
name|rdev
argument_list|,
name|credp
argument_list|,
name|prid
argument_list|,
name|okalloc
argument_list|,
operator|&
name|ialloc_context
argument_list|,
operator|&
name|call_again
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Return an error if we were unable to allocate a new inode. 	 * This should only happen if we run out of space on disk or 	 * encounter a disk error. 	 */
if|if
condition|(
name|code
condition|)
block|{
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
name|code
return|;
block|}
if|if
condition|(
operator|!
name|call_again
operator|&&
operator|(
name|ip
operator|==
name|NULL
operator|)
condition|)
block|{
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* 	 * If call_again is set, then we were unable to get an 	 * inode in one operation.  We need to commit the current 	 * transaction and call xfs_ialloc() again.  It is guaranteed 	 * to succeed the second time. 	 */
if|if
condition|(
name|call_again
condition|)
block|{
comment|/* 		 * Normally, xfs_trans_commit releases all the locks. 		 * We call bhold to hang on to the ialloc_context across 		 * the commit.  Holding this buffer prevents any other 		 * processes from doing any allocations in this 		 * allocation group. 		 */
name|xfs_trans_bhold
argument_list|(
name|tp
argument_list|,
name|ialloc_context
argument_list|)
expr_stmt|;
comment|/* 		 * Save the log reservation so we can use 		 * them in the next transaction. 		 */
name|log_res
operator|=
name|xfs_trans_get_log_res
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|log_count
operator|=
name|xfs_trans_get_log_count
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * We want the quota changes to be associated with the next 		 * transaction, NOT this one. So, detach the dqinfo from this 		 * and attach it to the next transaction. 		 */
name|dqinfo
operator|=
name|NULL
expr_stmt|;
name|tflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_dqinfo
condition|)
block|{
name|dqinfo
operator|=
operator|(
name|void
operator|*
operator|)
name|tp
operator|->
name|t_dqinfo
expr_stmt|;
name|tp
operator|->
name|t_dqinfo
operator|=
name|NULL
expr_stmt|;
name|tflags
operator|=
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DQ_DIRTY
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
operator|(
name|XFS_TRANS_DQ_DIRTY
operator|)
expr_stmt|;
block|}
name|ntp
operator|=
name|xfs_trans_dup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|code
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|ntp
expr_stmt|;
if|if
condition|(
name|committed
operator|!=
name|NULL
condition|)
block|{
operator|*
name|committed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If we get an error during the commit processing, 		 * release the buffer that is still held and return 		 * to the caller. 		 */
if|if
condition|(
name|code
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|ialloc_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|dqinfo
condition|)
block|{
name|tp
operator|->
name|t_dqinfo
operator|=
name|dqinfo
expr_stmt|;
name|XFS_TRANS_FREE_DQINFO
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
operator|*
name|tpp
operator|=
name|ntp
expr_stmt|;
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
name|code
return|;
block|}
name|code
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|log_res
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|log_count
argument_list|)
expr_stmt|;
comment|/* 		 * Re-attach the quota info that we detached from prev trx. 		 */
if|if
condition|(
name|dqinfo
condition|)
block|{
name|tp
operator|->
name|t_dqinfo
operator|=
name|dqinfo
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|tflags
expr_stmt|;
block|}
if|if
condition|(
name|code
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|ialloc_context
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|ntp
expr_stmt|;
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
name|code
return|;
block|}
name|xfs_trans_bjoin
argument_list|(
name|tp
argument_list|,
name|ialloc_context
argument_list|)
expr_stmt|;
comment|/* 		 * Call ialloc again. Since we've locked out all 		 * other allocations in this allocation group, 		 * this call should always succeed. 		 */
name|code
operator|=
name|xfs_ialloc
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|mode
argument_list|,
name|nlink
argument_list|,
name|rdev
argument_list|,
name|credp
argument_list|,
name|prid
argument_list|,
name|okalloc
argument_list|,
operator|&
name|ialloc_context
argument_list|,
operator|&
name|call_again
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * If we get an error at this point, return to the caller 		 * so that the current transaction can be aborted. 		 */
if|if
condition|(
name|code
condition|)
block|{
operator|*
name|tpp
operator|=
name|tp
expr_stmt|;
operator|*
name|ipp
operator|=
name|NULL
expr_stmt|;
return|return
name|code
return|;
block|}
name|ASSERT
argument_list|(
operator|(
operator|!
name|call_again
operator|)
operator|&&
operator|(
name|ip
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|committed
operator|!=
name|NULL
condition|)
block|{
operator|*
name|committed
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
operator|*
name|tpp
operator|=
name|tp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Decrement the link count on an inode& log the change.  * If this causes the link count to go to zero, initiate the  * logging activity required to truncate a file.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_droplink
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|--
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're dropping the last link to this file. 		 * Move the on-disk inode to the AGI unlinked list. 		 * From xfs_inactive() we will pull the inode from 		 * the list and free it. 		 */
name|error
operator|=
name|xfs_iunlink
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This gets called when the inode's version needs to be changed from 1 to 2.  * Currently this happens when the nlink field overflows the old 16-bit value  * or when chproj is called to change the project for the first time.  * As a side effect the superblock version will also get rev'd  * to contain the NLINK bit.  */
end_comment

begin_function
name|void
name|xfs_bump_ino_vers2
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|unsigned
name|long
name|s
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|=
name|XFS_DINODE_VERSION_2
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_onlink
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_pad
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|XFS_SB_VERSION_ADDNLINK
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
expr_stmt|;
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_SB_VERSIONNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Caller must log the inode */
block|}
end_function

begin_comment
comment|/*  * Increment the link count on an inode& log the change.  */
end_comment

begin_function
name|int
name|xfs_bumplink
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|>=
name|XFS_MAXLINK
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EMLINK
argument_list|)
return|;
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_version
operator|==
name|XFS_DINODE_VERSION_1
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|>
name|XFS_MAXLINK_1
operator|)
condition|)
block|{
comment|/* 		 * The inode has increased its number of links beyond 		 * what can fit in an old format inode.  It now needs 		 * to be converted to a version 2 inode with a 32 bit 		 * link count.  If this is the first inode in the file 		 * system to do this, then we need to bump the superblock 		 * version number as well. 		 */
name|xfs_bump_ino_vers2
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Try to truncate the given file to 0 length.  Currently called  * only out of xfs_remove when it has to truncate a file to free  * up space for the remove to proceed.  */
end_comment

begin_function
name|int
name|xfs_truncate_file
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|QUOTADEBUG
comment|/* 	 * This is called to truncate the quotainodes too. 	 */
if|if
condition|(
name|XFS_IS_UQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_uquotino
condition|)
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_udquot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XFS_IS_GQUOTA_ON
argument_list|(
name|mp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_gquotino
condition|)
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_gdquot
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Make the call to xfs_itruncate_start before starting the 	 * transaction, because we cannot make the call while we're 	 * in a transaction. 	 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_itruncate_start
argument_list|(
name|ip
argument_list|,
name|XFS_ITRUNC_DEFINITE
argument_list|,
operator|(
name|xfs_fsize_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_TRUNCATE_FILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_ITRUNCATE_LOG_COUNT
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Follow the normal truncate locking protocol.  Since we 	 * hold the inode in the transaction, we know that it's number 	 * of references will stay constant. 	 */
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * Signal a sync xaction.  The only case where that isn't 	 * the case is if we're truncating an already unlinked file 	 * on a wsync fs.  In that case, we know the blocks can't 	 * reappear in the file because the links to file are 	 * permanently toast.  Currently, we're always going to 	 * want a sync transaction because this code is being 	 * called from places where nlink is guaranteed to be 1 	 * but I'm leaving the tests in to protect against future 	 * changes -- rcc. 	 */
name|error
operator|=
name|xfs_itruncate_finish
argument_list|(
operator|&
name|tp
argument_list|,
name|ip
argument_list|,
operator|(
name|xfs_fsize_t
operator|)
literal|0
argument_list|,
name|XFS_DATA_FORK
argument_list|,
operator|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|!=
literal|0
operator|||
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_ichgtime
argument_list|(
name|ip
argument_list|,
name|XFS_ICHGTIME_MOD
operator||
name|XFS_ICHGTIME_CHG
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

