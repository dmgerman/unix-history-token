begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * Cursor allocation zone.  */
end_comment

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_btree_cur_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Btree magic numbers.  */
end_comment

begin_decl_stmt
specifier|const
name|__uint32_t
name|xfs_magics
index|[
name|XFS_BTNUM_MAX
index|]
init|=
block|{
name|XFS_ABTB_MAGIC
block|,
name|XFS_ABTC_MAGIC
block|,
name|XFS_BMAP_MAGIC
block|,
name|XFS_IBT_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for internal routines.  */
end_comment

begin_comment
comment|/*  * Checking routine: return maxrecs for the block.  */
end_comment

begin_function_decl
name|STATIC
name|int
comment|/* number of records fitting in block */
name|xfs_btree_maxrecs
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_btree_block_t
modifier|*
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* generic btree block pointer */
end_comment

begin_comment
comment|/*  * Internal routines.  */
end_comment

begin_comment
comment|/*  * Retrieve the block pointer from the cursor at the given level.  * This may be a bmap btree root or from a buffer.  */
end_comment

begin_function_decl
name|STATIC
name|xfs_btree_block_t
modifier|*
comment|/* generic btree block pointer */
name|xfs_btree_get_block
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level in btree */
name|struct
name|xfs_buf
modifier|*
modifier|*
name|bpp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* buffer containing the block */
end_comment

begin_comment
comment|/*  * Checking routine: return maxrecs for the block.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* number of records fitting in block */
name|xfs_btree_maxrecs
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_btree_block_t
modifier|*
name|block
parameter_list|)
comment|/* generic btree block pointer */
block|{
switch|switch
condition|(
name|cur
operator|->
name|bc_btnum
condition|)
block|{
case|case
name|XFS_BTNUM_BNO
case|:
case|case
name|XFS_BTNUM_CNT
case|:
return|return
operator|(
name|int
operator|)
name|XFS_ALLOC_BLOCK_MAXRECS
argument_list|(
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_h
operator|.
name|bb_level
argument_list|)
argument_list|,
name|cur
argument_list|)
return|;
case|case
name|XFS_BTNUM_BMAP
case|:
return|return
operator|(
name|int
operator|)
name|XFS_BMAP_BLOCK_IMAXRECS
argument_list|(
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_h
operator|.
name|bb_level
argument_list|)
argument_list|,
name|cur
argument_list|)
return|;
case|case
name|XFS_BTNUM_INO
case|:
return|return
operator|(
name|int
operator|)
name|XFS_INOBT_BLOCK_MAXRECS
argument_list|(
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_h
operator|.
name|bb_level
argument_list|)
argument_list|,
name|cur
argument_list|)
return|;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * External routines.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Debug routine: check that block header is ok.  */
end_comment

begin_function
name|void
name|xfs_btree_check_block
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_btree_block_t
modifier|*
name|block
parameter_list|,
comment|/* generic btree block pointer */
name|int
name|level
parameter_list|,
comment|/* level of the btree block */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
comment|/* buffer containing block, if any */
block|{
if|if
condition|(
name|XFS_BTREE_LONG_PTRS
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|)
condition|)
name|xfs_btree_check_lblock
argument_list|(
name|cur
argument_list|,
operator|(
name|xfs_btree_lblock_t
operator|*
operator|)
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|xfs_btree_check_sblock
argument_list|(
name|cur
argument_list|,
operator|(
name|xfs_btree_sblock_t
operator|*
operator|)
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debug routine: check that keys are in the right order.  */
end_comment

begin_function
name|void
name|xfs_btree_check_key
parameter_list|(
name|xfs_btnum_t
name|btnum
parameter_list|,
comment|/* btree identifier */
name|void
modifier|*
name|ak1
parameter_list|,
comment|/* pointer to left (lower) key */
name|void
modifier|*
name|ak2
parameter_list|)
comment|/* pointer to right (higher) key */
block|{
switch|switch
condition|(
name|btnum
condition|)
block|{
case|case
name|XFS_BTNUM_BNO
case|:
block|{
name|xfs_alloc_key_t
modifier|*
name|k1
decl_stmt|;
name|xfs_alloc_key_t
modifier|*
name|k2
decl_stmt|;
name|k1
operator|=
name|ak1
expr_stmt|;
name|k2
operator|=
name|ak2
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|k1
operator|->
name|ar_startblock
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|k2
operator|->
name|ar_startblock
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_BTNUM_CNT
case|:
block|{
name|xfs_alloc_key_t
modifier|*
name|k1
decl_stmt|;
name|xfs_alloc_key_t
modifier|*
name|k2
decl_stmt|;
name|k1
operator|=
name|ak1
expr_stmt|;
name|k2
operator|=
name|ak2
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|k1
operator|->
name|ar_blockcount
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|k2
operator|->
name|ar_blockcount
argument_list|)
operator|||
operator|(
name|k1
operator|->
name|ar_blockcount
operator|==
name|k2
operator|->
name|ar_blockcount
operator|&&
name|be32_to_cpu
argument_list|(
name|k1
operator|->
name|ar_startblock
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|k2
operator|->
name|ar_startblock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_BTNUM_BMAP
case|:
block|{
name|xfs_bmbt_key_t
modifier|*
name|k1
decl_stmt|;
name|xfs_bmbt_key_t
modifier|*
name|k2
decl_stmt|;
name|k1
operator|=
name|ak1
expr_stmt|;
name|k2
operator|=
name|ak2
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|k1
operator|->
name|br_startoff
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|k2
operator|->
name|br_startoff
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_BTNUM_INO
case|:
block|{
name|xfs_inobt_key_t
modifier|*
name|k1
decl_stmt|;
name|xfs_inobt_key_t
modifier|*
name|k2
decl_stmt|;
name|k1
operator|=
name|ak1
expr_stmt|;
name|k2
operator|=
name|ak2
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|k1
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|k2
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Checking routine: check that long form block header is ok.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
comment|/* error (0 or EFSCORRUPTED) */
name|xfs_btree_check_lblock
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_btree_lblock_t
modifier|*
name|block
parameter_list|,
comment|/* btree long form block pointer */
name|int
name|level
parameter_list|,
comment|/* level of the btree block */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
comment|/* buffer for block, if any */
block|{
name|int
name|lblock_ok
decl_stmt|;
comment|/* block passes checks */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount point */
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
name|lblock_ok
operator|=
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_magic
argument_list|)
operator|==
name|xfs_magics
index|[
name|cur
operator|->
name|bc_btnum
index|]
operator|&&
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_level
argument_list|)
operator|==
name|level
operator|&&
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|<=
name|xfs_btree_maxrecs
argument_list|(
name|cur
argument_list|,
operator|(
name|xfs_btree_block_t
operator|*
operator|)
name|block
argument_list|)
operator|&&
name|block
operator|->
name|bb_leftsib
operator|&&
operator|(
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_leftsib
argument_list|)
operator|==
name|NULLDFSBNO
operator|||
name|XFS_FSB_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_leftsib
argument_list|)
argument_list|)
operator|)
operator|&&
name|block
operator|->
name|bb_rightsib
operator|&&
operator|(
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
operator|==
name|NULLDFSBNO
operator|||
name|XFS_FSB_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|lblock_ok
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_BTREE_CHECK_LBLOCK
argument_list|,
name|XFS_RANDOM_BTREE_CHECK_LBLOCK
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
condition|)
name|xfs_buftrace
argument_list|(
literal|"LBTREE ERROR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_btree_check_lblock"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Checking routine: check that (long) pointer is ok.  */
end_comment

begin_function
name|int
comment|/* error (0 or EFSCORRUPTED) */
name|xfs_btree_check_lptr
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_dfsbno_t
name|ptr
parameter_list|,
comment|/* btree block disk address */
name|int
name|level
parameter_list|)
comment|/* btree block level */
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount point */
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|level
operator|>
literal|0
operator|&&
name|ptr
operator|!=
name|NULLDFSBNO
operator|&&
name|XFS_FSB_SANITY_CHECK
argument_list|(
name|mp
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Debug routine: check that records are in the right order.  */
end_comment

begin_function
name|void
name|xfs_btree_check_rec
parameter_list|(
name|xfs_btnum_t
name|btnum
parameter_list|,
comment|/* btree identifier */
name|void
modifier|*
name|ar1
parameter_list|,
comment|/* pointer to left (lower) record */
name|void
modifier|*
name|ar2
parameter_list|)
comment|/* pointer to right (higher) record */
block|{
switch|switch
condition|(
name|btnum
condition|)
block|{
case|case
name|XFS_BTNUM_BNO
case|:
block|{
name|xfs_alloc_rec_t
modifier|*
name|r1
decl_stmt|;
name|xfs_alloc_rec_t
modifier|*
name|r2
decl_stmt|;
name|r1
operator|=
name|ar1
expr_stmt|;
name|r2
operator|=
name|ar2
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|r1
operator|->
name|ar_startblock
argument_list|)
operator|+
name|be32_to_cpu
argument_list|(
name|r1
operator|->
name|ar_blockcount
argument_list|)
operator|<=
name|be32_to_cpu
argument_list|(
name|r2
operator|->
name|ar_startblock
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_BTNUM_CNT
case|:
block|{
name|xfs_alloc_rec_t
modifier|*
name|r1
decl_stmt|;
name|xfs_alloc_rec_t
modifier|*
name|r2
decl_stmt|;
name|r1
operator|=
name|ar1
expr_stmt|;
name|r2
operator|=
name|ar2
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|r1
operator|->
name|ar_blockcount
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|r2
operator|->
name|ar_blockcount
argument_list|)
operator|||
operator|(
name|r1
operator|->
name|ar_blockcount
operator|==
name|r2
operator|->
name|ar_blockcount
operator|&&
name|be32_to_cpu
argument_list|(
name|r1
operator|->
name|ar_startblock
argument_list|)
operator|<
name|be32_to_cpu
argument_list|(
name|r2
operator|->
name|ar_startblock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_BTNUM_BMAP
case|:
block|{
name|xfs_bmbt_rec_t
modifier|*
name|r1
decl_stmt|;
name|xfs_bmbt_rec_t
modifier|*
name|r2
decl_stmt|;
name|r1
operator|=
name|ar1
expr_stmt|;
name|r2
operator|=
name|ar2
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_bmbt_disk_get_startoff
argument_list|(
name|r1
argument_list|)
operator|+
name|xfs_bmbt_disk_get_blockcount
argument_list|(
name|r1
argument_list|)
operator|<=
name|xfs_bmbt_disk_get_startoff
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_BTNUM_INO
case|:
block|{
name|xfs_inobt_rec_t
modifier|*
name|r1
decl_stmt|;
name|xfs_inobt_rec_t
modifier|*
name|r2
decl_stmt|;
name|r1
operator|=
name|ar1
expr_stmt|;
name|r2
operator|=
name|ar2
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|r1
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|XFS_INODES_PER_CHUNK
operator|<=
name|INT_GET
argument_list|(
name|r2
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Checking routine: check that block header is ok.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
comment|/* error (0 or EFSCORRUPTED) */
name|xfs_btree_check_sblock
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_btree_sblock_t
modifier|*
name|block
parameter_list|,
comment|/* btree short form block pointer */
name|int
name|level
parameter_list|,
comment|/* level of the btree block */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
comment|/* buffer containing block */
block|{
name|xfs_buf_t
modifier|*
name|agbp
decl_stmt|;
comment|/* buffer for ag. freespace struct */
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* ag. freespace structure */
name|xfs_agblock_t
name|agflen
decl_stmt|;
comment|/* native ag. freespace length */
name|int
name|sblock_ok
decl_stmt|;
comment|/* block passes checks */
name|agbp
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agbp
expr_stmt|;
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|agflen
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
expr_stmt|;
name|sblock_ok
operator|=
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_magic
argument_list|)
operator|==
name|xfs_magics
index|[
name|cur
operator|->
name|bc_btnum
index|]
operator|&&
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_level
argument_list|)
operator|==
name|level
operator|&&
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_numrecs
argument_list|)
operator|<=
name|xfs_btree_maxrecs
argument_list|(
name|cur
argument_list|,
operator|(
name|xfs_btree_block_t
operator|*
operator|)
name|block
argument_list|)
operator|&&
operator|(
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_leftsib
argument_list|)
operator|==
name|NULLAGBLOCK
operator|||
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_leftsib
argument_list|)
operator|<
name|agflen
operator|)
operator|&&
name|block
operator|->
name|bb_leftsib
operator|&&
operator|(
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
operator|==
name|NULLAGBLOCK
operator|||
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_rightsib
argument_list|)
operator|<
name|agflen
operator|)
operator|&&
name|block
operator|->
name|bb_rightsib
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|!
name|sblock_ok
argument_list|,
name|cur
operator|->
name|bc_mp
argument_list|,
name|XFS_ERRTAG_BTREE_CHECK_SBLOCK
argument_list|,
name|XFS_RANDOM_BTREE_CHECK_SBLOCK
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
condition|)
name|xfs_buftrace
argument_list|(
literal|"SBTREE ERROR"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_btree_check_sblock"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|cur
operator|->
name|bc_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Checking routine: check that (short) pointer is ok.  */
end_comment

begin_function
name|int
comment|/* error (0 or EFSCORRUPTED) */
name|xfs_btree_check_sptr
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|xfs_agblock_t
name|ptr
parameter_list|,
comment|/* btree block disk address */
name|int
name|level
parameter_list|)
comment|/* btree block level */
block|{
name|xfs_buf_t
modifier|*
name|agbp
decl_stmt|;
comment|/* buffer for ag. freespace struct */
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* ag. freespace structure */
name|agbp
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agbp
expr_stmt|;
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|XFS_WANT_CORRUPTED_RETURN
argument_list|(
name|level
operator|>
literal|0
operator|&&
name|ptr
operator|!=
name|NULLAGBLOCK
operator|&&
name|ptr
operator|!=
literal|0
operator|&&
name|ptr
operator|<
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_length
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the btree cursor.  */
end_comment

begin_function
name|void
name|xfs_btree_del_cursor
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|error
parameter_list|)
comment|/* del because of error */
block|{
name|int
name|i
decl_stmt|;
comment|/* btree level */
comment|/* 	 * Clear the buffer pointers, and release the buffers. 	 * If we're doing this in the face of an error, we 	 * need to make sure to inspect all of the entries 	 * in the bc_bufs array for buffers to be unlocked. 	 * This is because some of the btree code works from 	 * level n down to 0, and if we get an error along 	 * the way we won't have initialized all the entries 	 * down to 0. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur
operator|->
name|bc_nlevels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|bc_bufs
index|[
name|i
index|]
condition|)
name|xfs_btree_setbuf
argument_list|(
name|cur
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
break|break;
block|}
comment|/* 	 * Can't free a bmap cursor without having dealt with the 	 * allocated indirect blocks' accounting. 	 */
name|ASSERT
argument_list|(
name|cur
operator|->
name|bc_btnum
operator|!=
name|XFS_BTNUM_BMAP
operator|||
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Free the cursor. 	 */
name|kmem_zone_free
argument_list|(
name|xfs_btree_cur_zone
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Duplicate the btree cursor.  * Allocate a new one, copy the record, re-get the buffers.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_btree_dup_cursor
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* input cursor */
name|xfs_btree_cur_t
modifier|*
modifier|*
name|ncur
parameter_list|)
comment|/* output cursor */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* btree block's buffer pointer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* level number of btree block */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* mount structure for filesystem */
name|xfs_btree_cur_t
modifier|*
name|new
decl_stmt|;
comment|/* new cursor value */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer, can be NULL */
name|tp
operator|=
name|cur
operator|->
name|bc_tp
expr_stmt|;
name|mp
operator|=
name|cur
operator|->
name|bc_mp
expr_stmt|;
comment|/* 	 * Allocate a new cursor like the old one. 	 */
name|new
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agbp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agno
argument_list|,
name|cur
operator|->
name|bc_btnum
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|ip
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|whichfork
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the record currently in the cursor. 	 */
name|new
operator|->
name|bc_rec
operator|=
name|cur
operator|->
name|bc_rec
expr_stmt|;
comment|/* 	 * For each level current, re-get the buffer and copy the ptr value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new
operator|->
name|bc_nlevels
condition|;
name|i
operator|++
control|)
block|{
name|new
operator|->
name|bc_ptrs
index|[
name|i
index|]
operator|=
name|cur
operator|->
name|bc_ptrs
index|[
name|i
index|]
expr_stmt|;
name|new
operator|->
name|bc_ra
index|[
name|i
index|]
operator|=
name|cur
operator|->
name|bc_ra
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|i
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|new
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|*
name|ncur
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|new
operator|->
name|bc_bufs
index|[
name|i
index|]
operator|=
name|bp
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|->
name|bc_bufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * For bmap btrees, copy the firstblock, flist, and flags values, 	 * since init cursor doesn't get them. 	 */
if|if
condition|(
name|new
operator|->
name|bc_btnum
operator|==
name|XFS_BTNUM_BMAP
condition|)
block|{
name|new
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
expr_stmt|;
name|new
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
expr_stmt|;
name|new
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
expr_stmt|;
block|}
operator|*
name|ncur
operator|=
name|new
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Change the cursor to point to the first record at the given level.  * Other levels are unaffected.  */
end_comment

begin_function
name|int
comment|/* success=1, failure=0 */
name|xfs_btree_firstrec
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|)
comment|/* level to change */
block|{
name|xfs_btree_block_t
modifier|*
name|block
decl_stmt|;
comment|/* generic btree block pointer */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing block */
comment|/* 	 * Get the block pointer for this level. 	 */
name|block
operator|=
name|xfs_btree_get_block
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|xfs_btree_check_block
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * It's empty, there is no such record. 	 */
if|if
condition|(
operator|!
name|block
operator|->
name|bb_h
operator|.
name|bb_numrecs
condition|)
return|return
literal|0
return|;
comment|/* 	 * Set the ptr value to 1, that's the first record/key. 	 */
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the block pointer from the cursor at the given level.  * This may be a bmap btree root or from a buffer.  */
end_comment

begin_function
name|STATIC
name|xfs_btree_block_t
modifier|*
comment|/* generic btree block pointer */
name|xfs_btree_get_block
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|,
comment|/* level in btree */
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
comment|/* buffer containing the block */
block|{
name|xfs_btree_block_t
modifier|*
name|block
decl_stmt|;
comment|/* return value */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* return buffer */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* inode fork pointer */
name|int
name|whichfork
decl_stmt|;
comment|/* data or attr fork */
if|if
condition|(
name|cur
operator|->
name|bc_btnum
operator|==
name|XFS_BTNUM_BMAP
operator|&&
name|level
operator|==
name|cur
operator|->
name|bc_nlevels
operator|-
literal|1
condition|)
block|{
name|whichfork
operator|=
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|whichfork
expr_stmt|;
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|block
operator|=
operator|(
name|xfs_btree_block_t
operator|*
operator|)
name|ifp
operator|->
name|if_broot
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|level
index|]
expr_stmt|;
name|block
operator|=
name|XFS_BUF_TO_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|block
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the block, return it with no data read.  * Long-form addressing.  */
end_comment

begin_function
name|xfs_buf_t
modifier|*
comment|/* buffer for fsbno */
name|xfs_btree_get_bufl
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_fsblock_t
name|fsbno
parameter_list|,
comment|/* file system block number */
name|uint
name|lock
parameter_list|)
comment|/* lock flags for get_buf */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer pointer (return value) */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* real disk block address */
name|ASSERT
argument_list|(
name|fsbno
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|fsbno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the block, return it with no data read.  * Short-form addressing.  */
end_comment

begin_function
name|xfs_buf_t
modifier|*
comment|/* buffer for agno/agbno */
name|xfs_btree_get_bufs
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_agblock_t
name|agbno
parameter_list|,
comment|/* allocation group block number */
name|uint
name|lock
parameter_list|)
comment|/* lock flags for get_buf */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer pointer (return value) */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* real disk block address */
name|ASSERT
argument_list|(
name|agno
operator|!=
name|NULLAGNUMBER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agbno
operator|!=
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
name|d
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new btree cursor.  * The cursor is either for allocation (A) or bmap (B) or inodes (I).  */
end_comment

begin_function
name|xfs_btree_cur_t
modifier|*
comment|/* new btree cursor */
name|xfs_btree_init_cursor
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_buf_t
modifier|*
name|agbp
parameter_list|,
comment|/* (A only) buffer for agf structure */
comment|/* (I only) buffer for agi structure */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* (AI only) allocation group number */
name|xfs_btnum_t
name|btnum
parameter_list|,
comment|/* btree identifier */
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
comment|/* (B only) inode owning the btree */
name|int
name|whichfork
parameter_list|)
comment|/* (B only) data or attr fork */
block|{
name|xfs_agf_t
modifier|*
name|agf
decl_stmt|;
comment|/* (A) allocation group freespace */
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
comment|/* (I) allocation group inodespace */
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* return value */
name|xfs_ifork_t
modifier|*
name|ifp
decl_stmt|;
comment|/* (I) inode fork pointer */
name|int
name|nlevels
init|=
literal|0
decl_stmt|;
comment|/* number of levels in the btree */
name|ASSERT
argument_list|(
name|xfs_btree_cur_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a new cursor. 	 */
name|cur
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_btree_cur_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Deduce the number of btree levels from the arguments. 	 */
switch|switch
condition|(
name|btnum
condition|)
block|{
case|case
name|XFS_BTNUM_BNO
case|:
case|case
name|XFS_BTNUM_CNT
case|:
name|agf
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|nlevels
operator|=
name|be32_to_cpu
argument_list|(
name|agf
operator|->
name|agf_levels
index|[
name|btnum
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_BTNUM_BMAP
case|:
name|ifp
operator|=
name|XFS_IFORK_PTR
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|nlevels
operator|=
name|be16_to_cpu
argument_list|(
name|ifp
operator|->
name|if_broot
operator|->
name|bb_level
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|XFS_BTNUM_INO
case|:
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|nlevels
operator|=
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_level
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the common fields. 	 */
name|cur
operator|->
name|bc_tp
operator|=
name|tp
expr_stmt|;
name|cur
operator|->
name|bc_mp
operator|=
name|mp
expr_stmt|;
name|cur
operator|->
name|bc_nlevels
operator|=
name|nlevels
expr_stmt|;
name|cur
operator|->
name|bc_btnum
operator|=
name|btnum
expr_stmt|;
name|cur
operator|->
name|bc_blocklog
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
comment|/* 	 * Fill in private fields. 	 */
switch|switch
condition|(
name|btnum
condition|)
block|{
case|case
name|XFS_BTNUM_BNO
case|:
case|case
name|XFS_BTNUM_CNT
case|:
comment|/* 		 * Allocation btree fields. 		 */
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agbp
operator|=
name|agbp
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agno
operator|=
name|agno
expr_stmt|;
break|break;
case|case
name|XFS_BTNUM_BMAP
case|:
comment|/* 		 * Bmap btree fields. 		 */
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|forksize
operator|=
name|XFS_IFORK_SIZE
argument_list|(
name|ip
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|ip
operator|=
name|ip
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|firstblock
operator|=
name|NULLFSBLOCK
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flist
operator|=
name|NULL
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|b
operator|.
name|whichfork
operator|=
name|whichfork
expr_stmt|;
break|break;
case|case
name|XFS_BTNUM_INO
case|:
comment|/* 		 * Inode allocation btree fields. 		 */
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agbp
operator|=
name|agbp
expr_stmt|;
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
operator|=
name|agno
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|cur
return|;
block|}
end_function

begin_comment
comment|/*  * Check for the cursor referring to the last block at the given level.  */
end_comment

begin_function
name|int
comment|/* 1=is last block, 0=not last block */
name|xfs_btree_islastblock
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|)
comment|/* level to check */
block|{
name|xfs_btree_block_t
modifier|*
name|block
decl_stmt|;
comment|/* generic btree block pointer */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing block */
name|block
operator|=
name|xfs_btree_get_block
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|xfs_btree_check_block
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BTREE_LONG_PTRS
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|)
condition|)
return|return
name|be64_to_cpu
argument_list|(
name|block
operator|->
name|bb_u
operator|.
name|l
operator|.
name|bb_rightsib
argument_list|)
operator|==
name|NULLDFSBNO
return|;
else|else
return|return
name|be32_to_cpu
argument_list|(
name|block
operator|->
name|bb_u
operator|.
name|s
operator|.
name|bb_rightsib
argument_list|)
operator|==
name|NULLAGBLOCK
return|;
block|}
end_function

begin_comment
comment|/*  * Change the cursor to point to the last record in the current block  * at the given level.  Other levels are unaffected.  */
end_comment

begin_function
name|int
comment|/* success=1, failure=0 */
name|xfs_btree_lastrec
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|level
parameter_list|)
comment|/* level to change */
block|{
name|xfs_btree_block_t
modifier|*
name|block
decl_stmt|;
comment|/* generic btree block pointer */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer containing block */
comment|/* 	 * Get the block pointer for this level. 	 */
name|block
operator|=
name|xfs_btree_get_block
argument_list|(
name|cur
argument_list|,
name|level
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|xfs_btree_check_block
argument_list|(
name|cur
argument_list|,
name|block
argument_list|,
name|level
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * It's empty, there is no such record. 	 */
if|if
condition|(
operator|!
name|block
operator|->
name|bb_h
operator|.
name|bb_numrecs
condition|)
return|return
literal|0
return|;
comment|/* 	 * Set the ptr value to numrecs, that's the last record/key. 	 */
name|cur
operator|->
name|bc_ptrs
index|[
name|level
index|]
operator|=
name|be16_to_cpu
argument_list|(
name|block
operator|->
name|bb_h
operator|.
name|bb_numrecs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Compute first and last byte offsets for the fields given.  * Interprets the offsets table, which contains struct field offsets.  */
end_comment

begin_function
name|void
name|xfs_btree_offsets
parameter_list|(
name|__int64_t
name|fields
parameter_list|,
comment|/* bitmask of fields */
specifier|const
name|short
modifier|*
name|offsets
parameter_list|,
comment|/* table of field offsets */
name|int
name|nbits
parameter_list|,
comment|/* number of bits to inspect */
name|int
modifier|*
name|first
parameter_list|,
comment|/* output: first byte offset */
name|int
modifier|*
name|last
parameter_list|)
comment|/* output: last byte offset */
block|{
name|int
name|i
decl_stmt|;
comment|/* current bit number */
name|__int64_t
name|imask
decl_stmt|;
comment|/* mask for current bit number */
name|ASSERT
argument_list|(
name|fields
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Find the lowest bit, so the first byte offset. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|imask
operator|=
literal|1LL
init|;
condition|;
name|i
operator|++
operator|,
name|imask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|imask
operator|&
name|fields
condition|)
block|{
operator|*
name|first
operator|=
name|offsets
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Find the highest bit, so the last byte offset. 	 */
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
operator|,
name|imask
operator|=
literal|1LL
operator|<<
name|i
init|;
condition|;
name|i
operator|--
operator|,
name|imask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|imask
operator|&
name|fields
condition|)
block|{
operator|*
name|last
operator|=
name|offsets
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the block, return it read in.  * Long-form addressing.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_btree_read_bufl
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_fsblock_t
name|fsbno
parameter_list|,
comment|/* file system block number */
name|uint
name|lock
parameter_list|,
comment|/* lock flags for read_buf */
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
comment|/* buffer for fsbno */
name|int
name|refval
parameter_list|)
comment|/* ref count value for buffer */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* return value */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* real disk block address */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|fsbno
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|fsbno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
name|lock
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|bp
operator|||
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_MAP
argument_list|,
name|refval
argument_list|)
expr_stmt|;
block|}
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the block, return it read in.  * Short-form addressing.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_btree_read_bufs
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_agblock_t
name|agbno
parameter_list|,
comment|/* allocation group block number */
name|uint
name|lock
parameter_list|,
comment|/* lock flags for read_buf */
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
comment|/* buffer for agno/agbno */
name|int
name|refval
parameter_list|)
comment|/* ref count value for buffer */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* return value */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* real disk block address */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|agno
operator|!=
name|NULLAGNUMBER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agbno
operator|!=
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
name|d
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
name|lock
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|bp
operator|||
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|refval
condition|)
block|{
case|case
name|XFS_ALLOC_BTREE_REF
case|:
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_MAP
argument_list|,
name|refval
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_INO_BTREE_REF
case|:
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_INOMAP
argument_list|,
name|refval
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read-ahead the block, don't wait for it, don't return a buffer.  * Long-form addressing.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_btree_reada_bufl
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_fsblock_t
name|fsbno
parameter_list|,
comment|/* file system block number */
name|xfs_extlen_t
name|count
parameter_list|)
comment|/* count of filesystem blocks */
block|{
name|xfs_daddr_t
name|d
decl_stmt|;
name|ASSERT
argument_list|(
name|fsbno
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|fsbno
argument_list|)
expr_stmt|;
name|xfs_baread
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read-ahead the block, don't wait for it, don't return a buffer.  * Short-form addressing.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xfs_btree_reada_bufs
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_agnumber_t
name|agno
parameter_list|,
comment|/* allocation group number */
name|xfs_agblock_t
name|agbno
parameter_list|,
comment|/* allocation group block number */
name|xfs_extlen_t
name|count
parameter_list|)
comment|/* count of filesystem blocks */
block|{
name|xfs_daddr_t
name|d
decl_stmt|;
name|ASSERT
argument_list|(
name|agno
operator|!=
name|NULLAGNUMBER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agbno
operator|!=
name|NULLAGBLOCK
argument_list|)
expr_stmt|;
name|d
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|)
expr_stmt|;
name|xfs_baread
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read-ahead btree blocks, at the given level.  * Bits in lr are set from XFS_BTCUR_{LEFT,RIGHT}RA.  */
end_comment

begin_function
name|int
name|xfs_btree_readahead_core
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|lev
parameter_list|,
comment|/* level in btree */
name|int
name|lr
parameter_list|)
comment|/* left/right bits */
block|{
name|xfs_alloc_block_t
modifier|*
name|a
decl_stmt|;
name|xfs_bmbt_block_t
modifier|*
name|b
decl_stmt|;
name|xfs_inobt_block_t
modifier|*
name|i
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_ra
index|[
name|lev
index|]
operator||=
name|lr
expr_stmt|;
switch|switch
condition|(
name|cur
operator|->
name|bc_btnum
condition|)
block|{
case|case
name|XFS_BTNUM_BNO
case|:
case|case
name|XFS_BTNUM_CNT
case|:
name|a
operator|=
name|XFS_BUF_TO_ALLOC_BLOCK
argument_list|(
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lr
operator|&
name|XFS_BTCUR_LEFTRA
operator|)
operator|&&
name|be32_to_cpu
argument_list|(
name|a
operator|->
name|bb_leftsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_btree_reada_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|a
operator|->
name|bb_leftsib
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lr
operator|&
name|XFS_BTCUR_RIGHTRA
operator|)
operator|&&
name|be32_to_cpu
argument_list|(
name|a
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_btree_reada_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|a
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|a
operator|->
name|bb_rightsib
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|XFS_BTNUM_BMAP
case|:
name|b
operator|=
name|XFS_BUF_TO_BMBT_BLOCK
argument_list|(
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lr
operator|&
name|XFS_BTCUR_LEFTRA
operator|)
operator|&&
name|be64_to_cpu
argument_list|(
name|b
operator|->
name|bb_leftsib
argument_list|)
operator|!=
name|NULLDFSBNO
condition|)
block|{
name|xfs_btree_reada_bufl
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|be64_to_cpu
argument_list|(
name|b
operator|->
name|bb_leftsib
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lr
operator|&
name|XFS_BTCUR_RIGHTRA
operator|)
operator|&&
name|be64_to_cpu
argument_list|(
name|b
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLDFSBNO
condition|)
block|{
name|xfs_btree_reada_bufl
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|be64_to_cpu
argument_list|(
name|b
operator|->
name|bb_rightsib
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|XFS_BTNUM_INO
case|:
name|i
operator|=
name|XFS_BUF_TO_INOBT_BLOCK
argument_list|(
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lr
operator|&
name|XFS_BTCUR_LEFTRA
operator|)
operator|&&
name|be32_to_cpu
argument_list|(
name|i
operator|->
name|bb_leftsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_btree_reada_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|i
operator|->
name|bb_leftsib
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lr
operator|&
name|XFS_BTCUR_RIGHTRA
operator|)
operator|&&
name|be32_to_cpu
argument_list|(
name|i
operator|->
name|bb_rightsib
argument_list|)
operator|!=
name|NULLAGBLOCK
condition|)
block|{
name|xfs_btree_reada_bufs
argument_list|(
name|cur
operator|->
name|bc_mp
argument_list|,
name|cur
operator|->
name|bc_private
operator|.
name|i
operator|.
name|agno
argument_list|,
name|be32_to_cpu
argument_list|(
name|i
operator|->
name|bb_rightsib
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Set the buffer for level "lev" in the cursor to bp, releasing  * any previous buffer.  */
end_comment

begin_function
name|void
name|xfs_btree_setbuf
parameter_list|(
name|xfs_btree_cur_t
modifier|*
name|cur
parameter_list|,
comment|/* btree cursor */
name|int
name|lev
parameter_list|,
comment|/* level in btree */
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
comment|/* new buffer to set */
block|{
name|xfs_btree_block_t
modifier|*
name|b
decl_stmt|;
comment|/* btree block */
name|xfs_buf_t
modifier|*
name|obp
decl_stmt|;
comment|/* old buffer pointer */
name|obp
operator|=
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
expr_stmt|;
if|if
condition|(
name|obp
condition|)
name|xfs_trans_brelse
argument_list|(
name|cur
operator|->
name|bc_tp
argument_list|,
name|obp
argument_list|)
expr_stmt|;
name|cur
operator|->
name|bc_bufs
index|[
name|lev
index|]
operator|=
name|bp
expr_stmt|;
name|cur
operator|->
name|bc_ra
index|[
name|lev
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return;
name|b
operator|=
name|XFS_BUF_TO_BLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BTREE_LONG_PTRS
argument_list|(
name|cur
operator|->
name|bc_btnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|be64_to_cpu
argument_list|(
name|b
operator|->
name|bb_u
operator|.
name|l
operator|.
name|bb_leftsib
argument_list|)
operator|==
name|NULLDFSBNO
condition|)
name|cur
operator|->
name|bc_ra
index|[
name|lev
index|]
operator||=
name|XFS_BTCUR_LEFTRA
expr_stmt|;
if|if
condition|(
name|be64_to_cpu
argument_list|(
name|b
operator|->
name|bb_u
operator|.
name|l
operator|.
name|bb_rightsib
argument_list|)
operator|==
name|NULLDFSBNO
condition|)
name|cur
operator|->
name|bc_ra
index|[
name|lev
index|]
operator||=
name|XFS_BTCUR_RIGHTRA
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|b
operator|->
name|bb_u
operator|.
name|s
operator|.
name|bb_leftsib
argument_list|)
operator|==
name|NULLAGBLOCK
condition|)
name|cur
operator|->
name|bc_ra
index|[
name|lev
index|]
operator||=
name|XFS_BTCUR_LEFTRA
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|b
operator|->
name|bb_u
operator|.
name|s
operator|.
name|bb_rightsib
argument_list|)
operator|==
name|NULLAGBLOCK
condition|)
name|cur
operator|->
name|bc_ra
index|[
name|lev
index|]
operator||=
name|XFS_BTCUR_RIGHTRA
expr_stmt|;
block|}
block|}
end_function

end_unit

