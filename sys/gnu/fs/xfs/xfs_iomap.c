begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.	 Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_cap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_include
include|#
directive|include
file|"xfs_utils.h"
end_include

begin_include
include|#
directive|include
file|"xfs_iomap.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_RW_TRACE
argument_list|)
end_if

begin_function
name|void
name|xfs_iomap_enter_trace
parameter_list|(
name|int
name|tag
parameter_list|,
name|xfs_iocore_t
modifier|*
name|io
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|ssize_t
name|count
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
init|=
name|XFS_IO_INODE
argument_list|(
name|io
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|i_rwtrace
condition|)
return|return;
name|ktrace_enter
argument_list|(
name|ip
operator|->
name|i_rwtrace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|tag
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|offset
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|offset
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|count
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|io
operator|->
name|io_new_size
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|io
operator|->
name|io_new_size
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_iomap_map_trace
parameter_list|(
name|int
name|tag
parameter_list|,
name|xfs_iocore_t
modifier|*
name|io
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|ssize_t
name|count
parameter_list|,
name|xfs_iomap_t
modifier|*
name|iomapp
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|imapp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
init|=
name|XFS_IO_INODE
argument_list|(
name|io
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|i_rwtrace
condition|)
return|return;
name|ktrace_enter
argument_list|(
name|ip
operator|->
name|i_rwtrace
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|tag
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|offset
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|offset
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|count
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|flags
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|iomapp
operator|->
name|iomap_offset
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|iomapp
operator|->
name|iomap_offset
operator|&
literal|0xffffffff
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|iomapp
operator|->
name|iomap_delta
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|iomapp
operator|->
name|iomap_bsize
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|iomapp
operator|->
name|iomap_bn
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|imapp
operator|->
name|br_startoff
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|imapp
operator|->
name|br_blockcount
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|__psint_t
call|)
argument_list|(
name|imapp
operator|->
name|br_startblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_iomap_enter_trace
parameter_list|(
name|tag
parameter_list|,
name|io
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xfs_iomap_map_trace
parameter_list|(
name|tag
parameter_list|,
name|io
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|iomapp
parameter_list|,
name|imapp
parameter_list|,
name|flags
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XFS_WRITEIO_ALIGN
parameter_list|(
name|mp
parameter_list|,
name|off
parameter_list|)
value|(((off)>> mp->m_writeio_log) \<< mp->m_writeio_log)
end_define

begin_define
define|#
directive|define
name|XFS_STRAT_WRITE_IMAPS
value|2
end_define

begin_define
define|#
directive|define
name|XFS_WRITE_IMAPS
value|XFS_BMAP_MAX_NMAP
end_define

begin_function
name|STATIC
name|int
name|xfs_imap_to_bmap
parameter_list|(
name|xfs_iocore_t
modifier|*
name|io
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|imap
parameter_list|,
name|xfs_iomap_t
modifier|*
name|iomapp
parameter_list|,
name|int
name|imaps
parameter_list|,
comment|/* Number of imap entries */
name|int
name|iomaps
parameter_list|,
comment|/* Number of iomap entries */
name|int
name|flags
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_fsize_t
name|nisize
decl_stmt|;
name|int
name|pbm
decl_stmt|;
name|xfs_fsblock_t
name|start_block
decl_stmt|;
name|mp
operator|=
name|io
operator|->
name|io_mount
expr_stmt|;
name|nisize
operator|=
name|XFS_SIZE
argument_list|(
name|mp
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_new_size
operator|>
name|nisize
condition|)
name|nisize
operator|=
name|io
operator|->
name|io_new_size
expr_stmt|;
for|for
control|(
name|pbm
operator|=
literal|0
init|;
name|imaps
operator|&&
name|pbm
operator|<
name|iomaps
condition|;
name|imaps
operator|--
operator|,
name|iomapp
operator|++
operator|,
name|imap
operator|++
operator|,
name|pbm
operator|++
control|)
block|{
name|iomapp
operator|->
name|iomap_target
operator|=
name|io
operator|->
name|io_flags
operator|&
name|XFS_IOCORE_RT
condition|?
name|mp
operator|->
name|m_rtdev_targp
else|:
name|mp
operator|->
name|m_ddev_targp
expr_stmt|;
name|iomapp
operator|->
name|iomap_offset
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|imap
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|iomapp
operator|->
name|iomap_delta
operator|=
name|offset
operator|-
name|iomapp
operator|->
name|iomap_offset
expr_stmt|;
name|iomapp
operator|->
name|iomap_bsize
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|imap
operator|->
name|br_blockcount
argument_list|)
expr_stmt|;
name|iomapp
operator|->
name|iomap_flags
operator|=
name|flags
expr_stmt|;
name|start_block
operator|=
name|imap
operator|->
name|br_startblock
expr_stmt|;
if|if
condition|(
name|start_block
operator|==
name|HOLESTARTBLOCK
condition|)
block|{
name|iomapp
operator|->
name|iomap_bn
operator|=
name|IOMAP_DADDR_NULL
expr_stmt|;
name|iomapp
operator|->
name|iomap_flags
operator|=
name|IOMAP_HOLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start_block
operator|==
name|DELAYSTARTBLOCK
condition|)
block|{
name|iomapp
operator|->
name|iomap_bn
operator|=
name|IOMAP_DADDR_NULL
expr_stmt|;
name|iomapp
operator|->
name|iomap_flags
operator|=
name|IOMAP_DELAY
expr_stmt|;
block|}
else|else
block|{
name|iomapp
operator|->
name|iomap_bn
operator|=
name|XFS_FSB_TO_DB_IO
argument_list|(
name|io
argument_list|,
name|start_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISUNWRITTEN
argument_list|(
name|imap
argument_list|)
condition|)
name|iomapp
operator|->
name|iomap_flags
operator||=
name|IOMAP_UNWRITTEN
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iomapp
operator|->
name|iomap_offset
operator|+
name|iomapp
operator|->
name|iomap_bsize
operator|)
operator|>=
name|nisize
condition|)
block|{
name|iomapp
operator|->
name|iomap_flags
operator||=
name|IOMAP_EOF
expr_stmt|;
block|}
name|offset
operator|+=
name|iomapp
operator|->
name|iomap_bsize
operator|-
name|iomapp
operator|->
name|iomap_delta
expr_stmt|;
block|}
return|return
name|pbm
return|;
comment|/* Return the number filled */
block|}
end_function

begin_function
name|int
name|xfs_iomap
parameter_list|(
name|xfs_iocore_t
modifier|*
name|io
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|ssize_t
name|count
parameter_list|,
name|int
name|flags
parameter_list|,
name|xfs_iomap_t
modifier|*
name|iomapp
parameter_list|,
name|int
modifier|*
name|niomaps
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|io
operator|->
name|io_mount
decl_stmt|;
name|xfs_fileoff_t
name|offset_fsb
decl_stmt|,
name|end_fsb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|lockmode
init|=
literal|0
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
decl_stmt|;
name|int
name|nimaps
init|=
literal|1
decl_stmt|;
name|int
name|bmapi_flags
init|=
literal|0
decl_stmt|;
name|int
name|iomap_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|BMAPI_READ
operator||
name|BMAPI_WRITE
operator||
name|BMAPI_ALLOCATE
operator||
name|BMAPI_UNWRITTEN
operator||
name|BMAPI_DEVICE
operator|)
condition|)
block|{
case|case
name|BMAPI_READ
case|:
name|xfs_iomap_enter_trace
argument_list|(
name|XFS_IOMAP_READ_ENTER
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|lockmode
operator|=
name|XFS_LCK_MAP_SHARED
argument_list|(
name|mp
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|bmapi_flags
operator|=
name|XFS_BMAPI_ENTIRE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BMAPI_IGNSTATE
condition|)
name|bmapi_flags
operator||=
name|XFS_BMAPI_IGSTATE
expr_stmt|;
break|break;
case|case
name|BMAPI_WRITE
case|:
name|xfs_iomap_enter_trace
argument_list|(
name|XFS_IOMAP_WRITE_ENTER
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|lockmode
operator|=
name|XFS_ILOCK_EXCL
operator||
name|XFS_EXTSIZE_WR
expr_stmt|;
name|bmapi_flags
operator|=
literal|0
expr_stmt|;
name|XFS_ILOCK
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|lockmode
argument_list|)
expr_stmt|;
break|break;
case|case
name|BMAPI_ALLOCATE
case|:
name|xfs_iomap_enter_trace
argument_list|(
name|XFS_IOMAP_ALLOC_ENTER
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|lockmode
operator|=
name|XFS_ILOCK_SHARED
operator||
name|XFS_EXTSIZE_RD
expr_stmt|;
name|bmapi_flags
operator|=
name|XFS_BMAPI_ENTIRE
expr_stmt|;
comment|/* Attempt non-blocking lock */
if|if
condition|(
name|flags
operator|&
name|BMAPI_TRYLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|XFS_ILOCK_NOWAIT
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|lockmode
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EAGAIN
argument_list|)
return|;
block|}
else|else
block|{
name|XFS_ILOCK
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|lockmode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BMAPI_UNWRITTEN
case|:
goto|goto
name|phase2
goto|;
case|case
name|BMAPI_DEVICE
case|:
name|lockmode
operator|=
name|XFS_LCK_MAP_SHARED
argument_list|(
name|mp
argument_list|,
name|io
argument_list|)
expr_stmt|;
name|iomapp
operator|->
name|iomap_target
operator|=
name|io
operator|->
name|io_flags
operator|&
name|XFS_IOCORE_RT
condition|?
name|mp
operator|->
name|m_rtdev_targp
else|:
name|mp
operator|->
name|m_ddev_targp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|niomaps
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|panic
argument_list|(
literal|"unrecognized bmapi flags"
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|offset
operator|<=
name|mp
operator|->
name|m_maxioffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfs_fsize_t
operator|)
name|offset
operator|+
name|count
operator|>
name|mp
operator|->
name|m_maxioffset
condition|)
name|count
operator|=
name|mp
operator|->
name|m_maxioffset
operator|-
name|offset
expr_stmt|;
name|end_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_ufsize_t
operator|)
name|offset
operator|+
name|count
argument_list|)
expr_stmt|;
name|offset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BMAPI
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|io
argument_list|,
name|offset_fsb
argument_list|,
call|(
name|xfs_filblks_t
call|)
argument_list|(
name|end_fsb
operator|-
name|offset_fsb
argument_list|)
argument_list|,
name|bmapi_flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|phase2
label|:
switch|switch
condition|(
name|flags
operator|&
operator|(
name|BMAPI_WRITE
operator||
name|BMAPI_ALLOCATE
operator||
name|BMAPI_UNWRITTEN
operator|)
condition|)
block|{
case|case
name|BMAPI_WRITE
case|:
comment|/* If we found an extent, return it */
if|if
condition|(
name|nimaps
operator|&&
operator|(
name|imap
operator|.
name|br_startblock
operator|!=
name|HOLESTARTBLOCK
operator|)
condition|)
block|{
name|xfs_iomap_map_trace
argument_list|(
name|XFS_IOMAP_WRITE_MAP
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|iomapp
argument_list|,
operator|&
name|imap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|BMAPI_DIRECT
operator||
name|BMAPI_MMAP
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_IOMAP_WRITE_DIRECT
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|,
name|nimaps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|XFS_IOMAP_WRITE_DELAY
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_iomap_map_trace
argument_list|(
name|XFS_IOMAP_ALLOC_MAP
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|iomapp
argument_list|,
operator|&
name|imap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|iomap_flags
operator|=
name|IOMAP_NEW
expr_stmt|;
break|break;
case|case
name|BMAPI_ALLOCATE
case|:
comment|/* If we found an extent, return it */
name|XFS_IUNLOCK
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|lockmode
argument_list|)
expr_stmt|;
name|lockmode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nimaps
operator|&&
operator|!
name|ISNULLSTARTBLOCK
argument_list|(
name|imap
operator|.
name|br_startblock
argument_list|)
condition|)
block|{
name|xfs_iomap_map_trace
argument_list|(
name|XFS_IOMAP_WRITE_MAP
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|iomapp
argument_list|,
operator|&
name|imap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|XFS_IOMAP_WRITE_ALLOCATE
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|)
expr_stmt|;
break|break;
case|case
name|BMAPI_UNWRITTEN
case|:
name|lockmode
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|XFS_IOMAP_WRITE_UNWRITTEN
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|nimaps
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nimaps
condition|)
block|{
operator|*
name|niomaps
operator|=
name|xfs_imap_to_bmap
argument_list|(
name|io
argument_list|,
name|offset
argument_list|,
operator|&
name|imap
argument_list|,
name|iomapp
argument_list|,
name|nimaps
argument_list|,
operator|*
name|niomaps
argument_list|,
name|iomap_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|niomaps
condition|)
block|{
operator|*
name|niomaps
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|lockmode
condition|)
name|XFS_IUNLOCK
argument_list|(
name|mp
argument_list|,
name|io
argument_list|,
name|lockmode
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_flush_space
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|int
modifier|*
name|fsynced
parameter_list|,
name|int
modifier|*
name|ioflags
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|fsynced
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ip
operator|->
name|i_delayed_blks
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_flush_inode
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
operator|*
name|fsynced
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ioflags
operator||=
name|BMAPI_SYNC
expr_stmt|;
operator|*
name|fsynced
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
literal|1
case|:
operator|*
name|fsynced
operator|=
literal|2
expr_stmt|;
operator|*
name|ioflags
operator||=
name|BMAPI_SYNC
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|2
case|:
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_flush_device
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
operator|*
name|fsynced
operator|=
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|xfs_iomap_write_direct
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|size_t
name|count
parameter_list|,
name|int
name|flags
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|ret_imap
parameter_list|,
name|int
modifier|*
name|nmaps
parameter_list|,
name|int
name|found
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
name|xfs_iocore_t
modifier|*
name|io
init|=
operator|&
name|ip
operator|->
name|i_iocore
decl_stmt|;
name|xfs_fileoff_t
name|offset_fsb
decl_stmt|;
name|xfs_fileoff_t
name|last_fsb
decl_stmt|;
name|xfs_filblks_t
name|count_fsb
decl_stmt|;
name|xfs_fsize_t
name|isize
decl_stmt|;
name|xfs_fsblock_t
name|firstfsb
decl_stmt|;
name|int
name|nimaps
decl_stmt|,
name|maps
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|bmapi_flag
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
index|[
name|XFS_WRITE_IMAPS
index|]
decl_stmt|,
modifier|*
name|imapp
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|int
name|aeof
decl_stmt|;
name|xfs_filblks_t
name|datablocks
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|int
name|numrtextents
decl_stmt|;
name|uint
name|resblks
decl_stmt|;
comment|/* 	 * Make sure that the dquots are there. This doesn't hold 	 * the ilock across a disk read. 	 */
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|ip
operator|->
name|i_mount
argument_list|,
name|ip
argument_list|,
name|XFS_QMOPT_ILOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
name|maps
operator|=
name|min
argument_list|(
name|XFS_WRITE_IMAPS
argument_list|,
operator|*
name|nmaps
argument_list|)
expr_stmt|;
name|nimaps
operator|=
name|maps
expr_stmt|;
name|isize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
name|aeof
operator|=
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|isize
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_new_size
operator|>
name|isize
condition|)
name|isize
operator|=
name|io
operator|->
name|io_new_size
expr_stmt|;
name|offset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|last_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
call|(
name|xfs_ufsize_t
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|count_fsb
operator|=
name|last_fsb
operator|-
name|offset_fsb
expr_stmt|;
if|if
condition|(
name|found
operator|&&
operator|(
name|ret_imap
operator|->
name|br_startblock
operator|==
name|HOLESTARTBLOCK
operator|)
condition|)
block|{
name|xfs_fileoff_t
name|map_last_fsb
decl_stmt|;
name|map_last_fsb
operator|=
name|ret_imap
operator|->
name|br_blockcount
operator|+
name|ret_imap
operator|->
name|br_startoff
expr_stmt|;
if|if
condition|(
name|map_last_fsb
operator|<
name|last_fsb
condition|)
block|{
name|last_fsb
operator|=
name|map_last_fsb
expr_stmt|;
name|count_fsb
operator|=
name|last_fsb
operator|-
name|offset_fsb
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|count_fsb
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * determine if reserving space on 	 * the data or realtime partition. 	 */
if|if
condition|(
operator|(
name|rt
operator|=
name|XFS_IS_REALTIME_INODE
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
name|int
name|sbrtextsize
decl_stmt|,
name|iprtextsize
decl_stmt|;
name|sbrtextsize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|iprtextsize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
condition|?
name|ip
operator|->
name|i_d
operator|.
name|di_extsize
else|:
name|sbrtextsize
expr_stmt|;
name|numrtextents
operator|=
operator|(
name|count_fsb
operator|+
name|iprtextsize
operator|-
literal|1
operator|)
expr_stmt|;
name|do_div
argument_list|(
name|numrtextents
argument_list|,
name|sbrtextsize
argument_list|)
expr_stmt|;
name|datablocks
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|datablocks
operator|=
name|count_fsb
expr_stmt|;
name|numrtextents
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * allocate and setup the transaction 	 */
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_DIOSTRAT
argument_list|)
expr_stmt|;
name|resblks
operator|=
name|XFS_DIOSTRAT_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|datablocks
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
name|numrtextents
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_WRITE_LOG_COUNT
argument_list|)
expr_stmt|;
comment|/* 	 * check for running out of space 	 */
if|if
condition|(
name|error
condition|)
comment|/* 		 * Free the transaction structure. 		 */
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_out
goto|;
comment|/* Don't return in above if .. trans .., 					need lock to return */
if|if
condition|(
name|XFS_TRANS_RESERVE_BLKQUOTA
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ip
argument_list|,
name|resblks
argument_list|)
condition|)
block|{
name|error
operator|=
operator|(
name|EDQUOT
operator|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|nimaps
operator|=
literal|1
expr_stmt|;
name|bmapi_flag
operator|=
name|XFS_BMAPI_WRITE
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BMAPI_MMAP
operator|)
operator|&&
operator|(
name|offset
operator|<
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|||
name|rt
operator|)
condition|)
name|bmapi_flag
operator||=
name|XFS_BMAPI_PREALLOC
expr_stmt|;
comment|/* 	 * issue the bmapi() call to allocate the blocks 	 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|firstfsb
argument_list|)
expr_stmt|;
name|imapp
operator|=
operator|&
name|imap
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|offset_fsb
argument_list|,
name|count_fsb
argument_list|,
name|bmapi_flag
argument_list|,
operator|&
name|firstfsb
argument_list|,
literal|0
argument_list|,
name|imapp
argument_list|,
operator|&
name|nimaps
argument_list|,
operator|&
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * complete the transaction 	 */
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|firstfsb
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|error_out
goto|;
block|}
comment|/* copy any maps to caller's array and return any error. */
if|if
condition|(
name|nimaps
operator|==
literal|0
condition|)
block|{
name|error
operator|=
operator|(
name|ENOSPC
operator|)
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
operator|*
name|ret_imap
operator|=
name|imap
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nmaps
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|error0
label|:
comment|/* Cancel bmap, unlock inode, and cancel trans */
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|error1
label|:
comment|/* Just cancel transaction */
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
operator|*
name|nmaps
operator|=
literal|0
expr_stmt|;
comment|/* nothing set-up here */
name|error_out
label|:
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xfs_iomap_write_delay
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|size_t
name|count
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|ret_imap
parameter_list|,
name|int
modifier|*
name|nmaps
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
name|xfs_iocore_t
modifier|*
name|io
init|=
operator|&
name|ip
operator|->
name|i_iocore
decl_stmt|;
name|xfs_fileoff_t
name|offset_fsb
decl_stmt|;
name|xfs_fileoff_t
name|last_fsb
decl_stmt|;
name|xfs_fsize_t
name|isize
decl_stmt|;
name|xfs_fsblock_t
name|firstblock
decl_stmt|;
name|int
name|nimaps
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
index|[
name|XFS_WRITE_IMAPS
index|]
decl_stmt|;
name|int
name|aeof
decl_stmt|;
name|int
name|fsynced
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that the dquots are there. This doesn't hold 	 * the ilock across a disk read. 	 */
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|XFS_QMOPT_ILOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
name|retry
label|:
name|isize
operator|=
name|ip
operator|->
name|i_d
operator|.
name|di_size
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|io_new_size
operator|>
name|isize
condition|)
block|{
name|isize
operator|=
name|io
operator|->
name|io_new_size
expr_stmt|;
block|}
name|aeof
operator|=
literal|0
expr_stmt|;
name|offset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|last_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
operator|(
call|(
name|xfs_ufsize_t
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the caller is doing a write at the end of the file, 	 * then extend the allocation (and the buffer used for the write) 	 * out to the file system's write iosize.  We clean up any extra 	 * space left over when the file is closed in xfs_inactive(). 	 * 	 * We don't bother with this for sync writes, because we need 	 * to minimize the amount we write for good performance. 	 */
if|if
condition|(
operator|!
operator|(
name|ioflag
operator|&
name|BMAPI_SYNC
operator|)
operator|&&
operator|(
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|)
condition|)
block|{
name|xfs_off_t
name|aligned_offset
decl_stmt|;
name|unsigned
name|int
name|iosize
decl_stmt|;
name|xfs_fileoff_t
name|ioalign
decl_stmt|;
name|iosize
operator|=
name|mp
operator|->
name|m_writeio_blocks
expr_stmt|;
name|aligned_offset
operator|=
name|XFS_WRITEIO_ALIGN
argument_list|(
name|mp
argument_list|,
operator|(
name|offset
operator|+
name|count
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ioalign
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|aligned_offset
argument_list|)
expr_stmt|;
name|last_fsb
operator|=
name|ioalign
operator|+
name|iosize
expr_stmt|;
name|aeof
operator|=
literal|1
expr_stmt|;
block|}
name|nimaps
operator|=
name|XFS_WRITE_IMAPS
expr_stmt|;
name|firstblock
operator|=
name|NULLFSBLOCK
expr_stmt|;
comment|/* 	 * roundup the allocation request to m_dalign boundary if file size 	 * is greater that 512K and we are allocating past the allocation eof 	 */
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
operator|(
name|isize
operator|>=
name|mp
operator|->
name|m_dalign
operator|)
operator|&&
name|aeof
condition|)
block|{
name|int
name|eof
decl_stmt|;
name|xfs_fileoff_t
name|new_last_fsb
decl_stmt|;
name|new_last_fsb
operator|=
name|roundup_64
argument_list|(
name|last_fsb
argument_list|,
name|mp
operator|->
name|m_dalign
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bmap_eof
argument_list|(
name|ip
argument_list|,
name|new_last_fsb
argument_list|,
name|XFS_DATA_FORK
argument_list|,
operator|&
name|eof
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|eof
condition|)
block|{
name|last_fsb
operator|=
name|new_last_fsb
expr_stmt|;
block|}
block|}
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
name|offset_fsb
argument_list|,
call|(
name|xfs_filblks_t
call|)
argument_list|(
name|last_fsb
operator|-
name|offset_fsb
argument_list|)
argument_list|,
name|XFS_BMAPI_DELAY
operator||
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_ENTIRE
argument_list|,
operator|&
name|firstblock
argument_list|,
literal|1
argument_list|,
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * This can be EDQUOT, if nimaps == 0 	 */
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|!=
name|ENOSPC
operator|)
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
comment|/* 	 * If bmapi returned us nothing, and if we didn't get back EDQUOT, 	 * then we must have run out of space. 	 */
if|if
condition|(
name|nimaps
operator|==
literal|0
condition|)
block|{
name|xfs_iomap_enter_trace
argument_list|(
name|XFS_IOMAP_WRITE_NOSPACE
argument_list|,
name|io
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_flush_space
argument_list|(
name|ip
argument_list|,
operator|&
name|fsynced
argument_list|,
operator|&
name|ioflag
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
operator|*
name|ret_imap
operator|=
name|imap
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nmaps
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pass in a delayed allocate extent, convert it to real extents;  * return to the caller the extent we create which maps on top of  * the originating callers request.  *  * Called without a lock on the inode.  */
end_comment

begin_function
name|int
name|xfs_iomap_write_allocate
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|map
parameter_list|,
name|int
modifier|*
name|retmap
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
name|xfs_fileoff_t
name|offset_fsb
decl_stmt|,
name|last_block
decl_stmt|;
name|xfs_fileoff_t
name|end_fsb
decl_stmt|,
name|map_start_fsb
decl_stmt|;
name|xfs_fsblock_t
name|first_block
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_filblks_t
name|count_fsb
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
index|[
name|XFS_STRAT_WRITE_IMAPS
index|]
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nimaps
decl_stmt|,
name|committed
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|nres
decl_stmt|;
operator|*
name|retmap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure that the dquots are there. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_DQATTACH
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
name|offset_fsb
operator|=
name|map
operator|->
name|br_startoff
expr_stmt|;
name|count_fsb
operator|=
name|map
operator|->
name|br_blockcount
expr_stmt|;
name|map_start_fsb
operator|=
name|offset_fsb
expr_stmt|;
name|XFS_STATS_ADD
argument_list|(
name|xs_xstrat_bytes
argument_list|,
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|count_fsb
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count_fsb
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Set up a transaction with which to allocate the 		 * backing store for the file.  Do allocations in a 		 * loop until we get some space in the range we are 		 * interested in.  The other space that might be allocated 		 * is in the delayed allocation extent on which we sit 		 * but before our buffer starts. 		 */
name|nimaps
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nimaps
operator|==
literal|0
condition|)
block|{
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_STRAT_WRITE
argument_list|)
expr_stmt|;
name|nres
operator|=
name|XFS_EXTENTADD_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|nres
argument_list|,
name|XFS_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_WRITE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_WRITE_LOG_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|first_block
argument_list|)
expr_stmt|;
name|nimaps
operator|=
name|XFS_STRAT_WRITE_IMAPS
expr_stmt|;
comment|/* 			 * Ensure we don't go beyond eof - it is possible 			 * the extents changed since we did the read call, 			 * we dropped the ilock in the interim. 			 */
name|end_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|ip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|xfs_bmap_last_offset
argument_list|(
name|NULL
argument_list|,
name|ip
argument_list|,
operator|&
name|last_block
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|last_block
operator|=
name|XFS_FILEOFF_MAX
argument_list|(
name|last_block
argument_list|,
name|end_fsb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|map_start_fsb
operator|+
name|count_fsb
operator|)
operator|>
name|last_block
condition|)
block|{
name|count_fsb
operator|=
name|last_block
operator|-
name|map_start_fsb
expr_stmt|;
if|if
condition|(
name|count_fsb
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|trans_cancel
goto|;
block|}
block|}
comment|/* Go get the actual blocks */
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|map_start_fsb
argument_list|,
name|count_fsb
argument_list|,
name|XFS_BMAPI_WRITE
argument_list|,
operator|&
name|first_block
argument_list|,
literal|1
argument_list|,
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|,
operator|&
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|trans_cancel
goto|;
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|free_list
argument_list|,
name|first_block
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|trans_cancel
goto|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * See if we were able to allocate an extent that 		 * covers at least part of the callers request 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nimaps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|map
operator|->
name|br_startoff
operator|>=
name|imap
index|[
name|i
index|]
operator|.
name|br_startoff
operator|)
operator|&&
operator|(
name|map
operator|->
name|br_startoff
operator|<
operator|(
name|imap
index|[
name|i
index|]
operator|.
name|br_startoff
operator|+
name|imap
index|[
name|i
index|]
operator|.
name|br_blockcount
operator|)
operator|)
condition|)
block|{
operator|*
name|map
operator|=
name|imap
index|[
name|i
index|]
expr_stmt|;
operator|*
name|retmap
operator|=
literal|1
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_xstrat_quick
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count_fsb
operator|-=
name|imap
index|[
name|i
index|]
operator|.
name|br_blockcount
expr_stmt|;
block|}
comment|/* So far we have not mapped the requested part of the 		 * file, just surrounding data, try again. 		 */
name|nimaps
operator|--
expr_stmt|;
name|offset_fsb
operator|=
name|imap
index|[
name|nimaps
index|]
operator|.
name|br_startoff
operator|+
name|imap
index|[
name|nimaps
index|]
operator|.
name|br_blockcount
expr_stmt|;
name|map_start_fsb
operator|=
name|offset_fsb
expr_stmt|;
block|}
name|trans_cancel
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
name|error0
label|:
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xfs_iomap_write_unwritten
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|xfs_off_t
name|offset
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|ip
operator|->
name|i_mount
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_fileoff_t
name|offset_fsb
decl_stmt|;
name|xfs_filblks_t
name|count_fsb
decl_stmt|;
name|xfs_filblks_t
name|numblks_fsb
decl_stmt|;
name|xfs_bmbt_irec_t
name|imap
decl_stmt|;
name|int
name|committed
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nres
decl_stmt|;
name|int
name|nimaps
decl_stmt|;
name|xfs_fsblock_t
name|firstfsb
decl_stmt|;
name|xfs_bmap_free_t
name|free_list
decl_stmt|;
name|xfs_iomap_enter_trace
argument_list|(
name|XFS_IOMAP_UNWRITTEN
argument_list|,
operator|&
name|ip
operator|->
name|i_iocore
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|offset_fsb
operator|=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|count_fsb
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|count
argument_list|)
expr_stmt|;
do|do
block|{
name|nres
operator|=
name|XFS_DIOSTRAT_SPACE_RES
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * set up a transaction to convert the range of extents 		 * from unwritten to real. Do allocations in a loop until 		 * we have covered the range passed in. 		 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_STRAT_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|nres
argument_list|,
name|XFS_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_WRITE_LOG_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * Modify the unwritten extent state of the buffer. 		 */
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|free_list
argument_list|,
operator|&
name|firstfsb
argument_list|)
expr_stmt|;
name|nimaps
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|offset_fsb
argument_list|,
name|count_fsb
argument_list|,
name|XFS_BMAPI_WRITE
argument_list|,
operator|&
name|firstfsb
argument_list|,
literal|1
argument_list|,
operator|&
name|imap
argument_list|,
operator|&
name|nimaps
argument_list|,
operator|&
name|free_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_on_bmapi_transaction
goto|;
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
operator|(
name|tp
operator|)
argument_list|,
operator|&
operator|(
name|free_list
operator|)
argument_list|,
name|firstfsb
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_on_bmapi_transaction
goto|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error0
goto|;
if|if
condition|(
operator|(
name|numblks_fsb
operator|=
name|imap
operator|.
name|br_blockcount
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The numblks_fsb value should always get 			 * smaller, otherwise the loop is stuck. 			 */
name|ASSERT
argument_list|(
name|imap
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
break|break;
block|}
name|offset_fsb
operator|+=
name|numblks_fsb
expr_stmt|;
name|count_fsb
operator|-=
name|numblks_fsb
expr_stmt|;
block|}
do|while
condition|(
name|count_fsb
operator|>
literal|0
condition|)
do|;
return|return
literal|0
return|;
name|error_on_bmapi_transaction
label|:
name|xfs_bmap_cancel
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
operator|(
name|XFS_TRANS_RELEASE_LOG_RES
operator||
name|XFS_TRANS_ABORT
operator|)
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error0
label|:
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
end_function

end_unit

