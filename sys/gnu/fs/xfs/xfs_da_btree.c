begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_data.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_block.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_node.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_comment
comment|/*  * xfs_da_btree.c  *  * Routines to implement directories as Btrees of hashed names.  */
end_comment

begin_comment
comment|/*========================================================================  * Function prototypes for the kernel.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Routines used for growing the Btree.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_da_root_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|existing_root
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|new_child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_da_node_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|existing_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|split_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk_to_add
parameter_list|,
name|int
name|treelevel
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_da_node_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|node_blk_1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|node_blk_2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_da_node_add
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|old_node_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|new_node_blk
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Routines used for shrinking the Btree.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_da_root_join
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|root_blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_da_node_toosmall
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_da_node_remove
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_da_node_unbalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|src_node_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|dst_node_blk
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Utility routines.  */
end_comment

begin_function_decl
name|STATIC
name|uint
name|xfs_da_node_lasthash
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_da_node_order
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|node1_bp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|node2_bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|xfs_dabuf_t
modifier|*
name|xfs_da_buf_make
parameter_list|(
name|int
name|nbuf
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|bps
parameter_list|,
name|inst_t
modifier|*
name|ra
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*========================================================================  * Routines used for growing the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Create the initial contents of an intermediate node.  */
end_comment

begin_function
name|int
name|xfs_da_node_create
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
name|blkno
parameter_list|,
name|int
name|level
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|tp
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|INT_ZERO
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|pad
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_ZERO
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split a leaf node, rebalance, then possibly split  * intermediate nodes, rebalance, etc.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_da_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|oldblk
decl_stmt|,
modifier|*
name|newblk
decl_stmt|,
modifier|*
name|addblk
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|max
decl_stmt|,
name|action
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Walk back up the tree splitting/inserting/adjusting as necessary. 	 * If we need to insert and there isn't room, split the node, then 	 * decide which fragment to insert the new block from below into. 	 * Note that we may split the root this way, but we need more fixup. 	 */
name|max
operator|=
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|max
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|max
operator|<
name|XFS_DA_NODE_MAXDEPTH
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|max
index|]
operator|.
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
operator|||
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|max
index|]
operator|.
name|magic
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|addblk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|max
index|]
expr_stmt|;
comment|/* initial dummy value */
for|for
control|(
name|i
operator|=
name|max
init|;
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
name|addblk
condition|;
name|state
operator|->
name|path
operator|.
name|active
operator|--
operator|,
name|i
operator|--
control|)
block|{
name|oldblk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
expr_stmt|;
name|newblk
operator|=
operator|&
name|state
operator|->
name|altpath
operator|.
name|blk
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * If a leaf node then 		 *     Allocate a new leaf node, then rebalance across them. 		 * else if an intermediate node then 		 *     We split on the last layer, must we split the node? 		 */
switch|switch
condition|(
name|oldblk
operator|->
name|magic
condition|)
block|{
case|case
name|XFS_ATTR_LEAF_MAGIC
case|:
ifndef|#
directive|ifndef
name|__KERNEL__
return|return
operator|(
name|ENOTTY
operator|)
return|;
else|#
directive|else
name|error
operator|=
name|xfs_attr_leaf_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|ENOSPC
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: attr is inconsistent */
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|addblk
operator|=
name|newblk
expr_stmt|;
break|break;
block|}
comment|/* 			 * Entry wouldn't fit, split the leaf again. 			 */
name|state
operator|->
name|extravalid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|inleaf
condition|)
block|{
name|state
operator|->
name|extraafter
operator|=
literal|0
expr_stmt|;
comment|/* before newblk */
name|error
operator|=
name|xfs_attr_leaf_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|extraafter
operator|=
literal|1
expr_stmt|;
comment|/* after newblk */
name|error
operator|=
name|xfs_attr_leaf_split
argument_list|(
name|state
argument_list|,
name|newblk
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: attr inconsistent */
name|addblk
operator|=
name|newblk
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|XFS_DIR_LEAF_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_dir_leaf_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|ENOSPC
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir is inconsistent */
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|addblk
operator|=
name|newblk
expr_stmt|;
break|break;
block|}
comment|/* 			 * Entry wouldn't fit, split the leaf again. 			 */
name|state
operator|->
name|extravalid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|inleaf
condition|)
block|{
name|state
operator|->
name|extraafter
operator|=
literal|0
expr_stmt|;
comment|/* before newblk */
name|error
operator|=
name|xfs_dir_leaf_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir incon. */
name|addblk
operator|=
name|newblk
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|extraafter
operator|=
literal|1
expr_stmt|;
comment|/* after newblk */
name|error
operator|=
name|xfs_dir_leaf_split
argument_list|(
name|state
argument_list|,
name|newblk
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir incon. */
name|addblk
operator|=
name|newblk
expr_stmt|;
block|}
break|break;
case|case
name|XFS_DIR2_LEAFN_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_dir2_leafn_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|addblk
operator|=
name|newblk
expr_stmt|;
break|break;
case|case
name|XFS_DA_NODE_MAGIC
case|:
name|error
operator|=
name|xfs_da_node_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|,
name|addblk
argument_list|,
name|max
operator|-
name|i
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|addblk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|addblk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir is inconsistent */
comment|/* 			 * Record the newly split block for the next time thru? 			 */
if|if
condition|(
name|action
condition|)
name|addblk
operator|=
name|newblk
expr_stmt|;
else|else
name|addblk
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Update the btree to show the new hashval for this child. 		 */
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * If we won't need this block again, it's getting dropped 		 * from the active path by the loop control, so we need 		 * to mark it done now. 		 */
if|if
condition|(
name|i
operator|>
literal|0
operator|||
operator|!
name|addblk
condition|)
name|xfs_da_buf_done
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addblk
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Split the root node. 	 */
name|ASSERT
argument_list|(
name|state
operator|->
name|path
operator|.
name|active
operator|==
literal|0
argument_list|)
expr_stmt|;
name|oldblk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|xfs_da_root_split
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|addblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_da_buf_done
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|addblk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|addblk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir is inconsistent */
block|}
comment|/* 	 * Update pointers to the node which used to be block 0 and 	 * just got bumped because of the addition of a new root node. 	 * There might be three blocks involved if a double split occurred, 	 * and the original block 0 could be at any position in the list. 	 */
name|node
operator|=
name|oldblk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|INT_ISZERO
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
if|if
condition|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|addblk
operator|->
name|blkno
condition|)
block|{
name|bp
operator|=
name|addblk
operator|->
name|bp
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|extravalid
argument_list|)
expr_stmt|;
name|bp
operator|=
name|state
operator|->
name|extrablk
operator|.
name|bp
expr_stmt|;
block|}
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|oldblk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|hdr
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|oldblk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
if|if
condition|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|addblk
operator|->
name|blkno
condition|)
block|{
name|bp
operator|=
name|addblk
operator|->
name|bp
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|extravalid
argument_list|)
expr_stmt|;
name|bp
operator|=
name|state
operator|->
name|extrablk
operator|.
name|bp
expr_stmt|;
block|}
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|oldblk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|hdr
operator|.
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|oldblk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|addblk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|addblk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split the root.  We have to create a new root and point to the two  * parts (the split old root) that we just created.  Copy block zero to  * the EOF, extending the inode in process.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_da_root_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|oldroot
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* 	 * Copy the existing (incorrect) block from the root node position 	 * to a free space somewhere. 	 */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|state
operator|->
name|mp
expr_stmt|;
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|oldroot
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
condition|)
block|{
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|oldroot
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
operator|-
operator|(
name|char
operator|*
operator|)
name|oldroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|leaf
operator|=
operator|(
name|xfs_dir2_leaf_t
operator|*
operator|)
name|oldroot
expr_stmt|;
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|leaf
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|node
argument_list|,
name|oldroot
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|blk1
operator|->
name|bp
argument_list|)
expr_stmt|;
name|blk1
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|blk1
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
comment|/* 	 * Set up the new root node. 	 */
name|error
operator|=
name|xfs_da_node_create
argument_list|(
name|args
argument_list|,
name|args
operator|->
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|?
name|mp
operator|->
name|m_dirleafblk
else|:
literal|0
argument_list|,
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|blk1
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|blk1
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|btree
index|[
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|blk2
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|btree
index|[
literal|1
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|blk2
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
condition|)
block|{
name|ASSERT
argument_list|(
name|blk1
operator|->
name|blkno
operator|>=
name|mp
operator|->
name|m_dirleafblk
operator|&&
name|blk1
operator|->
name|blkno
operator|<
name|mp
operator|->
name|m_dirfreeblk
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk2
operator|->
name|blkno
operator|>=
name|mp
operator|->
name|m_dirleafblk
operator|&&
name|blk2
operator|->
name|blkno
operator|<
name|mp
operator|->
name|m_dirfreeblk
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Header is already logged by xfs_da_node_create */
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|btree
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split the node, rebalance, then add the new entry.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_da_node_split
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|oldblk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|newblk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|addblk
parameter_list|,
name|int
name|treelevel
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|int
name|newcount
decl_stmt|,
name|error
decl_stmt|;
name|int
name|useextra
decl_stmt|;
name|node
operator|=
name|oldblk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * With V2 the extra block is data or freespace. 	 */
name|useextra
operator|=
name|state
operator|->
name|extravalid
operator|&&
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
expr_stmt|;
name|newcount
operator|=
literal|1
operator|+
name|useextra
expr_stmt|;
comment|/* 	 * Do we have to split the node? 	 */
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|newcount
operator|)
operator|>
name|state
operator|->
name|node_ents
condition|)
block|{
comment|/* 		 * Allocate a new node, add to the doubly linked chain of 		 * nodes, then move some of our excess entries into it. 		 */
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|state
operator|->
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir is inconsistent */
name|error
operator|=
name|xfs_da_node_create
argument_list|(
name|state
operator|->
name|args
argument_list|,
name|blkno
argument_list|,
name|treelevel
argument_list|,
operator|&
name|newblk
operator|->
name|bp
argument_list|,
name|state
operator|->
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* GROT: dir is inconsistent */
name|newblk
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|newblk
operator|->
name|magic
operator|=
name|XFS_DA_NODE_MAGIC
expr_stmt|;
name|xfs_da_node_rebalance
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_blk_link
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Insert the new entry(s) into the correct block 	 * (updating last hashval in the process). 	 * 	 * xfs_da_node_add() inserts BEFORE the given index, 	 * and as a result of using node_lookup_int() we always 	 * point to a valid entry (not after one), but a split 	 * operation always results in a new block whose hashvals 	 * FOLLOW the current block. 	 * 	 * If we had double-split op below us, then add the extra block too. 	 */
name|node
operator|=
name|oldblk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|oldblk
operator|->
name|index
operator|<=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|oldblk
operator|->
name|index
operator|++
expr_stmt|;
name|xfs_da_node_add
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
name|addblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|useextra
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|extraafter
condition|)
name|oldblk
operator|->
name|index
operator|++
expr_stmt|;
name|xfs_da_node_add
argument_list|(
name|state
argument_list|,
name|oldblk
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|)
expr_stmt|;
name|state
operator|->
name|extravalid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|newblk
operator|->
name|index
operator|++
expr_stmt|;
name|xfs_da_node_add
argument_list|(
name|state
argument_list|,
name|newblk
argument_list|,
name|addblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|useextra
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|extraafter
condition|)
name|newblk
operator|->
name|index
operator|++
expr_stmt|;
name|xfs_da_node_add
argument_list|(
name|state
argument_list|,
name|newblk
argument_list|,
operator|&
name|state
operator|->
name|extrablk
argument_list|)
expr_stmt|;
name|state
operator|->
name|extravalid
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Balance the btree elements between two intermediate nodes,  * usually one full and one empty.  *  * NOTE: if blk2 is empty, then it will get the upper half of blk1.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_da_node_rebalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk1
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|blk2
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|,
modifier|*
name|tmpnode
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree_s
decl_stmt|,
modifier|*
name|btree_d
decl_stmt|;
name|int
name|count
decl_stmt|,
name|tmp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|node1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|node2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
comment|/* 	 * Figure out how many entries need to move, and in which direction. 	 * Swap the nodes around if that makes it simpler. 	 */
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|node1
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|node1
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tmpnode
operator|=
name|node1
expr_stmt|;
name|node1
operator|=
name|node2
expr_stmt|;
name|node2
operator|=
name|tmpnode
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|tp
operator|=
name|state
operator|->
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Two cases: high-to-low and low-to-high. 	 */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Move elements in node2 up to make a hole. 		 */
if|if
condition|(
operator|(
name|tmp
operator|=
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|tmp
operator|*=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|btree_s
operator|=
operator|&
name|node2
operator|->
name|btree
index|[
literal|0
index|]
expr_stmt|;
name|btree_d
operator|=
operator|&
name|node2
operator|->
name|btree
index|[
name|count
index|]
expr_stmt|;
name|memmove
argument_list|(
name|btree_d
argument_list|,
name|btree_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move the req'd B-tree elements from high in node1 to 		 * low in node2. 		 */
name|INT_MOD
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|btree_s
operator|=
operator|&
name|node1
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|count
index|]
expr_stmt|;
name|btree_d
operator|=
operator|&
name|node2
operator|->
name|btree
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|btree_d
argument_list|,
name|btree_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|count
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Move the req'd B-tree elements from low in node2 to 		 * high in node1. 		 */
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|tmp
operator|=
name|count
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|btree_s
operator|=
operator|&
name|node2
operator|->
name|btree
index|[
literal|0
index|]
expr_stmt|;
name|btree_d
operator|=
operator|&
name|node1
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|btree_d
argument_list|,
name|btree_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node1
argument_list|,
name|btree_d
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Move elements in node2 down to fill the hole. 		 */
name|tmp
operator|=
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|count
expr_stmt|;
name|tmp
operator|*=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|btree_s
operator|=
operator|&
name|node2
operator|->
name|btree
index|[
name|count
index|]
expr_stmt|;
name|btree_d
operator|=
operator|&
name|node2
operator|->
name|btree
index|[
literal|0
index|]
expr_stmt|;
name|memmove
argument_list|(
name|btree_d
argument_list|,
name|btree_s
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
operator|(
name|count
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Log header of node 1 and all current bits of node 2. 	 */
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|blk1
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node1
argument_list|,
operator|&
name|node1
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|node1
operator|->
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|blk2
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node2
argument_list|,
operator|&
name|node2
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|node2
operator|->
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|node2
operator|->
name|btree
index|[
literal|0
index|]
argument_list|)
operator|*
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Record the last hashval from each block for upward propagation. 	 * (note: don't use the swapped node pointers) 	 */
name|node1
operator|=
name|blk1
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|node2
operator|=
name|blk2
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|blk1
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|node1
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|blk2
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|node2
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the expected index for insertion. 	 */
if|if
condition|(
name|blk1
operator|->
name|index
operator|>=
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|blk2
operator|->
name|index
operator|=
name|blk1
operator|->
name|index
operator|-
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|blk1
operator|->
name|index
operator|=
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* make it invalid */
block|}
block|}
end_function

begin_comment
comment|/*  * Add a new entry to an intermediate node.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_da_node_add
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|oldblk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|newblk
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|node
operator|=
name|oldblk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|mp
operator|=
name|state
operator|->
name|mp
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|oldblk
operator|->
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|oldblk
operator|->
name|index
operator|<=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|newblk
operator|->
name|blkno
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|args
operator|->
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|newblk
operator|->
name|blkno
operator|>=
name|mp
operator|->
name|m_dirleafblk
operator|&&
name|newblk
operator|->
name|blkno
operator|<
name|mp
operator|->
name|m_dirfreeblk
argument_list|)
expr_stmt|;
comment|/* 	 * We may need to make some room before we insert the new node. 	 */
name|tmp
operator|=
literal|0
expr_stmt|;
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
name|oldblk
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|oldblk
operator|->
name|index
operator|<
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|oldblk
operator|->
name|index
operator|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|btree
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|btree
operator|+
literal|1
argument_list|,
name|btree
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|newblk
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|btree
operator|->
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|newblk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|oldblk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
name|btree
argument_list|,
name|tmp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|btree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|oldblk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the last hash value from the oldblk to propagate upwards. 	 */
name|oldblk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for shrinking the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Deallocate an empty leaf node, remove it from its parent,  * possibly deallocating that block, etc...  */
end_comment

begin_function
name|int
name|xfs_da_join
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
decl_stmt|,
modifier|*
name|save_blk
decl_stmt|;
name|int
name|action
decl_stmt|,
name|error
decl_stmt|;
name|action
operator|=
literal|0
expr_stmt|;
name|drop_blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|save_blk
operator|=
operator|&
name|state
operator|->
name|altpath
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|.
name|magic
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
operator|||
name|drop_blk
operator|->
name|magic
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Walk back up the tree joining/deallocating as necessary. 	 * When we stop dropping blocks, break out. 	 */
for|for
control|(
init|;
name|state
operator|->
name|path
operator|.
name|active
operator|>=
literal|2
condition|;
name|drop_blk
operator|--
operator|,
name|save_blk
operator|--
operator|,
name|state
operator|->
name|path
operator|.
name|active
operator|--
control|)
block|{
comment|/* 		 * See if we can combine the block with a neighbor. 		 *   (action == 0) => no options, just leave 		 *   (action == 1) => coalesce, then unlink 		 *   (action == 2) => block empty, unlink it 		 */
switch|switch
condition|(
name|drop_blk
operator|->
name|magic
condition|)
block|{
case|case
name|XFS_ATTR_LEAF_MAGIC
case|:
ifndef|#
directive|ifndef
name|__KERNEL__
name|error
operator|=
name|ENOTTY
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|xfs_attr_leaf_toosmall
argument_list|(
name|state
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|action
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|__KERNEL__
name|xfs_attr_leaf_unbalance
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|,
name|save_blk
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|XFS_DIR_LEAF_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_dir_leaf_toosmall
argument_list|(
name|state
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|action
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|xfs_dir_leaf_unbalance
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|,
name|save_blk
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DIR2_LEAFN_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_dir2_leafn_toosmall
argument_list|(
name|state
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|action
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|xfs_dir2_leafn_unbalance
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|,
name|save_blk
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DA_NODE_MAGIC
case|:
comment|/* 			 * Remove the offending node, fixup hashvals, 			 * check for a toosmall neighbor. 			 */
name|xfs_da_node_remove
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|)
expr_stmt|;
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_node_toosmall
argument_list|(
name|state
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|action
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|xfs_da_node_unbalance
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|,
name|save_blk
argument_list|)
expr_stmt|;
break|break;
block|}
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_blk_unlink
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|,
name|save_blk
argument_list|)
expr_stmt|;
name|xfs_da_state_kill_altpath
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|xfs_da_shrink_inode
argument_list|(
name|state
operator|->
name|args
argument_list|,
name|drop_blk
operator|->
name|blkno
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
name|drop_blk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * We joined all the way to the top.  If it turns out that 	 * we only have one entry in the root, make the child block 	 * the new root. 	 */
name|xfs_da_node_remove
argument_list|(
name|state
argument_list|,
name|drop_blk
argument_list|)
expr_stmt|;
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_root_join
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have only one entry in the root.  Copy the only remaining child of  * the old root to block 0 as the new root node.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_da_root_join
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|root_blk
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|oldroot
decl_stmt|;
comment|/* REFERENCED */
name|xfs_da_blkinfo_t
modifier|*
name|blkinfo
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|xfs_dablk_t
name|child
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|root_blk
operator|->
name|magic
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|oldroot
operator|=
name|root_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_ISZERO
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_ISZERO
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the root has more than one child, then don't do anything. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Read in the (only) child block, then copy those bytes into 	 * the root block's buffer and free the original child block. 	 */
name|child
operator|=
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|child
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|child
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|blkinfo
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|oldroot
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|blkinfo
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
operator|||
name|INT_GET
argument_list|(
name|blkinfo
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|blkinfo
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|INT_ISZERO
argument_list|(
name|blkinfo
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_ISZERO
argument_list|(
name|blkinfo
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|root_blk
operator|->
name|bp
operator|->
name|data
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|state
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|root_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_shrink_inode
argument_list|(
name|args
argument_list|,
name|child
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check a node block and its neighbors to see if the block should be  * collapsed into one or the other neighbor.  Always keep the block  * with the smaller block number.  * If the current block is over 50% full, don't try to join it, return 0.  * If the block is empty, fill in the state structure and return 2.  * If it can be collapsed, fill in the state structure and return 1.  * If nothing can be done, return 0.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_da_node_toosmall
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|action
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|int
name|count
decl_stmt|,
name|forward
decl_stmt|,
name|error
decl_stmt|,
name|retval
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Check for the degenerate case of the block being over 50% full. 	 * If so, it's not worth even looking to see if we might be able 	 * to coalesce with a sibling. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|xfs_da_intnode_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
operator|(
name|state
operator|->
name|node_ents
operator|>>
literal|1
operator|)
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
comment|/* blk over 50%, don't try to join */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* blk over 50%, don't try to join */
block|}
comment|/* 	 * Check for the degenerate case of the block being empty. 	 * If the block is empty, we'll simply delete it, no need to 	 * coalesce it with a sibling block.  We choose (aribtrarily) 	 * to merge with the forward block unless it is NULL. 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Make altpath point to the block we want to keep and 		 * path point to the block we want to drop (this one). 		 */
name|forward
operator|=
operator|(
operator|!
name|INT_ISZERO
argument_list|(
name|info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|action
operator|=
literal|2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Examine each sibling block to see if we can coalesce with 	 * at least 25% free space to spare.  We need to figure out 	 * whether to merge with the forward or the backward block. 	 * We prefer coalescing with the lower numbered sibling so as 	 * to shrink a directory over time. 	 */
comment|/* start with smaller blk num */
name|forward
operator|=
operator|(
name|INT_GET
argument_list|(
name|info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|forward
operator|=
operator|!
name|forward
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|forward
condition|)
name|blkno
operator|=
name|INT_GET
argument_list|(
name|info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
else|else
name|blkno
operator|=
name|INT_GET
argument_list|(
name|info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|state
operator|->
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|xfs_da_intnode_t
operator|*
operator|)
name|info
expr_stmt|;
name|count
operator|=
name|state
operator|->
name|node_ents
expr_stmt|;
name|count
operator|-=
name|state
operator|->
name|node_ents
operator|>>
literal|2
expr_stmt|;
name|count
operator|-=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|count
operator|-=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
break|break;
comment|/* fits with at least 25% to spare */
block|}
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make altpath point to the block we want to keep (the lower 	 * numbered block) and path point to the block we want to drop. 	 */
name|memcpy
argument_list|(
operator|&
name|state
operator|->
name|altpath
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkno
operator|<
name|blk
operator|->
name|blkno
condition|)
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|altpath
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
name|forward
argument_list|,
literal|0
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|retval
condition|)
block|{
operator|*
name|action
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|*
name|action
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk back up the tree adjusting hash values as necessary,  * when we stop making changes, return.  */
end_comment

begin_function
name|void
name|xfs_da_fixhashpath
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_path_t
modifier|*
name|path
parameter_list|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|xfs_dahash_t
name|lasthash
init|=
literal|0
decl_stmt|;
name|int
name|level
decl_stmt|,
name|count
decl_stmt|;
name|level
operator|=
name|path
operator|->
name|active
operator|-
literal|1
expr_stmt|;
name|blk
operator|=
operator|&
name|path
operator|->
name|blk
index|[
name|level
index|]
expr_stmt|;
switch|switch
condition|(
name|blk
operator|->
name|magic
condition|)
block|{
ifdef|#
directive|ifdef
name|__KERNEL__
case|case
name|XFS_ATTR_LEAF_MAGIC
case|:
name|lasthash
operator|=
name|xfs_attr_leaf_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
break|break;
endif|#
directive|endif
case|case
name|XFS_DIR_LEAF_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|lasthash
operator|=
name|xfs_dir_leaf_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
break|break;
case|case
name|XFS_DIR2_LEAFN_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|lasthash
operator|=
name|xfs_dir2_leafn_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
break|break;
case|case
name|XFS_DA_NODE_MAGIC
case|:
name|lasthash
operator|=
name|xfs_da_node_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
break|break;
block|}
for|for
control|(
name|blk
operator|--
operator|,
name|level
operator|--
init|;
name|level
operator|>=
literal|0
condition|;
name|blk
operator|--
operator|,
name|level
operator|--
control|)
block|{
name|node
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
name|blk
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|lasthash
condition|)
break|break;
name|blk
operator|->
name|hashval
operator|=
name|lasthash
expr_stmt|;
name|INT_SET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|lasthash
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
name|btree
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|btree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lasthash
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove an entry from an intermediate node.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_da_node_remove
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|node
operator|=
name|drop_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|index
operator|<
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Copy over the offending entry, or just zero it out. 	 */
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
name|drop_blk
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|drop_blk
operator|->
name|index
operator|<
operator|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|tmp
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
name|drop_blk
operator|->
name|index
operator|-
literal|1
expr_stmt|;
name|tmp
operator|*=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|btree
argument_list|,
name|btree
operator|+
literal|1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
name|btree
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|btree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
name|btree
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|btree
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|state
operator|->
name|args
operator|->
name|trans
argument_list|,
name|drop_blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|node
operator|->
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the last hash value from the block to propagate upwards. 	 */
name|btree
operator|--
expr_stmt|;
name|drop_blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unbalance the btree elements between two intermediate nodes,  * move all Btree elements from one node into another.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_da_node_unbalance
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|save_blk
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|drop_node
decl_stmt|,
modifier|*
name|save_node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|drop_node
operator|=
name|drop_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|save_node
operator|=
name|save_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|tp
operator|=
name|state
operator|->
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * If the dying block has lower hashvals, then move all the 	 * elements in the remaining block up to make a hole. 	 */
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|save_node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|save_node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
condition|)
block|{
name|btree
operator|=
operator|&
name|save_node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
expr_stmt|;
name|tmp
operator|=
name|INT_GET
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|btree
argument_list|,
operator|&
name|save_node
operator|->
name|btree
index|[
literal|0
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|btree
operator|=
operator|&
name|save_node
operator|->
name|btree
index|[
literal|0
index|]
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|save_node
argument_list|,
name|btree
argument_list|,
operator|(
name|INT_GET
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|btree
operator|=
operator|&
name|save_node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
index|]
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|save_node
argument_list|,
name|btree
argument_list|,
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Move all the B-tree elements from drop_blk to save_blk. 	 */
name|tmp
operator|=
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|btree
argument_list|,
operator|&
name|drop_node
operator|->
name|btree
index|[
literal|0
index|]
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|INT_MOD
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|INT_GET
argument_list|(
name|drop_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|save_node
argument_list|,
operator|&
name|save_node
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|save_node
operator|->
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Save the last hashval in the remaining block for upward propagation. 	 */
name|save_blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|save_node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|save_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Routines used for finding things in the Btree.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Walk down the Btree looking for a particular filename, filling  * in the state structure as we go.  *  * We will set the state structure to point to each of the elements  * in each of the nodes where either the hashval is or should be.  *  * We support duplicate hashval's so for each entry in the current  * node that could contain the desired hashval, descend.  This is a  * pruned depth-first tree search.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_da_node_lookup_int
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|curr
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|xfs_dablk_t
name|blkno
decl_stmt|;
name|int
name|probe
decl_stmt|,
name|span
decl_stmt|,
name|max
decl_stmt|,
name|error
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dahash_t
name|hashval
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
comment|/* 	 * Descend thru the B-tree searching each level for the right 	 * node to use, until the right hashval is found. 	 */
if|if
condition|(
name|args
operator|->
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
condition|)
name|blkno
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dirleafblk
expr_stmt|;
else|else
name|blkno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|,
name|state
operator|->
name|path
operator|.
name|active
operator|=
literal|1
init|;
name|state
operator|->
name|path
operator|.
name|active
operator|<=
name|XFS_DA_NODE_MAXDEPTH
condition|;
name|blk
operator|++
operator|,
name|state
operator|->
name|path
operator|.
name|active
operator|++
control|)
block|{
comment|/* 		 * Read the next node down in the tree. 		 */
name|blk
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|blk
operator|->
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|blk
operator|->
name|blkno
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|active
operator|--
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|curr
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
operator|||
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
operator|||
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
comment|/* 		 * Search an intermediate node for a match. 		 */
name|blk
operator|->
name|magic
operator|=
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
condition|)
block|{
name|node
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* 			 * Binary search.  (note: small blocks will skip loop) 			 */
name|max
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|probe
operator|=
name|span
operator|=
name|max
operator|/
literal|2
expr_stmt|;
name|hashval
operator|=
name|args
operator|->
name|hashval
expr_stmt|;
for|for
control|(
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
name|probe
index|]
init|;
name|span
operator|>
literal|4
condition|;
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
name|probe
index|]
control|)
block|{
name|span
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|hashval
condition|)
name|probe
operator|+=
name|span
expr_stmt|;
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
name|hashval
condition|)
name|probe
operator|-=
name|span
expr_stmt|;
else|else
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|probe
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|probe
operator|<
name|max
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|span
operator|<=
literal|4
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|hashval
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Since we may have duplicate hashval's, find the first 			 * matching hashval in the node. 			 */
while|while
condition|(
operator|(
name|probe
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>=
name|hashval
operator|)
condition|)
block|{
name|btree
operator|--
expr_stmt|;
name|probe
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|probe
operator|<
name|max
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|btree
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|hashval
operator|)
condition|)
block|{
name|btree
operator|++
expr_stmt|;
name|probe
operator|++
expr_stmt|;
block|}
comment|/* 			 * Pick the right block to descend on. 			 */
if|if
condition|(
name|probe
operator|==
name|max
condition|)
block|{
name|blk
operator|->
name|index
operator|=
name|max
operator|-
literal|1
expr_stmt|;
name|blkno
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|max
operator|-
literal|1
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blk
operator|->
name|index
operator|=
name|probe
expr_stmt|;
name|blkno
operator|=
name|INT_GET
argument_list|(
name|btree
operator|->
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__KERNEL__
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
condition|)
block|{
name|blk
operator|->
name|hashval
operator|=
name|xfs_attr_leaf_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
condition|)
block|{
name|blk
operator|->
name|hashval
operator|=
name|xfs_dir_leaf_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|curr
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
condition|)
block|{
name|blk
operator|->
name|hashval
operator|=
name|xfs_dir2_leafn_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * A leaf block that ends in the hashval that we are interested in 	 * (final hashval == search hashval) means that the next block may 	 * contain more entries with the same hashval, shift upward to the 	 * next leaf and keep searching. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_lookup_int
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
operator|&
name|blk
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR2_LEAFN_MAGIC
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir2_leafn_lookup_int
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
operator|&
name|blk
operator|->
name|index
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__KERNEL__
elseif|else
if|if
condition|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
condition|)
block|{
name|retval
operator|=
name|xfs_attr_leaf_lookup_int
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|blk
operator|->
name|index
operator|=
name|args
operator|->
name|index
expr_stmt|;
name|args
operator|->
name|blkno
operator|=
name|blk
operator|->
name|blkno
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|retval
operator|==
name|ENOENT
operator|)
operator|||
operator|(
name|retval
operator|==
name|ENOATTR
operator|)
operator|)
operator|&&
operator|(
name|blk
operator|->
name|hashval
operator|==
name|args
operator|->
name|hashval
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_da_path_shift
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
ifdef|#
directive|ifdef
name|__KERNEL__
elseif|else
if|if
condition|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
condition|)
block|{
comment|/* path_shift() gives ENOENT */
name|retval
operator|=
name|XFS_ERROR
argument_list|(
name|ENOATTR
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
block|}
operator|*
name|result
operator|=
name|retval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Utility routines.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Link a new block into a doubly linked list of blocks (of whatever type).  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_da_blk_link
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|old_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|new_blk
parameter_list|)
block|{
name|xfs_da_blkinfo_t
modifier|*
name|old_info
decl_stmt|,
modifier|*
name|new_info
decl_stmt|,
modifier|*
name|tmp_info
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|int
name|before
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|old_info
operator|=
name|old_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|new_info
operator|=
name|new_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|old_blk
operator|->
name|magic
operator|==
name|XFS_DA_NODE_MAGIC
operator|||
name|old_blk
operator|->
name|magic
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
operator|||
name|old_blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|old_blk
operator|->
name|magic
operator|==
name|INT_GET
argument_list|(
name|old_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_blk
operator|->
name|magic
operator|==
name|INT_GET
argument_list|(
name|new_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|old_blk
operator|->
name|magic
operator|==
name|new_blk
operator|->
name|magic
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|old_blk
operator|->
name|magic
condition|)
block|{
ifdef|#
directive|ifdef
name|__KERNEL__
case|case
name|XFS_ATTR_LEAF_MAGIC
case|:
name|before
operator|=
name|xfs_attr_leaf_order
argument_list|(
name|old_blk
operator|->
name|bp
argument_list|,
name|new_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|XFS_DIR_LEAF_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|before
operator|=
name|xfs_dir_leaf_order
argument_list|(
name|old_blk
operator|->
name|bp
argument_list|,
name|new_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DIR2_LEAFN_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|before
operator|=
name|xfs_dir2_leafn_order
argument_list|(
name|old_blk
operator|->
name|bp
argument_list|,
name|new_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DA_NODE_MAGIC
case|:
name|before
operator|=
name|xfs_da_node_order
argument_list|(
name|old_blk
operator|->
name|bp
argument_list|,
name|new_blk
operator|->
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Link blocks in appropriate order. 	 */
if|if
condition|(
name|before
condition|)
block|{
comment|/* 		 * Link new block in before existing block. 		 */
name|INT_SET
argument_list|(
name|new_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|old_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|new_info
operator|->
name|back
operator|=
name|old_info
operator|->
name|back
expr_stmt|;
comment|/* INT_: direct copy */
if|if
condition|(
name|INT_GET
argument_list|(
name|old_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|INT_GET
argument_list|(
name|old_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_info
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|INT_GET
argument_list|(
name|old_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|old_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|tmp_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|new_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|old_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|new_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Link new block in after existing block. 		 */
name|new_info
operator|->
name|forw
operator|=
name|old_info
operator|->
name|forw
expr_stmt|;
comment|/* INT_: direct copy */
name|INT_SET
argument_list|(
name|new_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|old_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|old_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|INT_GET
argument_list|(
name|old_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_info
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|INT_GET
argument_list|(
name|old_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|old_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|tmp_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|new_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|old_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|new_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
block|}
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|old_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|new_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two intermediate nodes for "order".  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_da_node_order
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|node1_bp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|node2_bp
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
name|node1
operator|=
name|node1_bp
operator|->
name|data
expr_stmt|;
name|node2
operator|=
name|node2_bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|node1
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|node2
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|INT_GET
argument_list|(
name|node1
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node1
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pick up the last hashvalue from an intermediate node.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_da_node_lasthash
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_ISZERO
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlink a block from a doubly linked list of blocks.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_da_blk_unlink
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|drop_blk
parameter_list|,
name|xfs_da_state_blk_t
modifier|*
name|save_blk
parameter_list|)
block|{
name|xfs_da_blkinfo_t
modifier|*
name|drop_info
decl_stmt|,
modifier|*
name|save_info
decl_stmt|,
modifier|*
name|tmp_info
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Set up environment. 	 */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|save_info
operator|=
name|save_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|drop_info
operator|=
name|drop_blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|save_blk
operator|->
name|magic
operator|==
name|XFS_DA_NODE_MAGIC
operator|||
name|save_blk
operator|->
name|magic
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
operator|||
name|save_blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|save_blk
operator|->
name|magic
operator|==
name|INT_GET
argument_list|(
name|save_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|drop_blk
operator|->
name|magic
operator|==
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|save_blk
operator|->
name|magic
operator|==
name|drop_blk
operator|->
name|magic
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|save_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|drop_blk
operator|->
name|blkno
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|save_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|drop_blk
operator|->
name|blkno
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|save_blk
operator|->
name|blkno
operator|)
operator|||
operator|(
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|save_blk
operator|->
name|blkno
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Unlink the leaf block from the doubly linked chain of leaves. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|save_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|drop_blk
operator|->
name|blkno
condition|)
block|{
name|save_info
operator|->
name|back
operator|=
name|drop_info
operator|->
name|back
expr_stmt|;
comment|/* INT_: direct copy */
if|if
condition|(
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_info
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|INT_GET
argument_list|(
name|save_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|drop_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|tmp_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|save_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|save_info
operator|->
name|forw
operator|=
name|drop_info
operator|->
name|forw
expr_stmt|;
comment|/* INT_: direct copy */
if|if
condition|(
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|INT_GET
argument_list|(
name|drop_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_info
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|INT_GET
argument_list|(
name|save_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|tmp_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|drop_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|tmp_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|save_blk
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmp_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|save_blk
operator|->
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|save_info
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move a path "forward" or "!forward" one block at the current level.  *  * This routine will adjust a "path" to point to the next block  * "forward" (higher hashvalues) or "!forward" (lower hashvals) in the  * Btree, including updating pointers to the intermediate nodes between  * the new bottom and the root.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_da_path_shift
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|,
name|xfs_da_state_path_t
modifier|*
name|path
parameter_list|,
name|int
name|forward
parameter_list|,
name|int
name|release
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
block|{
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
name|xfs_dablk_t
name|blkno
init|=
literal|0
decl_stmt|;
name|int
name|level
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Roll up the Btree looking for the first block where our 	 * current index is not at the edge of the block.  Note that 	 * we skip the bottom layer because we want the sibling block. 	 */
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|path
operator|->
name|active
operator|>
literal|0
operator|)
operator|&&
operator|(
name|path
operator|->
name|active
operator|<
name|XFS_DA_NODE_MAXDEPTH
operator|)
argument_list|)
expr_stmt|;
name|level
operator|=
operator|(
name|path
operator|->
name|active
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* skip bottom layer in path */
for|for
control|(
name|blk
operator|=
operator|&
name|path
operator|->
name|blk
index|[
name|level
index|]
init|;
name|level
operator|>=
literal|0
condition|;
name|blk
operator|--
operator|,
name|level
operator|--
control|)
block|{
name|ASSERT
argument_list|(
name|blk
operator|->
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
operator|&&
operator|(
name|blk
operator|->
name|index
operator|<
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|blk
operator|->
name|index
operator|++
expr_stmt|;
name|blkno
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|blk
operator|->
name|index
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|forward
operator|&&
operator|(
name|blk
operator|->
name|index
operator|>
literal|0
operator|)
condition|)
block|{
name|blk
operator|->
name|index
operator|--
expr_stmt|;
name|blkno
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|blk
operator|->
name|index
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|level
operator|<
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* we're out of our tree */
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Roll down the edge of the subtree until we reach the 	 * same depth we were at originally. 	 */
for|for
control|(
name|blk
operator|++
operator|,
name|level
operator|++
init|;
name|level
operator|<
name|path
operator|->
name|active
condition|;
name|blk
operator|++
operator|,
name|level
operator|++
control|)
block|{
comment|/* 		 * Release the old block. 		 * (if it's dirty, trans won't actually let go) 		 */
if|if
condition|(
name|release
condition|)
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Read the next child block. 		 */
name|blk
operator|->
name|blkno
operator|=
name|blkno
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
name|blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|blk
operator|->
name|bp
argument_list|,
name|args
operator|->
name|whichfork
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|=
name|blk
operator|->
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
operator|||
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
operator|||
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_ATTR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|blk
operator|->
name|magic
operator|=
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
condition|)
block|{
name|node
operator|=
operator|(
name|xfs_da_intnode_t
operator|*
operator|)
name|info
expr_stmt|;
name|blk
operator|->
name|hashval
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
condition|)
name|blk
operator|->
name|index
operator|=
literal|0
expr_stmt|;
else|else
name|blk
operator|->
name|index
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
expr_stmt|;
name|blkno
operator|=
name|INT_GET
argument_list|(
name|node
operator|->
name|btree
index|[
name|blk
operator|->
name|index
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|level
operator|==
name|path
operator|->
name|active
operator|-
literal|1
argument_list|)
expr_stmt|;
name|blk
operator|->
name|index
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|blk
operator|->
name|magic
condition|)
block|{
ifdef|#
directive|ifdef
name|__KERNEL__
case|case
name|XFS_ATTR_LEAF_MAGIC
case|:
name|blk
operator|->
name|hashval
operator|=
name|xfs_attr_leaf_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|XFS_DIR_LEAF_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|blk
operator|->
name|hashval
operator|=
name|xfs_dir_leaf_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_DIR2_LEAFN_MAGIC
case|:
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|blk
operator|->
name|hashval
operator|=
name|xfs_dir2_leafn_lasthash
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_ATTR_LEAF_MAGIC
operator|||
name|blk
operator|->
name|magic
operator|==
name|XFS_DIRX_LEAF_MAGIC
argument_list|(
name|state
operator|->
name|mp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * Utility routines.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Implement a simple hash on a character string.  * Rotate the hash value by 7 bits, then XOR each character in.  * This is implemented with some source-level loop unrolling.  */
end_comment

begin_function
name|xfs_dahash_t
name|xfs_da_hashname
parameter_list|(
specifier|const
name|uchar_t
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|xfs_dahash_t
name|hash
decl_stmt|;
define|#
directive|define
name|ROTL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)<< (y)) | ((x)>> (32 - (y))))
ifdef|#
directive|ifdef
name|SLOWVERSION
comment|/* 	 * This is the old one-byte-at-a-time version. 	 */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|namelen
operator|>
literal|0
condition|;
name|namelen
operator|--
control|)
block|{
name|hash
operator|=
operator|*
name|name
operator|++
operator|^
name|ROTL
argument_list|(
name|hash
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hash
operator|)
return|;
else|#
directive|else
comment|/* 	 * Do four characters at a time as long as we can. 	 */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|namelen
operator|>=
literal|4
condition|;
name|namelen
operator|-=
literal|4
operator|,
name|name
operator|+=
literal|4
control|)
block|{
name|hash
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|<<
literal|21
operator|)
operator|^
operator|(
name|name
index|[
literal|1
index|]
operator|<<
literal|14
operator|)
operator|^
operator|(
name|name
index|[
literal|2
index|]
operator|<<
literal|7
operator|)
operator|^
operator|(
name|name
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
operator|^
name|ROTL
argument_list|(
name|hash
argument_list|,
literal|7
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now do the rest of the characters. 	 */
switch|switch
condition|(
name|namelen
condition|)
block|{
case|case
literal|3
case|:
return|return
operator|(
name|name
index|[
literal|0
index|]
operator|<<
literal|14
operator|)
operator|^
operator|(
name|name
index|[
literal|1
index|]
operator|<<
literal|7
operator|)
operator|^
operator|(
name|name
index|[
literal|2
index|]
operator|<<
literal|0
operator|)
operator|^
name|ROTL
argument_list|(
name|hash
argument_list|,
literal|7
operator|*
literal|3
argument_list|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|name
index|[
literal|0
index|]
operator|<<
literal|7
operator|)
operator|^
operator|(
name|name
index|[
literal|1
index|]
operator|<<
literal|0
operator|)
operator|^
name|ROTL
argument_list|(
name|hash
argument_list|,
literal|7
operator|*
literal|2
argument_list|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|name
index|[
literal|0
index|]
operator|<<
literal|0
operator|)
operator|^
name|ROTL
argument_list|(
name|hash
argument_list|,
literal|7
operator|*
literal|1
argument_list|)
return|;
case|case
literal|0
case|:
return|return
name|hash
return|;
block|}
comment|/* NOTREACHED */
endif|#
directive|endif
undef|#
directive|undef
name|ROTL
return|return
literal|0
return|;
comment|/* keep gcc happy */
block|}
end_function

begin_comment
comment|/*  * Add a block to the btree ahead of the file.  * Return the new block number to the caller.  */
end_comment

begin_function
name|int
name|xfs_da_grow_inode
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
modifier|*
name|new_blkno
parameter_list|)
block|{
name|xfs_fileoff_t
name|bno
decl_stmt|,
name|b
decl_stmt|;
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
name|xfs_bmbt_irec_t
modifier|*
name|mapp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|nmap
decl_stmt|,
name|error
decl_stmt|,
name|w
decl_stmt|,
name|count
decl_stmt|,
name|c
decl_stmt|,
name|got
decl_stmt|,
name|i
decl_stmt|,
name|mapi
decl_stmt|;
name|xfs_fsize_t
name|size
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|w
operator|=
name|args
operator|->
name|whichfork
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * For new directories adjust the file offset and block count. 	 */
if|if
condition|(
name|w
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|bno
operator|=
name|mp
operator|->
name|m_dirleafblk
expr_stmt|;
name|count
operator|=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
block|}
else|else
block|{
name|bno
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Find a spot in the file space to put the new block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_first_unused
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|count
argument_list|,
operator|&
name|bno
argument_list|,
name|w
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|w
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|bno
operator|>=
name|mp
operator|->
name|m_dirleafblk
operator|&&
name|bno
operator|<
name|mp
operator|->
name|m_dirfreeblk
argument_list|)
expr_stmt|;
comment|/* 	 * Try mapping it in one filesystem block. 	 */
name|nmap
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|firstblock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
name|count
argument_list|,
name|XFS_BMAPI_AFLAG
argument_list|(
name|w
argument_list|)
operator||
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_METADATA
operator||
name|XFS_BMAPI_CONTIG
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|total
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
name|args
operator|->
name|flist
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|nmap
operator|<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmap
operator|==
literal|1
condition|)
block|{
name|mapp
operator|=
operator|&
name|map
expr_stmt|;
name|mapi
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we didn't get it and the block might work if fragmented, 	 * try without the CONTIG flag.  Loop until we get it all. 	 */
elseif|else
if|if
condition|(
name|nmap
operator|==
literal|0
operator|&&
name|count
operator|>
literal|1
condition|)
block|{
name|mapp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bno
operator|,
name|mapi
operator|=
literal|0
init|;
name|b
operator|<
name|bno
operator|+
name|count
condition|;
control|)
block|{
name|nmap
operator|=
name|MIN
argument_list|(
name|XFS_BMAP_MAX_NMAP
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|int
call|)
argument_list|(
name|bno
operator|+
name|count
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|XFS_BMAPI_AFLAG
argument_list|(
name|w
argument_list|)
operator||
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_METADATA
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|total
argument_list|,
operator|&
name|mapp
index|[
name|mapi
index|]
argument_list|,
operator|&
name|nmap
argument_list|,
name|args
operator|->
name|flist
argument_list|)
operator|)
condition|)
block|{
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|nmap
operator|<
literal|1
condition|)
break|break;
name|mapi
operator|+=
name|nmap
expr_stmt|;
name|b
operator|=
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_blockcount
expr_stmt|;
block|}
block|}
else|else
block|{
name|mapi
operator|=
literal|0
expr_stmt|;
name|mapp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Count the blocks we got, make sure it matches the total. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|got
operator|=
literal|0
init|;
name|i
operator|<
name|mapi
condition|;
name|i
operator|++
control|)
name|got
operator|+=
name|mapp
index|[
name|i
index|]
operator|.
name|br_blockcount
expr_stmt|;
if|if
condition|(
name|got
operator|!=
name|count
operator|||
name|mapp
index|[
literal|0
index|]
operator|.
name|br_startoff
operator|!=
name|bno
operator|||
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|mapp
index|[
name|mapi
operator|-
literal|1
index|]
operator|.
name|br_blockcount
operator|!=
name|bno
operator|+
name|count
condition|)
block|{
if|if
condition|(
name|mapp
operator|!=
operator|&
name|map
condition|)
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
if|if
condition|(
name|mapp
operator|!=
operator|&
name|map
condition|)
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
operator|*
name|new_blkno
operator|=
operator|(
name|xfs_dablk_t
operator|)
name|bno
expr_stmt|;
comment|/* 	 * For version 1 directories, adjust the file size if it changed. 	 */
if|if
condition|(
name|w
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V1
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|mapi
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|bno
argument_list|,
name|w
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|size
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|dp
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|size
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Ick.  We need to always be able to remove a btree block, even  * if there's no space reservation because the filesystem is full.  * This is called if xfs_bunmapi on a btree block fails due to ENOSPC.  * It swaps the target block with the last block in the file.  The  * last block in the file can always be removed since it can't cause  * a bmap btree split to do that.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_da_swap_lastblock
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
modifier|*
name|dead_blknop
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|dead_bufp
parameter_list|)
block|{
name|xfs_dablk_t
name|dead_blkno
decl_stmt|,
name|last_blkno
decl_stmt|,
name|sib_blkno
decl_stmt|,
name|par_blkno
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|dead_buf
decl_stmt|,
modifier|*
name|last_buf
decl_stmt|,
modifier|*
name|sib_buf
decl_stmt|,
modifier|*
name|par_buf
decl_stmt|;
name|xfs_fileoff_t
name|lastoff
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|w
decl_stmt|,
name|entno
decl_stmt|,
name|level
decl_stmt|,
name|dead_level
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|dead_info
decl_stmt|,
modifier|*
name|sib_info
decl_stmt|;
name|xfs_da_intnode_t
modifier|*
name|par_node
decl_stmt|,
modifier|*
name|dead_node
decl_stmt|;
name|xfs_dir_leafblock_t
modifier|*
name|dead_leaf
decl_stmt|;
name|xfs_dir2_leaf_t
modifier|*
name|dead_leaf2
decl_stmt|;
name|xfs_dahash_t
name|dead_hash
decl_stmt|;
name|dead_buf
operator|=
operator|*
name|dead_bufp
expr_stmt|;
name|dead_blkno
operator|=
operator|*
name|dead_blknop
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|ip
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|w
operator|=
name|args
operator|->
name|whichfork
expr_stmt|;
name|ASSERT
argument_list|(
name|w
operator|==
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|lastoff
operator|=
name|mp
operator|->
name|m_dirfreeblk
expr_stmt|;
name|error
operator|=
name|xfs_bmap_last_before
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|lastoff
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
operator|&
name|lastoff
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|unlikely
argument_list|(
name|lastoff
operator|==
literal|0
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Read the last block in the btree space. 	 */
name|last_blkno
operator|=
operator|(
name|xfs_dablk_t
operator|)
name|lastoff
operator|-
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|last_blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|last_buf
argument_list|,
name|w
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Copy the last block into the dead buffer and log it. 	 */
name|memcpy
argument_list|(
name|dead_buf
operator|->
name|data
argument_list|,
name|last_buf
operator|->
name|data
argument_list|,
name|mp
operator|->
name|m_dirblksize
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|dead_buf
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_dirblksize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dead_info
operator|=
name|dead_buf
operator|->
name|data
expr_stmt|;
comment|/* 	 * Get values from the moved block. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V1
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|dead_leaf
operator|=
operator|(
name|xfs_dir_leafblock_t
operator|*
operator|)
name|dead_info
expr_stmt|;
name|dead_level
operator|=
literal|0
expr_stmt|;
name|dead_hash
operator|=
name|INT_GET
argument_list|(
name|dead_leaf
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|dead_leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|dead_leaf2
operator|=
operator|(
name|xfs_dir2_leaf_t
operator|*
operator|)
name|dead_info
expr_stmt|;
name|dead_level
operator|=
literal|0
expr_stmt|;
name|dead_hash
operator|=
name|INT_GET
argument_list|(
name|dead_leaf2
operator|->
name|ents
index|[
name|INT_GET
argument_list|(
name|dead_leaf2
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DA_NODE_MAGIC
argument_list|)
expr_stmt|;
name|dead_node
operator|=
operator|(
name|xfs_da_intnode_t
operator|*
operator|)
name|dead_info
expr_stmt|;
name|dead_level
operator|=
name|INT_GET
argument_list|(
name|dead_node
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|dead_hash
operator|=
name|INT_GET
argument_list|(
name|dead_node
operator|->
name|btree
index|[
name|INT_GET
argument_list|(
name|dead_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
name|sib_buf
operator|=
name|par_buf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If the moved block has a left sibling, fix up the pointers. 	 */
if|if
condition|(
operator|(
name|sib_blkno
operator|=
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|sib_blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|sib_buf
argument_list|,
name|w
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|sib_info
operator|=
name|sib_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|sib_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|last_blkno
operator|||
name|INT_GET
argument_list|(
name|sib_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|INT_SET
argument_list|(
name|sib_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|dead_blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|sib_buf
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|sib_info
argument_list|,
operator|&
name|sib_info
operator|->
name|forw
argument_list|,
sizeof|sizeof
argument_list|(
name|sib_info
operator|->
name|forw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|sib_buf
argument_list|)
expr_stmt|;
name|sib_buf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the moved block has a right sibling, fix up the pointers. 	 */
if|if
condition|(
operator|(
name|sib_blkno
operator|=
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|sib_blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|sib_buf
argument_list|,
name|w
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|sib_info
operator|=
name|sib_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|sib_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|last_blkno
operator|||
name|INT_GET
argument_list|(
name|sib_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|INT_GET
argument_list|(
name|dead_info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|INT_SET
argument_list|(
name|sib_info
operator|->
name|back
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|dead_blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|sib_buf
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|sib_info
argument_list|,
operator|&
name|sib_info
operator|->
name|back
argument_list|,
sizeof|sizeof
argument_list|(
name|sib_info
operator|->
name|back
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|sib_buf
argument_list|)
expr_stmt|;
name|sib_buf
operator|=
name|NULL
expr_stmt|;
block|}
name|par_blkno
operator|=
name|XFS_DIR_IS_V1
argument_list|(
name|mp
argument_list|)
condition|?
literal|0
else|:
name|mp
operator|->
name|m_dirleafblk
expr_stmt|;
name|level
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Walk down the tree looking for the parent of the moved block. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|par_blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|par_buf
argument_list|,
name|w
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|par_node
operator|=
name|par_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DA_NODE_MAGIC
operator|||
operator|(
name|level
operator|>=
literal|0
operator|&&
name|level
operator|!=
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(4)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|level
operator|=
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
for|for
control|(
name|entno
operator|=
literal|0
init|;
name|entno
operator|<
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&&
name|INT_GET
argument_list|(
name|par_node
operator|->
name|btree
index|[
name|entno
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|dead_hash
condition|;
name|entno
operator|++
control|)
continue|continue;
if|if
condition|(
name|unlikely
argument_list|(
name|entno
operator|==
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(5)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|par_blkno
operator|=
name|INT_GET
argument_list|(
name|par_node
operator|->
name|btree
index|[
name|entno
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|dead_level
operator|+
literal|1
condition|)
break|break;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|par_buf
argument_list|)
expr_stmt|;
name|par_buf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * We're in the right parent block. 	 * Look for the right entry. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|entno
operator|<
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&&
name|INT_GET
argument_list|(
name|par_node
operator|->
name|btree
index|[
name|entno
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|last_blkno
condition|;
name|entno
operator|++
control|)
continue|continue;
if|if
condition|(
name|entno
operator|<
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
break|break;
name|par_blkno
operator|=
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|par_buf
argument_list|)
expr_stmt|;
name|par_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|par_blkno
operator|==
literal|0
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(6)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|par_blkno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|par_buf
argument_list|,
name|w
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|par_node
operator|=
name|par_buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|level
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|level
operator|||
name|INT_GET
argument_list|(
name|par_node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DA_NODE_MAGIC
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_swap_lastblock(7)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|entno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Update the parent entry pointing to the moved block. 	 */
name|INT_SET
argument_list|(
name|par_node
operator|->
name|btree
index|[
name|entno
index|]
operator|.
name|before
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|dead_blkno
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|par_buf
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|par_node
argument_list|,
operator|&
name|par_node
operator|->
name|btree
index|[
name|entno
index|]
operator|.
name|before
argument_list|,
sizeof|sizeof
argument_list|(
name|par_node
operator|->
name|btree
index|[
name|entno
index|]
operator|.
name|before
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|par_buf
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|dead_buf
argument_list|)
expr_stmt|;
operator|*
name|dead_blknop
operator|=
name|last_blkno
expr_stmt|;
operator|*
name|dead_bufp
operator|=
name|last_buf
expr_stmt|;
return|return
literal|0
return|;
name|done
label|:
if|if
condition|(
name|par_buf
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|par_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sib_buf
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|sib_buf
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|last_buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a btree block from a directory or attribute.  */
end_comment

begin_function
name|int
name|xfs_da_shrink_inode
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dablk_t
name|dead_blkno
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|dead_buf
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
name|int
name|done
decl_stmt|,
name|error
decl_stmt|,
name|w
decl_stmt|,
name|count
decl_stmt|;
name|xfs_fileoff_t
name|bno
decl_stmt|;
name|xfs_fsize_t
name|size
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|w
operator|=
name|args
operator|->
name|whichfork
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|)
name|count
operator|=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
else|else
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Remove extents.  If we get ENOSPC for a dir we have to move 		 * the last block to the place we want to kill. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bunmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|dead_blkno
argument_list|,
name|count
argument_list|,
name|XFS_BMAPI_AFLAG
argument_list|(
name|w
argument_list|)
operator||
name|XFS_BMAPI_METADATA
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|firstblock
argument_list|,
name|args
operator|->
name|flist
argument_list|,
operator|&
name|done
argument_list|)
operator|)
operator|==
name|ENOSPC
condition|)
block|{
if|if
condition|(
name|w
operator|!=
name|XFS_DATA_FORK
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_swap_lastblock
argument_list|(
name|args
argument_list|,
operator|&
name|dead_blkno
argument_list|,
operator|&
name|dead_buf
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
else|else
break|break;
block|}
name|ASSERT
argument_list|(
name|done
argument_list|)
expr_stmt|;
name|xfs_da_binval
argument_list|(
name|tp
argument_list|,
name|dead_buf
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the directory size for version 1. 	 */
if|if
condition|(
name|w
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V1
argument_list|(
name|mp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|bno
argument_list|,
name|w
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|size
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|dp
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|size
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|done
label|:
name|xfs_da_binval
argument_list|(
name|tp
argument_list|,
name|dead_buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * See if the mapping(s) for this btree block are valid, i.e.  * don't contain holes, are logically contiguous, and cover the whole range.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_da_map_covers_blocks
parameter_list|(
name|int
name|nmap
parameter_list|,
name|xfs_bmbt_irec_t
modifier|*
name|mapp
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xfs_fileoff_t
name|off
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|off
operator|=
name|bno
init|;
name|i
operator|<
name|nmap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mapp
index|[
name|i
index|]
operator|.
name|br_startblock
operator|==
name|HOLESTARTBLOCK
operator|||
name|mapp
index|[
name|i
index|]
operator|.
name|br_startblock
operator|==
name|DELAYSTARTBLOCK
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|off
operator|!=
name|mapp
index|[
name|i
index|]
operator|.
name|br_startoff
condition|)
block|{
return|return
literal|0
return|;
block|}
name|off
operator|+=
name|mapp
index|[
name|i
index|]
operator|.
name|br_blockcount
expr_stmt|;
block|}
return|return
name|off
operator|==
name|bno
operator|+
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Make a dabuf.  * Used for get_buf, read_buf, read_bufr, and reada_buf.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_da_do_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|,
name|xfs_daddr_t
modifier|*
name|mappedbnop
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
name|int
name|whichfork
parameter_list|,
name|int
name|caller
parameter_list|,
name|inst_t
modifier|*
name|ra
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
name|xfs_buf_t
modifier|*
modifier|*
name|bplist
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
name|xfs_bmbt_irec_t
modifier|*
name|mapp
decl_stmt|;
name|xfs_daddr_t
name|mappedbno
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|nbplist
init|=
literal|0
decl_stmt|;
name|int
name|nfsb
decl_stmt|;
name|int
name|nmap
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|rbp
decl_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
if|if
condition|(
name|whichfork
operator|==
name|XFS_DATA_FORK
operator|&&
name|XFS_DIR_IS_V2
argument_list|(
name|mp
argument_list|)
condition|)
name|nfsb
operator|=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
else|else
name|nfsb
operator|=
literal|1
expr_stmt|;
name|mappedbno
operator|=
operator|*
name|mappedbnop
expr_stmt|;
comment|/* 	 * Caller doesn't have a mapping.  -2 means don't complain 	 * if we land in a hole. 	 */
if|if
condition|(
name|mappedbno
operator|==
operator|-
literal|1
operator|||
name|mappedbno
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* 		 * Optimize the one-block case. 		 */
if|if
condition|(
name|nfsb
operator|==
literal|1
condition|)
block|{
name|xfs_fsblock_t
name|fsb
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi_single
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|whichfork
argument_list|,
operator|&
name|fsb
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|bno
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|mapp
operator|=
operator|&
name|map
expr_stmt|;
if|if
condition|(
name|fsb
operator|==
name|NULLFSBLOCK
condition|)
block|{
name|nmap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|br_startblock
operator|=
name|fsb
expr_stmt|;
name|map
operator|.
name|br_startoff
operator|=
operator|(
name|xfs_fileoff_t
operator|)
name|bno
expr_stmt|;
name|map
operator|.
name|br_blockcount
operator|=
literal|1
expr_stmt|;
name|nmap
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|mapp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|nfsb
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|nmap
operator|=
name|nfsb
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
operator|(
name|xfs_fileoff_t
operator|)
name|bno
argument_list|,
name|nfsb
argument_list|,
name|XFS_BMAPI_METADATA
operator||
name|XFS_BMAPI_AFLAG
argument_list|(
name|whichfork
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mapp
argument_list|,
operator|&
name|nmap
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|exit0
goto|;
block|}
block|}
else|else
block|{
name|map
operator|.
name|br_startblock
operator|=
name|XFS_DADDR_TO_FSB
argument_list|(
name|mp
argument_list|,
name|mappedbno
argument_list|)
expr_stmt|;
name|map
operator|.
name|br_startoff
operator|=
operator|(
name|xfs_fileoff_t
operator|)
name|bno
expr_stmt|;
name|map
operator|.
name|br_blockcount
operator|=
name|nfsb
expr_stmt|;
name|mapp
operator|=
operator|&
name|map
expr_stmt|;
name|nmap
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xfs_da_map_covers_blocks
argument_list|(
name|nmap
argument_list|,
name|mapp
argument_list|,
name|bno
argument_list|,
name|nfsb
argument_list|)
condition|)
block|{
name|error
operator|=
name|mappedbno
operator|==
operator|-
literal|2
condition|?
literal|0
else|:
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|error
operator|==
name|EFSCORRUPTED
argument_list|)
condition|)
block|{
if|if
condition|(
name|xfs_error_level
operator|>=
name|XFS_ERRLEVEL_LOW
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"xfs_da_do_buf: bno %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"dir: inode %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|dp
operator|->
name|i_ino
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmap
condition|;
name|i
operator|++
control|)
block|{
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d\n"
argument_list|,
name|i
argument_list|,
name|mapp
index|[
name|i
index|]
operator|.
name|br_startoff
argument_list|,
name|mapp
index|[
name|i
index|]
operator|.
name|br_startblock
argument_list|,
name|mapp
index|[
name|i
index|]
operator|.
name|br_blockcount
argument_list|,
name|mapp
index|[
name|i
index|]
operator|.
name|br_state
argument_list|)
expr_stmt|;
block|}
block|}
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_da_do_buf(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit0
goto|;
block|}
if|if
condition|(
name|caller
operator|!=
literal|3
operator|&&
name|nmap
operator|>
literal|1
condition|)
block|{
name|bplist
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
operator|*
name|nmap
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|nbplist
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bplist
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Turn the mapping(s) into buffer(s). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmap
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nmapped
decl_stmt|;
name|mappedbno
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|mapp
index|[
name|i
index|]
operator|.
name|br_startblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|*
name|mappedbnop
operator|=
name|mappedbno
expr_stmt|;
name|nmapped
operator|=
operator|(
name|int
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mapp
index|[
name|i
index|]
operator|.
name|br_blockcount
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|caller
condition|)
block|{
case|case
literal|0
case|:
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|trans
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|mappedbno
argument_list|,
name|nmapped
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|bp
condition|?
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
else|:
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
ifndef|#
directive|ifndef
name|__KERNEL__
case|case
literal|2
case|:
endif|#
directive|endif
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|trans
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|mappedbno
argument_list|,
name|nmapped
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|__KERNEL__
case|case
literal|3
case|:
name|xfs_baread
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|mappedbno
argument_list|,
name|nmapped
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bp
condition|)
name|xfs_trans_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|exit1
goto|;
block|}
if|if
condition|(
operator|!
name|bp
condition|)
continue|continue;
if|if
condition|(
name|caller
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|whichfork
operator|==
name|XFS_ATTR_FORK
condition|)
block|{
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_ATTR_BTREE
argument_list|,
name|XFS_ATTR_BTREE_REF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XFS_BUF_SET_VTYPE_REF
argument_list|(
name|bp
argument_list|,
name|B_FS_DIR_BTREE
argument_list|,
name|XFS_DIR_BTREE_REF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bplist
condition|)
block|{
name|bplist
index|[
name|nbplist
operator|++
index|]
operator|=
name|bp
expr_stmt|;
block|}
block|}
comment|/* 	 * Build a dabuf structure. 	 */
if|if
condition|(
name|bplist
condition|)
block|{
name|rbp
operator|=
name|xfs_da_buf_make
argument_list|(
name|nbplist
argument_list|,
name|bplist
argument_list|,
name|ra
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
condition|)
name|rbp
operator|=
name|xfs_da_buf_make
argument_list|(
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|ra
argument_list|)
expr_stmt|;
else|else
name|rbp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For read_buf, check the magic number. 	 */
if|if
condition|(
name|caller
operator|==
literal|1
condition|)
block|{
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
name|xfs_da_blkinfo_t
modifier|*
name|info
decl_stmt|;
name|uint
name|magic
decl_stmt|,
name|magic1
decl_stmt|;
name|info
operator|=
name|rbp
operator|->
name|data
expr_stmt|;
name|data
operator|=
name|rbp
operator|->
name|data
expr_stmt|;
name|free
operator|=
name|rbp
operator|->
name|data
expr_stmt|;
name|magic
operator|=
name|INT_GET
argument_list|(
name|info
operator|->
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|magic1
operator|=
name|INT_GET
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|XFS_TEST_ERROR
argument_list|(
operator|(
name|magic
operator|!=
name|XFS_DA_NODE_MAGIC
operator|)
operator|&&
operator|(
name|magic
operator|!=
name|XFS_DIR_LEAF_MAGIC
operator|)
operator|&&
operator|(
name|magic
operator|!=
name|XFS_ATTR_LEAF_MAGIC
operator|)
operator|&&
operator|(
name|magic
operator|!=
name|XFS_DIR2_LEAF1_MAGIC
operator|)
operator|&&
operator|(
name|magic
operator|!=
name|XFS_DIR2_LEAFN_MAGIC
operator|)
operator|&&
operator|(
name|magic1
operator|!=
name|XFS_DIR2_BLOCK_MAGIC
operator|)
operator|&&
operator|(
name|magic1
operator|!=
name|XFS_DIR2_DATA_MAGIC
operator|)
operator|&&
operator|(
name|INT_GET
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DIR2_FREE_MAGIC
operator|)
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_DA_READ_BUF
argument_list|,
name|XFS_RANDOM_DA_READ_BUF
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_buftrace
argument_list|(
literal|"DA READ ERROR"
argument_list|,
name|rbp
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_da_do_buf(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|rbp
argument_list|)
expr_stmt|;
name|nbplist
operator|=
literal|0
expr_stmt|;
goto|goto
name|exit1
goto|;
block|}
block|}
if|if
condition|(
name|bplist
condition|)
block|{
name|kmem_free
argument_list|(
name|bplist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
operator|*
name|nmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapp
operator|!=
operator|&
name|map
condition|)
block|{
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|nfsb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bpp
condition|)
operator|*
name|bpp
operator|=
name|rbp
expr_stmt|;
return|return
literal|0
return|;
name|exit1
label|:
if|if
condition|(
name|bplist
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbplist
condition|;
name|i
operator|++
control|)
name|xfs_trans_brelse
argument_list|(
name|trans
argument_list|,
name|bplist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|bplist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
operator|*
name|nmap
argument_list|)
expr_stmt|;
block|}
name|exit0
label|:
if|if
condition|(
name|mapp
operator|!=
operator|&
name|map
condition|)
name|kmem_free
argument_list|(
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapp
argument_list|)
operator|*
name|nfsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpp
condition|)
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the dir/attr block.  */
end_comment

begin_function
name|int
name|xfs_da_get_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|,
name|xfs_daddr_t
name|mappedbno
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
return|return
name|xfs_da_do_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
operator|&
name|mappedbno
argument_list|,
name|bpp
argument_list|,
name|whichfork
argument_list|,
literal|0
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the dir/attr block, fill in the contents.  */
end_comment

begin_function
name|int
name|xfs_da_read_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|,
name|xfs_daddr_t
name|mappedbno
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
return|return
name|xfs_da_do_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
operator|&
name|mappedbno
argument_list|,
name|bpp
argument_list|,
name|whichfork
argument_list|,
literal|1
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Readahead the dir/attr block.  */
end_comment

begin_function
name|xfs_daddr_t
name|xfs_da_reada_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|,
name|int
name|whichfork
parameter_list|)
block|{
name|xfs_daddr_t
name|rval
decl_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xfs_da_do_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
operator|&
name|rval
argument_list|,
name|NULL
argument_list|,
name|whichfork
argument_list|,
literal|3
argument_list|,
operator|(
name|inst_t
operator|*
operator|)
name|__return_address
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the number of bits needed to hold i different values.  */
end_comment

begin_function
name|uint
name|xfs_da_log2_roundup
parameter_list|(
name|uint
name|i
parameter_list|)
block|{
name|uint
name|rval
decl_stmt|;
for|for
control|(
name|rval
operator|=
literal|0
init|;
name|rval
operator|<
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|i
argument_list|)
condition|;
name|rval
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|rval
operator|)
operator|>=
name|i
condition|)
break|break;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_da_state_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* anchor for state struct zone */
end_comment

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_dabuf_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dabuf zone */
end_comment

begin_comment
comment|/*  * Allocate a dir-state structure.  * We don't put them on the stack since they're large.  */
end_comment

begin_function
name|xfs_da_state_t
modifier|*
name|xfs_da_state_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|kmem_zone_zalloc
argument_list|(
name|xfs_da_state_zone
argument_list|,
name|KM_SLEEP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kill the altpath contents of a da-state structure.  */
end_comment

begin_function
name|void
name|xfs_da_state_kill_altpath
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|altpath
operator|.
name|active
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|->
name|altpath
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|altpath
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|!=
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
condition|)
name|xfs_da_buf_done
argument_list|(
name|state
operator|->
name|altpath
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|altpath
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|state
operator|->
name|altpath
operator|.
name|active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a da-state structure.  */
end_comment

begin_function
name|void
name|xfs_da_state_free
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xfs_da_state_kill_altpath
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|path
operator|.
name|active
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
condition|)
name|xfs_da_buf_done
argument_list|(
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|extravalid
operator|&&
name|state
operator|->
name|extrablk
operator|.
name|bp
condition|)
name|xfs_da_buf_done
argument_list|(
name|state
operator|->
name|extrablk
operator|.
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|kmem_zone_free
argument_list|(
name|xfs_da_state_zone
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_DABUF_DEBUG
end_ifdef

begin_decl_stmt
name|xfs_dabuf_t
modifier|*
name|xfs_dabuf_global_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lock_t
name|xfs_dabuf_global_lock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Create a dabuf.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|xfs_dabuf_t
modifier|*
name|xfs_da_buf_make
parameter_list|(
name|int
name|nbuf
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
name|bps
parameter_list|,
name|inst_t
modifier|*
name|ra
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|dabuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|off
decl_stmt|;
if|if
condition|(
name|nbuf
operator|==
literal|1
condition|)
name|dabuf
operator|=
name|kmem_zone_alloc
argument_list|(
name|xfs_dabuf_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
else|else
name|dabuf
operator|=
name|kmem_alloc
argument_list|(
name|XFS_DA_BUF_SIZE
argument_list|(
name|nbuf
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dabuf
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_DABUF_DEBUG
name|dabuf
operator|->
name|ra
operator|=
name|ra
expr_stmt|;
name|dabuf
operator|->
name|target
operator|=
name|XFS_BUF_TARGET
argument_list|(
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dabuf
operator|->
name|blkno
operator|=
name|XFS_BUF_ADDR
argument_list|(
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nbuf
operator|==
literal|1
condition|)
block|{
name|dabuf
operator|->
name|nbuf
operator|=
literal|1
expr_stmt|;
name|bp
operator|=
name|bps
index|[
literal|0
index|]
expr_stmt|;
name|dabuf
operator|->
name|bbcount
operator|=
operator|(
name|short
operator|)
name|BTOBB
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|dabuf
operator|->
name|data
operator|=
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
name|dabuf
operator|->
name|nbuf
operator|=
name|nbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dabuf
operator|->
name|bbcount
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|dabuf
operator|->
name|bps
index|[
name|i
index|]
operator|=
name|bp
operator|=
name|bps
index|[
name|i
index|]
expr_stmt|;
name|dabuf
operator|->
name|bbcount
operator|+=
name|BTOBB
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dabuf
operator|->
name|data
operator|=
name|kmem_alloc
argument_list|(
name|BBTOB
argument_list|(
name|dabuf
operator|->
name|bbcount
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
operator|,
name|off
operator|+=
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
control|)
block|{
name|bp
operator|=
name|bps
index|[
name|i
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dabuf
operator|->
name|data
operator|+
name|off
argument_list|,
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|XFS_DABUF_DEBUG
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xfs_dabuf_t
modifier|*
name|p
decl_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|xfs_dabuf_global_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|xfs_dabuf_global_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|ASSERT
argument_list|(
name|p
operator|->
name|blkno
operator|!=
name|dabuf
operator|->
name|blkno
operator|||
name|p
operator|->
name|target
operator|!=
name|dabuf
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
name|dabuf
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xfs_dabuf_global_list
condition|)
name|xfs_dabuf_global_list
operator|->
name|prev
operator|=
name|dabuf
expr_stmt|;
name|dabuf
operator|->
name|next
operator|=
name|xfs_dabuf_global_list
expr_stmt|;
name|xfs_dabuf_global_list
operator|=
name|dabuf
expr_stmt|;
name|mutex_spinunlock
argument_list|(
operator|&
name|xfs_dabuf_global_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|dabuf
return|;
block|}
end_function

begin_comment
comment|/*  * Un-dirty a dabuf.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_da_buf_clean
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|dabuf
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|off
decl_stmt|;
if|if
condition|(
name|dabuf
operator|->
name|dirty
condition|)
block|{
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|nbuf
operator|>
literal|1
argument_list|)
expr_stmt|;
name|dabuf
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
operator|=
literal|0
init|;
name|i
operator|<
name|dabuf
operator|->
name|nbuf
condition|;
name|i
operator|++
operator|,
name|off
operator|+=
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
control|)
block|{
name|bp
operator|=
name|dabuf
operator|->
name|bps
index|[
name|i
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dabuf
operator|->
name|data
operator|+
name|off
argument_list|,
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Release a dabuf.  */
end_comment

begin_function
name|void
name|xfs_da_buf_done
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|dabuf
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dabuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|nbuf
operator|&&
name|dabuf
operator|->
name|data
operator|&&
name|dabuf
operator|->
name|bbcount
operator|&&
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dabuf
operator|->
name|dirty
condition|)
name|xfs_da_buf_clean
argument_list|(
name|dabuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dabuf
operator|->
name|nbuf
operator|>
literal|1
condition|)
name|kmem_free
argument_list|(
name|dabuf
operator|->
name|data
argument_list|,
name|BBTOB
argument_list|(
name|dabuf
operator|->
name|bbcount
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_DABUF_DEBUG
block|{
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|xfs_dabuf_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dabuf
operator|->
name|prev
condition|)
name|dabuf
operator|->
name|prev
operator|->
name|next
operator|=
name|dabuf
operator|->
name|next
expr_stmt|;
else|else
name|xfs_dabuf_global_list
operator|=
name|dabuf
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dabuf
operator|->
name|next
condition|)
name|dabuf
operator|->
name|next
operator|->
name|prev
operator|=
name|dabuf
operator|->
name|prev
expr_stmt|;
name|mutex_spinunlock
argument_list|(
operator|&
name|xfs_dabuf_global_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|dabuf
argument_list|,
literal|0
argument_list|,
name|XFS_DA_BUF_SIZE
argument_list|(
name|dabuf
operator|->
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dabuf
operator|->
name|nbuf
operator|==
literal|1
condition|)
name|kmem_zone_free
argument_list|(
name|xfs_dabuf_zone
argument_list|,
name|dabuf
argument_list|)
expr_stmt|;
else|else
name|kmem_free
argument_list|(
name|dabuf
argument_list|,
name|XFS_DA_BUF_SIZE
argument_list|(
name|dabuf
operator|->
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log transaction from a dabuf.  */
end_comment

begin_function
name|void
name|xfs_da_log_buf
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|dabuf
parameter_list|,
name|uint
name|first
parameter_list|,
name|uint
name|last
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|uint
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint
name|l
decl_stmt|;
name|int
name|off
decl_stmt|;
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|nbuf
operator|&&
name|dabuf
operator|->
name|data
operator|&&
name|dabuf
operator|->
name|bbcount
operator|&&
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dabuf
operator|->
name|nbuf
operator|==
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|data
operator|==
operator|(
name|void
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
return|return;
block|}
name|dabuf
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|first
operator|<=
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
operator|=
literal|0
init|;
name|i
operator|<
name|dabuf
operator|->
name|nbuf
condition|;
name|i
operator|++
operator|,
name|off
operator|+=
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
control|)
block|{
name|bp
operator|=
name|dabuf
operator|->
name|bps
index|[
name|i
index|]
expr_stmt|;
name|f
operator|=
name|off
expr_stmt|;
name|l
operator|=
name|f
operator|+
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|<
name|first
condition|)
name|f
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|last
condition|)
name|l
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|f
operator|<=
name|l
condition|)
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|f
operator|-
name|off
argument_list|,
name|l
operator|-
name|off
argument_list|)
expr_stmt|;
comment|/* 		 * B_DONE is set by xfs_trans_log buf. 		 * If we don't set it on a new buffer (get not read) 		 * then if we don't put anything in the buffer it won't 		 * be set, and at commit it it released into the cache, 		 * and then a read will fail. 		 */
elseif|else
if|if
condition|(
operator|!
operator|(
name|XFS_BUF_ISDONE
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
name|XFS_BUF_DONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|last
operator|<
name|off
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release dabuf from a transaction.  * Have to free up the dabuf before the buffers are released,  * since the synchronization on the dabuf is really the lock on the buffer.  */
end_comment

begin_function
name|void
name|xfs_da_brelse
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|dabuf
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_buf_t
modifier|*
modifier|*
name|bplist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nbuf
decl_stmt|;
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|nbuf
operator|&&
name|dabuf
operator|->
name|data
operator|&&
name|dabuf
operator|->
name|bbcount
operator|&&
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nbuf
operator|=
name|dabuf
operator|->
name|nbuf
operator|)
operator|==
literal|1
condition|)
block|{
name|bplist
operator|=
operator|&
name|bp
expr_stmt|;
name|bp
operator|=
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|bplist
operator|=
name|kmem_alloc
argument_list|(
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bplist
argument_list|,
name|dabuf
operator|->
name|bps
argument_list|,
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|dabuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bplist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bplist
operator|!=
operator|&
name|bp
condition|)
name|kmem_free
argument_list|(
name|bplist
argument_list|,
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invalidate dabuf from a transaction.  */
end_comment

begin_function
name|void
name|xfs_da_binval
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|dabuf
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_buf_t
modifier|*
modifier|*
name|bplist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nbuf
decl_stmt|;
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|nbuf
operator|&&
name|dabuf
operator|->
name|data
operator|&&
name|dabuf
operator|->
name|bbcount
operator|&&
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nbuf
operator|=
name|dabuf
operator|->
name|nbuf
operator|)
operator|==
literal|1
condition|)
block|{
name|bplist
operator|=
operator|&
name|bp
expr_stmt|;
name|bp
operator|=
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|bplist
operator|=
name|kmem_alloc
argument_list|(
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bplist
argument_list|,
name|dabuf
operator|->
name|bps
argument_list|,
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|dabuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
name|xfs_trans_binval
argument_list|(
name|tp
argument_list|,
name|bplist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bplist
operator|!=
operator|&
name|bp
condition|)
name|kmem_free
argument_list|(
name|bplist
argument_list|,
name|nbuf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bplist
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the first daddr from a dabuf.  */
end_comment

begin_function
name|xfs_daddr_t
name|xfs_da_blkno
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|dabuf
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dabuf
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|XFS_BUF_ADDR
argument_list|(
name|dabuf
operator|->
name|bps
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

end_unit

