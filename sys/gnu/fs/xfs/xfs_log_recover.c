begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_imap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log_recover.h"
end_include

begin_include
include|#
directive|include
file|"xfs_extfree_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_function_decl
name|STATIC
name|int
name|xlog_find_zeroed
parameter_list|(
name|xlog_t
modifier|*
parameter_list|,
name|xfs_daddr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xlog_clear_stale_blocks
parameter_list|(
name|xlog_t
modifier|*
parameter_list|,
name|xfs_lsn_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_recover_insert_item_backq
parameter_list|(
name|xlog_recover_item_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_function_decl
name|STATIC
name|void
name|xlog_recover_check_summary
parameter_list|(
name|xlog_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xlog_recover_check_ail
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_log_item_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xlog_recover_check_summary
parameter_list|(
name|log
parameter_list|)
end_define

begin_define
define|#
directive|define
name|xlog_recover_check_ail
parameter_list|(
name|mp
parameter_list|,
name|lip
parameter_list|,
name|gen
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Sector aligned buffer routines for buffer create/read/write/access  */
end_comment

begin_define
define|#
directive|define
name|XLOG_SECTOR_ROUNDUP_BBCOUNT
parameter_list|(
name|log
parameter_list|,
name|bbs
parameter_list|)
define|\
value|( ((log)->l_sectbb_mask&& (bbs& (log)->l_sectbb_mask)) ? \ 	((bbs + (log)->l_sectbb_mask + 1)& ~(log)->l_sectbb_mask) : (bbs) )
end_define

begin_define
define|#
directive|define
name|XLOG_SECTOR_ROUNDDOWN_BLKNO
parameter_list|(
name|log
parameter_list|,
name|bno
parameter_list|)
value|((bno)& ~(log)->l_sectbb_mask)
end_define

begin_function
name|xfs_buf_t
modifier|*
name|xlog_get_bp
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|num_bblks
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|num_bblks
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|l_sectbb_log
condition|)
block|{
if|if
condition|(
name|num_bblks
operator|>
literal|1
condition|)
name|num_bblks
operator|+=
name|XLOG_SECTOR_ROUNDUP_BBCOUNT
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|num_bblks
operator|=
name|XLOG_SECTOR_ROUNDUP_BBCOUNT
argument_list|(
name|log
argument_list|,
name|num_bblks
argument_list|)
expr_stmt|;
block|}
return|return
name|xfs_buf_get_noaddr
argument_list|(
name|BBTOB
argument_list|(
name|num_bblks
argument_list|)
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_logdev_targp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|xlog_put_bp
parameter_list|(
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_buf_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nbblks should be uint, but oh well.  Just want to catch that 32-bit length.  */
end_comment

begin_function
name|int
name|xlog_bread
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|blk_no
parameter_list|,
name|int
name|nbblks
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|log
operator|->
name|l_sectbb_log
condition|)
block|{
name|blk_no
operator|=
name|XLOG_SECTOR_ROUNDDOWN_BLKNO
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|)
expr_stmt|;
name|nbblks
operator|=
name|XLOG_SECTOR_ROUNDUP_BBCOUNT
argument_list|(
name|log
argument_list|,
name|nbblks
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|nbblks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BBTOB
argument_list|(
name|nbblks
argument_list|)
operator|<=
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
name|log
operator|->
name|l_logBBstart
operator|+
name|blk_no
argument_list|)
expr_stmt|;
name|XFS_BUF_READ
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_BUSY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_COUNT
argument_list|(
name|bp
argument_list|,
name|BBTOB
argument_list|(
name|nbblks
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_TARGET
argument_list|(
name|bp
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_iowait
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_bread"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Write out the buffer at the given block for the given number of blocks.  * The buffer is kept locked across the write and is returned locked.  * This can only be used for synchronous log writes.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_bwrite
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|blk_no
parameter_list|,
name|int
name|nbblks
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|log
operator|->
name|l_sectbb_log
condition|)
block|{
name|blk_no
operator|=
name|XLOG_SECTOR_ROUNDDOWN_BLKNO
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|)
expr_stmt|;
name|nbblks
operator|=
name|XLOG_SECTOR_ROUNDUP_BBCOUNT
argument_list|(
name|log
argument_list|,
name|nbblks
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|nbblks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BBTOB
argument_list|(
name|nbblks
argument_list|)
operator|<=
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_ADDR
argument_list|(
name|bp
argument_list|,
name|log
operator|->
name|l_logBBstart
operator|+
name|blk_no
argument_list|)
expr_stmt|;
name|XFS_BUF_ZEROFLAGS
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_BUSY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_HOLD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_PSEMA
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_COUNT
argument_list|(
name|bp
argument_list|,
name|BBTOB
argument_list|(
name|nbblks
argument_list|)
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_TARGET
argument_list|(
name|bp
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_bwrite"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|xfs_caddr_t
name|xlog_align
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|blk_no
parameter_list|,
name|int
name|nbblks
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_caddr_t
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|log
operator|->
name|l_sectbb_log
condition|)
return|return
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
return|;
name|ptr
operator|=
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
operator|+
name|BBTOB
argument_list|(
operator|(
name|int
operator|)
name|blk_no
operator|&
name|log
operator|->
name|l_sectbb_mask
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_SIZE
argument_list|(
name|bp
argument_list|)
operator|>=
name|BBTOB
argument_list|(
name|nbblks
operator|+
operator|(
name|blk_no
operator|&
name|log
operator|->
name|l_sectbb_mask
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * dump debug superblock and log record information  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_header_check_dump
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_rec_header_t
modifier|*
name|head
parameter_list|)
block|{
name|int
name|b
decl_stmt|;
name|printk
argument_list|(
literal|"%s:  SB : uuid = "
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|16
condition|;
name|b
operator|++
control|)
name|printk
argument_list|(
literal|"%02x"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
operator|)
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|", fmt = %d\n"
argument_list|,
name|XLOG_FMT
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"    log : uuid = "
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|16
condition|;
name|b
operator|++
control|)
name|printk
argument_list|(
literal|"%02x"
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|head
operator|->
name|h_fs_uuid
operator|)
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|", fmt = %d\n"
argument_list|,
name|INT_GET
argument_list|(
name|head
operator|->
name|h_fmt
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xlog_header_check_dump
parameter_list|(
name|mp
parameter_list|,
name|head
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * check log record header for recovery  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_header_check_recover
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_rec_header_t
modifier|*
name|head
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|head
operator|->
name|h_magicno
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XLOG_HEADER_MAGIC_NUM
argument_list|)
expr_stmt|;
comment|/* 	 * IRIX doesn't write the h_fmt field and leaves it zeroed 	 * (XLOG_FMT_UNKNOWN). This stops us from trying to recover 	 * a dirty log created in IRIX. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|head
operator|->
name|h_fmt
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XLOG_FMT
argument_list|)
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: dirty log written in incompatible format - can't recover"
argument_list|)
expr_stmt|;
name|xlog_header_check_dump
argument_list|(
name|mp
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_header_check_recover(1)"
argument_list|,
name|XFS_ERRLEVEL_HIGH
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|uuid_equal
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|,
operator|&
name|head
operator|->
name|h_fs_uuid
argument_list|)
argument_list|)
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: dirty log entry has mismatched uuid - can't recover"
argument_list|)
expr_stmt|;
name|xlog_header_check_dump
argument_list|(
name|mp
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_header_check_recover(2)"
argument_list|,
name|XFS_ERRLEVEL_HIGH
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * read the head block of the log and check the header  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_header_check_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_rec_header_t
modifier|*
name|head
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|INT_GET
argument_list|(
name|head
operator|->
name|h_magicno
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XLOG_HEADER_MAGIC_NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuid_is_nil
argument_list|(
operator|&
name|head
operator|->
name|h_fs_uuid
argument_list|)
condition|)
block|{
comment|/* 		 * IRIX doesn't write the h_fs_uuid or h_fmt fields. If 		 * h_fs_uuid is nil, we assume this log was last mounted 		 * by IRIX and continue. 		 */
name|xlog_warn
argument_list|(
literal|"XFS: nil uuid in log - IRIX style log"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|uuid_equal
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|,
operator|&
name|head
operator|->
name|h_fs_uuid
argument_list|)
argument_list|)
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: log has mismatched uuid - can't recover"
argument_list|)
expr_stmt|;
name|xlog_header_check_dump
argument_list|(
name|mp
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_header_check_mount"
argument_list|,
name|XFS_ERRLEVEL_HIGH
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_recover_iodone
parameter_list|(
name|struct
name|xfs_buf
modifier|*
name|bp
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* 		 * We're not going to bother about retrying 		 * this during recovery. One strike! 		 */
name|mp
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_mount_t
operator|*
argument_list|)
expr_stmt|;
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_iodone"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_METADATA_IO_ERROR
argument_list|)
expr_stmt|;
block|}
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|XFS_BUF_CLR_IODONE_FUNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine finds (to an approximation) the first block in the physical  * log which contains the given cycle.  It uses a binary search algorithm.  * Note that the algorithm can not be perfect because the disk will not  * necessarily be perfect.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_find_cycle_start
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_daddr_t
name|first_blk
parameter_list|,
name|xfs_daddr_t
modifier|*
name|last_blk
parameter_list|,
name|uint
name|cycle
parameter_list|)
block|{
name|xfs_caddr_t
name|offset
decl_stmt|;
name|xfs_daddr_t
name|mid_blk
decl_stmt|;
name|uint
name|mid_cycle
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mid_blk
operator|=
name|BLK_AVG
argument_list|(
name|first_blk
argument_list|,
operator|*
name|last_blk
argument_list|)
expr_stmt|;
while|while
condition|(
name|mid_blk
operator|!=
name|first_blk
operator|&&
name|mid_blk
operator|!=
operator|*
name|last_blk
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|mid_blk
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|mid_blk
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mid_cycle
operator|=
name|GET_CYCLE
argument_list|(
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid_cycle
operator|==
name|cycle
condition|)
block|{
operator|*
name|last_blk
operator|=
name|mid_blk
expr_stmt|;
comment|/* last_half_cycle == mid_cycle */
block|}
else|else
block|{
name|first_blk
operator|=
name|mid_blk
expr_stmt|;
comment|/* first_half_cycle == mid_cycle */
block|}
name|mid_blk
operator|=
name|BLK_AVG
argument_list|(
name|first_blk
argument_list|,
operator|*
name|last_blk
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|mid_blk
operator|==
name|first_blk
operator|&&
name|mid_blk
operator|+
literal|1
operator|==
operator|*
name|last_blk
operator|)
operator|||
operator|(
name|mid_blk
operator|==
operator|*
name|last_blk
operator|&&
name|mid_blk
operator|-
literal|1
operator|==
name|first_blk
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check that the range of blocks does not contain the cycle number  * given.  The scan needs to occur from front to back and the ptr into the  * region must be updated since a later routine will need to perform another  * test.  If the region is completely good, we end up returning the same  * last block number.  *  * Set blkno to -1 if we encounter no errors.  This is an invalid block number  * since we don't ever expect logs to get this large.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_find_verify_cycle
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|start_blk
parameter_list|,
name|int
name|nbblks
parameter_list|,
name|uint
name|stop_on_cycle_no
parameter_list|,
name|xfs_daddr_t
modifier|*
name|new_blk
parameter_list|)
block|{
name|xfs_daddr_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint
name|cycle
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_daddr_t
name|bufblks
decl_stmt|;
name|xfs_caddr_t
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bufblks
operator|=
literal|1
operator|<<
name|ffs
argument_list|(
name|nbblks
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
name|bufblks
argument_list|)
operator|)
condition|)
block|{
comment|/* can't get enough memory to do everything in one big buffer */
name|bufblks
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bufblks
operator|<=
name|log
operator|->
name|l_sectbb_log
condition|)
return|return
name|ENOMEM
return|;
block|}
for|for
control|(
name|i
operator|=
name|start_blk
init|;
name|i
operator|<
name|start_blk
operator|+
name|nbblks
condition|;
name|i
operator|+=
name|bufblks
control|)
block|{
name|int
name|bcount
decl_stmt|;
name|bcount
operator|=
name|min
argument_list|(
name|bufblks
argument_list|,
operator|(
name|start_blk
operator|+
name|nbblks
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
name|bcount
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|buf
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
name|bcount
argument_list|,
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bcount
condition|;
name|j
operator|++
control|)
block|{
name|cycle
operator|=
name|GET_CYCLE
argument_list|(
name|buf
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycle
operator|==
name|stop_on_cycle_no
condition|)
block|{
operator|*
name|new_blk
operator|=
name|i
operator|+
name|j
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|buf
operator|+=
name|BBSIZE
expr_stmt|;
block|}
block|}
operator|*
name|new_blk
operator|=
operator|-
literal|1
expr_stmt|;
name|out
label|:
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Potentially backup over partial log record write.  *  * In the typical case, last_blk is the number of the block directly after  * a good log record.  Therefore, we subtract one to get the block number  * of the last block in the given buffer.  extra_bblks contains the number  * of blocks we would have read on a previous read.  This happens when the  * last log record is split over the end of the physical log.  *  * extra_bblks is the number of blocks potentially verified on a previous  * call to this routine.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_find_verify_log_record
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|start_blk
parameter_list|,
name|xfs_daddr_t
modifier|*
name|last_blk
parameter_list|,
name|int
name|extra_bblks
parameter_list|)
block|{
name|xfs_daddr_t
name|i
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_caddr_t
name|offset
init|=
name|NULL
decl_stmt|;
name|xlog_rec_header_t
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|smallmem
init|=
literal|0
decl_stmt|;
name|int
name|num_blks
init|=
operator|*
name|last_blk
operator|-
name|start_blk
decl_stmt|;
name|int
name|xhdrs
decl_stmt|;
name|ASSERT
argument_list|(
name|start_blk
operator|!=
literal|0
operator|||
operator|*
name|last_blk
operator|!=
name|start_blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
name|num_blks
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|ENOMEM
return|;
name|smallmem
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
name|num_blks
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
name|num_blks
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
operator|(
name|num_blks
operator|-
literal|1
operator|)
operator|<<
name|BBSHIFT
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|(
operator|*
name|last_blk
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|<
name|start_blk
condition|)
block|{
comment|/* valid log record not found */
name|xlog_warn
argument_list|(
literal|"XFS: Log inconsistent (didn't find previous header)"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|smallmem
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|head
operator|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|offset
expr_stmt|;
if|if
condition|(
name|XLOG_HEADER_MAGIC_NUM
operator|==
name|INT_GET
argument_list|(
name|head
operator|->
name|h_magicno
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|smallmem
condition|)
name|offset
operator|-=
name|BBSIZE
expr_stmt|;
block|}
comment|/* 	 * We hit the beginning of the physical log& still no header.  Return 	 * to caller.  If caller can handle a return of -1, then this routine 	 * will be called again for the end of the physical log. 	 */
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We have the final block of the good log (the first block 	 * of the log record _before_ the head. So we check the uuid. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_header_check_mount
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|head
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We may have found a log record header before we expected one. 	 * last_blk will be the 1st block # with a given cycle #.  We may end 	 * up reading an entire log record.  In this case, we don't want to 	 * reset last_blk.  Only when last_blk points in the middle of a log 	 * record do we update last_blk. 	 */
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|uint
name|h_size
init|=
name|INT_GET
argument_list|(
name|head
operator|->
name|h_size
argument_list|,
name|ARCH_CONVERT
argument_list|)
decl_stmt|;
name|xhdrs
operator|=
name|h_size
operator|/
name|XLOG_HEADER_CYCLE_SIZE
expr_stmt|;
if|if
condition|(
name|h_size
operator|%
name|XLOG_HEADER_CYCLE_SIZE
condition|)
name|xhdrs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xhdrs
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|last_blk
operator|-
name|i
operator|+
name|extra_bblks
operator|!=
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|head
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|+
name|xhdrs
condition|)
operator|*
name|last_blk
operator|=
name|i
expr_stmt|;
name|out
label|:
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Head is defined to be the point of the log where the next log write  * write could go.  This means that incomplete LR writes at the end are  * eliminated when calculating the head.  We aren't guaranteed that previous  * LR have complete transactions.  We only know that a cycle number of  * current cycle number -1 won't be present in the log if we start writing  * from our current block number.  *  * last_blk contains the block number of the first block with a given  * cycle number.  *  * Return: zero if normal, non-zero if error.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_find_head
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
modifier|*
name|return_head_blk
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_caddr_t
name|offset
decl_stmt|;
name|xfs_daddr_t
name|new_blk
decl_stmt|,
name|first_blk
decl_stmt|,
name|start_blk
decl_stmt|,
name|last_blk
decl_stmt|,
name|head_blk
decl_stmt|;
name|int
name|num_scan_bblks
decl_stmt|;
name|uint
name|first_half_cycle
decl_stmt|,
name|last_half_cycle
decl_stmt|;
name|uint
name|stop_on_cycle
decl_stmt|;
name|int
name|error
decl_stmt|,
name|log_bbnum
init|=
name|log
operator|->
name|l_logBBsize
decl_stmt|;
comment|/* Is the end of the log device zeroed? */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_zeroed
argument_list|(
name|log
argument_list|,
operator|&
name|first_blk
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|return_head_blk
operator|=
name|first_blk
expr_stmt|;
comment|/* Is the whole lot zeroed? */
if|if
condition|(
operator|!
name|first_blk
condition|)
block|{
comment|/* Linux XFS shouldn't generate totally zeroed logs - 			 * mkfs etc write a dummy unmount record to a fresh 			 * log so we can store the uuid in there 			 */
name|xlog_warn
argument_list|(
literal|"XFS: totally zeroed log"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: empty log check failed"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|first_blk
operator|=
literal|0
expr_stmt|;
comment|/* get cycle # of 1st block */
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|first_half_cycle
operator|=
name|GET_CYCLE
argument_list|(
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|last_blk
operator|=
name|head_blk
operator|=
name|log_bbnum
operator|-
literal|1
expr_stmt|;
comment|/* get cycle # of last block */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|last_blk
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|last_blk
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|last_half_cycle
operator|=
name|GET_CYCLE
argument_list|(
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|last_half_cycle
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the 1st half cycle number is equal to the last half cycle number, 	 * then the entire log is stamped with the same cycle number.  In this 	 * case, head_blk can't be set to zero (which makes sense).  The below 	 * math doesn't work out properly with head_blk equal to zero.  Instead, 	 * we set it to log_bbnum which is an invalid block number, but this 	 * value makes the math correct.  If head_blk doesn't changed through 	 * all the tests below, *head_blk is set to zero at the very end rather 	 * than log_bbnum.  In a sense, log_bbnum and zero are the same block 	 * in a circular file. 	 */
if|if
condition|(
name|first_half_cycle
operator|==
name|last_half_cycle
condition|)
block|{
comment|/* 		 * In this case we believe that the entire log should have 		 * cycle number last_half_cycle.  We need to scan backwards 		 * from the end verifying that there are no holes still 		 * containing last_half_cycle - 1.  If we find such a hole, 		 * then the start of that hole will be the new head.  The 		 * simple case looks like 		 *        x | x ... | x - 1 | x 		 * Another case that fits this picture would be 		 *        x | x + 1 | x ... | x 		 * In this case the head really is somewhere at the end of the 		 * log, as one of the latest writes at the beginning was 		 * incomplete. 		 * One more case is 		 *        x | x + 1 | x ... | x - 1 | x 		 * This is really the combination of the above two cases, and 		 * the head has to end up at the start of the x-1 hole at the 		 * end of the log. 		 * 		 * In the 256k log case, we will read from the beginning to the 		 * end of the log and search for cycle numbers equal to x-1. 		 * We don't worry about the x+1 blocks that we encounter, 		 * because we know that they cannot be the head since the log 		 * started with x. 		 */
name|head_blk
operator|=
name|log_bbnum
expr_stmt|;
name|stop_on_cycle
operator|=
name|last_half_cycle
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * In this case we want to find the first block with cycle 		 * number matching last_half_cycle.  We expect the log to be 		 * some variation on 		 *        x + 1 ... | x ... 		 * The first block with cycle number x (last_half_cycle) will 		 * be where the new head belongs.  First we do a binary search 		 * for the first occurrence of last_half_cycle.  The binary 		 * search may not be totally accurate, so then we scan back 		 * from there looking for occurrences of last_half_cycle before 		 * us.  If that backwards scan wraps around the beginning of 		 * the log, then we look for occurrences of last_half_cycle - 1 		 * at the end of the log.  The cases we're looking for look 		 * like 		 *        x + 1 ... | x | x + 1 | x ... 		 *                               ^ binary search stopped here 		 * or 		 *        x + 1 ... | x ... | x - 1 | x 		 *<---------> less than scan distance 		 */
name|stop_on_cycle
operator|=
name|last_half_cycle
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_cycle_start
argument_list|(
name|log
argument_list|,
name|bp
argument_list|,
name|first_blk
argument_list|,
operator|&
name|head_blk
argument_list|,
name|last_half_cycle
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
block|}
comment|/* 	 * Now validate the answer.  Scan back some number of maximum possible 	 * blocks and make sure each one has the expected cycle number.  The 	 * maximum is determined by the total possible amount of buffering 	 * in the in-core log.  The following number can be made tighter if 	 * we actually look at the block size of the filesystem. 	 */
name|num_scan_bblks
operator|=
name|XLOG_TOTAL_REC_SHIFT
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_blk
operator|>=
name|num_scan_bblks
condition|)
block|{
comment|/* 		 * We are guaranteed that the entire check can be performed 		 * in one buffer. 		 */
name|start_blk
operator|=
name|head_blk
operator|-
name|num_scan_bblks
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_cycle
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
name|num_scan_bblks
argument_list|,
name|stop_on_cycle
argument_list|,
operator|&
name|new_blk
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
if|if
condition|(
name|new_blk
operator|!=
operator|-
literal|1
condition|)
name|head_blk
operator|=
name|new_blk
expr_stmt|;
block|}
else|else
block|{
comment|/* need to read 2 parts of log */
comment|/* 		 * We are going to scan backwards in the log in two parts. 		 * First we scan the physical end of the log.  In this part 		 * of the log, we are looking for blocks with cycle number 		 * last_half_cycle - 1. 		 * If we find one, then we know that the log starts there, as 		 * we've found a hole that didn't get written in going around 		 * the end of the physical log.  The simple case for this is 		 *        x + 1 ... | x ... | x - 1 | x 		 *<---------> less than scan distance 		 * If all of the blocks at the end of the log have cycle number 		 * last_half_cycle, then we check the blocks at the start of 		 * the log looking for occurrences of last_half_cycle.  If we 		 * find one, then our current estimate for the location of the 		 * first occurrence of last_half_cycle is wrong and we move 		 * back to the hole we've found.  This case looks like 		 *        x + 1 ... | x | x + 1 | x ... 		 *                               ^ binary search stopped here 		 * Another case we need to handle that only occurs in 256k 		 * logs is 		 *        x + 1 ... | x ... | x+1 | x ... 		 *                   ^ binary search stops here 		 * In a 256k log, the scan at the end of the log will see the 		 * x + 1 blocks.  We need to skip past those since that is 		 * certainly not the head of the log.  By searching for 		 * last_half_cycle-1 we accomplish that. 		 */
name|start_blk
operator|=
name|log_bbnum
operator|-
name|num_scan_bblks
operator|+
name|head_blk
expr_stmt|;
name|ASSERT
argument_list|(
name|head_blk
operator|<=
name|INT_MAX
operator|&&
operator|(
name|xfs_daddr_t
operator|)
name|num_scan_bblks
operator|-
name|head_blk
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_cycle
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
name|num_scan_bblks
operator|-
operator|(
name|int
operator|)
name|head_blk
argument_list|,
operator|(
name|stop_on_cycle
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|new_blk
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
if|if
condition|(
name|new_blk
operator|!=
operator|-
literal|1
condition|)
block|{
name|head_blk
operator|=
name|new_blk
expr_stmt|;
goto|goto
name|bad_blk
goto|;
block|}
comment|/* 		 * Scan beginning of log now.  The last part of the physical 		 * log is good.  This scan needs to verify that it doesn't find 		 * the last_half_cycle. 		 */
name|start_blk
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|head_blk
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_cycle
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
operator|(
name|int
operator|)
name|head_blk
argument_list|,
name|stop_on_cycle
argument_list|,
operator|&
name|new_blk
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
if|if
condition|(
name|new_blk
operator|!=
operator|-
literal|1
condition|)
name|head_blk
operator|=
name|new_blk
expr_stmt|;
block|}
name|bad_blk
label|:
comment|/* 	 * Now we need to make sure head_blk is not pointing to a block in 	 * the middle of a log record. 	 */
name|num_scan_bblks
operator|=
name|XLOG_REC_SHIFT
argument_list|(
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_blk
operator|>=
name|num_scan_bblks
condition|)
block|{
name|start_blk
operator|=
name|head_blk
operator|-
name|num_scan_bblks
expr_stmt|;
comment|/* don't read head_blk */
comment|/* start ptr at last block ptr before head_blk */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_log_record
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
operator|&
name|head_blk
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|bp_err
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|bp_err
goto|;
block|}
else|else
block|{
name|start_blk
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|head_blk
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_log_record
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
operator|&
name|head_blk
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* We hit the beginning of the log during our search */
name|start_blk
operator|=
name|log_bbnum
operator|-
name|num_scan_bblks
operator|+
name|head_blk
expr_stmt|;
name|new_blk
operator|=
name|log_bbnum
expr_stmt|;
name|ASSERT
argument_list|(
name|start_blk
operator|<=
name|INT_MAX
operator|&&
operator|(
name|xfs_daddr_t
operator|)
name|log_bbnum
operator|-
name|start_blk
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|head_blk
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_log_record
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
operator|&
name|new_blk
argument_list|,
operator|(
name|int
operator|)
name|head_blk
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|bp_err
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|bp_err
goto|;
if|if
condition|(
name|new_blk
operator|!=
name|log_bbnum
condition|)
name|head_blk
operator|=
name|new_blk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|bp_err
goto|;
block|}
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_blk
operator|==
name|log_bbnum
condition|)
operator|*
name|return_head_blk
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|return_head_blk
operator|=
name|head_blk
expr_stmt|;
comment|/* 	 * When returning here, we have a good block number.  Bad block 	 * means that during a previous crash, we didn't have a clean break 	 * from cycle number N to cycle number N-1.  In this case, we need 	 * to find the first block with cycle number N-1. 	 */
return|return
literal|0
return|;
name|bp_err
label|:
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|xlog_warn
argument_list|(
literal|"XFS: failed to find log head"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Find the sync block number or the tail of the log.  *  * This will be the block number of the last record to have its  * associated buffers synced to disk.  Every log record header has  * a sync lsn embedded in it.  LSNs hold block numbers, so it is easy  * to get a sync block number.  The only concern is to figure out which  * log record header to believe.  *  * The following algorithm uses the log record header with the largest  * lsn.  The entire log record does not need to be valid.  We only care  * that the header is valid.  *  * We could speed up search by using current head_blk buffer, but it is not  * available.  */
end_comment

begin_function
name|int
name|xlog_find_tail
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
modifier|*
name|head_blk
parameter_list|,
name|xfs_daddr_t
modifier|*
name|tail_blk
parameter_list|)
block|{
name|xlog_rec_header_t
modifier|*
name|rhead
decl_stmt|;
name|xlog_op_header_t
modifier|*
name|op_head
decl_stmt|;
name|xfs_caddr_t
name|offset
init|=
name|NULL
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|found
decl_stmt|;
name|xfs_daddr_t
name|umount_data_blk
decl_stmt|;
name|xfs_daddr_t
name|after_umount_blk
decl_stmt|;
name|xfs_lsn_t
name|tail_lsn
decl_stmt|;
name|int
name|hblks
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Find previous log record 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_head
argument_list|(
name|log
argument_list|,
name|head_blk
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|*
name|head_blk
operator|==
literal|0
condition|)
block|{
comment|/* special case */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CYCLE
argument_list|(
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|tail_blk
operator|=
literal|0
expr_stmt|;
comment|/* leave all other log inited values alone */
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* 	 * Search backwards looking for log record header block 	 */
name|ASSERT
argument_list|(
operator|*
name|head_blk
operator|<
name|INT_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|head_blk
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XLOG_HEADER_MAGIC_NUM
operator|==
name|INT_GET
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we haven't found the log record header block, start looking 	 * again from the end of the physical log.  XXXmiken: There should be 	 * a check here to make sure we didn't search more than N blocks in 	 * the previous code. 	 */
if|if
condition|(
operator|!
name|found
condition|)
block|{
for|for
control|(
name|i
operator|=
name|log
operator|->
name|l_logBBsize
operator|-
literal|1
init|;
name|i
operator|>=
call|(
name|int
call|)
argument_list|(
operator|*
name|head_blk
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|XLOG_HEADER_MAGIC_NUM
operator|==
name|INT_GET
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|found
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: xlog_find_tail: couldn't find sync record"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
comment|/* find blk_no of tail of log */
name|rhead
operator|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|offset
expr_stmt|;
operator|*
name|tail_blk
operator|=
name|BLOCK_LSN
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_tail_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reset log values according to the state of the log when we 	 * crashed.  In the case where head_blk == 0, we bump curr_cycle 	 * one because the next write starts a new cycle rather than 	 * continuing the cycle of the last good log record.  At this 	 * point we have guaranteed that all partial log records have been 	 * accounted for.  Therefore, we know that the last good log record 	 * written was complete and ended exactly on the end boundary 	 * of the physical log. 	 */
name|log
operator|->
name|l_prev_block
operator|=
name|i
expr_stmt|;
name|log
operator|->
name|l_curr_block
operator|=
operator|(
name|int
operator|)
operator|*
name|head_blk
expr_stmt|;
name|log
operator|->
name|l_curr_cycle
operator|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_cycle
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|2
condition|)
name|log
operator|->
name|l_curr_cycle
operator|++
expr_stmt|;
name|log
operator|->
name|l_tail_lsn
operator|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_tail_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_last_sync_lsn
operator|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_grant_reserve_cycle
operator|=
name|log
operator|->
name|l_curr_cycle
expr_stmt|;
name|log
operator|->
name|l_grant_reserve_bytes
operator|=
name|BBTOB
argument_list|(
name|log
operator|->
name|l_curr_block
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_grant_write_cycle
operator|=
name|log
operator|->
name|l_curr_cycle
expr_stmt|;
name|log
operator|->
name|l_grant_write_bytes
operator|=
name|BBTOB
argument_list|(
name|log
operator|->
name|l_curr_block
argument_list|)
expr_stmt|;
comment|/* 	 * Look for unmount record.  If we find it, then we know there 	 * was a clean unmount.  Since 'i' could be the last block in 	 * the physical log, we convert to a log block before comparing 	 * to the head_blk. 	 * 	 * Save the current tail lsn to use to pass to 	 * xlog_clear_stale_blocks() below.  We won't want to clear the 	 * unmount record if there is one, so we pass the lsn of the 	 * unmount record rather than the block after it. 	 */
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|int
name|h_size
init|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_size
argument_list|,
name|ARCH_CONVERT
argument_list|)
decl_stmt|;
name|int
name|h_version
init|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|h_version
operator|&
name|XLOG_VERSION_2
operator|)
operator|&&
operator|(
name|h_size
operator|>
name|XLOG_HEADER_CYCLE_SIZE
operator|)
condition|)
block|{
name|hblks
operator|=
name|h_size
operator|/
name|XLOG_HEADER_CYCLE_SIZE
expr_stmt|;
if|if
condition|(
name|h_size
operator|%
name|XLOG_HEADER_CYCLE_SIZE
condition|)
name|hblks
operator|++
expr_stmt|;
block|}
else|else
block|{
name|hblks
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|hblks
operator|=
literal|1
expr_stmt|;
block|}
name|after_umount_blk
operator|=
operator|(
name|i
operator|+
name|hblks
operator|+
operator|(
name|int
operator|)
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|)
operator|%
name|log
operator|->
name|l_logBBsize
expr_stmt|;
name|tail_lsn
operator|=
name|log
operator|->
name|l_tail_lsn
expr_stmt|;
if|if
condition|(
operator|*
name|head_blk
operator|==
name|after_umount_blk
operator|&&
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_num_logops
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
literal|1
condition|)
block|{
name|umount_data_blk
operator|=
operator|(
name|i
operator|+
name|hblks
operator|)
operator|%
name|log
operator|->
name|l_logBBsize
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|umount_data_blk
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|bread_err
goto|;
block|}
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|umount_data_blk
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|op_head
operator|=
operator|(
name|xlog_op_header_t
operator|*
operator|)
name|offset
expr_stmt|;
if|if
condition|(
name|op_head
operator|->
name|oh_flags
operator|&
name|XLOG_UNMOUNT_TRANS
condition|)
block|{
comment|/* 			 * Set tail and last sync so that newly written 			 * log records will point recovery to after the 			 * current unmount record. 			 */
name|ASSIGN_ANY_LSN_HOST
argument_list|(
name|log
operator|->
name|l_tail_lsn
argument_list|,
name|log
operator|->
name|l_curr_cycle
argument_list|,
name|after_umount_blk
argument_list|)
expr_stmt|;
name|ASSIGN_ANY_LSN_HOST
argument_list|(
name|log
operator|->
name|l_last_sync_lsn
argument_list|,
name|log
operator|->
name|l_curr_cycle
argument_list|,
name|after_umount_blk
argument_list|)
expr_stmt|;
operator|*
name|tail_blk
operator|=
name|after_umount_blk
expr_stmt|;
block|}
block|}
comment|/* 	 * Make sure that there are no blocks in front of the head 	 * with the same cycle number as the head.  This can happen 	 * because we allow multiple outstanding log writes concurrently, 	 * and the later writes might make it out before earlier ones. 	 * 	 * We use the lsn from before modifying it so that we'll never 	 * overwrite the unmount record after a clean unmount. 	 * 	 * Do this only if we are going to recover the filesystem 	 * 	 * NOTE: This used to say "if (!readonly)" 	 * However on Linux, we can& do recover a read-only filesystem. 	 * We only skip recovery if NORECOVERY is specified on mount, 	 * in which case we would not be here. 	 * 	 * But... if the -device- itself is readonly, just skip this. 	 * We can't recover this device anyway, so it won't matter. 	 */
if|if
condition|(
operator|!
name|xfs_readonly_buftarg
argument_list|(
name|log
operator|->
name|l_mp
operator|->
name|m_logdev_targp
argument_list|)
condition|)
block|{
name|error
operator|=
name|xlog_clear_stale_blocks
argument_list|(
name|log
argument_list|,
name|tail_lsn
argument_list|)
expr_stmt|;
block|}
name|bread_err
label|:
name|exit
label|:
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|xlog_warn
argument_list|(
literal|"XFS: failed to locate log tail"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Is the log zeroed at all?  *  * The last binary search should be changed to perform an X block read  * once X becomes small enough.  You can then search linearly through  * the X blocks.  This will cut down on the number of reads we need to do.  *  * If the log is partially zeroed, this routine will pass back the blkno  * of the first block with cycle number 0.  It won't have a complete LR  * preceding it.  *  * Return:  *	0  => the log is completely written to  *	-1 => use *blk_no as the first block of the log  *>0 => error has occurred  */
end_comment

begin_function
name|int
name|xlog_find_zeroed
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
modifier|*
name|blk_no
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_caddr_t
name|offset
decl_stmt|;
name|uint
name|first_cycle
decl_stmt|,
name|last_cycle
decl_stmt|;
name|xfs_daddr_t
name|new_blk
decl_stmt|,
name|last_blk
decl_stmt|,
name|start_blk
decl_stmt|;
name|xfs_daddr_t
name|num_scan_bblks
decl_stmt|;
name|int
name|error
decl_stmt|,
name|log_bbnum
init|=
name|log
operator|->
name|l_logBBsize
decl_stmt|;
comment|/* check totally zeroed log */
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|first_cycle
operator|=
name|GET_CYCLE
argument_list|(
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_cycle
operator|==
literal|0
condition|)
block|{
comment|/* completely zeroed log */
operator|*
name|blk_no
operator|=
literal|0
expr_stmt|;
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check partially zeroed log */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|log_bbnum
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|log_bbnum
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|last_cycle
operator|=
name|GET_CYCLE
argument_list|(
name|offset
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_cycle
operator|!=
literal|0
condition|)
block|{
comment|/* log completely written to */
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|first_cycle
operator|!=
literal|1
condition|)
block|{
comment|/* 		 * If the cycle of the last block is zero, the cycle of 		 * the first block must be 1. If it's not, maybe we're 		 * not looking at a log... Bail out. 		 */
name|xlog_warn
argument_list|(
literal|"XFS: Log inconsistent or not a log (last==0, first!=1)"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* we have a partially zeroed log */
name|last_blk
operator|=
name|log_bbnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_cycle_start
argument_list|(
name|log
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
operator|&
name|last_blk
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
comment|/* 	 * Validate the answer.  Because there is no way to guarantee that 	 * the entire log is made up of log records which are the same size, 	 * we scan over the defined maximum blocks.  At this point, the maximum 	 * is not chosen to mean anything special.   XXXmiken 	 */
name|num_scan_bblks
operator|=
name|XLOG_TOTAL_REC_SHIFT
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|num_scan_bblks
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_blk
operator|<
name|num_scan_bblks
condition|)
name|num_scan_bblks
operator|=
name|last_blk
expr_stmt|;
name|start_blk
operator|=
name|last_blk
operator|-
name|num_scan_bblks
expr_stmt|;
comment|/* 	 * We search for any instances of cycle number 0 that occur before 	 * our current estimate of the head.  What we're trying to detect is 	 *        1 ... | 0 | 1 | 0... 	 *                       ^ binary search ends here 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_cycle
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
operator|(
name|int
operator|)
name|num_scan_bblks
argument_list|,
literal|0
argument_list|,
operator|&
name|new_blk
argument_list|)
operator|)
condition|)
goto|goto
name|bp_err
goto|;
if|if
condition|(
name|new_blk
operator|!=
operator|-
literal|1
condition|)
name|last_blk
operator|=
name|new_blk
expr_stmt|;
comment|/* 	 * Potentially backup over partial log record write.  We don't need 	 * to search the end of the log because we know it is zero. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_verify_log_record
argument_list|(
name|log
argument_list|,
name|start_blk
argument_list|,
operator|&
name|last_blk
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|bp_err
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|bp_err
goto|;
operator|*
name|blk_no
operator|=
name|last_blk
expr_stmt|;
name|bp_err
label|:
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * These are simple subroutines used by xlog_clear_stale_blocks() below  * to initialize a buffer full of empty log record headers and write  * them into the log.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_add_record
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_caddr_t
name|buf
parameter_list|,
name|int
name|cycle
parameter_list|,
name|int
name|block
parameter_list|,
name|int
name|tail_cycle
parameter_list|,
name|int
name|tail_block
parameter_list|)
block|{
name|xlog_rec_header_t
modifier|*
name|recp
init|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|buf
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|BBSIZE
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|recp
operator|->
name|h_magicno
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XLOG_HEADER_MAGIC_NUM
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|recp
operator|->
name|h_cycle
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|recp
operator|->
name|h_version
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|ASSIGN_ANY_LSN_DISK
argument_list|(
name|recp
operator|->
name|h_lsn
argument_list|,
name|cycle
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|ASSIGN_ANY_LSN_DISK
argument_list|(
name|recp
operator|->
name|h_tail_lsn
argument_list|,
name|tail_cycle
argument_list|,
name|tail_block
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|recp
operator|->
name|h_fmt
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XLOG_FMT
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|recp
operator|->
name|h_fs_uuid
argument_list|,
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_write_log_records
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|cycle
parameter_list|,
name|int
name|start_block
parameter_list|,
name|int
name|blocks
parameter_list|,
name|int
name|tail_cycle
parameter_list|,
name|int
name|tail_block
parameter_list|)
block|{
name|xfs_caddr_t
name|offset
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|balign
decl_stmt|,
name|ealign
decl_stmt|;
name|int
name|sectbb
init|=
name|XLOG_SECTOR_ROUNDUP_BBCOUNT
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|end_block
init|=
name|start_block
operator|+
name|blocks
decl_stmt|;
name|int
name|bufblks
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|bufblks
operator|=
literal|1
operator|<<
name|ffs
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|bp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
name|bufblks
argument_list|)
operator|)
condition|)
block|{
name|bufblks
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|bufblks
operator|<=
name|log
operator|->
name|l_sectbb_log
condition|)
return|return
name|ENOMEM
return|;
block|}
comment|/* We may need to do a read at the start to fill in part of 	 * the buffer in the starting sector not covered by the first 	 * write below. 	 */
name|balign
operator|=
name|XLOG_SECTOR_ROUNDDOWN_BLKNO
argument_list|(
name|log
argument_list|,
name|start_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|balign
operator|!=
name|start_block
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|start_block
argument_list|,
literal|1
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|j
operator|=
name|start_block
operator|-
name|balign
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|start_block
init|;
name|i
operator|<
name|end_block
condition|;
name|i
operator|+=
name|bufblks
control|)
block|{
name|int
name|bcount
decl_stmt|,
name|endcount
decl_stmt|;
name|bcount
operator|=
name|min
argument_list|(
name|bufblks
argument_list|,
name|end_block
operator|-
name|start_block
argument_list|)
expr_stmt|;
name|endcount
operator|=
name|bcount
operator|-
name|j
expr_stmt|;
comment|/* We may need to do a read at the end to fill in part of 		 * the buffer in the final sector not covered by the write. 		 * If this is the same sector as the above read, skip it. 		 */
name|ealign
operator|=
name|XLOG_SECTOR_ROUNDDOWN_BLKNO
argument_list|(
name|log
argument_list|,
name|end_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
operator|(
name|start_block
operator|+
name|endcount
operator|>
name|ealign
operator|)
condition|)
block|{
name|offset
operator|=
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|balign
operator|=
name|BBTOB
argument_list|(
name|ealign
operator|-
name|start_block
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_PTR
argument_list|(
name|bp
argument_list|,
name|offset
operator|+
name|balign
argument_list|,
name|BBTOB
argument_list|(
name|sectbb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|ealign
argument_list|,
name|sectbb
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
break|break;
name|XFS_BUF_SET_PTR
argument_list|(
name|bp
argument_list|,
name|offset
argument_list|,
name|bufblks
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|start_block
argument_list|,
name|endcount
argument_list|,
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|endcount
condition|;
name|j
operator|++
control|)
block|{
name|xlog_add_record
argument_list|(
name|log
argument_list|,
name|offset
argument_list|,
name|cycle
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|tail_cycle
argument_list|,
name|tail_block
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|BBSIZE
expr_stmt|;
block|}
name|error
operator|=
name|xlog_bwrite
argument_list|(
name|log
argument_list|,
name|start_block
argument_list|,
name|endcount
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|start_block
operator|+=
name|endcount
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|xlog_put_bp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called to blow away any incomplete log writes out  * in front of the log head.  We do this so that we won't become confused  * if we come up, write only a little bit more, and then crash again.  * If we leave the partial log records out there, this situation could  * cause us to think those partial writes are valid blocks since they  * have the current cycle number.  We get rid of them by overwriting them  * with empty log records with the old cycle number rather than the  * current one.  *  * The tail lsn is passed in rather than taken from  * the log so that we will not write over the unmount record after a  * clean unmount in a 512 block log.  Doing so would leave the log without  * any valid log records in it until a new one was written.  If we crashed  * during that time we would not be able to recover.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_clear_stale_blocks
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_lsn_t
name|tail_lsn
parameter_list|)
block|{
name|int
name|tail_cycle
decl_stmt|,
name|head_cycle
decl_stmt|;
name|int
name|tail_block
decl_stmt|,
name|head_block
decl_stmt|;
name|int
name|tail_distance
decl_stmt|,
name|max_distance
decl_stmt|;
name|int
name|distance
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tail_cycle
operator|=
name|CYCLE_LSN
argument_list|(
name|tail_lsn
argument_list|)
expr_stmt|;
name|tail_block
operator|=
name|BLOCK_LSN
argument_list|(
name|tail_lsn
argument_list|)
expr_stmt|;
name|head_cycle
operator|=
name|log
operator|->
name|l_curr_cycle
expr_stmt|;
name|head_block
operator|=
name|log
operator|->
name|l_curr_block
expr_stmt|;
comment|/* 	 * Figure out the distance between the new head of the log 	 * and the tail.  We want to write over any blocks beyond the 	 * head that we may have written just before the crash, but 	 * we don't want to overwrite the tail of the log. 	 */
if|if
condition|(
name|head_cycle
operator|==
name|tail_cycle
condition|)
block|{
comment|/* 		 * The tail is behind the head in the physical log, 		 * so the distance from the head to the tail is the 		 * distance from the head to the end of the log plus 		 * the distance from the beginning of the log to the 		 * tail. 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|head_block
operator|<
name|tail_block
operator|||
name|head_block
operator|>=
name|log
operator|->
name|l_logBBsize
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_clear_stale_blocks(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|tail_distance
operator|=
name|tail_block
operator|+
operator|(
name|log
operator|->
name|l_logBBsize
operator|-
name|head_block
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The head is behind the tail in the physical log, 		 * so the distance from the head to the tail is just 		 * the tail block minus the head block. 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|head_block
operator|>=
name|tail_block
operator|||
name|head_cycle
operator|!=
operator|(
name|tail_cycle
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_clear_stale_blocks(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|tail_distance
operator|=
name|tail_block
operator|-
name|head_block
expr_stmt|;
block|}
comment|/* 	 * If the head is right up against the tail, we can't clear 	 * anything. 	 */
if|if
condition|(
name|tail_distance
operator|<=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|tail_distance
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|max_distance
operator|=
name|XLOG_TOTAL_REC_SHIFT
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* 	 * Take the smaller of the maximum amount of outstanding I/O 	 * we could have and the distance to the tail to clear out. 	 * We take the smaller so that we don't overwrite the tail and 	 * we don't waste all day writing from the head to the tail 	 * for no reason. 	 */
name|max_distance
operator|=
name|MIN
argument_list|(
name|max_distance
argument_list|,
name|tail_distance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|head_block
operator|+
name|max_distance
operator|)
operator|<=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
comment|/* 		 * We can stomp all the blocks we need to without 		 * wrapping around the end of the log.  Just do it 		 * in a single write.  Use the cycle number of the 		 * current cycle minus one so that the log will look like: 		 *     n ... | n - 1 ... 		 */
name|error
operator|=
name|xlog_write_log_records
argument_list|(
name|log
argument_list|,
operator|(
name|head_cycle
operator|-
literal|1
operator|)
argument_list|,
name|head_block
argument_list|,
name|max_distance
argument_list|,
name|tail_cycle
argument_list|,
name|tail_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
comment|/* 		 * We need to wrap around the end of the physical log in 		 * order to clear all the blocks.  Do it in two separate 		 * I/Os.  The first write should be from the head to the 		 * end of the physical log, and it should use the current 		 * cycle number minus one just like above. 		 */
name|distance
operator|=
name|log
operator|->
name|l_logBBsize
operator|-
name|head_block
expr_stmt|;
name|error
operator|=
name|xlog_write_log_records
argument_list|(
name|log
argument_list|,
operator|(
name|head_cycle
operator|-
literal|1
operator|)
argument_list|,
name|head_block
argument_list|,
name|distance
argument_list|,
name|tail_cycle
argument_list|,
name|tail_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 		 * Now write the blocks at the start of the physical log. 		 * This writes the remainder of the blocks we want to clear. 		 * It uses the current cycle number since we're now on the 		 * same cycle as the head so that we get: 		 *    n ... n ... | n - 1 ... 		 *    ^^^^^ blocks we're writing 		 */
name|distance
operator|=
name|max_distance
operator|-
operator|(
name|log
operator|->
name|l_logBBsize
operator|-
name|head_block
operator|)
expr_stmt|;
name|error
operator|=
name|xlog_write_log_records
argument_list|(
name|log
argument_list|,
name|head_cycle
argument_list|,
literal|0
argument_list|,
name|distance
argument_list|,
name|tail_cycle
argument_list|,
name|tail_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  *		Log recover routines  *  ******************************************************************************  */
end_comment

begin_function
name|STATIC
name|xlog_recover_t
modifier|*
name|xlog_recover_find_tid
parameter_list|(
name|xlog_recover_t
modifier|*
name|q
parameter_list|,
name|xlog_tid_t
name|tid
parameter_list|)
block|{
name|xlog_recover_t
modifier|*
name|p
init|=
name|q
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|r_log_tid
operator|==
name|tid
condition|)
break|break;
name|p
operator|=
name|p
operator|->
name|r_next
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_recover_put_hashq
parameter_list|(
name|xlog_recover_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_recover_t
modifier|*
name|trans
parameter_list|)
block|{
name|trans
operator|->
name|r_next
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
name|trans
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_recover_add_item
parameter_list|(
name|xlog_recover_item_t
modifier|*
modifier|*
name|itemq
parameter_list|)
block|{
name|xlog_recover_item_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xlog_recover_item_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|xlog_recover_insert_item_backq
argument_list|(
name|itemq
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_add_to_cont_trans
parameter_list|(
name|xlog_recover_t
modifier|*
name|trans
parameter_list|,
name|xfs_caddr_t
name|dp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|xlog_recover_item_t
modifier|*
name|item
decl_stmt|;
name|xfs_caddr_t
name|ptr
decl_stmt|,
name|old_ptr
decl_stmt|;
name|int
name|old_len
decl_stmt|;
name|item
operator|=
name|trans
operator|->
name|r_itemq
expr_stmt|;
if|if
condition|(
name|item
operator|==
literal|0
condition|)
block|{
comment|/* finish copying rest of trans header */
name|xlog_recover_add_item
argument_list|(
operator|&
name|trans
operator|->
name|r_itemq
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|trans
operator|->
name|r_theader
operator|+
sizeof|sizeof
argument_list|(
name|xfs_trans_header_t
argument_list|)
operator|-
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* d, s, l */
return|return
literal|0
return|;
block|}
name|item
operator|=
name|item
operator|->
name|ri_prev
expr_stmt|;
name|old_ptr
operator|=
name|item
operator|->
name|ri_buf
index|[
name|item
operator|->
name|ri_cnt
operator|-
literal|1
index|]
operator|.
name|i_addr
expr_stmt|;
name|old_len
operator|=
name|item
operator|->
name|ri_buf
index|[
name|item
operator|->
name|ri_cnt
operator|-
literal|1
index|]
operator|.
name|i_len
expr_stmt|;
name|ptr
operator|=
name|kmem_realloc
argument_list|(
name|old_ptr
argument_list|,
name|len
operator|+
name|old_len
argument_list|,
name|old_len
argument_list|,
literal|0u
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ptr
index|[
name|old_len
index|]
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* d, s, l */
name|item
operator|->
name|ri_buf
index|[
name|item
operator|->
name|ri_cnt
operator|-
literal|1
index|]
operator|.
name|i_len
operator|+=
name|len
expr_stmt|;
name|item
operator|->
name|ri_buf
index|[
name|item
operator|->
name|ri_cnt
operator|-
literal|1
index|]
operator|.
name|i_addr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The next region to add is the start of a new region.  It could be  * a whole region or it could be the first part of a new region.  Because  * of this, the assumption here is that the type and size fields of all  * format structures fit into the first 32 bits of the structure.  *  * This works because all regions must be 32 bit aligned.  Therefore, we  * either have both fields or we have neither field.  In the case we have  * neither field, the data part of the region is zero length.  We only have  * a log_op_header and can throw away the header since a new one will appear  * later.  If we have at least 4 bytes, then we can determine how many regions  * will appear in the current log item.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_add_to_trans
parameter_list|(
name|xlog_recover_t
modifier|*
name|trans
parameter_list|,
name|xfs_caddr_t
name|dp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|xfs_inode_log_format_t
modifier|*
name|in_f
decl_stmt|;
comment|/* any will do */
name|xlog_recover_item_t
modifier|*
name|item
decl_stmt|;
name|xfs_caddr_t
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
literal|0
return|;
name|item
operator|=
name|trans
operator|->
name|r_itemq
expr_stmt|;
if|if
condition|(
name|item
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
operator|==
name|XFS_TRANS_HEADER_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|xfs_trans_header_t
argument_list|)
condition|)
name|xlog_recover_add_item
argument_list|(
operator|&
name|trans
operator|->
name|r_itemq
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|trans
operator|->
name|r_theader
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* d, s, l */
return|return
literal|0
return|;
block|}
name|ptr
operator|=
name|kmem_alloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|in_f
operator|=
operator|(
name|xfs_inode_log_format_t
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|ri_prev
operator|->
name|ri_total
operator|!=
literal|0
operator|&&
name|item
operator|->
name|ri_prev
operator|->
name|ri_total
operator|==
name|item
operator|->
name|ri_prev
operator|->
name|ri_cnt
condition|)
block|{
name|xlog_recover_add_item
argument_list|(
operator|&
name|trans
operator|->
name|r_itemq
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|trans
operator|->
name|r_itemq
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|ri_prev
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|ri_total
operator|==
literal|0
condition|)
block|{
comment|/* first region to be added */
name|item
operator|->
name|ri_total
operator|=
name|in_f
operator|->
name|ilf_size
expr_stmt|;
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_total
operator|<=
name|XLOG_MAX_REGIONS_IN_ITEM
argument_list|)
expr_stmt|;
name|item
operator|->
name|ri_buf
operator|=
name|kmem_zalloc
argument_list|(
operator|(
name|item
operator|->
name|ri_total
operator|*
sizeof|sizeof
argument_list|(
name|xfs_log_iovec_t
argument_list|)
operator|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_total
operator|>
name|item
operator|->
name|ri_cnt
argument_list|)
expr_stmt|;
comment|/* Description region is ri_buf[0] */
name|item
operator|->
name|ri_buf
index|[
name|item
operator|->
name|ri_cnt
index|]
operator|.
name|i_addr
operator|=
name|ptr
expr_stmt|;
name|item
operator|->
name|ri_buf
index|[
name|item
operator|->
name|ri_cnt
index|]
operator|.
name|i_len
operator|=
name|len
expr_stmt|;
name|item
operator|->
name|ri_cnt
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_recover_new_tid
parameter_list|(
name|xlog_recover_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_tid_t
name|tid
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|)
block|{
name|xlog_recover_t
modifier|*
name|trans
decl_stmt|;
name|trans
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xlog_recover_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|trans
operator|->
name|r_log_tid
operator|=
name|tid
expr_stmt|;
name|trans
operator|->
name|r_lsn
operator|=
name|lsn
expr_stmt|;
name|xlog_recover_put_hashq
argument_list|(
name|q
argument_list|,
name|trans
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_unlink_tid
parameter_list|(
name|xlog_recover_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_recover_t
modifier|*
name|trans
parameter_list|)
block|{
name|xlog_recover_t
modifier|*
name|tp
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|trans
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans
operator|==
operator|*
name|q
condition|)
block|{
operator|*
name|q
operator|=
operator|(
operator|*
name|q
operator|)
operator|->
name|r_next
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
operator|*
name|q
expr_stmt|;
while|while
condition|(
name|tp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|r_next
operator|==
name|trans
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|tp
operator|=
name|tp
operator|->
name|r_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_unlink_tid: trans not found"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|tp
operator|->
name|r_next
operator|=
name|tp
operator|->
name|r_next
operator|->
name|r_next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_recover_insert_item_backq
parameter_list|(
name|xlog_recover_item_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
block|{
name|item
operator|->
name|ri_prev
operator|=
name|item
operator|->
name|ri_next
operator|=
name|item
expr_stmt|;
operator|*
name|q
operator|=
name|item
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|ri_next
operator|=
operator|*
name|q
expr_stmt|;
name|item
operator|->
name|ri_prev
operator|=
operator|(
operator|*
name|q
operator|)
operator|->
name|ri_prev
expr_stmt|;
operator|(
operator|*
name|q
operator|)
operator|->
name|ri_prev
operator|=
name|item
expr_stmt|;
name|item
operator|->
name|ri_prev
operator|->
name|ri_next
operator|=
name|item
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|xlog_recover_insert_item_frontq
parameter_list|(
name|xlog_recover_item_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|)
block|{
name|xlog_recover_insert_item_backq
argument_list|(
name|q
argument_list|,
name|item
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|item
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_reorder_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_t
modifier|*
name|trans
parameter_list|)
block|{
name|xlog_recover_item_t
modifier|*
name|first_item
decl_stmt|,
modifier|*
name|itemq
decl_stmt|,
modifier|*
name|itemq_next
decl_stmt|;
name|xfs_buf_log_format_t
modifier|*
name|buf_f
decl_stmt|;
name|xfs_buf_log_format_v1_t
modifier|*
name|obuf_f
decl_stmt|;
name|ushort
name|flags
init|=
literal|0
decl_stmt|;
name|first_item
operator|=
name|itemq
operator|=
name|trans
operator|->
name|r_itemq
expr_stmt|;
name|trans
operator|->
name|r_itemq
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|itemq_next
operator|=
name|itemq
operator|->
name|ri_next
expr_stmt|;
name|buf_f
operator|=
operator|(
name|xfs_buf_log_format_t
operator|*
operator|)
name|itemq
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
switch|switch
condition|(
name|ITEM_TYPE
argument_list|(
name|itemq
argument_list|)
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
name|flags
operator|=
name|buf_f
operator|->
name|blf_flags
expr_stmt|;
break|break;
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
name|obuf_f
operator|=
operator|(
name|xfs_buf_log_format_v1_t
operator|*
operator|)
name|buf_f
expr_stmt|;
name|flags
operator|=
name|obuf_f
operator|->
name|blf_flags
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ITEM_TYPE
argument_list|(
name|itemq
argument_list|)
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BLI_CANCEL
operator|)
condition|)
block|{
name|xlog_recover_insert_item_frontq
argument_list|(
operator|&
name|trans
operator|->
name|r_itemq
argument_list|,
name|itemq
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XFS_LI_INODE
case|:
case|case
name|XFS_LI_6_1_INODE
case|:
case|case
name|XFS_LI_5_3_INODE
case|:
case|case
name|XFS_LI_DQUOT
case|:
case|case
name|XFS_LI_QUOTAOFF
case|:
case|case
name|XFS_LI_EFD
case|:
case|case
name|XFS_LI_EFI
case|:
name|xlog_recover_insert_item_backq
argument_list|(
operator|&
name|trans
operator|->
name|r_itemq
argument_list|,
name|itemq
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_reorder_trans: unrecognized type of log operation"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|itemq
operator|=
name|itemq_next
expr_stmt|;
block|}
do|while
condition|(
name|first_item
operator|!=
name|itemq
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Build up the table of buf cancel records so that we don't replay  * cancelled data in the second pass.  For buffer records that are  * not cancel records, there is nothing to do here so we just return.  *  * If we get a cancel record which is already in the table, this indicates  * that the buffer was cancelled multiple times.  In order to ensure  * that during pass 2 we keep the record in the table until we reach its  * last occurrence in the log, we keep a reference count in the cancel  * record in the table to tell us how many times we expect to see this  * record during the second pass.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_do_buffer_pass1
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_buf_log_format_t
modifier|*
name|buf_f
parameter_list|)
block|{
name|xfs_buf_cancel_t
modifier|*
name|bcp
decl_stmt|;
name|xfs_buf_cancel_t
modifier|*
name|nextp
decl_stmt|;
name|xfs_buf_cancel_t
modifier|*
name|prevp
decl_stmt|;
name|xfs_buf_cancel_t
modifier|*
modifier|*
name|bucket
decl_stmt|;
name|xfs_buf_log_format_v1_t
modifier|*
name|obuf_f
decl_stmt|;
name|xfs_daddr_t
name|blkno
init|=
literal|0
decl_stmt|;
name|uint
name|len
init|=
literal|0
decl_stmt|;
name|ushort
name|flags
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|buf_f
operator|->
name|blf_type
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
name|blkno
operator|=
name|buf_f
operator|->
name|blf_blkno
expr_stmt|;
name|len
operator|=
name|buf_f
operator|->
name|blf_len
expr_stmt|;
name|flags
operator|=
name|buf_f
operator|->
name|blf_flags
expr_stmt|;
break|break;
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
name|obuf_f
operator|=
operator|(
name|xfs_buf_log_format_v1_t
operator|*
operator|)
name|buf_f
expr_stmt|;
name|blkno
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|obuf_f
operator|->
name|blf_blkno
expr_stmt|;
name|len
operator|=
name|obuf_f
operator|->
name|blf_len
expr_stmt|;
name|flags
operator|=
name|obuf_f
operator|->
name|blf_flags
expr_stmt|;
break|break;
block|}
comment|/* 	 * If this isn't a cancel buffer item, then just return. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BLI_CANCEL
operator|)
condition|)
return|return;
comment|/* 	 * Insert an xfs_buf_cancel record into the hash table of 	 * them.  If there is already an identical record, bump 	 * its reference count. 	 */
name|bucket
operator|=
operator|&
name|log
operator|->
name|l_buf_cancel_table
index|[
operator|(
name|__uint64_t
operator|)
name|blkno
operator|%
name|XLOG_BC_TABLE_SIZE
index|]
expr_stmt|;
comment|/* 	 * If the hash bucket is empty then just insert a new record into 	 * the bucket. 	 */
if|if
condition|(
operator|*
name|bucket
operator|==
name|NULL
condition|)
block|{
name|bcp
operator|=
operator|(
name|xfs_buf_cancel_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_buf_cancel_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcp
operator|->
name|bc_blkno
operator|=
name|blkno
expr_stmt|;
name|bcp
operator|->
name|bc_len
operator|=
name|len
expr_stmt|;
name|bcp
operator|->
name|bc_refcount
operator|=
literal|1
expr_stmt|;
name|bcp
operator|->
name|bc_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|bucket
operator|=
name|bcp
expr_stmt|;
return|return;
block|}
comment|/* 	 * The hash bucket is not empty, so search for duplicates of our 	 * record.  If we find one them just bump its refcount.  If not 	 * then add us at the end of the list. 	 */
name|prevp
operator|=
name|NULL
expr_stmt|;
name|nextp
operator|=
operator|*
name|bucket
expr_stmt|;
while|while
condition|(
name|nextp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nextp
operator|->
name|bc_blkno
operator|==
name|blkno
operator|&&
name|nextp
operator|->
name|bc_len
operator|==
name|len
condition|)
block|{
name|nextp
operator|->
name|bc_refcount
operator|++
expr_stmt|;
return|return;
block|}
name|prevp
operator|=
name|nextp
expr_stmt|;
name|nextp
operator|=
name|nextp
operator|->
name|bc_next
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|prevp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bcp
operator|=
operator|(
name|xfs_buf_cancel_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_buf_cancel_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcp
operator|->
name|bc_blkno
operator|=
name|blkno
expr_stmt|;
name|bcp
operator|->
name|bc_len
operator|=
name|len
expr_stmt|;
name|bcp
operator|->
name|bc_refcount
operator|=
literal|1
expr_stmt|;
name|bcp
operator|->
name|bc_next
operator|=
name|NULL
expr_stmt|;
name|prevp
operator|->
name|bc_next
operator|=
name|bcp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see whether the buffer being recovered has a corresponding  * entry in the buffer cancel record table.  If it does then return 1  * so that it will be cancelled, otherwise return 0.  If the buffer is  * actually a buffer cancel item (XFS_BLI_CANCEL is set), then decrement  * the refcount on the entry in the table and remove it from the table  * if this is the last reference.  *  * We remove the cancel record from the table when we encounter its  * last occurrence in the log so that if the same buffer is re-used  * again after its last cancellation we actually replay the changes  * made at that point.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_check_buffer_cancelled
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|,
name|uint
name|len
parameter_list|,
name|ushort
name|flags
parameter_list|)
block|{
name|xfs_buf_cancel_t
modifier|*
name|bcp
decl_stmt|;
name|xfs_buf_cancel_t
modifier|*
name|prevp
decl_stmt|;
name|xfs_buf_cancel_t
modifier|*
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|log
operator|->
name|l_buf_cancel_table
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * There is nothing in the table built in pass one, 		 * so this buffer must not be cancelled. 		 */
name|ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bucket
operator|=
operator|&
name|log
operator|->
name|l_buf_cancel_table
index|[
operator|(
name|__uint64_t
operator|)
name|blkno
operator|%
name|XLOG_BC_TABLE_SIZE
index|]
expr_stmt|;
name|bcp
operator|=
operator|*
name|bucket
expr_stmt|;
if|if
condition|(
name|bcp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * There is no corresponding entry in the table built 		 * in pass one, so this buffer has not been cancelled. 		 */
name|ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Search for an entry in the buffer cancel table that 	 * matches our buffer. 	 */
name|prevp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|bcp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bcp
operator|->
name|bc_blkno
operator|==
name|blkno
operator|&&
name|bcp
operator|->
name|bc_len
operator|==
name|len
condition|)
block|{
comment|/* 			 * We've go a match, so return 1 so that the 			 * recovery of this buffer is cancelled. 			 * If this buffer is actually a buffer cancel 			 * log item, then decrement the refcount on the 			 * one in the table and remove it if this is the 			 * last reference. 			 */
if|if
condition|(
name|flags
operator|&
name|XFS_BLI_CANCEL
condition|)
block|{
name|bcp
operator|->
name|bc_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|bcp
operator|->
name|bc_refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prevp
operator|==
name|NULL
condition|)
block|{
operator|*
name|bucket
operator|=
name|bcp
operator|->
name|bc_next
expr_stmt|;
block|}
else|else
block|{
name|prevp
operator|->
name|bc_next
operator|=
name|bcp
operator|->
name|bc_next
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|bcp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_buf_cancel_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
name|prevp
operator|=
name|bcp
expr_stmt|;
name|bcp
operator|=
name|bcp
operator|->
name|bc_next
expr_stmt|;
block|}
comment|/* 	 * We didn't find a corresponding entry in the table, so 	 * return 0 so that the buffer is NOT cancelled. 	 */
name|ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|XFS_BLI_CANCEL
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_do_buffer_pass2
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_buf_log_format_t
modifier|*
name|buf_f
parameter_list|)
block|{
name|xfs_buf_log_format_v1_t
modifier|*
name|obuf_f
decl_stmt|;
name|xfs_daddr_t
name|blkno
init|=
literal|0
decl_stmt|;
name|ushort
name|flags
init|=
literal|0
decl_stmt|;
name|uint
name|len
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|buf_f
operator|->
name|blf_type
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
name|blkno
operator|=
name|buf_f
operator|->
name|blf_blkno
expr_stmt|;
name|flags
operator|=
name|buf_f
operator|->
name|blf_flags
expr_stmt|;
name|len
operator|=
name|buf_f
operator|->
name|blf_len
expr_stmt|;
break|break;
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
name|obuf_f
operator|=
operator|(
name|xfs_buf_log_format_v1_t
operator|*
operator|)
name|buf_f
expr_stmt|;
name|blkno
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|obuf_f
operator|->
name|blf_blkno
expr_stmt|;
name|flags
operator|=
name|obuf_f
operator|->
name|blf_flags
expr_stmt|;
name|len
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|obuf_f
operator|->
name|blf_len
expr_stmt|;
break|break;
block|}
return|return
name|xlog_check_buffer_cancelled
argument_list|(
name|log
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform recovery for a buffer full of inodes.  In these buffers,  * the only data which should be recovered is that which corresponds  * to the di_next_unlinked pointers in the on disk inode structures.  * The rest of the data for the inodes is always logged through the  * inodes themselves rather than the inode buffer and is recovered  * in xlog_recover_do_inode_trans().  *  * The only time when buffers full of inodes are fully recovered is  * when the buffer is full of newly allocated inodes.  In this case  * the buffer will not be marked as an inode buffer and so will be  * sent to xlog_recover_do_reg_buffer() below during recovery.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_do_inode_buffer
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_buf_log_format_t
modifier|*
name|buf_f
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|item_index
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|int
name|reg_buf_offset
decl_stmt|;
name|int
name|reg_buf_bytes
decl_stmt|;
name|int
name|next_unlinked_offset
decl_stmt|;
name|int
name|inodes_per_buf
decl_stmt|;
name|xfs_agino_t
modifier|*
name|logged_nextp
decl_stmt|;
name|xfs_agino_t
modifier|*
name|buffer_nextp
decl_stmt|;
name|xfs_buf_log_format_v1_t
modifier|*
name|obuf_f
decl_stmt|;
name|unsigned
name|int
modifier|*
name|data_map
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|map_size
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|buf_f
operator|->
name|blf_type
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
name|data_map
operator|=
name|buf_f
operator|->
name|blf_data_map
expr_stmt|;
name|map_size
operator|=
name|buf_f
operator|->
name|blf_map_size
expr_stmt|;
break|break;
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
name|obuf_f
operator|=
operator|(
name|xfs_buf_log_format_v1_t
operator|*
operator|)
name|buf_f
expr_stmt|;
name|data_map
operator|=
name|obuf_f
operator|->
name|blf_data_map
expr_stmt|;
name|map_size
operator|=
name|obuf_f
operator|->
name|blf_map_size
expr_stmt|;
break|break;
block|}
comment|/* 	 * Set the variables corresponding to the current region to 	 * 0 so that we'll initialize them on the first pass through 	 * the loop. 	 */
name|reg_buf_offset
operator|=
literal|0
expr_stmt|;
name|reg_buf_bytes
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|nbits
operator|=
literal|0
expr_stmt|;
name|item_index
operator|=
literal|0
expr_stmt|;
name|inodes_per_buf
operator|=
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inodes_per_buf
condition|;
name|i
operator|++
control|)
block|{
name|next_unlinked_offset
operator|=
operator|(
name|i
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodesize
operator|)
operator|+
name|offsetof
argument_list|(
name|xfs_dinode_t
argument_list|,
name|di_next_unlinked
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_unlinked_offset
operator|>=
operator|(
name|reg_buf_offset
operator|+
name|reg_buf_bytes
operator|)
condition|)
block|{
comment|/* 			 * The next di_next_unlinked field is beyond 			 * the current logged region.  Find the next 			 * logged region that contains or is beyond 			 * the current di_next_unlinked field. 			 */
name|bit
operator|+=
name|nbits
expr_stmt|;
name|bit
operator|=
name|xfs_next_bit
argument_list|(
name|data_map
argument_list|,
name|map_size
argument_list|,
name|bit
argument_list|)
expr_stmt|;
comment|/* 			 * If there are no more logged regions in the 			 * buffer, then we're done. 			 */
if|if
condition|(
name|bit
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
name|nbits
operator|=
name|xfs_contig_bits
argument_list|(
name|data_map
argument_list|,
name|map_size
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nbits
operator|>
literal|0
argument_list|)
expr_stmt|;
name|reg_buf_offset
operator|=
name|bit
operator|<<
name|XFS_BLI_SHIFT
expr_stmt|;
name|reg_buf_bytes
operator|=
name|nbits
operator|<<
name|XFS_BLI_SHIFT
expr_stmt|;
name|item_index
operator|++
expr_stmt|;
block|}
comment|/* 		 * If the current logged region starts after the current 		 * di_next_unlinked field, then move on to the next 		 * di_next_unlinked field. 		 */
if|if
condition|(
name|next_unlinked_offset
operator|<
name|reg_buf_offset
condition|)
block|{
continue|continue;
block|}
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_buf
index|[
name|item_index
index|]
operator|.
name|i_addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|item
operator|->
name|ri_buf
index|[
name|item_index
index|]
operator|.
name|i_len
operator|%
name|XFS_BLI_CHUNK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|reg_buf_offset
operator|+
name|reg_buf_bytes
operator|)
operator|<=
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The current logged region contains a copy of the 		 * current di_next_unlinked field.  Extract its value 		 * and copy it to the buffer copy. 		 */
name|logged_nextp
operator|=
operator|(
name|xfs_agino_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|item
operator|->
name|ri_buf
index|[
name|item_index
index|]
operator|.
name|i_addr
operator|)
operator|+
operator|(
name|next_unlinked_offset
operator|-
name|reg_buf_offset
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|*
name|logged_nextp
operator|==
literal|0
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"bad inode buffer log record (ptr = 0x%p, bp = 0x%p).  XFS trying to replay bad (0) inode di_next_unlinked field"
argument_list|,
name|item
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_recover_do_inode_buf"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|buffer_nextp
operator|=
operator|(
name|xfs_agino_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|next_unlinked_offset
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
operator|*
name|buffer_nextp
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|*
name|logged_nextp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a 'normal' buffer recovery.  Each logged region of the  * buffer should be copied over the corresponding region in the  * given buffer.  The bitmap in the buf log format structure indicates  * where to place the logged data.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_do_reg_buffer
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_buf_log_format_t
modifier|*
name|buf_f
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|int
name|nbits
decl_stmt|;
name|xfs_buf_log_format_v1_t
modifier|*
name|obuf_f
decl_stmt|;
name|unsigned
name|int
modifier|*
name|data_map
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|map_size
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|buf_f
operator|->
name|blf_type
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
name|data_map
operator|=
name|buf_f
operator|->
name|blf_data_map
expr_stmt|;
name|map_size
operator|=
name|buf_f
operator|->
name|blf_map_size
expr_stmt|;
break|break;
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
name|obuf_f
operator|=
operator|(
name|xfs_buf_log_format_v1_t
operator|*
operator|)
name|buf_f
expr_stmt|;
name|data_map
operator|=
name|obuf_f
operator|->
name|blf_data_map
expr_stmt|;
name|map_size
operator|=
name|obuf_f
operator|->
name|blf_map_size
expr_stmt|;
break|break;
block|}
name|bit
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* 0 is the buf format structure */
while|while
condition|(
literal|1
condition|)
block|{
name|bit
operator|=
name|xfs_next_bit
argument_list|(
name|data_map
argument_list|,
name|map_size
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|==
operator|-
literal|1
condition|)
break|break;
name|nbits
operator|=
name|xfs_contig_bits
argument_list|(
name|data_map
argument_list|,
name|map_size
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nbits
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_buf
index|[
name|i
index|]
operator|.
name|i_addr
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_buf
index|[
name|i
index|]
operator|.
name|i_len
operator|%
name|XFS_BLI_CHUNK
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|>=
operator|(
operator|(
name|uint
operator|)
name|bit
operator|<<
name|XFS_BLI_SHIFT
operator|)
operator|+
operator|(
name|nbits
operator|<<
name|XFS_BLI_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Do a sanity check if this is a dquot buffer. Just checking 		 * the first dquot in the buffer should do. XXXThis is 		 * probably a good thing to do for other buf types also. 		 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf_f
operator|->
name|blf_flags
operator|&
operator|(
name|XFS_BLI_UDQUOT_BUF
operator||
name|XFS_BLI_PDQUOT_BUF
operator||
name|XFS_BLI_GDQUOT_BUF
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_qm_dqcheck
argument_list|(
operator|(
name|xfs_disk_dquot_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
name|i
index|]
operator|.
name|i_addr
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|XFS_QMOPT_DOWARN
argument_list|,
literal|"dquot_buf_recover"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|memcpy
argument_list|(
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
operator|(
name|uint
operator|)
name|bit
operator|<<
name|XFS_BLI_SHIFT
argument_list|)
argument_list|,
comment|/* dest */
name|item
operator|->
name|ri_buf
index|[
name|i
index|]
operator|.
name|i_addr
argument_list|,
comment|/* source */
name|nbits
operator|<<
name|XFS_BLI_SHIFT
argument_list|)
expr_stmt|;
comment|/* length */
name|i
operator|++
expr_stmt|;
name|bit
operator|+=
name|nbits
expr_stmt|;
block|}
comment|/* Shouldn't be any more regions */
name|ASSERT
argument_list|(
name|i
operator|==
name|item
operator|->
name|ri_total
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do some primitive error checking on ondisk dquot data structures.  */
end_comment

begin_function
name|int
name|xfs_qm_dqcheck
parameter_list|(
name|xfs_disk_dquot_t
modifier|*
name|ddq
parameter_list|,
name|xfs_dqid_t
name|id
parameter_list|,
name|uint
name|type
parameter_list|,
comment|/* used only when IO_dorepair is true */
name|uint
name|flags
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|xfs_dqblk_t
modifier|*
name|d
init|=
operator|(
name|xfs_dqblk_t
operator|*
operator|)
name|ddq
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
comment|/* 	 * We can encounter an uninitialized dquot buffer for 2 reasons: 	 * 1. If we crash while deleting the quotainode(s), and those blks got 	 *    used for user data. This is because we take the path of regular 	 *    file deletion; however, the size field of quotainodes is never 	 *    updated, so all the tricks that we play in itruncate_finish 	 *    don't quite matter. 	 * 	 * 2. We don't play the quota buffers when there's a quotaoff logitem. 	 *    But the allocation will be replayed so we'll end up with an 	 *    uninitialized quota block. 	 * 	 * This is all fine; things are still consistent, and we haven't lost 	 * any quota information. Just don't complain about bad dquot blks. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|ddq
operator|->
name|d_magic
argument_list|)
operator|!=
name|XFS_DQUOT_MAGIC
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x"
argument_list|,
name|str
argument_list|,
name|id
argument_list|,
name|be16_to_cpu
argument_list|(
name|ddq
operator|->
name|d_magic
argument_list|)
argument_list|,
name|XFS_DQUOT_MAGIC
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ddq
operator|->
name|d_version
operator|!=
name|XFS_DQUOT_VERSION
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x"
argument_list|,
name|str
argument_list|,
name|id
argument_list|,
name|ddq
operator|->
name|d_version
argument_list|,
name|XFS_DQUOT_VERSION
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ddq
operator|->
name|d_flags
operator|!=
name|XFS_DQ_USER
operator|&&
name|ddq
operator|->
name|d_flags
operator|!=
name|XFS_DQ_PROJ
operator|&&
name|ddq
operator|->
name|d_flags
operator|!=
name|XFS_DQ_GROUP
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : XFS dquot ID 0x%x, unknown flags 0x%x"
argument_list|,
name|str
argument_list|,
name|id
argument_list|,
name|ddq
operator|->
name|d_flags
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
operator|-
literal|1
operator|&&
name|id
operator|!=
name|be32_to_cpu
argument_list|(
name|ddq
operator|->
name|d_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : ondisk-dquot 0x%p, ID mismatch: "
literal|"0x%x expected, found id 0x%x"
argument_list|,
name|str
argument_list|,
name|ddq
argument_list|,
name|id
argument_list|,
name|be32_to_cpu
argument_list|(
name|ddq
operator|->
name|d_id
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|errs
operator|&&
name|ddq
operator|->
name|d_id
condition|)
block|{
if|if
condition|(
name|ddq
operator|->
name|d_blk_softlimit
operator|&&
name|be64_to_cpu
argument_list|(
name|ddq
operator|->
name|d_bcount
argument_list|)
operator|>=
name|be64_to_cpu
argument_list|(
name|ddq
operator|->
name|d_blk_softlimit
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ddq
operator|->
name|d_btimer
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : Dquot ID 0x%x (0x%p) "
literal|"BLK TIMER NOT STARTED"
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|be32_to_cpu
argument_list|(
name|ddq
operator|->
name|d_id
argument_list|)
argument_list|,
name|ddq
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ddq
operator|->
name|d_ino_softlimit
operator|&&
name|be64_to_cpu
argument_list|(
name|ddq
operator|->
name|d_icount
argument_list|)
operator|>=
name|be64_to_cpu
argument_list|(
name|ddq
operator|->
name|d_ino_softlimit
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ddq
operator|->
name|d_itimer
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : Dquot ID 0x%x (0x%p) "
literal|"INODE TIMER NOT STARTED"
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|be32_to_cpu
argument_list|(
name|ddq
operator|->
name|d_id
argument_list|)
argument_list|,
name|ddq
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ddq
operator|->
name|d_rtb_softlimit
operator|&&
name|be64_to_cpu
argument_list|(
name|ddq
operator|->
name|d_rtbcount
argument_list|)
operator|>=
name|be64_to_cpu
argument_list|(
name|ddq
operator|->
name|d_rtb_softlimit
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ddq
operator|->
name|d_rtbtimer
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
literal|"%s : Dquot ID 0x%x (0x%p) "
literal|"RTBLK TIMER NOT STARTED"
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
name|be32_to_cpu
argument_list|(
name|ddq
operator|->
name|d_id
argument_list|)
argument_list|,
name|ddq
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|errs
operator|||
operator|!
operator|(
name|flags
operator|&
name|XFS_QMOPT_DQREPAIR
operator|)
condition|)
return|return
name|errs
return|;
if|if
condition|(
name|flags
operator|&
name|XFS_QMOPT_DOWARN
condition|)
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"Re-initializing dquot ID 0x%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Typically, a repair is only requested by quotacheck. 	 */
name|ASSERT
argument_list|(
name|id
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|flags
operator|&
name|XFS_QMOPT_DQREPAIR
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_dqblk_t
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|dd_diskdq
operator|.
name|d_magic
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DQUOT_MAGIC
argument_list|)
expr_stmt|;
name|d
operator|->
name|dd_diskdq
operator|.
name|d_version
operator|=
name|XFS_DQUOT_VERSION
expr_stmt|;
name|d
operator|->
name|dd_diskdq
operator|.
name|d_flags
operator|=
name|type
expr_stmt|;
name|d
operator|->
name|dd_diskdq
operator|.
name|d_id
operator|=
name|cpu_to_be32
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|errs
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a dquot buffer recovery.  * Simple algorithm: if we have found a QUOTAOFF logitem of the same type  * (ie. USR or GRP), then just toss this buffer away; don't recover it.  * Else, treat it as a regular buffer and do recovery.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_do_dquot_buffer
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|xfs_buf_t
modifier|*
name|bp
parameter_list|,
name|xfs_buf_log_format_t
modifier|*
name|buf_f
parameter_list|)
block|{
name|uint
name|type
decl_stmt|;
comment|/* 	 * Filesystems are required to send in quota flags at mount time. 	 */
if|if
condition|(
name|mp
operator|->
name|m_qflags
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf_f
operator|->
name|blf_flags
operator|&
name|XFS_BLI_UDQUOT_BUF
condition|)
name|type
operator||=
name|XFS_DQ_USER
expr_stmt|;
if|if
condition|(
name|buf_f
operator|->
name|blf_flags
operator|&
name|XFS_BLI_PDQUOT_BUF
condition|)
name|type
operator||=
name|XFS_DQ_PROJ
expr_stmt|;
if|if
condition|(
name|buf_f
operator|->
name|blf_flags
operator|&
name|XFS_BLI_GDQUOT_BUF
condition|)
name|type
operator||=
name|XFS_DQ_GROUP
expr_stmt|;
comment|/* 	 * This type of quotas was turned off, so ignore this buffer 	 */
if|if
condition|(
name|log
operator|->
name|l_quotaoffs_flag
operator|&
name|type
condition|)
return|return;
name|xlog_recover_do_reg_buffer
argument_list|(
name|mp
argument_list|,
name|item
argument_list|,
name|bp
argument_list|,
name|buf_f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine replays a modification made to a buffer at runtime.  * There are actually two types of buffer, regular and inode, which  * are handled differently.  Inode buffers are handled differently  * in that we only recover a specific set of data from them, namely  * the inode di_next_unlinked fields.  This is because all other inode  * data is actually logged via inode records and any data we replay  * here which overlaps that may be stale.  *  * When meta-data buffers are freed at run time we log a buffer item  * with the XFS_BLI_CANCEL bit set to indicate that previous copies  * of the buffer in the log should not be replayed at recovery time.  * This is so that if the blocks covered by the buffer are reused for  * file data before we crash we don't end up replaying old, freed  * meta-data into a user's file.  *  * To handle the cancellation of buffer log items, we make two passes  * over the log during recovery.  During the first we build a table of  * those buffers which have been cancelled, and during the second we  * only replay those buffers which do not have corresponding cancel  * records in the table.  See xlog_recover_do_buffer_pass[1,2] above  * for more details on the implementation of the table of cancel records.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_do_buffer_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_buf_log_format_t
modifier|*
name|buf_f
decl_stmt|;
name|xfs_buf_log_format_v1_t
modifier|*
name|obuf_f
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cancel
decl_stmt|;
name|xfs_daddr_t
name|blkno
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ushort
name|flags
decl_stmt|;
name|buf_f
operator|=
operator|(
name|xfs_buf_log_format_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
if|if
condition|(
name|pass
operator|==
name|XLOG_RECOVER_PASS1
condition|)
block|{
comment|/* 		 * In this pass we're only looking for buf items 		 * with the XFS_BLI_CANCEL bit set. 		 */
name|xlog_recover_do_buffer_pass1
argument_list|(
name|log
argument_list|,
name|buf_f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 		 * In this pass we want to recover all the buffers 		 * which have not been cancelled and are not 		 * cancellation buffers themselves.  The routine 		 * we call here will tell us whether or not to 		 * continue with the replay of this buffer. 		 */
name|cancel
operator|=
name|xlog_recover_do_buffer_pass2
argument_list|(
name|log
argument_list|,
name|buf_f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
switch|switch
condition|(
name|buf_f
operator|->
name|blf_type
condition|)
block|{
case|case
name|XFS_LI_BUF
case|:
name|blkno
operator|=
name|buf_f
operator|->
name|blf_blkno
expr_stmt|;
name|len
operator|=
name|buf_f
operator|->
name|blf_len
expr_stmt|;
name|flags
operator|=
name|buf_f
operator|->
name|blf_flags
expr_stmt|;
break|break;
case|case
name|XFS_LI_6_1_BUF
case|:
case|case
name|XFS_LI_5_3_BUF
case|:
name|obuf_f
operator|=
operator|(
name|xfs_buf_log_format_v1_t
operator|*
operator|)
name|buf_f
expr_stmt|;
name|blkno
operator|=
name|obuf_f
operator|->
name|blf_blkno
expr_stmt|;
name|len
operator|=
name|obuf_f
operator|->
name|blf_len
expr_stmt|;
name|flags
operator|=
name|obuf_f
operator|->
name|blf_flags
expr_stmt|;
break|break;
default|default:
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
literal|"xfs_log_recover: unknown buffer type 0x%x, logdev %s"
argument_list|,
name|buf_f
operator|->
name|blf_type
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_logname
condition|?
name|log
operator|->
name|l_mp
operator|->
name|m_logname
else|:
literal|"internal"
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_recover_do_buffer_trans"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFS_BLI_INODE_BUF
condition|)
block|{
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
name|XFS_BUF_LOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|xfs_buf_read
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|blkno
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_do..(read#1)"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFS_BLI_INODE_BUF
condition|)
block|{
name|error
operator|=
name|xlog_recover_do_inode_buffer
argument_list|(
name|mp
argument_list|,
name|item
argument_list|,
name|bp
argument_list|,
name|buf_f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
operator|(
name|XFS_BLI_UDQUOT_BUF
operator||
name|XFS_BLI_PDQUOT_BUF
operator||
name|XFS_BLI_GDQUOT_BUF
operator|)
condition|)
block|{
name|xlog_recover_do_dquot_buffer
argument_list|(
name|mp
argument_list|,
name|log
argument_list|,
name|item
argument_list|,
name|bp
argument_list|,
name|buf_f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xlog_recover_do_reg_buffer
argument_list|(
name|mp
argument_list|,
name|item
argument_list|,
name|bp
argument_list|,
name|buf_f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
comment|/* 	 * Perform delayed write on the buffer.  Asynchronous writes will be 	 * slower when taking into account all the buffers to be flushed. 	 * 	 * Also make sure that only inode buffers with good sizes stay in 	 * the buffer cache.  The kernel moves inodes in buffers of 1 block 	 * or XFS_INODE_CLUSTER_SIZE bytes, whichever is bigger.  The inode 	 * buffers in the log can be a different size if the log was generated 	 * by an older kernel using unclustered inode buffers or a newer kernel 	 * running with a different inode cluster size.  Regardless, if the 	 * the inode buffer size isn't MAX(blocksize, XFS_INODE_CLUSTER_SIZE) 	 * for *our* value of XFS_INODE_CLUSTER_SIZE, then we need to keep 	 * the buffer out of the buffer cache so that the buffer won't 	 * overlap with future reads of those inodes. 	 */
if|if
condition|(
name|XFS_DINODE_MAGIC
operator|==
name|INT_GET
argument_list|(
operator|*
operator|(
operator|(
name|__uint16_t
operator|*
operator|)
operator|(
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&&
operator|(
name|XFS_BUF_COUNT
argument_list|(
name|bp
argument_list|)
operator|!=
name|MAX
argument_list|(
name|log
operator|->
name|l_mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
operator|(
name|__uint32_t
operator|)
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|log
operator|->
name|l_mp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
operator|||
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_mount_t
operator|*
argument_list|)
operator|==
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_recover_iodone
argument_list|)
expr_stmt|;
name|xfs_bdwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_do_inode_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_inode_log_format_t
modifier|*
name|in_f
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_imap_t
name|imap
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|int
name|len
decl_stmt|;
name|xfs_caddr_t
name|src
decl_stmt|;
name|xfs_caddr_t
name|dest
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|attr_index
decl_stmt|;
name|uint
name|fields
decl_stmt|;
name|xfs_dinode_core_t
modifier|*
name|dicp
decl_stmt|;
if|if
condition|(
name|pass
operator|==
name|XLOG_RECOVER_PASS1
condition|)
block|{
return|return
literal|0
return|;
block|}
name|in_f
operator|=
operator|(
name|xfs_inode_log_format_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
name|ino
operator|=
name|in_f
operator|->
name|ilf_ino
expr_stmt|;
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
if|if
condition|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_INODE
condition|)
block|{
name|imap
operator|.
name|im_blkno
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|in_f
operator|->
name|ilf_blkno
expr_stmt|;
name|imap
operator|.
name|im_len
operator|=
name|in_f
operator|->
name|ilf_len
expr_stmt|;
name|imap
operator|.
name|im_boffset
operator|=
name|in_f
operator|->
name|ilf_boffset
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * It's an old inode format record.  We don't know where 		 * its cluster is located on disk, and we can't allow 		 * xfs_imap() to figure it out because the inode btrees 		 * are not ready to be used.  Therefore do not pass the 		 * XFS_IMAP_LOOKUP flag to xfs_imap().  This will give 		 * us only the single block in which the inode lives 		 * rather than its cluster, so we must make sure to 		 * invalidate the buffer when we write it out below. 		 */
name|imap
operator|.
name|im_blkno
operator|=
literal|0
expr_stmt|;
name|xfs_imap
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|NULL
argument_list|,
name|ino
argument_list|,
operator|&
name|imap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Inode buffers can be freed, look out for it, 	 * and do not replay the inode. 	 */
if|if
condition|(
name|xlog_check_buffer_cancelled
argument_list|(
name|log
argument_list|,
name|imap
operator|.
name|im_blkno
argument_list|,
name|imap
operator|.
name|im_len
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|imap
operator|.
name|im_blkno
argument_list|,
name|imap
operator|.
name|im_len
argument_list|,
name|XFS_BUF_LOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_do..(read#2)"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|imap
operator|.
name|im_blkno
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|in_f
operator|->
name|ilf_fields
operator|&
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|imap
operator|.
name|im_boffset
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the place we're flushing out to really looks 	 * like an inode! 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DINODE_MAGIC
argument_list|)
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad inode magic number, dino ptr = 0x%p, dino bp = 0x%p, ino = %Ld"
argument_list|,
name|dip
argument_list|,
name|bp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_recover_do_inode_trans(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|dicp
operator|=
operator|(
name|xfs_dinode_core_t
operator|*
operator|)
operator|(
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_addr
operator|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|dicp
operator|->
name|di_magic
operator|!=
name|XFS_DINODE_MAGIC
argument_list|)
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad inode log record, rec ptr 0x%p, ino %Ld"
argument_list|,
name|item
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_recover_do_inode_trans(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* Skip replay when the on disk inode is newer than the log one */
if|if
condition|(
name|dicp
operator|->
name|di_flushiter
operator|<
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_flushiter
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
comment|/* 		 * Deal with the wrap case, DI_MAX_FLUSH is less 		 * than smaller numbers 		 */
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_flushiter
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|DI_MAX_FLUSH
operator|)
operator|&&
operator|(
name|dicp
operator|->
name|di_flushiter
operator|<
operator|(
name|DI_MAX_FLUSH
operator|>>
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* do nothing */
block|}
else|else
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Take the opportunity to reset the flush iteration count */
name|dicp
operator|->
name|di_flushiter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|dicp
operator|->
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dicp
operator|->
name|di_format
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|)
operator|&&
operator|(
name|dicp
operator|->
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xlog_recover_do_inode_trans(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|dicp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad regular inode log record, rec ptr 0x%p, ino ptr = 0x%p, ino bp = 0x%p, ino %Ld"
argument_list|,
name|item
argument_list|,
name|dip
argument_list|,
name|bp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|dicp
operator|->
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dicp
operator|->
name|di_format
operator|!=
name|XFS_DINODE_FMT_EXTENTS
operator|)
operator|&&
operator|(
name|dicp
operator|->
name|di_format
operator|!=
name|XFS_DINODE_FMT_BTREE
operator|)
operator|&&
operator|(
name|dicp
operator|->
name|di_format
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xlog_recover_do_inode_trans(4)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|dicp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad dir inode log record, rec ptr 0x%p, ino ptr = 0x%p, ino bp = 0x%p, ino %Ld"
argument_list|,
name|item
argument_list|,
name|dip
argument_list|,
name|bp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|dicp
operator|->
name|di_nextents
operator|+
name|dicp
operator|->
name|di_anextents
operator|>
name|dicp
operator|->
name|di_nblocks
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xlog_recover_do_inode_trans(5)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|dicp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld"
argument_list|,
name|item
argument_list|,
name|dip
argument_list|,
name|bp
argument_list|,
name|ino
argument_list|,
name|dicp
operator|->
name|di_nextents
operator|+
name|dicp
operator|->
name|di_anextents
argument_list|,
name|dicp
operator|->
name|di_nblocks
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|dicp
operator|->
name|di_forkoff
operator|>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodesize
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xlog_recover_do_inode_trans(6)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|dicp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad inode log rec ptr 0x%p, dino ptr 0x%p, dino bp 0x%p, ino %Ld, forkoff 0x%x"
argument_list|,
name|item
argument_list|,
name|dip
argument_list|,
name|bp
argument_list|,
name|ino
argument_list|,
name|dicp
operator|->
name|di_forkoff
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_len
operator|>
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
argument_list|)
condition|)
block|{
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xlog_recover_do_inode_trans(7)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|dicp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"xfs_inode_recover: Bad inode log record length %d, rec ptr 0x%p"
argument_list|,
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_len
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* The core is in in-core format */
name|xfs_xlate_dinode_core
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|dip
operator|->
name|di_core
argument_list|,
operator|(
name|xfs_dinode_core_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_addr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* the rest is in on-disk format */
if|if
condition|(
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_len
operator|>
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|xfs_caddr_t
operator|)
name|dip
operator|+
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
argument_list|,
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_addr
operator|+
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
argument_list|,
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_len
operator|-
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|in_f
operator|->
name|ilf_fields
expr_stmt|;
switch|switch
condition|(
name|fields
operator|&
operator|(
name|XFS_ILOG_DEV
operator||
name|XFS_ILOG_UUID
operator|)
condition|)
block|{
case|case
name|XFS_ILOG_DEV
case|:
name|INT_SET
argument_list|(
name|dip
operator|->
name|di_u
operator|.
name|di_dev
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|in_f
operator|->
name|ilf_u
operator|.
name|ilfu_rdev
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ILOG_UUID
case|:
name|dip
operator|->
name|di_u
operator|.
name|di_muuid
operator|=
name|in_f
operator|->
name|ilf_u
operator|.
name|ilfu_uuid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|in_f
operator|->
name|ilf_size
operator|==
literal|2
condition|)
goto|goto
name|write_inode_buffer
goto|;
name|len
operator|=
name|item
operator|->
name|ri_buf
index|[
literal|2
index|]
operator|.
name|i_len
expr_stmt|;
name|src
operator|=
name|item
operator|->
name|ri_buf
index|[
literal|2
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|in_f
operator|->
name|ilf_size
operator|<=
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|in_f
operator|->
name|ilf_size
operator|==
literal|3
operator|)
operator|||
operator|(
name|fields
operator|&
name|XFS_ILOG_AFORK
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|fields
operator|&
name|XFS_ILOG_DFORK
operator|)
operator|||
operator|(
name|len
operator|==
name|in_f
operator|->
name|ilf_dsize
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fields
operator|&
name|XFS_ILOG_DFORK
condition|)
block|{
case|case
name|XFS_ILOG_DDATA
case|:
case|case
name|XFS_ILOG_DEXT
case|:
name|memcpy
argument_list|(
operator|&
name|dip
operator|->
name|di_u
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ILOG_DBROOT
case|:
name|xfs_bmbt_to_bmdr
argument_list|(
operator|(
name|xfs_bmbt_block_t
operator|*
operator|)
name|src
argument_list|,
name|len
argument_list|,
operator|&
operator|(
name|dip
operator|->
name|di_u
operator|.
name|di_bmbt
operator|)
argument_list|,
name|XFS_DFORK_DSIZE
argument_list|(
name|dip
argument_list|,
name|mp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * There are no data fork flags set. 		 */
name|ASSERT
argument_list|(
operator|(
name|fields
operator|&
name|XFS_ILOG_DFORK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we logged any attribute data, recover it.  There may or 	 * may not have been any other non-core data logged in this 	 * transaction. 	 */
if|if
condition|(
name|in_f
operator|->
name|ilf_fields
operator|&
name|XFS_ILOG_AFORK
condition|)
block|{
if|if
condition|(
name|in_f
operator|->
name|ilf_fields
operator|&
name|XFS_ILOG_DFORK
condition|)
block|{
name|attr_index
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|attr_index
operator|=
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|item
operator|->
name|ri_buf
index|[
name|attr_index
index|]
operator|.
name|i_len
expr_stmt|;
name|src
operator|=
name|item
operator|->
name|ri_buf
index|[
name|attr_index
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|==
name|in_f
operator|->
name|ilf_asize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|in_f
operator|->
name|ilf_fields
operator|&
name|XFS_ILOG_AFORK
condition|)
block|{
case|case
name|XFS_ILOG_ADATA
case|:
case|case
name|XFS_ILOG_AEXT
case|:
name|dest
operator|=
name|XFS_DFORK_APTR
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|len
operator|<=
name|XFS_DFORK_ASIZE
argument_list|(
name|dip
argument_list|,
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ILOG_ABROOT
case|:
name|dest
operator|=
name|XFS_DFORK_APTR
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|xfs_bmbt_to_bmdr
argument_list|(
operator|(
name|xfs_bmbt_block_t
operator|*
operator|)
name|src
argument_list|,
name|len
argument_list|,
operator|(
name|xfs_bmdr_block_t
operator|*
operator|)
name|dest
argument_list|,
name|XFS_DFORK_ASIZE
argument_list|(
name|dip
argument_list|,
name|mp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_do_inode_trans: Invalid flag"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
block|}
name|write_inode_buffer
label|:
if|if
condition|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_INODE
condition|)
block|{
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
operator|||
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_mount_t
operator|*
argument_list|)
operator|==
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_recover_iodone
argument_list|)
expr_stmt|;
name|xfs_bdwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XFS_BUF_STALE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recover QUOTAOFF records. We simply make a note of it in the xlog_t  * structure, so that we know not to do any dquot item or dquot buffer recovery,  * of that type.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_do_quotaoff_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_qoff_logformat_t
modifier|*
name|qoff_f
decl_stmt|;
if|if
condition|(
name|pass
operator|==
name|XLOG_RECOVER_PASS2
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qoff_f
operator|=
operator|(
name|xfs_qoff_logformat_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|qoff_f
argument_list|)
expr_stmt|;
comment|/* 	 * The logitem format's flag tells us if this was user quotaoff, 	 * group/project quotaoff or both. 	 */
if|if
condition|(
name|qoff_f
operator|->
name|qf_flags
operator|&
name|XFS_UQUOTA_ACCT
condition|)
name|log
operator|->
name|l_quotaoffs_flag
operator||=
name|XFS_DQ_USER
expr_stmt|;
if|if
condition|(
name|qoff_f
operator|->
name|qf_flags
operator|&
name|XFS_PQUOTA_ACCT
condition|)
name|log
operator|->
name|l_quotaoffs_flag
operator||=
name|XFS_DQ_PROJ
expr_stmt|;
if|if
condition|(
name|qoff_f
operator|->
name|qf_flags
operator|&
name|XFS_GQUOTA_ACCT
condition|)
name|log
operator|->
name|l_quotaoffs_flag
operator||=
name|XFS_DQ_GROUP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recover a dquot record  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_do_dquot_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|struct
name|xfs_disk_dquot
modifier|*
name|ddq
decl_stmt|,
modifier|*
name|recddq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_dq_logformat_t
modifier|*
name|dq_f
decl_stmt|;
name|uint
name|type
decl_stmt|;
if|if
condition|(
name|pass
operator|==
name|XLOG_RECOVER_PASS1
condition|)
block|{
return|return
literal|0
return|;
block|}
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
comment|/* 	 * Filesystems are required to send in quota flags at mount time. 	 */
if|if
condition|(
name|mp
operator|->
name|m_qflags
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|recddq
operator|=
operator|(
name|xfs_disk_dquot_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|recddq
argument_list|)
expr_stmt|;
comment|/* 	 * This type of quotas was turned off, so ignore this record. 	 */
name|type
operator|=
name|INT_GET
argument_list|(
name|recddq
operator|->
name|d_flags
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&
operator|(
name|XFS_DQ_USER
operator||
name|XFS_DQ_PROJ
operator||
name|XFS_DQ_GROUP
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|l_quotaoffs_flag
operator|&
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * At this point we know that quota was _not_ turned off. 	 * Since the mount flags are not indicating to us otherwise, this 	 * must mean that quota is on, and the dquot needs to be replayed. 	 * Remember that we may not have fully recovered the superblock yet, 	 * so we can't do the usual trick of looking at the SB quota bits. 	 * 	 * The other possibility, of course, is that the quota subsystem was 	 * removed since the last mount - ENOSYS. 	 */
name|dq_f
operator|=
operator|(
name|xfs_dq_logformat_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|dq_f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_qm_dqcheck
argument_list|(
name|recddq
argument_list|,
name|dq_f
operator|->
name|qlf_id
argument_list|,
literal|0
argument_list|,
name|XFS_QMOPT_DOWARN
argument_list|,
literal|"xlog_recover_do_dquot_trans (log copy)"
argument_list|)
operator|)
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|dq_f
operator|->
name|qlf_len
operator|==
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|dq_f
operator|->
name|qlf_blkno
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|dq_f
operator|->
name|qlf_len
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_do..(read#3)"
argument_list|,
name|mp
argument_list|,
name|bp
argument_list|,
name|dq_f
operator|->
name|qlf_blkno
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ddq
operator|=
operator|(
name|xfs_disk_dquot_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
name|dq_f
operator|->
name|qlf_boffset
argument_list|)
expr_stmt|;
comment|/* 	 * At least the magic num portion should be on disk because this 	 * was among a chunk of dquots created earlier, and we did some 	 * minimal initialization then. 	 */
if|if
condition|(
name|xfs_qm_dqcheck
argument_list|(
name|ddq
argument_list|,
name|dq_f
operator|->
name|qlf_id
argument_list|,
literal|0
argument_list|,
name|XFS_QMOPT_DOWARN
argument_list|,
literal|"xlog_recover_do_dquot_trans"
argument_list|)
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|memcpy
argument_list|(
name|ddq
argument_list|,
name|recddq
argument_list|,
name|item
operator|->
name|ri_buf
index|[
literal|1
index|]
operator|.
name|i_len
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dq_f
operator|->
name|qlf_size
operator|==
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|void
operator|*
argument_list|)
operator|==
name|NULL
operator|||
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_mount_t
operator|*
argument_list|)
operator|==
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_IODONE_FUNC
argument_list|(
name|bp
argument_list|,
name|xlog_recover_iodone
argument_list|)
expr_stmt|;
name|xfs_bdwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called to create an in-core extent free intent  * item from the efi format structure which was logged on disk.  * It allocates an in-core efi, copies the extents from the format  * structure into it, and adds the efi to the AIL with the given  * LSN.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_do_efi_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_efi_log_item_t
modifier|*
name|efip
decl_stmt|;
name|xfs_efi_log_format_t
modifier|*
name|efi_formatp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
name|XLOG_RECOVER_PASS1
condition|)
block|{
return|return;
block|}
name|efi_formatp
operator|=
operator|(
name|xfs_efi_log_format_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_len
operator|==
operator|(
sizeof|sizeof
argument_list|(
name|xfs_efi_log_format_t
argument_list|)
operator|+
operator|(
operator|(
name|efi_formatp
operator|->
name|efi_nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
name|efip
operator|=
name|xfs_efi_init
argument_list|(
name|mp
argument_list|,
name|efi_formatp
operator|->
name|efi_nextents
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|efip
operator|->
name|efi_format
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|efi_formatp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_efi_log_format_t
argument_list|)
operator|+
operator|(
operator|(
name|efi_formatp
operator|->
name|efi_nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|efip
operator|->
name|efi_next_extent
operator|=
name|efi_formatp
operator|->
name|efi_nextents
expr_stmt|;
name|efip
operator|->
name|efi_flags
operator||=
name|XFS_EFI_COMMITTED
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * xfs_trans_update_ail() drops the AIL lock. 	 */
name|xfs_trans_update_ail
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
name|efip
argument_list|,
name|lsn
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called when an efd format structure is found in  * a committed transaction in the log.  It's purpose is to cancel  * the corresponding efi if it was still in the log.  To do this  * it searches the AIL for the efi with an id equal to that in the  * efd format structure.  If we find it, we remove the efi from the  * AIL and free it.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_do_efd_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_item_t
modifier|*
name|item
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_efd_log_format_t
modifier|*
name|efd_formatp
decl_stmt|;
name|xfs_efi_log_item_t
modifier|*
name|efip
init|=
name|NULL
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|int
name|gen
decl_stmt|;
name|__uint64_t
name|efi_id
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
name|XLOG_RECOVER_PASS1
condition|)
block|{
return|return;
block|}
name|efd_formatp
operator|=
operator|(
name|xfs_efd_log_format_t
operator|*
operator|)
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_addr
expr_stmt|;
name|ASSERT
argument_list|(
name|item
operator|->
name|ri_buf
index|[
literal|0
index|]
operator|.
name|i_len
operator|==
operator|(
sizeof|sizeof
argument_list|(
name|xfs_efd_log_format_t
argument_list|)
operator|+
operator|(
operator|(
name|efd_formatp
operator|->
name|efd_nextents
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|efi_id
operator|=
name|efd_formatp
operator|->
name|efd_efi_id
expr_stmt|;
comment|/* 	 * Search for the efi with the id in the efd format structure 	 * in the AIL. 	 */
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lip
operator|=
name|xfs_trans_first_ail
argument_list|(
name|mp
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
while|while
condition|(
name|lip
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lip
operator|->
name|li_type
operator|==
name|XFS_LI_EFI
condition|)
block|{
name|efip
operator|=
operator|(
name|xfs_efi_log_item_t
operator|*
operator|)
name|lip
expr_stmt|;
if|if
condition|(
name|efip
operator|->
name|efi_format
operator|.
name|efi_id
operator|==
name|efi_id
condition|)
block|{
comment|/* 				 * xfs_trans_delete_ail() drops the 				 * AIL lock. 				 */
name|xfs_trans_delete_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|lip
operator|=
name|xfs_trans_next_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
operator|&
name|gen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we found it, then free it up.  If it wasn't there, it 	 * must have been overwritten in the log.  Oh well. 	 */
if|if
condition|(
name|lip
operator|!=
name|NULL
condition|)
block|{
name|xfs_efi_item_free
argument_list|(
name|efip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform the transaction  *  * If the transaction modifies a buffer or inode, do it now.  Otherwise,  * EFIs and EFDs get queued up by adding entries into the AIL for them.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_do_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_t
modifier|*
name|trans
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|xlog_recover_item_t
modifier|*
name|item
decl_stmt|,
modifier|*
name|first_item
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_reorder_trans
argument_list|(
name|log
argument_list|,
name|trans
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|first_item
operator|=
name|item
operator|=
name|trans
operator|->
name|r_itemq
expr_stmt|;
do|do
block|{
comment|/* 		 * we don't need to worry about the block number being 		 * truncated in> 1 TB buffers because in user-land, 		 * we're now n32 or 64-bit so xfs_daddr_t is 64-bits so 		 * the blknos will get through the user-mode buffer 		 * cache properly.  The only bad case is o32 kernels 		 * where xfs_daddr_t is 32-bits but mount will warn us 		 * off a> 1 TB filesystem before we get here. 		 */
if|if
condition|(
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_BUF
operator|)
operator|||
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_6_1_BUF
operator|)
operator|||
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_5_3_BUF
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_do_buffer_trans
argument_list|(
name|log
argument_list|,
name|item
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_INODE
operator|)
operator|||
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_6_1_INODE
operator|)
operator|||
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_5_3_INODE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_do_inode_trans
argument_list|(
name|log
argument_list|,
name|item
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_EFI
condition|)
block|{
name|xlog_recover_do_efi_trans
argument_list|(
name|log
argument_list|,
name|item
argument_list|,
name|trans
operator|->
name|r_lsn
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_EFD
condition|)
block|{
name|xlog_recover_do_efd_trans
argument_list|(
name|log
argument_list|,
name|item
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_DQUOT
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_do_dquot_trans
argument_list|(
name|log
argument_list|,
name|item
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ITEM_TYPE
argument_list|(
name|item
argument_list|)
operator|==
name|XFS_LI_QUOTAOFF
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_do_quotaoff_trans
argument_list|(
name|log
argument_list|,
name|item
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_do_trans"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
name|item
operator|=
name|item
operator|->
name|ri_next
expr_stmt|;
block|}
do|while
condition|(
name|first_item
operator|!=
name|item
condition|)
do|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Free up any resources allocated by the transaction  *  * Remember that EFIs, EFDs, and IUNLINKs are handled later.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_free_trans
parameter_list|(
name|xlog_recover_t
modifier|*
name|trans
parameter_list|)
block|{
name|xlog_recover_item_t
modifier|*
name|first_item
decl_stmt|,
modifier|*
name|item
decl_stmt|,
modifier|*
name|free_item
decl_stmt|;
name|int
name|i
decl_stmt|;
name|item
operator|=
name|first_item
operator|=
name|trans
operator|->
name|r_itemq
expr_stmt|;
do|do
block|{
name|free_item
operator|=
name|item
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|ri_next
expr_stmt|;
comment|/* Free the regions in the item. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|free_item
operator|->
name|ri_cnt
condition|;
name|i
operator|++
control|)
block|{
name|kmem_free
argument_list|(
name|free_item
operator|->
name|ri_buf
index|[
name|i
index|]
operator|.
name|i_addr
argument_list|,
name|free_item
operator|->
name|ri_buf
index|[
name|i
index|]
operator|.
name|i_len
argument_list|)
expr_stmt|;
block|}
comment|/* Free the item itself */
name|kmem_free
argument_list|(
name|free_item
operator|->
name|ri_buf
argument_list|,
operator|(
name|free_item
operator|->
name|ri_total
operator|*
sizeof|sizeof
argument_list|(
name|xfs_log_iovec_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|free_item
argument_list|,
sizeof|sizeof
argument_list|(
name|xlog_recover_item_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|first_item
operator|!=
name|item
condition|)
do|;
comment|/* Free the transaction recover structure */
name|kmem_free
argument_list|(
name|trans
argument_list|,
sizeof|sizeof
argument_list|(
name|xlog_recover_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_commit_trans
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_t
modifier|*
modifier|*
name|q
parameter_list|,
name|xlog_recover_t
modifier|*
name|trans
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_unlink_tid
argument_list|(
name|q
argument_list|,
name|trans
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_do_trans
argument_list|(
name|log
argument_list|,
name|trans
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|xlog_recover_free_trans
argument_list|(
name|trans
argument_list|)
expr_stmt|;
comment|/* no error */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_recover_unmount_trans
parameter_list|(
name|xlog_recover_t
modifier|*
name|trans
parameter_list|)
block|{
comment|/* Do nothing now */
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_unmount_trans: Unmount LR"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * There are two valid states of the r_state field.  0 indicates that the  * transaction structure is in a normal state.  We have either seen the  * start of the transaction or the last operation we added was not a partial  * operation.  If the last operation we added to the transaction was a  * partial operation, we need to mark r_state with XLOG_WAS_CONT_TRANS.  *  * NOTE: skip LRs with 0 data length.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_recover_process_data
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_recover_t
modifier|*
name|rhash
index|[]
parameter_list|,
name|xlog_rec_header_t
modifier|*
name|rhead
parameter_list|,
name|xfs_caddr_t
name|dp
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xfs_caddr_t
name|lp
decl_stmt|;
name|int
name|num_logops
decl_stmt|;
name|xlog_op_header_t
modifier|*
name|ohead
decl_stmt|;
name|xlog_recover_t
modifier|*
name|trans
decl_stmt|;
name|xlog_tid_t
name|tid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|uint
name|flags
decl_stmt|;
name|lp
operator|=
name|dp
operator|+
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|num_logops
operator|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_num_logops
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
comment|/* check the log format matches our own - else we can't recover */
if|if
condition|(
name|xlog_header_check_recover
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|rhead
argument_list|)
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
while|while
condition|(
operator|(
name|dp
operator|<
name|lp
operator|)
operator|&&
name|num_logops
condition|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|+
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
operator|<=
name|lp
argument_list|)
expr_stmt|;
name|ohead
operator|=
operator|(
name|xlog_op_header_t
operator|*
operator|)
name|dp
expr_stmt|;
name|dp
operator|+=
sizeof|sizeof
argument_list|(
name|xlog_op_header_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ohead
operator|->
name|oh_clientid
operator|!=
name|XFS_TRANSACTION
operator|&&
name|ohead
operator|->
name|oh_clientid
operator|!=
name|XFS_LOG
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_process_data: bad clientid"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
name|tid
operator|=
name|INT_GET
argument_list|(
name|ohead
operator|->
name|oh_tid
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|hash
operator|=
name|XLOG_RHASH
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|trans
operator|=
name|xlog_recover_find_tid
argument_list|(
name|rhash
index|[
name|hash
index|]
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans
operator|==
name|NULL
condition|)
block|{
comment|/* not found; add new tid */
if|if
condition|(
name|ohead
operator|->
name|oh_flags
operator|&
name|XLOG_START_TRANS
condition|)
name|xlog_recover_new_tid
argument_list|(
operator|&
name|rhash
index|[
name|hash
index|]
argument_list|,
name|tid
argument_list|,
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_lsn
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|dp
operator|+
name|INT_GET
argument_list|(
name|ohead
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<=
name|lp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ohead
operator|->
name|oh_flags
operator|&
operator|~
name|XLOG_END_TRANS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XLOG_WAS_CONT_TRANS
condition|)
name|flags
operator|&=
operator|~
name|XLOG_CONTINUE_TRANS
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|XLOG_COMMIT_TRANS
case|:
name|error
operator|=
name|xlog_recover_commit_trans
argument_list|(
name|log
argument_list|,
operator|&
name|rhash
index|[
name|hash
index|]
argument_list|,
name|trans
argument_list|,
name|pass
argument_list|)
expr_stmt|;
break|break;
case|case
name|XLOG_UNMOUNT_TRANS
case|:
name|error
operator|=
name|xlog_recover_unmount_trans
argument_list|(
name|trans
argument_list|)
expr_stmt|;
break|break;
case|case
name|XLOG_WAS_CONT_TRANS
case|:
name|error
operator|=
name|xlog_recover_add_to_cont_trans
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|INT_GET
argument_list|(
name|ohead
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XLOG_START_TRANS
case|:
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_process_data: bad transaction"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
name|XLOG_CONTINUE_TRANS
case|:
name|error
operator|=
name|xlog_recover_add_to_trans
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|INT_GET
argument_list|(
name|ohead
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xlog_warn
argument_list|(
literal|"XFS: xlog_recover_process_data: bad flag"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|dp
operator|+=
name|INT_GET
argument_list|(
name|ohead
operator|->
name|oh_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|num_logops
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process an extent free intent item that was recovered from  * the log.  We need to free the extents that it describes.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_process_efi
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_efi_log_item_t
modifier|*
name|efip
parameter_list|)
block|{
name|xfs_efd_log_item_t
modifier|*
name|efdp
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xfs_extent_t
modifier|*
name|extp
decl_stmt|;
name|xfs_fsblock_t
name|startblock_fsb
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|efip
operator|->
name|efi_flags
operator|&
name|XFS_EFI_RECOVERED
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * First check the validity of the extents described by the 	 * EFI.  If any are bad, then assume that all are bad and 	 * just toss the EFI. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
condition|;
name|i
operator|++
control|)
block|{
name|extp
operator|=
operator|&
operator|(
name|efip
operator|->
name|efi_format
operator|.
name|efi_extents
index|[
name|i
index|]
operator|)
expr_stmt|;
name|startblock_fsb
operator|=
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|extp
operator|->
name|ext_start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|startblock_fsb
operator|==
literal|0
operator|)
operator|||
operator|(
name|extp
operator|->
name|ext_len
operator|==
literal|0
operator|)
operator|||
operator|(
name|startblock_fsb
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
operator|)
operator|||
operator|(
name|extp
operator|->
name|ext_len
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agblocks
operator|)
condition|)
block|{
comment|/* 			 * This will pull the EFI from the AIL and 			 * free the memory associated with it. 			 */
name|xfs_efi_release
argument_list|(
name|efip
argument_list|,
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|efdp
operator|=
name|xfs_trans_get_efd
argument_list|(
name|tp
argument_list|,
name|efip
argument_list|,
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|efip
operator|->
name|efi_format
operator|.
name|efi_nextents
condition|;
name|i
operator|++
control|)
block|{
name|extp
operator|=
operator|&
operator|(
name|efip
operator|->
name|efi_format
operator|.
name|efi_extents
index|[
name|i
index|]
operator|)
expr_stmt|;
name|xfs_free_extent
argument_list|(
name|tp
argument_list|,
name|extp
operator|->
name|ext_start
argument_list|,
name|extp
operator|->
name|ext_len
argument_list|)
expr_stmt|;
name|xfs_trans_log_efd_extent
argument_list|(
name|tp
argument_list|,
name|efdp
argument_list|,
name|extp
operator|->
name|ext_start
argument_list|,
name|extp
operator|->
name|ext_len
argument_list|)
expr_stmt|;
block|}
name|efip
operator|->
name|efi_flags
operator||=
name|XFS_EFI_RECOVERED
expr_stmt|;
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that once we've encountered something other than an EFI  * in the AIL that there are no more EFIs in the AIL.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_function
name|STATIC
name|void
name|xlog_recover_check_ail
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_log_item_t
modifier|*
name|lip
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|int
name|orig_gen
init|=
name|gen
decl_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|lip
operator|->
name|li_type
operator|!=
name|XFS_LI_EFI
argument_list|)
expr_stmt|;
name|lip
operator|=
name|xfs_trans_next_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
operator|&
name|gen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * The check will be bogus if we restart from the 		 * beginning of the AIL, so ASSERT that we don't. 		 * We never should since we're holding the AIL lock 		 * the entire time. 		 */
name|ASSERT
argument_list|(
name|gen
operator|==
name|orig_gen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lip
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * When this is called, all of the EFIs which did not have  * corresponding EFDs should be in the AIL.  What we do now  * is free the extents associated with each one.  *  * Since we process the EFIs in normal transactions, they  * will be removed at some point after the commit.  This prevents  * us from just walking down the list processing each one.  * We'll use a flag in the EFI to skip those that we've already  * processed and use the AIL iteration mechanism's generation  * count to try to speed this up at least a bit.  *  * When we start, we know that the EFIs are the only things in  * the AIL.  As we process them, however, other items are added  * to the AIL.  Since everything added to the AIL must come after  * everything already in the AIL, we stop processing as soon as  * we see something other than an EFI in the AIL.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_process_efis
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_efi_log_item_t
modifier|*
name|efip
decl_stmt|;
name|int
name|gen
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lip
operator|=
name|xfs_trans_first_ail
argument_list|(
name|mp
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
while|while
condition|(
name|lip
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We're done when we see something other than an EFI. 		 */
if|if
condition|(
name|lip
operator|->
name|li_type
operator|!=
name|XFS_LI_EFI
condition|)
block|{
name|xlog_recover_check_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
name|gen
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Skip EFIs that we've already processed. 		 */
name|efip
operator|=
operator|(
name|xfs_efi_log_item_t
operator|*
operator|)
name|lip
expr_stmt|;
if|if
condition|(
name|efip
operator|->
name|efi_flags
operator|&
name|XFS_EFI_RECOVERED
condition|)
block|{
name|lip
operator|=
name|xfs_trans_next_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
operator|&
name|gen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xlog_recover_process_efi
argument_list|(
name|mp
argument_list|,
name|efip
argument_list|)
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lip
operator|=
name|xfs_trans_next_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
operator|&
name|gen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine performs a transaction to null out a bad inode pointer  * in an agi unlinked inode hash bucket.  */
end_comment

begin_function
name|STATIC
name|void
name|xlog_recover_clear_agi_bucket
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_agnumber_t
name|agno
parameter_list|,
name|int
name|bucket
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
name|xfs_buf_t
modifier|*
name|agibp
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_CLEAR_AGI_BUCKET
argument_list|)
expr_stmt|;
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_CLEAR_AGI_BUCKET_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|agibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
return|return;
block|}
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_magicnum
argument_list|)
operator|!=
name|XFS_AGI_MAGIC
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
return|return;
block|}
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|NULLAGINO
argument_list|)
expr_stmt|;
name|offset
operator|=
name|offsetof
argument_list|(
name|xfs_agi_t
argument_list|,
name|agi_unlinked
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|*
name|bucket
operator|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|agibp
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xlog_iunlink_recover  *  * This is called during recovery to process any inodes which  * we unlinked but not freed when the system crashed.  These  * inodes will be on the lists in the AGI blocks.  What we do  * here is scan all the AGIs and fully truncate and free any  * inodes found on the lists.  Each inode is removed from the  * lists when it has been fully truncated and is freed.  The  * freeing of the inode and its removal from the list must be  * atomic.  */
end_comment

begin_function
name|void
name|xlog_recover_process_iunlinks
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
name|xfs_buf_t
modifier|*
name|agibp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|ibp
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|int
name|bucket
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint
name|mp_dmevmask
decl_stmt|;
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
comment|/* 	 * Prevent any DMAPI event from being sent while in this function. 	 */
name|mp_dmevmask
operator|=
name|mp
operator|->
name|m_dmevmask
expr_stmt|;
name|mp
operator|->
name|m_dmevmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|agno
operator|=
literal|0
init|;
name|agno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|;
name|agno
operator|++
control|)
block|{
comment|/* 		 * Find the agi for this ag. 		 */
name|agibp
operator|=
name|xfs_buf_read
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISERROR
argument_list|(
name|agibp
argument_list|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_process_iunlinks(#1)"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|agibp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_AGI_MAGIC
operator|==
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_magicnum
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|XFS_AGI_UNLINKED_BUCKETS
condition|;
name|bucket
operator|++
control|)
block|{
name|agino
operator|=
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_unlinked
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|agino
operator|!=
name|NULLAGINO
condition|)
block|{
comment|/* 				 * Release the agi buffer so that it can 				 * be acquired in the normal course of the 				 * transaction to truncate and free the inode. 				 */
name|xfs_buf_relse
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agino
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|||
operator|(
name|ip
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 					 * Get the on disk inode to find the 					 * next inode in the bucket. 					 */
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|ibp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|||
operator|(
name|dip
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_d
operator|.
name|di_nlink
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* setup for the next pass */
name|agino
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_next_unlinked
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* 					 * Prevent any DMAPI event from 					 * being sent when the 					 * reference on the inode is 					 * dropped. 					 */
name|ip
operator|->
name|i_d
operator|.
name|di_dmevmask
operator|=
literal|0
expr_stmt|;
comment|/* 					 * If this is a new inode, handle 					 * it specially.  Otherwise, 					 * just drop our reference to the 					 * inode.  If there are no 					 * other references, this will 					 * send the inode to 					 * xfs_inactive() which will 					 * truncate the file and free 					 * the inode. 					 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
condition|)
name|xfs_iput_new
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * We can't read in the inode 					 * this bucket points to, or 					 * this inode is messed up.  Just 					 * ditch this bucket of inodes.  We 					 * will lose some inodes and space, 					 * but at least we won't hang.  Call 					 * xlog_recover_clear_agi_bucket() 					 * to perform a transaction to clear 					 * the inode pointer in the bucket. 					 */
name|xlog_recover_clear_agi_bucket
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|agino
operator|=
name|NULLAGINO
expr_stmt|;
block|}
comment|/* 				 * Reacquire the agibuffer and continue around 				 * the loop. 				 */
name|agibp
operator|=
name|xfs_buf_read
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISERROR
argument_list|(
name|agibp
argument_list|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_process_iunlinks(#2)"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|agibp
argument_list|,
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_AGI_MAGIC
operator|==
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_magicnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Release the buffer for the current agi so we can 		 * go on to the next one. 		 */
name|xfs_buf_relse
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_dmevmask
operator|=
name|mp_dmevmask
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|STATIC
name|void
name|xlog_pack_data_checksum
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint
modifier|*
name|up
decl_stmt|;
name|uint
name|chksum
init|=
literal|0
decl_stmt|;
name|up
operator|=
operator|(
name|uint
operator|*
operator|)
name|iclog
operator|->
name|ic_datap
expr_stmt|;
comment|/* divide length by 4 to get # words */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size
operator|>>
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|chksum
operator|^=
name|INT_GET
argument_list|(
operator|*
name|up
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|up
operator|++
expr_stmt|;
block|}
name|INT_SET
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_chksum
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|chksum
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xlog_pack_data_checksum
parameter_list|(
name|log
parameter_list|,
name|iclog
parameter_list|,
name|size
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Stamp cycle number in every block  */
end_comment

begin_function
name|void
name|xlog_pack_data
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_in_core_t
modifier|*
name|iclog
parameter_list|,
name|int
name|roundoff
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|size
init|=
name|iclog
operator|->
name|ic_offset
operator|+
name|roundoff
decl_stmt|;
name|uint
name|cycle_lsn
decl_stmt|;
name|xfs_caddr_t
name|dp
decl_stmt|;
name|xlog_in_core_2_t
modifier|*
name|xhdr
decl_stmt|;
name|xlog_pack_data_checksum
argument_list|(
name|log
argument_list|,
name|iclog
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cycle_lsn
operator|=
name|CYCLE_LSN_DISK
argument_list|(
name|iclog
operator|->
name|ic_header
operator|.
name|h_lsn
argument_list|)
expr_stmt|;
name|dp
operator|=
name|iclog
operator|->
name|ic_datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BTOBB
argument_list|(
name|size
argument_list|)
operator|&&
name|i
operator|<
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|iclog
operator|->
name|ic_header
operator|.
name|h_cycle_data
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
expr_stmt|;
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
operator|=
name|cycle_lsn
expr_stmt|;
name|dp
operator|+=
name|BBSIZE
expr_stmt|;
block|}
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|xhdr
operator|=
operator|(
name|xlog_in_core_2_t
operator|*
operator|)
operator|&
name|iclog
operator|->
name|ic_header
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|BTOBB
argument_list|(
name|size
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
operator|/
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|k
operator|=
name|i
operator|%
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|xhdr
index|[
name|j
index|]
operator|.
name|hic_xheader
operator|.
name|xh_cycle_data
index|[
name|k
index|]
operator|=
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
expr_stmt|;
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
operator|=
name|cycle_lsn
expr_stmt|;
name|dp
operator|+=
name|BBSIZE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|log
operator|->
name|l_iclog_heads
condition|;
name|i
operator|++
control|)
block|{
name|xhdr
index|[
name|i
index|]
operator|.
name|hic_xheader
operator|.
name|xh_cycle
operator|=
name|cycle_lsn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|XFS_LOUD_RECOVERY
argument_list|)
end_if

begin_function
name|STATIC
name|void
name|xlog_unpack_data_checksum
parameter_list|(
name|xlog_rec_header_t
modifier|*
name|rhead
parameter_list|,
name|xfs_caddr_t
name|dp
parameter_list|,
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|uint
modifier|*
name|up
init|=
operator|(
name|uint
operator|*
operator|)
name|dp
decl_stmt|;
name|uint
name|chksum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* divide length by 4 to get # words */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>>
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|chksum
operator|^=
name|INT_GET
argument_list|(
operator|*
name|up
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|up
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chksum
operator|!=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_chksum
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
if|if
condition|(
name|rhead
operator|->
name|h_chksum
operator|||
operator|(
operator|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_CHKSUM_MISMATCH
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_DEBUG
argument_list|,
literal|"XFS: LogR chksum mismatch: was (0x%x) is (0x%x)"
argument_list|,
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_chksum
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|chksum
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_DEBUG
argument_list|,
literal|"XFS: Disregard message if filesystem was created with non-DEBUG kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_DEBUG
argument_list|,
literal|"XFS: LogR this is a LogV2 filesystem"
argument_list|)
expr_stmt|;
block|}
name|log
operator|->
name|l_flags
operator||=
name|XLOG_CHKSUM_MISMATCH
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xlog_unpack_data_checksum
parameter_list|(
name|rhead
parameter_list|,
name|dp
parameter_list|,
name|log
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
name|xlog_unpack_data
parameter_list|(
name|xlog_rec_header_t
modifier|*
name|rhead
parameter_list|,
name|xfs_caddr_t
name|dp
parameter_list|,
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|xlog_in_core_2_t
modifier|*
name|xhdr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|&&
name|i
operator|<
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
operator|=
operator|*
operator|(
name|uint
operator|*
operator|)
operator|&
name|rhead
operator|->
name|h_cycle_data
index|[
name|i
index|]
expr_stmt|;
name|dp
operator|+=
name|BBSIZE
expr_stmt|;
block|}
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|xhdr
operator|=
operator|(
name|xlog_in_core_2_t
operator|*
operator|)
name|rhead
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
operator|/
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
name|k
operator|=
name|i
operator|%
operator|(
name|XLOG_HEADER_CYCLE_SIZE
operator|/
name|BBSIZE
operator|)
expr_stmt|;
operator|*
operator|(
name|uint
operator|*
operator|)
name|dp
operator|=
name|xhdr
index|[
name|j
index|]
operator|.
name|hic_xheader
operator|.
name|xh_cycle_data
index|[
name|k
index|]
expr_stmt|;
name|dp
operator|+=
name|BBSIZE
expr_stmt|;
block|}
block|}
name|xlog_unpack_data_checksum
argument_list|(
name|rhead
argument_list|,
name|dp
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xlog_valid_rec_header
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xlog_rec_header_t
modifier|*
name|rhead
parameter_list|,
name|xfs_daddr_t
name|blkno
parameter_list|)
block|{
name|int
name|hlen
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_magicno
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XLOG_HEADER_MAGIC_NUM
operator|)
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_valid_rec_header(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|!
name|rhead
operator|->
name|h_version
operator|||
operator|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&
operator|(
operator|~
name|XLOG_VERSION_OKBITS
operator|)
operator|)
operator|!=
literal|0
operator|)
argument_list|)
condition|)
block|{
name|xlog_warn
argument_list|(
literal|"XFS: %s: unrecognised log version (%d)."
argument_list|,
name|__FUNCTION__
argument_list|,
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
comment|/* LR body must have data or it wouldn't have been written */
name|hlen
operator|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|hlen
operator|<=
literal|0
operator|||
name|hlen
operator|>
name|INT_MAX
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_valid_rec_header(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|blkno
operator|>
name|log
operator|->
name|l_logBBsize
operator|||
name|blkno
operator|>
name|INT_MAX
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xlog_valid_rec_header(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read the log from tail to head and process the log records found.  * Handle the two cases where the tail and head are in the same cycle  * and where the active portion of the log wraps around the end of  * the physical log separately.  The pass parameter is passed through  * to the routines called to process the data and is not looked at  * here.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_do_recovery_pass
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|head_blk
parameter_list|,
name|xfs_daddr_t
name|tail_blk
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|xlog_rec_header_t
modifier|*
name|rhead
decl_stmt|;
name|xfs_daddr_t
name|blk_no
decl_stmt|;
name|xfs_caddr_t
name|bufaddr
decl_stmt|,
name|offset
decl_stmt|;
name|xfs_buf_t
modifier|*
name|hbp
decl_stmt|,
modifier|*
name|dbp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|h_size
decl_stmt|;
name|int
name|bblks
decl_stmt|,
name|split_bblks
decl_stmt|;
name|int
name|hblks
decl_stmt|,
name|split_hblks
decl_stmt|,
name|wrapped_hblks
decl_stmt|;
name|xlog_recover_t
modifier|*
name|rhash
index|[
name|XLOG_RHASH_SIZE
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|head_blk
operator|!=
name|tail_blk
argument_list|)
expr_stmt|;
comment|/* 	 * Read the header of the tail block and get the iclog buffer size from 	 * h_size.  Use this to tell how many sectors make up the log header. 	 */
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
comment|/* 		 * When using variable length iclogs, read first sector of 		 * iclog header and extract the header size from it.  Get a 		 * new hbp that is the correct size. 		 */
name|hbp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hbp
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|tail_blk
argument_list|,
literal|1
argument_list|,
name|hbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err1
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|tail_blk
argument_list|,
literal|1
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
name|rhead
operator|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|offset
expr_stmt|;
name|error
operator|=
name|xlog_valid_rec_header
argument_list|(
name|log
argument_list|,
name|rhead
argument_list|,
name|tail_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err1
goto|;
name|h_size
operator|=
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&
name|XLOG_VERSION_2
operator|)
operator|&&
operator|(
name|h_size
operator|>
name|XLOG_HEADER_CYCLE_SIZE
operator|)
condition|)
block|{
name|hblks
operator|=
name|h_size
operator|/
name|XLOG_HEADER_CYCLE_SIZE
expr_stmt|;
if|if
condition|(
name|h_size
operator|%
name|XLOG_HEADER_CYCLE_SIZE
condition|)
name|hblks
operator|++
expr_stmt|;
name|xlog_put_bp
argument_list|(
name|hbp
argument_list|)
expr_stmt|;
name|hbp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
name|hblks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hblks
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|log
operator|->
name|l_sectbb_log
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hblks
operator|=
literal|1
expr_stmt|;
name|hbp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|h_size
operator|=
name|XLOG_BIG_RECORD_BSIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hbp
condition|)
return|return
name|ENOMEM
return|;
name|dbp
operator|=
name|xlog_get_bp
argument_list|(
name|log
argument_list|,
name|BTOBB
argument_list|(
name|h_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbp
condition|)
block|{
name|xlog_put_bp
argument_list|(
name|hbp
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memset
argument_list|(
name|rhash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rhash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail_blk
operator|<=
name|head_blk
condition|)
block|{
for|for
control|(
name|blk_no
operator|=
name|tail_blk
init|;
name|blk_no
operator|<
name|head_blk
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|hblks
argument_list|,
name|hbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
name|rhead
operator|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|offset
expr_stmt|;
name|error
operator|=
name|xlog_valid_rec_header
argument_list|(
name|log
argument_list|,
name|rhead
argument_list|,
name|blk_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
comment|/* blocks in data section */
name|bblks
operator|=
operator|(
name|int
operator|)
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
operator|+
name|hblks
argument_list|,
name|bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
operator|+
name|hblks
argument_list|,
name|bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xlog_unpack_data
argument_list|(
name|rhead
argument_list|,
name|offset
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_process_data
argument_list|(
name|log
argument_list|,
name|rhash
argument_list|,
name|rhead
argument_list|,
name|offset
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|blk_no
operator|+=
name|bblks
operator|+
name|hblks
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Perform recovery around the end of the physical log. 		 * When the head is not on the same cycle number as the tail, 		 * we can't do a sequential recovery as above. 		 */
name|blk_no
operator|=
name|tail_blk
expr_stmt|;
while|while
condition|(
name|blk_no
operator|<
name|log
operator|->
name|l_logBBsize
condition|)
block|{
comment|/* 			 * Check for header wrapping around physical end-of-log 			 */
name|offset
operator|=
name|NULL
expr_stmt|;
name|split_hblks
operator|=
literal|0
expr_stmt|;
name|wrapped_hblks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blk_no
operator|+
name|hblks
operator|<=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
comment|/* Read header in one read */
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This LR is split across physical log end */
if|if
condition|(
name|blk_no
operator|!=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
comment|/* some data before physical log end */
name|ASSERT
argument_list|(
name|blk_no
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
name|split_hblks
operator|=
name|log
operator|->
name|l_logBBsize
operator|-
operator|(
name|int
operator|)
name|blk_no
expr_stmt|;
name|ASSERT
argument_list|(
name|split_hblks
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|split_hblks
argument_list|,
name|hbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|split_hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Note: this black magic still works with 				 * large sector sizes (non-512) only because: 				 * - we increased the buffer size originally 				 *   by 1 sector giving us enough extra space 				 *   for the second read; 				 * - the log start is guaranteed to be sector 				 *   aligned; 				 * - we read the log end (LR header start) 				 *   _first_, then the log start (LR header end) 				 *   - order is important. 				 */
name|bufaddr
operator|=
name|XFS_BUF_PTR
argument_list|(
name|hbp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_PTR
argument_list|(
name|hbp
argument_list|,
name|bufaddr
operator|+
name|BBTOB
argument_list|(
name|split_hblks
argument_list|)
argument_list|,
name|BBTOB
argument_list|(
name|hblks
operator|-
name|split_hblks
argument_list|)
argument_list|)
expr_stmt|;
name|wrapped_hblks
operator|=
name|hblks
operator|-
name|split_hblks
expr_stmt|;
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
name|wrapped_hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
name|XFS_BUF_SET_PTR
argument_list|(
name|hbp
argument_list|,
name|bufaddr
argument_list|,
name|BBTOB
argument_list|(
name|hblks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
literal|0
argument_list|,
name|wrapped_hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
block|}
name|rhead
operator|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|offset
expr_stmt|;
name|error
operator|=
name|xlog_valid_rec_header
argument_list|(
name|log
argument_list|,
name|rhead
argument_list|,
name|split_hblks
condition|?
name|blk_no
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
name|bblks
operator|=
operator|(
name|int
operator|)
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
name|blk_no
operator|+=
name|hblks
expr_stmt|;
comment|/* Read in data for log record */
if|if
condition|(
name|blk_no
operator|+
name|bblks
operator|<=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This log record is split across the 				 * physical end of log */
name|offset
operator|=
name|NULL
expr_stmt|;
name|split_bblks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blk_no
operator|!=
name|log
operator|->
name|l_logBBsize
condition|)
block|{
comment|/* some data is before the physical 					 * end of log */
name|ASSERT
argument_list|(
operator|!
name|wrapped_hblks
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blk_no
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
name|split_bblks
operator|=
name|log
operator|->
name|l_logBBsize
operator|-
operator|(
name|int
operator|)
name|blk_no
expr_stmt|;
name|ASSERT
argument_list|(
name|split_bblks
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|split_bblks
argument_list|,
name|dbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|split_bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Note: this black magic still works with 				 * large sector sizes (non-512) only because: 				 * - we increased the buffer size originally 				 *   by 1 sector giving us enough extra space 				 *   for the second read; 				 * - the log start is guaranteed to be sector 				 *   aligned; 				 * - we read the log end (LR header start) 				 *   _first_, then the log start (LR header end) 				 *   - order is important. 				 */
name|bufaddr
operator|=
name|XFS_BUF_PTR
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|XFS_BUF_SET_PTR
argument_list|(
name|dbp
argument_list|,
name|bufaddr
operator|+
name|BBTOB
argument_list|(
name|split_bblks
argument_list|)
argument_list|,
name|BBTOB
argument_list|(
name|bblks
operator|-
name|split_bblks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|wrapped_hblks
argument_list|,
name|bblks
operator|-
name|split_bblks
argument_list|,
name|dbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|XFS_BUF_SET_PTR
argument_list|(
name|dbp
argument_list|,
name|bufaddr
argument_list|,
name|h_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|wrapped_hblks
argument_list|,
name|bblks
operator|-
name|split_bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
name|xlog_unpack_data
argument_list|(
name|rhead
argument_list|,
name|offset
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_process_data
argument_list|(
name|log
argument_list|,
name|rhash
argument_list|,
name|rhead
argument_list|,
name|offset
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|blk_no
operator|+=
name|bblks
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|blk_no
operator|>=
name|log
operator|->
name|l_logBBsize
argument_list|)
expr_stmt|;
name|blk_no
operator|-=
name|log
operator|->
name|l_logBBsize
expr_stmt|;
comment|/* read first part of physical log */
while|while
condition|(
name|blk_no
operator|<
name|head_blk
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|hblks
argument_list|,
name|hbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
argument_list|,
name|hblks
argument_list|,
name|hbp
argument_list|)
expr_stmt|;
name|rhead
operator|=
operator|(
name|xlog_rec_header_t
operator|*
operator|)
name|offset
expr_stmt|;
name|error
operator|=
name|xlog_valid_rec_header
argument_list|(
name|log
argument_list|,
name|rhead
argument_list|,
name|blk_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bread_err2
goto|;
name|bblks
operator|=
operator|(
name|int
operator|)
name|BTOBB
argument_list|(
name|INT_GET
argument_list|(
name|rhead
operator|->
name|h_len
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_bread
argument_list|(
name|log
argument_list|,
name|blk_no
operator|+
name|hblks
argument_list|,
name|bblks
argument_list|,
name|dbp
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|offset
operator|=
name|xlog_align
argument_list|(
name|log
argument_list|,
name|blk_no
operator|+
name|hblks
argument_list|,
name|bblks
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xlog_unpack_data
argument_list|(
name|rhead
argument_list|,
name|offset
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_recover_process_data
argument_list|(
name|log
argument_list|,
name|rhash
argument_list|,
name|rhead
argument_list|,
name|offset
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
goto|goto
name|bread_err2
goto|;
name|blk_no
operator|+=
name|bblks
operator|+
name|hblks
expr_stmt|;
block|}
block|}
name|bread_err2
label|:
name|xlog_put_bp
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|bread_err1
label|:
name|xlog_put_bp
argument_list|(
name|hbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Do the recovery of the log.  We actually do this in two phases.  * The two passes are necessary in order to implement the function  * of cancelling a record written into the log.  The first pass  * determines those things which have been cancelled, and the  * second pass replays log items normally except for those which  * have been cancelled.  The handling of the replay and cancellations  * takes place in the log item type specific routines.  *  * The table of items which have cancel records in the log is allocated  * and freed at this level, since only here do we know when all of  * the log recovery has been completed.  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_do_log_recovery
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|head_blk
parameter_list|,
name|xfs_daddr_t
name|tail_blk
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|head_blk
operator|!=
name|tail_blk
argument_list|)
expr_stmt|;
comment|/* 	 * First do a pass to find all of the cancelled buf log items. 	 * Store them in the buf_cancel_table for use in the second pass. 	 */
name|log
operator|->
name|l_buf_cancel_table
operator|=
operator|(
name|xfs_buf_cancel_t
operator|*
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|XLOG_BC_TABLE_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|xfs_buf_cancel_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|xlog_do_recovery_pass
argument_list|(
name|log
argument_list|,
name|head_blk
argument_list|,
name|tail_blk
argument_list|,
name|XLOG_RECOVER_PASS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|log
operator|->
name|l_buf_cancel_table
argument_list|,
name|XLOG_BC_TABLE_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|xfs_buf_cancel_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_buf_cancel_table
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Then do a second pass to actually recover the items in the log. 	 * When it is complete free the table of buf cancel items. 	 */
name|error
operator|=
name|xlog_do_recovery_pass
argument_list|(
name|log
argument_list|,
name|head_blk
argument_list|,
name|tail_blk
argument_list|,
name|XLOG_RECOVER_PASS2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XLOG_BC_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|ASSERT
argument_list|(
name|log
operator|->
name|l_buf_cancel_table
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|kmem_free
argument_list|(
name|log
operator|->
name|l_buf_cancel_table
argument_list|,
name|XLOG_BC_TABLE_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|xfs_buf_cancel_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_buf_cancel_table
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Do the actual recovery  */
end_comment

begin_function
name|STATIC
name|int
name|xlog_do_recover
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|xfs_daddr_t
name|head_blk
parameter_list|,
name|xfs_daddr_t
name|tail_blk
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
comment|/* 	 * XXX: Disable log recovery for now, until we fix panics. 	 */
name|printf
argument_list|(
literal|"XFS log recovery disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * First replay the images in the log. 	 */
name|error
operator|=
name|xlog_do_log_recovery
argument_list|(
name|log
argument_list|,
name|head_blk
argument_list|,
name|tail_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|XFS_bflush
argument_list|(
name|log
operator|->
name|l_mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
comment|/* 	 * If IO errors happened during recovery, bail out. 	 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|log
operator|->
name|l_mp
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * We now update the tail_lsn since much of the recovery has completed 	 * and there may be space available to use.  If there were no extent 	 * or iunlinks, we can free up the entire log and set the tail_lsn to 	 * be the last_sync_lsn.  This was set in xlog_find_tail to be the 	 * lsn of the last known good LR on disk.  If there are extent frees 	 * or iunlinks they will have some entries in the AIL; so we look at 	 * the AIL to determine how to set the tail_lsn. 	 */
name|xlog_assign_tail_lsn
argument_list|(
name|log
operator|->
name|l_mp
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've finished replaying all buffer and inode 	 * updates, re-read in the superblock. 	 */
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDONE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|XFS_BUF_READ
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_iowait
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_do_recover"
argument_list|,
name|log
operator|->
name|l_mp
argument_list|,
name|bp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Convert superblock from on-disk format */
name|sbp
operator|=
operator|&
name|log
operator|->
name|l_mp
operator|->
name|m_sb
expr_stmt|;
name|xfs_xlatesb
argument_list|(
name|XFS_BUF_TO_SBP
argument_list|(
name|bp
argument_list|)
argument_list|,
name|sbp
argument_list|,
literal|1
argument_list|,
name|XFS_SB_ALL_BITS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sbp
operator|->
name|sb_magicnum
operator|==
name|XFS_SB_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_SB_GOOD_VERSION
argument_list|(
name|sbp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xlog_recover_check_summary
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* Normal transactions can now occur */
name|log
operator|->
name|l_flags
operator|&=
operator|~
name|XLOG_ACTIVE_RECOVERY
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Perform recovery and re-initialize some log variables in xlog_find_tail.  *  * Return error or zero.  */
end_comment

begin_function
name|int
name|xlog_recover
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xfs_daddr_t
name|head_blk
decl_stmt|,
name|tail_blk
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* find the tail of the log */
if|if
condition|(
operator|(
name|error
operator|=
name|xlog_find_tail
argument_list|(
name|log
argument_list|,
operator|&
name|head_blk
argument_list|,
operator|&
name|tail_blk
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|tail_blk
operator|!=
name|head_blk
condition|)
block|{
comment|/* There used to be a comment here: 		 * 		 * disallow recovery on read-only mounts.  note -- mount 		 * checks for ENOSPC and turns it into an intelligent 		 * error message. 		 * ...but this is no longer true.  Now, unless you specify 		 * NORECOVERY (in which case this function would never be 		 * called), we just go ahead and recover.  We do this all 		 * under the vfs layer, so we can get away with it unless 		 * the device itself is read-only, in which case we fail. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dev_is_read_only
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
literal|"recovery required"
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"Starting XFS recovery on filesystem: %s (logdev: %s)"
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_fsname
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_logname
condition|?
name|log
operator|->
name|l_mp
operator|->
name|m_logname
else|:
literal|"internal"
argument_list|)
expr_stmt|;
name|error
operator|=
name|xlog_do_recover
argument_list|(
name|log
argument_list|,
name|head_blk
argument_list|,
name|tail_blk
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_flags
operator||=
name|XLOG_RECOVERY_NEEDED
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * In the first part of recovery we replay inodes and buffers and build  * up the list of extent free items which need to be processed.  Here  * we process the extent free items and clean up the on disk unlinked  * inode lists.  This is separated from the first part of recovery so  * that the root and real-time bitmap inodes can be read in from disk in  * between the two stages.  This is necessary so that we can free space  * in the real-time portion of the file system.  */
end_comment

begin_function
name|int
name|xlog_recover_finish
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|,
name|int
name|mfsi_flags
parameter_list|)
block|{
comment|/* 	 * Now we're ready to do the transactions needed for the 	 * rest of recovery.  Start with completing all the extent 	 * free intent records and then process the unlinked inode 	 * lists.  At this point, we essentially run in normal mode 	 * except that we're still performing recovery actions 	 * rather than accepting new requests. 	 */
if|if
condition|(
name|log
operator|->
name|l_flags
operator|&
name|XLOG_RECOVERY_NEEDED
condition|)
block|{
name|xlog_recover_process_efis
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* 		 * Sync the log to get all the EFIs out of the AIL. 		 * This isn't absolutely necessary, but it helps in 		 * case the unlink transactions would have problems 		 * pushing the EFIs out of the way. 		 */
name|xfs_log_force
argument_list|(
name|log
operator|->
name|l_mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
operator|(
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_NOUNLINK
operator|)
operator|==
literal|0
condition|)
block|{
name|xlog_recover_process_iunlinks
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
name|xlog_recover_check_summary
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"Ending XFS recovery on filesystem: %s (logdev: %s)"
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_fsname
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_logname
condition|?
name|log
operator|->
name|l_mp
operator|->
name|m_logname
else|:
literal|"internal"
argument_list|)
expr_stmt|;
name|log
operator|->
name|l_flags
operator|&=
operator|~
name|XLOG_RECOVERY_NEEDED
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_DEBUG
argument_list|,
literal|"!Ending clean XFS mount for filesystem: %s"
argument_list|,
name|log
operator|->
name|l_mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_comment
comment|/*  * Read all of the agf and agi counters and check that they  * are consistent with the superblock counters.  */
end_comment

begin_function
name|void
name|xlog_recover_check_summary
parameter_list|(
name|xlog_t
modifier|*
name|log
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_agf_t
modifier|*
name|agfp
decl_stmt|;
name|xfs_agi_t
modifier|*
name|agip
decl_stmt|;
name|xfs_buf_t
modifier|*
name|agfbp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|agibp
decl_stmt|;
name|xfs_daddr_t
name|agfdaddr
decl_stmt|;
name|xfs_daddr_t
name|agidaddr
decl_stmt|;
name|xfs_buf_t
modifier|*
name|sbbp
decl_stmt|;
ifdef|#
directive|ifdef
name|XFS_LOUD_RECOVERY
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
endif|#
directive|endif
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|__uint64_t
name|freeblks
decl_stmt|;
name|__uint64_t
name|itotal
decl_stmt|;
name|__uint64_t
name|ifree
decl_stmt|;
name|mp
operator|=
name|log
operator|->
name|l_mp
expr_stmt|;
name|freeblks
operator|=
literal|0LL
expr_stmt|;
name|itotal
operator|=
literal|0LL
expr_stmt|;
name|ifree
operator|=
literal|0LL
expr_stmt|;
for|for
control|(
name|agno
operator|=
literal|0
init|;
name|agno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|;
name|agno
operator|++
control|)
block|{
name|agfdaddr
operator|=
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGF_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|agfbp
operator|=
name|xfs_buf_read
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|agfdaddr
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISERROR
argument_list|(
name|agfbp
argument_list|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_check_summary(agf)"
argument_list|,
name|mp
argument_list|,
name|agfbp
argument_list|,
name|agfdaddr
argument_list|)
expr_stmt|;
block|}
name|agfp
operator|=
name|XFS_BUF_TO_AGF
argument_list|(
name|agfbp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_AGF_MAGIC
operator|==
name|be32_to_cpu
argument_list|(
name|agfp
operator|->
name|agf_magicnum
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_AGF_GOOD_VERSION
argument_list|(
name|be32_to_cpu
argument_list|(
name|agfp
operator|->
name|agf_versionnum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|agfp
operator|->
name|agf_seqno
argument_list|)
operator|==
name|agno
argument_list|)
expr_stmt|;
name|freeblks
operator|+=
name|be32_to_cpu
argument_list|(
name|agfp
operator|->
name|agf_freeblks
argument_list|)
operator|+
name|be32_to_cpu
argument_list|(
name|agfp
operator|->
name|agf_flcount
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|agfbp
argument_list|)
expr_stmt|;
name|agidaddr
operator|=
name|XFS_AG_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|XFS_AGI_DADDR
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|agibp
operator|=
name|xfs_buf_read
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|agidaddr
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BUF_ISERROR
argument_list|(
name|agibp
argument_list|)
condition|)
block|{
name|xfs_ioerror_alert
argument_list|(
literal|"xlog_recover_check_summary(agi)"
argument_list|,
name|mp
argument_list|,
name|agibp
argument_list|,
name|agidaddr
argument_list|)
expr_stmt|;
block|}
name|agip
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_AGI_MAGIC
operator|==
name|be32_to_cpu
argument_list|(
name|agip
operator|->
name|agi_magicnum
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_AGI_GOOD_VERSION
argument_list|(
name|be32_to_cpu
argument_list|(
name|agip
operator|->
name|agi_versionnum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|agip
operator|->
name|agi_seqno
argument_list|)
operator|==
name|agno
argument_list|)
expr_stmt|;
name|itotal
operator|+=
name|be32_to_cpu
argument_list|(
name|agip
operator|->
name|agi_count
argument_list|)
expr_stmt|;
name|ifree
operator|+=
name|be32_to_cpu
argument_list|(
name|agip
operator|->
name|agi_freecount
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|agibp
argument_list|)
expr_stmt|;
block|}
name|sbbp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_LOUD_RECOVERY
name|sbp
operator|=
operator|&
name|mp
operator|->
name|m_sb
expr_stmt|;
name|xfs_xlatesb
argument_list|(
name|XFS_BUF_TO_SBP
argument_list|(
name|sbbp
argument_list|)
argument_list|,
name|sbp
argument_list|,
literal|1
argument_list|,
name|XFS_SB_ALL_BITS
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"xlog_recover_check_summary: sb_icount %Lu itotal %Lu"
argument_list|,
name|sbp
operator|->
name|sb_icount
argument_list|,
name|itotal
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"xlog_recover_check_summary: sb_ifree %Lu itotal %Lu"
argument_list|,
name|sbp
operator|->
name|sb_ifree
argument_list|,
name|ifree
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"xlog_recover_check_summary: sb_fdblocks %Lu freeblks %Lu"
argument_list|,
name|sbp
operator|->
name|sb_fdblocks
argument_list|,
name|freeblks
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * This is turned off until I account for the allocation 	 * btree blocks which live in free space. 	 */
block|ASSERT(sbp->sb_icount == itotal); 	ASSERT(sbp->sb_ifree == ifree); 	ASSERT(sbp->sb_fdblocks == freeblks);
endif|#
directive|endif
endif|#
directive|endif
name|xfs_buf_relse
argument_list|(
name|sbbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

