begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fsops.h"
end_include

begin_function_decl
name|STATIC
name|void
name|xfs_mount_log_sbunit
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|__int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_uuid_mount
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_uuid_unmount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
block|{
name|short
name|offset
decl_stmt|;
name|short
name|type
decl_stmt|;
comment|/* 0 = integer 		* 1 = binary / string (no translation) 		*/
block|}
name|xfs_sb_info
index|[]
init|=
block|{
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_magicnum
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_blocksize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_dblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rextents
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_uuid
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logstart
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rootino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rbmino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rsumino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rextsize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_agblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_agcount
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rbmblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_versionnum
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_sectsize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inodesize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inopblock
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_fname
index|[
literal|0
index|]
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_blocklog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_sectlog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inodelog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inopblog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_agblklog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rextslog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inprogress
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_imax_pct
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_icount
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_ifree
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_fdblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_frextents
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_uquotino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_gquotino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_qflags
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_flags
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_shared_vn
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inoalignmt
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_unit
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_width
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_dirblklog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logsectlog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logsectsize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logsunit
argument_list|)
block|,
literal|0
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|xfs_sb_t
argument_list|)
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return a pointer to an initialized xfs_mount structure.  */
end_comment

begin_function
name|xfs_mount_t
modifier|*
name|xfs_mount_init
parameter_list|(
name|void
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|AIL_LOCKINIT
argument_list|(
operator|&
name|mp
operator|->
name|m_ail_lock
argument_list|,
literal|"xfs_ail"
argument_list|)
expr_stmt|;
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_sb_lock
argument_list|,
literal|"xfs_sb"
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|mp
operator|->
name|m_ilock
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
literal|"xfs_ilock"
argument_list|)
expr_stmt|;
name|initnsema
argument_list|(
operator|&
name|mp
operator|->
name|m_growlock
argument_list|,
literal|1
argument_list|,
literal|"xfs_grow"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the AIL. 	 */
name|xfs_trans_ail_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Init freeze sync structures */
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|,
literal|"xfs_freeze"
argument_list|)
expr_stmt|;
name|init_sv
argument_list|(
operator|&
name|mp
operator|->
name|m_wait_unfreeze
argument_list|,
name|SV_DEFAULT
argument_list|,
literal|"xfs_freeze"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|mp
operator|->
name|m_active_trans
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Moved from elsewhere. Linux initializes those 'on demand' part 	 * way through mount code. This spells trouble for FreeBSD and 	 * WITNESS because the mount can fail and we hit lock destruction 	 * code for locks that might not even been initialized yet. 	 */
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_agirotor_lock
argument_list|,
literal|"m_agirotor_lock"
argument_list|)
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the resources associated with a mount structure.  Assume that  * the structure was initially zeroed, so we can tell which fields got  * initialized.  */
end_comment

begin_function
name|void
name|xfs_mount_free
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|remove_bhv
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_ihash
condition|)
name|xfs_ihash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_chash
condition|)
name|xfs_chash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_perag
condition|)
block|{
name|int
name|agno
decl_stmt|;
for|for
control|(
name|agno
operator|=
literal|0
init|;
name|agno
operator|<
name|mp
operator|->
name|m_maxagi
condition|;
name|agno
operator|++
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagf_init
condition|)
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_perag_busy_t
argument_list|)
operator|*
name|XFS_PAGB_NUM_SLOTS
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_perag_t
argument_list|)
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
name|free_rwsem
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
block|}
name|AIL_LOCK_DESTROY
argument_list|(
operator|&
name|mp
operator|->
name|m_ail_lock
argument_list|)
expr_stmt|;
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_sb_lock
argument_list|)
expr_stmt|;
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_agirotor_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_ilock
argument_list|)
expr_stmt|;
name|freesema
argument_list|(
operator|&
name|mp
operator|->
name|m_growlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_quotainfo
condition|)
name|XFS_QM_DONE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_fsname
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_fsname
argument_list|,
name|mp
operator|->
name|m_fsname_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_bhv
condition|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|bhv_remove_all_vfsops
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VFS_REMOVEBHV
argument_list|(
name|vfsp
argument_list|,
operator|&
name|mp
operator|->
name|m_bhv
argument_list|)
expr_stmt|;
block|}
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|)
expr_stmt|;
name|sv_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_wait_unfreeze
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_mount_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the validity of the SB found.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_mount_validate_sb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_t
modifier|*
name|sbp
parameter_list|)
block|{
comment|/* 	 * If the log device and data device have the 	 * same device number, the log is internal. 	 * Consequently, the sb_logstart should be non-zero.  If 	 * we have a zero sb_logstart in this case, we may be trying to mount 	 * a volume filesystem in a non-volume manner. 	 */
if|if
condition|(
name|sbp
operator|->
name|sb_magicnum
operator|!=
name|XFS_SB_MAGIC
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: bad magic number"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EWRONGFS
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|XFS_SB_GOOD_VERSION
argument_list|(
name|sbp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: bad version"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EWRONGFS
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_logstart
operator|==
literal|0
operator|&&
name|mp
operator|->
name|m_logdev_targp
operator|==
name|mp
operator|->
name|m_ddev_targp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: filesystem is marked as having an external log; "
literal|"specify logdev on the\nmount command line."
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_mount_validate_sb(1)"
argument_list|,
name|XFS_ERRLEVEL_HIGH
argument_list|,
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_logstart
operator|!=
literal|0
operator|&&
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: filesystem is marked as having an internal log; "
literal|"don't specify logdev on\nthe mount command line."
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_mount_validate_sb(2)"
argument_list|,
name|XFS_ERRLEVEL_HIGH
argument_list|,
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * More sanity checking. These were stolen directly from 	 * xfs_repair. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|<=
literal|0
operator|||
name|sbp
operator|->
name|sb_sectsize
operator|<
name|XFS_MIN_SECTORSIZE
operator|||
name|sbp
operator|->
name|sb_sectsize
operator|>
name|XFS_MAX_SECTORSIZE
operator|||
name|sbp
operator|->
name|sb_sectlog
operator|<
name|XFS_MIN_SECTORSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_sectlog
operator|>
name|XFS_MAX_SECTORSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_blocksize
operator|<
name|XFS_MIN_BLOCKSIZE
operator|||
name|sbp
operator|->
name|sb_blocksize
operator|>
name|XFS_MAX_BLOCKSIZE
operator|||
name|sbp
operator|->
name|sb_blocklog
operator|<
name|XFS_MIN_BLOCKSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_blocklog
operator|>
name|XFS_MAX_BLOCKSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_inodesize
operator|<
name|XFS_DINODE_MIN_SIZE
operator|||
name|sbp
operator|->
name|sb_inodesize
operator|>
name|XFS_DINODE_MAX_SIZE
operator|||
operator|(
name|sbp
operator|->
name|sb_rextsize
operator|*
name|sbp
operator|->
name|sb_blocksize
operator|>
name|XFS_MAX_RTEXTSIZE
operator|)
operator|||
operator|(
name|sbp
operator|->
name|sb_rextsize
operator|*
name|sbp
operator|->
name|sb_blocksize
operator|<
name|XFS_MIN_RTEXTSIZE
operator|)
operator|||
name|sbp
operator|->
name|sb_imax_pct
operator|>
literal|100
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: SB sanity check 1 failed"
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_mount_validate_sb(3)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Sanity check AG count, size fields against data size field 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_dblocks
operator|==
literal|0
operator|||
name|sbp
operator|->
name|sb_dblocks
operator|>
operator|(
name|xfs_drfsbno_t
operator|)
name|sbp
operator|->
name|sb_agcount
operator|*
name|sbp
operator|->
name|sb_agblocks
operator|||
name|sbp
operator|->
name|sb_dblocks
operator|<
call|(
name|xfs_drfsbno_t
call|)
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|-
literal|1
argument_list|)
operator|*
name|sbp
operator|->
name|sb_agblocks
operator|+
name|XFS_MIN_AG_BLOCKS
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: SB sanity check 2 failed"
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_mount_validate_sb(4)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|XFS_BIG_BLKNOS
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|sbp
operator|->
name|sb_dblocks
operator|<<
call|(
name|__uint64_t
call|)
argument_list|(
name|sbp
operator|->
name|sb_blocklog
operator|-
name|BBSHIFT
argument_list|)
operator|)
operator|>
name|UINT_MAX
operator|||
operator|(
name|sbp
operator|->
name|sb_rblocks
operator|<<
call|(
name|__uint64_t
call|)
argument_list|(
name|sbp
operator|->
name|sb_blocklog
operator|-
name|BBSHIFT
argument_list|)
operator|)
operator|>
name|UINT_MAX
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: File system is too large to be mounted on this system."
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_inprogress
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: file system busy"
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_mount_validate_sb(5)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Until this is fixed only page-sized or smaller data blocks work. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_blocksize
operator|>
name|PAGE_SIZE
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Attempted to mount file system with blocksize %d bytes"
argument_list|,
name|sbp
operator|->
name|sb_blocksize
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Only page-sized (%d) or less blocksizes currently work."
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSYS
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xfs_initialize_perag
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|agcount
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|max_metadata
decl_stmt|;
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
init|=
operator|&
name|mp
operator|->
name|m_sb
decl_stmt|;
name|xfs_ino_t
name|max_inum
init|=
name|XFS_MAXINUMBER_32
decl_stmt|;
comment|/* Check to see if the filesystem can overflow 32 bit inodes */
name|agino
operator|=
name|XFS_OFFBNO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_agblocks
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agcount
operator|-
literal|1
argument_list|,
name|agino
argument_list|)
expr_stmt|;
comment|/* Clear the mount flag if no inode can overflow 32 bits 	 * on this filesystem, or if specifically requested.. 	 */
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_32BITINOOPT
operator|)
operator|&&
name|ino
operator|>
name|max_inum
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_32BITINODES
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|XFS_MOUNT_32BITINODES
expr_stmt|;
block|}
comment|/* If we can overflow then setup the ag headers accordingly */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_32BITINODES
condition|)
block|{
comment|/* Calculate how much should be reserved for inodes to 		 * meet the max inode percentage. 		 */
if|if
condition|(
name|mp
operator|->
name|m_maxicount
condition|)
block|{
name|__uint64_t
name|icount
decl_stmt|;
name|icount
operator|=
name|sbp
operator|->
name|sb_dblocks
operator|*
name|sbp
operator|->
name|sb_imax_pct
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|icount
operator|+=
name|sbp
operator|->
name|sb_agblocks
operator|-
literal|1
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
name|mp
operator|->
name|m_ialloc_blks
argument_list|)
expr_stmt|;
name|max_metadata
operator|=
name|icount
expr_stmt|;
block|}
else|else
block|{
name|max_metadata
operator|=
name|agcount
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|agcount
condition|;
name|index
operator|++
control|)
block|{
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|index
argument_list|,
name|agino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|>
name|max_inum
condition|)
block|{
name|index
operator|++
expr_stmt|;
break|break;
block|}
comment|/* This ag is prefered for inodes */
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|index
index|]
expr_stmt|;
name|pag
operator|->
name|pagi_inodeok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|max_metadata
condition|)
name|pag
operator|->
name|pagf_metadata
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Setup default behavior for smaller filesystems */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|agcount
condition|;
name|index
operator|++
control|)
block|{
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|index
index|]
expr_stmt|;
name|pag
operator|->
name|pagi_inodeok
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|mp
operator|->
name|m_maxagi
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xfs_xlatesb  *  *     data       - on disk version of sb  *     sb         - a superblock  *     dir        - conversion direction:<0 - convert sb to buf  *>0 - convert buf to sb  *     arch       - architecture to read/write from/to buf  *     fields     - which fields to copy (bitmask)  */
end_comment

begin_function
name|void
name|xfs_xlatesb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|xfs_sb_t
modifier|*
name|sb
parameter_list|,
name|int
name|dir
parameter_list|,
name|xfs_arch_t
name|arch
parameter_list|,
name|__int64_t
name|fields
parameter_list|)
block|{
name|xfs_caddr_t
name|buf_ptr
decl_stmt|;
name|xfs_caddr_t
name|mem_ptr
decl_stmt|;
name|xfs_sb_field_t
name|f
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
return|return;
name|buf_ptr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|data
expr_stmt|;
name|mem_ptr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|sb
expr_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
name|f
operator|=
operator|(
name|xfs_sb_field_t
operator|)
name|xfs_lowbit64
argument_list|(
operator|(
name|__uint64_t
operator|)
name|fields
argument_list|)
expr_stmt|;
name|first
operator|=
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|offset
expr_stmt|;
name|size
operator|=
name|xfs_sb_info
index|[
name|f
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
name|first
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|type
operator|==
literal|0
operator|||
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|type
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|ARCH_NOCONVERT
operator|||
name|size
operator|==
literal|1
operator|||
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|type
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|mem_ptr
operator|+
name|first
argument_list|,
name|buf_ptr
operator|+
name|first
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buf_ptr
operator|+
name|first
argument_list|,
name|mem_ptr
operator|+
name|first
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|INT_XLATE
argument_list|(
operator|*
operator|(
name|__uint16_t
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
name|first
operator|)
argument_list|,
operator|*
operator|(
name|__uint16_t
operator|*
operator|)
operator|(
name|mem_ptr
operator|+
name|first
operator|)
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|INT_XLATE
argument_list|(
operator|*
operator|(
name|__uint32_t
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
name|first
operator|)
argument_list|,
operator|*
operator|(
name|__uint32_t
operator|*
operator|)
operator|(
name|mem_ptr
operator|+
name|first
operator|)
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|INT_XLATE
argument_list|(
operator|*
operator|(
name|__uint64_t
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
name|first
operator|)
argument_list|,
operator|*
operator|(
name|__uint64_t
operator|*
operator|)
operator|(
name|mem_ptr
operator|+
name|first
operator|)
argument_list|,
name|dir
argument_list|,
name|arch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fields
operator|&=
operator|~
operator|(
literal|1LL
operator|<<
name|f
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * xfs_readsb  *  * Does the initial read of the superblock.  */
end_comment

begin_function
name|int
name|xfs_readsb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|unsigned
name|int
name|sector_size
decl_stmt|;
name|unsigned
name|int
name|extra_flags
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_sb_bp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_ddev_targp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a (locked) buffer to hold the superblock. 	 * This will be kept around at all times to optimize 	 * access to the superblock. 	 */
name|sector_size
operator|=
name|xfs_getsize_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|extra_flags
operator|=
name|XFS_BUF_LOCK
operator||
name|XFS_BUF_MANAGE
operator||
name|XFS_BUF_MAPPED
expr_stmt|;
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_SB_DADDR
argument_list|,
name|BTOBB
argument_list|(
name|sector_size
argument_list|)
argument_list|,
name|extra_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: SB read failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bp
condition|?
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the mount structure from the superblock. 	 * But first do some basic consistency checking. 	 */
name|sbp
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_xlatesb
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
argument_list|,
literal|1
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|XFS_SB_ALL_BITS
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_mount_validate_sb
argument_list|(
name|mp
argument_list|,
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: SB validate failed"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * We must be able to do sector-sized and sector-aligned IO. 	 */
if|if
condition|(
name|sector_size
operator|>
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: device supports only %u byte sectors (not %u)"
argument_list|,
name|sector_size
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * If device sector size is smaller than the superblock size, 	 * re-read the superblock so the buffer is correctly sized. 	 */
if|if
condition|(
name|sector_size
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
condition|)
block|{
name|XFS_BUF_UNMANAGE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sector_size
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
expr_stmt|;
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_SB_DADDR
argument_list|,
name|BTOBB
argument_list|(
name|sector_size
argument_list|)
argument_list|,
name|extra_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: SB re-read failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bp
condition|?
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_sb_bp
operator|=
name|bp
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|bp
condition|)
block|{
name|XFS_BUF_UNMANAGE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_mount_common  *  * Mount initialization code establishing various mount  * fields from the superblock associated with the given  * mount structure  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_mount_common
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_t
modifier|*
name|sbp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mp
operator|->
name|m_agfrotor
operator|=
name|mp
operator|->
name|m_agirotor
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_maxagi
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
expr_stmt|;
name|mp
operator|->
name|m_blkbit_log
operator|=
name|sbp
operator|->
name|sb_blocklog
operator|+
name|XFS_NBBYLOG
expr_stmt|;
name|mp
operator|->
name|m_blkbb_log
operator|=
name|sbp
operator|->
name|sb_blocklog
operator|-
name|BBSHIFT
expr_stmt|;
name|mp
operator|->
name|m_sectbb_log
operator|=
name|sbp
operator|->
name|sb_sectlog
operator|-
name|BBSHIFT
expr_stmt|;
name|mp
operator|->
name|m_agno_log
operator|=
name|xfs_highbit32
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|m_agino_log
operator|=
name|sbp
operator|->
name|sb_inopblog
operator|+
name|sbp
operator|->
name|sb_agblklog
expr_stmt|;
name|mp
operator|->
name|m_litino
operator|=
name|sbp
operator|->
name|sb_inodesize
operator|-
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|)
expr_stmt|;
name|mp
operator|->
name|m_blockmask
operator|=
name|sbp
operator|->
name|sb_blocksize
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|m_blockwsize
operator|=
name|sbp
operator|->
name|sb_blocksize
operator|>>
name|XFS_WORDLOG
expr_stmt|;
name|mp
operator|->
name|m_blockwmask
operator|=
name|mp
operator|->
name|m_blockwsize
operator|-
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|mp
operator|->
name|m_del_inodes
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for attributes, in case they get created. 	 * This value is for inodes getting attributes for the first time, 	 * the per-inode value is for old attribute values. 	 */
name|ASSERT
argument_list|(
name|sbp
operator|->
name|sb_inodesize
operator|>=
literal|256
operator|&&
name|sbp
operator|->
name|sb_inodesize
operator|<=
literal|2048
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sbp
operator|->
name|sb_inodesize
condition|)
block|{
case|case
literal|256
case|:
name|mp
operator|->
name|m_attroffset
operator|=
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
operator|-
name|XFS_BMDR_SPACE_CALC
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
case|case
literal|1024
case|:
case|case
literal|2048
case|:
name|mp
operator|->
name|m_attroffset
operator|=
name|XFS_BMDR_SPACE_CALC
argument_list|(
literal|12
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_attroffset
operator|<
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_alloc_mxr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_alloc
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_alloc_mnr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MINRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_alloc
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_bmap_dmxr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_bmap_dmnr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MINRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_inobt_mxr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_inobt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_inobt_mnr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MINRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_inobt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_bsize
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ialloc_inos
operator|=
operator|(
name|int
operator|)
name|MAX
argument_list|(
operator|(
name|__uint16_t
operator|)
name|XFS_INODES_PER_CHUNK
argument_list|,
name|sbp
operator|->
name|sb_inopblock
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ialloc_blks
operator|=
name|mp
operator|->
name|m_ialloc_inos
operator|>>
name|sbp
operator|->
name|sb_inopblog
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xfs_mountfs  *  * This function does the following on an initial mount of a file system:  *	- reads the superblock from disk and init the mount struct  *	- if we're a 32-bit kernel, do a size check on the superblock  *		so we don't mount terabyte filesystems  *	- init mount struct realtime fields  *	- allocate inode hash table for fs  *	- init directory manager  *	- perform recovery and init the log manager  */
end_comment

begin_function
name|int
name|xfs_mountfs
parameter_list|(
name|xfs_vfs_t
modifier|*
name|vfsp
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|mfsi_flags
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
init|=
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
decl_stmt|;
name|xfs_inode_t
modifier|*
name|rip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|rvp
init|=
literal|0
decl_stmt|;
name|int
name|readio_log
decl_stmt|,
name|writeio_log
decl_stmt|;
name|vmap_t
name|vmap
decl_stmt|;
name|xfs_daddr_t
name|d
decl_stmt|;
name|__uint64_t
name|ret64
decl_stmt|;
name|__int64_t
name|update_flags
decl_stmt|;
name|uint
name|quotamount
decl_stmt|,
name|quotaflags
decl_stmt|;
name|int
name|agno
decl_stmt|;
name|int
name|uuid_mounted
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_sb_bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_readsb
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|xfs_mount_common
argument_list|(
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
comment|/* 	 * Check if sb_agblocks is aligned at stripe boundary 	 * If sb_agblocks is NOT aligned turn off m_dalign since 	 * allocator alignment is within an ag, therefore ag has 	 * to be aligned at stripe boundary. 	 */
name|update_flags
operator|=
literal|0LL
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
operator|!
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_SECOND
operator|)
condition|)
block|{
comment|/* 		 * If stripe unit and stripe width are not multiples 		 * of the fs blocksize turn off alignment. 		 */
if|if
condition|(
operator|(
name|BBTOB
argument_list|(
name|mp
operator|->
name|m_dalign
argument_list|)
operator|&
name|mp
operator|->
name|m_blockmask
operator|)
operator|||
operator|(
name|BBTOB
argument_list|(
name|mp
operator|->
name|m_swidth
argument_list|)
operator|&
name|mp
operator|->
name|m_blockmask
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_RETERR
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: alignment check 1 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|mp
operator|->
name|m_dalign
operator|=
name|mp
operator|->
name|m_swidth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Convert the stripe unit and width to FSBs. 			 */
name|mp
operator|->
name|m_dalign
operator|=
name|XFS_BB_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_dalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
operator|(
name|sbp
operator|->
name|sb_agblocks
operator|%
name|mp
operator|->
name|m_dalign
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_RETERR
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|mp
operator|->
name|m_dalign
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_swidth
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_dalign
condition|)
block|{
name|mp
operator|->
name|m_swidth
operator|=
name|XFS_BB_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_swidth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_RETERR
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: alignment check 3 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|mp
operator|->
name|m_swidth
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Update superblock with new values 		 * and log changes 		 */
if|if
condition|(
name|XFS_SB_VERSION_HASDALIGN
argument_list|(
name|sbp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sbp
operator|->
name|sb_unit
operator|!=
name|mp
operator|->
name|m_dalign
condition|)
block|{
name|sbp
operator|->
name|sb_unit
operator|=
name|mp
operator|->
name|m_dalign
expr_stmt|;
name|update_flags
operator||=
name|XFS_SB_UNIT
expr_stmt|;
block|}
if|if
condition|(
name|sbp
operator|->
name|sb_width
operator|!=
name|mp
operator|->
name|m_swidth
condition|)
block|{
name|sbp
operator|->
name|sb_width
operator|=
name|mp
operator|->
name|m_swidth
expr_stmt|;
name|update_flags
operator||=
name|XFS_SB_WIDTH
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOALIGN
operator|)
operator|!=
name|XFS_MOUNT_NOALIGN
operator|&&
name|XFS_SB_VERSION_HASDALIGN
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|mp
operator|->
name|m_dalign
operator|=
name|sbp
operator|->
name|sb_unit
expr_stmt|;
name|mp
operator|->
name|m_swidth
operator|=
name|sbp
operator|->
name|sb_width
expr_stmt|;
block|}
name|xfs_alloc_compute_maxlevels
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_bmap_compute_maxlevels
argument_list|(
name|mp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_compute_maxlevels
argument_list|(
name|mp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|xfs_ialloc_compute_maxlevels
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_imax_pct
condition|)
block|{
name|__uint64_t
name|icount
decl_stmt|;
comment|/* Make sure the maximum inode count is a multiple of the 		 * units we allocate inodes in. 		 */
name|icount
operator|=
name|sbp
operator|->
name|sb_dblocks
operator|*
name|sbp
operator|->
name|sb_imax_pct
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
name|mp
operator|->
name|m_ialloc_blks
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_maxicount
operator|=
operator|(
name|icount
operator|*
name|mp
operator|->
name|m_ialloc_blks
operator|)
operator|<<
name|sbp
operator|->
name|sb_inopblog
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|m_maxicount
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_maxioffset
operator|=
name|xfs_max_file_offset
argument_list|(
name|sbp
operator|->
name|sb_blocklog
argument_list|)
expr_stmt|;
comment|/* 	 * XFS uses the uuid from the superblock as the unique 	 * identifier for fsid.  We can not use the uuid from the volume 	 * since a single partition filesystem is identical to a single 	 * partition volume/filesystem. 	 */
if|if
condition|(
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_SECOND
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOUUID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xfs_uuid_mount
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|uuid_mounted
operator|=
literal|1
expr_stmt|;
name|ret64
operator|=
name|uuid_hash64
argument_list|(
operator|&
name|sbp
operator|->
name|sb_uuid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|vfsp
operator|->
name|vfs_fsid
argument_list|,
operator|&
name|ret64
argument_list|,
sizeof|sizeof
argument_list|(
name|ret64
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the default minimum read and write sizes unless 	 * already specified in a mount option. 	 * We use smaller I/O sizes when the file system 	 * is being used for NFS service (wsync mount option). 	 */
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_DFLT_IOSIZE
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|readio_log
operator|=
name|XFS_WSYNC_READIO_LOG
expr_stmt|;
name|writeio_log
operator|=
name|XFS_WSYNC_WRITEIO_LOG
expr_stmt|;
block|}
else|else
block|{
name|readio_log
operator|=
name|XFS_READIO_LOG_LARGE
expr_stmt|;
name|writeio_log
operator|=
name|XFS_WRITEIO_LOG_LARGE
expr_stmt|;
block|}
block|}
else|else
block|{
name|readio_log
operator|=
name|mp
operator|->
name|m_readio_log
expr_stmt|;
name|writeio_log
operator|=
name|mp
operator|->
name|m_writeio_log
expr_stmt|;
block|}
comment|/* 	 * Set the number of readahead buffers to use based on 	 * physical memory size. 	 */
if|if
condition|(
name|xfs_physmem
operator|<=
literal|4096
condition|)
comment|/*<= 16MB */
name|mp
operator|->
name|m_nreadaheads
operator|=
name|XFS_RW_NREADAHEAD_16MB
expr_stmt|;
elseif|else
if|if
condition|(
name|xfs_physmem
operator|<=
literal|8192
condition|)
comment|/*<= 32MB */
name|mp
operator|->
name|m_nreadaheads
operator|=
name|XFS_RW_NREADAHEAD_32MB
expr_stmt|;
else|else
name|mp
operator|->
name|m_nreadaheads
operator|=
name|XFS_RW_NREADAHEAD_K32
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_blocklog
operator|>
name|readio_log
condition|)
block|{
name|mp
operator|->
name|m_readio_log
operator|=
name|sbp
operator|->
name|sb_blocklog
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_readio_log
operator|=
name|readio_log
expr_stmt|;
block|}
name|mp
operator|->
name|m_readio_blocks
operator|=
literal|1
operator|<<
operator|(
name|mp
operator|->
name|m_readio_log
operator|-
name|sbp
operator|->
name|sb_blocklog
operator|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_blocklog
operator|>
name|writeio_log
condition|)
block|{
name|mp
operator|->
name|m_writeio_log
operator|=
name|sbp
operator|->
name|sb_blocklog
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_writeio_log
operator|=
name|writeio_log
expr_stmt|;
block|}
name|mp
operator|->
name|m_writeio_blocks
operator|=
literal|1
operator|<<
operator|(
name|mp
operator|->
name|m_writeio_log
operator|-
name|sbp
operator|->
name|sb_blocklog
operator|)
expr_stmt|;
comment|/* 	 * Set the inode cluster size based on the physical memory 	 * size.  This may still be overridden by the file system 	 * block size if it is larger than the chosen cluster size. 	 */
if|if
condition|(
name|xfs_physmem
operator|<=
name|btoc
argument_list|(
literal|32
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
block|{
comment|/*<= 32 MB */
name|mp
operator|->
name|m_inode_cluster_size
operator|=
name|XFS_INODE_SMALL_CLUSTER_SIZE
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_inode_cluster_size
operator|=
name|XFS_INODE_BIG_CLUSTER_SIZE
expr_stmt|;
block|}
comment|/* 	 * Set whether we're using inode alignment. 	 */
if|if
condition|(
name|XFS_SB_VERSION_HASALIGN
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
name|mp
operator|->
name|m_sb
operator|.
name|sb_inoalignmt
operator|>=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_inode_cluster_size
argument_list|)
condition|)
name|mp
operator|->
name|m_inoalign_mask
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_inoalignmt
operator|-
literal|1
expr_stmt|;
else|else
name|mp
operator|->
name|m_inoalign_mask
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we are using stripe alignment, check whether 	 * the stripe unit is a multiple of the inode alignment 	 */
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
name|mp
operator|->
name|m_inoalign_mask
operator|&&
operator|!
operator|(
name|mp
operator|->
name|m_dalign
operator|&
name|mp
operator|->
name|m_inoalign_mask
operator|)
condition|)
name|mp
operator|->
name|m_sinoalign
operator|=
name|mp
operator|->
name|m_dalign
expr_stmt|;
else|else
name|mp
operator|->
name|m_sinoalign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check that the data (and log if separate) are an ok size. 	 */
name|d
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|d
argument_list|)
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 1 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
operator|-
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 2 failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error1
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_CLIENT
operator|)
operator|==
literal|0
operator|)
operator|&&
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
condition|)
block|{
name|d
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_logblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|d
argument_list|)
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_logblocks
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 3 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_logdev_targp
argument_list|,
name|d
operator|-
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 3 failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error1
goto|;
block|}
block|}
comment|/* 	 * Initialize realtime fields in the mount structure 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_rtmount_init
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: RT mount failed"
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* 	 * For client case we are done now 	 */
if|if
condition|(
name|mfsi_flags
operator|&
name|XFS_MFSI_CLIENT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 *  Copies the low order bits of the timestamp and the randomly 	 *  set "sequence" number out of a UUID. 	 */
name|uuid_getnodeuniq
argument_list|(
operator|&
name|sbp
operator|->
name|sb_uuid
argument_list|,
name|mp
operator|->
name|m_fixedfsid
argument_list|)
expr_stmt|;
comment|/* 	 *  The vfs structure needs to have a file system independent 	 *  way of checking for the invariant file system ID.  Since it 	 *  can't look at mount structures it has a pointer to the data 	 *  in the mount structure. 	 * 	 *  File systems that don't support user level file handles (i.e. 	 *  all of them except for XFS) will leave vfs_altfsid as NULL. 	 */
name|vfsp
operator|->
name|vfs_altfsid
operator|=
operator|(
name|xfs_fsid_t
operator|*
operator|)
name|mp
operator|->
name|m_fixedfsid
expr_stmt|;
name|mp
operator|->
name|m_dmevmask
operator|=
literal|0
expr_stmt|;
comment|/* not persistent; set after each mount */
comment|/* 	 * Select the right directory manager. 	 */
name|mp
operator|->
name|m_dirops
operator|=
name|XFS_SB_VERSION_HASDIRV2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|?
name|xfsv2_dirops
else|:
name|xfsv1_dirops
expr_stmt|;
comment|/* 	 * Initialize directory manager's entries. 	 */
name|XFS_DIR_MOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the attribute manager's entries. 	 */
name|mp
operator|->
name|m_attr_magicpct
operator|=
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|*
literal|37
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* 	 * Initialize the precomputed transaction reservations values. 	 */
name|xfs_trans_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the inode hash table for this 	 * file system. 	 */
name|xfs_ihash_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_chash_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the per-ag data. 	 */
name|init_rwsem
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_perag
operator|=
name|kmem_zalloc
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|*
sizeof|sizeof
argument_list|(
name|xfs_perag_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|xfs_initialize_perag
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_agcount
argument_list|)
expr_stmt|;
comment|/* 	 * log's mount-time initialization. Perform 1st part recovery if needed 	 */
if|if
condition|(
name|likely
argument_list|(
name|sbp
operator|->
name|sb_logblocks
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* check for volume case */
name|error
operator|=
name|xfs_log_mount
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_logdev_targp
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_logstart
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_logblocks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: log mount failed"
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
block|}
else|else
block|{
comment|/* No log has been defined */
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: no log defined"
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_mountfs_int(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
comment|/* 	 * Get and sanity-check the root inode. 	 * Save the pointer to it in the mount structure. 	 */
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|sbp
operator|->
name|sb_rootino
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|rip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: failed to read root inode"
argument_list|)
expr_stmt|;
goto|goto
name|error3
goto|;
block|}
name|ASSERT
argument_list|(
name|rip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rvp
operator|=
name|XFS_ITOV
argument_list|(
name|rip
argument_list|)
expr_stmt|;
name|VMAP
argument_list|(
name|rvp
argument_list|,
name|vmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: corrupted root inode"
argument_list|)
expr_stmt|;
name|prdev
argument_list|(
literal|"Root inode %llu is not a directory"
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|rip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_mountfs_int(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
name|mp
operator|->
name|m_rootip
operator|=
name|rip
expr_stmt|;
comment|/* save it */
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize realtime inode pointers in the mount structure 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_rtmount_inodes
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Free up the root inode. 		 */
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: failed to read RT inodes"
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
comment|/* 	 * If fs is not mounted readonly, then update the superblock 	 * unit and width changes. 	 */
if|if
condition|(
name|update_flags
operator|&&
operator|!
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
name|xfs_mount_log_sbunit
argument_list|(
name|mp
argument_list|,
name|update_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the XFS quota management subsystem for this mount 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_INIT
argument_list|(
name|mp
argument_list|,
operator|&
name|quotamount
argument_list|,
operator|&
name|quotaflags
argument_list|)
operator|)
condition|)
goto|goto
name|error4
goto|;
comment|/* 	 * Finish recovering the file system.  This part needed to be 	 * delayed until after the root and real-time bitmap inodes 	 * were consistently read in. 	 */
name|error
operator|=
name|xfs_log_mount_finish
argument_list|(
name|mp
argument_list|,
name|mfsi_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: log mount finish failed"
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
comment|/* 	 * Complete the quota initialisation, post-log-replay component. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_MOUNT
argument_list|(
name|mp
argument_list|,
name|quotamount
argument_list|,
name|quotaflags
argument_list|)
operator|)
condition|)
goto|goto
name|error4
goto|;
return|return
literal|0
return|;
name|error4
label|:
comment|/* 	 * Free up the root inode. 	 */
name|VN_RELE
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
name|vn_purge
argument_list|(
name|rvp
argument_list|,
operator|&
name|vmap
argument_list|)
expr_stmt|;
name|error3
label|:
name|xfs_log_unmount_dealloc
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error2
label|:
name|xfs_ihash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_chash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
name|agno
operator|=
literal|0
init|;
name|agno
operator|<
name|sbp
operator|->
name|sb_agcount
condition|;
name|agno
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_perag_busy_t
argument_list|)
operator|*
name|XFS_PAGB_NUM_SLOTS
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
argument_list|,
name|sbp
operator|->
name|sb_agcount
operator|*
sizeof|sizeof
argument_list|(
name|xfs_perag_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_perag
operator|=
name|NULL
expr_stmt|;
comment|/* FALLTHROUGH */
name|error1
label|:
if|if
condition|(
name|uuid_mounted
condition|)
name|xfs_uuid_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_freesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_unmountfs  *  * This flushes out the inodes,dquots and the superblock, unmounts the  * log and makes sure that incore structures are freed.  */
end_comment

begin_function
name|int
name|xfs_unmountfs
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|struct
name|cred
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|INDUCE_IO_ERROR
argument_list|)
name|int64_t
name|fsid
decl_stmt|;
endif|#
directive|endif
name|xfs_iflush_all
argument_list|(
name|mp
argument_list|,
name|XFS_FLUSH_ALL
argument_list|)
expr_stmt|;
name|XFS_QM_DQPURGEALL
argument_list|(
name|mp
argument_list|,
name|XFS_QMOPT_UQUOTA
operator||
name|XFS_QMOPT_GQUOTA
operator||
name|XFS_QMOPT_UMOUNTING
argument_list|)
expr_stmt|;
comment|/* 	 * Flush out the log synchronously so that we know for sure 	 * that nothing is pinned.  This is important because bflush() 	 * will skip pinned buffers. 	 */
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|)
expr_stmt|;
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
condition|)
block|{
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
block|}
name|xfs_unmountfs_writesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_log_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Done! No more fs ops. */
name|xfs_freesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * All inodes from this mount point should be freed. 	 */
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_inodes
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * We may have bufs that are in the process of getting written still. 	 * We must wait for the I/O completion of those. The sync flag here 	 * does a two pass iteration thru the bufcache. 	 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|xfs_incore_relse
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* synchronous */
block|}
name|xfs_unmountfs_close
argument_list|(
name|mp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOUUID
operator|)
operator|==
literal|0
condition|)
name|xfs_uuid_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|INDUCE_IO_ERROR
argument_list|)
comment|/* 	 * clear all error tags on this filesystem 	 */
name|memcpy
argument_list|(
operator|&
name|fsid
argument_list|,
operator|&
name|vfsp
operator|->
name|vfs_fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_errortag_clearall_umount
argument_list|(
name|fsid
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XFS_IODONE
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|xfs_mount_free
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xfs_unmountfs_close
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|struct
name|cred
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|have_logdev
init|=
operator|(
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
operator|)
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_ddev_targp
condition|)
block|{
name|xfs_blkdev_put
argument_list|(
name|mp
operator|->
name|m_ddev_targp
operator|->
name|specvp
argument_list|)
expr_stmt|;
comment|/* FreeBSD non-portable */
name|xfs_free_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ddev_targp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
condition|)
block|{
name|xfs_blkdev_put
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
operator|->
name|specvp
argument_list|)
expr_stmt|;
comment|/* FreeBSD non-portable */
name|xfs_free_buftarg
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_rtdev_targp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_logdev_targp
operator|&&
name|have_logdev
condition|)
block|{
name|xfs_blkdev_put
argument_list|(
name|mp
operator|->
name|m_logdev_targp
operator|->
name|specvp
argument_list|)
expr_stmt|;
comment|/* FreeBSD non-portable */
name|xfs_free_buftarg
argument_list|(
name|mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_logdev_targp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|xfs_unmountfs_writesb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|sbp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * skip superblock write if fs is read-only, or 	 * if we are doing a forced umount. 	 */
name|sbp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * mark shared-readonly if desired 		 */
name|sb
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_mk_sharedro
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|XFS_SBF_READONLY
operator|)
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|XFS_SBF_READONLY
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASSHARED
argument_list|(
name|sb
argument_list|)
condition|)
name|XFS_SB_VERSION_ADDSHARED
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
name|mp
argument_list|,
literal|"Unmounting, marking shared read-only"
argument_list|)
expr_stmt|;
block|}
comment|/* Not on FreeBSD XFS_BUF_UNDONE(sbp); */
name|XFS_BUF_UNREAD
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_WRITE
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNASYNC
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_TARGET
argument_list|(
name|sbp
argument_list|)
operator|==
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
comment|/* Nevermind errors we might get here. */
name|error
operator|=
name|xfs_iowait
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_unmountfs_writesb"
argument_list|,
name|mp
argument_list|,
name|sbp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|sbp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|mp
operator|->
name|m_mk_sharedro
condition|)
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"Superblock write error detected while unmounting.  Filesystem may not be marked shared readonly"
argument_list|)
expr_stmt|;
block|}
name|xfs_buf_relse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_mod_sb() can be used to copy arbitrary changes to the  * in-core superblock into the superblock buffer to be logged.  * It does not provide the higher level of locking that is  * needed to protect the in-core superblock from concurrent  * access.  */
end_comment

begin_function
name|void
name|xfs_mod_sb
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|__int64_t
name|fields
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|xfs_sb_field_t
name|f
decl_stmt|;
name|ASSERT
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
return|return;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|bp
operator|=
name|xfs_trans_getsb
argument_list|(
name|tp
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|first
operator|=
sizeof|sizeof
argument_list|(
name|xfs_sb_t
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
comment|/* translate/copy */
name|xfs_xlatesb
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|fields
argument_list|)
expr_stmt|;
comment|/* find modified range */
name|f
operator|=
operator|(
name|xfs_sb_field_t
operator|)
name|xfs_lowbit64
argument_list|(
operator|(
name|__uint64_t
operator|)
name|fields
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
literal|1LL
operator|<<
name|f
operator|)
operator|&
name|XFS_SB_MOD_BITS
argument_list|)
expr_stmt|;
name|first
operator|=
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|offset
expr_stmt|;
name|f
operator|=
operator|(
name|xfs_sb_field_t
operator|)
name|xfs_highbit64
argument_list|(
operator|(
name|__uint64_t
operator|)
name|fields
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
literal|1LL
operator|<<
name|f
operator|)
operator|&
name|XFS_SB_MOD_BITS
argument_list|)
expr_stmt|;
name|last
operator|=
name|xfs_sb_info
index|[
name|f
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xfs_mod_incore_sb_unlocked() is a utility routine common used to apply  * a delta to a specified field in the in-core superblock.  Simply  * switch on the field indicated and apply the delta to that field.  * Fields are not allowed to dip below zero, so if the delta would  * do this do not apply it and return EINVAL.  *  * The SB_LOCK must be held when this routine is called.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_mod_incore_sb_unlocked
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
name|int
name|scounter
decl_stmt|;
comment|/* short counter for 32 bit fields */
name|long
name|long
name|lcounter
decl_stmt|;
comment|/* long counter for 64 bit fields */
name|long
name|long
name|res_used
decl_stmt|,
name|rem
decl_stmt|;
comment|/* 	 * With the in-core superblock spin lock held, switch 	 * on the indicated field.  Apply the delta to the 	 * proper field.  If the fields value would dip below 	 * 0, then do not apply the delta and return EINVAL. 	 */
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_SBS_ICOUNT
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_IFREE
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_FDBLOCKS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
expr_stmt|;
name|res_used
operator|=
call|(
name|long
name|long
call|)
argument_list|(
name|mp
operator|->
name|m_resblks
operator|-
name|mp
operator|->
name|m_resblks_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|/* Putting blocks back */
if|if
condition|(
name|res_used
operator|>
name|delta
condition|)
block|{
name|mp
operator|->
name|m_resblks_avail
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|rem
operator|=
name|delta
operator|-
name|res_used
expr_stmt|;
name|mp
operator|->
name|m_resblks_avail
operator|=
name|mp
operator|->
name|m_resblks
expr_stmt|;
name|lcounter
operator|+=
name|rem
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Taking blocks away */
name|lcounter
operator|+=
name|delta
expr_stmt|;
comment|/* 		 * If were out of blocks, use any available reserved blocks if 		 * were allowed to. 		 */
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rsvd
condition|)
block|{
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_resblks_avail
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_resblks_avail
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* not reserved */
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
block|}
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_FREXTENTS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_frextents
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_frextents
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_DBLOCKS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_AGCOUNT
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|=
name|scounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_IMAX_PCT
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_imax_pct
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_imax_pct
operator|=
name|scounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_REXTSIZE
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|=
name|scounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_RBMBLOCKS
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
operator|=
name|scounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_RBLOCKS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_REXTENTS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|=
name|lcounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XFS_SBS_REXTSLOG
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextslog
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextslog
operator|=
name|scounter
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * xfs_mod_incore_sb() is used to change a field in the in-core  * superblock structure by the specified delta.  This modification  * is protected by the SB_LOCK.  Just use the xfs_mod_incore_sb_unlocked()  * routine to do the work.  */
end_comment

begin_function
name|int
name|xfs_mod_incore_sb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
name|int
name|status
decl_stmt|;
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|status
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_mod_incore_sb_batch() is used to change more than one field  * in the in-core superblock structure at a time.  This modification  * is protected by a lock internal to this module.  The fields and  * changes to those fields are specified in the array of xfs_mod_sb  * structures passed in.  *  * Either all of the specified deltas will be applied or none of  * them will.  If any modified field dips below 0, then all modifications  * will be backed out and EINVAL will be returned.  */
end_comment

begin_function
name|int
name|xfs_mod_incore_sb_batch
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_mod_sb_t
modifier|*
name|msb
parameter_list|,
name|uint
name|nmsb
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|xfs_mod_sb_t
modifier|*
name|msbp
decl_stmt|;
comment|/* 	 * Loop through the array of mod structures and apply each 	 * individually.  If any fail, then back out all those 	 * which have already been applied.  Do all of this within 	 * the scope of the SB_LOCK so that all of the changes will 	 * be atomic. 	 */
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|msbp
operator|=
operator|&
name|msb
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|msbp
operator|=
operator|&
name|msbp
index|[
literal|0
index|]
init|;
name|msbp
operator|<
operator|(
name|msb
operator|+
name|nmsb
operator|)
condition|;
name|msbp
operator|++
control|)
block|{
comment|/* 		 * Apply the delta at index n.  If it fails, break 		 * from the loop so we'll fall into the undo loop 		 * below. 		 */
name|status
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|msbp
operator|->
name|msb_field
argument_list|,
name|msbp
operator|->
name|msb_delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
comment|/* 	 * If we didn't complete the loop above, then back out 	 * any changes made to the superblock.  If you add code 	 * between the loop above and here, make sure that you 	 * preserve the value of status. Loop back until 	 * we step below the beginning of the array.  Make sure 	 * we don't touch anything back there. 	 */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|--
expr_stmt|;
while|while
condition|(
name|msbp
operator|>=
name|msb
condition|)
block|{
name|status
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|msbp
operator|->
name|msb_field
argument_list|,
operator|-
operator|(
name|msbp
operator|->
name|msb_delta
operator|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
name|msbp
operator|--
expr_stmt|;
block|}
block|}
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_getsb() is called to obtain the buffer for the superblock.  * The buffer is returned locked and read in from disk.  * The buffer should be released with a call to xfs_brelse().  *  * If the flags parameter is BUF_TRYLOCK, then we'll only return  * the superblock buffer if it can be locked without sleeping.  * If it can't then we'll return NULL.  */
end_comment

begin_function
name|xfs_buf_t
modifier|*
name|xfs_getsb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_sb_bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|mp
operator|->
name|m_sb_bp
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFS_BUF_TRYLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|XFS_BUF_CPSEMA
argument_list|(
name|bp
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|XFS_BUF_PSEMA
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
name|XFS_BUF_HOLD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISDONE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used to free the superblock along various error paths.  */
end_comment

begin_function
name|void
name|xfs_freesb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Use xfs_getsb() so that the buffer will be locked 	 * when we call xfs_buf_relse(). 	 */
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_UNMANAGE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_sb_bp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if the UUID is unique among mounted XFS filesystems.  * Mount fails if UUID is nil or a FS with the same UUID is already mounted.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_uuid_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|uuid_is_nil
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Filesystem %s has nil UUID - can't mount"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|uuid_table_insert
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Filesystem %s has duplicate UUID - can't mount"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Remove filesystem from the UUID table.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_uuid_unmount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|uuid_table_remove
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used to log changes to the superblock unit and width fields which could  * be altered by the mount options. Only the first superblock is updated.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_mount_log_sbunit
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|__int64_t
name|fields
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|ASSERT
argument_list|(
name|fields
operator|&
operator|(
name|XFS_SB_UNIT
operator||
name|XFS_SB_WIDTH
operator||
name|XFS_SB_UUID
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SB_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
operator|+
literal|128
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XFS_DEFAULT_LOG_COUNT
argument_list|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfs_mod_sb
argument_list|(
name|tp
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions to lock access out of the filesystem for forced  * shutdown or snapshot.  */
end_comment

begin_function
name|void
name|xfs_start_freeze
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|unsigned
name|long
name|s
init|=
name|mutex_spinlock
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|)
decl_stmt|;
name|mp
operator|->
name|m_frozen
operator|=
name|level
expr_stmt|;
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|XFS_FREEZE_TRANS
condition|)
block|{
while|while
condition|(
name|atomic_read
argument_list|(
operator|&
name|mp
operator|->
name|m_active_trans
argument_list|)
operator|>
literal|0
condition|)
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xfs_finish_freeze
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|unsigned
name|long
name|s
init|=
name|mutex_spinlock
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_frozen
condition|)
block|{
name|mp
operator|->
name|m_frozen
operator|=
literal|0
expr_stmt|;
name|sv_broadcast
argument_list|(
operator|&
name|mp
operator|->
name|m_wait_unfreeze
argument_list|)
expr_stmt|;
block|}
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xfs_check_frozen
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_frozen
condition|)
block|{
name|s
operator|=
name|mutex_spinlock
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_frozen
operator|<
name|level
condition|)
block|{
name|mutex_spinunlock
argument_list|(
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_wait
argument_list|(
operator|&
name|mp
operator|->
name|m_wait_unfreeze
argument_list|,
literal|0
argument_list|,
operator|&
name|mp
operator|->
name|m_freeze_lock
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|level
operator|==
name|XFS_FREEZE_TRANS
condition|)
name|atomic_inc
argument_list|(
operator|&
name|mp
operator|->
name|m_active_trans
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

