begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fsops.h"
end_include

begin_function_decl
name|STATIC
name|void
name|xfs_mount_log_sbunit
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|__int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_uuid_mount
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_uuid_unmount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_unmountfs_wait
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PERCPU_SB
end_ifdef

begin_function_decl
name|STATIC
name|void
name|xfs_icsb_destroy_counters
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_icsb_balance_counter
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_sb_field_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_icsb_sync_counters
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_icsb_modify_counters
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_sb_field_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_icsb_modify_counters_locked
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_sb_field_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_icsb_disable_counter
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_sb_field_t
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_icsb_destroy_counters
parameter_list|(
name|mp
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|xfs_icsb_balance_counter
parameter_list|(
name|mp
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|xfs_icsb_sync_counters
parameter_list|(
name|mp
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|xfs_icsb_modify_counters
parameter_list|(
name|mp
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|xfs_icsb_modify_counters_locked
parameter_list|(
name|mp
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|short
name|offset
decl_stmt|;
name|short
name|type
decl_stmt|;
comment|/* 0 = integer 			 * 1 = binary / string (no translation) 			 */
block|}
name|xfs_sb_info
index|[]
init|=
block|{
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_magicnum
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_blocksize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_dblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rextents
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_uuid
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logstart
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rootino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rbmino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rsumino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rextsize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_agblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_agcount
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rbmblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_versionnum
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_sectsize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inodesize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inopblock
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_fname
index|[
literal|0
index|]
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_blocklog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_sectlog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inodelog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inopblog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_agblklog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_rextslog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inprogress
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_imax_pct
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_icount
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_ifree
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_fdblocks
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_frextents
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_uquotino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_gquotino
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_qflags
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_flags
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_shared_vn
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_inoalignmt
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_unit
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_width
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_dirblklog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logsectlog
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logsectsize
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_logsunit
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_features2
argument_list|)
block|,
literal|0
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|xfs_sb_t
argument_list|)
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return a pointer to an initialized xfs_mount structure.  */
end_comment

begin_function
name|xfs_mount_t
modifier|*
name|xfs_mount_init
parameter_list|(
name|void
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_mount_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_icsb_init_counters
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_NO_PERCPU_SB
expr_stmt|;
block|}
name|AIL_LOCKINIT
argument_list|(
operator|&
name|mp
operator|->
name|m_ail_lock
argument_list|,
literal|"xfs_ail"
argument_list|)
expr_stmt|;
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_sb_lock
argument_list|,
literal|"xfs_sb"
argument_list|)
expr_stmt|;
comment|/* FreeBSD specfic */
name|sx_init
argument_list|(
operator|&
name|mp
operator|->
name|m_ilock
argument_list|,
literal|"xfs_mnt"
argument_list|)
expr_stmt|;
name|initnsema
argument_list|(
operator|&
name|mp
operator|->
name|m_growlock
argument_list|,
literal|1
argument_list|,
literal|"xfs_grow"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the AIL. 	 */
name|xfs_trans_ail_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|mp
operator|->
name|m_active_trans
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the resources associated with a mount structure.  Assume that  * the structure was initially zeroed, so we can tell which fields got  * initialized.  */
end_comment

begin_function
name|void
name|xfs_mount_free
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|remove_bhv
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_ihash
condition|)
name|xfs_ihash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_chash
condition|)
name|xfs_chash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_perag
condition|)
block|{
name|int
name|agno
decl_stmt|;
for|for
control|(
name|agno
operator|=
literal|0
init|;
name|agno
operator|<
name|mp
operator|->
name|m_maxagi
condition|;
name|agno
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_perag_busy_t
argument_list|)
operator|*
name|XFS_PAGB_NUM_SLOTS
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_perag_t
argument_list|)
operator|*
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
argument_list|)
expr_stmt|;
block|}
name|AIL_LOCK_DESTROY
argument_list|(
operator|&
name|mp
operator|->
name|m_ail_lock
argument_list|)
expr_stmt|;
name|spinlock_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_sb_lock
argument_list|)
expr_stmt|;
comment|/* FreeBSD specfic */
name|sx_destroy
argument_list|(
operator|&
name|mp
operator|->
name|m_ilock
argument_list|)
expr_stmt|;
name|freesema
argument_list|(
operator|&
name|mp
operator|->
name|m_growlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_quotainfo
condition|)
name|XFS_QM_DONE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_fsname
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_fsname
argument_list|,
name|mp
operator|->
name|m_fsname_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtname
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_rtname
argument_list|,
name|strlen
argument_list|(
name|mp
operator|->
name|m_rtname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_logname
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_logname
argument_list|,
name|strlen
argument_list|(
name|mp
operator|->
name|m_logname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_bhv
condition|)
block|{
name|xfs_vfs_t
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|bhv_remove_all_vfsops
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VFS_REMOVEBHV
argument_list|(
name|vfsp
argument_list|,
operator|&
name|mp
operator|->
name|m_bhv
argument_list|)
expr_stmt|;
block|}
name|xfs_icsb_destroy_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_mount_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the validity of the SB found.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_mount_validate_sb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_t
modifier|*
name|sbp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* 	 * If the log device and data device have the 	 * same device number, the log is internal. 	 * Consequently, the sb_logstart should be non-zero.  If 	 * we have a zero sb_logstart in this case, we may be trying to mount 	 * a volume filesystem in a non-volume manner. 	 */
if|if
condition|(
name|sbp
operator|->
name|sb_magicnum
operator|!=
name|XFS_SB_MAGIC
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"bad magic number"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EWRONGFS
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|XFS_SB_GOOD_VERSION
argument_list|(
name|sbp
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"bad version"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EWRONGFS
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_logstart
operator|==
literal|0
operator|&&
name|mp
operator|->
name|m_logdev_targp
operator|==
name|mp
operator|->
name|m_ddev_targp
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"filesystem is marked as having an external log; "
literal|"specify logdev on the\nmount command line."
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_logstart
operator|!=
literal|0
operator|&&
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"filesystem is marked as having an internal log; "
literal|"do not specify logdev on\nthe mount command line."
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * More sanity checking. These were stolen directly from 	 * xfs_repair. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|<=
literal|0
operator|||
name|sbp
operator|->
name|sb_sectsize
operator|<
name|XFS_MIN_SECTORSIZE
operator|||
name|sbp
operator|->
name|sb_sectsize
operator|>
name|XFS_MAX_SECTORSIZE
operator|||
name|sbp
operator|->
name|sb_sectlog
operator|<
name|XFS_MIN_SECTORSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_sectlog
operator|>
name|XFS_MAX_SECTORSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_blocksize
operator|<
name|XFS_MIN_BLOCKSIZE
operator|||
name|sbp
operator|->
name|sb_blocksize
operator|>
name|XFS_MAX_BLOCKSIZE
operator|||
name|sbp
operator|->
name|sb_blocklog
operator|<
name|XFS_MIN_BLOCKSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_blocklog
operator|>
name|XFS_MAX_BLOCKSIZE_LOG
operator|||
name|sbp
operator|->
name|sb_inodesize
operator|<
name|XFS_DINODE_MIN_SIZE
operator|||
name|sbp
operator|->
name|sb_inodesize
operator|>
name|XFS_DINODE_MAX_SIZE
operator|||
name|sbp
operator|->
name|sb_inodelog
operator|<
name|XFS_DINODE_MIN_LOG
operator|||
name|sbp
operator|->
name|sb_inodelog
operator|>
name|XFS_DINODE_MAX_LOG
operator|||
operator|(
name|sbp
operator|->
name|sb_blocklog
operator|-
name|sbp
operator|->
name|sb_inodelog
operator|!=
name|sbp
operator|->
name|sb_inopblog
operator|)
operator|||
operator|(
name|sbp
operator|->
name|sb_rextsize
operator|*
name|sbp
operator|->
name|sb_blocksize
operator|>
name|XFS_MAX_RTEXTSIZE
operator|)
operator|||
operator|(
name|sbp
operator|->
name|sb_rextsize
operator|*
name|sbp
operator|->
name|sb_blocksize
operator|<
name|XFS_MIN_RTEXTSIZE
operator|)
operator|||
operator|(
name|sbp
operator|->
name|sb_imax_pct
operator|>
literal|100
comment|/* zero sb_imax_pct is valid */
operator|)
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"SB sanity check 1 failed"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Sanity check AG count, size fields against data size field 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_dblocks
operator|==
literal|0
operator|||
name|sbp
operator|->
name|sb_dblocks
operator|>
operator|(
name|xfs_drfsbno_t
operator|)
name|sbp
operator|->
name|sb_agcount
operator|*
name|sbp
operator|->
name|sb_agblocks
operator|||
name|sbp
operator|->
name|sb_dblocks
operator|<
call|(
name|xfs_drfsbno_t
call|)
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|-
literal|1
argument_list|)
operator|*
name|sbp
operator|->
name|sb_agblocks
operator|+
name|XFS_MIN_AG_BLOCKS
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"SB sanity check 2 failed"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|ASSERT
argument_list|(
name|PAGE_SHIFT
operator|>=
name|sbp
operator|->
name|sb_blocklog
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sbp
operator|->
name|sb_blocklog
operator|>=
name|BBSHIFT
argument_list|)
expr_stmt|;
if|#
directive|if
name|XFS_BIG_BLKNOS
comment|/* Limited by ULONG_MAX of page cache index */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|sbp
operator|->
name|sb_dblocks
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|sbp
operator|->
name|sb_blocklog
operator|)
operator|)
operator|>
name|ULONG_MAX
operator|||
operator|(
name|sbp
operator|->
name|sb_rblocks
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|sbp
operator|->
name|sb_blocklog
operator|)
operator|)
operator|>
name|ULONG_MAX
argument_list|)
condition|)
block|{
else|#
directive|else
comment|/* Limited by UINT_MAX of sectors */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|sbp
operator|->
name|sb_dblocks
operator|<<
operator|(
name|sbp
operator|->
name|sb_blocklog
operator|-
name|BBSHIFT
operator|)
operator|)
operator|>
name|UINT_MAX
operator|||
operator|(
name|sbp
operator|->
name|sb_rblocks
operator|<<
operator|(
name|sbp
operator|->
name|sb_blocklog
operator|-
name|BBSHIFT
operator|)
operator|)
operator|>
name|UINT_MAX
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"file system too large to be mounted on this system."
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_inprogress
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"file system busy"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/* 	 * Version 1 directory format has never worked on Linux. 	 */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|XFS_SB_VERSION_HASDIRV2
argument_list|(
name|sbp
argument_list|)
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"file system using version 1 directory format"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSYS
argument_list|)
return|;
block|}
comment|/* 	 * Until this is fixed only page-sized or smaller data blocks work. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|sbp
operator|->
name|sb_blocksize
operator|>
name|PAGE_SIZE
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"file system with blocksize %d bytes"
argument_list|,
name|sbp
operator|->
name|sb_blocksize
argument_list|)
expr_stmt|;
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"only pagesize (%ld) or less will currently work."
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSYS
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
name|xfs_agnumber_t
name|xfs_initialize_perag
parameter_list|(
name|struct
name|xfs_vfs
modifier|*
name|vfs
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_agnumber_t
name|agcount
parameter_list|)
block|{
name|xfs_agnumber_t
name|index
decl_stmt|,
name|max_metadata
decl_stmt|;
name|xfs_perag_t
modifier|*
name|pag
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
init|=
operator|&
name|mp
operator|->
name|m_sb
decl_stmt|;
name|xfs_ino_t
name|max_inum
init|=
name|XFS_MAXINUMBER_32
decl_stmt|;
comment|/* Check to see if the filesystem can overflow 32 bit inodes */
name|agino
operator|=
name|XFS_OFFBNO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_agblocks
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agcount
operator|-
literal|1
argument_list|,
name|agino
argument_list|)
expr_stmt|;
comment|/* Clear the mount flag if no inode can overflow 32 bits 	 * on this filesystem, or if specifically requested.. 	 */
if|if
condition|(
operator|(
name|vfs
operator|->
name|vfs_flag
operator|&
name|VFS_32BITINODES
operator|)
operator|&&
name|ino
operator|>
name|max_inum
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_32BITINODES
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|XFS_MOUNT_32BITINODES
expr_stmt|;
block|}
comment|/* If we can overflow then setup the ag headers accordingly */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_32BITINODES
condition|)
block|{
comment|/* Calculate how much should be reserved for inodes to 		 * meet the max inode percentage. 		 */
if|if
condition|(
name|mp
operator|->
name|m_maxicount
condition|)
block|{
name|__uint64_t
name|icount
decl_stmt|;
name|icount
operator|=
name|sbp
operator|->
name|sb_dblocks
operator|*
name|sbp
operator|->
name|sb_imax_pct
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|icount
operator|+=
name|sbp
operator|->
name|sb_agblocks
operator|-
literal|1
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
name|sbp
operator|->
name|sb_agblocks
argument_list|)
expr_stmt|;
name|max_metadata
operator|=
name|icount
expr_stmt|;
block|}
else|else
block|{
name|max_metadata
operator|=
name|agcount
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|agcount
condition|;
name|index
operator|++
control|)
block|{
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|index
argument_list|,
name|agino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|>
name|max_inum
condition|)
block|{
name|index
operator|++
expr_stmt|;
break|break;
block|}
comment|/* This ag is preferred for inodes */
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|index
index|]
expr_stmt|;
name|pag
operator|->
name|pagi_inodeok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|max_metadata
condition|)
name|pag
operator|->
name|pagf_metadata
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Setup default behavior for smaller filesystems */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|agcount
condition|;
name|index
operator|++
control|)
block|{
name|pag
operator|=
operator|&
name|mp
operator|->
name|m_perag
index|[
name|index
index|]
expr_stmt|;
name|pag
operator|->
name|pagi_inodeok
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|index
return|;
block|}
comment|/*  * xfs_xlatesb  *  *     data       - on disk version of sb  *     sb         - a superblock  *     dir        - conversion direction:<0 - convert sb to buf  *>0 - convert buf to sb  *     fields     - which fields to copy (bitmask)  */
name|void
name|xfs_xlatesb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|xfs_sb_t
modifier|*
name|sb
parameter_list|,
name|int
name|dir
parameter_list|,
name|__int64_t
name|fields
parameter_list|)
block|{
name|xfs_caddr_t
name|buf_ptr
decl_stmt|;
name|xfs_caddr_t
name|mem_ptr
decl_stmt|;
name|xfs_sb_field_t
name|f
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
return|return;
name|buf_ptr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|data
expr_stmt|;
name|mem_ptr
operator|=
operator|(
name|xfs_caddr_t
operator|)
name|sb
expr_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
name|f
operator|=
operator|(
name|xfs_sb_field_t
operator|)
name|xfs_lowbit64
argument_list|(
operator|(
name|__uint64_t
operator|)
name|fields
argument_list|)
expr_stmt|;
name|first
operator|=
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|offset
expr_stmt|;
name|size
operator|=
name|xfs_sb_info
index|[
name|f
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
name|first
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|type
operator|==
literal|0
operator|||
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|type
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|||
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|type
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|mem_ptr
operator|+
name|first
argument_list|,
name|buf_ptr
operator|+
name|first
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|buf_ptr
operator|+
name|first
argument_list|,
name|mem_ptr
operator|+
name|first
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|2
case|:
name|INT_XLATE
argument_list|(
operator|*
operator|(
name|__uint16_t
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
name|first
operator|)
argument_list|,
operator|*
operator|(
name|__uint16_t
operator|*
operator|)
operator|(
name|mem_ptr
operator|+
name|first
operator|)
argument_list|,
name|dir
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|INT_XLATE
argument_list|(
operator|*
operator|(
name|__uint32_t
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
name|first
operator|)
argument_list|,
operator|*
operator|(
name|__uint32_t
operator|*
operator|)
operator|(
name|mem_ptr
operator|+
name|first
operator|)
argument_list|,
name|dir
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|INT_XLATE
argument_list|(
operator|*
operator|(
name|__uint64_t
operator|*
operator|)
operator|(
name|buf_ptr
operator|+
name|first
operator|)
argument_list|,
operator|*
operator|(
name|__uint64_t
operator|*
operator|)
operator|(
name|mem_ptr
operator|+
name|first
operator|)
argument_list|,
name|dir
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fields
operator|&=
operator|~
operator|(
literal|1LL
operator|<<
name|f
operator|)
expr_stmt|;
block|}
block|}
comment|/*  * xfs_readsb  *  * Does the initial read of the superblock.  */
name|int
name|xfs_readsb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|sector_size
decl_stmt|;
name|unsigned
name|int
name|extra_flags
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_sb_bp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_ddev_targp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a (locked) buffer to hold the superblock. 	 * This will be kept around at all times to optimize 	 * access to the superblock. 	 */
name|sector_size
operator|=
name|xfs_getsize_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|extra_flags
operator|=
name|XFS_BUF_LOCK
operator||
name|XFS_BUF_MANAGE
operator||
name|XFS_BUF_MAPPED
expr_stmt|;
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"SB read failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bp
condition|?
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the mount structure from the superblock. 	 * But first do some basic consistency checking. 	 */
name|sbp
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_xlatesb
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
argument_list|,
literal|1
argument_list|,
name|XFS_SB_ALL_BITS
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_mount_validate_sb
argument_list|(
name|mp
argument_list|,
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"SB validate failed"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * We must be able to do sector-sized and sector-aligned IO. 	 */
if|if
condition|(
name|sector_size
operator|>
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"device supports only %u byte sectors (not %u)"
argument_list|,
name|sector_size
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * If device sector size is smaller than the superblock size, 	 * re-read the superblock so the buffer is correctly sized. 	 */
if|if
condition|(
name|sector_size
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
condition|)
block|{
name|XFS_BUF_UNMANAGE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sector_size
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
expr_stmt|;
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_SB_DADDR
argument_list|,
name|BTOBB
argument_list|(
name|sector_size
argument_list|)
argument_list|,
name|extra_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
name|XFS_BUF_ISERROR
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|xfs_fs_mount_cmn_err
argument_list|(
name|flags
argument_list|,
literal|"SB re-read failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bp
condition|?
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ASSERT
argument_list|(
name|XFS_BUF_ISBUSY
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_ICOUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_IFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_sb_bp
operator|=
name|bp
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_VALUSEMA
argument_list|(
name|bp
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|bp
condition|)
block|{
name|XFS_BUF_UNMANAGE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
comment|/*  * xfs_mount_common  *  * Mount initialization code establishing various mount  * fields from the superblock associated with the given  * mount structure  */
name|STATIC
name|void
name|xfs_mount_common
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_t
modifier|*
name|sbp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mp
operator|->
name|m_agfrotor
operator|=
name|mp
operator|->
name|m_agirotor
operator|=
literal|0
expr_stmt|;
name|spinlock_init
argument_list|(
operator|&
name|mp
operator|->
name|m_agirotor_lock
argument_list|,
literal|"m_agirotor_lock"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_maxagi
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
expr_stmt|;
name|mp
operator|->
name|m_blkbit_log
operator|=
name|sbp
operator|->
name|sb_blocklog
operator|+
name|XFS_NBBYLOG
expr_stmt|;
name|mp
operator|->
name|m_blkbb_log
operator|=
name|sbp
operator|->
name|sb_blocklog
operator|-
name|BBSHIFT
expr_stmt|;
name|mp
operator|->
name|m_sectbb_log
operator|=
name|sbp
operator|->
name|sb_sectlog
operator|-
name|BBSHIFT
expr_stmt|;
name|mp
operator|->
name|m_agno_log
operator|=
name|xfs_highbit32
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|m_agino_log
operator|=
name|sbp
operator|->
name|sb_inopblog
operator|+
name|sbp
operator|->
name|sb_agblklog
expr_stmt|;
name|mp
operator|->
name|m_litino
operator|=
name|sbp
operator|->
name|sb_inodesize
operator|-
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dinode_core_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_agino_t
argument_list|)
operator|)
expr_stmt|;
name|mp
operator|->
name|m_blockmask
operator|=
name|sbp
operator|->
name|sb_blocksize
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|m_blockwsize
operator|=
name|sbp
operator|->
name|sb_blocksize
operator|>>
name|XFS_WORDLOG
expr_stmt|;
name|mp
operator|->
name|m_blockwmask
operator|=
name|mp
operator|->
name|m_blockwsize
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RMC
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mp
operator|->
name|m_del_inodes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INIT
argument_list|(
operator|&
name|mp
operator|->
name|m_del_inodes
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for attributes, in case they get created. 	 * This value is for inodes getting attributes for the first time, 	 * the per-inode value is for old attribute values. 	 */
name|ASSERT
argument_list|(
name|sbp
operator|->
name|sb_inodesize
operator|>=
literal|256
operator|&&
name|sbp
operator|->
name|sb_inodesize
operator|<=
literal|2048
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sbp
operator|->
name|sb_inodesize
condition|)
block|{
case|case
literal|256
case|:
name|mp
operator|->
name|m_attroffset
operator|=
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
operator|-
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|MINABTPTRS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
case|case
literal|1024
case|:
case|case
literal|2048
case|:
name|mp
operator|->
name|m_attroffset
operator|=
name|XFS_BMDR_SPACE_CALC
argument_list|(
literal|6
operator|*
name|MINABTPTRS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_attroffset
operator|<
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_alloc_mxr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_alloc
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_alloc_mnr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MINRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_alloc
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_bmap_dmxr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_bmap_dmnr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MINRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_bmbt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_inobt_mxr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MAXRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_inobt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_inobt_mnr
index|[
name|i
index|]
operator|=
name|XFS_BTREE_BLOCK_MINRECS
argument_list|(
name|sbp
operator|->
name|sb_blocksize
argument_list|,
name|xfs_inobt
argument_list|,
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_bsize
operator|=
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ialloc_inos
operator|=
operator|(
name|int
operator|)
name|MAX
argument_list|(
operator|(
name|__uint16_t
operator|)
name|XFS_INODES_PER_CHUNK
argument_list|,
name|sbp
operator|->
name|sb_inopblock
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ialloc_blks
operator|=
name|mp
operator|->
name|m_ialloc_inos
operator|>>
name|sbp
operator|->
name|sb_inopblog
expr_stmt|;
block|}
comment|/*  * xfs_mountfs  *  * This function does the following on an initial mount of a file system:  *	- reads the superblock from disk and init the mount struct  *	- if we're a 32-bit kernel, do a size check on the superblock  *		so we don't mount terabyte filesystems  *	- init mount struct realtime fields  *	- allocate inode hash table for fs  *	- init directory manager  *	- perform recovery and init the log manager  */
name|int
name|xfs_mountfs
parameter_list|(
name|xfs_vfs_t
modifier|*
name|vfsp
parameter_list|,
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|mfsi_flags
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
init|=
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
decl_stmt|;
name|xfs_inode_t
modifier|*
name|rip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|rvp
init|=
name|NULL
decl_stmt|;
name|int
name|readio_log
decl_stmt|,
name|writeio_log
decl_stmt|;
name|xfs_daddr_t
name|d
decl_stmt|;
name|__uint64_t
name|ret64
decl_stmt|;
name|__int64_t
name|update_flags
decl_stmt|;
name|uint
name|quotamount
decl_stmt|,
name|quotaflags
decl_stmt|;
name|int
name|agno
decl_stmt|;
name|int
name|uuid_mounted
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_sb_bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_readsb
argument_list|(
name|mp
argument_list|,
name|mfsi_flags
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
name|xfs_mount_common
argument_list|(
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
comment|/* 	 * Check if sb_agblocks is aligned at stripe boundary 	 * If sb_agblocks is NOT aligned turn off m_dalign since 	 * allocator alignment is within an ag, therefore ag has 	 * to be aligned at stripe boundary. 	 */
name|update_flags
operator|=
literal|0LL
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
operator|!
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_SECOND
operator|)
condition|)
block|{
comment|/* 		 * If stripe unit and stripe width are not multiples 		 * of the fs blocksize turn off alignment. 		 */
if|if
condition|(
operator|(
name|BBTOB
argument_list|(
name|mp
operator|->
name|m_dalign
argument_list|)
operator|&
name|mp
operator|->
name|m_blockmask
operator|)
operator|||
operator|(
name|BBTOB
argument_list|(
name|mp
operator|->
name|m_swidth
argument_list|)
operator|&
name|mp
operator|->
name|m_blockmask
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_RETERR
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: alignment check 1 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|mp
operator|->
name|m_dalign
operator|=
name|mp
operator|->
name|m_swidth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Convert the stripe unit and width to FSBs. 			 */
name|mp
operator|->
name|m_dalign
operator|=
name|XFS_BB_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_dalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
operator|(
name|sbp
operator|->
name|sb_agblocks
operator|%
name|mp
operator|->
name|m_dalign
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_RETERR
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"stripe alignment turned off: sunit(%d)/swidth(%d) incompatible with agsize(%d)"
argument_list|,
name|mp
operator|->
name|m_dalign
argument_list|,
name|mp
operator|->
name|m_swidth
argument_list|,
name|sbp
operator|->
name|sb_agblocks
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dalign
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_swidth
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_dalign
condition|)
block|{
name|mp
operator|->
name|m_swidth
operator|=
name|XFS_BB_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_swidth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_RETERR
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"stripe alignment turned off: sunit(%d) less than bsize(%d)"
argument_list|,
name|mp
operator|->
name|m_dalign
argument_list|,
name|mp
operator|->
name|m_blockmask
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|mp
operator|->
name|m_swidth
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Update superblock with new values 		 * and log changes 		 */
if|if
condition|(
name|XFS_SB_VERSION_HASDALIGN
argument_list|(
name|sbp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sbp
operator|->
name|sb_unit
operator|!=
name|mp
operator|->
name|m_dalign
condition|)
block|{
name|sbp
operator|->
name|sb_unit
operator|=
name|mp
operator|->
name|m_dalign
expr_stmt|;
name|update_flags
operator||=
name|XFS_SB_UNIT
expr_stmt|;
block|}
if|if
condition|(
name|sbp
operator|->
name|sb_width
operator|!=
name|mp
operator|->
name|m_swidth
condition|)
block|{
name|sbp
operator|->
name|sb_width
operator|=
name|mp
operator|->
name|m_swidth
expr_stmt|;
name|update_flags
operator||=
name|XFS_SB_WIDTH
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOALIGN
operator|)
operator|!=
name|XFS_MOUNT_NOALIGN
operator|&&
name|XFS_SB_VERSION_HASDALIGN
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|mp
operator|->
name|m_dalign
operator|=
name|sbp
operator|->
name|sb_unit
expr_stmt|;
name|mp
operator|->
name|m_swidth
operator|=
name|sbp
operator|->
name|sb_width
expr_stmt|;
block|}
name|xfs_alloc_compute_maxlevels
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_bmap_compute_maxlevels
argument_list|(
name|mp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|xfs_bmap_compute_maxlevels
argument_list|(
name|mp
argument_list|,
name|XFS_ATTR_FORK
argument_list|)
expr_stmt|;
name|xfs_ialloc_compute_maxlevels
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_imax_pct
condition|)
block|{
name|__uint64_t
name|icount
decl_stmt|;
comment|/* Make sure the maximum inode count is a multiple of the 		 * units we allocate inodes in. 		 */
name|icount
operator|=
name|sbp
operator|->
name|sb_dblocks
operator|*
name|sbp
operator|->
name|sb_imax_pct
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|do_div
argument_list|(
name|icount
argument_list|,
name|mp
operator|->
name|m_ialloc_blks
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_maxicount
operator|=
operator|(
name|icount
operator|*
name|mp
operator|->
name|m_ialloc_blks
operator|)
operator|<<
name|sbp
operator|->
name|sb_inopblog
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|m_maxicount
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_maxioffset
operator|=
name|xfs_max_file_offset
argument_list|(
name|sbp
operator|->
name|sb_blocklog
argument_list|)
expr_stmt|;
comment|/* 	 * XFS uses the uuid from the superblock as the unique 	 * identifier for fsid.  We can not use the uuid from the volume 	 * since a single partition filesystem is identical to a single 	 * partition volume/filesystem. 	 */
if|if
condition|(
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_SECOND
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOUUID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xfs_uuid_mount
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|uuid_mounted
operator|=
literal|1
expr_stmt|;
name|ret64
operator|=
name|uuid_hash64
argument_list|(
operator|&
name|sbp
operator|->
name|sb_uuid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|vfsp
operator|->
name|vfs_fsid
argument_list|,
operator|&
name|ret64
argument_list|,
sizeof|sizeof
argument_list|(
name|ret64
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the default minimum read and write sizes unless 	 * already specified in a mount option. 	 * We use smaller I/O sizes when the file system 	 * is being used for NFS service (wsync mount option). 	 */
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_DFLT_IOSIZE
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|readio_log
operator|=
name|XFS_WSYNC_READIO_LOG
expr_stmt|;
name|writeio_log
operator|=
name|XFS_WSYNC_WRITEIO_LOG
expr_stmt|;
block|}
else|else
block|{
name|readio_log
operator|=
name|XFS_READIO_LOG_LARGE
expr_stmt|;
name|writeio_log
operator|=
name|XFS_WRITEIO_LOG_LARGE
expr_stmt|;
block|}
block|}
else|else
block|{
name|readio_log
operator|=
name|mp
operator|->
name|m_readio_log
expr_stmt|;
name|writeio_log
operator|=
name|mp
operator|->
name|m_writeio_log
expr_stmt|;
block|}
comment|/* 	 * Set the number of readahead buffers to use based on 	 * physical memory size. 	 */
if|if
condition|(
name|xfs_physmem
operator|<=
literal|4096
condition|)
comment|/*<= 16MB */
name|mp
operator|->
name|m_nreadaheads
operator|=
name|XFS_RW_NREADAHEAD_16MB
expr_stmt|;
elseif|else
if|if
condition|(
name|xfs_physmem
operator|<=
literal|8192
condition|)
comment|/*<= 32MB */
name|mp
operator|->
name|m_nreadaheads
operator|=
name|XFS_RW_NREADAHEAD_32MB
expr_stmt|;
else|else
name|mp
operator|->
name|m_nreadaheads
operator|=
name|XFS_RW_NREADAHEAD_K32
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_blocklog
operator|>
name|readio_log
condition|)
block|{
name|mp
operator|->
name|m_readio_log
operator|=
name|sbp
operator|->
name|sb_blocklog
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_readio_log
operator|=
name|readio_log
expr_stmt|;
block|}
name|mp
operator|->
name|m_readio_blocks
operator|=
literal|1
operator|<<
operator|(
name|mp
operator|->
name|m_readio_log
operator|-
name|sbp
operator|->
name|sb_blocklog
operator|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_blocklog
operator|>
name|writeio_log
condition|)
block|{
name|mp
operator|->
name|m_writeio_log
operator|=
name|sbp
operator|->
name|sb_blocklog
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_writeio_log
operator|=
name|writeio_log
expr_stmt|;
block|}
name|mp
operator|->
name|m_writeio_blocks
operator|=
literal|1
operator|<<
operator|(
name|mp
operator|->
name|m_writeio_log
operator|-
name|sbp
operator|->
name|sb_blocklog
operator|)
expr_stmt|;
comment|/* 	 * Set the inode cluster size based on the physical memory 	 * size.  This may still be overridden by the file system 	 * block size if it is larger than the chosen cluster size. 	 */
if|if
condition|(
name|xfs_physmem
operator|<=
name|btoc
argument_list|(
literal|32
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
condition|)
block|{
comment|/*<= 32 MB */
name|mp
operator|->
name|m_inode_cluster_size
operator|=
name|XFS_INODE_SMALL_CLUSTER_SIZE
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_inode_cluster_size
operator|=
name|XFS_INODE_BIG_CLUSTER_SIZE
expr_stmt|;
block|}
comment|/* 	 * Set whether we're using inode alignment. 	 */
if|if
condition|(
name|XFS_SB_VERSION_HASALIGN
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
name|mp
operator|->
name|m_sb
operator|.
name|sb_inoalignmt
operator|>=
name|XFS_B_TO_FSBT
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_inode_cluster_size
argument_list|)
condition|)
name|mp
operator|->
name|m_inoalign_mask
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_inoalignmt
operator|-
literal|1
expr_stmt|;
else|else
name|mp
operator|->
name|m_inoalign_mask
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we are using stripe alignment, check whether 	 * the stripe unit is a multiple of the inode alignment 	 */
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|&&
name|mp
operator|->
name|m_inoalign_mask
operator|&&
operator|!
operator|(
name|mp
operator|->
name|m_dalign
operator|&
name|mp
operator|->
name|m_inoalign_mask
operator|)
condition|)
name|mp
operator|->
name|m_sinoalign
operator|=
name|mp
operator|->
name|m_dalign
expr_stmt|;
else|else
name|mp
operator|->
name|m_sinoalign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check that the data (and log if separate) are an ok size. 	 */
name|d
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|d
argument_list|)
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 1 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
operator|-
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XFS_FSS_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 2 failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error1
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|mfsi_flags
operator|&
name|XFS_MFSI_CLIENT
operator|)
operator|==
literal|0
operator|)
operator|&&
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
condition|)
block|{
name|d
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_logblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|d
argument_list|)
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_logblocks
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 3 failed"
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_logdev_targp
argument_list|,
name|d
operator|-
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: size check 3 failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error1
goto|;
block|}
block|}
comment|/* 	 * Initialize realtime fields in the mount structure 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_rtmount_init
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: RT mount failed"
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* 	 * For client case we are done now 	 */
if|if
condition|(
name|mfsi_flags
operator|&
name|XFS_MFSI_CLIENT
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* 	 *  Copies the low order bits of the timestamp and the randomly 	 *  set "sequence" number out of a UUID. 	 */
name|uuid_getnodeuniq
argument_list|(
operator|&
name|sbp
operator|->
name|sb_uuid
argument_list|,
name|mp
operator|->
name|m_fixedfsid
argument_list|)
expr_stmt|;
comment|/* 	 *  The vfs structure needs to have a file system independent 	 *  way of checking for the invariant file system ID.  Since it 	 *  can't look at mount structures it has a pointer to the data 	 *  in the mount structure. 	 * 	 *  File systems that don't support user level file handles (i.e. 	 *  all of them except for XFS) will leave vfs_altfsid as NULL. 	 */
name|vfsp
operator|->
name|vfs_altfsid
operator|=
operator|(
name|xfs_fsid_t
operator|*
operator|)
name|mp
operator|->
name|m_fixedfsid
expr_stmt|;
name|mp
operator|->
name|m_dmevmask
operator|=
literal|0
expr_stmt|;
comment|/* not persistent; set after each mount */
comment|/* 	 * Select the right directory manager. 	 */
name|mp
operator|->
name|m_dirops
operator|=
name|XFS_SB_VERSION_HASDIRV2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|?
name|xfsv2_dirops
else|:
name|xfsv1_dirops
expr_stmt|;
comment|/* 	 * Initialize directory manager's entries. 	 */
name|XFS_DIR_MOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the attribute manager's entries. 	 */
name|mp
operator|->
name|m_attr_magicpct
operator|=
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|*
literal|37
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* 	 * Initialize the precomputed transaction reservations values. 	 */
name|xfs_trans_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the inode hash table for this 	 * file system. 	 */
name|xfs_ihash_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_chash_init
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and initialize the per-ag data. 	 */
name|init_rwsem
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_perag
operator|=
name|kmem_zalloc
argument_list|(
name|sbp
operator|->
name|sb_agcount
operator|*
sizeof|sizeof
argument_list|(
name|xfs_perag_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_maxagi
operator|=
name|xfs_initialize_perag
argument_list|(
name|vfsp
argument_list|,
name|mp
argument_list|,
name|sbp
operator|->
name|sb_agcount
argument_list|)
expr_stmt|;
comment|/* 	 * log's mount-time initialization. Perform 1st part recovery if needed 	 */
if|if
condition|(
name|likely
argument_list|(
name|sbp
operator|->
name|sb_logblocks
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* check for volume case */
name|error
operator|=
name|xfs_log_mount
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_logdev_targp
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_logstart
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|sbp
operator|->
name|sb_logblocks
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: log mount failed"
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
block|}
else|else
block|{
comment|/* No log has been defined */
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: no log defined"
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_mountfs_int(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
comment|/* 	 * Get and sanity-check the root inode. 	 * Save the pointer to it in the mount structure. 	 */
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|sbp
operator|->
name|sb_rootino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|rip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: failed to read root inode"
argument_list|)
expr_stmt|;
goto|goto
name|error3
goto|;
block|}
name|ASSERT
argument_list|(
name|rip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rvp
operator|=
name|XFS_ITOV
argument_list|(
name|rip
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|rip
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: corrupted root inode"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Root inode %p is not a directory: %llu"
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|rip
operator|->
name|i_ino
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_mountfs_int(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
name|mp
operator|->
name|m_rootip
operator|=
name|rip
expr_stmt|;
comment|/* save it */
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize realtime inode pointers in the mount structure 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_rtmount_inodes
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Free up the root inode. 		 */
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: failed to read RT inodes"
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
comment|/* 	 * If fs is not mounted readonly, then update the superblock 	 * unit and width changes. 	 */
if|if
condition|(
name|update_flags
operator|&&
operator|!
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
name|xfs_mount_log_sbunit
argument_list|(
name|mp
argument_list|,
name|update_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the XFS quota management subsystem for this mount 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_INIT
argument_list|(
name|mp
argument_list|,
operator|&
name|quotamount
argument_list|,
operator|&
name|quotaflags
argument_list|)
operator|)
condition|)
goto|goto
name|error4
goto|;
comment|/* 	 * Finish recovering the file system.  This part needed to be 	 * delayed until after the root and real-time bitmap inodes 	 * were consistently read in. 	 */
name|error
operator|=
name|xfs_log_mount_finish
argument_list|(
name|mp
argument_list|,
name|mfsi_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: log mount finish failed"
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
comment|/* 	 * Complete the quota initialisation, post-log-replay component. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|XFS_QM_MOUNT
argument_list|(
name|mp
argument_list|,
name|quotamount
argument_list|,
name|quotaflags
argument_list|,
name|mfsi_flags
argument_list|)
operator|)
condition|)
goto|goto
name|error4
goto|;
return|return
literal|0
return|;
name|error4
label|:
comment|/* 	 * Free up the root inode. 	 */
name|VN_RELE
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
name|error3
label|:
name|xfs_log_unmount_dealloc
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error2
label|:
name|xfs_ihash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_chash_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
name|agno
operator|=
literal|0
init|;
name|agno
operator|<
name|sbp
operator|->
name|sb_agcount
condition|;
name|agno
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
condition|)
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
index|[
name|agno
index|]
operator|.
name|pagb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_perag_busy_t
argument_list|)
operator|*
name|XFS_PAGB_NUM_SLOTS
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mp
operator|->
name|m_perag
argument_list|,
name|sbp
operator|->
name|sb_agcount
operator|*
sizeof|sizeof
argument_list|(
name|xfs_perag_t
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_perag
operator|=
name|NULL
expr_stmt|;
comment|/* FALLTHROUGH */
name|error1
label|:
if|if
condition|(
name|uuid_mounted
condition|)
name|xfs_uuid_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_freesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/*  * xfs_unmountfs  *  * This flushes out the inodes,dquots and the superblock, unmounts the  * log and makes sure that incore structures are freed.  */
name|int
name|xfs_unmountfs
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|struct
name|cred
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|INDUCE_IO_ERROR
argument_list|)
name|int64_t
name|fsid
decl_stmt|;
endif|#
directive|endif
name|xfs_iflush_all
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|XFS_QM_DQPURGEALL
argument_list|(
name|mp
argument_list|,
name|XFS_QMOPT_QUOTALL
operator||
name|XFS_QMOPT_UMOUNTING
argument_list|)
expr_stmt|;
comment|/* 	 * Flush out the log synchronously so that we know for sure 	 * that nothing is pinned.  This is important because bflush() 	 * will skip pinned buffers. 	 */
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|)
expr_stmt|;
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
condition|)
block|{
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
block|}
name|xfs_unmountfs_writesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_unmountfs_wait
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* wait for async bufs */
name|xfs_log_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Done! No more fs ops. */
name|xfs_freesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * All inodes from this mount point should be freed. 	 */
comment|//ASSERT(mp->m_inodes == NULL);
if|if
condition|(
name|mp
operator|->
name|m_inodes
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"WRONG: mp->m_ireclaims: %d\n"
argument_list|,
name|mp
operator|->
name|m_ireclaims
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WRONG: mp->m_inodes: %p\n"
argument_list|,
name|mp
operator|->
name|m_inodes
argument_list|)
expr_stmt|;
block|}
name|xfs_unmountfs_close
argument_list|(
name|mp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NOUUID
operator|)
operator|==
literal|0
condition|)
name|xfs_uuid_unmount
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|INDUCE_IO_ERROR
argument_list|)
comment|/* 	 * clear all error tags on this filesystem 	 */
name|memcpy
argument_list|(
operator|&
name|fsid
argument_list|,
operator|&
name|vfsp
operator|->
name|vfs_fsid
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_errortag_clearall_umount
argument_list|(
name|fsid
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XFS_IODONE
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|xfs_mount_free
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|void
name|xfs_unmountfs_close
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|struct
name|cred
modifier|*
name|cr
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
condition|)
name|xfs_free_buftarg
argument_list|(
name|mp
operator|->
name|m_logdev_targp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
condition|)
name|xfs_free_buftarg
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_free_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|STATIC
name|void
name|xfs_unmountfs_wait
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_logdev_targp
operator|!=
name|mp
operator|->
name|m_ddev_targp
condition|)
name|xfs_wait_buftarg
argument_list|(
name|mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
condition|)
name|xfs_wait_buftarg
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
name|xfs_wait_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
block|}
name|int
name|xfs_unmountfs_writesb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|sbp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * skip superblock write if fs is read-only, or 	 * if we are doing a forced umount. 	 */
name|sbp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|||
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
name|xfs_icsb_sync_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 		 * mark shared-readonly if desired 		 */
name|sb
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_mk_sharedro
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|XFS_SBF_READONLY
operator|)
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|XFS_SBF_READONLY
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASSHARED
argument_list|(
name|sb
argument_list|)
condition|)
name|XFS_SB_VERSION_ADDSHARED
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|xfs_fs_cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
name|mp
argument_list|,
literal|"Unmounting, marking shared read-only"
argument_list|)
expr_stmt|;
block|}
name|XFS_BUF_UNDONE
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNREAD
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNDELAYWRITE
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_WRITE
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|XFS_BUF_UNASYNC
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_TARGET
argument_list|(
name|sbp
argument_list|)
operator|==
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|xfsbdstrat
argument_list|(
name|mp
argument_list|,
name|sbp
argument_list|)
expr_stmt|;
comment|/* Nevermind errors we might get here. */
name|error
operator|=
name|xfs_iowait
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|xfs_ioerror_alert
argument_list|(
literal|"xfs_unmountfs_writesb"
argument_list|,
name|mp
argument_list|,
name|sbp
argument_list|,
name|XFS_BUF_ADDR
argument_list|(
name|sbp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|mp
operator|->
name|m_mk_sharedro
condition|)
name|xfs_fs_cmn_err
argument_list|(
name|CE_ALERT
argument_list|,
name|mp
argument_list|,
literal|"Superblock write error detected while unmounting.  Filesystem may not be marked shared readonly"
argument_list|)
expr_stmt|;
block|}
name|xfs_buf_relse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/*  * xfs_mod_sb() can be used to copy arbitrary changes to the  * in-core superblock into the superblock buffer to be logged.  * It does not provide the higher level of locking that is  * needed to protect the in-core superblock from concurrent  * access.  */
name|void
name|xfs_mod_sb
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|__int64_t
name|fields
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|xfs_sb_field_t
name|f
decl_stmt|;
name|ASSERT
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
return|return;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|bp
operator|=
name|xfs_trans_getsb
argument_list|(
name|tp
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|first
operator|=
sizeof|sizeof
argument_list|(
name|xfs_sb_t
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
comment|/* translate/copy */
name|xfs_xlatesb
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
name|fields
argument_list|)
expr_stmt|;
comment|/* find modified range */
name|f
operator|=
operator|(
name|xfs_sb_field_t
operator|)
name|xfs_lowbit64
argument_list|(
operator|(
name|__uint64_t
operator|)
name|fields
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
literal|1LL
operator|<<
name|f
operator|)
operator|&
name|XFS_SB_MOD_BITS
argument_list|)
expr_stmt|;
name|first
operator|=
name|xfs_sb_info
index|[
name|f
index|]
operator|.
name|offset
expr_stmt|;
name|f
operator|=
operator|(
name|xfs_sb_field_t
operator|)
name|xfs_highbit64
argument_list|(
operator|(
name|__uint64_t
operator|)
name|fields
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
literal|1LL
operator|<<
name|f
operator|)
operator|&
name|XFS_SB_MOD_BITS
argument_list|)
expr_stmt|;
name|last
operator|=
name|xfs_sb_info
index|[
name|f
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
literal|1
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
comment|/*  * xfs_mod_incore_sb_unlocked() is a utility routine common used to apply  * a delta to a specified field in the in-core superblock.  Simply  * switch on the field indicated and apply the delta to that field.  * Fields are not allowed to dip below zero, so if the delta would  * do this do not apply it and return EINVAL.  *  * The SB_LOCK must be held when this routine is called.  */
name|int
name|xfs_mod_incore_sb_unlocked
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
name|int
name|scounter
decl_stmt|;
comment|/* short counter for 32 bit fields */
name|long
name|long
name|lcounter
decl_stmt|;
comment|/* long counter for 64 bit fields */
name|long
name|long
name|res_used
decl_stmt|,
name|rem
decl_stmt|;
comment|/* 	 * With the in-core superblock spin lock held, switch 	 * on the indicated field.  Apply the delta to the 	 * proper field.  If the fields value would dip below 	 * 0, then do not apply the delta and return EINVAL. 	 */
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_SBS_ICOUNT
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_IFREE
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_FDBLOCKS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
expr_stmt|;
name|res_used
operator|=
call|(
name|long
name|long
call|)
argument_list|(
name|mp
operator|->
name|m_resblks
operator|-
name|mp
operator|->
name|m_resblks_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|/* Putting blocks back */
if|if
condition|(
name|res_used
operator|>
name|delta
condition|)
block|{
name|mp
operator|->
name|m_resblks_avail
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|rem
operator|=
name|delta
operator|-
name|res_used
expr_stmt|;
name|mp
operator|->
name|m_resblks_avail
operator|=
name|mp
operator|->
name|m_resblks
expr_stmt|;
name|lcounter
operator|+=
name|rem
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Taking blocks away */
name|lcounter
operator|+=
name|delta
expr_stmt|;
comment|/* 		 * If were out of blocks, use any available reserved blocks if 		 * were allowed to. 		 */
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rsvd
condition|)
block|{
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_resblks_avail
operator|+
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_resblks_avail
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* not reserved */
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
block|}
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_FREXTENTS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_frextents
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_frextents
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_DBLOCKS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_dblocks
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_AGCOUNT
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|=
name|scounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_IMAX_PCT
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_imax_pct
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_imax_pct
operator|=
name|scounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_REXTSIZE
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextsize
operator|=
name|scounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_RBMBLOCKS
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
operator|=
name|scounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_RBLOCKS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_REXTENTS
case|:
name|lcounter
operator|=
operator|(
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|lcounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|=
name|lcounter
expr_stmt|;
return|return
literal|0
return|;
case|case
name|XFS_SBS_REXTSLOG
case|:
name|scounter
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextslog
expr_stmt|;
name|scounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|scounter
operator|<
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextslog
operator|=
name|scounter
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
comment|/*  * xfs_mod_incore_sb() is used to change a field in the in-core  * superblock structure by the specified delta.  This modification  * is protected by the SB_LOCK.  Just use the xfs_mod_incore_sb_unlocked()  * routine to do the work.  */
name|int
name|xfs_mod_incore_sb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* check for per-cpu counters */
switch|switch
condition|(
name|field
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PERCPU_SB
case|case
name|XFS_SBS_ICOUNT
case|:
case|case
name|XFS_SBS_IFREE
case|:
case|case
name|XFS_SBS_FDBLOCKS
case|:
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NO_PERCPU_SB
operator|)
condition|)
block|{
name|status
operator|=
name|xfs_icsb_modify_counters
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default:
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|status
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
comment|/*  * xfs_mod_incore_sb_batch() is used to change more than one field  * in the in-core superblock structure at a time.  This modification  * is protected by a lock internal to this module.  The fields and  * changes to those fields are specified in the array of xfs_mod_sb  * structures passed in.  *  * Either all of the specified deltas will be applied or none of  * them will.  If any modified field dips below 0, then all modifications  * will be backed out and EINVAL will be returned.  */
name|int
name|xfs_mod_incore_sb_batch
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_mod_sb_t
modifier|*
name|msb
parameter_list|,
name|uint
name|nmsb
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
name|unsigned
name|long
name|s
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|xfs_mod_sb_t
modifier|*
name|msbp
decl_stmt|;
comment|/* 	 * Loop through the array of mod structures and apply each 	 * individually.  If any fail, then back out all those 	 * which have already been applied.  Do all of this within 	 * the scope of the SB_LOCK so that all of the changes will 	 * be atomic. 	 */
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|msbp
operator|=
operator|&
name|msb
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|msbp
operator|=
operator|&
name|msbp
index|[
literal|0
index|]
init|;
name|msbp
operator|<
operator|(
name|msb
operator|+
name|nmsb
operator|)
condition|;
name|msbp
operator|++
control|)
block|{
comment|/* 		 * Apply the delta at index n.  If it fails, break 		 * from the loop so we'll fall into the undo loop 		 * below. 		 */
switch|switch
condition|(
name|msbp
operator|->
name|msb_field
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PERCPU_SB
case|case
name|XFS_SBS_ICOUNT
case|:
case|case
name|XFS_SBS_IFREE
case|:
case|case
name|XFS_SBS_FDBLOCKS
case|:
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NO_PERCPU_SB
operator|)
condition|)
block|{
name|status
operator|=
name|xfs_icsb_modify_counters_locked
argument_list|(
name|mp
argument_list|,
name|msbp
operator|->
name|msb_field
argument_list|,
name|msbp
operator|->
name|msb_delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default:
name|status
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|msbp
operator|->
name|msb_field
argument_list|,
name|msbp
operator|->
name|msb_delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
comment|/* 	 * If we didn't complete the loop above, then back out 	 * any changes made to the superblock.  If you add code 	 * between the loop above and here, make sure that you 	 * preserve the value of status. Loop back until 	 * we step below the beginning of the array.  Make sure 	 * we don't touch anything back there. 	 */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|--
expr_stmt|;
while|while
condition|(
name|msbp
operator|>=
name|msb
condition|)
block|{
switch|switch
condition|(
name|msbp
operator|->
name|msb_field
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_PERCPU_SB
case|case
name|XFS_SBS_ICOUNT
case|:
case|case
name|XFS_SBS_IFREE
case|:
case|case
name|XFS_SBS_FDBLOCKS
case|:
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_NO_PERCPU_SB
operator|)
condition|)
block|{
name|status
operator|=
name|xfs_icsb_modify_counters_locked
argument_list|(
name|mp
argument_list|,
name|msbp
operator|->
name|msb_field
argument_list|,
operator|-
operator|(
name|msbp
operator|->
name|msb_delta
operator|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default:
name|status
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|msbp
operator|->
name|msb_field
argument_list|,
operator|-
operator|(
name|msbp
operator|->
name|msb_delta
operator|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
name|msbp
operator|--
expr_stmt|;
block|}
block|}
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/*  * xfs_getsb() is called to obtain the buffer for the superblock.  * The buffer is returned locked and read in from disk.  * The buffer should be released with a call to xfs_brelse().  *  * If the flags parameter is BUF_TRYLOCK, then we'll only return  * the superblock buffer if it can be locked without sleeping.  * If it can't then we'll return NULL.  */
name|xfs_buf_t
modifier|*
name|xfs_getsb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|extra_flags
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|sector_size
decl_stmt|;
name|bp
operator|=
name|mp
operator|->
name|m_sb_bp
expr_stmt|;
name|sector_size
operator|=
name|xfs_getsize_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT
comment|/* MANAGED buf's appear broken in FreeBSD 	 * but it's unclear if we need a persistant superblock? 	 * since we now translate the ondisk superblock to 	 * a separate translated structure and then translate that 	 * structure back when we want to write the superblock 	 */
name|extra_flags
operator|=
name|XFS_BUF_LOCK
operator||
name|XFS_BUF_MANAGE
operator||
name|XFS_BUF_MAPPED
expr_stmt|;
name|extra_flags
operator|=
name|XFS_BUF_MANAGE
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|m_sb_bp
operator|=
name|bp
operator|=
name|xfs_buf_read_flags
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_SB_DADDR
argument_list|,
name|BTOBB
argument_list|(
name|sector_size
argument_list|)
argument_list|,
name|extra_flags
argument_list|)
expr_stmt|;
name|XFS_BUF_HOLD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|XFS_BUF_ISDONE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_BUF_ISDONE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"xfs_getsb: %p bp flags 0x%x\n"
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
comment|/*  * Used to free the superblock along various error paths.  */
name|void
name|xfs_freesb
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Use xfs_getsb() so that the buffer will be locked 	 * when we call xfs_buf_relse(). 	 */
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFS_BUF_UNMANAGE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_sb_bp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  * See if the UUID is unique among mounted XFS filesystems.  * Mount fails if UUID is nil or a FS with the same UUID is already mounted.  */
name|STATIC
name|int
name|xfs_uuid_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|uuid_is_nil
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Filesystem %s has nil UUID - can't mount"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|uuid_table_insert
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Filesystem %s has duplicate UUID - can't mount"
argument_list|,
name|mp
operator|->
name|m_fsname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * Remove filesystem from the UUID table.  */
name|STATIC
name|void
name|xfs_uuid_unmount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|uuid_table_remove
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
operator|.
name|sb_uuid
argument_list|)
expr_stmt|;
block|}
comment|/*  * Used to log changes to the superblock unit and width fields which could  * be altered by the mount options. Only the first superblock is updated.  */
name|STATIC
name|void
name|xfs_mount_log_sbunit
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|__int64_t
name|fields
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|ASSERT
argument_list|(
name|fields
operator|&
operator|(
name|XFS_SB_UNIT
operator||
name|XFS_SB_WIDTH
operator||
name|XFS_SB_UUID
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SB_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
operator|+
literal|128
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XFS_DEFAULT_LOG_COUNT
argument_list|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfs_mod_sb
argument_list|(
name|tp
argument_list|,
name|fields
argument_list|)
expr_stmt|;
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PERCPU_SB
comment|/*  * Per-cpu incore superblock counters  *  * Simple concept, difficult implementation  *  * Basically, replace the incore superblock counters with a distributed per cpu  * counter for contended fields (e.g.  free block count).  *  * Difficulties arise in that the incore sb is used for ENOSPC checking, and  * hence needs to be accurately read when we are running low on space. Hence  * there is a method to enable and disable the per-cpu counters based on how  * much "stuff" is available in them.  *  * Basically, a counter is enabled if there is enough free resource to justify  * running a per-cpu fast-path. If the per-cpu counter runs out (i.e. a local  * ENOSPC), then we disable the counters to synchronise all callers and  * re-distribute the available resources.  *  * If, once we redistributed the available resources, we still get a failure,  * we disable the per-cpu counter and go through the slow path.  *  * The slow path is the current xfs_mod_incore_sb() function.  This means that  * when we disable a per-cpu counter, we need to drain it's resources back to  * the global superblock. We do this after disabling the counter to prevent  * more threads from queueing up on the counter.  *  * Essentially, this means that we still need a lock in the fast path to enable  * synchronisation between the global counters and the per-cpu counters. This  * is not a problem because the lock will be local to a CPU almost all the time  * and have little contention except when we get to ENOSPC conditions.  *  * Basically, this lock becomes a barrier that enables us to lock out the fast  * path while we do things like enabling and disabling counters and  * synchronising the counters.  *  * Locking rules:  *  * 	1. XFS_SB_LOCK() before picking up per-cpu locks  * 	2. per-cpu locks always picked up via for_each_online_cpu() order  * 	3. accurate counter sync requires XFS_SB_LOCK + per cpu locks  * 	4. modifying per-cpu counters requires holding per-cpu lock  * 	5. modifying global counters requires holding XFS_SB_LOCK  *	6. enabling or disabling a counter requires holding the XFS_SB_LOCK  *	   and _none_ of the per-cpu locks.  *  * Disabled counters are only ever re-enabled by a balance operation  * that results in more free resources per CPU than a given threshold.  * To ensure counters don't remain disabled, they are rebalanced when  * the global resource goes above a higher threshold (i.e. some hysteresis  * is present to prevent thrashing).  */
comment|/*  * hot-plug CPU notifier support.  *  * We cannot use the hotcpu_register() function because it does  * not allow notifier instances. We need a notifier per filesystem  * as we need to be able to identify the filesystem to balance  * the counters out. This is achieved by having a notifier block  * embedded in the xfs_mount_t and doing pointer magic to get the  * mount pointer from the notifier block address.  */
name|STATIC
name|int
name|xfs_icsb_cpu_notify
parameter_list|(
name|struct
name|notifier_block
modifier|*
name|nfb
parameter_list|,
name|unsigned
name|long
name|action
parameter_list|,
name|void
modifier|*
name|hcpu
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|cntp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|mp
operator|=
operator|(
name|xfs_mount_t
operator|*
operator|)
name|container_of
argument_list|(
name|nfb
argument_list|,
name|xfs_mount_t
argument_list|,
name|m_icsb_notifier
argument_list|)
expr_stmt|;
name|cntp
operator|=
operator|(
name|xfs_icsb_cnts_t
operator|*
operator|)
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hcpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CPU_UP_PREPARE
case|:
comment|/* Easy Case - initialize the area and locks, and 		 * then rebalance when online does everything else for us. */
name|memset
argument_list|(
name|cntp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_icsb_cnts_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_ONLINE
case|:
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_ICOUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_IFREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_DEAD
case|:
comment|/* Disable all the counters, then fold the dead cpu's 		 * count into the total on the global superblock and 		 * re-enable the counters. */
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_icsb_disable_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_ICOUNT
argument_list|)
expr_stmt|;
name|xfs_icsb_disable_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_IFREE
argument_list|)
expr_stmt|;
name|xfs_icsb_disable_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
operator|+=
name|cntp
operator|->
name|icsb_icount
expr_stmt|;
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
operator|+=
name|cntp
operator|->
name|icsb_ifree
expr_stmt|;
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
operator|+=
name|cntp
operator|->
name|icsb_fdblocks
expr_stmt|;
name|memset
argument_list|(
name|cntp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_icsb_cnts_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_ICOUNT
argument_list|,
name|XFS_ICSB_SB_LOCKED
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_IFREE
argument_list|,
name|XFS_ICSB_SB_LOCKED
argument_list|)
expr_stmt|;
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
name|XFS_ICSB_SB_LOCKED
argument_list|)
expr_stmt|;
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NOTIFY_OK
return|;
block|}
name|int
name|xfs_icsb_init_counters
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|cntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mp
operator|->
name|m_sb_cnts
operator|=
name|alloc_percpu
argument_list|(
name|xfs_icsb_cnts_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_sb_cnts
operator|==
name|NULL
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mp
operator|->
name|m_icsb_notifier
operator|.
name|notifier_call
operator|=
name|xfs_icsb_cpu_notify
expr_stmt|;
name|mp
operator|->
name|m_icsb_notifier
operator|.
name|priority
operator|=
literal|0
expr_stmt|;
name|register_cpu_notifier
argument_list|(
operator|&
name|mp
operator|->
name|m_icsb_notifier
argument_list|)
expr_stmt|;
name|for_each_online_cpu
argument_list|(
argument|i
argument_list|)
block|{
name|cntp
operator|=
operator|(
name|xfs_icsb_cnts_t
operator|*
operator|)
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cntp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_icsb_cnts_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * start with all counters disabled so that the 	 * initial balance kicks us off correctly 	 */
name|mp
operator|->
name|m_icsb_counters
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|STATIC
name|void
name|xfs_icsb_destroy_counters
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_sb_cnts
condition|)
block|{
name|unregister_cpu_notifier
argument_list|(
operator|&
name|mp
operator|->
name|m_icsb_notifier
argument_list|)
expr_stmt|;
name|free_percpu
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|)
expr_stmt|;
block|}
block|}
name|STATIC
specifier|inline
name|void
name|xfs_icsb_lock_cntr
parameter_list|(
name|xfs_icsb_cnts_t
modifier|*
name|icsbp
parameter_list|)
block|{
while|while
condition|(
name|test_and_set_bit
argument_list|(
name|XFS_ICSB_FLAG_LOCK
argument_list|,
operator|&
name|icsbp
operator|->
name|icsb_flags
argument_list|)
condition|)
block|{
name|ndelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
name|STATIC
specifier|inline
name|void
name|xfs_icsb_unlock_cntr
parameter_list|(
name|xfs_icsb_cnts_t
modifier|*
name|icsbp
parameter_list|)
block|{
name|clear_bit
argument_list|(
name|XFS_ICSB_FLAG_LOCK
argument_list|,
operator|&
name|icsbp
operator|->
name|icsb_flags
argument_list|)
expr_stmt|;
block|}
name|STATIC
specifier|inline
name|void
name|xfs_icsb_lock_all_counters
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|cntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_online_cpu
argument_list|(
argument|i
argument_list|)
block|{
name|cntp
operator|=
operator|(
name|xfs_icsb_cnts_t
operator|*
operator|)
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xfs_icsb_lock_cntr
argument_list|(
name|cntp
argument_list|)
expr_stmt|;
block|}
block|}
name|STATIC
specifier|inline
name|void
name|xfs_icsb_unlock_all_counters
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|cntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|for_each_online_cpu
argument_list|(
argument|i
argument_list|)
block|{
name|cntp
operator|=
operator|(
name|xfs_icsb_cnts_t
operator|*
operator|)
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xfs_icsb_unlock_cntr
argument_list|(
name|cntp
argument_list|)
expr_stmt|;
block|}
block|}
name|STATIC
name|void
name|xfs_icsb_count
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_icsb_cnts_t
modifier|*
name|cnt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|cntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|cnt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_icsb_cnts_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_ICSB_LAZY_COUNT
operator|)
condition|)
name|xfs_icsb_lock_all_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|for_each_online_cpu
argument_list|(
argument|i
argument_list|)
block|{
name|cntp
operator|=
operator|(
name|xfs_icsb_cnts_t
operator|*
operator|)
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cnt
operator|->
name|icsb_icount
operator|+=
name|cntp
operator|->
name|icsb_icount
expr_stmt|;
name|cnt
operator|->
name|icsb_ifree
operator|+=
name|cntp
operator|->
name|icsb_ifree
expr_stmt|;
name|cnt
operator|->
name|icsb_fdblocks
operator|+=
name|cntp
operator|->
name|icsb_fdblocks
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_ICSB_LAZY_COUNT
operator|)
condition|)
name|xfs_icsb_unlock_all_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|STATIC
name|int
name|xfs_icsb_counter_disabled
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
name|field
operator|>=
name|XFS_SBS_ICOUNT
operator|)
operator|&&
operator|(
name|field
operator|<=
name|XFS_SBS_FDBLOCKS
operator|)
argument_list|)
expr_stmt|;
return|return
name|test_bit
argument_list|(
name|field
argument_list|,
operator|&
name|mp
operator|->
name|m_icsb_counters
argument_list|)
return|;
block|}
name|STATIC
name|int
name|xfs_icsb_disable_counter
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|)
block|{
name|xfs_icsb_cnts_t
name|cnt
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|field
operator|>=
name|XFS_SBS_ICOUNT
operator|)
operator|&&
operator|(
name|field
operator|<=
name|XFS_SBS_FDBLOCKS
operator|)
argument_list|)
expr_stmt|;
name|xfs_icsb_lock_all_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test_and_set_bit
argument_list|(
name|field
argument_list|,
operator|&
name|mp
operator|->
name|m_icsb_counters
argument_list|)
condition|)
block|{
comment|/* drain back to superblock */
name|xfs_icsb_count
argument_list|(
name|mp
argument_list|,
operator|&
name|cnt
argument_list|,
name|XFS_ICSB_SB_LOCKED
operator||
name|XFS_ICSB_LAZY_COUNT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_SBS_ICOUNT
case|:
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
operator|=
name|cnt
operator|.
name|icsb_icount
expr_stmt|;
break|break;
case|case
name|XFS_SBS_IFREE
case|:
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
operator|=
name|cnt
operator|.
name|icsb_ifree
expr_stmt|;
break|break;
case|case
name|XFS_SBS_FDBLOCKS
case|:
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
operator|=
name|cnt
operator|.
name|icsb_fdblocks
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
block|}
name|xfs_icsb_unlock_all_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|STATIC
name|void
name|xfs_icsb_enable_counter
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|uint64_t
name|count
parameter_list|,
name|uint64_t
name|resid
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|cntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|field
operator|>=
name|XFS_SBS_ICOUNT
operator|)
operator|&&
operator|(
name|field
operator|<=
name|XFS_SBS_FDBLOCKS
operator|)
argument_list|)
expr_stmt|;
name|xfs_icsb_lock_all_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|for_each_online_cpu
argument_list|(
argument|i
argument_list|)
block|{
name|cntp
operator|=
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_SBS_ICOUNT
case|:
name|cntp
operator|->
name|icsb_icount
operator|=
name|count
operator|+
name|resid
expr_stmt|;
break|break;
case|case
name|XFS_SBS_IFREE
case|:
name|cntp
operator|->
name|icsb_ifree
operator|=
name|count
operator|+
name|resid
expr_stmt|;
break|break;
case|case
name|XFS_SBS_FDBLOCKS
case|:
name|cntp
operator|->
name|icsb_fdblocks
operator|=
name|count
operator|+
name|resid
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
name|resid
operator|=
literal|0
expr_stmt|;
block|}
name|clear_bit
argument_list|(
name|field
argument_list|,
operator|&
name|mp
operator|->
name|m_icsb_counters
argument_list|)
expr_stmt|;
name|xfs_icsb_unlock_all_counters
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|STATIC
name|void
name|xfs_icsb_sync_counters_int
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_icsb_cnts_t
name|cnt
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Pass 1: lock all counters */
if|if
condition|(
operator|(
name|flags
operator|&
name|XFS_ICSB_SB_LOCKED
operator|)
operator|==
literal|0
condition|)
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_icsb_count
argument_list|(
name|mp
argument_list|,
operator|&
name|cnt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Step 3: update mp->m_sb fields */
if|if
condition|(
operator|!
name|xfs_icsb_counter_disabled
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_ICOUNT
argument_list|)
condition|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
operator|=
name|cnt
operator|.
name|icsb_icount
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_icsb_counter_disabled
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_IFREE
argument_list|)
condition|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
operator|=
name|cnt
operator|.
name|icsb_ifree
expr_stmt|;
if|if
condition|(
operator|!
name|xfs_icsb_counter_disabled
argument_list|(
name|mp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|)
condition|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
operator|=
name|cnt
operator|.
name|icsb_fdblocks
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFS_ICSB_SB_LOCKED
operator|)
operator|==
literal|0
condition|)
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*  * Accurate update of per-cpu counters to incore superblock  */
name|STATIC
name|void
name|xfs_icsb_sync_counters
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_icsb_sync_counters_int
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * lazy addition used for things like df, background sb syncs, etc  */
name|void
name|xfs_icsb_sync_counters_lazy
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_icsb_sync_counters_int
argument_list|(
name|mp
argument_list|,
name|XFS_ICSB_LAZY_COUNT
argument_list|)
expr_stmt|;
block|}
comment|/*  * Balance and enable/disable counters as necessary.  *  * Thresholds for re-enabling counters are somewhat magic.  * inode counts are chosen to be the same number as single  * on disk allocation chunk per CPU, and free blocks is  * something far enough zero that we aren't going thrash  * when we get near ENOSPC.  */
define|#
directive|define
name|XFS_ICSB_INO_CNTR_REENABLE
value|64
define|#
directive|define
name|XFS_ICSB_FDBLK_CNTR_REENABLE
value|512
name|STATIC
name|void
name|xfs_icsb_balance_counter
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint64_t
name|count
decl_stmt|,
name|resid
init|=
literal|0
decl_stmt|;
name|int
name|weight
init|=
name|num_online_cpus
argument_list|()
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_ICSB_SB_LOCKED
operator|)
condition|)
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* disable counter and sync counter */
name|xfs_icsb_disable_counter
argument_list|(
name|mp
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* update counters  - first CPU gets residual*/
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_SBS_ICOUNT
case|:
name|count
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_icount
expr_stmt|;
name|resid
operator|=
name|do_div
argument_list|(
name|count
argument_list|,
name|weight
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|XFS_ICSB_INO_CNTR_REENABLE
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|XFS_SBS_IFREE
case|:
name|count
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_ifree
expr_stmt|;
name|resid
operator|=
name|do_div
argument_list|(
name|count
argument_list|,
name|weight
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|XFS_ICSB_INO_CNTR_REENABLE
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|XFS_SBS_FDBLOCKS
case|:
name|count
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_fdblocks
expr_stmt|;
name|resid
operator|=
name|do_div
argument_list|(
name|count
argument_list|,
name|weight
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|XFS_ICSB_FDBLK_CNTR_REENABLE
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
name|xfs_icsb_enable_counter
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|count
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_ICSB_SB_LOCKED
operator|)
condition|)
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|STATIC
name|int
name|xfs_icsb_modify_counters_int
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|xfs_icsb_cnts_t
modifier|*
name|icsbp
decl_stmt|;
name|long
name|long
name|lcounter
decl_stmt|;
comment|/* long counter for 64 bit fields */
name|int
name|cpu
decl_stmt|,
name|s
decl_stmt|,
name|locked
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|balance_done
init|=
literal|0
decl_stmt|;
name|again
label|:
name|cpu
operator|=
name|get_cpu
argument_list|()
expr_stmt|;
name|icsbp
operator|=
operator|(
name|xfs_icsb_cnts_t
operator|*
operator|)
name|per_cpu_ptr
argument_list|(
name|mp
operator|->
name|m_sb_cnts
argument_list|,
name|cpu
argument_list|)
operator|,
name|xfs_icsb_lock_cntr
argument_list|(
name|icsbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|xfs_icsb_counter_disabled
argument_list|(
name|mp
argument_list|,
name|field
argument_list|)
argument_list|)
condition|)
goto|goto
name|slow_path
goto|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_SBS_ICOUNT
case|:
name|lcounter
operator|=
name|icsbp
operator|->
name|icsb_icount
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|lcounter
operator|<
literal|0
argument_list|)
condition|)
goto|goto
name|slow_path
goto|;
name|icsbp
operator|->
name|icsb_icount
operator|=
name|lcounter
expr_stmt|;
break|break;
case|case
name|XFS_SBS_IFREE
case|:
name|lcounter
operator|=
name|icsbp
operator|->
name|icsb_ifree
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|lcounter
operator|<
literal|0
argument_list|)
condition|)
goto|goto
name|slow_path
goto|;
name|icsbp
operator|->
name|icsb_ifree
operator|=
name|lcounter
expr_stmt|;
break|break;
case|case
name|XFS_SBS_FDBLOCKS
case|:
name|BUG_ON
argument_list|(
operator|(
name|mp
operator|->
name|m_resblks
operator|-
name|mp
operator|->
name|m_resblks_avail
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|lcounter
operator|=
name|icsbp
operator|->
name|icsb_fdblocks
expr_stmt|;
name|lcounter
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|lcounter
operator|<
literal|0
argument_list|)
condition|)
goto|goto
name|slow_path
goto|;
name|icsbp
operator|->
name|icsb_fdblocks
operator|=
name|lcounter
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
name|xfs_icsb_unlock_cntr
argument_list|(
name|icsbp
argument_list|)
expr_stmt|;
name|put_cpu
argument_list|()
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* 	 * The slow path needs to be run with the SBLOCK 	 * held so that we prevent other threads from 	 * attempting to run this path at the same time. 	 * this provides exclusion for the balancing code, 	 * and exclusive fallback if the balance does not 	 * provide enough resources to continue in an unlocked 	 * manner. 	 */
name|slow_path
label|:
name|xfs_icsb_unlock_cntr
argument_list|(
name|icsbp
argument_list|)
expr_stmt|;
name|put_cpu
argument_list|()
expr_stmt|;
comment|/* need to hold superblock incase we need 	 * to disable a counter */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_ICSB_SB_LOCKED
operator|)
condition|)
block|{
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|XFS_ICSB_SB_LOCKED
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|balance_done
condition|)
block|{
name|xfs_icsb_balance_counter
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|balance_done
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
comment|/* 		 * we might not have enough on this local 		 * cpu to allocate for a bulk request. 		 * We need to drain this field from all CPUs 		 * and disable the counter fastpath 		 */
name|xfs_icsb_disable_counter
argument_list|(
name|mp
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|xfs_mod_incore_sb_unlocked
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|STATIC
name|int
name|xfs_icsb_modify_counters
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
return|return
name|xfs_icsb_modify_counters_int
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/*  * Called when superblock is already locked  */
name|STATIC
name|int
name|xfs_icsb_modify_counters_locked
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_sb_field_t
name|field
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|rsvd
parameter_list|)
block|{
return|return
name|xfs_icsb_modify_counters_int
argument_list|(
name|mp
argument_list|,
name|field
argument_list|,
name|delta
argument_list|,
name|rsvd
argument_list|,
name|XFS_ICSB_SB_LOCKED
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

