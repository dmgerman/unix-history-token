begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_data.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_block.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_node.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_trace.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * Local function declarations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|xfs_dir2_leaf_check
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_dir2_leaf_check
parameter_list|(
name|dp
parameter_list|,
name|bp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|xfs_dir2_leaf_lookup_int
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|lbpp
parameter_list|,
name|int
modifier|*
name|indexp
parameter_list|,
name|xfs_dabuf_t
modifier|*
modifier|*
name|dbpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfs_dir2_leaf_log_bests
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_dabuf
modifier|*
name|bp
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfs_dir2_leaf_log_tail
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_dabuf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Convert a block form directory to a leaf form directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_block_to_leaf
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|dbp
parameter_list|)
comment|/* input block's buffer */
block|{
name|__be16
modifier|*
name|bestsp
decl_stmt|;
comment|/* leaf's bestsp entries */
name|xfs_dablk_t
name|blkno
decl_stmt|;
comment|/* leaf block's bno */
name|xfs_dir2_block_t
modifier|*
name|block
decl_stmt|;
comment|/* block structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|blp
decl_stmt|;
comment|/* block's leaf entries */
name|xfs_dir2_block_tail_t
modifier|*
name|btp
decl_stmt|;
comment|/* block's tail */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* leaf block's buffer */
name|xfs_dir2_db_t
name|ldb
decl_stmt|;
comment|/* leaf block's bno */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf's tail */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|needlog
decl_stmt|;
comment|/* need to log block header */
name|int
name|needscan
decl_stmt|;
comment|/* need to rescan bestfree */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args_b
argument_list|(
literal|"block_to_leaf"
argument_list|,
name|args
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Add the leaf block to the inode. 	 * This interface will only put blocks in the leaf/node range. 	 * Since that's empty now, we'll get the root (block 0 in range). 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_grow_inode
argument_list|(
name|args
argument_list|,
operator|&
name|blkno
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ldb
operator|=
name|XFS_DIR2_DA_TO_DB
argument_list|(
name|mp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ldb
operator|==
name|XFS_DIR2_LEAF_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the leaf block, get a buffer for it. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_leaf_init
argument_list|(
name|args
argument_list|,
name|ldb
argument_list|,
operator|&
name|lbp
argument_list|,
name|XFS_DIR2_LEAF1_MAGIC
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|lbp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|block
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|btp
operator|=
name|XFS_DIR2_BLOCK_TAIL_P
argument_list|(
name|mp
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|blp
operator|=
name|XFS_DIR2_BLOCK_LEAF_P
argument_list|(
name|btp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the counts in the leaf header. 	 */
name|leaf
operator|->
name|hdr
operator|.
name|count
operator|=
name|cpu_to_be16
argument_list|(
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|stale
operator|=
name|cpu_to_be16
argument_list|(
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|stale
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Could compact these but I think we always do the conversion 	 * after squeezing out stale entries. 	 */
name|memcpy
argument_list|(
name|leaf
operator|->
name|ents
argument_list|,
name|blp
argument_list|,
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|count
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_dir2_leaf_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
literal|0
argument_list|,
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|needscan
operator|=
literal|0
expr_stmt|;
name|needlog
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Make the space formerly occupied by the leaf entries and block 	 * tail be free. 	 */
name|xfs_dir2_data_make_free
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|blp
operator|-
operator|(
name|char
operator|*
operator|)
name|block
argument_list|)
argument_list|,
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|block
operator|+
name|mp
operator|->
name|m_dirblksize
operator|-
operator|(
name|char
operator|*
operator|)
name|blp
argument_list|)
argument_list|,
operator|&
name|needlog
argument_list|,
operator|&
name|needscan
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the block header, make it a data block. 	 */
name|block
operator|->
name|hdr
operator|.
name|magic
operator|=
name|cpu_to_be32
argument_list|(
name|XFS_DIR2_DATA_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|needscan
condition|)
name|xfs_dir2_data_freescan
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dir2_data_t
operator|*
operator|)
name|block
argument_list|,
operator|&
name|needlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Set up leaf tail and bests table. 	 */
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|ltp
operator|->
name|bestcount
operator|=
name|cpu_to_be32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bestsp
operator|=
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
expr_stmt|;
name|bestsp
index|[
literal|0
index|]
operator|=
name|block
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
expr_stmt|;
comment|/* 	 * Log the data header and leaf bests table. 	 */
if|if
condition|(
name|needlog
condition|)
name|xfs_dir2_data_log_header
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry to a leaf form directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leaf_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|__be16
modifier|*
name|bestsp
decl_stmt|;
comment|/* freespace table in leaf */
name|int
name|compact
decl_stmt|;
comment|/* need to compact leaves */
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data block entry */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
decl_stmt|;
comment|/* data unused entry */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|grown
decl_stmt|;
comment|/* allocated new data block */
name|int
name|highstale
decl_stmt|;
comment|/* index of next stale leaf */
name|int
name|i
decl_stmt|;
comment|/* temporary, index */
name|int
name|index
decl_stmt|;
comment|/* leaf table position */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* leaf's buffer */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|int
name|length
decl_stmt|;
comment|/* length of new entry */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry table pointer */
name|int
name|lfloglow
decl_stmt|;
comment|/* low leaf logging index */
name|int
name|lfloghigh
decl_stmt|;
comment|/* high leaf logging index */
name|int
name|lowstale
decl_stmt|;
comment|/* index of prev stale leaf */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail pointer */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|needbytes
decl_stmt|;
comment|/* leaf block bytes needed */
name|int
name|needlog
decl_stmt|;
comment|/* need to log data header */
name|int
name|needscan
decl_stmt|;
comment|/* need to rescan data free */
name|__be16
modifier|*
name|tagp
decl_stmt|;
comment|/* end of data entry */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_db_t
name|use_block
decl_stmt|;
comment|/* data block number */
name|xfs_dir2_trace_args
argument_list|(
literal|"leaf_addname"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * Read the leaf block. 	 */
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|mp
operator|->
name|m_dirleafblk
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|lbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|lbp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the entry by hash value and name. 	 * We know it's not there, our caller has already done a lookup. 	 * So the index is of the entry to insert in front of. 	 * But if there are dup hash values the index is of the first of those. 	 */
name|index
operator|=
name|xfs_dir2_leaf_search_hash
argument_list|(
name|args
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|bestsp
operator|=
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
expr_stmt|;
name|length
operator|=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|args
operator|->
name|namelen
argument_list|)
expr_stmt|;
comment|/* 	 * See if there are any entries with the same hash value 	 * and space in their block for the new entry. 	 * This is good because it puts multiple same-hash value entries 	 * in a data block, improving the lookup of those entries. 	 */
for|for
control|(
name|use_block
operator|=
operator|-
literal|1
operator|,
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
init|;
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|hashval
argument_list|)
operator|==
name|args
operator|->
name|hashval
condition|;
name|index
operator|++
operator|,
name|lep
operator|++
control|)
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
continue|continue;
name|i
operator|=
name|XFS_DIR2_DATAPTR_TO_DB
argument_list|(
name|mp
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|<
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULLDATAOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|i
index|]
argument_list|)
operator|>=
name|length
condition|)
block|{
name|use_block
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Didn't find a block yet, linear search all the data blocks. 	 */
if|if
condition|(
name|use_block
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Remember a block we see that's missing. 			 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|i
index|]
argument_list|)
operator|==
name|NULLDATAOFF
operator|&&
name|use_block
operator|==
operator|-
literal|1
condition|)
name|use_block
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|i
index|]
argument_list|)
operator|>=
name|length
condition|)
block|{
name|use_block
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * How many bytes do we need in the leaf block? 	 */
name|needbytes
operator|=
operator|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
condition|?
literal|0
else|:
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|ents
index|[
literal|0
index|]
argument_list|)
operator|)
operator|+
operator|(
name|use_block
operator|!=
operator|-
literal|1
condition|?
literal|0
else|:
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|bests
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Now kill use_block if it refers to a missing block, so we 	 * can use it as an indication of allocation needed. 	 */
if|if
condition|(
name|use_block
operator|!=
operator|-
literal|1
operator|&&
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|use_block
index|]
argument_list|)
operator|==
name|NULLDATAOFF
condition|)
name|use_block
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If we don't have enough free bytes but we can make enough 	 * by compacting out stale entries, we'll do that. 	 */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|bestsp
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|leaf
operator|->
name|ents
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
index|]
operator|<
name|needbytes
operator|&&
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
operator|>
literal|1
condition|)
block|{
name|compact
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Otherwise if we don't have enough free bytes we need to 	 * convert to node form. 	 */
elseif|else
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|bestsp
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|leaf
operator|->
name|ents
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
index|]
operator|<
name|needbytes
condition|)
block|{
comment|/* 		 * Just checking or no space reservation, give up. 		 */
if|if
condition|(
name|args
operator|->
name|justcheck
operator|||
name|args
operator|->
name|total
operator|==
literal|0
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* 		 * Convert to node form. 		 */
name|error
operator|=
name|xfs_dir2_leaf_to_node
argument_list|(
name|args
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 		 * Then add the new entry. 		 */
return|return
name|xfs_dir2_node_addname
argument_list|(
name|args
argument_list|)
return|;
block|}
comment|/* 	 * Otherwise it will fit without compaction. 	 */
else|else
name|compact
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If just checking, then it will fit unless we needed to allocate 	 * a new data block. 	 */
if|if
condition|(
name|args
operator|->
name|justcheck
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|use_block
operator|==
operator|-
literal|1
condition|?
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
else|:
literal|0
return|;
block|}
comment|/* 	 * If no allocations are allowed, return now before we've 	 * changed anything. 	 */
if|if
condition|(
name|args
operator|->
name|total
operator|==
literal|0
operator|&&
name|use_block
operator|==
operator|-
literal|1
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* 	 * Need to compact the leaf entries, removing stale ones. 	 * Leave one stale entry behind - the one closest to our 	 * insertion index - and we'll shift that one to our insertion 	 * point later. 	 */
if|if
condition|(
name|compact
condition|)
block|{
name|xfs_dir2_leaf_compact_x1
argument_list|(
name|lbp
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|lowstale
argument_list|,
operator|&
name|highstale
argument_list|,
operator|&
name|lfloglow
argument_list|,
operator|&
name|lfloghigh
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There are stale entries, so we'll need log-low and log-high 	 * impossibly bad values later. 	 */
elseif|else
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
condition|)
block|{
name|lfloglow
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|lfloghigh
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * If there was no data block space found, we need to allocate 	 * a new one. 	 */
if|if
condition|(
name|use_block
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Add the new data block. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_grow_inode
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_DATA_SPACE
argument_list|,
operator|&
name|use_block
argument_list|)
operator|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * Initialize the block. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_data_init
argument_list|(
name|args
argument_list|,
name|use_block
argument_list|,
operator|&
name|dbp
argument_list|)
operator|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * If we're adding a new data block on the end we need to 		 * extend the bests table.  Copy it up one entry. 		 */
if|if
condition|(
name|use_block
operator|>=
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
condition|)
block|{
name|bestsp
operator|--
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|bestsp
index|[
literal|0
index|]
argument_list|,
operator|&
name|bestsp
index|[
literal|1
index|]
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|bestsp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|ltp
operator|->
name|bestcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_tail
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
literal|0
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we're filling in a previously empty block just log it. 		 */
else|else
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
name|use_block
argument_list|,
name|use_block
argument_list|)
expr_stmt|;
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|bestsp
index|[
name|use_block
index|]
operator|=
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
expr_stmt|;
name|grown
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Already had space in some data block. 	 * Just read that one in. 	 */
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|use_block
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|dbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|grown
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* 	 * Point to the biggest freespace in our data block. 	 */
name|dup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|be16_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|offset
argument_list|)
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
operator|>=
name|length
argument_list|)
expr_stmt|;
name|needscan
operator|=
name|needlog
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mark the initial part of our freespace in use for the new entry. 	 */
name|xfs_dir2_data_use_free
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
name|dup
argument_list|,
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|length
argument_list|,
operator|&
name|needlog
argument_list|,
operator|&
name|needscan
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize our new entry (at last). 	 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
name|dup
expr_stmt|;
name|INT_SET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|dep
operator|->
name|namelen
operator|=
name|args
operator|->
name|namelen
expr_stmt|;
name|memcpy
argument_list|(
name|dep
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|dep
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|tagp
operator|=
name|XFS_DIR2_DATA_ENTRY_TAG_P
argument_list|(
name|dep
argument_list|)
expr_stmt|;
operator|*
name|tagp
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * Need to scan fix up the bestfree table. 	 */
if|if
condition|(
name|needscan
condition|)
name|xfs_dir2_data_freescan
argument_list|(
name|mp
argument_list|,
name|data
argument_list|,
operator|&
name|needlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Need to log the data block's header. 	 */
if|if
condition|(
name|needlog
condition|)
name|xfs_dir2_data_log_header
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_entry
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
name|dep
argument_list|)
expr_stmt|;
comment|/* 	 * If the bests table needs to be changed, do it. 	 * Log the change unless we've already done that. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|use_block
index|]
argument_list|)
operator|!=
name|be16_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
name|bestsp
index|[
name|use_block
index|]
operator|=
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|grown
condition|)
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
name|use_block
argument_list|,
name|use_block
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now we need to make room to insert the leaf entry. 	 * If there are no stale entries, we just insert a hole at index. 	 */
if|if
condition|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|stale
condition|)
block|{
comment|/* 		 * lep is still good as the index leaf entry. 		 */
if|if
condition|(
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
name|memmove
argument_list|(
name|lep
operator|+
literal|1
argument_list|,
name|lep
argument_list|,
operator|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Record low and high logging indices for the leaf. 		 */
name|lfloglow
operator|=
name|index
expr_stmt|;
name|lfloghigh
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There are stale entries. 	 * We will use one of them for the new entry. 	 * It's probably not at the right location, so we'll have to 	 * shift some up or down first. 	 */
else|else
block|{
comment|/* 		 * If we didn't compact before, we need to find the nearest 		 * stale entries before and after our insertion point. 		 */
if|if
condition|(
name|compact
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Find the first stale entry before the insertion 			 * point, if any. 			 */
for|for
control|(
name|lowstale
operator|=
name|index
operator|-
literal|1
init|;
name|lowstale
operator|>=
literal|0
operator|&&
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
operator|.
name|address
argument_list|)
operator|!=
name|XFS_DIR2_NULL_DATAPTR
condition|;
name|lowstale
operator|--
control|)
continue|continue;
comment|/* 			 * Find the next stale entry at or after the insertion 			 * point, if any.   Stop if we go so far that the 			 * lowstale entry would be better. 			 */
for|for
control|(
name|highstale
operator|=
name|index
init|;
name|highstale
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|highstale
index|]
operator|.
name|address
argument_list|)
operator|!=
name|XFS_DIR2_NULL_DATAPTR
operator|&&
operator|(
name|lowstale
operator|<
literal|0
operator|||
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|>=
name|highstale
operator|-
name|index
operator|)
condition|;
name|highstale
operator|++
control|)
continue|continue;
block|}
comment|/* 		 * If the low one is better, use it. 		 */
if|if
condition|(
name|lowstale
operator|>=
literal|0
operator|&&
operator|(
name|highstale
operator|==
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|||
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|<
name|highstale
operator|-
name|index
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
operator|.
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
argument_list|)
expr_stmt|;
comment|/* 			 * Copy entries up to cover the stale entry 			 * and make room for the new entry. 			 */
if|if
condition|(
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|>
literal|0
condition|)
name|memmove
argument_list|(
operator|&
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
argument_list|,
operator|&
name|leaf
operator|->
name|ents
index|[
name|lowstale
operator|+
literal|1
index|]
argument_list|,
operator|(
name|index
operator|-
name|lowstale
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lep
argument_list|)
argument_list|)
expr_stmt|;
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
operator|-
literal|1
index|]
expr_stmt|;
name|lfloglow
operator|=
name|MIN
argument_list|(
name|lowstale
argument_list|,
name|lfloglow
argument_list|)
expr_stmt|;
name|lfloghigh
operator|=
name|MAX
argument_list|(
name|index
operator|-
literal|1
argument_list|,
name|lfloghigh
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The high one is better, so use that one. 		 */
else|else
block|{
name|ASSERT
argument_list|(
name|highstale
operator|-
name|index
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|highstale
index|]
operator|.
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
argument_list|)
expr_stmt|;
comment|/* 			 * Copy entries down to cover the stale entry 			 * and make room for the new entry. 			 */
if|if
condition|(
name|highstale
operator|-
name|index
operator|>
literal|0
condition|)
name|memmove
argument_list|(
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
argument_list|,
operator|(
name|highstale
operator|-
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lep
argument_list|)
argument_list|)
expr_stmt|;
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
name|lfloglow
operator|=
name|MIN
argument_list|(
name|index
argument_list|,
name|lfloglow
argument_list|)
expr_stmt|;
name|lfloghigh
operator|=
name|MAX
argument_list|(
name|highstale
argument_list|,
name|lfloghigh
argument_list|)
expr_stmt|;
block|}
name|be16_add
argument_list|(
operator|&
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the new leaf entry. 	 */
name|lep
operator|->
name|hashval
operator|=
name|cpu_to_be32
argument_list|(
name|args
operator|->
name|hashval
argument_list|)
expr_stmt|;
name|lep
operator|->
name|address
operator|=
name|cpu_to_be32
argument_list|(
name|XFS_DIR2_DB_OFF_TO_DATAPTR
argument_list|(
name|mp
argument_list|,
name|use_block
argument_list|,
name|be16_to_cpu
argument_list|(
operator|*
name|tagp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Log the leaf fields and give up the buffers. 	 */
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
name|lfloglow
argument_list|,
name|lfloghigh
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Check the internal consistency of a leaf1 block.  * Pop an assert if something is wrong.  */
end_comment

begin_function
name|void
name|xfs_dir2_leaf_check
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* leaf's buffer */
block|{
name|int
name|i
decl_stmt|;
comment|/* leaf index */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail pointer */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|stale
decl_stmt|;
comment|/* count of stale leaves */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAF1_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * This value is not restrictive enough. 	 * Should factor in the size of the bests table as well. 	 * We can deduce a value for that from di_size. 	 */
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|<=
name|XFS_DIR2_MAX_LEAF_ENTS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
comment|/* 	 * Leaves and bests don't overlap. 	 */
name|ASSERT
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|leaf
operator|->
name|ents
index|[
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
index|]
operator|<=
operator|(
name|char
operator|*
operator|)
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check hash value order, count stale entries. 	 */
for|for
control|(
name|i
operator|=
name|stale
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|i
index|]
operator|.
name|hashval
argument_list|)
operator|<=
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|hashval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|i
index|]
operator|.
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
name|stale
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
operator|==
name|stale
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Compact out any stale entries in the leaf.  * Log the header and changed leaf entries, if any.  */
end_comment

begin_function
name|void
name|xfs_dir2_leaf_compact
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* leaf buffer */
block|{
name|int
name|from
decl_stmt|;
comment|/* source leaf index */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|int
name|loglow
decl_stmt|;
comment|/* first leaf entry to log */
name|int
name|to
decl_stmt|;
comment|/* target leaf index */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|stale
condition|)
block|{
return|return;
block|}
comment|/* 	 * Compress out the stale entries in place. 	 */
for|for
control|(
name|from
operator|=
name|to
operator|=
literal|0
operator|,
name|loglow
operator|=
operator|-
literal|1
init|;
name|from
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|from
operator|++
control|)
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|from
index|]
operator|.
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
continue|continue;
comment|/* 		 * Only actually copy the entries that are different. 		 */
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
if|if
condition|(
name|loglow
operator|==
operator|-
literal|1
condition|)
name|loglow
operator|=
name|to
expr_stmt|;
name|leaf
operator|->
name|ents
index|[
name|to
index|]
operator|=
name|leaf
operator|->
name|ents
index|[
name|from
index|]
expr_stmt|;
block|}
name|to
operator|++
expr_stmt|;
block|}
comment|/* 	 * Update and log the header, log the leaf entries. 	 */
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
operator|==
name|from
operator|-
name|to
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
operator|-
operator|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|stale
operator|=
literal|0
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|loglow
operator|!=
operator|-
literal|1
condition|)
name|xfs_dir2_leaf_log_ents
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|loglow
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compact the leaf entries, removing stale ones.  * Leave one stale entry behind - the one closest to our  * insertion index - and the caller will shift that one to our insertion  * point later.  * Return new insertion index, where the remaining stale entry is,  * and leaf logging indices.  */
end_comment

begin_function
name|void
name|xfs_dir2_leaf_compact_x1
parameter_list|(
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|int
modifier|*
name|indexp
parameter_list|,
comment|/* insertion index */
name|int
modifier|*
name|lowstalep
parameter_list|,
comment|/* out: stale entry before us */
name|int
modifier|*
name|highstalep
parameter_list|,
comment|/* out: stale entry after us */
name|int
modifier|*
name|lowlogp
parameter_list|,
comment|/* out: low log index */
name|int
modifier|*
name|highlogp
parameter_list|)
comment|/* out: high log index */
block|{
name|int
name|from
decl_stmt|;
comment|/* source copy index */
name|int
name|highstale
decl_stmt|;
comment|/* stale entry at/after index */
name|int
name|index
decl_stmt|;
comment|/* insertion index */
name|int
name|keepstale
decl_stmt|;
comment|/* source index of kept stale */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|int
name|lowstale
decl_stmt|;
comment|/* stale entry before index */
name|int
name|newindex
init|=
literal|0
decl_stmt|;
comment|/* new insertion index */
name|int
name|to
decl_stmt|;
comment|/* destination copy index */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
operator|>
literal|1
argument_list|)
expr_stmt|;
name|index
operator|=
operator|*
name|indexp
expr_stmt|;
comment|/* 	 * Find the first stale entry before our index, if any. 	 */
for|for
control|(
name|lowstale
operator|=
name|index
operator|-
literal|1
init|;
name|lowstale
operator|>=
literal|0
operator|&&
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|lowstale
index|]
operator|.
name|address
argument_list|)
operator|!=
name|XFS_DIR2_NULL_DATAPTR
condition|;
name|lowstale
operator|--
control|)
continue|continue;
comment|/* 	 * Find the first stale entry at or after our index, if any. 	 * Stop if the answer would be worse than lowstale. 	 */
for|for
control|(
name|highstale
operator|=
name|index
init|;
name|highstale
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|highstale
index|]
operator|.
name|address
argument_list|)
operator|!=
name|XFS_DIR2_NULL_DATAPTR
operator|&&
operator|(
name|lowstale
operator|<
literal|0
operator|||
name|index
operator|-
name|lowstale
operator|>
name|highstale
operator|-
name|index
operator|)
condition|;
name|highstale
operator|++
control|)
continue|continue;
comment|/* 	 * Pick the better of lowstale and highstale. 	 */
if|if
condition|(
name|lowstale
operator|>=
literal|0
operator|&&
operator|(
name|highstale
operator|==
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|||
name|index
operator|-
name|lowstale
operator|<=
name|highstale
operator|-
name|index
operator|)
condition|)
name|keepstale
operator|=
name|lowstale
expr_stmt|;
else|else
name|keepstale
operator|=
name|highstale
expr_stmt|;
comment|/* 	 * Copy the entries in place, removing all the stale entries 	 * except keepstale. 	 */
for|for
control|(
name|from
operator|=
name|to
operator|=
literal|0
init|;
name|from
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|from
operator|++
control|)
block|{
comment|/* 		 * Notice the new value of index. 		 */
if|if
condition|(
name|index
operator|==
name|from
condition|)
name|newindex
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|keepstale
operator|&&
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|ents
index|[
name|from
index|]
operator|.
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|to
condition|)
operator|*
name|lowlogp
operator|=
name|to
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Record the new keepstale value for the insertion. 		 */
if|if
condition|(
name|from
operator|==
name|keepstale
condition|)
name|lowstale
operator|=
name|highstale
operator|=
name|to
expr_stmt|;
comment|/* 		 * Copy only the entries that have moved. 		 */
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|leaf
operator|->
name|ents
index|[
name|to
index|]
operator|=
name|leaf
operator|->
name|ents
index|[
name|from
index|]
expr_stmt|;
name|to
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|from
operator|>
name|to
argument_list|)
expr_stmt|;
comment|/* 	 * If the insertion point was past the last entry, 	 * set the new insertion point accordingly. 	 */
if|if
condition|(
name|index
operator|==
name|from
condition|)
name|newindex
operator|=
name|to
expr_stmt|;
operator|*
name|indexp
operator|=
name|newindex
expr_stmt|;
comment|/* 	 * Adjust the leaf header values. 	 */
name|be16_add
argument_list|(
operator|&
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
operator|-
operator|(
name|from
operator|-
name|to
operator|)
argument_list|)
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|stale
operator|=
name|cpu_to_be16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Remember the low/high stale value only in the "right" 	 * direction. 	 */
if|if
condition|(
name|lowstale
operator|>=
name|newindex
condition|)
name|lowstale
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|highstale
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
expr_stmt|;
operator|*
name|highlogp
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|*
name|lowstalep
operator|=
name|lowstale
expr_stmt|;
operator|*
name|highstalep
operator|=
name|highstale
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Getdents (readdir) for leaf and node directories.  * This reads the data blocks only, so is the same for both forms.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leaf_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore directory inode */
name|uio_t
modifier|*
name|uio
parameter_list|,
comment|/* I/O control& vectors */
name|int
modifier|*
name|eofp
parameter_list|,
comment|/* out: reached end of dir */
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
comment|/* caller's buffer */
name|xfs_dir2_put_t
name|put
parameter_list|)
comment|/* ABI formatting routine */
block|{
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* data block buffer */
name|int
name|byteoff
decl_stmt|;
comment|/* offset in current block */
name|xfs_dir2_db_t
name|curdb
decl_stmt|;
comment|/* db for current block */
name|xfs_dir2_off_t
name|curoff
decl_stmt|;
comment|/* current overall offset */
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data entry */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
decl_stmt|;
comment|/* unused entry */
name|int
name|eof
decl_stmt|;
comment|/* reached end of directory */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* temporary loop index */
name|int
name|j
decl_stmt|;
comment|/* temporary loop index */
name|int
name|length
decl_stmt|;
comment|/* temporary length value */
name|xfs_bmbt_irec_t
modifier|*
name|map
decl_stmt|;
comment|/* map vector for blocks */
name|xfs_extlen_t
name|map_blocks
decl_stmt|;
comment|/* number of fsbs in map */
name|xfs_dablk_t
name|map_off
decl_stmt|;
comment|/* last mapped file offset */
name|int
name|map_size
decl_stmt|;
comment|/* total entries in *map */
name|int
name|map_valid
decl_stmt|;
comment|/* valid entries in *map */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_dir2_off_t
name|newoff
decl_stmt|;
comment|/* new curoff after new blk */
name|int
name|nmap
decl_stmt|;
comment|/* mappings to ask xfs_bmapi */
name|xfs_dir2_put_args_t
modifier|*
name|p
decl_stmt|;
comment|/* formatting arg bundle */
name|char
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
comment|/* pointer to current data */
name|int
name|ra_current
decl_stmt|;
comment|/* number of read-ahead blks */
name|int
name|ra_index
decl_stmt|;
comment|/* *map index for read-ahead */
name|int
name|ra_offset
decl_stmt|;
comment|/* map entry offset for ra */
name|int
name|ra_want
decl_stmt|;
comment|/* readahead count wanted */
comment|/* 	 * If the offset is at or past the largest allowed value, 	 * give up right away, return eof. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>=
name|XFS_DIR2_MAX_DATAPTR
condition|)
block|{
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * Setup formatting arguments. 	 */
name|p
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|p
operator|->
name|dbp
operator|=
name|dbp
expr_stmt|;
name|p
operator|->
name|put
operator|=
name|put
expr_stmt|;
name|p
operator|->
name|uio
operator|=
name|uio
expr_stmt|;
comment|/* 	 * Set up to bmap a number of blocks based on the caller's 	 * buffer size, the directory block size, and the filesystem 	 * block size. 	 */
name|map_size
operator|=
name|howmany
argument_list|(
name|uio
operator|->
name|uio_resid
operator|+
name|mp
operator|->
name|m_dirblksize
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|)
expr_stmt|;
name|map
operator|=
name|kmem_alloc
argument_list|(
name|map_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|map_valid
operator|=
name|ra_index
operator|=
name|ra_offset
operator|=
name|ra_current
operator|=
name|map_blocks
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|eof
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Inside the loop we keep the main offset value as a byte offset 	 * in the directory file. 	 */
name|curoff
operator|=
name|XFS_DIR2_DATAPTR_TO_BYTE
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
comment|/* 	 * Force this conversion through db so we truncate the offset 	 * down to get the start of the data block. 	 */
name|map_off
operator|=
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_BYTE_TO_DB
argument_list|(
name|mp
argument_list|,
name|curoff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over directory entries until we reach the end offset. 	 * Get more blocks and readahead as necessary. 	 */
while|while
condition|(
name|curoff
operator|<
name|XFS_DIR2_LEAF_OFFSET
condition|)
block|{
comment|/* 		 * If we have no buffer, or we're off the end of the 		 * current buffer, need to get another one. 		 */
if|if
condition|(
operator|!
name|bp
operator|||
name|ptr
operator|>=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|data
operator|+
name|mp
operator|->
name|m_dirblksize
condition|)
block|{
comment|/* 			 * If we have a buffer, we need to release it and 			 * take it out of the mapping. 			 */
if|if
condition|(
name|bp
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|map_blocks
operator|-=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
comment|/* 				 * Loop to get rid of the extents for the 				 * directory block. 				 */
for|for
control|(
name|i
operator|=
name|mp
operator|->
name|m_dirblkfsbs
init|;
name|i
operator|>
literal|0
condition|;
control|)
block|{
name|j
operator|=
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|map
operator|->
name|br_blockcount
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|map
operator|->
name|br_blockcount
operator|-=
name|j
expr_stmt|;
name|map
operator|->
name|br_startblock
operator|+=
name|j
expr_stmt|;
name|map
operator|->
name|br_startoff
operator|+=
name|j
expr_stmt|;
comment|/* 					 * If mapping is done, pitch it from 					 * the table. 					 */
if|if
condition|(
operator|!
name|map
operator|->
name|br_blockcount
operator|&&
operator|--
name|map_valid
condition|)
name|memmove
argument_list|(
operator|&
name|map
index|[
literal|0
index|]
argument_list|,
operator|&
name|map
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|map
index|[
literal|0
index|]
argument_list|)
operator|*
name|map_valid
argument_list|)
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
block|}
block|}
comment|/* 			 * Recalculate the readahead blocks wanted. 			 */
name|ra_want
operator|=
name|howmany
argument_list|(
name|uio
operator|->
name|uio_resid
operator|+
name|mp
operator|->
name|m_dirblksize
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * If we don't have as many as we want, and we haven't 			 * run out of data blocks, get some more mappings. 			 */
if|if
condition|(
literal|1
operator|+
name|ra_want
operator|>
name|map_blocks
operator|&&
name|map_off
operator|<
name|XFS_DIR2_BYTE_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_LEAF_OFFSET
argument_list|)
condition|)
block|{
comment|/* 				 * Get more bmaps, fill in after the ones 				 * we already have in the table. 				 */
name|nmap
operator|=
name|map_size
operator|-
name|map_valid
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|map_off
argument_list|,
name|XFS_DIR2_BYTE_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_LEAF_OFFSET
argument_list|)
operator|-
name|map_off
argument_list|,
name|XFS_BMAPI_METADATA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|map
index|[
name|map_valid
index|]
argument_list|,
operator|&
name|nmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * Don't know if we should ignore this or 				 * try to return an error. 				 * The trouble with returning errors 				 * is that readdir will just stop without 				 * actually passing the error through. 				 */
if|if
condition|(
name|error
condition|)
break|break;
comment|/* XXX */
comment|/* 				 * If we got all the mappings we asked for, 				 * set the final map offset based on the 				 * last bmap value received. 				 * Otherwise, we've reached the end. 				 */
if|if
condition|(
name|nmap
operator|==
name|map_size
operator|-
name|map_valid
condition|)
name|map_off
operator|=
name|map
index|[
name|map_valid
operator|+
name|nmap
operator|-
literal|1
index|]
operator|.
name|br_startoff
operator|+
name|map
index|[
name|map_valid
operator|+
name|nmap
operator|-
literal|1
index|]
operator|.
name|br_blockcount
expr_stmt|;
else|else
name|map_off
operator|=
name|XFS_DIR2_BYTE_TO_DA
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_LEAF_OFFSET
argument_list|)
expr_stmt|;
comment|/* 				 * Look for holes in the mapping, and 				 * eliminate them.  Count up the valid blocks. 				 */
for|for
control|(
name|i
operator|=
name|map_valid
init|;
name|i
operator|<
name|map_valid
operator|+
name|nmap
condition|;
control|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|br_startblock
operator|==
name|HOLESTARTBLOCK
condition|)
block|{
name|nmap
operator|--
expr_stmt|;
name|length
operator|=
name|map_valid
operator|+
name|nmap
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|length
condition|)
name|memmove
argument_list|(
operator|&
name|map
index|[
name|i
index|]
argument_list|,
operator|&
name|map
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|map
index|[
name|i
index|]
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map_blocks
operator|+=
name|map
index|[
name|i
index|]
operator|.
name|br_blockcount
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|map_valid
operator|+=
name|nmap
expr_stmt|;
block|}
comment|/* 			 * No valid mappings, so no more data blocks. 			 */
if|if
condition|(
operator|!
name|map_valid
condition|)
block|{
name|curoff
operator|=
name|XFS_DIR2_DA_TO_BYTE
argument_list|(
name|mp
argument_list|,
name|map_off
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Read the directory block starting at the first 			 * mapping. 			 */
name|curdb
operator|=
name|XFS_DIR2_DA_TO_DB
argument_list|(
name|mp
argument_list|,
name|map
operator|->
name|br_startoff
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|map
operator|->
name|br_startoff
argument_list|,
name|map
operator|->
name|br_blockcount
operator|>=
name|mp
operator|->
name|m_dirblkfsbs
condition|?
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|map
operator|->
name|br_startblock
argument_list|)
else|:
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
comment|/* 			 * Should just skip over the data block instead 			 * of giving up. 			 */
if|if
condition|(
name|error
condition|)
break|break;
comment|/* XXX */
comment|/* 			 * Adjust the current amount of read-ahead: we just 			 * read a block that was previously ra. 			 */
if|if
condition|(
name|ra_current
condition|)
name|ra_current
operator|-=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
comment|/* 			 * Do we need more readahead? 			 */
for|for
control|(
name|ra_index
operator|=
name|ra_offset
operator|=
name|i
operator|=
literal|0
init|;
name|ra_want
operator|>
name|ra_current
operator|&&
name|i
operator|<
name|map_blocks
condition|;
name|i
operator|+=
name|mp
operator|->
name|m_dirblkfsbs
control|)
block|{
name|ASSERT
argument_list|(
name|ra_index
operator|<
name|map_valid
argument_list|)
expr_stmt|;
comment|/* 				 * Read-ahead a contiguous directory block. 				 */
if|if
condition|(
name|i
operator|>
name|ra_current
operator|&&
name|map
index|[
name|ra_index
index|]
operator|.
name|br_blockcount
operator|>=
name|mp
operator|->
name|m_dirblkfsbs
condition|)
block|{
name|xfs_baread
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|map
index|[
name|ra_index
index|]
operator|.
name|br_startblock
operator|+
name|ra_offset
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|BTOBB
argument_list|(
name|mp
operator|->
name|m_dirblksize
argument_list|)
argument_list|)
expr_stmt|;
name|ra_current
operator|=
name|i
expr_stmt|;
block|}
comment|/* 				 * Read-ahead a non-contiguous directory block. 				 * This doesn't use our mapping, but this 				 * is a very rare case. 				 */
elseif|else
if|if
condition|(
name|i
operator|>
name|ra_current
condition|)
block|{
operator|(
name|void
operator|)
name|xfs_da_reada_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|map
index|[
name|ra_index
index|]
operator|.
name|br_startoff
operator|+
name|ra_offset
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
name|ra_current
operator|=
name|i
expr_stmt|;
block|}
comment|/* 				 * Advance offset through the mapping table. 				 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mp
operator|->
name|m_dirblkfsbs
condition|;
name|j
operator|++
control|)
block|{
comment|/* 					 * The rest of this extent but not 					 * more than a dir block. 					 */
name|length
operator|=
name|MIN
argument_list|(
name|mp
operator|->
name|m_dirblkfsbs
argument_list|,
call|(
name|int
call|)
argument_list|(
name|map
index|[
name|ra_index
index|]
operator|.
name|br_blockcount
operator|-
name|ra_offset
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|+=
name|length
expr_stmt|;
name|ra_offset
operator|+=
name|length
expr_stmt|;
comment|/* 					 * Advance to the next mapping if 					 * this one is used up. 					 */
if|if
condition|(
name|ra_offset
operator|==
name|map
index|[
name|ra_index
index|]
operator|.
name|br_blockcount
condition|)
block|{
name|ra_offset
operator|=
literal|0
expr_stmt|;
name|ra_index
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 			 * Having done a read, we need to set a new offset. 			 */
name|newoff
operator|=
name|XFS_DIR2_DB_OFF_TO_BYTE
argument_list|(
name|mp
argument_list|,
name|curdb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Start of the current block. 			 */
if|if
condition|(
name|curoff
operator|<
name|newoff
condition|)
name|curoff
operator|=
name|newoff
expr_stmt|;
comment|/* 			 * Make sure we're in the right block. 			 */
elseif|else
if|if
condition|(
name|curoff
operator|>
name|newoff
condition|)
name|ASSERT
argument_list|(
name|XFS_DIR2_BYTE_TO_DB
argument_list|(
name|mp
argument_list|,
name|curoff
argument_list|)
operator|==
name|curdb
argument_list|)
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Find our position in the block. 			 */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
operator|->
name|u
expr_stmt|;
name|byteoff
operator|=
name|XFS_DIR2_BYTE_TO_OFF
argument_list|(
name|mp
argument_list|,
name|curoff
argument_list|)
expr_stmt|;
comment|/* 			 * Skip past the header. 			 */
if|if
condition|(
name|byteoff
operator|==
literal|0
condition|)
name|curoff
operator|+=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|data
operator|->
name|hdr
argument_list|)
expr_stmt|;
comment|/* 			 * Skip past entries until we reach our offset. 			 */
else|else
block|{
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|<
name|byteoff
condition|)
block|{
name|dup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|freetag
argument_list|)
operator|==
name|XFS_DIR2_DATA_FREE_TAG
condition|)
block|{
name|length
operator|=
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|length
expr_stmt|;
continue|continue;
block|}
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|length
operator|=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|dep
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|length
expr_stmt|;
block|}
comment|/* 				 * Now set our real offset. 				 */
name|curoff
operator|=
name|XFS_DIR2_DB_OFF_TO_BYTE
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_BYTE_TO_DB
argument_list|(
name|mp
argument_list|,
name|curoff
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|mp
operator|->
name|m_dirblksize
condition|)
block|{
continue|continue;
block|}
block|}
block|}
comment|/* 		 * We have a pointer to an entry. 		 * Is it a live one? 		 */
name|dup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* 		 * No, it's unused, skip over it. 		 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|freetag
argument_list|)
operator|==
name|XFS_DIR2_DATA_FREE_TAG
condition|)
block|{
name|length
operator|=
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|length
expr_stmt|;
name|curoff
operator|+=
name|length
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Copy the entry into the putargs, and try formatting it. 		 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|p
operator|->
name|namelen
operator|=
name|dep
operator|->
name|namelen
expr_stmt|;
name|length
operator|=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|p
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|p
operator|->
name|cook
operator|=
name|XFS_DIR2_BYTE_TO_DATAPTR
argument_list|(
name|mp
argument_list|,
name|curoff
operator|+
name|length
argument_list|)
expr_stmt|;
name|p
operator|->
name|ino
operator|=
name|INT_GET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
if|#
directive|if
name|XFS_BIG_INUMS
name|p
operator|->
name|ino
operator|+=
name|mp
operator|->
name|m_inoadd
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|dep
operator|->
name|name
expr_stmt|;
name|error
operator|=
name|p
operator|->
name|put
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Won't fit.  Return to caller. 		 */
if|if
condition|(
operator|!
name|p
operator|->
name|done
condition|)
block|{
name|eof
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * Advance to next entry in the block. 		 */
name|ptr
operator|+=
name|length
expr_stmt|;
name|curoff
operator|+=
name|length
expr_stmt|;
block|}
comment|/* 	 * All done.  Set output offset value to current offset. 	 */
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
if|if
condition|(
name|curoff
operator|>
name|XFS_DIR2_DATAPTR_TO_BYTE
argument_list|(
name|mp
argument_list|,
name|XFS_DIR2_MAX_DATAPTR
argument_list|)
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|XFS_DIR2_MAX_DATAPTR
expr_stmt|;
else|else
name|uio
operator|->
name|uio_offset
operator|=
name|XFS_DIR2_BYTE_TO_DATAPTR
argument_list|(
name|mp
argument_list|,
name|curoff
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|map
argument_list|,
name|map_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a new leaf block, leaf1 or leafn magic accepted.  */
end_comment

begin_function
name|int
name|xfs_dir2_leaf_init
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dir2_db_t
name|bno
parameter_list|,
comment|/* directory block number */
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|,
comment|/* out: leaf buffer */
name|int
name|magic
parameter_list|)
comment|/* magic number for block */
block|{
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* leaf buffer */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|ASSERT
argument_list|(
name|bno
operator|>=
name|XFS_DIR2_LEAF_FIRSTDB
argument_list|(
name|mp
argument_list|)
operator|&&
name|bno
operator|<
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the buffer for the block. 	 */
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
comment|/* 	 * Initialize the header. 	 */
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
operator|=
name|cpu_to_be16
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
operator|=
literal|0
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|back
operator|=
literal|0
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|stale
operator|=
literal|0
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * If it's a leaf-format directory initialize the tail. 	 * In this case our caller has the real bests table to copy into 	 * the block. 	 */
if|if
condition|(
name|magic
operator|==
name|XFS_DIR2_LEAF1_MAGIC
condition|)
block|{
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|ltp
operator|->
name|bestcount
operator|=
literal|0
expr_stmt|;
name|xfs_dir2_leaf_log_tail
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Log the bests entries indicated from a leaf1 block.  */
end_comment

begin_function
specifier|static
name|void
name|xfs_dir2_leaf_log_bests
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|int
name|first
parameter_list|,
comment|/* first entry to log */
name|int
name|last
parameter_list|)
comment|/* last entry to log */
block|{
name|__be16
modifier|*
name|firstb
decl_stmt|;
comment|/* pointer to first entry */
name|__be16
modifier|*
name|lastb
decl_stmt|;
comment|/* pointer to last entry */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail structure */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAF1_MAGIC
argument_list|)
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|firstb
operator|=
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
operator|+
name|first
expr_stmt|;
name|lastb
operator|=
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
operator|+
name|last
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|firstb
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lastb
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|lastb
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log the leaf entries indicated from a leaf1 or leafn block.  */
end_comment

begin_function
name|void
name|xfs_dir2_leaf_log_ents
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* leaf buffer */
name|int
name|first
parameter_list|,
comment|/* first entry to log */
name|int
name|last
parameter_list|)
comment|/* last entry to log */
block|{
name|xfs_dir2_leaf_entry_t
modifier|*
name|firstlep
decl_stmt|;
comment|/* pointer to first entry */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lastlep
decl_stmt|;
comment|/* pointer to last entry */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAF1_MAGIC
operator|||
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|firstlep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|first
index|]
expr_stmt|;
name|lastlep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|last
index|]
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|firstlep
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lastlep
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|lastlep
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log the header of the leaf1 or leafn block.  */
end_comment

begin_function
name|void
name|xfs_dir2_leaf_log_header
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* leaf buffer */
block|{
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAF1_MAGIC
operator|||
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|leaf
operator|->
name|hdr
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|hdr
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log the tail of the leaf1 block.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_dir2_leaf_log_tail
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* leaf buffer */
block|{
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAF1_MAGIC
argument_list|)
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ltp
operator|-
operator|(
name|char
operator|*
operator|)
name|leaf
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|mp
operator|->
name|m_dirblksize
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the entry referred to by args in the leaf format directory.  * Most of the work is done by the xfs_dir2_leaf_lookup_int routine which  * is also used by the node-format code.  */
end_comment

begin_function
name|int
name|xfs_dir2_leaf_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data block entry */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|int
name|index
decl_stmt|;
comment|/* found entry index */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* leaf buffer */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args
argument_list|(
literal|"leaf_lookup"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Look up name in the leaf block, returning both buffers and index. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_leaf_lookup_int
argument_list|(
name|args
argument_list|,
operator|&
name|lbp
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|dbp
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
comment|/* 	 * Get to the leaf entry and contained data entry address. 	 */
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
comment|/* 	 * Point to the data entry. 	 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dbp
operator|->
name|data
operator|+
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Return the found inode number. 	 */
name|args
operator|->
name|inumber
operator|=
name|INT_GET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EEXIST
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up name/hash in the leaf block.  * Fill in indexp with the found index, and dbpp with the data buffer.  * If not found dbpp will be NULL, and ENOENT comes back.  * lbpp will always be filled in with the leaf buffer unless there's an error.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir2_leaf_lookup_int
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
modifier|*
name|lbpp
parameter_list|,
comment|/* out: leaf buffer */
name|int
modifier|*
name|indexp
parameter_list|,
comment|/* out: index in leaf block */
name|xfs_dabuf_t
modifier|*
modifier|*
name|dbpp
parameter_list|)
comment|/* out: data buffer */
block|{
name|xfs_dir2_db_t
name|curdb
decl_stmt|;
comment|/* current data block number */
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data entry */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|int
name|index
decl_stmt|;
comment|/* index in leaf block */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* leaf buffer */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_dir2_db_t
name|newdb
decl_stmt|;
comment|/* new data block number */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
comment|/* 	 * Read the leaf block into the buffer. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|mp
operator|->
name|m_dirleafblk
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|lbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|lbpp
operator|=
name|lbp
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
comment|/* 	 * Look for the first leaf entry with our hash value. 	 */
name|index
operator|=
name|xfs_dir2_leaf_search_hash
argument_list|(
name|args
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over all the entries with the right hash value 	 * looking to match the name. 	 */
for|for
control|(
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
operator|,
name|dbp
operator|=
name|NULL
operator|,
name|curdb
operator|=
operator|-
literal|1
init|;
name|index
operator|<
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|&&
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|hashval
argument_list|)
operator|==
name|args
operator|->
name|hashval
condition|;
name|lep
operator|++
operator|,
name|index
operator|++
control|)
block|{
comment|/* 		 * Skip over stale leaf entries. 		 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
continue|continue;
comment|/* 		 * Get the new data block number. 		 */
name|newdb
operator|=
name|XFS_DIR2_DATAPTR_TO_DB
argument_list|(
name|mp
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If it's not the same as the old data block number, 		 * need to pitch the old one and read the new one. 		 */
if|if
condition|(
name|newdb
operator|!=
name|curdb
condition|)
block|{
if|if
condition|(
name|dbp
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|newdb
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|dbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|curdb
operator|=
name|newdb
expr_stmt|;
block|}
comment|/* 		 * Point to the data entry. 		 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dbp
operator|->
name|data
operator|+
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|mp
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * If it matches then return it. 		 */
if|if
condition|(
name|dep
operator|->
name|namelen
operator|==
name|args
operator|->
name|namelen
operator|&&
name|dep
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|args
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|dep
operator|->
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dbpp
operator|=
name|dbp
expr_stmt|;
operator|*
name|indexp
operator|=
name|index
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * No match found, return ENOENT. 	 */
name|ASSERT
argument_list|(
name|args
operator|->
name|oknoent
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbp
condition|)
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a leaf format directory.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leaf_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|__be16
modifier|*
name|bestsp
decl_stmt|;
comment|/* leaf block best freespace */
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
name|xfs_dir2_db_t
name|db
decl_stmt|;
comment|/* data block number */
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data entry structure */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|xfs_dir2_db_t
name|i
decl_stmt|;
comment|/* temporary data block # */
name|int
name|index
decl_stmt|;
comment|/* index into leaf entries */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* leaf buffer */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|needlog
decl_stmt|;
comment|/* need to log data header */
name|int
name|needscan
decl_stmt|;
comment|/* need to rescan data frees */
name|xfs_dir2_data_off_t
name|oldbest
decl_stmt|;
comment|/* old value of best free */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args
argument_list|(
literal|"leaf_removename"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup the leaf entry, get the leaf and data blocks read in. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_leaf_lookup_int
argument_list|(
name|args
argument_list|,
operator|&
name|lbp
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|dbp
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* 	 * Point to the leaf entry, use that to point to the data entry. 	 */
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
name|db
operator|=
name|XFS_DIR2_DATAPTR_TO_DB
argument_list|(
name|mp
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|mp
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|needscan
operator|=
name|needlog
operator|=
literal|0
expr_stmt|;
name|oldbest
operator|=
name|be16_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|bestsp
operator|=
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|db
index|]
argument_list|)
operator|==
name|oldbest
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the former data entry unused. 	 */
name|xfs_dir2_data_make_free
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
argument_list|,
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|dep
operator|->
name|namelen
argument_list|)
argument_list|,
operator|&
name|needlog
argument_list|,
operator|&
name|needscan
argument_list|)
expr_stmt|;
comment|/* 	 * We just mark the leaf entry stale by putting a null in it. 	 */
name|be16_add
argument_list|(
operator|&
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|lep
operator|->
name|address
operator|=
name|cpu_to_be32
argument_list|(
name|XFS_DIR2_NULL_DATAPTR
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_ents
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
name|index
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the freespace in the data block again if necessary, 	 * log the data block header if necessary. 	 */
if|if
condition|(
name|needscan
condition|)
name|xfs_dir2_data_freescan
argument_list|(
name|mp
argument_list|,
name|data
argument_list|,
operator|&
name|needlog
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|needlog
condition|)
name|xfs_dir2_data_log_header
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* 	 * If the longest freespace in the data block has changed, 	 * put the new value in the bests table and log that. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
operator|!=
name|oldbest
condition|)
block|{
name|bestsp
index|[
name|db
index|]
operator|=
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
expr_stmt|;
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
name|db
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
name|xfs_dir2_data_check
argument_list|(
name|dp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* 	 * If the data block is now empty then get rid of the data block. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
operator|==
name|mp
operator|->
name|m_dirblksize
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|data
operator|->
name|hdr
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|db
operator|!=
name|mp
operator|->
name|m_dirdatablk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_shrink_inode
argument_list|(
name|args
argument_list|,
name|db
argument_list|,
name|dbp
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Nope, can't get rid of it because it caused 			 * allocation of a bmap btree block to do so. 			 * Just go on, returning success, leaving the 			 * empty block in place. 			 */
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|&&
name|args
operator|->
name|total
operator|==
literal|0
condition|)
block|{
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|dbp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If this is the last data block then compact the 		 * bests table by getting rid of entries. 		 */
if|if
condition|(
name|db
operator|==
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Look for the last active entry (i). 			 */
for|for
control|(
name|i
operator|=
name|db
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|bestsp
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULLDATAOFF
condition|)
break|break;
block|}
comment|/* 			 * Copy the table down so inactive entries at the 			 * end are removed. 			 */
name|memmove
argument_list|(
operator|&
name|bestsp
index|[
name|db
operator|-
name|i
index|]
argument_list|,
name|bestsp
argument_list|,
operator|(
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
operator|(
name|db
operator|-
name|i
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bestsp
argument_list|)
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|ltp
operator|->
name|bestcount
argument_list|,
operator|-
operator|(
name|db
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_tail
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
literal|0
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|bestsp
index|[
name|db
index|]
operator|=
name|cpu_to_be16
argument_list|(
name|NULLDATAOFF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the data block was not the first one, drop it. 	 */
elseif|else
if|if
condition|(
name|db
operator|!=
name|mp
operator|->
name|m_dirdatablk
operator|&&
name|dbp
operator|!=
name|NULL
condition|)
block|{
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|NULL
expr_stmt|;
block|}
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
comment|/* 	 * See if we can convert to block form. 	 */
return|return
name|xfs_dir2_leaf_to_block
argument_list|(
name|args
argument_list|,
name|lbp
argument_list|,
name|dbp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replace the inode number in a leaf format directory entry.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leaf_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
comment|/* operation arguments */
block|{
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data block entry */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|int
name|index
decl_stmt|;
comment|/* index of leaf entry */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* leaf buffer */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|xfs_dir2_trace_args
argument_list|(
literal|"leaf_replace"
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the entry. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_leaf_lookup_int
argument_list|(
name|args
argument_list|,
operator|&
name|lbp
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|dbp
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
comment|/* 	 * Point to the leaf entry, get data address from it. 	 */
name|lep
operator|=
operator|&
name|leaf
operator|->
name|ents
index|[
name|index
index|]
expr_stmt|;
comment|/* 	 * Point to the data entry. 	 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dbp
operator|->
name|data
operator|+
name|XFS_DIR2_DATAPTR_TO_OFF
argument_list|(
name|dp
operator|->
name|i_mount
argument_list|,
name|be32_to_cpu
argument_list|(
name|lep
operator|->
name|address
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|args
operator|->
name|inumber
operator|!=
name|INT_GET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Put the new inode number in, log it. 	 */
name|INT_SET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|args
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
name|xfs_dir2_data_log_entry
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|,
name|dep
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return index in the leaf block (lbp) which is either the first  * one with this hash value, or if there are none, the insert point  * for that hash value.  */
end_comment

begin_function
name|int
comment|/* index value */
name|xfs_dir2_leaf_search_hash
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|lbp
parameter_list|)
comment|/* leaf buffer */
block|{
name|xfs_dahash_t
name|hash
init|=
literal|0
decl_stmt|;
comment|/* hash from this entry */
name|xfs_dahash_t
name|hashwant
decl_stmt|;
comment|/* hash value looking for */
name|int
name|high
decl_stmt|;
comment|/* high leaf index */
name|int
name|low
decl_stmt|;
comment|/* low leaf index */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
decl_stmt|;
comment|/* leaf entry */
name|int
name|mid
init|=
literal|0
decl_stmt|;
comment|/* current leaf index */
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
ifndef|#
directive|ifndef
name|__KERNEL__
if|if
condition|(
operator|!
name|leaf
operator|->
name|hdr
operator|.
name|count
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* 	 * Note, the table cannot be empty, so we have to go through the loop. 	 * Binary search the leaf entries looking for our hash value. 	 */
for|for
control|(
name|lep
operator|=
name|leaf
operator|->
name|ents
operator|,
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
operator|,
name|hashwant
operator|=
name|args
operator|->
name|hashval
init|;
name|low
operator|<=
name|high
condition|;
control|)
block|{
name|mid
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|hash
operator|=
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|mid
index|]
operator|.
name|hashval
argument_list|)
operator|)
operator|==
name|hashwant
condition|)
break|break;
if|if
condition|(
name|hash
operator|<
name|hashwant
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Found one, back up through all the equal hash values. 	 */
if|if
condition|(
name|hash
operator|==
name|hashwant
condition|)
block|{
while|while
condition|(
name|mid
operator|>
literal|0
operator|&&
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|mid
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
operator|==
name|hashwant
condition|)
block|{
name|mid
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Need to point to an entry higher than ours. 	 */
elseif|else
if|if
condition|(
name|hash
operator|<
name|hashwant
condition|)
name|mid
operator|++
expr_stmt|;
return|return
name|mid
return|;
block|}
end_function

begin_comment
comment|/*  * Trim off a trailing data block.  We know it's empty since the leaf  * freespace table says so.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_leaf_trim_data
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* operation arguments */
name|xfs_dabuf_t
modifier|*
name|lbp
parameter_list|,
comment|/* leaf buffer */
name|xfs_dir2_db_t
name|db
parameter_list|)
comment|/* data block number */
block|{
name|__be16
modifier|*
name|bestsp
decl_stmt|;
comment|/* leaf bests table */
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_dir2_data_t
modifier|*
name|data
decl_stmt|;
comment|/* data block structure */
endif|#
directive|endif
name|xfs_dabuf_t
modifier|*
name|dbp
decl_stmt|;
comment|/* data block buffer */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* leaf tail structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Read the offending data block.  We need its buffer. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|db
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|dbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|data
operator|=
name|dbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* this seems to be an error 	 * data is only valid if DEBUG is defined? 	 * RMC 09/08/1999 	 */
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|data
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
operator|==
name|mp
operator|->
name|m_dirblksize
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|data
operator|->
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|==
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of the data block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_shrink_inode
argument_list|(
name|args
argument_list|,
name|db
argument_list|,
name|dbp
argument_list|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Eliminate the last bests entry from the table. 	 */
name|bestsp
operator|=
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
expr_stmt|;
name|be32_add
argument_list|(
operator|&
name|ltp
operator|->
name|bestcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|bestsp
index|[
literal|1
index|]
argument_list|,
operator|&
name|bestsp
index|[
literal|0
index|]
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bestsp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_tail
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
literal|0
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Convert node form directory to leaf form directory.  * The root of the node form dir needs to already be a LEAFN block.  * Just return if we can't do anything.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_node_to_leaf
parameter_list|(
name|xfs_da_state_t
modifier|*
name|state
parameter_list|)
comment|/* directory operation state */
block|{
name|xfs_da_args_t
modifier|*
name|args
decl_stmt|;
comment|/* operation arguments */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|int
name|error
decl_stmt|;
comment|/* error return code */
name|xfs_dabuf_t
modifier|*
name|fbp
decl_stmt|;
comment|/* buffer for freespace block */
name|xfs_fileoff_t
name|fo
decl_stmt|;
comment|/* freespace file offset */
name|xfs_dir2_free_t
modifier|*
name|free
decl_stmt|;
comment|/* freespace structure */
name|xfs_dabuf_t
modifier|*
name|lbp
decl_stmt|;
comment|/* buffer for leaf block */
name|xfs_dir2_leaf_tail_t
modifier|*
name|ltp
decl_stmt|;
comment|/* tail of leaf structure */
name|xfs_dir2_leaf_t
modifier|*
name|leaf
decl_stmt|;
comment|/* leaf structure */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|rval
decl_stmt|;
comment|/* successful free trim? */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
comment|/* 	 * There's more than a leaf level in the btree, so there must 	 * be multiple leafn blocks.  Give up. 	 */
if|if
condition|(
name|state
operator|->
name|path
operator|.
name|active
operator|>
literal|1
condition|)
return|return
literal|0
return|;
name|args
operator|=
name|state
operator|->
name|args
expr_stmt|;
name|xfs_dir2_trace_args
argument_list|(
literal|"node_to_leaf"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mp
operator|=
name|state
operator|->
name|mp
expr_stmt|;
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Get the last offset in the file. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_last_offset
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|fo
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|fo
operator|-=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
comment|/* 	 * If there are freespace blocks other than the first one, 	 * take this opportunity to remove trailing empty freespace blocks 	 * that may have been left behind during no-space-reservation 	 * operations. 	 */
while|while
condition|(
name|fo
operator|>
name|mp
operator|->
name|m_dirfreeblk
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir2_node_trim_free
argument_list|(
name|args
argument_list|,
name|fo
argument_list|,
operator|&
name|rval
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|rval
condition|)
name|fo
operator|-=
name|mp
operator|->
name|m_dirblkfsbs
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* 	 * Now find the block just before the freespace block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_bmap_last_before
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
operator|&
name|fo
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * If it's not the single leaf block, give up. 	 */
if|if
condition|(
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|fo
argument_list|)
operator|>
name|XFS_DIR2_LEAF_OFFSET
operator|+
name|mp
operator|->
name|m_dirblksize
condition|)
return|return
literal|0
return|;
name|lbp
operator|=
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|.
name|bp
expr_stmt|;
name|leaf
operator|=
name|lbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_LEAFN_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Read the freespace block. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|mp
operator|->
name|m_dirfreeblk
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|fbp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
name|free
operator|=
name|fbp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_FREE_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|free
operator|->
name|hdr
operator|.
name|firstdb
argument_list|)
expr_stmt|;
comment|/* 	 * Now see if the leafn and free data will fit in a leaf1. 	 * If not, release the buffer and give up. 	 */
if|if
condition|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|hdr
argument_list|)
operator|+
operator|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
operator|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|ents
index|[
literal|0
index|]
argument_list|)
operator|+
name|be32_to_cpu
argument_list|(
name|free
operator|->
name|hdr
operator|.
name|nvalid
argument_list|)
operator|*
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|bests
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|tail
argument_list|)
operator|>
name|mp
operator|->
name|m_dirblksize
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|tp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If the leaf has any stale entries in it, compress them out. 	 * The compact routine will log the header. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|stale
argument_list|)
condition|)
name|xfs_dir2_leaf_compact
argument_list|(
name|args
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
else|else
name|xfs_dir2_leaf_log_header
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR2_LEAF1_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the leaf tail from the freespace block. 	 */
name|ltp
operator|=
name|XFS_DIR2_LEAF_TAIL_P
argument_list|(
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|ltp
operator|->
name|bestcount
operator|=
name|free
operator|->
name|hdr
operator|.
name|nvalid
expr_stmt|;
comment|/* 	 * Set up the leaf bests table. 	 */
name|memcpy
argument_list|(
name|XFS_DIR2_LEAF_BESTS_P
argument_list|(
name|ltp
argument_list|)
argument_list|,
name|free
operator|->
name|bests
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|leaf
operator|->
name|bests
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_bests
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|,
literal|0
argument_list|,
name|be32_to_cpu
argument_list|(
name|ltp
operator|->
name|bestcount
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_log_tail
argument_list|(
name|tp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|xfs_dir2_leaf_check
argument_list|(
name|dp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of the freespace block. 	 */
name|error
operator|=
name|xfs_dir2_shrink_inode
argument_list|(
name|args
argument_list|,
name|XFS_DIR2_FREE_FIRSTDB
argument_list|(
name|mp
argument_list|)
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * This can't fail here because it can only happen when 		 * punching out the middle of an extent, and this is an 		 * isolated block. 		 */
name|ASSERT
argument_list|(
name|error
operator|!=
name|ENOSPC
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fbp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Now see if we can convert the single-leaf directory 	 * down to a block form directory. 	 * This routine always kills the dabuf for the leaf, so 	 * eliminate it from the path. 	 */
name|error
operator|=
name|xfs_dir2_leaf_to_block
argument_list|(
name|args
argument_list|,
name|lbp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
literal|0
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

