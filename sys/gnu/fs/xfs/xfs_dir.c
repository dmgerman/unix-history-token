begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_comment
comment|/*  * xfs_dir.c  *  * Provide the external interfaces to manage directories.  */
end_comment

begin_comment
comment|/*========================================================================  * Function prototypes for the kernel.  *========================================================================*/
end_comment

begin_comment
comment|/*  * Functions for the dirops interfaces.  */
end_comment

begin_function_decl
specifier|static
name|void
name|xfs_dir_mount
parameter_list|(
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_isempty
parameter_list|(
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_init
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|trans
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dir
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|parent_dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_createname
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|trans
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name_string
parameter_list|,
name|int
name|name_len
parameter_list|,
name|xfs_ino_t
name|inode_number
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_lookup
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name_string
parameter_list|,
name|int
name|name_length
parameter_list|,
name|xfs_ino_t
modifier|*
name|inode_number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_removename
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|trans
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name_string
parameter_list|,
name|int
name|name_length
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_getdents
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_replace
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name_string
parameter_list|,
name|int
name|name_length
parameter_list|,
name|xfs_ino_t
name|inode_number
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_canenter
parameter_list|(
name|struct
name|xfs_trans
modifier|*
name|tp
parameter_list|,
name|struct
name|xfs_inode
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name_string
parameter_list|,
name|int
name|name_length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfs_dir_shortform_validate_ondisk
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|xfs_dirops_t
name|xfsv1_dirops
init|=
block|{
operator|.
name|xd_mount
operator|=
name|xfs_dir_mount
block|,
operator|.
name|xd_isempty
operator|=
name|xfs_dir_isempty
block|,
operator|.
name|xd_init
operator|=
name|xfs_dir_init
block|,
operator|.
name|xd_createname
operator|=
name|xfs_dir_createname
block|,
operator|.
name|xd_lookup
operator|=
name|xfs_dir_lookup
block|,
operator|.
name|xd_removename
operator|=
name|xfs_dir_removename
block|,
operator|.
name|xd_getdents
operator|=
name|xfs_dir_getdents
block|,
operator|.
name|xd_replace
operator|=
name|xfs_dir_replace
block|,
operator|.
name|xd_canenter
operator|=
name|xfs_dir_canenter
block|,
operator|.
name|xd_shortform_validate_ondisk
operator|=
name|xfs_dir_shortform_validate_ondisk
block|,
operator|.
name|xd_shortform_to_single
operator|=
name|xfs_dir_shortform_to_leaf
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal routines when dirsize == XFS_LBSIZE(mp).  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|number_entries
parameter_list|,
name|int
modifier|*
name|total_namebytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
name|xfs_dir_put_t
name|put
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_leaf_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Internal routines when dirsize> XFS_LBSIZE(mp).  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_dir_node_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_node_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_node_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_node_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
name|xfs_dir_put_t
name|put
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_dir_node_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_DIR_TRACE
argument_list|)
end_if

begin_decl_stmt
name|ktrace_t
modifier|*
name|xfs_dir_trace_buf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*========================================================================  * Overall external interface routines.  *========================================================================*/
end_comment

begin_decl_stmt
name|xfs_dahash_t
name|xfs_dir_hash_dot
decl_stmt|,
name|xfs_dir_hash_dotdot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One-time startup routine called from xfs_init().  */
end_comment

begin_function
name|void
name|xfs_dir_startup
parameter_list|(
name|void
parameter_list|)
block|{
name|xfs_dir_hash_dot
operator|=
name|xfs_da_hashname
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfs_dir_hash_dotdot
operator|=
name|xfs_da_hashname
argument_list|(
literal|".."
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize directory-related fields in the mount structure.  */
end_comment

begin_function
specifier|static
name|void
name|xfs_dir_mount
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|uint
name|shortcount
decl_stmt|,
name|leafcount
decl_stmt|,
name|count
decl_stmt|;
name|mp
operator|->
name|m_dirversion
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_ATTR2
operator|)
condition|)
block|{
name|shortcount
operator|=
operator|(
name|mp
operator|->
name|m_attroffset
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
operator|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_entry_t
argument_list|)
expr_stmt|;
name|leafcount
operator|=
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
operator|)
operator|/
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|shortcount
operator|=
operator|(
name|XFS_BMDR_SPACE_CALC
argument_list|(
name|MINABTPTRS
argument_list|)
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_hdr_t
argument_list|)
operator|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_sf_entry_t
argument_list|)
expr_stmt|;
name|leafcount
operator|=
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_hdr_t
argument_list|)
operator|)
operator|/
operator|(
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_entry_t
argument_list|)
operator|+
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_dir_leaf_name_t
argument_list|)
operator|)
expr_stmt|;
block|}
name|count
operator|=
name|shortcount
operator|>
name|leafcount
condition|?
name|shortcount
else|:
name|leafcount
expr_stmt|;
name|mp
operator|->
name|m_dircook_elog
operator|=
name|xfs_da_log2_roundup
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_dircook_elog
operator|<=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dir_node_ents
operator|=
name|mp
operator|->
name|m_attr_node_ents
operator|=
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_hdr_t
argument_list|)
operator|)
operator|/
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_da_node_entry_t
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dir_magicpct
operator|=
operator|(
name|XFS_LBSIZE
argument_list|(
name|mp
argument_list|)
operator|*
literal|37
operator|)
operator|/
literal|100
expr_stmt|;
name|mp
operator|->
name|m_dirblksize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|mp
operator|->
name|m_dirblkfsbs
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if directory contains only "." and "..".  */
end_comment

begin_function
specifier|static
name|int
name|xfs_dir_isempty
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|)
block|{
name|xfs_dir_sf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|>
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hdr
operator|=
operator|(
name|xfs_dir_sf_hdr_t
operator|*
operator|)
name|dp
operator|->
name|i_df
operator|.
name|if_u1
operator|.
name|if_data
expr_stmt|;
return|return
operator|(
name|hdr
operator|->
name|count
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a directory with its "." and ".." entries.  */
end_comment

begin_function
specifier|static
name|int
name|xfs_dir_init
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dir
parameter_list|,
name|xfs_inode_t
modifier|*
name|parent_dir
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dir
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dir
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_dir_ino_validate
argument_list|(
name|trans
operator|->
name|t_mountp
argument_list|,
name|parent_dir
operator|->
name|i_ino
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
return|return
operator|(
name|xfs_dir_shortform_create
argument_list|(
operator|&
name|args
argument_list|,
name|parent_dir
operator|->
name|i_ino
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic handler routine to add a name to a directory.  * Transitions directory from shortform to Btree as necessary.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir_createname
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
name|inum
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|newsize
decl_stmt|,
name|done
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|xfs_dir_ino_validate
argument_list|(
name|trans
operator|->
name|t_mountp
argument_list|,
name|inum
argument_list|)
operator|)
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_create
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|inum
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|newsize
operator|=
name|XFS_DIR_SF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|.
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|+
name|newsize
operator|)
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_shortform_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|total
operator|==
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|retval
operator|=
name|xfs_dir_shortform_to_leaf
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|done
operator|=
name|retval
operator|!=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
operator|&&
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|done
operator|=
name|retval
operator|!=
name|ENOSPC
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|total
operator|==
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|retval
operator|=
name|xfs_dir_leaf_to_node
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|done
operator|=
name|retval
operator|!=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|retval
operator|=
name|xfs_dir_node_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic handler routine to check if a name can be added to a directory,  * without adding any blocks to the directory.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir_canenter
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|newsize
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|newsize
operator|=
name|XFS_DIR_SF_ENTSIZE_BYNAME
argument_list|(
name|args
operator|.
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_size
operator|+
name|newsize
operator|)
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
name|retval
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|xfs_dir_node_addname
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic handler routine to remove a name from a directory.  * Transitions directory from Btree to shortform as necessary.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir_removename
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|count
decl_stmt|,
name|totallen
decl_stmt|,
name|newsize
decl_stmt|,
name|retval
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_remove
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|ino
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|retval
operator|=
name|xfs_dir_shortform_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_removename
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|totallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|newsize
operator|=
name|XFS_DIR_SF_ALLFIT
argument_list|(
name|count
argument_list|,
name|totallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|<=
name|XFS_IFORK_DSIZE
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_to_shortform
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|retval
operator|=
name|xfs_dir_node_removename
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir_lookup
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
modifier|*
name|inum
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_lookup
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|total
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
literal|0
expr_stmt|;
name|args
operator|.
name|oknoent
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|retval
operator|=
name|xfs_dir_shortform_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|xfs_dir_node_lookup
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
operator|*
name|inum
operator|=
name|args
operator|.
name|inumber
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement readdir.  */
end_comment

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|)
block|{
name|xfs_dirent_t
modifier|*
name|dbp
decl_stmt|;
name|int
name|alignment
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dir_put_t
name|put
decl_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_dir_getdents
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
comment|/* 	 * If our caller has given us a single contiguous memory buffer, 	 * just work directly within that buffer.  If it's in user memory, 	 * lock it down first. 	 */
name|alignment
operator|=
sizeof|sizeof
argument_list|(
name|xfs_off_t
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
operator|(
name|__psint_t
operator|)
name|uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|&
name|alignment
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|uio
operator|->
name|uio_iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|&
name|alignment
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dbp
operator|=
name|NULL
expr_stmt|;
name|put
operator|=
name|xfs_dir_put_dirent64_direct
expr_stmt|;
block|}
else|else
block|{
name|dbp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dbp
argument_list|)
operator|+
name|MAXNAMELEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|put
operator|=
name|xfs_dir_put_dirent64_uio
expr_stmt|;
block|}
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|retval
operator|=
name|xfs_dir_shortform_getdents
argument_list|(
name|dp
argument_list|,
name|uio
argument_list|,
name|eofp
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_getdents
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|eofp
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|xfs_dir_node_getdents
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|eofp
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|dbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbp
argument_list|)
operator|+
name|MAXNAMELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
comment|/* error */
name|xfs_dir_replace
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|xfs_ino_t
name|inum
parameter_list|,
name|xfs_fsblock_t
modifier|*
name|firstblock
parameter_list|,
name|xfs_bmap_free_t
modifier|*
name|flist
parameter_list|,
name|xfs_extlen_t
name|total
parameter_list|)
block|{
name|xfs_da_args_t
name|args
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dp
operator|->
name|i_d
operator|.
name|di_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|xfs_dir_ino_validate
argument_list|(
name|trans
operator|->
name|t_mountp
argument_list|,
name|inum
argument_list|)
operator|)
condition|)
return|return
name|retval
return|;
comment|/* 	 * Fill in the arg structure for this request. 	 */
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|namelen
operator|=
name|namelen
expr_stmt|;
name|args
operator|.
name|hashval
operator|=
name|xfs_da_hashname
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|args
operator|.
name|inumber
operator|=
name|inum
expr_stmt|;
name|args
operator|.
name|dp
operator|=
name|dp
expr_stmt|;
name|args
operator|.
name|firstblock
operator|=
name|firstblock
expr_stmt|;
name|args
operator|.
name|flist
operator|=
name|flist
expr_stmt|;
name|args
operator|.
name|total
operator|=
name|total
expr_stmt|;
name|args
operator|.
name|whichfork
operator|=
name|XFS_DATA_FORK
expr_stmt|;
name|args
operator|.
name|trans
operator|=
name|trans
expr_stmt|;
name|args
operator|.
name|justcheck
operator|=
name|args
operator|.
name|addname
operator|=
name|args
operator|.
name|oknoent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decide on what work routines to call based on the inode size. 	 */
if|if
condition|(
name|dp
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|retval
operator|=
name|xfs_dir_shortform_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfs_bmap_one_block
argument_list|(
name|dp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
condition|)
block|{
name|retval
operator|=
name|xfs_dir_leaf_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|xfs_dir_node_replace
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfs_dir_shortform_validate_ondisk
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_dinode_t
modifier|*
name|dp
parameter_list|)
block|{
name|xfs_ino_t
name|ino
decl_stmt|;
name|int
name|namelen_sum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|xfs_dir_shortform_t
modifier|*
name|sf
decl_stmt|;
name|xfs_dir_sf_entry_t
modifier|*
name|sfe
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|INT_GET
argument_list|(
name|dp
operator|->
name|di_core
operator|.
name|di_mode
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|INT_GET
argument_list|(
name|dp
operator|->
name|di_core
operator|.
name|di_format
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|INT_GET
argument_list|(
name|dp
operator|->
name|di_core
operator|.
name|di_size
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|sf
operator|->
name|hdr
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"Invalid shortform size: dp 0x%p"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sf
operator|=
operator|(
name|xfs_dir_shortform_t
operator|*
operator|)
operator|(
operator|&
name|dp
operator|->
name|di_u
operator|.
name|di_dirsf
operator|)
expr_stmt|;
name|ino
operator|=
name|XFS_GET_DIR_INO8
argument_list|(
name|sf
operator|->
name|hdr
operator|.
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_dir_ino_validate
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
condition|)
return|return
literal|1
return|;
name|count
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|count
operator|*
literal|10
operator|)
operator|>
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"Invalid shortform count: dp 0x%p"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|namelen_sum
operator|=
literal|0
expr_stmt|;
name|sfe
operator|=
operator|&
name|sf
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sf
operator|->
name|hdr
operator|.
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ino
operator|=
name|XFS_GET_DIR_INO8
argument_list|(
name|sfe
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|xfs_dir_ino_validate
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfe
operator|->
name|namelen
operator|>=
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"Invalid shortform namelen: dp 0x%p"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|namelen_sum
operator|+=
name|sfe
operator|->
name|namelen
expr_stmt|;
name|sfe
operator|=
name|XFS_DIR_SF_NEXTENTRY
argument_list|(
name|sfe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namelen_sum
operator|>=
name|XFS_LITINO
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|xfs_fs_cmn_err
argument_list|(
name|CE_WARN
argument_list|,
name|mp
argument_list|,
literal|"Invalid shortform namelen: dp 0x%p"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * External routines when dirsize == XFS_LBSIZE(dp->i_mount).  *========================================================================*/
end_comment

begin_comment
comment|/*  * Add a name to the leaf directory structure  * This is the external routine.  */
end_comment

begin_function
name|int
name|xfs_dir_leaf_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|ENOENT
condition|)
name|retval
operator|=
name|xfs_dir_leaf_add
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from the leaf directory structure  * This is the external routine.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|int
modifier|*
name|totallen
parameter_list|)
block|{
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|int
name|index
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
operator|(
name|void
operator|)
name|xfs_dir_leaf_remove
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
operator|*
name|totallen
operator|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|namebytes
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a leaf directory structure.  * This is the external routine.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy out directory entries for getdents(), for leaf directories.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
name|xfs_dir_put_t
name|put
parameter_list|)
block|{
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|eob
decl_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|dp
operator|->
name|i_transp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_getdents_int
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
name|uio
argument_list|,
operator|&
name|eob
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|eofp
operator|=
operator|(
name|eob
operator|==
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in a leaf directory structure, replace the inode number.  * This is the external routine.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_leaf_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|retval
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_ino_t
name|inum
decl_stmt|;
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|inum
operator|=
name|args
operator|->
name|inumber
expr_stmt|;
name|retval
operator|=
name|xfs_da_read_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|args
operator|->
name|dp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_lookup_int
argument_list|(
name|bp
argument_list|,
name|args
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX - replace assert? */
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|inum
argument_list|,
operator|&
name|namest
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|namest
argument_list|,
sizeof|sizeof
argument_list|(
name|namest
operator|->
name|inumber
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================  * External routines when dirsize> XFS_LBSIZE(mp).  *========================================================================*/
end_comment

begin_comment
comment|/*  * Add a name to a Btree-format directory.  *  * This will involve walking down the Btree, and may involve splitting  * leaf nodes and even splitting intermediate nodes up to and including  * the root node (a special case of an intermediate node).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_node_addname
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Fill in bucket of arguments/results/context to carry around. 	 */
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
comment|/* 	 * Search to see if name already exists, and get back a pointer 	 * to where it should go. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|retval
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|ENOENT
condition|)
goto|goto
name|error
goto|;
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_add
argument_list|(
name|blk
operator|->
name|bp
argument_list|,
name|args
argument_list|,
name|blk
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Addition succeeded, update Btree hashvals. 		 */
if|if
condition|(
operator|!
name|args
operator|->
name|justcheck
condition|)
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Addition failed, split as many Btree elements as required. 		 */
if|if
condition|(
name|args
operator|->
name|total
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|retval
operator|==
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|retval
operator|=
name|xfs_da_split
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from a B-tree directory.  *  * This will involve walking down the Btree, and may involve joining  * leaf nodes and even joining intermediate nodes up to and including  * the root node (a special case of an intermediate node).  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_node_removename
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|error
decl_stmt|;
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
comment|/* 	 * Search to see if name exists, and get back a pointer to it. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|retval
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|EEXIST
condition|)
block|{
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * Remove the name and update the hashvals in the tree. 	 */
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xfs_dir_leaf_remove
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|blk
operator|->
name|bp
argument_list|,
name|blk
operator|->
name|index
argument_list|)
expr_stmt|;
name|xfs_da_fixhashpath
argument_list|(
name|state
argument_list|,
operator|&
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if the tree needs to be collapsed. 	 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|error
operator|=
name|xfs_da_join
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a filename in a int directory.  * Use an internal routine to actually do all the work.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_node_lookup
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
comment|/* 	 * Search to see if name exists, 	 * and get back a pointer to it. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|retval
operator|=
name|error
expr_stmt|;
block|}
comment|/* 	 * If not in a transaction, we have to release all the buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|path
operator|.
name|active
condition|;
name|i
operator|++
control|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_dir_node_getdents
parameter_list|(
name|xfs_trans_t
modifier|*
name|trans
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|xfs_dirent_t
modifier|*
name|dbp
parameter_list|,
name|xfs_dir_put_t
name|put
parameter_list|)
block|{
name|xfs_da_intnode_t
modifier|*
name|node
decl_stmt|;
name|xfs_da_node_entry_t
modifier|*
name|btree
decl_stmt|;
name|xfs_dir_leafblock_t
modifier|*
name|leaf
init|=
name|NULL
decl_stmt|;
name|xfs_dablk_t
name|bno
decl_stmt|,
name|nextbno
decl_stmt|;
name|xfs_dahash_t
name|cookhash
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|eob
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_daddr_t
name|nextda
decl_stmt|;
comment|/* 	 * Pick up our context. 	 */
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|bno
operator|=
name|XFS_DA_COOKIE_BNO
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|cookhash
operator|=
name|XFS_DA_COOKIE_HASH
argument_list|(
name|mp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"node: start"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 	 * Re-find our place, even if we're confused about what our place is. 	 * 	 * First we check the block number from the magic cookie, it is a 	 * cache of where we ended last time.  If we find a leaf block, and 	 * the starting hashval in that block is less than our desired 	 * hashval, then we run with it. 	 */
if|if
condition|(
name|bno
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
operator|-
literal|2
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|!=
name|EFSCORRUPTED
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bp
condition|)
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|bp
operator|&&
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_DIR_LEAF_MAGIC
condition|)
block|{
name|xfs_dir_trace_g_dub
argument_list|(
literal|"node: block not a leaf"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|&&
name|INT_GET
argument_list|(
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|>
name|cookhash
condition|)
block|{
name|xfs_dir_trace_g_dub
argument_list|(
literal|"node: leaf hash too large"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|&&
name|cookhash
operator|>
name|INT_GET
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
name|xfs_dir_trace_g_dub
argument_list|(
literal|"node: leaf hash too small"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * If we did not find a leaf block from the blockno in the cookie, 	 * or we there was no blockno in the cookie (eg: first time thru), 	 * the we start at the top of the Btree and re-find our hashval. 	 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|xfs_dir_trace_g_du
argument_list|(
literal|"node: start at root"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|bno
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
name|node
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_DA_NODE_MAGIC
condition|)
break|break;
name|btree
operator|=
operator|&
name|node
operator|->
name|btree
index|[
literal|0
index|]
expr_stmt|;
name|xfs_dir_trace_g_dun
argument_list|(
literal|"node: node detail"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|;
name|btree
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|btree
operator|->
name|hashval
argument_list|)
operator|>=
name|cookhash
condition|)
block|{
name|bno
operator|=
name|be32_to_cpu
argument_list|(
name|btree
operator|->
name|before
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
condition|)
block|{
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"node: hash beyond EOF"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|XFS_DA_MAKE_COOKIE
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XFS_DA_MAXHASH
argument_list|)
expr_stmt|;
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xfs_dir_trace_g_dub
argument_list|(
literal|"node: going to block"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|cookhash
operator|!=
name|XFS_DA_MAXHASH
argument_list|)
expr_stmt|;
comment|/* 	 * We've dropped down to the (first) leaf block that contains the 	 * hashval we are interested in.  Continue rolling upward thru the 	 * leaf blocks until we fill up our buffer. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|be16_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|magic
argument_list|)
operator|!=
name|XFS_DIR_LEAF_MAGIC
argument_list|)
condition|)
block|{
name|xfs_dir_trace_g_dul
argument_list|(
literal|"node: not a leaf"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|XFS_CORRUPTION_ERROR
argument_list|(
literal|"xfs_dir_node_getdents(1)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
name|xfs_dir_trace_g_dul
argument_list|(
literal|"node: leaf detail"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextbno
operator|=
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|)
operator|)
condition|)
block|{
name|nextda
operator|=
name|xfs_da_reada_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|nextbno
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
block|}
else|else
name|nextda
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|xfs_dir_leaf_getdents_int
argument_list|(
name|bp
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
name|uio
argument_list|,
operator|&
name|eob
argument_list|,
name|dbp
argument_list|,
name|put
argument_list|,
name|nextda
argument_list|)
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|trans
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bno
operator|=
name|nextbno
expr_stmt|;
if|if
condition|(
name|eob
condition|)
block|{
name|xfs_dir_trace_g_dub
argument_list|(
literal|"node: E-O-B"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|,
name|bno
argument_list|)
expr_stmt|;
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bno
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|xfs_da_read_buf
argument_list|(
name|trans
argument_list|,
name|dp
argument_list|,
name|bno
argument_list|,
name|nextda
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|unlikely
argument_list|(
name|bp
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_dir_node_getdents(2)"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
operator|)
return|;
block|}
block|}
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
name|xfs_dir_trace_g_du
argument_list|(
literal|"node: E-O-F"
argument_list|,
name|dp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a filename in an int directory, replace the inode number.  * Use an internal routine to actually do the lookup.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_dir_node_replace
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|)
block|{
name|xfs_da_state_t
modifier|*
name|state
decl_stmt|;
name|xfs_da_state_blk_t
modifier|*
name|blk
decl_stmt|;
name|xfs_dir_leafblock_t
modifier|*
name|leaf
decl_stmt|;
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
decl_stmt|;
name|xfs_dir_leaf_name_t
modifier|*
name|namest
decl_stmt|;
name|xfs_ino_t
name|inum
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
name|state
operator|=
name|xfs_da_state_alloc
argument_list|()
expr_stmt|;
name|state
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|state
operator|->
name|mp
operator|=
name|args
operator|->
name|dp
operator|->
name|i_mount
expr_stmt|;
name|state
operator|->
name|blocksize
operator|=
name|state
operator|->
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|state
operator|->
name|node_ents
operator|=
name|state
operator|->
name|mp
operator|->
name|m_dir_node_ents
expr_stmt|;
name|inum
operator|=
name|args
operator|->
name|inumber
expr_stmt|;
comment|/* 	 * Search to see if name exists, 	 * and get back a pointer to it. 	 */
name|error
operator|=
name|xfs_da_node_lookup_int
argument_list|(
name|state
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|retval
operator|=
name|error
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
name|EEXIST
condition|)
block|{
name|blk
operator|=
operator|&
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|blk
operator|->
name|magic
operator|==
name|XFS_DIR_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|bp
operator|=
name|blk
operator|->
name|bp
expr_stmt|;
name|leaf
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|entry
operator|=
operator|&
name|leaf
operator|->
name|entries
index|[
name|blk
operator|->
name|index
index|]
expr_stmt|;
name|namest
operator|=
name|XFS_DIR_LEAF_NAMESTRUCT
argument_list|(
name|leaf
argument_list|,
name|INT_GET
argument_list|(
name|entry
operator|->
name|nameidx
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX - replace assert ? */
name|XFS_DIR_SF_PUT_DIRINO
argument_list|(
operator|&
name|inum
argument_list|,
operator|&
name|namest
operator|->
name|inumber
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|bp
argument_list|,
name|XFS_DA_LOGRANGE
argument_list|(
name|leaf
argument_list|,
name|namest
argument_list|,
sizeof|sizeof
argument_list|(
name|namest
operator|->
name|inumber
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_da_buf_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|blk
operator|->
name|bp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
expr_stmt|;
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|path
operator|.
name|active
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|xfs_da_brelse
argument_list|(
name|args
operator|->
name|trans
argument_list|,
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
argument_list|)
expr_stmt|;
name|state
operator|->
name|path
operator|.
name|blk
index|[
name|i
index|]
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
name|xfs_da_state_free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XFS_DIR_TRACE
argument_list|)
end_if

begin_comment
comment|/*  * Add a trace buffer entry for an inode and a uio.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_g_du
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|)
block|{
name|xfs_dir_trace_enter
argument_list|(
name|XFS_DIR_KTRACE_G_DU
argument_list|,
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
operator|->
name|i_mount
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for an inode and a uio.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_g_dub
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|xfs_dablk_t
name|bno
parameter_list|)
block|{
name|xfs_dir_trace_enter
argument_list|(
name|XFS_DIR_KTRACE_G_DUB
argument_list|,
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
operator|->
name|i_mount
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|bno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for an inode and a uio.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_g_dun
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|xfs_da_intnode_t
modifier|*
name|node
parameter_list|)
block|{
name|int
name|last
init|=
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
operator|-
literal|1
decl_stmt|;
name|xfs_dir_trace_enter
argument_list|(
name|XFS_DIR_KTRACE_G_DUN
argument_list|,
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
operator|->
name|i_mount
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|be16_to_cpu
argument_list|(
name|node
operator|->
name|hdr
operator|.
name|count
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|btree
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|be32_to_cpu
argument_list|(
name|node
operator|->
name|btree
index|[
name|last
index|]
operator|.
name|hashval
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for an inode and a uio.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_g_dul
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|xfs_dir_leafblock_t
modifier|*
name|leaf
parameter_list|)
block|{
name|int
name|last
init|=
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|-
literal|1
decl_stmt|;
name|xfs_dir_trace_enter
argument_list|(
name|XFS_DIR_KTRACE_G_DUL
argument_list|,
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
operator|->
name|i_mount
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|be32_to_cpu
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|info
operator|.
name|forw
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|INT_GET
argument_list|(
name|leaf
operator|->
name|hdr
operator|.
name|count
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|INT_GET
argument_list|(
name|leaf
operator|->
name|entries
index|[
literal|0
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|INT_GET
argument_list|(
name|leaf
operator|->
name|entries
index|[
name|last
index|]
operator|.
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for an inode and a uio.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_g_due
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|xfs_dir_leaf_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|xfs_dir_trace_enter
argument_list|(
name|XFS_DIR_KTRACE_G_DUE
argument_list|,
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
operator|->
name|i_mount
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|INT_GET
argument_list|(
name|entry
operator|->
name|hashval
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for an inode and a uio.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_g_duc
parameter_list|(
name|char
modifier|*
name|where
parameter_list|,
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|xfs_off_t
name|cookie
parameter_list|)
block|{
name|xfs_dir_trace_enter
argument_list|(
name|XFS_DIR_KTRACE_G_DUC
argument_list|,
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dp
operator|->
name|i_mount
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|uio
operator|->
name|uio_offset
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|cookie
operator|>>
literal|32
argument_list|)
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|cookie
operator|&
literal|0xFFFFFFFF
argument_list|)
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a trace buffer entry for the arguments given to the routine,  * generic form.  */
end_comment

begin_function
name|void
name|xfs_dir_trace_enter
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|where
parameter_list|,
name|void
modifier|*
name|a0
parameter_list|,
name|void
modifier|*
name|a1
parameter_list|,
name|void
modifier|*
name|a2
parameter_list|,
name|void
modifier|*
name|a3
parameter_list|,
name|void
modifier|*
name|a4
parameter_list|,
name|void
modifier|*
name|a5
parameter_list|,
name|void
modifier|*
name|a6
parameter_list|,
name|void
modifier|*
name|a7
parameter_list|,
name|void
modifier|*
name|a8
parameter_list|,
name|void
modifier|*
name|a9
parameter_list|,
name|void
modifier|*
name|a10
parameter_list|,
name|void
modifier|*
name|a11
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|xfs_dir_trace_buf
argument_list|)
expr_stmt|;
name|ktrace_enter
argument_list|(
name|xfs_dir_trace_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|type
argument_list|,
operator|(
name|void
operator|*
operator|)
name|where
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a2
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a3
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a4
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a5
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a6
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a7
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a8
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a9
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a10
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a11
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XFS_DIR_TRACE */
end_comment

end_unit

