begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dfrag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mac.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/*  * Syssgi interface for swapext  */
end_comment

begin_function
name|int
name|xfs_swapext
parameter_list|(
name|xfs_swapext_t
modifier|*
name|sxp
parameter_list|)
block|{
name|xfs_swapext_t
name|sx
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
init|=
name|NULL
decl_stmt|,
modifier|*
name|tip
init|=
name|NULL
decl_stmt|,
modifier|*
name|ips
index|[
literal|2
index|]
decl_stmt|;
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_bstat_t
modifier|*
name|sbp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|,
modifier|*
name|tvp
init|=
name|NULL
decl_stmt|;
name|struct
name|vnode
modifier|*
name|bvp
decl_stmt|,
modifier|*
name|btvp
decl_stmt|;
name|bhv_desc_t
modifier|*
name|bdp
decl_stmt|,
modifier|*
name|tbdp
decl_stmt|;
name|vn_bhv_head_t
modifier|*
name|bhp
decl_stmt|,
modifier|*
name|tbhp
decl_stmt|;
name|uint
name|lock_flags
init|=
literal|0
decl_stmt|;
name|int
name|ilf_fields
decl_stmt|,
name|tilf_fields
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|xfs_ifork_t
name|tempif
decl_stmt|,
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|tifp
decl_stmt|;
name|__uint64_t
name|tmp
decl_stmt|;
name|int
name|aforkblks
init|=
literal|0
decl_stmt|;
name|int
name|taforkblks
init|=
literal|0
decl_stmt|;
name|int
name|locked
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|cred
modifier|*
name|cred
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|sx
argument_list|,
name|sxp
argument_list|,
sizeof|sizeof
argument_list|(
name|sx
argument_list|)
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* Pull information for the target fd */
if|if
condition|(
name|fgetvp
argument_list|(
name|td
argument_list|,
operator|(
name|int
operator|)
name|sx
operator|.
name|sx_fdtarget
argument_list|,
operator|&
name|bvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|vp
operator|=
name|VPTOXFSVP
argument_list|(
name|bvp
argument_list|)
expr_stmt|;
name|bhp
operator|=
name|VN_BHV_HEAD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|bdp
operator|=
name|vn_bhv_lookup
argument_list|(
name|bhp
argument_list|,
operator|&
name|xfs_vnodeops
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
else|else
block|{
name|ip
operator|=
name|XFS_BHVTOI
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgetvp
argument_list|(
name|td
argument_list|,
operator|(
name|int
operator|)
name|sx
operator|.
name|sx_fdtmp
argument_list|,
operator|&
name|btvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|tvp
operator|=
name|VPTOXFSVP
argument_list|(
name|btvp
argument_list|)
expr_stmt|;
name|tbhp
operator|=
name|VN_BHV_HEAD
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|tbdp
operator|=
name|vn_bhv_lookup
argument_list|(
name|tbhp
argument_list|,
operator|&
name|xfs_vnodeops
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbdp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
else|else
block|{
name|tip
operator|=
name|XFS_BHVTOI
argument_list|(
name|tbdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|==
name|tip
operator|->
name|i_ino
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|mp
operator|=
name|ip
operator|->
name|i_mount
expr_stmt|;
name|sbp
operator|=
operator|&
name|sx
operator|.
name|sx_stat
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|locked
operator|=
literal|1
expr_stmt|;
comment|/* Lock in i_ino order */
if|if
condition|(
name|ip
operator|->
name|i_ino
operator|<
name|tip
operator|->
name|i_ino
condition|)
block|{
name|ips
index|[
literal|0
index|]
operator|=
name|ip
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|tip
expr_stmt|;
block|}
else|else
block|{
name|ips
index|[
literal|0
index|]
operator|=
name|tip
expr_stmt|;
name|ips
index|[
literal|1
index|]
operator|=
name|ip
expr_stmt|;
block|}
name|lock_flags
operator|=
name|XFS_ILOCK_EXCL
operator||
name|XFS_IOLOCK_EXCL
expr_stmt|;
name|xfs_lock_inodes
argument_list|(
name|ips
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
comment|/* Check permissions */
if|if
condition|(
operator|(
name|error
operator|=
name|_MAC_XFS_IACCESS
argument_list|(
name|ip
argument_list|,
name|MACWRITE
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|_MAC_XFS_IACCESS
argument_list|(
name|tip
argument_list|,
name|MACWRITE
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
operator|(
name|current_fsuid
argument_list|(
name|cred
argument_list|)
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_uid
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iaccess
argument_list|(
name|ip
argument_list|,
name|S_IWUSR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|&&
operator|!
name|capable_cred
argument_list|(
name|NULL
argument_list|,
name|CAP_FOWNER
argument_list|)
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
operator|(
name|current_fsuid
argument_list|(
name|cred
argument_list|)
operator|!=
name|tip
operator|->
name|i_d
operator|.
name|di_uid
operator|)
operator|&&
operator|(
name|error
operator|=
name|xfs_iaccess
argument_list|(
name|tip
argument_list|,
name|S_IWUSR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|&&
operator|!
name|capable_cred
argument_list|(
name|NULL
argument_list|,
name|CAP_FOWNER
argument_list|)
condition|)
block|{
goto|goto
name|error0
goto|;
block|}
comment|/* Verify both files are either real-time or non-realtime */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
operator|!=
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_REALTIME
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* Should never get a local format */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
operator|||
name|tip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_LOCAL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
if|if
condition|(
name|VN_CACHED
argument_list|(
name|tvp
argument_list|)
operator|!=
literal|0
condition|)
name|xfs_inval_cached_pages
argument_list|(
name|XFS_ITOV
argument_list|(
name|tip
argument_list|)
argument_list|,
operator|&
operator|(
name|tip
operator|->
name|i_iocore
operator|)
argument_list|,
operator|(
name|loff_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Verify O_DIRECT for ftmp */
if|if
condition|(
name|VN_CACHED
argument_list|(
name|tvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* Verify all data are being swapped */
if|if
condition|(
name|sx
operator|.
name|sx_offset
operator|!=
literal|0
operator|||
name|sx
operator|.
name|sx_length
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_size
operator|||
name|sx
operator|.
name|sx_length
operator|!=
name|tip
operator|->
name|i_d
operator|.
name|di_size
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * If the target has extended attributes, the tmp file 	 * must also in order to ensure the correct data fork 	 * format. 	 */
if|if
condition|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|!=
name|XFS_IFORK_Q
argument_list|(
name|tip
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* 	 * Compare the current change& modify times with that 	 * passed in.  If they differ, we abort this swap. 	 * This is the mechanism used to ensure the calling 	 * process that the file was not changed out from 	 * under it. 	 */
if|if
condition|(
operator|(
name|sbp
operator|->
name|bs_ctime
operator|.
name|tv_sec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_sec
operator|)
operator|||
operator|(
name|sbp
operator|->
name|bs_ctime
operator|.
name|tv_nsec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_ctime
operator|.
name|t_nsec
operator|)
operator|||
operator|(
name|sbp
operator|->
name|bs_mtime
operator|.
name|tv_sec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_sec
operator|)
operator|||
operator|(
name|sbp
operator|->
name|bs_mtime
operator|.
name|tv_nsec
operator|!=
name|ip
operator|->
name|i_d
operator|.
name|di_mtime
operator|.
name|t_nsec
operator|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
comment|/* We need to fail if the file is memory mapped.  Once we have tossed 	 * all existing pages, the page fault will have no option 	 * but to go to the filesystem for pages. By making the page fault call 	 * VOP_READ (or write in the case of autogrow) they block on the iolock 	 * until we have switched the extents. 	 */
if|if
condition|(
name|VN_MAPPED
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|error0
goto|;
block|}
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * There is a race condition here since we gave up the 	 * ilock.  However, the data fork will not change since 	 * we have the iolock (locked for truncation too) so we 	 * are safe.  We don't really care if non-io related 	 * fields change. 	 */
name|XVOP_TOSS_PAGES
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF
argument_list|)
expr_stmt|;
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_SWAPEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ICHANGE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|XFS_IOLOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|xfs_lock_inodes
argument_list|(
name|ips
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Count the number of extended attribute blocks 	 */
if|if
condition|(
operator|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|ip
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_bmap_count_blocks
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
operator|&
name|aforkblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|XFS_IFORK_Q
argument_list|(
name|tip
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_anextents
operator|>
literal|0
operator|)
operator|)
operator|&&
operator|(
name|tip
operator|->
name|i_d
operator|.
name|di_aformat
operator|!=
name|XFS_DINODE_FMT_LOCAL
operator|)
condition|)
block|{
name|error
operator|=
name|xfs_bmap_count_blocks
argument_list|(
name|tp
argument_list|,
name|tip
argument_list|,
name|XFS_ATTR_FORK
argument_list|,
operator|&
name|taforkblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Swap the data forks of the inodes 	 */
name|ifp
operator|=
operator|&
name|ip
operator|->
name|i_df
expr_stmt|;
name|tifp
operator|=
operator|&
name|tip
operator|->
name|i_df
expr_stmt|;
name|tempif
operator|=
operator|*
name|ifp
expr_stmt|;
comment|/* struct copy */
operator|*
name|ifp
operator|=
operator|*
name|tifp
expr_stmt|;
comment|/* struct copy */
operator|*
name|tifp
operator|=
name|tempif
expr_stmt|;
comment|/* struct copy */
comment|/* 	 * Fix the on-disk inode values 	 */
name|tmp
operator|=
operator|(
name|__uint64_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|=
name|tip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|-
name|taforkblks
operator|+
name|aforkblks
expr_stmt|;
name|tip
operator|->
name|i_d
operator|.
name|di_nblocks
operator|=
name|tmp
operator|+
name|taforkblks
operator|-
name|aforkblks
expr_stmt|;
name|tmp
operator|=
operator|(
name|__uint64_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|=
name|tip
operator|->
name|i_d
operator|.
name|di_nextents
expr_stmt|;
name|tip
operator|->
name|i_d
operator|.
name|di_nextents
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
operator|(
name|__uint64_t
operator|)
name|ip
operator|->
name|i_d
operator|.
name|di_format
expr_stmt|;
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|tip
operator|->
name|i_d
operator|.
name|di_format
expr_stmt|;
name|tip
operator|->
name|i_d
operator|.
name|di_format
operator|=
name|tmp
expr_stmt|;
name|ilf_fields
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
comment|/* If the extents fit in the inode, fix the 		 * pointer.  Otherwise it's already NULL or 		 * pointing to the extent. 		 */
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_nextents
operator|<=
name|XFS_INLINE_EXTS
condition|)
block|{
name|ifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|ifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
expr_stmt|;
block|}
name|ilf_fields
operator||=
name|XFS_ILOG_DEXT
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|ilf_fields
operator||=
name|XFS_ILOG_DBROOT
expr_stmt|;
break|break;
block|}
name|tilf_fields
operator|=
name|XFS_ILOG_CORE
expr_stmt|;
switch|switch
condition|(
name|tip
operator|->
name|i_d
operator|.
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
comment|/* If the extents fit in the inode, fix the 		 * pointer.  Otherwise it's already NULL or 		 * pointing to the extent. 		 */
if|if
condition|(
name|tip
operator|->
name|i_d
operator|.
name|di_nextents
operator|<=
name|XFS_INLINE_EXTS
condition|)
block|{
name|tifp
operator|->
name|if_u1
operator|.
name|if_extents
operator|=
name|tifp
operator|->
name|if_u2
operator|.
name|if_inline_ext
expr_stmt|;
block|}
name|tilf_fields
operator||=
name|XFS_ILOG_DEXT
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|tilf_fields
operator||=
name|XFS_ILOG_DBROOT
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|XXXKAN
comment|/* Not necessary, vnodes are vrefed already by fgetvp */
comment|/* 	 * Increment vnode ref counts since xfs_trans_commit& 	 * xfs_trans_cancel will both unlock the inodes and 	 * decrement the associated ref counts. 	 */
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|tip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|ilf_fields
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|tip
argument_list|,
name|tilf_fields
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a synchronous mount, make sure that the 	 * transaction goes to disk before returning to the user. 	 */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_WSYNC
condition|)
block|{
name|xfs_trans_set_sync
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SWAPEXT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|error0
label|:
if|if
condition|(
name|locked
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|tip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

